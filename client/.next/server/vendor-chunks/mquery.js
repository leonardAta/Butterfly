/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/mquery";
exports.ids = ["vendor-chunks/mquery"];
exports.modules = {

/***/ "../server/node_modules/mquery/lib/collection/collection.js":
/*!******************************************************************!*\
  !*** ../server/node_modules/mquery/lib/collection/collection.js ***!
  \******************************************************************/
/***/ ((module, exports) => {

"use strict";
eval("\n\n/**\n * methods a collection must implement\n */\n\nconst methods = [\n  'find',\n  'findOne',\n  'updateMany',\n  'updateOne',\n  'replaceOne',\n  'count',\n  'distinct',\n  'findOneAndDelete',\n  'findOneAndUpdate',\n  'aggregate',\n  'findCursor',\n  'deleteOne',\n  'deleteMany'\n];\n\n/**\n * Collection base class from which implementations inherit\n */\n\nfunction Collection() {}\n\nfor (let i = 0, len = methods.length; i < len; ++i) {\n  const method = methods[i];\n  Collection.prototype[method] = notImplemented(method);\n}\n\nmodule.exports = exports = Collection;\nCollection.methods = methods;\n\n/**\n * creates a function which throws an implementation error\n */\n\nfunction notImplemented(method) {\n  return function() {\n    throw new Error('collection.' + method + ' not implemented');\n  };\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tcXVlcnkvbGliL2NvbGxlY3Rpb24vY29sbGVjdGlvbi5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxzQ0FBc0MsU0FBUztBQUMvQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2NsaWVudC8uLi9zZXJ2ZXIvbm9kZV9tb2R1bGVzL21xdWVyeS9saWIvY29sbGVjdGlvbi9jb2xsZWN0aW9uLmpzPzlkNjIiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIG1ldGhvZHMgYSBjb2xsZWN0aW9uIG11c3QgaW1wbGVtZW50XG4gKi9cblxuY29uc3QgbWV0aG9kcyA9IFtcbiAgJ2ZpbmQnLFxuICAnZmluZE9uZScsXG4gICd1cGRhdGVNYW55JyxcbiAgJ3VwZGF0ZU9uZScsXG4gICdyZXBsYWNlT25lJyxcbiAgJ2NvdW50JyxcbiAgJ2Rpc3RpbmN0JyxcbiAgJ2ZpbmRPbmVBbmREZWxldGUnLFxuICAnZmluZE9uZUFuZFVwZGF0ZScsXG4gICdhZ2dyZWdhdGUnLFxuICAnZmluZEN1cnNvcicsXG4gICdkZWxldGVPbmUnLFxuICAnZGVsZXRlTWFueSdcbl07XG5cbi8qKlxuICogQ29sbGVjdGlvbiBiYXNlIGNsYXNzIGZyb20gd2hpY2ggaW1wbGVtZW50YXRpb25zIGluaGVyaXRcbiAqL1xuXG5mdW5jdGlvbiBDb2xsZWN0aW9uKCkge31cblxuZm9yIChsZXQgaSA9IDAsIGxlbiA9IG1ldGhvZHMubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgY29uc3QgbWV0aG9kID0gbWV0aG9kc1tpXTtcbiAgQ29sbGVjdGlvbi5wcm90b3R5cGVbbWV0aG9kXSA9IG5vdEltcGxlbWVudGVkKG1ldGhvZCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IENvbGxlY3Rpb247XG5Db2xsZWN0aW9uLm1ldGhvZHMgPSBtZXRob2RzO1xuXG4vKipcbiAqIGNyZWF0ZXMgYSBmdW5jdGlvbiB3aGljaCB0aHJvd3MgYW4gaW1wbGVtZW50YXRpb24gZXJyb3JcbiAqL1xuXG5mdW5jdGlvbiBub3RJbXBsZW1lbnRlZChtZXRob2QpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignY29sbGVjdGlvbi4nICsgbWV0aG9kICsgJyBub3QgaW1wbGVtZW50ZWQnKTtcbiAgfTtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../server/node_modules/mquery/lib/collection/collection.js\n");

/***/ }),

/***/ "../server/node_modules/mquery/lib/collection/index.js":
/*!*************************************************************!*\
  !*** ../server/node_modules/mquery/lib/collection/index.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst env = __webpack_require__(/*! ../env */ \"../server/node_modules/mquery/lib/env.js\");\n\nif ('unknown' == env.type) {\n  throw new Error('Unknown environment');\n}\n\nmodule.exports =\n  env.isNode ? __webpack_require__(/*! ./node */ \"../server/node_modules/mquery/lib/collection/node.js\") :\n    env.isMongo ? __webpack_require__(/*! ./collection */ \"../server/node_modules/mquery/lib/collection/collection.js\") :\n      __webpack_require__(/*! ./collection */ \"../server/node_modules/mquery/lib/collection/collection.js\");\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tcXVlcnkvbGliL2NvbGxlY3Rpb24vaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsWUFBWSxtQkFBTyxDQUFDLHdEQUFROztBQUU1QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLG1CQUFPLENBQUMsb0VBQVE7QUFDL0Isa0JBQWtCLG1CQUFPLENBQUMsZ0ZBQWM7QUFDeEMsTUFBTSxtQkFBTyxDQUFDLGdGQUFjIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2xpZW50Ly4uL3NlcnZlci9ub2RlX21vZHVsZXMvbXF1ZXJ5L2xpYi9jb2xsZWN0aW9uL2luZGV4LmpzPzMwMTEiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBlbnYgPSByZXF1aXJlKCcuLi9lbnYnKTtcblxuaWYgKCd1bmtub3duJyA9PSBlbnYudHlwZSkge1xuICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gZW52aXJvbm1lbnQnKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPVxuICBlbnYuaXNOb2RlID8gcmVxdWlyZSgnLi9ub2RlJykgOlxuICAgIGVudi5pc01vbmdvID8gcmVxdWlyZSgnLi9jb2xsZWN0aW9uJykgOlxuICAgICAgcmVxdWlyZSgnLi9jb2xsZWN0aW9uJyk7XG5cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../server/node_modules/mquery/lib/collection/index.js\n");

/***/ }),

/***/ "../server/node_modules/mquery/lib/collection/node.js":
/*!************************************************************!*\
  !*** ../server/node_modules/mquery/lib/collection/node.js ***!
  \************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("\n\n/**\n * Module dependencies\n */\n\nconst Collection = __webpack_require__(/*! ./collection */ \"../server/node_modules/mquery/lib/collection/collection.js\");\n\nclass NodeCollection extends Collection {\n  constructor(col) {\n    super();\n\n    this.collection = col;\n    this.collectionName = col.collectionName;\n  }\n\n  /**\n   * find(match, options)\n   */\n  async find(match, options) {\n    const cursor = this.collection.find(match, options);\n\n    return cursor.toArray();\n  }\n\n  /**\n   * findOne(match, options)\n   */\n  async findOne(match, options) {\n    return this.collection.findOne(match, options);\n  }\n\n  /**\n   * count(match, options)\n   */\n  async count(match, options) {\n    return this.collection.count(match, options);\n  }\n\n  /**\n   * distinct(prop, match, options)\n   */\n  async distinct(prop, match, options) {\n    return this.collection.distinct(prop, match, options);\n  }\n\n  /**\n   * updateMany(match, update, options)\n   */\n  async updateMany(match, update, options) {\n    return this.collection.updateMany(match, update, options);\n  }\n\n  /**\n   * updateOne(match, update, options)\n   */\n  async updateOne(match, update, options) {\n    return this.collection.updateOne(match, update, options);\n  }\n\n  /**\n   * replaceOne(match, update, options)\n   */\n  async replaceOne(match, update, options) {\n    return this.collection.replaceOne(match, update, options);\n  }\n\n  /**\n   * deleteOne(match, options)\n   */\n  async deleteOne(match, options) {\n    return this.collection.deleteOne(match, options);\n  }\n\n  /**\n   * deleteMany(match, options)\n   */\n  async deleteMany(match, options) {\n    return this.collection.deleteMany(match, options);\n  }\n\n  /**\n   * findOneAndDelete(match, options, function(err[, result])\n   */\n  async findOneAndDelete(match, options) {\n    return this.collection.findOneAndDelete(match, options);\n  }\n\n  /**\n   * findOneAndUpdate(match, update, options)\n   */\n  async findOneAndUpdate(match, update, options) {\n    return this.collection.findOneAndUpdate(match, update, options);\n  }\n\n  /**\n   * var cursor = findCursor(match, options)\n   */\n  findCursor(match, options) {\n    return this.collection.find(match, options);\n  }\n\n  /**\n   * aggregation(operators...)\n   * TODO\n   */\n}\n\n\n/**\n * Expose\n */\n\nmodule.exports = exports = NodeCollection;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tcXVlcnkvbGliL2NvbGxlY3Rpb24vbm9kZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CLG1CQUFPLENBQUMsZ0ZBQWM7O0FBRXpDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2xpZW50Ly4uL3NlcnZlci9ub2RlX21vZHVsZXMvbXF1ZXJ5L2xpYi9jb2xsZWN0aW9uL25vZGUuanM/ODIzZiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llc1xuICovXG5cbmNvbnN0IENvbGxlY3Rpb24gPSByZXF1aXJlKCcuL2NvbGxlY3Rpb24nKTtcblxuY2xhc3MgTm9kZUNvbGxlY3Rpb24gZXh0ZW5kcyBDb2xsZWN0aW9uIHtcbiAgY29uc3RydWN0b3IoY29sKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIHRoaXMuY29sbGVjdGlvbiA9IGNvbDtcbiAgICB0aGlzLmNvbGxlY3Rpb25OYW1lID0gY29sLmNvbGxlY3Rpb25OYW1lO1xuICB9XG5cbiAgLyoqXG4gICAqIGZpbmQobWF0Y2gsIG9wdGlvbnMpXG4gICAqL1xuICBhc3luYyBmaW5kKG1hdGNoLCBvcHRpb25zKSB7XG4gICAgY29uc3QgY3Vyc29yID0gdGhpcy5jb2xsZWN0aW9uLmZpbmQobWF0Y2gsIG9wdGlvbnMpO1xuXG4gICAgcmV0dXJuIGN1cnNvci50b0FycmF5KCk7XG4gIH1cblxuICAvKipcbiAgICogZmluZE9uZShtYXRjaCwgb3B0aW9ucylcbiAgICovXG4gIGFzeW5jIGZpbmRPbmUobWF0Y2gsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdGhpcy5jb2xsZWN0aW9uLmZpbmRPbmUobWF0Y2gsIG9wdGlvbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIGNvdW50KG1hdGNoLCBvcHRpb25zKVxuICAgKi9cbiAgYXN5bmMgY291bnQobWF0Y2gsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdGhpcy5jb2xsZWN0aW9uLmNvdW50KG1hdGNoLCBvcHRpb25zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBkaXN0aW5jdChwcm9wLCBtYXRjaCwgb3B0aW9ucylcbiAgICovXG4gIGFzeW5jIGRpc3RpbmN0KHByb3AsIG1hdGNoLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIHRoaXMuY29sbGVjdGlvbi5kaXN0aW5jdChwcm9wLCBtYXRjaCwgb3B0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgICogdXBkYXRlTWFueShtYXRjaCwgdXBkYXRlLCBvcHRpb25zKVxuICAgKi9cbiAgYXN5bmMgdXBkYXRlTWFueShtYXRjaCwgdXBkYXRlLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIHRoaXMuY29sbGVjdGlvbi51cGRhdGVNYW55KG1hdGNoLCB1cGRhdGUsIG9wdGlvbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIHVwZGF0ZU9uZShtYXRjaCwgdXBkYXRlLCBvcHRpb25zKVxuICAgKi9cbiAgYXN5bmMgdXBkYXRlT25lKG1hdGNoLCB1cGRhdGUsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdGhpcy5jb2xsZWN0aW9uLnVwZGF0ZU9uZShtYXRjaCwgdXBkYXRlLCBvcHRpb25zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiByZXBsYWNlT25lKG1hdGNoLCB1cGRhdGUsIG9wdGlvbnMpXG4gICAqL1xuICBhc3luYyByZXBsYWNlT25lKG1hdGNoLCB1cGRhdGUsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdGhpcy5jb2xsZWN0aW9uLnJlcGxhY2VPbmUobWF0Y2gsIHVwZGF0ZSwgb3B0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgICogZGVsZXRlT25lKG1hdGNoLCBvcHRpb25zKVxuICAgKi9cbiAgYXN5bmMgZGVsZXRlT25lKG1hdGNoLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIHRoaXMuY29sbGVjdGlvbi5kZWxldGVPbmUobWF0Y2gsIG9wdGlvbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIGRlbGV0ZU1hbnkobWF0Y2gsIG9wdGlvbnMpXG4gICAqL1xuICBhc3luYyBkZWxldGVNYW55KG1hdGNoLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIHRoaXMuY29sbGVjdGlvbi5kZWxldGVNYW55KG1hdGNoLCBvcHRpb25zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBmaW5kT25lQW5kRGVsZXRlKG1hdGNoLCBvcHRpb25zLCBmdW5jdGlvbihlcnJbLCByZXN1bHRdKVxuICAgKi9cbiAgYXN5bmMgZmluZE9uZUFuZERlbGV0ZShtYXRjaCwgb3B0aW9ucykge1xuICAgIHJldHVybiB0aGlzLmNvbGxlY3Rpb24uZmluZE9uZUFuZERlbGV0ZShtYXRjaCwgb3B0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgICogZmluZE9uZUFuZFVwZGF0ZShtYXRjaCwgdXBkYXRlLCBvcHRpb25zKVxuICAgKi9cbiAgYXN5bmMgZmluZE9uZUFuZFVwZGF0ZShtYXRjaCwgdXBkYXRlLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIHRoaXMuY29sbGVjdGlvbi5maW5kT25lQW5kVXBkYXRlKG1hdGNoLCB1cGRhdGUsIG9wdGlvbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIHZhciBjdXJzb3IgPSBmaW5kQ3Vyc29yKG1hdGNoLCBvcHRpb25zKVxuICAgKi9cbiAgZmluZEN1cnNvcihtYXRjaCwgb3B0aW9ucykge1xuICAgIHJldHVybiB0aGlzLmNvbGxlY3Rpb24uZmluZChtYXRjaCwgb3B0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgICogYWdncmVnYXRpb24ob3BlcmF0b3JzLi4uKVxuICAgKiBUT0RPXG4gICAqL1xufVxuXG5cbi8qKlxuICogRXhwb3NlXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gTm9kZUNvbGxlY3Rpb247XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../server/node_modules/mquery/lib/collection/node.js\n");

/***/ }),

/***/ "../server/node_modules/mquery/lib/env.js":
/*!************************************************!*\
  !*** ../server/node_modules/mquery/lib/env.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\nexports.isNode = 'undefined' != typeof process\n           && 'object' == \"object\"\n           && 'object' == typeof global\n           && 'function' == typeof Buffer\n           && process.argv;\n\nexports.isMongo = !exports.isNode\n           && 'function' == typeof printjson\n           && 'function' == typeof ObjectId\n           && 'function' == typeof rs\n           && 'function' == typeof sh;\n\nexports.isBrowser = !exports.isNode\n                 && !exports.isMongo\n                 && 'undefined' != typeof window;\n\nexports.type = exports.isNode ? 'node'\n  : exports.isMongo ? 'mongo'\n    : exports.isBrowser ? 'browser'\n      : 'unknown';\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tcXVlcnkvbGliL2Vudi5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixjQUFjO0FBQ2QsMEJBQTBCLFFBQWE7QUFDdkM7QUFDQTtBQUNBOztBQUVBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUI7QUFDakI7QUFDQTs7QUFFQSxZQUFZO0FBQ1o7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2xpZW50Ly4uL3NlcnZlci9ub2RlX21vZHVsZXMvbXF1ZXJ5L2xpYi9lbnYuanM/ZDNlMyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuaXNOb2RlID0gJ3VuZGVmaW5lZCcgIT0gdHlwZW9mIHByb2Nlc3NcbiAgICAgICAgICAgJiYgJ29iamVjdCcgPT0gdHlwZW9mIG1vZHVsZVxuICAgICAgICAgICAmJiAnb2JqZWN0JyA9PSB0eXBlb2YgZ2xvYmFsXG4gICAgICAgICAgICYmICdmdW5jdGlvbicgPT0gdHlwZW9mIEJ1ZmZlclxuICAgICAgICAgICAmJiBwcm9jZXNzLmFyZ3Y7XG5cbmV4cG9ydHMuaXNNb25nbyA9ICFleHBvcnRzLmlzTm9kZVxuICAgICAgICAgICAmJiAnZnVuY3Rpb24nID09IHR5cGVvZiBwcmludGpzb25cbiAgICAgICAgICAgJiYgJ2Z1bmN0aW9uJyA9PSB0eXBlb2YgT2JqZWN0SWRcbiAgICAgICAgICAgJiYgJ2Z1bmN0aW9uJyA9PSB0eXBlb2YgcnNcbiAgICAgICAgICAgJiYgJ2Z1bmN0aW9uJyA9PSB0eXBlb2Ygc2g7XG5cbmV4cG9ydHMuaXNCcm93c2VyID0gIWV4cG9ydHMuaXNOb2RlXG4gICAgICAgICAgICAgICAgICYmICFleHBvcnRzLmlzTW9uZ29cbiAgICAgICAgICAgICAgICAgJiYgJ3VuZGVmaW5lZCcgIT0gdHlwZW9mIHdpbmRvdztcblxuZXhwb3J0cy50eXBlID0gZXhwb3J0cy5pc05vZGUgPyAnbm9kZSdcbiAgOiBleHBvcnRzLmlzTW9uZ28gPyAnbW9uZ28nXG4gICAgOiBleHBvcnRzLmlzQnJvd3NlciA/ICdicm93c2VyJ1xuICAgICAgOiAndW5rbm93bic7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../server/node_modules/mquery/lib/env.js\n");

/***/ }),

/***/ "../server/node_modules/mquery/lib/mquery.js":
/*!***************************************************!*\
  !*** ../server/node_modules/mquery/lib/mquery.js ***!
  \***************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("\n\n/**\n * Dependencies\n */\n\nconst assert = __webpack_require__(/*! assert */ \"assert\");\nconst util = __webpack_require__(/*! util */ \"util\");\nconst utils = __webpack_require__(/*! ./utils */ \"../server/node_modules/mquery/lib/utils.js\");\nconst debug = __webpack_require__(/*! debug */ \"../server/node_modules/mquery/node_modules/debug/src/index.js\")('mquery');\n\n/**\n * Query constructor used for building queries.\n *\n * #### Example:\n *\n *     var query = new Query({ name: 'mquery' });\n *     query.setOptions({ collection: moduleCollection })\n *     await query.where('age').gte(21).exec();\n *\n * @param {Object} [criteria] criteria for the query OR the collection instance to use\n * @param {Object} [options]\n * @api public\n */\n\nfunction Query(criteria, options) {\n  if (!(this instanceof Query))\n    return new Query(criteria, options);\n\n  const proto = this.constructor.prototype;\n\n  this.op = proto.op || undefined;\n\n  this.options = Object.assign({}, proto.options);\n\n  this._conditions = proto._conditions\n    ? utils.clone(proto._conditions)\n    : {};\n\n  this._fields = proto._fields\n    ? utils.clone(proto._fields)\n    : undefined;\n\n  this._updateDoc = proto._updateDoc\n    ? utils.clone(proto._updateDoc)\n    : undefined;\n\n  this._path = proto._path || undefined;\n  this._distinctDoc = proto._distinctDoc || undefined;\n  this._collection = proto._collection || undefined;\n  this._traceFunction = proto._traceFunction || undefined;\n\n  if (options) {\n    this.setOptions(options);\n  }\n\n  if (criteria) {\n    this.find(criteria);\n  }\n}\n\n/**\n * This is a parameter that the user can set which determines if mquery\n * uses $within or $geoWithin for queries. It defaults to true which\n * means $geoWithin will be used. If using MongoDB < 2.4 you should\n * set this to false.\n *\n * @api public\n * @property use$geoWithin\n */\n\nlet $withinCmd = '$geoWithin';\nObject.defineProperty(Query, 'use$geoWithin', {\n  get: function() { return $withinCmd == '$geoWithin'; },\n  set: function(v) {\n    if (true === v) {\n      // mongodb >= 2.4\n      $withinCmd = '$geoWithin';\n    } else {\n      $withinCmd = '$within';\n    }\n  }\n});\n\n/**\n * Converts this query to a constructor function with all arguments and options retained.\n *\n * #### Example:\n *\n *     // Create a query that will read documents with a \"video\" category from\n *     // `aCollection` on the primary node in the replica-set unless it is down,\n *     // in which case we'll read from a secondary node.\n *     var query = mquery({ category: 'video' })\n *     query.setOptions({ collection: aCollection, read: 'primaryPreferred' });\n *\n *     // create a constructor based off these settings\n *     var Video = query.toConstructor();\n *\n *     // Video is now a subclass of mquery() and works the same way but with the\n *     // default query parameters and options set.\n *\n *     // run a query with the previous settings but filter for movies with names\n *     // that start with \"Life\".\n *     Video().where({ name: /^Life/ }).exec(cb);\n *\n * @return {Query} new Query\n * @api public\n */\n\nQuery.prototype.toConstructor = function toConstructor() {\n  function CustomQuery(criteria, options) {\n    if (!(this instanceof CustomQuery))\n      return new CustomQuery(criteria, options);\n    Query.call(this, criteria, options);\n  }\n\n  utils.inherits(CustomQuery, Query);\n\n  // set inherited defaults\n  const p = CustomQuery.prototype;\n\n  p.options = {};\n  p.setOptions(this.options);\n\n  p.op = this.op;\n  p._conditions = utils.clone(this._conditions);\n  p._fields = utils.clone(this._fields);\n  p._updateDoc = utils.clone(this._updateDoc);\n  p._path = this._path;\n  p._distinctDoc = this._distinctDoc;\n  p._collection = this._collection;\n  p._traceFunction = this._traceFunction;\n\n  return CustomQuery;\n};\n\n/**\n * Sets query options.\n *\n * #### Options:\n *\n * - [tailable](http://www.mongodb.org/display/DOCS/Tailable+Cursors) *\n * - [sort](http://www.mongodb.org/display/DOCS/Advanced+Queries#AdvancedQueries-%7B%7Bsort(\\)%7D%7D) *\n * - [limit](http://www.mongodb.org/display/DOCS/Advanced+Queries#AdvancedQueries-%7B%7Blimit%28%29%7D%7D) *\n * - [skip](http://www.mongodb.org/display/DOCS/Advanced+Queries#AdvancedQueries-%7B%7Bskip%28%29%7D%7D) *\n * - [maxTime](http://docs.mongodb.org/manual/reference/operator/meta/maxTimeMS/#op._S_maxTimeMS) *\n * - [batchSize](http://www.mongodb.org/display/DOCS/Advanced+Queries#AdvancedQueries-%7B%7BbatchSize%28%29%7D%7D) *\n * - [comment](http://www.mongodb.org/display/DOCS/Advanced+Queries#AdvancedQueries-%24comment) *\n * - [hint](http://www.mongodb.org/display/DOCS/Advanced+Queries#AdvancedQueries-%24hint) *\n * - [slaveOk](http://docs.mongodb.org/manual/applications/replication/#read-preference) *\n * - [safe](http://www.mongodb.org/display/DOCS/getLastError+Command)\n * - collection the collection to query against\n *\n * _* denotes a query helper method is also available_\n *\n * @param {Object} options\n * @api public\n */\n\nQuery.prototype.setOptions = function(options) {\n  if (!(options && utils.isObject(options)))\n    return this;\n\n  // set arbitrary options\n  const methods = utils.keys(options);\n  let method;\n\n  for (let i = 0; i < methods.length; ++i) {\n    method = methods[i];\n\n    // use methods if exist (safer option manipulation)\n    if ('function' == typeof this[method]) {\n      const args = Array.isArray(options[method])\n        ? options[method]\n        : [options[method]];\n      this[method].apply(this, args);\n    } else {\n      this.options[method] = options[method];\n    }\n  }\n\n  return this;\n};\n\n/**\n * Sets this Querys collection.\n *\n * @param {Collection} coll\n * @return {Query} this\n */\n\nQuery.prototype.collection = function collection(coll) {\n  this._collection = new Query.Collection(coll);\n\n  return this;\n};\n\n/**\n * Adds a collation to this op (MongoDB 3.4 and up)\n *\n * #### Example:\n *\n *     query.find().collation({ locale: \"en_US\", strength: 1 })\n *\n * @param {Object} value\n * @return {Query} this\n * @see MongoDB docs https://docs.mongodb.com/manual/reference/method/cursor.collation/#cursor.collation\n * @api public\n */\n\nQuery.prototype.collation = function(value) {\n  this.options.collation = value;\n  return this;\n};\n\n/**\n * Specifies a `$where` condition\n *\n * Use `$where` when you need to select documents using a JavaScript expression.\n *\n * #### Example:\n *\n *     query.$where('this.comments.length > 10 || this.name.length > 5')\n *\n *     query.$where(function () {\n *       return this.comments.length > 10 || this.name.length > 5;\n *     })\n *\n * @param {String|Function} js javascript string or function\n * @return {Query} this\n * @memberOf Query\n * @method $where\n * @api public\n */\n\nQuery.prototype.$where = function(js) {\n  this._conditions.$where = js;\n  return this;\n};\n\n/**\n * Specifies a `path` for use with chaining.\n *\n * #### Example:\n *\n *     // instead of writing:\n *     await User.find({age: {$gte: 21, $lte: 65}});\n *\n *     // we can instead write:\n *     User.where('age').gte(21).lte(65);\n *\n *     // passing query conditions is permitted\n *     User.find().where({ name: 'vonderful' })\n *\n *     // chaining\n *     await User\n *       .where('age').gte(21).lte(65)\n *       .where('name', /^vonderful/i)\n *       .where('friends').slice(10)\n *       .exec()\n *\n * @param {String} [path]\n * @param {Object} [val]\n * @return {Query} this\n * @api public\n */\n\nQuery.prototype.where = function() {\n  if (!arguments.length) return this;\n  if (!this.op) this.op = 'find';\n\n  const type = typeof arguments[0];\n\n  if ('string' == type) {\n    this._path = arguments[0];\n\n    if (2 === arguments.length) {\n      this._conditions[this._path] = arguments[1];\n    }\n\n    return this;\n  }\n\n  if ('object' == type && !Array.isArray(arguments[0])) {\n    return this.merge(arguments[0]);\n  }\n\n  throw new TypeError('path must be a string or object');\n};\n\n/**\n * Specifies the complementary comparison value for paths specified with `where()`\n *\n * #### Example:\n *\n *     User.where('age').equals(49);\n *\n *     // is the same as\n *\n *     User.where('age', 49);\n *\n * @param {Object} val\n * @return {Query} this\n * @api public\n */\n\nQuery.prototype.equals = function equals(val) {\n  this._ensurePath('equals');\n  const path = this._path;\n  this._conditions[path] = val;\n  return this;\n};\n\n/**\n * Specifies the complementary comparison value for paths specified with `where()`\n * This is alias of `equals`\n *\n * #### Example:\n *\n *     User.where('age').eq(49);\n *\n *     // is the same as\n *\n *     User.shere('age').equals(49);\n *\n *     // is the same as\n *\n *     User.where('age', 49);\n *\n * @param {Object} val\n * @return {Query} this\n * @api public\n */\n\nQuery.prototype.eq = function eq(val) {\n  this._ensurePath('eq');\n  const path = this._path;\n  this._conditions[path] = val;\n  return this;\n};\n\n/**\n * Specifies arguments for an `$or` condition.\n *\n * #### Example:\n *\n *     query.or([{ color: 'red' }, { status: 'emergency' }])\n *\n * @param {Array} array array of conditions\n * @return {Query} this\n * @api public\n */\n\nQuery.prototype.or = function or(array) {\n  const or = this._conditions.$or || (this._conditions.$or = []);\n  if (!Array.isArray(array)) array = [array];\n  or.push.apply(or, array);\n  return this;\n};\n\n/**\n * Specifies arguments for a `$nor` condition.\n *\n * #### Example:\n *\n *     query.nor([{ color: 'green' }, { status: 'ok' }])\n *\n * @param {Array} array array of conditions\n * @return {Query} this\n * @api public\n */\n\nQuery.prototype.nor = function nor(array) {\n  const nor = this._conditions.$nor || (this._conditions.$nor = []);\n  if (!Array.isArray(array)) array = [array];\n  nor.push.apply(nor, array);\n  return this;\n};\n\n/**\n * Specifies arguments for a `$and` condition.\n *\n * #### Example:\n *\n *     query.and([{ color: 'green' }, { status: 'ok' }])\n *\n * @see $and http://docs.mongodb.org/manual/reference/operator/and/\n * @param {Array} array array of conditions\n * @return {Query} this\n * @api public\n */\n\nQuery.prototype.and = function and(array) {\n  const and = this._conditions.$and || (this._conditions.$and = []);\n  if (!Array.isArray(array)) array = [array];\n  and.push.apply(and, array);\n  return this;\n};\n\n/**\n * Specifies a $gt query condition.\n *\n * When called with one argument, the most recent path passed to `where()` is used.\n *\n * #### Example:\n *\n *     Thing.find().where('age').gt(21)\n *\n *     // or\n *     Thing.find().gt('age', 21)\n *\n * @method gt\n * @memberOf Query\n * @param {String} [path]\n * @param {Number} val\n * @api public\n */\n\n/**\n * Specifies a $gte query condition.\n *\n * When called with one argument, the most recent path passed to `where()` is used.\n *\n * @method gte\n * @memberOf Query\n * @param {String} [path]\n * @param {Number} val\n * @api public\n */\n\n/**\n * Specifies a $lt query condition.\n *\n * When called with one argument, the most recent path passed to `where()` is used.\n *\n * @method lt\n * @memberOf Query\n * @param {String} [path]\n * @param {Number} val\n * @api public\n */\n\n/**\n * Specifies a $lte query condition.\n *\n * When called with one argument, the most recent path passed to `where()` is used.\n *\n * @method lte\n * @memberOf Query\n * @param {String} [path]\n * @param {Number} val\n * @api public\n */\n\n/**\n * Specifies a $ne query condition.\n *\n * When called with one argument, the most recent path passed to `where()` is used.\n *\n * @method ne\n * @memberOf Query\n * @param {String} [path]\n * @param {Number} val\n * @api public\n */\n\n/**\n * Specifies an $in query condition.\n *\n * When called with one argument, the most recent path passed to `where()` is used.\n *\n * @method in\n * @memberOf Query\n * @param {String} [path]\n * @param {Number} val\n * @api public\n */\n\n/**\n * Specifies an $nin query condition.\n *\n * When called with one argument, the most recent path passed to `where()` is used.\n *\n * @method nin\n * @memberOf Query\n * @param {String} [path]\n * @param {Number} val\n * @api public\n */\n\n/**\n * Specifies an $all query condition.\n *\n * When called with one argument, the most recent path passed to `where()` is used.\n *\n * @method all\n * @memberOf Query\n * @param {String} [path]\n * @param {Number} val\n * @api public\n */\n\n/**\n * Specifies a $size query condition.\n *\n * When called with one argument, the most recent path passed to `where()` is used.\n *\n * @method size\n * @memberOf Query\n * @param {String} [path]\n * @param {Number} val\n * @api public\n */\n\n/**\n * Specifies a $regex query condition.\n *\n * When called with one argument, the most recent path passed to `where()` is used.\n *\n * @method regex\n * @memberOf Query\n * @param {String} [path]\n * @param {String|RegExp} val\n * @api public\n */\n\n/**\n * Specifies a $maxDistance query condition.\n *\n * When called with one argument, the most recent path passed to `where()` is used.\n *\n * @method maxDistance\n * @memberOf Query\n * @param {String} [path]\n * @param {Number} val\n * @api public\n */\n\n/*!\n * gt, gte, lt, lte, ne, in, nin, all, regex, size, maxDistance\n *\n *     Thing.where('type').nin(array)\n */\n\n'gt gte lt lte ne in nin all regex size maxDistance minDistance'.split(' ').forEach(function($conditional) {\n  Query.prototype[$conditional] = function() {\n    let path, val;\n\n    if (1 === arguments.length) {\n      this._ensurePath($conditional);\n      val = arguments[0];\n      path = this._path;\n    } else {\n      val = arguments[1];\n      path = arguments[0];\n    }\n\n    const conds = this._conditions[path] === null || typeof this._conditions[path] === 'object' ?\n      this._conditions[path] :\n      (this._conditions[path] = {});\n    conds['$' + $conditional] = val;\n    return this;\n  };\n});\n\n/**\n * Specifies a `$mod` condition\n *\n * @param {String} [path]\n * @param {Number} val\n * @return {Query} this\n * @api public\n */\n\nQuery.prototype.mod = function() {\n  let val, path;\n\n  if (1 === arguments.length) {\n    this._ensurePath('mod');\n    val = arguments[0];\n    path = this._path;\n  } else if (2 === arguments.length && !Array.isArray(arguments[1])) {\n    this._ensurePath('mod');\n    val = [arguments[0], arguments[1]];\n    path = this._path;\n  } else if (3 === arguments.length) {\n    val = [arguments[1], arguments[2]];\n    path = arguments[0];\n  } else {\n    val = arguments[1];\n    path = arguments[0];\n  }\n\n  const conds = this._conditions[path] || (this._conditions[path] = {});\n  conds.$mod = val;\n  return this;\n};\n\n/**\n * Specifies an `$exists` condition\n *\n * #### Example:\n *\n *     // { name: { $exists: true }}\n *     Thing.where('name').exists()\n *     Thing.where('name').exists(true)\n *     Thing.find().exists('name')\n *\n *     // { name: { $exists: false }}\n *     Thing.where('name').exists(false);\n *     Thing.find().exists('name', false);\n *\n * @param {String} [path]\n * @param {Number} val\n * @return {Query} this\n * @api public\n */\n\nQuery.prototype.exists = function() {\n  let path, val;\n\n  if (0 === arguments.length) {\n    this._ensurePath('exists');\n    path = this._path;\n    val = true;\n  } else if (1 === arguments.length) {\n    if ('boolean' === typeof arguments[0]) {\n      this._ensurePath('exists');\n      path = this._path;\n      val = arguments[0];\n    } else {\n      path = arguments[0];\n      val = true;\n    }\n  } else if (2 === arguments.length) {\n    path = arguments[0];\n    val = arguments[1];\n  }\n\n  const conds = this._conditions[path] || (this._conditions[path] = {});\n  conds.$exists = val;\n  return this;\n};\n\n/**\n * Specifies an `$elemMatch` condition\n *\n * #### Example:\n *\n *     query.elemMatch('comment', { author: 'autobot', votes: {$gte: 5}})\n *\n *     query.where('comment').elemMatch({ author: 'autobot', votes: {$gte: 5}})\n *\n *     query.elemMatch('comment', function (elem) {\n *       elem.where('author').equals('autobot');\n *       elem.where('votes').gte(5);\n *     })\n *\n *     query.where('comment').elemMatch(function (elem) {\n *       elem.where({ author: 'autobot' });\n *       elem.where('votes').gte(5);\n *     })\n *\n * @param {String|Object|Function} path\n * @param {Object|Function} criteria\n * @return {Query} this\n * @api public\n */\n\nQuery.prototype.elemMatch = function() {\n  if (null == arguments[0])\n    throw new TypeError('Invalid argument');\n\n  let fn, path, criteria;\n\n  if ('function' === typeof arguments[0]) {\n    this._ensurePath('elemMatch');\n    path = this._path;\n    fn = arguments[0];\n  } else if (utils.isObject(arguments[0])) {\n    this._ensurePath('elemMatch');\n    path = this._path;\n    criteria = arguments[0];\n  } else if ('function' === typeof arguments[1]) {\n    path = arguments[0];\n    fn = arguments[1];\n  } else if (arguments[1] && utils.isObject(arguments[1])) {\n    path = arguments[0];\n    criteria = arguments[1];\n  } else {\n    throw new TypeError('Invalid argument');\n  }\n\n  if (fn) {\n    criteria = new Query;\n    fn(criteria);\n    criteria = criteria._conditions;\n  }\n\n  const conds = this._conditions[path] || (this._conditions[path] = {});\n  conds.$elemMatch = criteria;\n  return this;\n};\n\n// Spatial queries\n\n/**\n * Sugar for geo-spatial queries.\n *\n * #### Example:\n *\n *     query.within().box()\n *     query.within().circle()\n *     query.within().geometry()\n *\n *     query.where('loc').within({ center: [50,50], radius: 10, unique: true, spherical: true });\n *     query.where('loc').within({ box: [[40.73, -73.9], [40.7, -73.988]] });\n *     query.where('loc').within({ polygon: [[],[],[],[]] });\n *\n *     query.where('loc').within([], [], []) // polygon\n *     query.where('loc').within([], []) // box\n *     query.where('loc').within({ type: 'LineString', coordinates: [...] }); // geometry\n *\n * #### Note:\n *\n * Must be used after `where()`.\n *\n * @memberOf Query\n * @return {Query} this\n * @api public\n */\n\nQuery.prototype.within = function within() {\n  // opinionated, must be used after where\n  this._ensurePath('within');\n  this._geoComparison = $withinCmd;\n\n  if (0 === arguments.length) {\n    return this;\n  }\n\n  if (2 === arguments.length) {\n    return this.box.apply(this, arguments);\n  } else if (2 < arguments.length) {\n    return this.polygon.apply(this, arguments);\n  }\n\n  const area = arguments[0];\n\n  if (!area)\n    throw new TypeError('Invalid argument');\n\n  if (area.center)\n    return this.circle(area);\n\n  if (area.box)\n    return this.box.apply(this, area.box);\n\n  if (area.polygon)\n    return this.polygon.apply(this, area.polygon);\n\n  if (area.type && area.coordinates)\n    return this.geometry(area);\n\n  throw new TypeError('Invalid argument');\n};\n\n/**\n * Specifies a $box condition\n *\n * #### Example:\n *\n *     var lowerLeft = [40.73083, -73.99756]\n *     var upperRight= [40.741404,  -73.988135]\n *\n *     query.where('loc').within().box(lowerLeft, upperRight)\n *     query.box('loc', lowerLeft, upperRight )\n *\n * @see http://www.mongodb.org/display/DOCS/Geospatial+Indexing\n * @see Query#within #query_Query-within\n * @param {String} path\n * @param {Object} val\n * @return {Query} this\n * @api public\n */\n\nQuery.prototype.box = function() {\n  let path, box;\n\n  if (3 === arguments.length) {\n    // box('loc', [], [])\n    path = arguments[0];\n    box = [arguments[1], arguments[2]];\n  } else if (2 === arguments.length) {\n    // box([], [])\n    this._ensurePath('box');\n    path = this._path;\n    box = [arguments[0], arguments[1]];\n  } else {\n    throw new TypeError('Invalid argument');\n  }\n\n  const conds = this._conditions[path] || (this._conditions[path] = {});\n  conds[this._geoComparison || $withinCmd] = { $box: box };\n  return this;\n};\n\n/**\n * Specifies a $polygon condition\n *\n * #### Example:\n *\n *     query.where('loc').within().polygon([10,20], [13, 25], [7,15])\n *     query.polygon('loc', [10,20], [13, 25], [7,15])\n *\n * @param {String|Array} [path]\n * @param {Array|Object} [val]\n * @return {Query} this\n * @see http://www.mongodb.org/display/DOCS/Geospatial+Indexing\n * @api public\n */\n\nQuery.prototype.polygon = function() {\n  let val, path;\n\n  if ('string' == typeof arguments[0]) {\n    // polygon('loc', [],[],[])\n    val = Array.from(arguments);\n    path = val.shift();\n  } else {\n    // polygon([],[],[])\n    this._ensurePath('polygon');\n    path = this._path;\n    val = Array.from(arguments);\n  }\n\n  const conds = this._conditions[path] || (this._conditions[path] = {});\n  conds[this._geoComparison || $withinCmd] = { $polygon: val };\n  return this;\n};\n\n/**\n * Specifies a $center or $centerSphere condition.\n *\n * #### Example:\n *\n *     var area = { center: [50, 50], radius: 10, unique: true }\n *     query.where('loc').within().circle(area)\n *     query.center('loc', area);\n *\n *     // for spherical calculations\n *     var area = { center: [50, 50], radius: 10, unique: true, spherical: true }\n *     query.where('loc').within().circle(area)\n *     query.center('loc', area);\n *\n * @param {String} [path]\n * @param {Object} area\n * @return {Query} this\n * @see http://www.mongodb.org/display/DOCS/Geospatial+Indexing\n * @api public\n */\n\nQuery.prototype.circle = function() {\n  let path, val;\n\n  if (1 === arguments.length) {\n    this._ensurePath('circle');\n    path = this._path;\n    val = arguments[0];\n  } else if (2 === arguments.length) {\n    path = arguments[0];\n    val = arguments[1];\n  } else {\n    throw new TypeError('Invalid argument');\n  }\n\n  if (!('radius' in val && val.center))\n    throw new Error('center and radius are required');\n\n  const conds = this._conditions[path] || (this._conditions[path] = {});\n\n  const type = val.spherical\n    ? '$centerSphere'\n    : '$center';\n\n  const wKey = this._geoComparison || $withinCmd;\n  conds[wKey] = {};\n  conds[wKey][type] = [val.center, val.radius];\n\n  if ('unique' in val)\n    conds[wKey].$uniqueDocs = !!val.unique;\n\n  return this;\n};\n\n/**\n * Specifies a `$near` or `$nearSphere` condition\n *\n * These operators return documents sorted by distance.\n *\n * #### Example:\n *\n *     query.where('loc').near({ center: [10, 10] });\n *     query.where('loc').near({ center: [10, 10], maxDistance: 5 });\n *     query.where('loc').near({ center: [10, 10], maxDistance: 5, spherical: true });\n *     query.near('loc', { center: [10, 10], maxDistance: 5 });\n *     query.near({ center: { type: 'Point', coordinates: [..] }})\n *     query.near().geometry({ type: 'Point', coordinates: [..] })\n *\n * @param {String} [path]\n * @param {Object} val\n * @return {Query} this\n * @see http://www.mongodb.org/display/DOCS/Geospatial+Indexing\n * @api public\n */\n\nQuery.prototype.near = function near() {\n  let path, val;\n\n  this._geoComparison = '$near';\n\n  if (0 === arguments.length) {\n    return this;\n  } else if (1 === arguments.length) {\n    this._ensurePath('near');\n    path = this._path;\n    val = arguments[0];\n  } else if (2 === arguments.length) {\n    path = arguments[0];\n    val = arguments[1];\n  } else {\n    throw new TypeError('Invalid argument');\n  }\n\n  if (!val.center) {\n    throw new Error('center is required');\n  }\n\n  const conds = this._conditions[path] || (this._conditions[path] = {});\n\n  const type = val.spherical\n    ? '$nearSphere'\n    : '$near';\n\n  // center could be a GeoJSON object or an Array\n  if (Array.isArray(val.center)) {\n    conds[type] = val.center;\n\n    const radius = 'maxDistance' in val\n      ? val.maxDistance\n      : null;\n\n    if (null != radius) {\n      conds.$maxDistance = radius;\n    }\n    if (null != val.minDistance) {\n      conds.$minDistance = val.minDistance;\n    }\n  } else {\n    // GeoJSON?\n    if (val.center.type != 'Point' || !Array.isArray(val.center.coordinates)) {\n      throw new Error(util.format('Invalid GeoJSON specified for %s', type));\n    }\n    conds[type] = { $geometry: val.center };\n\n    // MongoDB 2.6 insists on maxDistance being in $near / $nearSphere\n    if ('maxDistance' in val) {\n      conds[type]['$maxDistance'] = val.maxDistance;\n    }\n    if ('minDistance' in val) {\n      conds[type]['$minDistance'] = val.minDistance;\n    }\n  }\n\n  return this;\n};\n\n/**\n * Declares an intersects query for `geometry()`.\n *\n * #### Example:\n *\n *     query.where('path').intersects().geometry({\n *         type: 'LineString'\n *       , coordinates: [[180.0, 11.0], [180, 9.0]]\n *     })\n *\n *     query.where('path').intersects({\n *         type: 'LineString'\n *       , coordinates: [[180.0, 11.0], [180, 9.0]]\n *     })\n *\n * @param {Object} [arg]\n * @return {Query} this\n * @api public\n */\n\nQuery.prototype.intersects = function intersects() {\n  // opinionated, must be used after where\n  this._ensurePath('intersects');\n\n  this._geoComparison = '$geoIntersects';\n\n  if (0 === arguments.length) {\n    return this;\n  }\n\n  const area = arguments[0];\n\n  if (null != area && area.type && area.coordinates)\n    return this.geometry(area);\n\n  throw new TypeError('Invalid argument');\n};\n\n/**\n * Specifies a `$geometry` condition\n *\n * #### Example:\n *\n *     var polyA = [[[ 10, 20 ], [ 10, 40 ], [ 30, 40 ], [ 30, 20 ]]]\n *     query.where('loc').within().geometry({ type: 'Polygon', coordinates: polyA })\n *\n *     // or\n *     var polyB = [[ 0, 0 ], [ 1, 1 ]]\n *     query.where('loc').within().geometry({ type: 'LineString', coordinates: polyB })\n *\n *     // or\n *     var polyC = [ 0, 0 ]\n *     query.where('loc').within().geometry({ type: 'Point', coordinates: polyC })\n *\n *     // or\n *     query.where('loc').intersects().geometry({ type: 'Point', coordinates: polyC })\n *\n * #### Note:\n *\n * `geometry()` **must** come after either `intersects()` or `within()`.\n *\n * The `object` argument must contain `type` and `coordinates` properties.\n * - type {String}\n * - coordinates {Array}\n *\n * The most recent path passed to `where()` is used.\n *\n * @param {Object} object Must contain a `type` property which is a String and a `coordinates` property which is an Array. See the examples.\n * @return {Query} this\n * @see http://docs.mongodb.org/manual/release-notes/2.4/#new-geospatial-indexes-with-geojson-and-improved-spherical-geometry\n * @see http://www.mongodb.org/display/DOCS/Geospatial+Indexing\n * @see $geometry http://docs.mongodb.org/manual/reference/operator/geometry/\n * @api public\n */\n\nQuery.prototype.geometry = function geometry() {\n  if (!('$within' == this._geoComparison ||\n        '$geoWithin' == this._geoComparison ||\n        '$near' == this._geoComparison ||\n        '$geoIntersects' == this._geoComparison)) {\n    throw new Error('geometry() must come after `within()`, `intersects()`, or `near()');\n  }\n\n  let val, path;\n\n  if (1 === arguments.length) {\n    this._ensurePath('geometry');\n    path = this._path;\n    val = arguments[0];\n  } else {\n    throw new TypeError('Invalid argument');\n  }\n\n  if (!(val.type && Array.isArray(val.coordinates))) {\n    throw new TypeError('Invalid argument');\n  }\n\n  const conds = this._conditions[path] || (this._conditions[path] = {});\n  conds[this._geoComparison] = { $geometry: val };\n\n  return this;\n};\n\n// end spatial\n\n/**\n * Specifies which document fields to include or exclude\n *\n * #### String syntax\n *\n * When passing a string, prefixing a path with `-` will flag that path as excluded. When a path does not have the `-` prefix, it is included.\n *\n * #### Example:\n *\n *     // include a and b, exclude c\n *     query.select('a b -c');\n *\n *     // or you may use object notation, useful when\n *     // you have keys already prefixed with a \"-\"\n *     query.select({a: 1, b: 1, c: 0});\n *\n * #### Note:\n *\n * Cannot be used with `distinct()`\n *\n * @param {Object|String} arg\n * @return {Query} this\n * @see SchemaType\n * @api public\n */\n\nQuery.prototype.select = function select() {\n  let arg = arguments[0];\n  if (!arg) return this;\n\n  if (arguments.length !== 1) {\n    throw new Error('Invalid select: select only takes 1 argument');\n  }\n\n  this._validate('select');\n\n  const fields = this._fields || (this._fields = {});\n  const type = typeof arg;\n  let i, len;\n\n  if (('string' == type || utils.isArgumentsObject(arg)) &&\n    'number' == typeof arg.length || Array.isArray(arg)) {\n    if ('string' == type)\n      arg = arg.split(/\\s+/);\n\n    for (i = 0, len = arg.length; i < len; ++i) {\n      let field = arg[i];\n      if (!field) continue;\n      const include = '-' == field[0] ? 0 : 1;\n      if (include === 0) field = field.substring(1);\n      fields[field] = include;\n    }\n\n    return this;\n  }\n\n  if (utils.isObject(arg)) {\n    const keys = utils.keys(arg);\n    for (i = 0; i < keys.length; ++i) {\n      fields[keys[i]] = arg[keys[i]];\n    }\n    return this;\n  }\n\n  throw new TypeError('Invalid select() argument. Must be string or object.');\n};\n\n/**\n * Specifies a $slice condition for a `path`\n *\n * #### Example:\n *\n *     query.slice('comments', 5)\n *     query.slice('comments', -5)\n *     query.slice('comments', [10, 5])\n *     query.where('comments').slice(5)\n *     query.where('comments').slice([-10, 5])\n *\n * @param {String} [path]\n * @param {Number} val number/range of elements to slice\n * @return {Query} this\n * @see mongodb http://www.mongodb.org/display/DOCS/Retrieving+a+Subset+of+Fields#RetrievingaSubsetofFields-RetrievingaSubrangeofArrayElements\n * @api public\n */\n\nQuery.prototype.slice = function() {\n  if (0 === arguments.length)\n    return this;\n\n  this._validate('slice');\n\n  let path, val;\n\n  if (1 === arguments.length) {\n    const arg = arguments[0];\n    if (typeof arg === 'object' && !Array.isArray(arg)) {\n      const keys = Object.keys(arg);\n      const numKeys = keys.length;\n      for (let i = 0; i < numKeys; ++i) {\n        this.slice(keys[i], arg[keys[i]]);\n      }\n      return this;\n    }\n    this._ensurePath('slice');\n    path = this._path;\n    val = arguments[0];\n  } else if (2 === arguments.length) {\n    if ('number' === typeof arguments[0]) {\n      this._ensurePath('slice');\n      path = this._path;\n      val = [arguments[0], arguments[1]];\n    } else {\n      path = arguments[0];\n      val = arguments[1];\n    }\n  } else if (3 === arguments.length) {\n    path = arguments[0];\n    val = [arguments[1], arguments[2]];\n  }\n\n  const myFields = this._fields || (this._fields = {});\n  myFields[path] = { $slice: val };\n  return this;\n};\n\n/**\n * Sets the sort order\n *\n * If an object is passed, values allowed are 'asc', 'desc', 'ascending', 'descending', 1, and -1.\n *\n * If a string is passed, it must be a space delimited list of path names. The sort order of each path is ascending unless the path name is prefixed with `-` which will be treated as descending.\n *\n * #### Example:\n *\n *     // these are equivalent\n *     query.sort({ field: 'asc', test: -1 });\n *     query.sort('field -test');\n *     query.sort([['field', 1], ['test', -1]]);\n *\n * #### Note:\n *\n *  - The array syntax `.sort([['field', 1], ['test', -1]])` can only be used with [mongodb driver >= 2.0.46](https://github.com/mongodb/node-mongodb-native/blob/2.1/HISTORY.md#2046-2015-10-15).\n *  - Cannot be used with `distinct()`\n *\n * @param {Object|String|Array} arg\n * @return {Query} this\n * @api public\n */\n\nQuery.prototype.sort = function(arg) {\n  if (!arg) return this;\n  let i, len, field;\n\n  this._validate('sort');\n\n  const type = typeof arg;\n\n  // .sort([['field', 1], ['test', -1]])\n  if (Array.isArray(arg)) {\n    len = arg.length;\n    for (i = 0; i < arg.length; ++i) {\n      if (!Array.isArray(arg[i])) {\n        throw new Error('Invalid sort() argument, must be array of arrays');\n      }\n      _pushArr(this.options, arg[i][0], arg[i][1]);\n    }\n    return this;\n  }\n\n  // .sort('field -test')\n  if (1 === arguments.length && 'string' == type) {\n    arg = arg.split(/\\s+/);\n    len = arg.length;\n    for (i = 0; i < len; ++i) {\n      field = arg[i];\n      if (!field) continue;\n      const ascend = '-' == field[0] ? -1 : 1;\n      if (ascend === -1) field = field.substring(1);\n      push(this.options, field, ascend);\n    }\n\n    return this;\n  }\n\n  // .sort({ field: 1, test: -1 })\n  if (utils.isObject(arg)) {\n    const keys = utils.keys(arg);\n    for (i = 0; i < keys.length; ++i) {\n      field = keys[i];\n      push(this.options, field, arg[field]);\n    }\n\n    return this;\n  }\n\n  if (typeof Map !== 'undefined' && arg instanceof Map) {\n    _pushMap(this.options, arg);\n    return this;\n  }\n  throw new TypeError('Invalid sort() argument. Must be a string, object, or array.');\n};\n\n/*!\n * @ignore\n */\n\nconst _validSortValue = {\n  1: 1,\n  '-1': -1,\n  asc: 1,\n  ascending: 1,\n  desc: -1,\n  descending: -1\n};\n\nfunction push(opts, field, value) {\n  if (Array.isArray(opts.sort)) {\n    throw new TypeError('Can\\'t mix sort syntaxes. Use either array or object:' +\n      '\\n- `.sort([[\\'field\\', 1], [\\'test\\', -1]])`' +\n      '\\n- `.sort({ field: 1, test: -1 })`');\n  }\n\n  let s;\n  if (value && value.$meta) {\n    s = opts.sort || (opts.sort = {});\n    s[field] = { $meta: value.$meta };\n    return;\n  }\n\n  s = opts.sort || (opts.sort = {});\n  let val = String(value || 1).toLowerCase();\n  val = _validSortValue[val];\n  if (!val) throw new TypeError('Invalid sort value: { ' + field + ': ' + value + ' }');\n\n  s[field] = val;\n}\n\nfunction _pushArr(opts, field, value) {\n  opts.sort = opts.sort || [];\n  if (!Array.isArray(opts.sort)) {\n    throw new TypeError('Can\\'t mix sort syntaxes. Use either array or object:' +\n      '\\n- `.sort([[\\'field\\', 1], [\\'test\\', -1]])`' +\n      '\\n- `.sort({ field: 1, test: -1 })`');\n  }\n\n  let val = String(value || 1).toLowerCase();\n  val = _validSortValue[val];\n  if (!val) throw new TypeError('Invalid sort value: [ ' + field + ', ' + value + ' ]');\n\n  opts.sort.push([field, val]);\n}\n\nfunction _pushMap(opts, map) {\n  opts.sort = opts.sort || new Map();\n  if (!(opts.sort instanceof Map)) {\n    throw new TypeError('Can\\'t mix sort syntaxes. Use either array or ' +\n      'object or map consistently');\n  }\n  map.forEach(function(value, key) {\n    let val = String(value || 1).toLowerCase();\n    val = _validSortValue[val];\n    if (!val) throw new TypeError('Invalid sort value: < ' + key + ': ' + value + ' >');\n\n    opts.sort.set(key, val);\n  });\n}\n\n\n/**\n * Specifies the limit option.\n *\n * #### Example:\n *\n *     query.limit(20)\n *\n * #### Note:\n *\n * Cannot be used with `distinct()`\n *\n * @method limit\n * @memberOf Query\n * @param {Number} val\n * @see mongodb http://www.mongodb.org/display/DOCS/Advanced+Queries#AdvancedQueries-%7B%7Blimit%28%29%7D%7D\n * @api public\n */\n/**\n * Specifies the skip option.\n *\n * #### Example:\n *\n *     query.skip(100).limit(20)\n *\n * #### Note:\n *\n * Cannot be used with `distinct()`\n *\n * @method skip\n * @memberOf Query\n * @param {Number} val\n * @see mongodb http://www.mongodb.org/display/DOCS/Advanced+Queries#AdvancedQueries-%7B%7Bskip%28%29%7D%7D\n * @api public\n */\n/**\n * Specifies the batchSize option.\n *\n * #### Example:\n *\n *     query.batchSize(100)\n *\n * #### Note:\n *\n * Cannot be used with `distinct()`\n *\n * @method batchSize\n * @memberOf Query\n * @param {Number} val\n * @see mongodb http://www.mongodb.org/display/DOCS/Advanced+Queries#AdvancedQueries-%7B%7BbatchSize%28%29%7D%7D\n * @api public\n */\n/**\n * Specifies the `comment` option.\n *\n * #### Example:\n *\n *     query.comment('login query')\n *\n * #### Note:\n *\n * Cannot be used with `distinct()`\n *\n * @method comment\n * @memberOf Query\n * @param {Number} val\n * @see mongodb http://www.mongodb.org/display/DOCS/Advanced+Queries#AdvancedQueries-%24comment\n * @api public\n */\n\n/*!\n * limit, skip, batchSize, comment\n *\n * Sets these associated options.\n *\n *     query.comment('feed query');\n */\n\n['limit', 'skip', 'batchSize', 'comment'].forEach(function(method) {\n  Query.prototype[method] = function(v) {\n    this._validate(method);\n    this.options[method] = v;\n    return this;\n  };\n});\n\n/**\n * Specifies the maxTimeMS option.\n *\n * #### Example:\n *\n *     query.maxTime(100)\n *     query.maxTimeMS(100)\n *\n * @method maxTime\n * @memberOf Query\n * @param {Number} ms\n * @see mongodb http://docs.mongodb.org/manual/reference/operator/meta/maxTimeMS/#op._S_maxTimeMS\n * @api public\n */\n\nQuery.prototype.maxTime = Query.prototype.maxTimeMS = function(ms) {\n  this._validate('maxTime');\n  this.options.maxTimeMS = ms;\n  return this;\n};\n\n/**\n * Sets query hints.\n *\n * #### Example:\n *\n *     query.hint({ indexA: 1, indexB: -1});\n *     query.hint('indexA_1_indexB_1');\n *\n * #### Note:\n *\n * Cannot be used with `distinct()`\n *\n * @param {Object|string} val a hint object or the index name\n * @return {Query} this\n * @see mongodb http://www.mongodb.org/display/DOCS/Advanced+Queries#AdvancedQueries-%24hint\n * @api public\n */\n\nQuery.prototype.hint = function() {\n  if (0 === arguments.length) return this;\n\n  this._validate('hint');\n\n  const arg = arguments[0];\n  if (utils.isObject(arg)) {\n    const hint = this.options.hint || (this.options.hint = {});\n\n    // must keep object keys in order so don't use Object.keys()\n    for (const k in arg) {\n      hint[k] = arg[k];\n    }\n\n    return this;\n  }\n  if (typeof arg === 'string') {\n    this.options.hint = arg;\n    return this;\n  }\n\n  throw new TypeError('Invalid hint. ' + arg);\n};\n\n/**\n * Requests acknowledgement that this operation has been persisted to MongoDB's\n * on-disk journal.\n * This option is only valid for operations that write to the database:\n *\n * - `deleteOne()`\n * - `deleteMany()`\n * - `findOneAndDelete()`\n * - `findOneAndUpdate()`\n * - `updateOne()`\n * - `updateMany()`\n *\n * Defaults to the `j` value if it is specified in writeConcern options\n *\n * #### Example:\n *\n *     mquery().w(2).j(true).wtimeout(2000);\n *\n * @method j\n * @memberOf Query\n * @instance\n * @param {boolean} val\n * @see mongodb https://docs.mongodb.com/manual/reference/write-concern/#j-option\n * @return {Query} this\n * @api public\n */\n\nQuery.prototype.j = function j(val) {\n  this.options.j = val;\n  return this;\n};\n\n/**\n * Sets the slaveOk option. _Deprecated_ in MongoDB 2.2 in favor of read preferences.\n *\n * #### Example:\n *\n *     query.slaveOk() // true\n *     query.slaveOk(true)\n *     query.slaveOk(false)\n *\n * @deprecated use read() preferences instead if on mongodb >= 2.2\n * @param {Boolean} v defaults to true\n * @see mongodb http://docs.mongodb.org/manual/applications/replication/#read-preference\n * @see read()\n * @return {Query} this\n * @api public\n */\n\nQuery.prototype.slaveOk = function(v) {\n  this.options.slaveOk = arguments.length ? !!v : true;\n  return this;\n};\n\n/**\n * Sets the readPreference option for the query.\n *\n * #### Example:\n *\n *     new Query().read('primary')\n *     new Query().read('p')  // same as primary\n *\n *     new Query().read('primaryPreferred')\n *     new Query().read('pp') // same as primaryPreferred\n *\n *     new Query().read('secondary')\n *     new Query().read('s')  // same as secondary\n *\n *     new Query().read('secondaryPreferred')\n *     new Query().read('sp') // same as secondaryPreferred\n *\n *     new Query().read('nearest')\n *     new Query().read('n')  // same as nearest\n *\n *     // you can also use mongodb.ReadPreference class to also specify tags\n *     new Query().read(mongodb.ReadPreference('secondary', [{ dc:'sf', s: 1 },{ dc:'ma', s: 2 }]))\n *\n *     new Query().setReadPreference('primary') // alias of .read()\n *\n * #### Preferences:\n *\n *     primary - (default)  Read from primary only. Operations will produce an error if primary is unavailable. Cannot be combined with tags.\n *     secondary            Read from secondary if available, otherwise error.\n *     primaryPreferred     Read from primary if available, otherwise a secondary.\n *     secondaryPreferred   Read from a secondary if available, otherwise read from the primary.\n *     nearest              All operations read from among the nearest candidates, but unlike other modes, this option will include both the primary and all secondaries in the random selection.\n *\n * Aliases\n *\n *     p   primary\n *     pp  primaryPreferred\n *     s   secondary\n *     sp  secondaryPreferred\n *     n   nearest\n *\n * Read more about how to use read preferences [here](http://docs.mongodb.org/manual/applications/replication/#read-preference) and [here](http://mongodb.github.com/node-mongodb-native/driver-articles/anintroductionto1_1and2_2.html#read-preferences).\n *\n * @param {String|ReadPreference} pref one of the listed preference options or their aliases\n * @see mongodb http://docs.mongodb.org/manual/applications/replication/#read-preference\n * @see driver http://mongodb.github.com/node-mongodb-native/driver-articles/anintroductionto1_1and2_2.html#read-preferences\n * @return {Query} this\n * @api public\n */\n\nQuery.prototype.read = Query.prototype.setReadPreference = function(pref) {\n  if (arguments.length > 1 && !Query.prototype.read.deprecationWarningIssued) {\n    console.error('Deprecation warning: \\'tags\\' argument is not supported anymore in Query.read() method. Please use mongodb.ReadPreference object instead.');\n    Query.prototype.read.deprecationWarningIssued = true;\n  }\n  this.options.readPreference = utils.readPref(pref);\n  return this;\n};\n\n/**\n * Sets the readConcern option for the query.\n *\n * #### Example:\n *\n *     new Query().readConcern('local')\n *     new Query().readConcern('l')  // same as local\n *\n *     new Query().readConcern('available')\n *     new Query().readConcern('a')  // same as available\n *\n *     new Query().readConcern('majority')\n *     new Query().readConcern('m')  // same as majority\n *\n *     new Query().readConcern('linearizable')\n *     new Query().readConcern('lz') // same as linearizable\n *\n *     new Query().readConcern('snapshot')\n *     new Query().readConcern('s')  // same as snapshot\n *\n *     new Query().r('s') // r is alias of readConcern\n *\n *\n * #### Read Concern Level:\n *\n *     local         MongoDB 3.2+ The query returns from the instance with no guarantee guarantee that the data has been written to a majority of the replica set members (i.e. may be rolled back).\n *     available     MongoDB 3.6+ The query returns from the instance with no guarantee guarantee that the data has been written to a majority of the replica set members (i.e. may be rolled back).\n *     majority      MongoDB 3.2+ The query returns the data that has been acknowledged by a majority of the replica set members. The documents returned by the read operation are durable, even in the event of failure.\n *     linearizable  MongoDB 3.4+ The query returns data that reflects all successful majority-acknowledged writes that completed prior to the start of the read operation. The query may wait for concurrently executing writes to propagate to a majority of replica set members before returning results.\n *     snapshot      MongoDB 4.0+ Only available for operations within multi-document transactions. Upon transaction commit with write concern \"majority\", the transaction operations are guaranteed to have read from a snapshot of majority-committed data.\n *\n * Aliases\n *\n *     l   local\n *     a   available\n *     m   majority\n *     lz  linearizable\n *     s   snapshot\n *\n * Read more about how to use read concern [here](https://docs.mongodb.com/manual/reference/read-concern/).\n *\n * @param {String} level one of the listed read concern level or their aliases\n * @see mongodb https://docs.mongodb.com/manual/reference/read-concern/\n * @return {Query} this\n * @api public\n */\n\nQuery.prototype.readConcern = Query.prototype.r = function(level) {\n  this.options.readConcern = utils.readConcern(level);\n  return this;\n};\n\n/**\n * Sets tailable option.\n *\n * #### Example:\n *\n *     query.tailable() <== true\n *     query.tailable(true)\n *     query.tailable(false)\n *\n * #### Note:\n *\n * Cannot be used with `distinct()`\n *\n * @param {Boolean} v defaults to true\n * @see mongodb http://www.mongodb.org/display/DOCS/Tailable+Cursors\n * @api public\n */\n\nQuery.prototype.tailable = function() {\n  this._validate('tailable');\n\n  this.options.tailable = arguments.length\n    ? !!arguments[0]\n    : true;\n\n  return this;\n};\n\n/**\n * Sets the specified number of `mongod` servers, or tag set of `mongod` servers,\n * that must acknowledge this write before this write is considered successful.\n * This option is only valid for operations that write to the database:\n *\n * - `deleteOne()`\n * - `deleteMany()`\n * - `findOneAndDelete()`\n * - `findOneAndUpdate()`\n * - `updateOne()`\n * - `updateMany()`\n *\n * Defaults to the `w` value if it is specified in writeConcern options\n *\n * #### Example:\n *\n *     mquery().writeConcern(0)\n *     mquery().writeConcern(1)\n *     mquery().writeConcern({ w: 1, j: true, wtimeout: 2000 })\n *     mquery().writeConcern('majority')\n *     mquery().writeConcern('m') // same as majority\n *     mquery().writeConcern('tagSetName') // if the tag set is 'm', use .writeConcern({ w: 'm' }) instead\n *     mquery().w(1) // w is alias of writeConcern\n *\n * @method writeConcern\n * @memberOf Query\n * @instance\n * @param {String|number|object} concern 0 for fire-and-forget, 1 for acknowledged by one server, 'majority' for majority of the replica set, or [any of the more advanced options](https://docs.mongodb.com/manual/reference/write-concern/#w-option).\n * @see mongodb https://docs.mongodb.com/manual/reference/write-concern/#w-option\n * @return {Query} this\n * @api public\n */\n\nQuery.prototype.writeConcern = Query.prototype.w = function writeConcern(concern) {\n  if ('object' === typeof concern) {\n    if ('undefined' !== typeof concern.j) this.options.j = concern.j;\n    if ('undefined' !== typeof concern.w) this.options.w = concern.w;\n    if ('undefined' !== typeof concern.wtimeout) this.options.wtimeout = concern.wtimeout;\n  } else {\n    this.options.w = 'm' === concern ? 'majority' : concern;\n  }\n  return this;\n};\n\n/**\n * Specifies a time limit, in milliseconds, for the write concern.\n * If `ms > 1`, it is maximum amount of time to wait for this write\n * to propagate through the replica set before this operation fails.\n * The default is `0`, which means no timeout.\n *\n * This option is only valid for operations that write to the database:\n *\n * - `deleteOne()`\n * - `deleteMany()`\n * - `findOneAndDelete()`\n * - `findOneAndUpdate()`\n * - `updateOne()`\n * - `updateMany()`\n *\n * Defaults to `wtimeout` value if it is specified in writeConcern\n *\n * #### Example:\n *\n *     mquery().w(2).j(true).wtimeout(2000)\n *\n * @method wtimeout\n * @memberOf Query\n * @instance\n * @param {number} ms number of milliseconds to wait\n * @see mongodb https://docs.mongodb.com/manual/reference/write-concern/#wtimeout\n * @return {Query} this\n * @api public\n */\n\nQuery.prototype.wtimeout = Query.prototype.wTimeout = function wtimeout(ms) {\n  this.options.wtimeout = ms;\n  return this;\n};\n\n/**\n * Merges another Query or conditions object into this one.\n *\n * When a Query is passed, conditions, field selection and options are merged.\n *\n * @param {Query|Object} source\n * @return {Query} this\n */\n\nQuery.prototype.merge = function(source) {\n  if (!source)\n    return this;\n\n  if (!Query.canMerge(source))\n    throw new TypeError('Invalid argument. Expected instanceof mquery or plain object');\n\n  if (source instanceof Query) {\n    // if source has a feature, apply it to ourselves\n\n    if (source._conditions) {\n      utils.merge(this._conditions, source._conditions);\n    }\n\n    if (source._fields) {\n      this._fields || (this._fields = {});\n      utils.merge(this._fields, source._fields);\n    }\n\n    if (source.options) {\n      this.options || (this.options = {});\n      utils.merge(this.options, source.options);\n    }\n\n    if (source._updateDoc) {\n      this._updateDoc || (this._updateDoc = {});\n      utils.mergeClone(this._updateDoc, source._updateDoc);\n    }\n\n    if (source._distinctDoc) {\n      this._distinctDoc = source._distinctDoc;\n    }\n\n    return this;\n  }\n\n  // plain object\n  utils.merge(this._conditions, source);\n\n  return this;\n};\n\n/**\n * Finds documents.\n *\n * #### Example:\n *\n *     query.find()\n *     await query.find()\n *     await query.find({ name: 'Burning Lights' })\n *\n * @param {Object} [criteria] mongodb selector\n * @return {Query} this\n * @api public\n */\n\nQuery.prototype.find = function(criteria) {\n  this.op = 'find';\n\n  if (Query.canMerge(criteria)) {\n    this.merge(criteria);\n  }\n\n  return this;\n};\n\n/**\n * Executes a `find` Query\n * @returns the result\n */\nQuery.prototype._find = async function _find() {\n  const conds = this._conditions;\n  const options = this._optionsForExec();\n\n  if (this.$useProjection) {\n    options.projection = this._fieldsForExec();\n  } else {\n    options.fields = this._fieldsForExec();\n  }\n\n  debug('_find', this._collection.collectionName, conds, options);\n\n  return this._collection.find(conds, options);\n};\n\n/**\n * Returns the query cursor\n *\n * #### Examples:\n *\n *     query.find().cursor();\n *     query.cursor({ name: 'Burning Lights' });\n *\n * @param {Object} [criteria] mongodb selector\n * @return {Object} cursor\n * @api public\n */\n\nQuery.prototype.cursor = function cursor(criteria) {\n  if (this.op) {\n    if (this.op !== 'find') {\n      throw new TypeError('.cursor only support .find method');\n    }\n  } else {\n    this.find(criteria);\n  }\n\n  const conds = this._conditions;\n  const options = this._optionsForExec();\n\n  if (this.$useProjection) {\n    options.projection = this._fieldsForExec();\n  } else {\n    options.fields = this._fieldsForExec();\n  }\n\n  debug('findCursor', this._collection.collectionName, conds, options);\n  return this._collection.findCursor(conds, options);\n};\n\n/**\n * Executes the query as a findOne() operation.\n *\n * #### Example:\n *\n *     query.findOne().where('name', /^Burning/);\n *\n *     query.findOne({ name: /^Burning/ })\n *\n *     await query.findOne({ name: /^Burning/ }); // executes\n *\n * @param {Object|Query} [criteria] mongodb selector\n * @return {Query} this\n * @api public\n */\n\nQuery.prototype.findOne = function(criteria) {\n  this.op = 'findOne';\n\n  if (Query.canMerge(criteria)) {\n    this.merge(criteria);\n  }\n\n  return this;\n};\n\n/**\n * Executes a `findOne` Query\n * @returns the results\n */\nQuery.prototype._findOne = async function _findOne() {\n  const conds = this._conditions;\n  const options = this._optionsForExec();\n\n  if (this.$useProjection) {\n    options.projection = this._fieldsForExec();\n  } else {\n    options.fields = this._fieldsForExec();\n  }\n\n  debug('findOne', this._collection.collectionName, conds, options);\n\n  return this._collection.findOne(conds, options);\n};\n\n/**\n * Exectues the query as a count() operation.\n *\n * #### Example:\n *\n *     query.count().where('color', 'black').exec();\n *\n *     query.count({ color: 'black' })\n *\n *     await query.count({ color: 'black' });\n *\n *     const doc = await query.where('color', 'black').count();\n *     console.log('there are %d kittens', count);\n *\n * @param {Object} [criteria] mongodb selector\n * @return {Query} this\n * @see mongodb http://www.mongodb.org/display/DOCS/Aggregation#Aggregation-Count\n * @api public\n */\n\nQuery.prototype.count = function(criteria) {\n  this.op = 'count';\n  this._validate();\n\n  if (Query.canMerge(criteria)) {\n    this.merge(criteria);\n  }\n\n  return this;\n};\n\n/**\n * Executes a `count` Query\n * @returns the results\n */\nQuery.prototype._count = async function _count() {\n  const conds = this._conditions,\n      options = this._optionsForExec();\n\n  debug('count', this._collection.collectionName, conds, options);\n\n  return this._collection.count(conds, options);\n};\n\n/**\n * Declares or executes a distinct() operation.\n *\n * #### Example:\n *\n *     await distinct(criteria, field)\n *     distinct(criteria, field)\n *     await distinct(field)\n *     distinct(field)\n *     await distinct()\n *     distinct()\n *\n * @param {Object|Query} [criteria]\n * @param {String} [field]\n * @return {Query} this\n * @see mongodb http://www.mongodb.org/display/DOCS/Aggregation#Aggregation-Distinct\n * @api public\n */\n\nQuery.prototype.distinct = function(criteria, field) {\n  this.op = 'distinct';\n  this._validate();\n\n  if (!field && typeof criteria === 'string') {\n    field = criteria;\n    criteria = undefined;\n  }\n\n  if ('string' == typeof field) {\n    this._distinctDoc = field;\n  }\n\n  if (Query.canMerge(criteria)) {\n    this.merge(criteria);\n  }\n\n  return this;\n};\n\n/**\n * Executes a `distinct` Query\n * @returns the results\n */\nQuery.prototype._distinct = async function _distinct() {\n  if (!this._distinctDoc) {\n    throw new Error('No value for `distinct` has been declared');\n  }\n\n  const conds = this._conditions,\n      options = this._optionsForExec();\n\n  debug('distinct', this._collection.collectionName, conds, options);\n\n  return this._collection.distinct(this._distinctDoc, conds, options);\n};\n\n/**\n * Declare and/or execute this query as an `updateMany()` operation. This function will update _all_ documents that match\n * `criteria`, rather than just the first one.\n *\n * _All paths passed that are not $atomic operations will become $set ops._\n *\n * #### Example:\n *\n *     // Update every document whose `title` contains 'test'\n *     mquery().updateMany({ title: /test/ }, { year: 2017 })\n *\n * @param {Object} [criteria]\n * @param {Object} [doc] the update command\n * @param {Object} [options]\n * @return {Query} this\n * @api public\n */\n\nQuery.prototype.updateMany = function updateMany(criteria, doc, options) {\n  if (arguments.length === 1) {\n    doc = criteria;\n    criteria = options = undefined;\n  }\n\n  return _update(this, 'updateMany', criteria, doc, options);\n};\n\n/**\n * Executes a `updateMany` Query\n * @returns the results\n */\nQuery.prototype._updateMany = async function() {\n  return _updateExec(this, 'updateMany');\n};\n\n/**\n * Declare and/or execute this query as an `updateOne()` operation. This function will _always_ update just one document,\n * regardless of the `multi` option.\n *\n * _All paths passed that are not $atomic operations will become $set ops._\n *\n * #### Example:\n *\n *     // Update the first document whose `title` contains 'test'\n *     mquery().updateMany({ title: /test/ }, { year: 2017 })\n *\n * @param {Object} [criteria]\n * @param {Object} [doc] the update command\n * @param {Object} [options]\n * @return {Query} this\n * @api public\n */\n\nQuery.prototype.updateOne = function updateOne(criteria, doc, options) {\n  if (arguments.length === 1) {\n    doc = criteria;\n    criteria = options = undefined;\n  }\n\n  return _update(this, 'updateOne', criteria, doc, options);\n};\n\n/**\n * Executes a `updateOne` Query\n * @returns the results\n */\nQuery.prototype._updateOne = async function() {\n  return _updateExec(this, 'updateOne');\n};\n\n/**\n * Declare and/or execute this query as an `replaceOne()` operation. Similar\n * to `updateOne()`, except `replaceOne()` is not allowed to use atomic\n * modifiers (`$set`, `$push`, etc.). Calling `replaceOne()` will always\n * replace the existing doc.\n *\n * #### Example:\n *\n *     // Replace the document with `_id` 1 with `{ _id: 1, year: 2017 }`\n *     mquery().replaceOne({ _id: 1 }, { year: 2017 })\n *\n * @param {Object} [criteria]\n * @param {Object} [doc] the update command\n * @param {Object} [options]\n * @return {Query} this\n * @api public\n */\n\nQuery.prototype.replaceOne = function replaceOne(criteria, doc, options) {\n  if (arguments.length === 1) {\n    doc = criteria;\n    criteria = options = undefined;\n  }\n\n  this.setOptions({ overwrite: true });\n  return _update(this, 'replaceOne', criteria, doc, options);\n};\n\n/**\n * Executes a `replaceOne` Query\n * @returns the results\n */\nQuery.prototype._replaceOne = async function() {\n  return _updateExec(this, 'replaceOne');\n};\n\n/*!\n * Internal helper for updateMany, updateOne\n */\n\nfunction _update(query, op, criteria, doc, options) {\n  query.op = op;\n\n  if (Query.canMerge(criteria)) {\n    query.merge(criteria);\n  }\n\n  if (doc) {\n    query._mergeUpdate(doc);\n  }\n\n  if (utils.isObject(options)) {\n    // { overwrite: true }\n    query.setOptions(options);\n  }\n\n  return query;\n}\n\n/**\n * Helper for de-duplicating \"update*\" functions\n * @param {Query} query The Query Object (replacement for \"this\")\n * @param {String} op The Operation to be done\n * @returns the results\n */\nasync function _updateExec(query, op) {\n  const options = query._optionsForExec();\n\n  const criteria = query._conditions;\n  const doc = query._updateForExec();\n\n  debug('update', query._collection.collectionName, criteria, doc, options);\n\n  return query._collection[op](criteria, doc, options);\n}\n\n/**\n * Declare and/or execute this query as a `deleteOne()` operation.\n *\n * #### Example:\n *\n *     await mquery(collection).deleteOne({ artist: 'Anne Murray' })\n *\n * @param {Object|Query} [criteria] mongodb selector\n * @return {Query} this\n * @api public\n */\n\nQuery.prototype.deleteOne = function(criteria) {\n  this.op = 'deleteOne';\n\n  if (Query.canMerge(criteria)) {\n    this.merge(criteria);\n  }\n\n  return this;\n};\n\n/**\n * Executes a `deleteOne` Query\n * @returns the results\n */\nQuery.prototype._deleteOne = async function() {\n  const options = this._optionsForExec();\n  delete options.justOne;\n\n  const conds = this._conditions;\n\n  debug('deleteOne', this._collection.collectionName, conds, options);\n\n  return this._collection.deleteOne(conds, options);\n};\n\n/**\n * Declare and/or execute this query as a `deleteMany()` operation. Always deletes\n * _every_ document that matches `criteria`.\n *\n * #### Example:\n *\n *     await mquery(collection).deleteMany({ artist: 'Anne Murray' })\n *\n * @param {Object|Query} [criteria] mongodb selector\n * @return {Query} this\n * @api public\n */\n\nQuery.prototype.deleteMany = function(criteria) {\n  this.op = 'deleteMany';\n\n  if (Query.canMerge(criteria)) {\n    this.merge(criteria);\n  }\n\n  return this;\n};\n\n/**\n * Executes a `deleteMany` Query\n * @returns the results\n */\nQuery.prototype._deleteMany = async function() {\n  const options = this._optionsForExec();\n  delete options.justOne;\n\n  const conds = this._conditions;\n\n  debug('deleteOne', this._collection.collectionName, conds, options);\n\n  return this._collection.deleteMany(conds, options);\n};\n\n/**\n * Issues a mongodb [findAndModify](http://www.mongodb.org/display/DOCS/findAndModify+Command) update command.\n *\n * Finds a matching document, updates it according to the `update` arg, passing any `options`, and returns the found document (if any).\n *\n * #### Available options\n *\n * - `new`: bool - true to return the modified document rather than the original. defaults to true\n * - `upsert`: bool - creates the object if it doesn't exist. defaults to false.\n * - `sort`: if multiple docs are found by the conditions, sets the sort order to choose which doc to update\n *\n * #### Examples:\n *\n *     await query.findOneAndUpdate(conditions, update, options) // executes\n *     query.findOneAndUpdate(conditions, update, options)  // returns Query\n *     await query.findOneAndUpdate(conditions, update) // executes\n *     query.findOneAndUpdate(conditions, update)           // returns Query\n *     await query.findOneAndUpdate(update)             // returns Query\n *     query.findOneAndUpdate(update)                       // returns Query\n *     await query.findOneAndUpdate()                     // executes\n *     query.findOneAndUpdate()                             // returns Query\n *\n * @param {Object|Query} [query]\n * @param {Object} [doc]\n * @param {Object} [options]\n * @see mongodb http://www.mongodb.org/display/DOCS/findAndModify+Command\n * @return {Query} this\n * @api public\n */\n\nQuery.prototype.findOneAndUpdate = function(criteria, doc, options) {\n  this.op = 'findOneAndUpdate';\n  this._validate();\n\n  if (arguments.length === 1) {\n    doc = criteria;\n    criteria = options = undefined;\n  }\n\n  if (Query.canMerge(criteria)) {\n    this.merge(criteria);\n  }\n\n  // apply doc\n  if (doc) {\n    this._mergeUpdate(doc);\n  }\n\n  options && this.setOptions(options);\n\n  return this;\n};\n\n/**\n * Executes a `findOneAndUpdate` Query\n * @returns the results\n */\nQuery.prototype._findOneAndUpdate = async function() {\n  const conds = this._conditions;\n  const update = this._updateForExec();\n  const options = this._optionsForExec();\n\n  return this._collection.findOneAndUpdate(conds, update, options);\n};\n\n/**\n * Issues a mongodb [findAndModify](http://www.mongodb.org/display/DOCS/findAndModify+Command) remove command.\n *\n * Finds a matching document, removes it, returning the found document (if any).\n *\n * #### Available options\n *\n * - `sort`: if multiple docs are found by the conditions, sets the sort order to choose which doc to update\n *\n * #### Examples:\n *\n *     await A.where().findOneAndRemove(conditions, options) // executes\n *     A.where().findOneAndRemove(conditions, options)  // return Query\n *     await A.where().findOneAndRemove(conditions) // executes\n *     A.where().findOneAndRemove(conditions) // returns Query\n *     await A.where().findOneAndRemove()   // executes\n *     A.where().findOneAndRemove()           // returns Query\n *     A.where().findOneAndDelete()           // alias of .findOneAndRemove()\n *\n * @param {Object} [conditions]\n * @param {Object} [options]\n * @return {Query} this\n * @see mongodb http://www.mongodb.org/display/DOCS/findAndModify+Command\n * @api public\n */\n\nQuery.prototype.findOneAndRemove = Query.prototype.findOneAndDelete = function(conditions, options) {\n  this.op = 'findOneAndRemove';\n  this._validate();\n\n  // apply conditions\n  if (Query.canMerge(conditions)) {\n    this.merge(conditions);\n  }\n\n  // apply options\n  options && this.setOptions(options);\n\n  return this;\n};\n\n/**\n * Executes a `findOneAndRemove` Query\n * @returns the results\n */\nQuery.prototype._findOneAndRemove = async function() {\n  const options = this._optionsForExec();\n  const conds = this._conditions;\n\n  return this._collection.findOneAndDelete(conds, options);\n};\n\n/**\n * Add trace function that gets called when the query is executed.\n * The function will be called with (method, queryInfo, query) and\n * should return a callback function which will be called\n * with (err, result, millis) when the query is complete.\n *\n * queryInfo is an object containing: {\n *   collectionName: <name of the collection>,\n *   conditions: <query criteria>,\n *   options: <comment, fields, readPreference, etc>,\n *   doc: [document to update, if applicable]\n * }\n *\n * NOTE: Does not trace stream queries.\n *\n * @param {Function} traceFunction\n * @return {Query} this\n * @api public\n */\nQuery.prototype.setTraceFunction = function(traceFunction) {\n  this._traceFunction = traceFunction;\n  return this;\n};\n\n/**\n * Executes the query\n *\n * #### Examples:\n *\n *     query.exec();\n *     await query.exec();\n *     query.exec('update');\n *     await query.exec('find');\n *\n * @param {String|Function} [operation]\n * @api public\n */\n\nQuery.prototype.exec = async function exec(op) {\n  if (typeof op === 'string') {\n    this.op = op;\n  }\n\n  assert.ok(this.op, 'Missing query type: (find, etc)');\n\n  const fnName = '_' + this.op;\n\n  // better error, because default would list it as \"this[fnName] is not a function\"\n  if (typeof this[fnName] !== 'function') {\n    throw new TypeError(`this[${fnName}] is not a function`);\n  }\n\n  return this[fnName]();\n};\n\n/**\n * Executes the query returning a `Promise` which will be\n * resolved with either the doc(s) or rejected with the error.\n *\n * @param {Function} [resolve]\n * @param {Function} [reject]\n * @return {Promise}\n * @api public\n */\n\nQuery.prototype.then = async function(res, rej) {\n  return this.exec().then(res, rej);\n};\n\n/**\n * Returns a cursor for the given `find` query.\n *\n * @throws Error if operation is not a find\n * @returns {Cursor} MongoDB driver cursor\n */\n\nQuery.prototype.cursor = function() {\n  if ('find' != this.op)\n    throw new Error('cursor() is only available for find');\n\n  const conds = this._conditions;\n\n  const options = this._optionsForExec();\n  if (this.$useProjection) {\n    options.projection = this._fieldsForExec();\n  } else {\n    options.fields = this._fieldsForExec();\n  }\n\n  debug('cursor', this._collection.collectionName, conds, options);\n\n  return this._collection.findCursor(conds, options);\n};\n\n/**\n * Determines if field selection has been made.\n *\n * @return {Boolean}\n * @api public\n */\n\nQuery.prototype.selected = function selected() {\n  return !!(this._fields && Object.keys(this._fields).length > 0);\n};\n\n/**\n * Determines if inclusive field selection has been made.\n *\n *     query.selectedInclusively() // false\n *     query.select('name')\n *     query.selectedInclusively() // true\n *     query.selectedExlusively() // false\n *\n * @returns {Boolean}\n */\n\nQuery.prototype.selectedInclusively = function selectedInclusively() {\n  if (!this._fields) return false;\n\n  const keys = Object.keys(this._fields);\n  if (0 === keys.length) return false;\n\n  for (let i = 0; i < keys.length; ++i) {\n    const key = keys[i];\n    if (0 === this._fields[key]) return false;\n    if (this._fields[key] &&\n        typeof this._fields[key] === 'object' &&\n        this._fields[key].$meta) {\n      return false;\n    }\n  }\n\n  return true;\n};\n\n/**\n * Determines if exclusive field selection has been made.\n *\n *     query.selectedExlusively() // false\n *     query.select('-name')\n *     query.selectedExlusively() // true\n *     query.selectedInclusively() // false\n *\n * @returns {Boolean}\n */\n\nQuery.prototype.selectedExclusively = function selectedExclusively() {\n  if (!this._fields) return false;\n\n  const keys = Object.keys(this._fields);\n  if (0 === keys.length) return false;\n\n  for (let i = 0; i < keys.length; ++i) {\n    const key = keys[i];\n    if (0 === this._fields[key]) return true;\n  }\n\n  return false;\n};\n\n/**\n * Merges `doc` with the current update object.\n *\n * @param {Object} doc\n */\n\nQuery.prototype._mergeUpdate = function(doc) {\n  if (!this._updateDoc) this._updateDoc = {};\n  if (doc instanceof Query) {\n    if (doc._updateDoc) {\n      utils.mergeClone(this._updateDoc, doc._updateDoc);\n    }\n  } else {\n    utils.mergeClone(this._updateDoc, doc);\n  }\n};\n\n/**\n * Returns default options.\n *\n * @return {Object}\n * @api private\n */\n\nQuery.prototype._optionsForExec = function() {\n  const options = utils.clone(this.options);\n  return options;\n};\n\n/**\n * Returns fields selection for this query.\n *\n * @return {Object}\n * @api private\n */\n\nQuery.prototype._fieldsForExec = function() {\n  return utils.clone(this._fields);\n};\n\n/**\n * Return an update document with corrected $set operations.\n *\n * @api private\n */\n\nQuery.prototype._updateForExec = function() {\n  const update = utils.clone(this._updateDoc);\n  const ops = utils.keys(update);\n  const ret = {};\n\n  for (const op of ops) {\n    if (this.options.overwrite) {\n      ret[op] = update[op];\n      continue;\n    }\n\n    if ('$' !== op[0]) {\n      // fix up $set sugar\n      if (!ret.$set) {\n        if (update.$set) {\n          ret.$set = update.$set;\n        } else {\n          ret.$set = {};\n        }\n      }\n      ret.$set[op] = update[op];\n      if (!~ops.indexOf('$set')) ops.push('$set');\n    } else if ('$set' === op) {\n      if (!ret.$set) {\n        ret[op] = update[op];\n      }\n    } else {\n      ret[op] = update[op];\n    }\n  }\n\n  this._compiledUpdate = ret;\n  return ret;\n};\n\n/**\n * Make sure _path is set.\n *\n * @parmam {String} method\n */\n\nQuery.prototype._ensurePath = function(method) {\n  if (!this._path) {\n    const msg = method + '() must be used after where() '\n                     + 'when called with these arguments';\n    throw new Error(msg);\n  }\n};\n\n/*!\n * Permissions\n */\n\nQuery.permissions = __webpack_require__(/*! ./permissions */ \"../server/node_modules/mquery/lib/permissions.js\");\n\nQuery._isPermitted = function(a, b) {\n  const denied = Query.permissions[b];\n  if (!denied) return true;\n  return true !== denied[a];\n};\n\nQuery.prototype._validate = function(action) {\n  let fail;\n  let validator;\n\n  if (undefined === action) {\n\n    validator = Query.permissions[this.op];\n    if ('function' != typeof validator) return true;\n\n    fail = validator(this);\n\n  } else if (!Query._isPermitted(action, this.op)) {\n    fail = action;\n  }\n\n  if (fail) {\n    throw new Error(fail + ' cannot be used with ' + this.op);\n  }\n};\n\n/**\n * Determines if `conds` can be merged using `mquery().merge()`\n *\n * @param {Object} conds\n * @return {Boolean}\n */\n\nQuery.canMerge = function(conds) {\n  return conds instanceof Query || utils.isObject(conds);\n};\n\n/**\n * Set a trace function that will get called whenever a\n * query is executed.\n *\n * See `setTraceFunction()` for details.\n *\n * @param {Object} conds\n * @return {Boolean}\n */\nQuery.setGlobalTraceFunction = function(traceFunction) {\n  Query.traceFunction = traceFunction;\n};\n\n/*!\n * Exports.\n */\n\nQuery.utils = utils;\nQuery.env = __webpack_require__(/*! ./env */ \"../server/node_modules/mquery/lib/env.js\");\nQuery.Collection = __webpack_require__(/*! ./collection */ \"../server/node_modules/mquery/lib/collection/index.js\");\nQuery.BaseCollection = __webpack_require__(/*! ./collection/collection */ \"../server/node_modules/mquery/lib/collection/collection.js\");\nmodule.exports = exports = Query;\n\n// TODO\n// test utils\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tcXVlcnkvbGliL21xdWVyeS5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBO0FBQ0E7O0FBRUEsZUFBZSxtQkFBTyxDQUFDLHNCQUFRO0FBQy9CLGFBQWEsbUJBQU8sQ0FBQyxrQkFBTTtBQUMzQixjQUFjLG1CQUFPLENBQUMsMkRBQVM7QUFDL0IsY0FBYyxtQkFBTyxDQUFDLDRFQUFPOztBQUU3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLGdCQUFnQjtBQUMvQywwQkFBMEIsOEJBQThCO0FBQ3hEO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLGlDQUFpQzs7QUFFakM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0JBQW9CLG9DQUFvQztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsbUJBQW1CO0FBQy9DLDBCQUEwQixtREFBbUQ7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGVBQWU7QUFDdEM7QUFDQSxZQUFZLE9BQU87QUFDbkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFF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O0FBQ25CLFdBQVcsUUFBUTtBQUNuQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsZUFBZTtBQUMxQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixZQUFZLE9BQU87QUFDbkI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Es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O0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHNCQUFzQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGVBQWU7QUFDMUIsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSw2REFBNkQ7O0FBRTdEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBWSxtQkFBTyxDQUFDLHVEQUFPO0FBQzNCLG1CQUFtQixtQkFBTyxDQUFDLDJFQUFjO0FBQ3pDLHVCQUF1QixtQkFBTyxDQUFDLDJGQUF5QjtBQUN4RDs7QUFFQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2xpZW50Ly4uL3NlcnZlci9ub2RlX21vZHVsZXMvbXF1ZXJ5L2xpYi9tcXVlcnkuanM/YmNhMCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogRGVwZW5kZW5jaWVzXG4gKi9cblxuY29uc3QgYXNzZXJ0ID0gcmVxdWlyZSgnYXNzZXJ0Jyk7XG5jb25zdCB1dGlsID0gcmVxdWlyZSgndXRpbCcpO1xuY29uc3QgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG5jb25zdCBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ21xdWVyeScpO1xuXG4vKipcbiAqIFF1ZXJ5IGNvbnN0cnVjdG9yIHVzZWQgZm9yIGJ1aWxkaW5nIHF1ZXJpZXMuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICB2YXIgcXVlcnkgPSBuZXcgUXVlcnkoeyBuYW1lOiAnbXF1ZXJ5JyB9KTtcbiAqICAgICBxdWVyeS5zZXRPcHRpb25zKHsgY29sbGVjdGlvbjogbW9kdWxlQ29sbGVjdGlvbiB9KVxuICogICAgIGF3YWl0IHF1ZXJ5LndoZXJlKCdhZ2UnKS5ndGUoMjEpLmV4ZWMoKTtcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gW2NyaXRlcmlhXSBjcml0ZXJpYSBmb3IgdGhlIHF1ZXJ5IE9SIHRoZSBjb2xsZWN0aW9uIGluc3RhbmNlIHRvIHVzZVxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBRdWVyeShjcml0ZXJpYSwgb3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUXVlcnkpKVxuICAgIHJldHVybiBuZXcgUXVlcnkoY3JpdGVyaWEsIG9wdGlvbnMpO1xuXG4gIGNvbnN0IHByb3RvID0gdGhpcy5jb25zdHJ1Y3Rvci5wcm90b3R5cGU7XG5cbiAgdGhpcy5vcCA9IHByb3RvLm9wIHx8IHVuZGVmaW5lZDtcblxuICB0aGlzLm9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBwcm90by5vcHRpb25zKTtcblxuICB0aGlzLl9jb25kaXRpb25zID0gcHJvdG8uX2NvbmRpdGlvbnNcbiAgICA/IHV0aWxzLmNsb25lKHByb3RvLl9jb25kaXRpb25zKVxuICAgIDoge307XG5cbiAgdGhpcy5fZmllbGRzID0gcHJvdG8uX2ZpZWxkc1xuICAgID8gdXRpbHMuY2xvbmUocHJvdG8uX2ZpZWxkcylcbiAgICA6IHVuZGVmaW5lZDtcblxuICB0aGlzLl91cGRhdGVEb2MgPSBwcm90by5fdXBkYXRlRG9jXG4gICAgPyB1dGlscy5jbG9uZShwcm90by5fdXBkYXRlRG9jKVxuICAgIDogdW5kZWZpbmVkO1xuXG4gIHRoaXMuX3BhdGggPSBwcm90by5fcGF0aCB8fCB1bmRlZmluZWQ7XG4gIHRoaXMuX2Rpc3RpbmN0RG9jID0gcHJvdG8uX2Rpc3RpbmN0RG9jIHx8IHVuZGVmaW5lZDtcbiAgdGhpcy5fY29sbGVjdGlvbiA9IHByb3RvLl9jb2xsZWN0aW9uIHx8IHVuZGVmaW5lZDtcbiAgdGhpcy5fdHJhY2VGdW5jdGlvbiA9IHByb3RvLl90cmFjZUZ1bmN0aW9uIHx8IHVuZGVmaW5lZDtcblxuICBpZiAob3B0aW9ucykge1xuICAgIHRoaXMuc2V0T3B0aW9ucyhvcHRpb25zKTtcbiAgfVxuXG4gIGlmIChjcml0ZXJpYSkge1xuICAgIHRoaXMuZmluZChjcml0ZXJpYSk7XG4gIH1cbn1cblxuLyoqXG4gKiBUaGlzIGlzIGEgcGFyYW1ldGVyIHRoYXQgdGhlIHVzZXIgY2FuIHNldCB3aGljaCBkZXRlcm1pbmVzIGlmIG1xdWVyeVxuICogdXNlcyAkd2l0aGluIG9yICRnZW9XaXRoaW4gZm9yIHF1ZXJpZXMuIEl0IGRlZmF1bHRzIHRvIHRydWUgd2hpY2hcbiAqIG1lYW5zICRnZW9XaXRoaW4gd2lsbCBiZSB1c2VkLiBJZiB1c2luZyBNb25nb0RCIDwgMi40IHlvdSBzaG91bGRcbiAqIHNldCB0aGlzIHRvIGZhbHNlLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKiBAcHJvcGVydHkgdXNlJGdlb1dpdGhpblxuICovXG5cbmxldCAkd2l0aGluQ21kID0gJyRnZW9XaXRoaW4nO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KFF1ZXJ5LCAndXNlJGdlb1dpdGhpbicsIHtcbiAgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuICR3aXRoaW5DbWQgPT0gJyRnZW9XaXRoaW4nOyB9LFxuICBzZXQ6IGZ1bmN0aW9uKHYpIHtcbiAgICBpZiAodHJ1ZSA9PT0gdikge1xuICAgICAgLy8gbW9uZ29kYiA+PSAyLjRcbiAgICAgICR3aXRoaW5DbWQgPSAnJGdlb1dpdGhpbic7XG4gICAgfSBlbHNlIHtcbiAgICAgICR3aXRoaW5DbWQgPSAnJHdpdGhpbic7XG4gICAgfVxuICB9XG59KTtcblxuLyoqXG4gKiBDb252ZXJ0cyB0aGlzIHF1ZXJ5IHRvIGEgY29uc3RydWN0b3IgZnVuY3Rpb24gd2l0aCBhbGwgYXJndW1lbnRzIGFuZCBvcHRpb25zIHJldGFpbmVkLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgLy8gQ3JlYXRlIGEgcXVlcnkgdGhhdCB3aWxsIHJlYWQgZG9jdW1lbnRzIHdpdGggYSBcInZpZGVvXCIgY2F0ZWdvcnkgZnJvbVxuICogICAgIC8vIGBhQ29sbGVjdGlvbmAgb24gdGhlIHByaW1hcnkgbm9kZSBpbiB0aGUgcmVwbGljYS1zZXQgdW5sZXNzIGl0IGlzIGRvd24sXG4gKiAgICAgLy8gaW4gd2hpY2ggY2FzZSB3ZSdsbCByZWFkIGZyb20gYSBzZWNvbmRhcnkgbm9kZS5cbiAqICAgICB2YXIgcXVlcnkgPSBtcXVlcnkoeyBjYXRlZ29yeTogJ3ZpZGVvJyB9KVxuICogICAgIHF1ZXJ5LnNldE9wdGlvbnMoeyBjb2xsZWN0aW9uOiBhQ29sbGVjdGlvbiwgcmVhZDogJ3ByaW1hcnlQcmVmZXJyZWQnIH0pO1xuICpcbiAqICAgICAvLyBjcmVhdGUgYSBjb25zdHJ1Y3RvciBiYXNlZCBvZmYgdGhlc2Ugc2V0dGluZ3NcbiAqICAgICB2YXIgVmlkZW8gPSBxdWVyeS50b0NvbnN0cnVjdG9yKCk7XG4gKlxuICogICAgIC8vIFZpZGVvIGlzIG5vdyBhIHN1YmNsYXNzIG9mIG1xdWVyeSgpIGFuZCB3b3JrcyB0aGUgc2FtZSB3YXkgYnV0IHdpdGggdGhlXG4gKiAgICAgLy8gZGVmYXVsdCBxdWVyeSBwYXJhbWV0ZXJzIGFuZCBvcHRpb25zIHNldC5cbiAqXG4gKiAgICAgLy8gcnVuIGEgcXVlcnkgd2l0aCB0aGUgcHJldmlvdXMgc2V0dGluZ3MgYnV0IGZpbHRlciBmb3IgbW92aWVzIHdpdGggbmFtZXNcbiAqICAgICAvLyB0aGF0IHN0YXJ0IHdpdGggXCJMaWZlXCIuXG4gKiAgICAgVmlkZW8oKS53aGVyZSh7IG5hbWU6IC9eTGlmZS8gfSkuZXhlYyhjYik7XG4gKlxuICogQHJldHVybiB7UXVlcnl9IG5ldyBRdWVyeVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5RdWVyeS5wcm90b3R5cGUudG9Db25zdHJ1Y3RvciA9IGZ1bmN0aW9uIHRvQ29uc3RydWN0b3IoKSB7XG4gIGZ1bmN0aW9uIEN1c3RvbVF1ZXJ5KGNyaXRlcmlhLCBvcHRpb25zKSB7XG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEN1c3RvbVF1ZXJ5KSlcbiAgICAgIHJldHVybiBuZXcgQ3VzdG9tUXVlcnkoY3JpdGVyaWEsIG9wdGlvbnMpO1xuICAgIFF1ZXJ5LmNhbGwodGhpcywgY3JpdGVyaWEsIG9wdGlvbnMpO1xuICB9XG5cbiAgdXRpbHMuaW5oZXJpdHMoQ3VzdG9tUXVlcnksIFF1ZXJ5KTtcblxuICAvLyBzZXQgaW5oZXJpdGVkIGRlZmF1bHRzXG4gIGNvbnN0IHAgPSBDdXN0b21RdWVyeS5wcm90b3R5cGU7XG5cbiAgcC5vcHRpb25zID0ge307XG4gIHAuc2V0T3B0aW9ucyh0aGlzLm9wdGlvbnMpO1xuXG4gIHAub3AgPSB0aGlzLm9wO1xuICBwLl9jb25kaXRpb25zID0gdXRpbHMuY2xvbmUodGhpcy5fY29uZGl0aW9ucyk7XG4gIHAuX2ZpZWxkcyA9IHV0aWxzLmNsb25lKHRoaXMuX2ZpZWxkcyk7XG4gIHAuX3VwZGF0ZURvYyA9IHV0aWxzLmNsb25lKHRoaXMuX3VwZGF0ZURvYyk7XG4gIHAuX3BhdGggPSB0aGlzLl9wYXRoO1xuICBwLl9kaXN0aW5jdERvYyA9IHRoaXMuX2Rpc3RpbmN0RG9jO1xuICBwLl9jb2xsZWN0aW9uID0gdGhpcy5fY29sbGVjdGlvbjtcbiAgcC5fdHJhY2VGdW5jdGlvbiA9IHRoaXMuX3RyYWNlRnVuY3Rpb247XG5cbiAgcmV0dXJuIEN1c3RvbVF1ZXJ5O1xufTtcblxuLyoqXG4gKiBTZXRzIHF1ZXJ5IG9wdGlvbnMuXG4gKlxuICogIyMjIyBPcHRpb25zOlxuICpcbiAqIC0gW3RhaWxhYmxlXShodHRwOi8vd3d3Lm1vbmdvZGIub3JnL2Rpc3BsYXkvRE9DUy9UYWlsYWJsZStDdXJzb3JzKSAqXG4gKiAtIFtzb3J0XShodHRwOi8vd3d3Lm1vbmdvZGIub3JnL2Rpc3BsYXkvRE9DUy9BZHZhbmNlZCtRdWVyaWVzI0FkdmFuY2VkUXVlcmllcy0lN0IlN0Jzb3J0KFxcKSU3RCU3RCkgKlxuICogLSBbbGltaXRdKGh0dHA6Ly93d3cubW9uZ29kYi5vcmcvZGlzcGxheS9ET0NTL0FkdmFuY2VkK1F1ZXJpZXMjQWR2YW5jZWRRdWVyaWVzLSU3QiU3QmxpbWl0JTI4JTI5JTdEJTdEKSAqXG4gKiAtIFtza2lwXShodHRwOi8vd3d3Lm1vbmdvZGIub3JnL2Rpc3BsYXkvRE9DUy9BZHZhbmNlZCtRdWVyaWVzI0FkdmFuY2VkUXVlcmllcy0lN0IlN0Jza2lwJTI4JTI5JTdEJTdEKSAqXG4gKiAtIFttYXhUaW1lXShodHRwOi8vZG9jcy5tb25nb2RiLm9yZy9tYW51YWwvcmVmZXJlbmNlL29wZXJhdG9yL21ldGEvbWF4VGltZU1TLyNvcC5fU19tYXhUaW1lTVMpICpcbiAqIC0gW2JhdGNoU2l6ZV0oaHR0cDovL3d3dy5tb25nb2RiLm9yZy9kaXNwbGF5L0RPQ1MvQWR2YW5jZWQrUXVlcmllcyNBZHZhbmNlZFF1ZXJpZXMtJTdCJTdCYmF0Y2hTaXplJTI4JTI5JTdEJTdEKSAqXG4gKiAtIFtjb21tZW50XShodHRwOi8vd3d3Lm1vbmdvZGIub3JnL2Rpc3BsYXkvRE9DUy9BZHZhbmNlZCtRdWVyaWVzI0FkdmFuY2VkUXVlcmllcy0lMjRjb21tZW50KSAqXG4gKiAtIFtoaW50XShodHRwOi8vd3d3Lm1vbmdvZGIub3JnL2Rpc3BsYXkvRE9DUy9BZHZhbmNlZCtRdWVyaWVzI0FkdmFuY2VkUXVlcmllcy0lMjRoaW50KSAqXG4gKiAtIFtzbGF2ZU9rXShodHRwOi8vZG9jcy5tb25nb2RiLm9yZy9tYW51YWwvYXBwbGljYXRpb25zL3JlcGxpY2F0aW9uLyNyZWFkLXByZWZlcmVuY2UpICpcbiAqIC0gW3NhZmVdKGh0dHA6Ly93d3cubW9uZ29kYi5vcmcvZGlzcGxheS9ET0NTL2dldExhc3RFcnJvcitDb21tYW5kKVxuICogLSBjb2xsZWN0aW9uIHRoZSBjb2xsZWN0aW9uIHRvIHF1ZXJ5IGFnYWluc3RcbiAqXG4gKiBfKiBkZW5vdGVzIGEgcXVlcnkgaGVscGVyIG1ldGhvZCBpcyBhbHNvIGF2YWlsYWJsZV9cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5RdWVyeS5wcm90b3R5cGUuc2V0T3B0aW9ucyA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgaWYgKCEob3B0aW9ucyAmJiB1dGlscy5pc09iamVjdChvcHRpb25zKSkpXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgLy8gc2V0IGFyYml0cmFyeSBvcHRpb25zXG4gIGNvbnN0IG1ldGhvZHMgPSB1dGlscy5rZXlzKG9wdGlvbnMpO1xuICBsZXQgbWV0aG9kO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbWV0aG9kcy5sZW5ndGg7ICsraSkge1xuICAgIG1ldGhvZCA9IG1ldGhvZHNbaV07XG5cbiAgICAvLyB1c2UgbWV0aG9kcyBpZiBleGlzdCAoc2FmZXIgb3B0aW9uIG1hbmlwdWxhdGlvbilcbiAgICBpZiAoJ2Z1bmN0aW9uJyA9PSB0eXBlb2YgdGhpc1ttZXRob2RdKSB7XG4gICAgICBjb25zdCBhcmdzID0gQXJyYXkuaXNBcnJheShvcHRpb25zW21ldGhvZF0pXG4gICAgICAgID8gb3B0aW9uc1ttZXRob2RdXG4gICAgICAgIDogW29wdGlvbnNbbWV0aG9kXV07XG4gICAgICB0aGlzW21ldGhvZF0uYXBwbHkodGhpcywgYXJncyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMub3B0aW9uc1ttZXRob2RdID0gb3B0aW9uc1ttZXRob2RdO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZXRzIHRoaXMgUXVlcnlzIGNvbGxlY3Rpb24uXG4gKlxuICogQHBhcmFtIHtDb2xsZWN0aW9ufSBjb2xsXG4gKiBAcmV0dXJuIHtRdWVyeX0gdGhpc1xuICovXG5cblF1ZXJ5LnByb3RvdHlwZS5jb2xsZWN0aW9uID0gZnVuY3Rpb24gY29sbGVjdGlvbihjb2xsKSB7XG4gIHRoaXMuX2NvbGxlY3Rpb24gPSBuZXcgUXVlcnkuQ29sbGVjdGlvbihjb2xsKTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQWRkcyBhIGNvbGxhdGlvbiB0byB0aGlzIG9wIChNb25nb0RCIDMuNCBhbmQgdXApXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBxdWVyeS5maW5kKCkuY29sbGF0aW9uKHsgbG9jYWxlOiBcImVuX1VTXCIsIHN0cmVuZ3RoOiAxIH0pXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbHVlXG4gKiBAcmV0dXJuIHtRdWVyeX0gdGhpc1xuICogQHNlZSBNb25nb0RCIGRvY3MgaHR0cHM6Ly9kb2NzLm1vbmdvZGIuY29tL21hbnVhbC9yZWZlcmVuY2UvbWV0aG9kL2N1cnNvci5jb2xsYXRpb24vI2N1cnNvci5jb2xsYXRpb25cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUXVlcnkucHJvdG90eXBlLmNvbGxhdGlvbiA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gIHRoaXMub3B0aW9ucy5jb2xsYXRpb24gPSB2YWx1ZTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNwZWNpZmllcyBhIGAkd2hlcmVgIGNvbmRpdGlvblxuICpcbiAqIFVzZSBgJHdoZXJlYCB3aGVuIHlvdSBuZWVkIHRvIHNlbGVjdCBkb2N1bWVudHMgdXNpbmcgYSBKYXZhU2NyaXB0IGV4cHJlc3Npb24uXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBxdWVyeS4kd2hlcmUoJ3RoaXMuY29tbWVudHMubGVuZ3RoID4gMTAgfHwgdGhpcy5uYW1lLmxlbmd0aCA+IDUnKVxuICpcbiAqICAgICBxdWVyeS4kd2hlcmUoZnVuY3Rpb24gKCkge1xuICogICAgICAgcmV0dXJuIHRoaXMuY29tbWVudHMubGVuZ3RoID4gMTAgfHwgdGhpcy5uYW1lLmxlbmd0aCA+IDU7XG4gKiAgICAgfSlcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ3xGdW5jdGlvbn0ganMgamF2YXNjcmlwdCBzdHJpbmcgb3IgZnVuY3Rpb25cbiAqIEByZXR1cm4ge1F1ZXJ5fSB0aGlzXG4gKiBAbWVtYmVyT2YgUXVlcnlcbiAqIEBtZXRob2QgJHdoZXJlXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblF1ZXJ5LnByb3RvdHlwZS4kd2hlcmUgPSBmdW5jdGlvbihqcykge1xuICB0aGlzLl9jb25kaXRpb25zLiR3aGVyZSA9IGpzO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU3BlY2lmaWVzIGEgYHBhdGhgIGZvciB1c2Ugd2l0aCBjaGFpbmluZy5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIC8vIGluc3RlYWQgb2Ygd3JpdGluZzpcbiAqICAgICBhd2FpdCBVc2VyLmZpbmQoe2FnZTogeyRndGU6IDIxLCAkbHRlOiA2NX19KTtcbiAqXG4gKiAgICAgLy8gd2UgY2FuIGluc3RlYWQgd3JpdGU6XG4gKiAgICAgVXNlci53aGVyZSgnYWdlJykuZ3RlKDIxKS5sdGUoNjUpO1xuICpcbiAqICAgICAvLyBwYXNzaW5nIHF1ZXJ5IGNvbmRpdGlvbnMgaXMgcGVybWl0dGVkXG4gKiAgICAgVXNlci5maW5kKCkud2hlcmUoeyBuYW1lOiAndm9uZGVyZnVsJyB9KVxuICpcbiAqICAgICAvLyBjaGFpbmluZ1xuICogICAgIGF3YWl0IFVzZXJcbiAqICAgICAgIC53aGVyZSgnYWdlJykuZ3RlKDIxKS5sdGUoNjUpXG4gKiAgICAgICAud2hlcmUoJ25hbWUnLCAvXnZvbmRlcmZ1bC9pKVxuICogICAgICAgLndoZXJlKCdmcmllbmRzJykuc2xpY2UoMTApXG4gKiAgICAgICAuZXhlYygpXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IFtwYXRoXVxuICogQHBhcmFtIHtPYmplY3R9IFt2YWxdXG4gKiBAcmV0dXJuIHtRdWVyeX0gdGhpc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5RdWVyeS5wcm90b3R5cGUud2hlcmUgPSBmdW5jdGlvbigpIHtcbiAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcztcbiAgaWYgKCF0aGlzLm9wKSB0aGlzLm9wID0gJ2ZpbmQnO1xuXG4gIGNvbnN0IHR5cGUgPSB0eXBlb2YgYXJndW1lbnRzWzBdO1xuXG4gIGlmICgnc3RyaW5nJyA9PSB0eXBlKSB7XG4gICAgdGhpcy5fcGF0aCA9IGFyZ3VtZW50c1swXTtcblxuICAgIGlmICgyID09PSBhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICB0aGlzLl9jb25kaXRpb25zW3RoaXMuX3BhdGhdID0gYXJndW1lbnRzWzFdO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgaWYgKCdvYmplY3QnID09IHR5cGUgJiYgIUFycmF5LmlzQXJyYXkoYXJndW1lbnRzWzBdKSkge1xuICAgIHJldHVybiB0aGlzLm1lcmdlKGFyZ3VtZW50c1swXSk7XG4gIH1cblxuICB0aHJvdyBuZXcgVHlwZUVycm9yKCdwYXRoIG11c3QgYmUgYSBzdHJpbmcgb3Igb2JqZWN0Jyk7XG59O1xuXG4vKipcbiAqIFNwZWNpZmllcyB0aGUgY29tcGxlbWVudGFyeSBjb21wYXJpc29uIHZhbHVlIGZvciBwYXRocyBzcGVjaWZpZWQgd2l0aCBgd2hlcmUoKWBcbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIFVzZXIud2hlcmUoJ2FnZScpLmVxdWFscyg0OSk7XG4gKlxuICogICAgIC8vIGlzIHRoZSBzYW1lIGFzXG4gKlxuICogICAgIFVzZXIud2hlcmUoJ2FnZScsIDQ5KTtcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsXG4gKiBAcmV0dXJuIHtRdWVyeX0gdGhpc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5RdWVyeS5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gZXF1YWxzKHZhbCkge1xuICB0aGlzLl9lbnN1cmVQYXRoKCdlcXVhbHMnKTtcbiAgY29uc3QgcGF0aCA9IHRoaXMuX3BhdGg7XG4gIHRoaXMuX2NvbmRpdGlvbnNbcGF0aF0gPSB2YWw7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTcGVjaWZpZXMgdGhlIGNvbXBsZW1lbnRhcnkgY29tcGFyaXNvbiB2YWx1ZSBmb3IgcGF0aHMgc3BlY2lmaWVkIHdpdGggYHdoZXJlKClgXG4gKiBUaGlzIGlzIGFsaWFzIG9mIGBlcXVhbHNgXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBVc2VyLndoZXJlKCdhZ2UnKS5lcSg0OSk7XG4gKlxuICogICAgIC8vIGlzIHRoZSBzYW1lIGFzXG4gKlxuICogICAgIFVzZXIuc2hlcmUoJ2FnZScpLmVxdWFscyg0OSk7XG4gKlxuICogICAgIC8vIGlzIHRoZSBzYW1lIGFzXG4gKlxuICogICAgIFVzZXIud2hlcmUoJ2FnZScsIDQ5KTtcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsXG4gKiBAcmV0dXJuIHtRdWVyeX0gdGhpc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5RdWVyeS5wcm90b3R5cGUuZXEgPSBmdW5jdGlvbiBlcSh2YWwpIHtcbiAgdGhpcy5fZW5zdXJlUGF0aCgnZXEnKTtcbiAgY29uc3QgcGF0aCA9IHRoaXMuX3BhdGg7XG4gIHRoaXMuX2NvbmRpdGlvbnNbcGF0aF0gPSB2YWw7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTcGVjaWZpZXMgYXJndW1lbnRzIGZvciBhbiBgJG9yYCBjb25kaXRpb24uXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBxdWVyeS5vcihbeyBjb2xvcjogJ3JlZCcgfSwgeyBzdGF0dXM6ICdlbWVyZ2VuY3knIH1dKVxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IGFycmF5IG9mIGNvbmRpdGlvbnNcbiAqIEByZXR1cm4ge1F1ZXJ5fSB0aGlzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblF1ZXJ5LnByb3RvdHlwZS5vciA9IGZ1bmN0aW9uIG9yKGFycmF5KSB7XG4gIGNvbnN0IG9yID0gdGhpcy5fY29uZGl0aW9ucy4kb3IgfHwgKHRoaXMuX2NvbmRpdGlvbnMuJG9yID0gW10pO1xuICBpZiAoIUFycmF5LmlzQXJyYXkoYXJyYXkpKSBhcnJheSA9IFthcnJheV07XG4gIG9yLnB1c2guYXBwbHkob3IsIGFycmF5KTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNwZWNpZmllcyBhcmd1bWVudHMgZm9yIGEgYCRub3JgIGNvbmRpdGlvbi5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIHF1ZXJ5Lm5vcihbeyBjb2xvcjogJ2dyZWVuJyB9LCB7IHN0YXR1czogJ29rJyB9XSlcbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBhcnJheSBvZiBjb25kaXRpb25zXG4gKiBAcmV0dXJuIHtRdWVyeX0gdGhpc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5RdWVyeS5wcm90b3R5cGUubm9yID0gZnVuY3Rpb24gbm9yKGFycmF5KSB7XG4gIGNvbnN0IG5vciA9IHRoaXMuX2NvbmRpdGlvbnMuJG5vciB8fCAodGhpcy5fY29uZGl0aW9ucy4kbm9yID0gW10pO1xuICBpZiAoIUFycmF5LmlzQXJyYXkoYXJyYXkpKSBhcnJheSA9IFthcnJheV07XG4gIG5vci5wdXNoLmFwcGx5KG5vciwgYXJyYXkpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU3BlY2lmaWVzIGFyZ3VtZW50cyBmb3IgYSBgJGFuZGAgY29uZGl0aW9uLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgcXVlcnkuYW5kKFt7IGNvbG9yOiAnZ3JlZW4nIH0sIHsgc3RhdHVzOiAnb2snIH1dKVxuICpcbiAqIEBzZWUgJGFuZCBodHRwOi8vZG9jcy5tb25nb2RiLm9yZy9tYW51YWwvcmVmZXJlbmNlL29wZXJhdG9yL2FuZC9cbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IGFycmF5IG9mIGNvbmRpdGlvbnNcbiAqIEByZXR1cm4ge1F1ZXJ5fSB0aGlzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblF1ZXJ5LnByb3RvdHlwZS5hbmQgPSBmdW5jdGlvbiBhbmQoYXJyYXkpIHtcbiAgY29uc3QgYW5kID0gdGhpcy5fY29uZGl0aW9ucy4kYW5kIHx8ICh0aGlzLl9jb25kaXRpb25zLiRhbmQgPSBbXSk7XG4gIGlmICghQXJyYXkuaXNBcnJheShhcnJheSkpIGFycmF5ID0gW2FycmF5XTtcbiAgYW5kLnB1c2guYXBwbHkoYW5kLCBhcnJheSk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTcGVjaWZpZXMgYSAkZ3QgcXVlcnkgY29uZGl0aW9uLlxuICpcbiAqIFdoZW4gY2FsbGVkIHdpdGggb25lIGFyZ3VtZW50LCB0aGUgbW9zdCByZWNlbnQgcGF0aCBwYXNzZWQgdG8gYHdoZXJlKClgIGlzIHVzZWQuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBUaGluZy5maW5kKCkud2hlcmUoJ2FnZScpLmd0KDIxKVxuICpcbiAqICAgICAvLyBvclxuICogICAgIFRoaW5nLmZpbmQoKS5ndCgnYWdlJywgMjEpXG4gKlxuICogQG1ldGhvZCBndFxuICogQG1lbWJlck9mIFF1ZXJ5XG4gKiBAcGFyYW0ge1N0cmluZ30gW3BhdGhdXG4gKiBAcGFyYW0ge051bWJlcn0gdmFsXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbi8qKlxuICogU3BlY2lmaWVzIGEgJGd0ZSBxdWVyeSBjb25kaXRpb24uXG4gKlxuICogV2hlbiBjYWxsZWQgd2l0aCBvbmUgYXJndW1lbnQsIHRoZSBtb3N0IHJlY2VudCBwYXRoIHBhc3NlZCB0byBgd2hlcmUoKWAgaXMgdXNlZC5cbiAqXG4gKiBAbWV0aG9kIGd0ZVxuICogQG1lbWJlck9mIFF1ZXJ5XG4gKiBAcGFyYW0ge1N0cmluZ30gW3BhdGhdXG4gKiBAcGFyYW0ge051bWJlcn0gdmFsXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbi8qKlxuICogU3BlY2lmaWVzIGEgJGx0IHF1ZXJ5IGNvbmRpdGlvbi5cbiAqXG4gKiBXaGVuIGNhbGxlZCB3aXRoIG9uZSBhcmd1bWVudCwgdGhlIG1vc3QgcmVjZW50IHBhdGggcGFzc2VkIHRvIGB3aGVyZSgpYCBpcyB1c2VkLlxuICpcbiAqIEBtZXRob2QgbHRcbiAqIEBtZW1iZXJPZiBRdWVyeVxuICogQHBhcmFtIHtTdHJpbmd9IFtwYXRoXVxuICogQHBhcmFtIHtOdW1iZXJ9IHZhbFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG4vKipcbiAqIFNwZWNpZmllcyBhICRsdGUgcXVlcnkgY29uZGl0aW9uLlxuICpcbiAqIFdoZW4gY2FsbGVkIHdpdGggb25lIGFyZ3VtZW50LCB0aGUgbW9zdCByZWNlbnQgcGF0aCBwYXNzZWQgdG8gYHdoZXJlKClgIGlzIHVzZWQuXG4gKlxuICogQG1ldGhvZCBsdGVcbiAqIEBtZW1iZXJPZiBRdWVyeVxuICogQHBhcmFtIHtTdHJpbmd9IFtwYXRoXVxuICogQHBhcmFtIHtOdW1iZXJ9IHZhbFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG4vKipcbiAqIFNwZWNpZmllcyBhICRuZSBxdWVyeSBjb25kaXRpb24uXG4gKlxuICogV2hlbiBjYWxsZWQgd2l0aCBvbmUgYXJndW1lbnQsIHRoZSBtb3N0IHJlY2VudCBwYXRoIHBhc3NlZCB0byBgd2hlcmUoKWAgaXMgdXNlZC5cbiAqXG4gKiBAbWV0aG9kIG5lXG4gKiBAbWVtYmVyT2YgUXVlcnlcbiAqIEBwYXJhbSB7U3RyaW5nfSBbcGF0aF1cbiAqIEBwYXJhbSB7TnVtYmVyfSB2YWxcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuLyoqXG4gKiBTcGVjaWZpZXMgYW4gJGluIHF1ZXJ5IGNvbmRpdGlvbi5cbiAqXG4gKiBXaGVuIGNhbGxlZCB3aXRoIG9uZSBhcmd1bWVudCwgdGhlIG1vc3QgcmVjZW50IHBhdGggcGFzc2VkIHRvIGB3aGVyZSgpYCBpcyB1c2VkLlxuICpcbiAqIEBtZXRob2QgaW5cbiAqIEBtZW1iZXJPZiBRdWVyeVxuICogQHBhcmFtIHtTdHJpbmd9IFtwYXRoXVxuICogQHBhcmFtIHtOdW1iZXJ9IHZhbFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG4vKipcbiAqIFNwZWNpZmllcyBhbiAkbmluIHF1ZXJ5IGNvbmRpdGlvbi5cbiAqXG4gKiBXaGVuIGNhbGxlZCB3aXRoIG9uZSBhcmd1bWVudCwgdGhlIG1vc3QgcmVjZW50IHBhdGggcGFzc2VkIHRvIGB3aGVyZSgpYCBpcyB1c2VkLlxuICpcbiAqIEBtZXRob2QgbmluXG4gKiBAbWVtYmVyT2YgUXVlcnlcbiAqIEBwYXJhbSB7U3RyaW5nfSBbcGF0aF1cbiAqIEBwYXJhbSB7TnVtYmVyfSB2YWxcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuLyoqXG4gKiBTcGVjaWZpZXMgYW4gJGFsbCBxdWVyeSBjb25kaXRpb24uXG4gKlxuICogV2hlbiBjYWxsZWQgd2l0aCBvbmUgYXJndW1lbnQsIHRoZSBtb3N0IHJlY2VudCBwYXRoIHBhc3NlZCB0byBgd2hlcmUoKWAgaXMgdXNlZC5cbiAqXG4gKiBAbWV0aG9kIGFsbFxuICogQG1lbWJlck9mIFF1ZXJ5XG4gKiBAcGFyYW0ge1N0cmluZ30gW3BhdGhdXG4gKiBAcGFyYW0ge051bWJlcn0gdmFsXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbi8qKlxuICogU3BlY2lmaWVzIGEgJHNpemUgcXVlcnkgY29uZGl0aW9uLlxuICpcbiAqIFdoZW4gY2FsbGVkIHdpdGggb25lIGFyZ3VtZW50LCB0aGUgbW9zdCByZWNlbnQgcGF0aCBwYXNzZWQgdG8gYHdoZXJlKClgIGlzIHVzZWQuXG4gKlxuICogQG1ldGhvZCBzaXplXG4gKiBAbWVtYmVyT2YgUXVlcnlcbiAqIEBwYXJhbSB7U3RyaW5nfSBbcGF0aF1cbiAqIEBwYXJhbSB7TnVtYmVyfSB2YWxcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuLyoqXG4gKiBTcGVjaWZpZXMgYSAkcmVnZXggcXVlcnkgY29uZGl0aW9uLlxuICpcbiAqIFdoZW4gY2FsbGVkIHdpdGggb25lIGFyZ3VtZW50LCB0aGUgbW9zdCByZWNlbnQgcGF0aCBwYXNzZWQgdG8gYHdoZXJlKClgIGlzIHVzZWQuXG4gKlxuICogQG1ldGhvZCByZWdleFxuICogQG1lbWJlck9mIFF1ZXJ5XG4gKiBAcGFyYW0ge1N0cmluZ30gW3BhdGhdXG4gKiBAcGFyYW0ge1N0cmluZ3xSZWdFeHB9IHZhbFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG4vKipcbiAqIFNwZWNpZmllcyBhICRtYXhEaXN0YW5jZSBxdWVyeSBjb25kaXRpb24uXG4gKlxuICogV2hlbiBjYWxsZWQgd2l0aCBvbmUgYXJndW1lbnQsIHRoZSBtb3N0IHJlY2VudCBwYXRoIHBhc3NlZCB0byBgd2hlcmUoKWAgaXMgdXNlZC5cbiAqXG4gKiBAbWV0aG9kIG1heERpc3RhbmNlXG4gKiBAbWVtYmVyT2YgUXVlcnlcbiAqIEBwYXJhbSB7U3RyaW5nfSBbcGF0aF1cbiAqIEBwYXJhbSB7TnVtYmVyfSB2YWxcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuLyohXG4gKiBndCwgZ3RlLCBsdCwgbHRlLCBuZSwgaW4sIG5pbiwgYWxsLCByZWdleCwgc2l6ZSwgbWF4RGlzdGFuY2VcbiAqXG4gKiAgICAgVGhpbmcud2hlcmUoJ3R5cGUnKS5uaW4oYXJyYXkpXG4gKi9cblxuJ2d0IGd0ZSBsdCBsdGUgbmUgaW4gbmluIGFsbCByZWdleCBzaXplIG1heERpc3RhbmNlIG1pbkRpc3RhbmNlJy5zcGxpdCgnICcpLmZvckVhY2goZnVuY3Rpb24oJGNvbmRpdGlvbmFsKSB7XG4gIFF1ZXJ5LnByb3RvdHlwZVskY29uZGl0aW9uYWxdID0gZnVuY3Rpb24oKSB7XG4gICAgbGV0IHBhdGgsIHZhbDtcblxuICAgIGlmICgxID09PSBhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICB0aGlzLl9lbnN1cmVQYXRoKCRjb25kaXRpb25hbCk7XG4gICAgICB2YWwgPSBhcmd1bWVudHNbMF07XG4gICAgICBwYXRoID0gdGhpcy5fcGF0aDtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsID0gYXJndW1lbnRzWzFdO1xuICAgICAgcGF0aCA9IGFyZ3VtZW50c1swXTtcbiAgICB9XG5cbiAgICBjb25zdCBjb25kcyA9IHRoaXMuX2NvbmRpdGlvbnNbcGF0aF0gPT09IG51bGwgfHwgdHlwZW9mIHRoaXMuX2NvbmRpdGlvbnNbcGF0aF0gPT09ICdvYmplY3QnID9cbiAgICAgIHRoaXMuX2NvbmRpdGlvbnNbcGF0aF0gOlxuICAgICAgKHRoaXMuX2NvbmRpdGlvbnNbcGF0aF0gPSB7fSk7XG4gICAgY29uZHNbJyQnICsgJGNvbmRpdGlvbmFsXSA9IHZhbDtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbn0pO1xuXG4vKipcbiAqIFNwZWNpZmllcyBhIGAkbW9kYCBjb25kaXRpb25cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gW3BhdGhdXG4gKiBAcGFyYW0ge051bWJlcn0gdmFsXG4gKiBAcmV0dXJuIHtRdWVyeX0gdGhpc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5RdWVyeS5wcm90b3R5cGUubW9kID0gZnVuY3Rpb24oKSB7XG4gIGxldCB2YWwsIHBhdGg7XG5cbiAgaWYgKDEgPT09IGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICB0aGlzLl9lbnN1cmVQYXRoKCdtb2QnKTtcbiAgICB2YWwgPSBhcmd1bWVudHNbMF07XG4gICAgcGF0aCA9IHRoaXMuX3BhdGg7XG4gIH0gZWxzZSBpZiAoMiA9PT0gYXJndW1lbnRzLmxlbmd0aCAmJiAhQXJyYXkuaXNBcnJheShhcmd1bWVudHNbMV0pKSB7XG4gICAgdGhpcy5fZW5zdXJlUGF0aCgnbW9kJyk7XG4gICAgdmFsID0gW2FyZ3VtZW50c1swXSwgYXJndW1lbnRzWzFdXTtcbiAgICBwYXRoID0gdGhpcy5fcGF0aDtcbiAgfSBlbHNlIGlmICgzID09PSBhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgdmFsID0gW2FyZ3VtZW50c1sxXSwgYXJndW1lbnRzWzJdXTtcbiAgICBwYXRoID0gYXJndW1lbnRzWzBdO1xuICB9IGVsc2Uge1xuICAgIHZhbCA9IGFyZ3VtZW50c1sxXTtcbiAgICBwYXRoID0gYXJndW1lbnRzWzBdO1xuICB9XG5cbiAgY29uc3QgY29uZHMgPSB0aGlzLl9jb25kaXRpb25zW3BhdGhdIHx8ICh0aGlzLl9jb25kaXRpb25zW3BhdGhdID0ge30pO1xuICBjb25kcy4kbW9kID0gdmFsO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU3BlY2lmaWVzIGFuIGAkZXhpc3RzYCBjb25kaXRpb25cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIC8vIHsgbmFtZTogeyAkZXhpc3RzOiB0cnVlIH19XG4gKiAgICAgVGhpbmcud2hlcmUoJ25hbWUnKS5leGlzdHMoKVxuICogICAgIFRoaW5nLndoZXJlKCduYW1lJykuZXhpc3RzKHRydWUpXG4gKiAgICAgVGhpbmcuZmluZCgpLmV4aXN0cygnbmFtZScpXG4gKlxuICogICAgIC8vIHsgbmFtZTogeyAkZXhpc3RzOiBmYWxzZSB9fVxuICogICAgIFRoaW5nLndoZXJlKCduYW1lJykuZXhpc3RzKGZhbHNlKTtcbiAqICAgICBUaGluZy5maW5kKCkuZXhpc3RzKCduYW1lJywgZmFsc2UpO1xuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBbcGF0aF1cbiAqIEBwYXJhbSB7TnVtYmVyfSB2YWxcbiAqIEByZXR1cm4ge1F1ZXJ5fSB0aGlzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblF1ZXJ5LnByb3RvdHlwZS5leGlzdHMgPSBmdW5jdGlvbigpIHtcbiAgbGV0IHBhdGgsIHZhbDtcblxuICBpZiAoMCA9PT0gYXJndW1lbnRzLmxlbmd0aCkge1xuICAgIHRoaXMuX2Vuc3VyZVBhdGgoJ2V4aXN0cycpO1xuICAgIHBhdGggPSB0aGlzLl9wYXRoO1xuICAgIHZhbCA9IHRydWU7XG4gIH0gZWxzZSBpZiAoMSA9PT0gYXJndW1lbnRzLmxlbmd0aCkge1xuICAgIGlmICgnYm9vbGVhbicgPT09IHR5cGVvZiBhcmd1bWVudHNbMF0pIHtcbiAgICAgIHRoaXMuX2Vuc3VyZVBhdGgoJ2V4aXN0cycpO1xuICAgICAgcGF0aCA9IHRoaXMuX3BhdGg7XG4gICAgICB2YWwgPSBhcmd1bWVudHNbMF07XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhdGggPSBhcmd1bWVudHNbMF07XG4gICAgICB2YWwgPSB0cnVlO1xuICAgIH1cbiAgfSBlbHNlIGlmICgyID09PSBhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgcGF0aCA9IGFyZ3VtZW50c1swXTtcbiAgICB2YWwgPSBhcmd1bWVudHNbMV07XG4gIH1cblxuICBjb25zdCBjb25kcyA9IHRoaXMuX2NvbmRpdGlvbnNbcGF0aF0gfHwgKHRoaXMuX2NvbmRpdGlvbnNbcGF0aF0gPSB7fSk7XG4gIGNvbmRzLiRleGlzdHMgPSB2YWw7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTcGVjaWZpZXMgYW4gYCRlbGVtTWF0Y2hgIGNvbmRpdGlvblxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgcXVlcnkuZWxlbU1hdGNoKCdjb21tZW50JywgeyBhdXRob3I6ICdhdXRvYm90Jywgdm90ZXM6IHskZ3RlOiA1fX0pXG4gKlxuICogICAgIHF1ZXJ5LndoZXJlKCdjb21tZW50JykuZWxlbU1hdGNoKHsgYXV0aG9yOiAnYXV0b2JvdCcsIHZvdGVzOiB7JGd0ZTogNX19KVxuICpcbiAqICAgICBxdWVyeS5lbGVtTWF0Y2goJ2NvbW1lbnQnLCBmdW5jdGlvbiAoZWxlbSkge1xuICogICAgICAgZWxlbS53aGVyZSgnYXV0aG9yJykuZXF1YWxzKCdhdXRvYm90Jyk7XG4gKiAgICAgICBlbGVtLndoZXJlKCd2b3RlcycpLmd0ZSg1KTtcbiAqICAgICB9KVxuICpcbiAqICAgICBxdWVyeS53aGVyZSgnY29tbWVudCcpLmVsZW1NYXRjaChmdW5jdGlvbiAoZWxlbSkge1xuICogICAgICAgZWxlbS53aGVyZSh7IGF1dGhvcjogJ2F1dG9ib3QnIH0pO1xuICogICAgICAgZWxlbS53aGVyZSgndm90ZXMnKS5ndGUoNSk7XG4gKiAgICAgfSlcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ3xPYmplY3R8RnVuY3Rpb259IHBhdGhcbiAqIEBwYXJhbSB7T2JqZWN0fEZ1bmN0aW9ufSBjcml0ZXJpYVxuICogQHJldHVybiB7UXVlcnl9IHRoaXNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUXVlcnkucHJvdG90eXBlLmVsZW1NYXRjaCA9IGZ1bmN0aW9uKCkge1xuICBpZiAobnVsbCA9PSBhcmd1bWVudHNbMF0pXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBhcmd1bWVudCcpO1xuXG4gIGxldCBmbiwgcGF0aCwgY3JpdGVyaWE7XG5cbiAgaWYgKCdmdW5jdGlvbicgPT09IHR5cGVvZiBhcmd1bWVudHNbMF0pIHtcbiAgICB0aGlzLl9lbnN1cmVQYXRoKCdlbGVtTWF0Y2gnKTtcbiAgICBwYXRoID0gdGhpcy5fcGF0aDtcbiAgICBmbiA9IGFyZ3VtZW50c1swXTtcbiAgfSBlbHNlIGlmICh1dGlscy5pc09iamVjdChhcmd1bWVudHNbMF0pKSB7XG4gICAgdGhpcy5fZW5zdXJlUGF0aCgnZWxlbU1hdGNoJyk7XG4gICAgcGF0aCA9IHRoaXMuX3BhdGg7XG4gICAgY3JpdGVyaWEgPSBhcmd1bWVudHNbMF07XG4gIH0gZWxzZSBpZiAoJ2Z1bmN0aW9uJyA9PT0gdHlwZW9mIGFyZ3VtZW50c1sxXSkge1xuICAgIHBhdGggPSBhcmd1bWVudHNbMF07XG4gICAgZm4gPSBhcmd1bWVudHNbMV07XG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzWzFdICYmIHV0aWxzLmlzT2JqZWN0KGFyZ3VtZW50c1sxXSkpIHtcbiAgICBwYXRoID0gYXJndW1lbnRzWzBdO1xuICAgIGNyaXRlcmlhID0gYXJndW1lbnRzWzFdO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgYXJndW1lbnQnKTtcbiAgfVxuXG4gIGlmIChmbikge1xuICAgIGNyaXRlcmlhID0gbmV3IFF1ZXJ5O1xuICAgIGZuKGNyaXRlcmlhKTtcbiAgICBjcml0ZXJpYSA9IGNyaXRlcmlhLl9jb25kaXRpb25zO1xuICB9XG5cbiAgY29uc3QgY29uZHMgPSB0aGlzLl9jb25kaXRpb25zW3BhdGhdIHx8ICh0aGlzLl9jb25kaXRpb25zW3BhdGhdID0ge30pO1xuICBjb25kcy4kZWxlbU1hdGNoID0gY3JpdGVyaWE7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLy8gU3BhdGlhbCBxdWVyaWVzXG5cbi8qKlxuICogU3VnYXIgZm9yIGdlby1zcGF0aWFsIHF1ZXJpZXMuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBxdWVyeS53aXRoaW4oKS5ib3goKVxuICogICAgIHF1ZXJ5LndpdGhpbigpLmNpcmNsZSgpXG4gKiAgICAgcXVlcnkud2l0aGluKCkuZ2VvbWV0cnkoKVxuICpcbiAqICAgICBxdWVyeS53aGVyZSgnbG9jJykud2l0aGluKHsgY2VudGVyOiBbNTAsNTBdLCByYWRpdXM6IDEwLCB1bmlxdWU6IHRydWUsIHNwaGVyaWNhbDogdHJ1ZSB9KTtcbiAqICAgICBxdWVyeS53aGVyZSgnbG9jJykud2l0aGluKHsgYm94OiBbWzQwLjczLCAtNzMuOV0sIFs0MC43LCAtNzMuOTg4XV0gfSk7XG4gKiAgICAgcXVlcnkud2hlcmUoJ2xvYycpLndpdGhpbih7IHBvbHlnb246IFtbXSxbXSxbXSxbXV0gfSk7XG4gKlxuICogICAgIHF1ZXJ5LndoZXJlKCdsb2MnKS53aXRoaW4oW10sIFtdLCBbXSkgLy8gcG9seWdvblxuICogICAgIHF1ZXJ5LndoZXJlKCdsb2MnKS53aXRoaW4oW10sIFtdKSAvLyBib3hcbiAqICAgICBxdWVyeS53aGVyZSgnbG9jJykud2l0aGluKHsgdHlwZTogJ0xpbmVTdHJpbmcnLCBjb29yZGluYXRlczogWy4uLl0gfSk7IC8vIGdlb21ldHJ5XG4gKlxuICogIyMjIyBOb3RlOlxuICpcbiAqIE11c3QgYmUgdXNlZCBhZnRlciBgd2hlcmUoKWAuXG4gKlxuICogQG1lbWJlck9mIFF1ZXJ5XG4gKiBAcmV0dXJuIHtRdWVyeX0gdGhpc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5RdWVyeS5wcm90b3R5cGUud2l0aGluID0gZnVuY3Rpb24gd2l0aGluKCkge1xuICAvLyBvcGluaW9uYXRlZCwgbXVzdCBiZSB1c2VkIGFmdGVyIHdoZXJlXG4gIHRoaXMuX2Vuc3VyZVBhdGgoJ3dpdGhpbicpO1xuICB0aGlzLl9nZW9Db21wYXJpc29uID0gJHdpdGhpbkNtZDtcblxuICBpZiAoMCA9PT0gYXJndW1lbnRzLmxlbmd0aCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgaWYgKDIgPT09IGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICByZXR1cm4gdGhpcy5ib3guYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfSBlbHNlIGlmICgyIDwgYXJndW1lbnRzLmxlbmd0aCkge1xuICAgIHJldHVybiB0aGlzLnBvbHlnb24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIGNvbnN0IGFyZWEgPSBhcmd1bWVudHNbMF07XG5cbiAgaWYgKCFhcmVhKVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgYXJndW1lbnQnKTtcblxuICBpZiAoYXJlYS5jZW50ZXIpXG4gICAgcmV0dXJuIHRoaXMuY2lyY2xlKGFyZWEpO1xuXG4gIGlmIChhcmVhLmJveClcbiAgICByZXR1cm4gdGhpcy5ib3guYXBwbHkodGhpcywgYXJlYS5ib3gpO1xuXG4gIGlmIChhcmVhLnBvbHlnb24pXG4gICAgcmV0dXJuIHRoaXMucG9seWdvbi5hcHBseSh0aGlzLCBhcmVhLnBvbHlnb24pO1xuXG4gIGlmIChhcmVhLnR5cGUgJiYgYXJlYS5jb29yZGluYXRlcylcbiAgICByZXR1cm4gdGhpcy5nZW9tZXRyeShhcmVhKTtcblxuICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIGFyZ3VtZW50Jyk7XG59O1xuXG4vKipcbiAqIFNwZWNpZmllcyBhICRib3ggY29uZGl0aW9uXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICB2YXIgbG93ZXJMZWZ0ID0gWzQwLjczMDgzLCAtNzMuOTk3NTZdXG4gKiAgICAgdmFyIHVwcGVyUmlnaHQ9IFs0MC43NDE0MDQsICAtNzMuOTg4MTM1XVxuICpcbiAqICAgICBxdWVyeS53aGVyZSgnbG9jJykud2l0aGluKCkuYm94KGxvd2VyTGVmdCwgdXBwZXJSaWdodClcbiAqICAgICBxdWVyeS5ib3goJ2xvYycsIGxvd2VyTGVmdCwgdXBwZXJSaWdodCApXG4gKlxuICogQHNlZSBodHRwOi8vd3d3Lm1vbmdvZGIub3JnL2Rpc3BsYXkvRE9DUy9HZW9zcGF0aWFsK0luZGV4aW5nXG4gKiBAc2VlIFF1ZXJ5I3dpdGhpbiAjcXVlcnlfUXVlcnktd2l0aGluXG4gKiBAcGFyYW0ge1N0cmluZ30gcGF0aFxuICogQHBhcmFtIHtPYmplY3R9IHZhbFxuICogQHJldHVybiB7UXVlcnl9IHRoaXNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUXVlcnkucHJvdG90eXBlLmJveCA9IGZ1bmN0aW9uKCkge1xuICBsZXQgcGF0aCwgYm94O1xuXG4gIGlmICgzID09PSBhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgLy8gYm94KCdsb2MnLCBbXSwgW10pXG4gICAgcGF0aCA9IGFyZ3VtZW50c1swXTtcbiAgICBib3ggPSBbYXJndW1lbnRzWzFdLCBhcmd1bWVudHNbMl1dO1xuICB9IGVsc2UgaWYgKDIgPT09IGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAvLyBib3goW10sIFtdKVxuICAgIHRoaXMuX2Vuc3VyZVBhdGgoJ2JveCcpO1xuICAgIHBhdGggPSB0aGlzLl9wYXRoO1xuICAgIGJveCA9IFthcmd1bWVudHNbMF0sIGFyZ3VtZW50c1sxXV07XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBhcmd1bWVudCcpO1xuICB9XG5cbiAgY29uc3QgY29uZHMgPSB0aGlzLl9jb25kaXRpb25zW3BhdGhdIHx8ICh0aGlzLl9jb25kaXRpb25zW3BhdGhdID0ge30pO1xuICBjb25kc1t0aGlzLl9nZW9Db21wYXJpc29uIHx8ICR3aXRoaW5DbWRdID0geyAkYm94OiBib3ggfTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNwZWNpZmllcyBhICRwb2x5Z29uIGNvbmRpdGlvblxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgcXVlcnkud2hlcmUoJ2xvYycpLndpdGhpbigpLnBvbHlnb24oWzEwLDIwXSwgWzEzLCAyNV0sIFs3LDE1XSlcbiAqICAgICBxdWVyeS5wb2x5Z29uKCdsb2MnLCBbMTAsMjBdLCBbMTMsIDI1XSwgWzcsMTVdKVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfEFycmF5fSBbcGF0aF1cbiAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBbdmFsXVxuICogQHJldHVybiB7UXVlcnl9IHRoaXNcbiAqIEBzZWUgaHR0cDovL3d3dy5tb25nb2RiLm9yZy9kaXNwbGF5L0RPQ1MvR2Vvc3BhdGlhbCtJbmRleGluZ1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5RdWVyeS5wcm90b3R5cGUucG9seWdvbiA9IGZ1bmN0aW9uKCkge1xuICBsZXQgdmFsLCBwYXRoO1xuXG4gIGlmICgnc3RyaW5nJyA9PSB0eXBlb2YgYXJndW1lbnRzWzBdKSB7XG4gICAgLy8gcG9seWdvbignbG9jJywgW10sW10sW10pXG4gICAgdmFsID0gQXJyYXkuZnJvbShhcmd1bWVudHMpO1xuICAgIHBhdGggPSB2YWwuc2hpZnQoKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBwb2x5Z29uKFtdLFtdLFtdKVxuICAgIHRoaXMuX2Vuc3VyZVBhdGgoJ3BvbHlnb24nKTtcbiAgICBwYXRoID0gdGhpcy5fcGF0aDtcbiAgICB2YWwgPSBBcnJheS5mcm9tKGFyZ3VtZW50cyk7XG4gIH1cblxuICBjb25zdCBjb25kcyA9IHRoaXMuX2NvbmRpdGlvbnNbcGF0aF0gfHwgKHRoaXMuX2NvbmRpdGlvbnNbcGF0aF0gPSB7fSk7XG4gIGNvbmRzW3RoaXMuX2dlb0NvbXBhcmlzb24gfHwgJHdpdGhpbkNtZF0gPSB7ICRwb2x5Z29uOiB2YWwgfTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNwZWNpZmllcyBhICRjZW50ZXIgb3IgJGNlbnRlclNwaGVyZSBjb25kaXRpb24uXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICB2YXIgYXJlYSA9IHsgY2VudGVyOiBbNTAsIDUwXSwgcmFkaXVzOiAxMCwgdW5pcXVlOiB0cnVlIH1cbiAqICAgICBxdWVyeS53aGVyZSgnbG9jJykud2l0aGluKCkuY2lyY2xlKGFyZWEpXG4gKiAgICAgcXVlcnkuY2VudGVyKCdsb2MnLCBhcmVhKTtcbiAqXG4gKiAgICAgLy8gZm9yIHNwaGVyaWNhbCBjYWxjdWxhdGlvbnNcbiAqICAgICB2YXIgYXJlYSA9IHsgY2VudGVyOiBbNTAsIDUwXSwgcmFkaXVzOiAxMCwgdW5pcXVlOiB0cnVlLCBzcGhlcmljYWw6IHRydWUgfVxuICogICAgIHF1ZXJ5LndoZXJlKCdsb2MnKS53aXRoaW4oKS5jaXJjbGUoYXJlYSlcbiAqICAgICBxdWVyeS5jZW50ZXIoJ2xvYycsIGFyZWEpO1xuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBbcGF0aF1cbiAqIEBwYXJhbSB7T2JqZWN0fSBhcmVhXG4gKiBAcmV0dXJuIHtRdWVyeX0gdGhpc1xuICogQHNlZSBodHRwOi8vd3d3Lm1vbmdvZGIub3JnL2Rpc3BsYXkvRE9DUy9HZW9zcGF0aWFsK0luZGV4aW5nXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblF1ZXJ5LnByb3RvdHlwZS5jaXJjbGUgPSBmdW5jdGlvbigpIHtcbiAgbGV0IHBhdGgsIHZhbDtcblxuICBpZiAoMSA9PT0gYXJndW1lbnRzLmxlbmd0aCkge1xuICAgIHRoaXMuX2Vuc3VyZVBhdGgoJ2NpcmNsZScpO1xuICAgIHBhdGggPSB0aGlzLl9wYXRoO1xuICAgIHZhbCA9IGFyZ3VtZW50c1swXTtcbiAgfSBlbHNlIGlmICgyID09PSBhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgcGF0aCA9IGFyZ3VtZW50c1swXTtcbiAgICB2YWwgPSBhcmd1bWVudHNbMV07XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBhcmd1bWVudCcpO1xuICB9XG5cbiAgaWYgKCEoJ3JhZGl1cycgaW4gdmFsICYmIHZhbC5jZW50ZXIpKVxuICAgIHRocm93IG5ldyBFcnJvcignY2VudGVyIGFuZCByYWRpdXMgYXJlIHJlcXVpcmVkJyk7XG5cbiAgY29uc3QgY29uZHMgPSB0aGlzLl9jb25kaXRpb25zW3BhdGhdIHx8ICh0aGlzLl9jb25kaXRpb25zW3BhdGhdID0ge30pO1xuXG4gIGNvbnN0IHR5cGUgPSB2YWwuc3BoZXJpY2FsXG4gICAgPyAnJGNlbnRlclNwaGVyZSdcbiAgICA6ICckY2VudGVyJztcblxuICBjb25zdCB3S2V5ID0gdGhpcy5fZ2VvQ29tcGFyaXNvbiB8fCAkd2l0aGluQ21kO1xuICBjb25kc1t3S2V5XSA9IHt9O1xuICBjb25kc1t3S2V5XVt0eXBlXSA9IFt2YWwuY2VudGVyLCB2YWwucmFkaXVzXTtcblxuICBpZiAoJ3VuaXF1ZScgaW4gdmFsKVxuICAgIGNvbmRzW3dLZXldLiR1bmlxdWVEb2NzID0gISF2YWwudW5pcXVlO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTcGVjaWZpZXMgYSBgJG5lYXJgIG9yIGAkbmVhclNwaGVyZWAgY29uZGl0aW9uXG4gKlxuICogVGhlc2Ugb3BlcmF0b3JzIHJldHVybiBkb2N1bWVudHMgc29ydGVkIGJ5IGRpc3RhbmNlLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgcXVlcnkud2hlcmUoJ2xvYycpLm5lYXIoeyBjZW50ZXI6IFsxMCwgMTBdIH0pO1xuICogICAgIHF1ZXJ5LndoZXJlKCdsb2MnKS5uZWFyKHsgY2VudGVyOiBbMTAsIDEwXSwgbWF4RGlzdGFuY2U6IDUgfSk7XG4gKiAgICAgcXVlcnkud2hlcmUoJ2xvYycpLm5lYXIoeyBjZW50ZXI6IFsxMCwgMTBdLCBtYXhEaXN0YW5jZTogNSwgc3BoZXJpY2FsOiB0cnVlIH0pO1xuICogICAgIHF1ZXJ5Lm5lYXIoJ2xvYycsIHsgY2VudGVyOiBbMTAsIDEwXSwgbWF4RGlzdGFuY2U6IDUgfSk7XG4gKiAgICAgcXVlcnkubmVhcih7IGNlbnRlcjogeyB0eXBlOiAnUG9pbnQnLCBjb29yZGluYXRlczogWy4uXSB9fSlcbiAqICAgICBxdWVyeS5uZWFyKCkuZ2VvbWV0cnkoeyB0eXBlOiAnUG9pbnQnLCBjb29yZGluYXRlczogWy4uXSB9KVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBbcGF0aF1cbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWxcbiAqIEByZXR1cm4ge1F1ZXJ5fSB0aGlzXG4gKiBAc2VlIGh0dHA6Ly93d3cubW9uZ29kYi5vcmcvZGlzcGxheS9ET0NTL0dlb3NwYXRpYWwrSW5kZXhpbmdcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUXVlcnkucHJvdG90eXBlLm5lYXIgPSBmdW5jdGlvbiBuZWFyKCkge1xuICBsZXQgcGF0aCwgdmFsO1xuXG4gIHRoaXMuX2dlb0NvbXBhcmlzb24gPSAnJG5lYXInO1xuXG4gIGlmICgwID09PSBhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0gZWxzZSBpZiAoMSA9PT0gYXJndW1lbnRzLmxlbmd0aCkge1xuICAgIHRoaXMuX2Vuc3VyZVBhdGgoJ25lYXInKTtcbiAgICBwYXRoID0gdGhpcy5fcGF0aDtcbiAgICB2YWwgPSBhcmd1bWVudHNbMF07XG4gIH0gZWxzZSBpZiAoMiA9PT0gYXJndW1lbnRzLmxlbmd0aCkge1xuICAgIHBhdGggPSBhcmd1bWVudHNbMF07XG4gICAgdmFsID0gYXJndW1lbnRzWzFdO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgYXJndW1lbnQnKTtcbiAgfVxuXG4gIGlmICghdmFsLmNlbnRlcikge1xuICAgIHRocm93IG5ldyBFcnJvcignY2VudGVyIGlzIHJlcXVpcmVkJyk7XG4gIH1cblxuICBjb25zdCBjb25kcyA9IHRoaXMuX2NvbmRpdGlvbnNbcGF0aF0gfHwgKHRoaXMuX2NvbmRpdGlvbnNbcGF0aF0gPSB7fSk7XG5cbiAgY29uc3QgdHlwZSA9IHZhbC5zcGhlcmljYWxcbiAgICA/ICckbmVhclNwaGVyZSdcbiAgICA6ICckbmVhcic7XG5cbiAgLy8gY2VudGVyIGNvdWxkIGJlIGEgR2VvSlNPTiBvYmplY3Qgb3IgYW4gQXJyYXlcbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsLmNlbnRlcikpIHtcbiAgICBjb25kc1t0eXBlXSA9IHZhbC5jZW50ZXI7XG5cbiAgICBjb25zdCByYWRpdXMgPSAnbWF4RGlzdGFuY2UnIGluIHZhbFxuICAgICAgPyB2YWwubWF4RGlzdGFuY2VcbiAgICAgIDogbnVsbDtcblxuICAgIGlmIChudWxsICE9IHJhZGl1cykge1xuICAgICAgY29uZHMuJG1heERpc3RhbmNlID0gcmFkaXVzO1xuICAgIH1cbiAgICBpZiAobnVsbCAhPSB2YWwubWluRGlzdGFuY2UpIHtcbiAgICAgIGNvbmRzLiRtaW5EaXN0YW5jZSA9IHZhbC5taW5EaXN0YW5jZTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gR2VvSlNPTj9cbiAgICBpZiAodmFsLmNlbnRlci50eXBlICE9ICdQb2ludCcgfHwgIUFycmF5LmlzQXJyYXkodmFsLmNlbnRlci5jb29yZGluYXRlcykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcih1dGlsLmZvcm1hdCgnSW52YWxpZCBHZW9KU09OIHNwZWNpZmllZCBmb3IgJXMnLCB0eXBlKSk7XG4gICAgfVxuICAgIGNvbmRzW3R5cGVdID0geyAkZ2VvbWV0cnk6IHZhbC5jZW50ZXIgfTtcblxuICAgIC8vIE1vbmdvREIgMi42IGluc2lzdHMgb24gbWF4RGlzdGFuY2UgYmVpbmcgaW4gJG5lYXIgLyAkbmVhclNwaGVyZVxuICAgIGlmICgnbWF4RGlzdGFuY2UnIGluIHZhbCkge1xuICAgICAgY29uZHNbdHlwZV1bJyRtYXhEaXN0YW5jZSddID0gdmFsLm1heERpc3RhbmNlO1xuICAgIH1cbiAgICBpZiAoJ21pbkRpc3RhbmNlJyBpbiB2YWwpIHtcbiAgICAgIGNvbmRzW3R5cGVdWyckbWluRGlzdGFuY2UnXSA9IHZhbC5taW5EaXN0YW5jZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogRGVjbGFyZXMgYW4gaW50ZXJzZWN0cyBxdWVyeSBmb3IgYGdlb21ldHJ5KClgLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgcXVlcnkud2hlcmUoJ3BhdGgnKS5pbnRlcnNlY3RzKCkuZ2VvbWV0cnkoe1xuICogICAgICAgICB0eXBlOiAnTGluZVN0cmluZydcbiAqICAgICAgICwgY29vcmRpbmF0ZXM6IFtbMTgwLjAsIDExLjBdLCBbMTgwLCA5LjBdXVxuICogICAgIH0pXG4gKlxuICogICAgIHF1ZXJ5LndoZXJlKCdwYXRoJykuaW50ZXJzZWN0cyh7XG4gKiAgICAgICAgIHR5cGU6ICdMaW5lU3RyaW5nJ1xuICogICAgICAgLCBjb29yZGluYXRlczogW1sxODAuMCwgMTEuMF0sIFsxODAsIDkuMF1dXG4gKiAgICAgfSlcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gW2FyZ11cbiAqIEByZXR1cm4ge1F1ZXJ5fSB0aGlzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblF1ZXJ5LnByb3RvdHlwZS5pbnRlcnNlY3RzID0gZnVuY3Rpb24gaW50ZXJzZWN0cygpIHtcbiAgLy8gb3BpbmlvbmF0ZWQsIG11c3QgYmUgdXNlZCBhZnRlciB3aGVyZVxuICB0aGlzLl9lbnN1cmVQYXRoKCdpbnRlcnNlY3RzJyk7XG5cbiAgdGhpcy5fZ2VvQ29tcGFyaXNvbiA9ICckZ2VvSW50ZXJzZWN0cyc7XG5cbiAgaWYgKDAgPT09IGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGNvbnN0IGFyZWEgPSBhcmd1bWVudHNbMF07XG5cbiAgaWYgKG51bGwgIT0gYXJlYSAmJiBhcmVhLnR5cGUgJiYgYXJlYS5jb29yZGluYXRlcylcbiAgICByZXR1cm4gdGhpcy5nZW9tZXRyeShhcmVhKTtcblxuICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIGFyZ3VtZW50Jyk7XG59O1xuXG4vKipcbiAqIFNwZWNpZmllcyBhIGAkZ2VvbWV0cnlgIGNvbmRpdGlvblxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgdmFyIHBvbHlBID0gW1tbIDEwLCAyMCBdLCBbIDEwLCA0MCBdLCBbIDMwLCA0MCBdLCBbIDMwLCAyMCBdXV1cbiAqICAgICBxdWVyeS53aGVyZSgnbG9jJykud2l0aGluKCkuZ2VvbWV0cnkoeyB0eXBlOiAnUG9seWdvbicsIGNvb3JkaW5hdGVzOiBwb2x5QSB9KVxuICpcbiAqICAgICAvLyBvclxuICogICAgIHZhciBwb2x5QiA9IFtbIDAsIDAgXSwgWyAxLCAxIF1dXG4gKiAgICAgcXVlcnkud2hlcmUoJ2xvYycpLndpdGhpbigpLmdlb21ldHJ5KHsgdHlwZTogJ0xpbmVTdHJpbmcnLCBjb29yZGluYXRlczogcG9seUIgfSlcbiAqXG4gKiAgICAgLy8gb3JcbiAqICAgICB2YXIgcG9seUMgPSBbIDAsIDAgXVxuICogICAgIHF1ZXJ5LndoZXJlKCdsb2MnKS53aXRoaW4oKS5nZW9tZXRyeSh7IHR5cGU6ICdQb2ludCcsIGNvb3JkaW5hdGVzOiBwb2x5QyB9KVxuICpcbiAqICAgICAvLyBvclxuICogICAgIHF1ZXJ5LndoZXJlKCdsb2MnKS5pbnRlcnNlY3RzKCkuZ2VvbWV0cnkoeyB0eXBlOiAnUG9pbnQnLCBjb29yZGluYXRlczogcG9seUMgfSlcbiAqXG4gKiAjIyMjIE5vdGU6XG4gKlxuICogYGdlb21ldHJ5KClgICoqbXVzdCoqIGNvbWUgYWZ0ZXIgZWl0aGVyIGBpbnRlcnNlY3RzKClgIG9yIGB3aXRoaW4oKWAuXG4gKlxuICogVGhlIGBvYmplY3RgIGFyZ3VtZW50IG11c3QgY29udGFpbiBgdHlwZWAgYW5kIGBjb29yZGluYXRlc2AgcHJvcGVydGllcy5cbiAqIC0gdHlwZSB7U3RyaW5nfVxuICogLSBjb29yZGluYXRlcyB7QXJyYXl9XG4gKlxuICogVGhlIG1vc3QgcmVjZW50IHBhdGggcGFzc2VkIHRvIGB3aGVyZSgpYCBpcyB1c2VkLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgTXVzdCBjb250YWluIGEgYHR5cGVgIHByb3BlcnR5IHdoaWNoIGlzIGEgU3RyaW5nIGFuZCBhIGBjb29yZGluYXRlc2AgcHJvcGVydHkgd2hpY2ggaXMgYW4gQXJyYXkuIFNlZSB0aGUgZXhhbXBsZXMuXG4gKiBAcmV0dXJuIHtRdWVyeX0gdGhpc1xuICogQHNlZSBodHRwOi8vZG9jcy5tb25nb2RiLm9yZy9tYW51YWwvcmVsZWFzZS1ub3Rlcy8yLjQvI25ldy1nZW9zcGF0aWFsLWluZGV4ZXMtd2l0aC1nZW9qc29uLWFuZC1pbXByb3ZlZC1zcGhlcmljYWwtZ2VvbWV0cnlcbiAqIEBzZWUgaHR0cDovL3d3dy5tb25nb2RiLm9yZy9kaXNwbGF5L0RPQ1MvR2Vvc3BhdGlhbCtJbmRleGluZ1xuICogQHNlZSAkZ2VvbWV0cnkgaHR0cDovL2RvY3MubW9uZ29kYi5vcmcvbWFudWFsL3JlZmVyZW5jZS9vcGVyYXRvci9nZW9tZXRyeS9cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUXVlcnkucHJvdG90eXBlLmdlb21ldHJ5ID0gZnVuY3Rpb24gZ2VvbWV0cnkoKSB7XG4gIGlmICghKCckd2l0aGluJyA9PSB0aGlzLl9nZW9Db21wYXJpc29uIHx8XG4gICAgICAgICckZ2VvV2l0aGluJyA9PSB0aGlzLl9nZW9Db21wYXJpc29uIHx8XG4gICAgICAgICckbmVhcicgPT0gdGhpcy5fZ2VvQ29tcGFyaXNvbiB8fFxuICAgICAgICAnJGdlb0ludGVyc2VjdHMnID09IHRoaXMuX2dlb0NvbXBhcmlzb24pKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdnZW9tZXRyeSgpIG11c3QgY29tZSBhZnRlciBgd2l0aGluKClgLCBgaW50ZXJzZWN0cygpYCwgb3IgYG5lYXIoKScpO1xuICB9XG5cbiAgbGV0IHZhbCwgcGF0aDtcblxuICBpZiAoMSA9PT0gYXJndW1lbnRzLmxlbmd0aCkge1xuICAgIHRoaXMuX2Vuc3VyZVBhdGgoJ2dlb21ldHJ5Jyk7XG4gICAgcGF0aCA9IHRoaXMuX3BhdGg7XG4gICAgdmFsID0gYXJndW1lbnRzWzBdO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgYXJndW1lbnQnKTtcbiAgfVxuXG4gIGlmICghKHZhbC50eXBlICYmIEFycmF5LmlzQXJyYXkodmFsLmNvb3JkaW5hdGVzKSkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIGFyZ3VtZW50Jyk7XG4gIH1cblxuICBjb25zdCBjb25kcyA9IHRoaXMuX2NvbmRpdGlvbnNbcGF0aF0gfHwgKHRoaXMuX2NvbmRpdGlvbnNbcGF0aF0gPSB7fSk7XG4gIGNvbmRzW3RoaXMuX2dlb0NvbXBhcmlzb25dID0geyAkZ2VvbWV0cnk6IHZhbCB9O1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLy8gZW5kIHNwYXRpYWxcblxuLyoqXG4gKiBTcGVjaWZpZXMgd2hpY2ggZG9jdW1lbnQgZmllbGRzIHRvIGluY2x1ZGUgb3IgZXhjbHVkZVxuICpcbiAqICMjIyMgU3RyaW5nIHN5bnRheFxuICpcbiAqIFdoZW4gcGFzc2luZyBhIHN0cmluZywgcHJlZml4aW5nIGEgcGF0aCB3aXRoIGAtYCB3aWxsIGZsYWcgdGhhdCBwYXRoIGFzIGV4Y2x1ZGVkLiBXaGVuIGEgcGF0aCBkb2VzIG5vdCBoYXZlIHRoZSBgLWAgcHJlZml4LCBpdCBpcyBpbmNsdWRlZC5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIC8vIGluY2x1ZGUgYSBhbmQgYiwgZXhjbHVkZSBjXG4gKiAgICAgcXVlcnkuc2VsZWN0KCdhIGIgLWMnKTtcbiAqXG4gKiAgICAgLy8gb3IgeW91IG1heSB1c2Ugb2JqZWN0IG5vdGF0aW9uLCB1c2VmdWwgd2hlblxuICogICAgIC8vIHlvdSBoYXZlIGtleXMgYWxyZWFkeSBwcmVmaXhlZCB3aXRoIGEgXCItXCJcbiAqICAgICBxdWVyeS5zZWxlY3Qoe2E6IDEsIGI6IDEsIGM6IDB9KTtcbiAqXG4gKiAjIyMjIE5vdGU6XG4gKlxuICogQ2Fubm90IGJlIHVzZWQgd2l0aCBgZGlzdGluY3QoKWBcbiAqXG4gKiBAcGFyYW0ge09iamVjdHxTdHJpbmd9IGFyZ1xuICogQHJldHVybiB7UXVlcnl9IHRoaXNcbiAqIEBzZWUgU2NoZW1hVHlwZVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5RdWVyeS5wcm90b3R5cGUuc2VsZWN0ID0gZnVuY3Rpb24gc2VsZWN0KCkge1xuICBsZXQgYXJnID0gYXJndW1lbnRzWzBdO1xuICBpZiAoIWFyZykgcmV0dXJuIHRoaXM7XG5cbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggIT09IDEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc2VsZWN0OiBzZWxlY3Qgb25seSB0YWtlcyAxIGFyZ3VtZW50Jyk7XG4gIH1cblxuICB0aGlzLl92YWxpZGF0ZSgnc2VsZWN0Jyk7XG5cbiAgY29uc3QgZmllbGRzID0gdGhpcy5fZmllbGRzIHx8ICh0aGlzLl9maWVsZHMgPSB7fSk7XG4gIGNvbnN0IHR5cGUgPSB0eXBlb2YgYXJnO1xuICBsZXQgaSwgbGVuO1xuXG4gIGlmICgoJ3N0cmluZycgPT0gdHlwZSB8fCB1dGlscy5pc0FyZ3VtZW50c09iamVjdChhcmcpKSAmJlxuICAgICdudW1iZXInID09IHR5cGVvZiBhcmcubGVuZ3RoIHx8IEFycmF5LmlzQXJyYXkoYXJnKSkge1xuICAgIGlmICgnc3RyaW5nJyA9PSB0eXBlKVxuICAgICAgYXJnID0gYXJnLnNwbGl0KC9cXHMrLyk7XG5cbiAgICBmb3IgKGkgPSAwLCBsZW4gPSBhcmcubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgIGxldCBmaWVsZCA9IGFyZ1tpXTtcbiAgICAgIGlmICghZmllbGQpIGNvbnRpbnVlO1xuICAgICAgY29uc3QgaW5jbHVkZSA9ICctJyA9PSBmaWVsZFswXSA/IDAgOiAxO1xuICAgICAgaWYgKGluY2x1ZGUgPT09IDApIGZpZWxkID0gZmllbGQuc3Vic3RyaW5nKDEpO1xuICAgICAgZmllbGRzW2ZpZWxkXSA9IGluY2x1ZGU7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBpZiAodXRpbHMuaXNPYmplY3QoYXJnKSkge1xuICAgIGNvbnN0IGtleXMgPSB1dGlscy5rZXlzKGFyZyk7XG4gICAgZm9yIChpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpIHtcbiAgICAgIGZpZWxkc1trZXlzW2ldXSA9IGFyZ1trZXlzW2ldXTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIHNlbGVjdCgpIGFyZ3VtZW50LiBNdXN0IGJlIHN0cmluZyBvciBvYmplY3QuJyk7XG59O1xuXG4vKipcbiAqIFNwZWNpZmllcyBhICRzbGljZSBjb25kaXRpb24gZm9yIGEgYHBhdGhgXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBxdWVyeS5zbGljZSgnY29tbWVudHMnLCA1KVxuICogICAgIHF1ZXJ5LnNsaWNlKCdjb21tZW50cycsIC01KVxuICogICAgIHF1ZXJ5LnNsaWNlKCdjb21tZW50cycsIFsxMCwgNV0pXG4gKiAgICAgcXVlcnkud2hlcmUoJ2NvbW1lbnRzJykuc2xpY2UoNSlcbiAqICAgICBxdWVyeS53aGVyZSgnY29tbWVudHMnKS5zbGljZShbLTEwLCA1XSlcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gW3BhdGhdXG4gKiBAcGFyYW0ge051bWJlcn0gdmFsIG51bWJlci9yYW5nZSBvZiBlbGVtZW50cyB0byBzbGljZVxuICogQHJldHVybiB7UXVlcnl9IHRoaXNcbiAqIEBzZWUgbW9uZ29kYiBodHRwOi8vd3d3Lm1vbmdvZGIub3JnL2Rpc3BsYXkvRE9DUy9SZXRyaWV2aW5nK2ErU3Vic2V0K29mK0ZpZWxkcyNSZXRyaWV2aW5nYVN1YnNldG9mRmllbGRzLVJldHJpZXZpbmdhU3VicmFuZ2VvZkFycmF5RWxlbWVudHNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUXVlcnkucHJvdG90eXBlLnNsaWNlID0gZnVuY3Rpb24oKSB7XG4gIGlmICgwID09PSBhcmd1bWVudHMubGVuZ3RoKVxuICAgIHJldHVybiB0aGlzO1xuXG4gIHRoaXMuX3ZhbGlkYXRlKCdzbGljZScpO1xuXG4gIGxldCBwYXRoLCB2YWw7XG5cbiAgaWYgKDEgPT09IGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICBjb25zdCBhcmcgPSBhcmd1bWVudHNbMF07XG4gICAgaWYgKHR5cGVvZiBhcmcgPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KGFyZykpIHtcbiAgICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhhcmcpO1xuICAgICAgY29uc3QgbnVtS2V5cyA9IGtleXMubGVuZ3RoO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1LZXlzOyArK2kpIHtcbiAgICAgICAgdGhpcy5zbGljZShrZXlzW2ldLCBhcmdba2V5c1tpXV0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHRoaXMuX2Vuc3VyZVBhdGgoJ3NsaWNlJyk7XG4gICAgcGF0aCA9IHRoaXMuX3BhdGg7XG4gICAgdmFsID0gYXJndW1lbnRzWzBdO1xuICB9IGVsc2UgaWYgKDIgPT09IGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICBpZiAoJ251bWJlcicgPT09IHR5cGVvZiBhcmd1bWVudHNbMF0pIHtcbiAgICAgIHRoaXMuX2Vuc3VyZVBhdGgoJ3NsaWNlJyk7XG4gICAgICBwYXRoID0gdGhpcy5fcGF0aDtcbiAgICAgIHZhbCA9IFthcmd1bWVudHNbMF0sIGFyZ3VtZW50c1sxXV07XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhdGggPSBhcmd1bWVudHNbMF07XG4gICAgICB2YWwgPSBhcmd1bWVudHNbMV07XG4gICAgfVxuICB9IGVsc2UgaWYgKDMgPT09IGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICBwYXRoID0gYXJndW1lbnRzWzBdO1xuICAgIHZhbCA9IFthcmd1bWVudHNbMV0sIGFyZ3VtZW50c1syXV07XG4gIH1cblxuICBjb25zdCBteUZpZWxkcyA9IHRoaXMuX2ZpZWxkcyB8fCAodGhpcy5fZmllbGRzID0ge30pO1xuICBteUZpZWxkc1twYXRoXSA9IHsgJHNsaWNlOiB2YWwgfTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNldHMgdGhlIHNvcnQgb3JkZXJcbiAqXG4gKiBJZiBhbiBvYmplY3QgaXMgcGFzc2VkLCB2YWx1ZXMgYWxsb3dlZCBhcmUgJ2FzYycsICdkZXNjJywgJ2FzY2VuZGluZycsICdkZXNjZW5kaW5nJywgMSwgYW5kIC0xLlxuICpcbiAqIElmIGEgc3RyaW5nIGlzIHBhc3NlZCwgaXQgbXVzdCBiZSBhIHNwYWNlIGRlbGltaXRlZCBsaXN0IG9mIHBhdGggbmFtZXMuIFRoZSBzb3J0IG9yZGVyIG9mIGVhY2ggcGF0aCBpcyBhc2NlbmRpbmcgdW5sZXNzIHRoZSBwYXRoIG5hbWUgaXMgcHJlZml4ZWQgd2l0aCBgLWAgd2hpY2ggd2lsbCBiZSB0cmVhdGVkIGFzIGRlc2NlbmRpbmcuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICAvLyB0aGVzZSBhcmUgZXF1aXZhbGVudFxuICogICAgIHF1ZXJ5LnNvcnQoeyBmaWVsZDogJ2FzYycsIHRlc3Q6IC0xIH0pO1xuICogICAgIHF1ZXJ5LnNvcnQoJ2ZpZWxkIC10ZXN0Jyk7XG4gKiAgICAgcXVlcnkuc29ydChbWydmaWVsZCcsIDFdLCBbJ3Rlc3QnLCAtMV1dKTtcbiAqXG4gKiAjIyMjIE5vdGU6XG4gKlxuICogIC0gVGhlIGFycmF5IHN5bnRheCBgLnNvcnQoW1snZmllbGQnLCAxXSwgWyd0ZXN0JywgLTFdXSlgIGNhbiBvbmx5IGJlIHVzZWQgd2l0aCBbbW9uZ29kYiBkcml2ZXIgPj0gMi4wLjQ2XShodHRwczovL2dpdGh1Yi5jb20vbW9uZ29kYi9ub2RlLW1vbmdvZGItbmF0aXZlL2Jsb2IvMi4xL0hJU1RPUlkubWQjMjA0Ni0yMDE1LTEwLTE1KS5cbiAqICAtIENhbm5vdCBiZSB1c2VkIHdpdGggYGRpc3RpbmN0KClgXG4gKlxuICogQHBhcmFtIHtPYmplY3R8U3RyaW5nfEFycmF5fSBhcmdcbiAqIEByZXR1cm4ge1F1ZXJ5fSB0aGlzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblF1ZXJ5LnByb3RvdHlwZS5zb3J0ID0gZnVuY3Rpb24oYXJnKSB7XG4gIGlmICghYXJnKSByZXR1cm4gdGhpcztcbiAgbGV0IGksIGxlbiwgZmllbGQ7XG5cbiAgdGhpcy5fdmFsaWRhdGUoJ3NvcnQnKTtcblxuICBjb25zdCB0eXBlID0gdHlwZW9mIGFyZztcblxuICAvLyAuc29ydChbWydmaWVsZCcsIDFdLCBbJ3Rlc3QnLCAtMV1dKVxuICBpZiAoQXJyYXkuaXNBcnJheShhcmcpKSB7XG4gICAgbGVuID0gYXJnLmxlbmd0aDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgYXJnLmxlbmd0aDsgKytpKSB7XG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkoYXJnW2ldKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc29ydCgpIGFyZ3VtZW50LCBtdXN0IGJlIGFycmF5IG9mIGFycmF5cycpO1xuICAgICAgfVxuICAgICAgX3B1c2hBcnIodGhpcy5vcHRpb25zLCBhcmdbaV1bMF0sIGFyZ1tpXVsxXSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gLnNvcnQoJ2ZpZWxkIC10ZXN0JylcbiAgaWYgKDEgPT09IGFyZ3VtZW50cy5sZW5ndGggJiYgJ3N0cmluZycgPT0gdHlwZSkge1xuICAgIGFyZyA9IGFyZy5zcGxpdCgvXFxzKy8pO1xuICAgIGxlbiA9IGFyZy5sZW5ndGg7XG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICBmaWVsZCA9IGFyZ1tpXTtcbiAgICAgIGlmICghZmllbGQpIGNvbnRpbnVlO1xuICAgICAgY29uc3QgYXNjZW5kID0gJy0nID09IGZpZWxkWzBdID8gLTEgOiAxO1xuICAgICAgaWYgKGFzY2VuZCA9PT0gLTEpIGZpZWxkID0gZmllbGQuc3Vic3RyaW5nKDEpO1xuICAgICAgcHVzaCh0aGlzLm9wdGlvbnMsIGZpZWxkLCBhc2NlbmQpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gLnNvcnQoeyBmaWVsZDogMSwgdGVzdDogLTEgfSlcbiAgaWYgKHV0aWxzLmlzT2JqZWN0KGFyZykpIHtcbiAgICBjb25zdCBrZXlzID0gdXRpbHMua2V5cyhhcmcpO1xuICAgIGZvciAoaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKSB7XG4gICAgICBmaWVsZCA9IGtleXNbaV07XG4gICAgICBwdXNoKHRoaXMub3B0aW9ucywgZmllbGQsIGFyZ1tmaWVsZF0pO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBNYXAgIT09ICd1bmRlZmluZWQnICYmIGFyZyBpbnN0YW5jZW9mIE1hcCkge1xuICAgIF9wdXNoTWFwKHRoaXMub3B0aW9ucywgYXJnKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIHNvcnQoKSBhcmd1bWVudC4gTXVzdCBiZSBhIHN0cmluZywgb2JqZWN0LCBvciBhcnJheS4nKTtcbn07XG5cbi8qIVxuICogQGlnbm9yZVxuICovXG5cbmNvbnN0IF92YWxpZFNvcnRWYWx1ZSA9IHtcbiAgMTogMSxcbiAgJy0xJzogLTEsXG4gIGFzYzogMSxcbiAgYXNjZW5kaW5nOiAxLFxuICBkZXNjOiAtMSxcbiAgZGVzY2VuZGluZzogLTFcbn07XG5cbmZ1bmN0aW9uIHB1c2gob3B0cywgZmllbGQsIHZhbHVlKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KG9wdHMuc29ydCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdDYW5cXCd0IG1peCBzb3J0IHN5bnRheGVzLiBVc2UgZWl0aGVyIGFycmF5IG9yIG9iamVjdDonICtcbiAgICAgICdcXG4tIGAuc29ydChbW1xcJ2ZpZWxkXFwnLCAxXSwgW1xcJ3Rlc3RcXCcsIC0xXV0pYCcgK1xuICAgICAgJ1xcbi0gYC5zb3J0KHsgZmllbGQ6IDEsIHRlc3Q6IC0xIH0pYCcpO1xuICB9XG5cbiAgbGV0IHM7XG4gIGlmICh2YWx1ZSAmJiB2YWx1ZS4kbWV0YSkge1xuICAgIHMgPSBvcHRzLnNvcnQgfHwgKG9wdHMuc29ydCA9IHt9KTtcbiAgICBzW2ZpZWxkXSA9IHsgJG1ldGE6IHZhbHVlLiRtZXRhIH07XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgcyA9IG9wdHMuc29ydCB8fCAob3B0cy5zb3J0ID0ge30pO1xuICBsZXQgdmFsID0gU3RyaW5nKHZhbHVlIHx8IDEpLnRvTG93ZXJDYXNlKCk7XG4gIHZhbCA9IF92YWxpZFNvcnRWYWx1ZVt2YWxdO1xuICBpZiAoIXZhbCkgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBzb3J0IHZhbHVlOiB7ICcgKyBmaWVsZCArICc6ICcgKyB2YWx1ZSArICcgfScpO1xuXG4gIHNbZmllbGRdID0gdmFsO1xufVxuXG5mdW5jdGlvbiBfcHVzaEFycihvcHRzLCBmaWVsZCwgdmFsdWUpIHtcbiAgb3B0cy5zb3J0ID0gb3B0cy5zb3J0IHx8IFtdO1xuICBpZiAoIUFycmF5LmlzQXJyYXkob3B0cy5zb3J0KSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0NhblxcJ3QgbWl4IHNvcnQgc3ludGF4ZXMuIFVzZSBlaXRoZXIgYXJyYXkgb3Igb2JqZWN0OicgK1xuICAgICAgJ1xcbi0gYC5zb3J0KFtbXFwnZmllbGRcXCcsIDFdLCBbXFwndGVzdFxcJywgLTFdXSlgJyArXG4gICAgICAnXFxuLSBgLnNvcnQoeyBmaWVsZDogMSwgdGVzdDogLTEgfSlgJyk7XG4gIH1cblxuICBsZXQgdmFsID0gU3RyaW5nKHZhbHVlIHx8IDEpLnRvTG93ZXJDYXNlKCk7XG4gIHZhbCA9IF92YWxpZFNvcnRWYWx1ZVt2YWxdO1xuICBpZiAoIXZhbCkgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBzb3J0IHZhbHVlOiBbICcgKyBmaWVsZCArICcsICcgKyB2YWx1ZSArICcgXScpO1xuXG4gIG9wdHMuc29ydC5wdXNoKFtmaWVsZCwgdmFsXSk7XG59XG5cbmZ1bmN0aW9uIF9wdXNoTWFwKG9wdHMsIG1hcCkge1xuICBvcHRzLnNvcnQgPSBvcHRzLnNvcnQgfHwgbmV3IE1hcCgpO1xuICBpZiAoIShvcHRzLnNvcnQgaW5zdGFuY2VvZiBNYXApKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQ2FuXFwndCBtaXggc29ydCBzeW50YXhlcy4gVXNlIGVpdGhlciBhcnJheSBvciAnICtcbiAgICAgICdvYmplY3Qgb3IgbWFwIGNvbnNpc3RlbnRseScpO1xuICB9XG4gIG1hcC5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAgICBsZXQgdmFsID0gU3RyaW5nKHZhbHVlIHx8IDEpLnRvTG93ZXJDYXNlKCk7XG4gICAgdmFsID0gX3ZhbGlkU29ydFZhbHVlW3ZhbF07XG4gICAgaWYgKCF2YWwpIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgc29ydCB2YWx1ZTogPCAnICsga2V5ICsgJzogJyArIHZhbHVlICsgJyA+Jyk7XG5cbiAgICBvcHRzLnNvcnQuc2V0KGtleSwgdmFsKTtcbiAgfSk7XG59XG5cblxuLyoqXG4gKiBTcGVjaWZpZXMgdGhlIGxpbWl0IG9wdGlvbi5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIHF1ZXJ5LmxpbWl0KDIwKVxuICpcbiAqICMjIyMgTm90ZTpcbiAqXG4gKiBDYW5ub3QgYmUgdXNlZCB3aXRoIGBkaXN0aW5jdCgpYFxuICpcbiAqIEBtZXRob2QgbGltaXRcbiAqIEBtZW1iZXJPZiBRdWVyeVxuICogQHBhcmFtIHtOdW1iZXJ9IHZhbFxuICogQHNlZSBtb25nb2RiIGh0dHA6Ly93d3cubW9uZ29kYi5vcmcvZGlzcGxheS9ET0NTL0FkdmFuY2VkK1F1ZXJpZXMjQWR2YW5jZWRRdWVyaWVzLSU3QiU3QmxpbWl0JTI4JTI5JTdEJTdEXG4gKiBAYXBpIHB1YmxpY1xuICovXG4vKipcbiAqIFNwZWNpZmllcyB0aGUgc2tpcCBvcHRpb24uXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBxdWVyeS5za2lwKDEwMCkubGltaXQoMjApXG4gKlxuICogIyMjIyBOb3RlOlxuICpcbiAqIENhbm5vdCBiZSB1c2VkIHdpdGggYGRpc3RpbmN0KClgXG4gKlxuICogQG1ldGhvZCBza2lwXG4gKiBAbWVtYmVyT2YgUXVlcnlcbiAqIEBwYXJhbSB7TnVtYmVyfSB2YWxcbiAqIEBzZWUgbW9uZ29kYiBodHRwOi8vd3d3Lm1vbmdvZGIub3JnL2Rpc3BsYXkvRE9DUy9BZHZhbmNlZCtRdWVyaWVzI0FkdmFuY2VkUXVlcmllcy0lN0IlN0Jza2lwJTI4JTI5JTdEJTdEXG4gKiBAYXBpIHB1YmxpY1xuICovXG4vKipcbiAqIFNwZWNpZmllcyB0aGUgYmF0Y2hTaXplIG9wdGlvbi5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIHF1ZXJ5LmJhdGNoU2l6ZSgxMDApXG4gKlxuICogIyMjIyBOb3RlOlxuICpcbiAqIENhbm5vdCBiZSB1c2VkIHdpdGggYGRpc3RpbmN0KClgXG4gKlxuICogQG1ldGhvZCBiYXRjaFNpemVcbiAqIEBtZW1iZXJPZiBRdWVyeVxuICogQHBhcmFtIHtOdW1iZXJ9IHZhbFxuICogQHNlZSBtb25nb2RiIGh0dHA6Ly93d3cubW9uZ29kYi5vcmcvZGlzcGxheS9ET0NTL0FkdmFuY2VkK1F1ZXJpZXMjQWR2YW5jZWRRdWVyaWVzLSU3QiU3QmJhdGNoU2l6ZSUyOCUyOSU3RCU3RFxuICogQGFwaSBwdWJsaWNcbiAqL1xuLyoqXG4gKiBTcGVjaWZpZXMgdGhlIGBjb21tZW50YCBvcHRpb24uXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBxdWVyeS5jb21tZW50KCdsb2dpbiBxdWVyeScpXG4gKlxuICogIyMjIyBOb3RlOlxuICpcbiAqIENhbm5vdCBiZSB1c2VkIHdpdGggYGRpc3RpbmN0KClgXG4gKlxuICogQG1ldGhvZCBjb21tZW50XG4gKiBAbWVtYmVyT2YgUXVlcnlcbiAqIEBwYXJhbSB7TnVtYmVyfSB2YWxcbiAqIEBzZWUgbW9uZ29kYiBodHRwOi8vd3d3Lm1vbmdvZGIub3JnL2Rpc3BsYXkvRE9DUy9BZHZhbmNlZCtRdWVyaWVzI0FkdmFuY2VkUXVlcmllcy0lMjRjb21tZW50XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbi8qIVxuICogbGltaXQsIHNraXAsIGJhdGNoU2l6ZSwgY29tbWVudFxuICpcbiAqIFNldHMgdGhlc2UgYXNzb2NpYXRlZCBvcHRpb25zLlxuICpcbiAqICAgICBxdWVyeS5jb21tZW50KCdmZWVkIHF1ZXJ5Jyk7XG4gKi9cblxuWydsaW1pdCcsICdza2lwJywgJ2JhdGNoU2l6ZScsICdjb21tZW50J10uZm9yRWFjaChmdW5jdGlvbihtZXRob2QpIHtcbiAgUXVlcnkucHJvdG90eXBlW21ldGhvZF0gPSBmdW5jdGlvbih2KSB7XG4gICAgdGhpcy5fdmFsaWRhdGUobWV0aG9kKTtcbiAgICB0aGlzLm9wdGlvbnNbbWV0aG9kXSA9IHY7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG59KTtcblxuLyoqXG4gKiBTcGVjaWZpZXMgdGhlIG1heFRpbWVNUyBvcHRpb24uXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBxdWVyeS5tYXhUaW1lKDEwMClcbiAqICAgICBxdWVyeS5tYXhUaW1lTVMoMTAwKVxuICpcbiAqIEBtZXRob2QgbWF4VGltZVxuICogQG1lbWJlck9mIFF1ZXJ5XG4gKiBAcGFyYW0ge051bWJlcn0gbXNcbiAqIEBzZWUgbW9uZ29kYiBodHRwOi8vZG9jcy5tb25nb2RiLm9yZy9tYW51YWwvcmVmZXJlbmNlL29wZXJhdG9yL21ldGEvbWF4VGltZU1TLyNvcC5fU19tYXhUaW1lTVNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUXVlcnkucHJvdG90eXBlLm1heFRpbWUgPSBRdWVyeS5wcm90b3R5cGUubWF4VGltZU1TID0gZnVuY3Rpb24obXMpIHtcbiAgdGhpcy5fdmFsaWRhdGUoJ21heFRpbWUnKTtcbiAgdGhpcy5vcHRpb25zLm1heFRpbWVNUyA9IG1zO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2V0cyBxdWVyeSBoaW50cy5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIHF1ZXJ5LmhpbnQoeyBpbmRleEE6IDEsIGluZGV4QjogLTF9KTtcbiAqICAgICBxdWVyeS5oaW50KCdpbmRleEFfMV9pbmRleEJfMScpO1xuICpcbiAqICMjIyMgTm90ZTpcbiAqXG4gKiBDYW5ub3QgYmUgdXNlZCB3aXRoIGBkaXN0aW5jdCgpYFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fHN0cmluZ30gdmFsIGEgaGludCBvYmplY3Qgb3IgdGhlIGluZGV4IG5hbWVcbiAqIEByZXR1cm4ge1F1ZXJ5fSB0aGlzXG4gKiBAc2VlIG1vbmdvZGIgaHR0cDovL3d3dy5tb25nb2RiLm9yZy9kaXNwbGF5L0RPQ1MvQWR2YW5jZWQrUXVlcmllcyNBZHZhbmNlZFF1ZXJpZXMtJTI0aGludFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5RdWVyeS5wcm90b3R5cGUuaGludCA9IGZ1bmN0aW9uKCkge1xuICBpZiAoMCA9PT0gYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXM7XG5cbiAgdGhpcy5fdmFsaWRhdGUoJ2hpbnQnKTtcblxuICBjb25zdCBhcmcgPSBhcmd1bWVudHNbMF07XG4gIGlmICh1dGlscy5pc09iamVjdChhcmcpKSB7XG4gICAgY29uc3QgaGludCA9IHRoaXMub3B0aW9ucy5oaW50IHx8ICh0aGlzLm9wdGlvbnMuaGludCA9IHt9KTtcblxuICAgIC8vIG11c3Qga2VlcCBvYmplY3Qga2V5cyBpbiBvcmRlciBzbyBkb24ndCB1c2UgT2JqZWN0LmtleXMoKVxuICAgIGZvciAoY29uc3QgayBpbiBhcmcpIHtcbiAgICAgIGhpbnRba10gPSBhcmdba107XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgaWYgKHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnKSB7XG4gICAgdGhpcy5vcHRpb25zLmhpbnQgPSBhcmc7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIGhpbnQuICcgKyBhcmcpO1xufTtcblxuLyoqXG4gKiBSZXF1ZXN0cyBhY2tub3dsZWRnZW1lbnQgdGhhdCB0aGlzIG9wZXJhdGlvbiBoYXMgYmVlbiBwZXJzaXN0ZWQgdG8gTW9uZ29EQidzXG4gKiBvbi1kaXNrIGpvdXJuYWwuXG4gKiBUaGlzIG9wdGlvbiBpcyBvbmx5IHZhbGlkIGZvciBvcGVyYXRpb25zIHRoYXQgd3JpdGUgdG8gdGhlIGRhdGFiYXNlOlxuICpcbiAqIC0gYGRlbGV0ZU9uZSgpYFxuICogLSBgZGVsZXRlTWFueSgpYFxuICogLSBgZmluZE9uZUFuZERlbGV0ZSgpYFxuICogLSBgZmluZE9uZUFuZFVwZGF0ZSgpYFxuICogLSBgdXBkYXRlT25lKClgXG4gKiAtIGB1cGRhdGVNYW55KClgXG4gKlxuICogRGVmYXVsdHMgdG8gdGhlIGBqYCB2YWx1ZSBpZiBpdCBpcyBzcGVjaWZpZWQgaW4gd3JpdGVDb25jZXJuIG9wdGlvbnNcbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIG1xdWVyeSgpLncoMikuaih0cnVlKS53dGltZW91dCgyMDAwKTtcbiAqXG4gKiBAbWV0aG9kIGpcbiAqIEBtZW1iZXJPZiBRdWVyeVxuICogQGluc3RhbmNlXG4gKiBAcGFyYW0ge2Jvb2xlYW59IHZhbFxuICogQHNlZSBtb25nb2RiIGh0dHBzOi8vZG9jcy5tb25nb2RiLmNvbS9tYW51YWwvcmVmZXJlbmNlL3dyaXRlLWNvbmNlcm4vI2otb3B0aW9uXG4gKiBAcmV0dXJuIHtRdWVyeX0gdGhpc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5RdWVyeS5wcm90b3R5cGUuaiA9IGZ1bmN0aW9uIGoodmFsKSB7XG4gIHRoaXMub3B0aW9ucy5qID0gdmFsO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2V0cyB0aGUgc2xhdmVPayBvcHRpb24uIF9EZXByZWNhdGVkXyBpbiBNb25nb0RCIDIuMiBpbiBmYXZvciBvZiByZWFkIHByZWZlcmVuY2VzLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgcXVlcnkuc2xhdmVPaygpIC8vIHRydWVcbiAqICAgICBxdWVyeS5zbGF2ZU9rKHRydWUpXG4gKiAgICAgcXVlcnkuc2xhdmVPayhmYWxzZSlcbiAqXG4gKiBAZGVwcmVjYXRlZCB1c2UgcmVhZCgpIHByZWZlcmVuY2VzIGluc3RlYWQgaWYgb24gbW9uZ29kYiA+PSAyLjJcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gdiBkZWZhdWx0cyB0byB0cnVlXG4gKiBAc2VlIG1vbmdvZGIgaHR0cDovL2RvY3MubW9uZ29kYi5vcmcvbWFudWFsL2FwcGxpY2F0aW9ucy9yZXBsaWNhdGlvbi8jcmVhZC1wcmVmZXJlbmNlXG4gKiBAc2VlIHJlYWQoKVxuICogQHJldHVybiB7UXVlcnl9IHRoaXNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUXVlcnkucHJvdG90eXBlLnNsYXZlT2sgPSBmdW5jdGlvbih2KSB7XG4gIHRoaXMub3B0aW9ucy5zbGF2ZU9rID0gYXJndW1lbnRzLmxlbmd0aCA/ICEhdiA6IHRydWU7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZXRzIHRoZSByZWFkUHJlZmVyZW5jZSBvcHRpb24gZm9yIHRoZSBxdWVyeS5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIG5ldyBRdWVyeSgpLnJlYWQoJ3ByaW1hcnknKVxuICogICAgIG5ldyBRdWVyeSgpLnJlYWQoJ3AnKSAgLy8gc2FtZSBhcyBwcmltYXJ5XG4gKlxuICogICAgIG5ldyBRdWVyeSgpLnJlYWQoJ3ByaW1hcnlQcmVmZXJyZWQnKVxuICogICAgIG5ldyBRdWVyeSgpLnJlYWQoJ3BwJykgLy8gc2FtZSBhcyBwcmltYXJ5UHJlZmVycmVkXG4gKlxuICogICAgIG5ldyBRdWVyeSgpLnJlYWQoJ3NlY29uZGFyeScpXG4gKiAgICAgbmV3IFF1ZXJ5KCkucmVhZCgncycpICAvLyBzYW1lIGFzIHNlY29uZGFyeVxuICpcbiAqICAgICBuZXcgUXVlcnkoKS5yZWFkKCdzZWNvbmRhcnlQcmVmZXJyZWQnKVxuICogICAgIG5ldyBRdWVyeSgpLnJlYWQoJ3NwJykgLy8gc2FtZSBhcyBzZWNvbmRhcnlQcmVmZXJyZWRcbiAqXG4gKiAgICAgbmV3IFF1ZXJ5KCkucmVhZCgnbmVhcmVzdCcpXG4gKiAgICAgbmV3IFF1ZXJ5KCkucmVhZCgnbicpICAvLyBzYW1lIGFzIG5lYXJlc3RcbiAqXG4gKiAgICAgLy8geW91IGNhbiBhbHNvIHVzZSBtb25nb2RiLlJlYWRQcmVmZXJlbmNlIGNsYXNzIHRvIGFsc28gc3BlY2lmeSB0YWdzXG4gKiAgICAgbmV3IFF1ZXJ5KCkucmVhZChtb25nb2RiLlJlYWRQcmVmZXJlbmNlKCdzZWNvbmRhcnknLCBbeyBkYzonc2YnLCBzOiAxIH0seyBkYzonbWEnLCBzOiAyIH1dKSlcbiAqXG4gKiAgICAgbmV3IFF1ZXJ5KCkuc2V0UmVhZFByZWZlcmVuY2UoJ3ByaW1hcnknKSAvLyBhbGlhcyBvZiAucmVhZCgpXG4gKlxuICogIyMjIyBQcmVmZXJlbmNlczpcbiAqXG4gKiAgICAgcHJpbWFyeSAtIChkZWZhdWx0KSAgUmVhZCBmcm9tIHByaW1hcnkgb25seS4gT3BlcmF0aW9ucyB3aWxsIHByb2R1Y2UgYW4gZXJyb3IgaWYgcHJpbWFyeSBpcyB1bmF2YWlsYWJsZS4gQ2Fubm90IGJlIGNvbWJpbmVkIHdpdGggdGFncy5cbiAqICAgICBzZWNvbmRhcnkgICAgICAgICAgICBSZWFkIGZyb20gc2Vjb25kYXJ5IGlmIGF2YWlsYWJsZSwgb3RoZXJ3aXNlIGVycm9yLlxuICogICAgIHByaW1hcnlQcmVmZXJyZWQgICAgIFJlYWQgZnJvbSBwcmltYXJ5IGlmIGF2YWlsYWJsZSwgb3RoZXJ3aXNlIGEgc2Vjb25kYXJ5LlxuICogICAgIHNlY29uZGFyeVByZWZlcnJlZCAgIFJlYWQgZnJvbSBhIHNlY29uZGFyeSBpZiBhdmFpbGFibGUsIG90aGVyd2lzZSByZWFkIGZyb20gdGhlIHByaW1hcnkuXG4gKiAgICAgbmVhcmVzdCAgICAgICAgICAgICAgQWxsIG9wZXJhdGlvbnMgcmVhZCBmcm9tIGFtb25nIHRoZSBuZWFyZXN0IGNhbmRpZGF0ZXMsIGJ1dCB1bmxpa2Ugb3RoZXIgbW9kZXMsIHRoaXMgb3B0aW9uIHdpbGwgaW5jbHVkZSBib3RoIHRoZSBwcmltYXJ5IGFuZCBhbGwgc2Vjb25kYXJpZXMgaW4gdGhlIHJhbmRvbSBzZWxlY3Rpb24uXG4gKlxuICogQWxpYXNlc1xuICpcbiAqICAgICBwICAgcHJpbWFyeVxuICogICAgIHBwICBwcmltYXJ5UHJlZmVycmVkXG4gKiAgICAgcyAgIHNlY29uZGFyeVxuICogICAgIHNwICBzZWNvbmRhcnlQcmVmZXJyZWRcbiAqICAgICBuICAgbmVhcmVzdFxuICpcbiAqIFJlYWQgbW9yZSBhYm91dCBob3cgdG8gdXNlIHJlYWQgcHJlZmVyZW5jZXMgW2hlcmVdKGh0dHA6Ly9kb2NzLm1vbmdvZGIub3JnL21hbnVhbC9hcHBsaWNhdGlvbnMvcmVwbGljYXRpb24vI3JlYWQtcHJlZmVyZW5jZSkgYW5kIFtoZXJlXShodHRwOi8vbW9uZ29kYi5naXRodWIuY29tL25vZGUtbW9uZ29kYi1uYXRpdmUvZHJpdmVyLWFydGljbGVzL2FuaW50cm9kdWN0aW9udG8xXzFhbmQyXzIuaHRtbCNyZWFkLXByZWZlcmVuY2VzKS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ3xSZWFkUHJlZmVyZW5jZX0gcHJlZiBvbmUgb2YgdGhlIGxpc3RlZCBwcmVmZXJlbmNlIG9wdGlvbnMgb3IgdGhlaXIgYWxpYXNlc1xuICogQHNlZSBtb25nb2RiIGh0dHA6Ly9kb2NzLm1vbmdvZGIub3JnL21hbnVhbC9hcHBsaWNhdGlvbnMvcmVwbGljYXRpb24vI3JlYWQtcHJlZmVyZW5jZVxuICogQHNlZSBkcml2ZXIgaHR0cDovL21vbmdvZGIuZ2l0aHViLmNvbS9ub2RlLW1vbmdvZGItbmF0aXZlL2RyaXZlci1hcnRpY2xlcy9hbmludHJvZHVjdGlvbnRvMV8xYW5kMl8yLmh0bWwjcmVhZC1wcmVmZXJlbmNlc1xuICogQHJldHVybiB7UXVlcnl9IHRoaXNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUXVlcnkucHJvdG90eXBlLnJlYWQgPSBRdWVyeS5wcm90b3R5cGUuc2V0UmVhZFByZWZlcmVuY2UgPSBmdW5jdGlvbihwcmVmKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSAmJiAhUXVlcnkucHJvdG90eXBlLnJlYWQuZGVwcmVjYXRpb25XYXJuaW5nSXNzdWVkKSB7XG4gICAgY29uc29sZS5lcnJvcignRGVwcmVjYXRpb24gd2FybmluZzogXFwndGFnc1xcJyBhcmd1bWVudCBpcyBub3Qgc3VwcG9ydGVkIGFueW1vcmUgaW4gUXVlcnkucmVhZCgpIG1ldGhvZC4gUGxlYXNlIHVzZSBtb25nb2RiLlJlYWRQcmVmZXJlbmNlIG9iamVjdCBpbnN0ZWFkLicpO1xuICAgIFF1ZXJ5LnByb3RvdHlwZS5yZWFkLmRlcHJlY2F0aW9uV2FybmluZ0lzc3VlZCA9IHRydWU7XG4gIH1cbiAgdGhpcy5vcHRpb25zLnJlYWRQcmVmZXJlbmNlID0gdXRpbHMucmVhZFByZWYocHJlZik7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZXRzIHRoZSByZWFkQ29uY2VybiBvcHRpb24gZm9yIHRoZSBxdWVyeS5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIG5ldyBRdWVyeSgpLnJlYWRDb25jZXJuKCdsb2NhbCcpXG4gKiAgICAgbmV3IFF1ZXJ5KCkucmVhZENvbmNlcm4oJ2wnKSAgLy8gc2FtZSBhcyBsb2NhbFxuICpcbiAqICAgICBuZXcgUXVlcnkoKS5yZWFkQ29uY2VybignYXZhaWxhYmxlJylcbiAqICAgICBuZXcgUXVlcnkoKS5yZWFkQ29uY2VybignYScpICAvLyBzYW1lIGFzIGF2YWlsYWJsZVxuICpcbiAqICAgICBuZXcgUXVlcnkoKS5yZWFkQ29uY2VybignbWFqb3JpdHknKVxuICogICAgIG5ldyBRdWVyeSgpLnJlYWRDb25jZXJuKCdtJykgIC8vIHNhbWUgYXMgbWFqb3JpdHlcbiAqXG4gKiAgICAgbmV3IFF1ZXJ5KCkucmVhZENvbmNlcm4oJ2xpbmVhcml6YWJsZScpXG4gKiAgICAgbmV3IFF1ZXJ5KCkucmVhZENvbmNlcm4oJ2x6JykgLy8gc2FtZSBhcyBsaW5lYXJpemFibGVcbiAqXG4gKiAgICAgbmV3IFF1ZXJ5KCkucmVhZENvbmNlcm4oJ3NuYXBzaG90JylcbiAqICAgICBuZXcgUXVlcnkoKS5yZWFkQ29uY2VybigncycpICAvLyBzYW1lIGFzIHNuYXBzaG90XG4gKlxuICogICAgIG5ldyBRdWVyeSgpLnIoJ3MnKSAvLyByIGlzIGFsaWFzIG9mIHJlYWRDb25jZXJuXG4gKlxuICpcbiAqICMjIyMgUmVhZCBDb25jZXJuIExldmVsOlxuICpcbiAqICAgICBsb2NhbCAgICAgICAgIE1vbmdvREIgMy4yKyBUaGUgcXVlcnkgcmV0dXJucyBmcm9tIHRoZSBpbnN0YW5jZSB3aXRoIG5vIGd1YXJhbnRlZSBndWFyYW50ZWUgdGhhdCB0aGUgZGF0YSBoYXMgYmVlbiB3cml0dGVuIHRvIGEgbWFqb3JpdHkgb2YgdGhlIHJlcGxpY2Egc2V0IG1lbWJlcnMgKGkuZS4gbWF5IGJlIHJvbGxlZCBiYWNrKS5cbiAqICAgICBhdmFpbGFibGUgICAgIE1vbmdvREIgMy42KyBUaGUgcXVlcnkgcmV0dXJucyBmcm9tIHRoZSBpbnN0YW5jZSB3aXRoIG5vIGd1YXJhbnRlZSBndWFyYW50ZWUgdGhhdCB0aGUgZGF0YSBoYXMgYmVlbiB3cml0dGVuIHRvIGEgbWFqb3JpdHkgb2YgdGhlIHJlcGxpY2Egc2V0IG1lbWJlcnMgKGkuZS4gbWF5IGJlIHJvbGxlZCBiYWNrKS5cbiAqICAgICBtYWpvcml0eSAgICAgIE1vbmdvREIgMy4yKyBUaGUgcXVlcnkgcmV0dXJucyB0aGUgZGF0YSB0aGF0IGhhcyBiZWVuIGFja25vd2xlZGdlZCBieSBhIG1ham9yaXR5IG9mIHRoZSByZXBsaWNhIHNldCBtZW1iZXJzLiBUaGUgZG9jdW1lbnRzIHJldHVybmVkIGJ5IHRoZSByZWFkIG9wZXJhdGlvbiBhcmUgZHVyYWJsZSwgZXZlbiBpbiB0aGUgZXZlbnQgb2YgZmFpbHVyZS5cbiAqICAgICBsaW5lYXJpemFibGUgIE1vbmdvREIgMy40KyBUaGUgcXVlcnkgcmV0dXJucyBkYXRhIHRoYXQgcmVmbGVjdHMgYWxsIHN1Y2Nlc3NmdWwgbWFqb3JpdHktYWNrbm93bGVkZ2VkIHdyaXRlcyB0aGF0IGNvbXBsZXRlZCBwcmlvciB0byB0aGUgc3RhcnQgb2YgdGhlIHJlYWQgb3BlcmF0aW9uLiBUaGUgcXVlcnkgbWF5IHdhaXQgZm9yIGNvbmN1cnJlbnRseSBleGVjdXRpbmcgd3JpdGVzIHRvIHByb3BhZ2F0ZSB0byBhIG1ham9yaXR5IG9mIHJlcGxpY2Egc2V0IG1lbWJlcnMgYmVmb3JlIHJldHVybmluZyByZXN1bHRzLlxuICogICAgIHNuYXBzaG90ICAgICAgTW9uZ29EQiA0LjArIE9ubHkgYXZhaWxhYmxlIGZvciBvcGVyYXRpb25zIHdpdGhpbiBtdWx0aS1kb2N1bWVudCB0cmFuc2FjdGlvbnMuIFVwb24gdHJhbnNhY3Rpb24gY29tbWl0IHdpdGggd3JpdGUgY29uY2VybiBcIm1ham9yaXR5XCIsIHRoZSB0cmFuc2FjdGlvbiBvcGVyYXRpb25zIGFyZSBndWFyYW50ZWVkIHRvIGhhdmUgcmVhZCBmcm9tIGEgc25hcHNob3Qgb2YgbWFqb3JpdHktY29tbWl0dGVkIGRhdGEuXG4gKlxuICogQWxpYXNlc1xuICpcbiAqICAgICBsICAgbG9jYWxcbiAqICAgICBhICAgYXZhaWxhYmxlXG4gKiAgICAgbSAgIG1ham9yaXR5XG4gKiAgICAgbHogIGxpbmVhcml6YWJsZVxuICogICAgIHMgICBzbmFwc2hvdFxuICpcbiAqIFJlYWQgbW9yZSBhYm91dCBob3cgdG8gdXNlIHJlYWQgY29uY2VybiBbaGVyZV0oaHR0cHM6Ly9kb2NzLm1vbmdvZGIuY29tL21hbnVhbC9yZWZlcmVuY2UvcmVhZC1jb25jZXJuLykuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGxldmVsIG9uZSBvZiB0aGUgbGlzdGVkIHJlYWQgY29uY2VybiBsZXZlbCBvciB0aGVpciBhbGlhc2VzXG4gKiBAc2VlIG1vbmdvZGIgaHR0cHM6Ly9kb2NzLm1vbmdvZGIuY29tL21hbnVhbC9yZWZlcmVuY2UvcmVhZC1jb25jZXJuL1xuICogQHJldHVybiB7UXVlcnl9IHRoaXNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUXVlcnkucHJvdG90eXBlLnJlYWRDb25jZXJuID0gUXVlcnkucHJvdG90eXBlLnIgPSBmdW5jdGlvbihsZXZlbCkge1xuICB0aGlzLm9wdGlvbnMucmVhZENvbmNlcm4gPSB1dGlscy5yZWFkQ29uY2VybihsZXZlbCk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZXRzIHRhaWxhYmxlIG9wdGlvbi5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIHF1ZXJ5LnRhaWxhYmxlKCkgPD09IHRydWVcbiAqICAgICBxdWVyeS50YWlsYWJsZSh0cnVlKVxuICogICAgIHF1ZXJ5LnRhaWxhYmxlKGZhbHNlKVxuICpcbiAqICMjIyMgTm90ZTpcbiAqXG4gKiBDYW5ub3QgYmUgdXNlZCB3aXRoIGBkaXN0aW5jdCgpYFxuICpcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gdiBkZWZhdWx0cyB0byB0cnVlXG4gKiBAc2VlIG1vbmdvZGIgaHR0cDovL3d3dy5tb25nb2RiLm9yZy9kaXNwbGF5L0RPQ1MvVGFpbGFibGUrQ3Vyc29yc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5RdWVyeS5wcm90b3R5cGUudGFpbGFibGUgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5fdmFsaWRhdGUoJ3RhaWxhYmxlJyk7XG5cbiAgdGhpcy5vcHRpb25zLnRhaWxhYmxlID0gYXJndW1lbnRzLmxlbmd0aFxuICAgID8gISFhcmd1bWVudHNbMF1cbiAgICA6IHRydWU7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNldHMgdGhlIHNwZWNpZmllZCBudW1iZXIgb2YgYG1vbmdvZGAgc2VydmVycywgb3IgdGFnIHNldCBvZiBgbW9uZ29kYCBzZXJ2ZXJzLFxuICogdGhhdCBtdXN0IGFja25vd2xlZGdlIHRoaXMgd3JpdGUgYmVmb3JlIHRoaXMgd3JpdGUgaXMgY29uc2lkZXJlZCBzdWNjZXNzZnVsLlxuICogVGhpcyBvcHRpb24gaXMgb25seSB2YWxpZCBmb3Igb3BlcmF0aW9ucyB0aGF0IHdyaXRlIHRvIHRoZSBkYXRhYmFzZTpcbiAqXG4gKiAtIGBkZWxldGVPbmUoKWBcbiAqIC0gYGRlbGV0ZU1hbnkoKWBcbiAqIC0gYGZpbmRPbmVBbmREZWxldGUoKWBcbiAqIC0gYGZpbmRPbmVBbmRVcGRhdGUoKWBcbiAqIC0gYHVwZGF0ZU9uZSgpYFxuICogLSBgdXBkYXRlTWFueSgpYFxuICpcbiAqIERlZmF1bHRzIHRvIHRoZSBgd2AgdmFsdWUgaWYgaXQgaXMgc3BlY2lmaWVkIGluIHdyaXRlQ29uY2VybiBvcHRpb25zXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBtcXVlcnkoKS53cml0ZUNvbmNlcm4oMClcbiAqICAgICBtcXVlcnkoKS53cml0ZUNvbmNlcm4oMSlcbiAqICAgICBtcXVlcnkoKS53cml0ZUNvbmNlcm4oeyB3OiAxLCBqOiB0cnVlLCB3dGltZW91dDogMjAwMCB9KVxuICogICAgIG1xdWVyeSgpLndyaXRlQ29uY2VybignbWFqb3JpdHknKVxuICogICAgIG1xdWVyeSgpLndyaXRlQ29uY2VybignbScpIC8vIHNhbWUgYXMgbWFqb3JpdHlcbiAqICAgICBtcXVlcnkoKS53cml0ZUNvbmNlcm4oJ3RhZ1NldE5hbWUnKSAvLyBpZiB0aGUgdGFnIHNldCBpcyAnbScsIHVzZSAud3JpdGVDb25jZXJuKHsgdzogJ20nIH0pIGluc3RlYWRcbiAqICAgICBtcXVlcnkoKS53KDEpIC8vIHcgaXMgYWxpYXMgb2Ygd3JpdGVDb25jZXJuXG4gKlxuICogQG1ldGhvZCB3cml0ZUNvbmNlcm5cbiAqIEBtZW1iZXJPZiBRdWVyeVxuICogQGluc3RhbmNlXG4gKiBAcGFyYW0ge1N0cmluZ3xudW1iZXJ8b2JqZWN0fSBjb25jZXJuIDAgZm9yIGZpcmUtYW5kLWZvcmdldCwgMSBmb3IgYWNrbm93bGVkZ2VkIGJ5IG9uZSBzZXJ2ZXIsICdtYWpvcml0eScgZm9yIG1ham9yaXR5IG9mIHRoZSByZXBsaWNhIHNldCwgb3IgW2FueSBvZiB0aGUgbW9yZSBhZHZhbmNlZCBvcHRpb25zXShodHRwczovL2RvY3MubW9uZ29kYi5jb20vbWFudWFsL3JlZmVyZW5jZS93cml0ZS1jb25jZXJuLyN3LW9wdGlvbikuXG4gKiBAc2VlIG1vbmdvZGIgaHR0cHM6Ly9kb2NzLm1vbmdvZGIuY29tL21hbnVhbC9yZWZlcmVuY2Uvd3JpdGUtY29uY2Vybi8jdy1vcHRpb25cbiAqIEByZXR1cm4ge1F1ZXJ5fSB0aGlzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblF1ZXJ5LnByb3RvdHlwZS53cml0ZUNvbmNlcm4gPSBRdWVyeS5wcm90b3R5cGUudyA9IGZ1bmN0aW9uIHdyaXRlQ29uY2Vybihjb25jZXJuKSB7XG4gIGlmICgnb2JqZWN0JyA9PT0gdHlwZW9mIGNvbmNlcm4pIHtcbiAgICBpZiAoJ3VuZGVmaW5lZCcgIT09IHR5cGVvZiBjb25jZXJuLmopIHRoaXMub3B0aW9ucy5qID0gY29uY2Vybi5qO1xuICAgIGlmICgndW5kZWZpbmVkJyAhPT0gdHlwZW9mIGNvbmNlcm4udykgdGhpcy5vcHRpb25zLncgPSBjb25jZXJuLnc7XG4gICAgaWYgKCd1bmRlZmluZWQnICE9PSB0eXBlb2YgY29uY2Vybi53dGltZW91dCkgdGhpcy5vcHRpb25zLnd0aW1lb3V0ID0gY29uY2Vybi53dGltZW91dDtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLm9wdGlvbnMudyA9ICdtJyA9PT0gY29uY2VybiA/ICdtYWpvcml0eScgOiBjb25jZXJuO1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTcGVjaWZpZXMgYSB0aW1lIGxpbWl0LCBpbiBtaWxsaXNlY29uZHMsIGZvciB0aGUgd3JpdGUgY29uY2Vybi5cbiAqIElmIGBtcyA+IDFgLCBpdCBpcyBtYXhpbXVtIGFtb3VudCBvZiB0aW1lIHRvIHdhaXQgZm9yIHRoaXMgd3JpdGVcbiAqIHRvIHByb3BhZ2F0ZSB0aHJvdWdoIHRoZSByZXBsaWNhIHNldCBiZWZvcmUgdGhpcyBvcGVyYXRpb24gZmFpbHMuXG4gKiBUaGUgZGVmYXVsdCBpcyBgMGAsIHdoaWNoIG1lYW5zIG5vIHRpbWVvdXQuXG4gKlxuICogVGhpcyBvcHRpb24gaXMgb25seSB2YWxpZCBmb3Igb3BlcmF0aW9ucyB0aGF0IHdyaXRlIHRvIHRoZSBkYXRhYmFzZTpcbiAqXG4gKiAtIGBkZWxldGVPbmUoKWBcbiAqIC0gYGRlbGV0ZU1hbnkoKWBcbiAqIC0gYGZpbmRPbmVBbmREZWxldGUoKWBcbiAqIC0gYGZpbmRPbmVBbmRVcGRhdGUoKWBcbiAqIC0gYHVwZGF0ZU9uZSgpYFxuICogLSBgdXBkYXRlTWFueSgpYFxuICpcbiAqIERlZmF1bHRzIHRvIGB3dGltZW91dGAgdmFsdWUgaWYgaXQgaXMgc3BlY2lmaWVkIGluIHdyaXRlQ29uY2VyblxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgbXF1ZXJ5KCkudygyKS5qKHRydWUpLnd0aW1lb3V0KDIwMDApXG4gKlxuICogQG1ldGhvZCB3dGltZW91dFxuICogQG1lbWJlck9mIFF1ZXJ5XG4gKiBAaW5zdGFuY2VcbiAqIEBwYXJhbSB7bnVtYmVyfSBtcyBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRvIHdhaXRcbiAqIEBzZWUgbW9uZ29kYiBodHRwczovL2RvY3MubW9uZ29kYi5jb20vbWFudWFsL3JlZmVyZW5jZS93cml0ZS1jb25jZXJuLyN3dGltZW91dFxuICogQHJldHVybiB7UXVlcnl9IHRoaXNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUXVlcnkucHJvdG90eXBlLnd0aW1lb3V0ID0gUXVlcnkucHJvdG90eXBlLndUaW1lb3V0ID0gZnVuY3Rpb24gd3RpbWVvdXQobXMpIHtcbiAgdGhpcy5vcHRpb25zLnd0aW1lb3V0ID0gbXM7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBNZXJnZXMgYW5vdGhlciBRdWVyeSBvciBjb25kaXRpb25zIG9iamVjdCBpbnRvIHRoaXMgb25lLlxuICpcbiAqIFdoZW4gYSBRdWVyeSBpcyBwYXNzZWQsIGNvbmRpdGlvbnMsIGZpZWxkIHNlbGVjdGlvbiBhbmQgb3B0aW9ucyBhcmUgbWVyZ2VkLlxuICpcbiAqIEBwYXJhbSB7UXVlcnl8T2JqZWN0fSBzb3VyY2VcbiAqIEByZXR1cm4ge1F1ZXJ5fSB0aGlzXG4gKi9cblxuUXVlcnkucHJvdG90eXBlLm1lcmdlID0gZnVuY3Rpb24oc291cmNlKSB7XG4gIGlmICghc291cmNlKVxuICAgIHJldHVybiB0aGlzO1xuXG4gIGlmICghUXVlcnkuY2FuTWVyZ2Uoc291cmNlKSlcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIGFyZ3VtZW50LiBFeHBlY3RlZCBpbnN0YW5jZW9mIG1xdWVyeSBvciBwbGFpbiBvYmplY3QnKTtcblxuICBpZiAoc291cmNlIGluc3RhbmNlb2YgUXVlcnkpIHtcbiAgICAvLyBpZiBzb3VyY2UgaGFzIGEgZmVhdHVyZSwgYXBwbHkgaXQgdG8gb3Vyc2VsdmVzXG5cbiAgICBpZiAoc291cmNlLl9jb25kaXRpb25zKSB7XG4gICAgICB1dGlscy5tZXJnZSh0aGlzLl9jb25kaXRpb25zLCBzb3VyY2UuX2NvbmRpdGlvbnMpO1xuICAgIH1cblxuICAgIGlmIChzb3VyY2UuX2ZpZWxkcykge1xuICAgICAgdGhpcy5fZmllbGRzIHx8ICh0aGlzLl9maWVsZHMgPSB7fSk7XG4gICAgICB1dGlscy5tZXJnZSh0aGlzLl9maWVsZHMsIHNvdXJjZS5fZmllbGRzKTtcbiAgICB9XG5cbiAgICBpZiAoc291cmNlLm9wdGlvbnMpIHtcbiAgICAgIHRoaXMub3B0aW9ucyB8fCAodGhpcy5vcHRpb25zID0ge30pO1xuICAgICAgdXRpbHMubWVyZ2UodGhpcy5vcHRpb25zLCBzb3VyY2Uub3B0aW9ucyk7XG4gICAgfVxuXG4gICAgaWYgKHNvdXJjZS5fdXBkYXRlRG9jKSB7XG4gICAgICB0aGlzLl91cGRhdGVEb2MgfHwgKHRoaXMuX3VwZGF0ZURvYyA9IHt9KTtcbiAgICAgIHV0aWxzLm1lcmdlQ2xvbmUodGhpcy5fdXBkYXRlRG9jLCBzb3VyY2UuX3VwZGF0ZURvYyk7XG4gICAgfVxuXG4gICAgaWYgKHNvdXJjZS5fZGlzdGluY3REb2MpIHtcbiAgICAgIHRoaXMuX2Rpc3RpbmN0RG9jID0gc291cmNlLl9kaXN0aW5jdERvYztcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIHBsYWluIG9iamVjdFxuICB1dGlscy5tZXJnZSh0aGlzLl9jb25kaXRpb25zLCBzb3VyY2UpO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBGaW5kcyBkb2N1bWVudHMuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBxdWVyeS5maW5kKClcbiAqICAgICBhd2FpdCBxdWVyeS5maW5kKClcbiAqICAgICBhd2FpdCBxdWVyeS5maW5kKHsgbmFtZTogJ0J1cm5pbmcgTGlnaHRzJyB9KVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBbY3JpdGVyaWFdIG1vbmdvZGIgc2VsZWN0b3JcbiAqIEByZXR1cm4ge1F1ZXJ5fSB0aGlzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblF1ZXJ5LnByb3RvdHlwZS5maW5kID0gZnVuY3Rpb24oY3JpdGVyaWEpIHtcbiAgdGhpcy5vcCA9ICdmaW5kJztcblxuICBpZiAoUXVlcnkuY2FuTWVyZ2UoY3JpdGVyaWEpKSB7XG4gICAgdGhpcy5tZXJnZShjcml0ZXJpYSk7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogRXhlY3V0ZXMgYSBgZmluZGAgUXVlcnlcbiAqIEByZXR1cm5zIHRoZSByZXN1bHRcbiAqL1xuUXVlcnkucHJvdG90eXBlLl9maW5kID0gYXN5bmMgZnVuY3Rpb24gX2ZpbmQoKSB7XG4gIGNvbnN0IGNvbmRzID0gdGhpcy5fY29uZGl0aW9ucztcbiAgY29uc3Qgb3B0aW9ucyA9IHRoaXMuX29wdGlvbnNGb3JFeGVjKCk7XG5cbiAgaWYgKHRoaXMuJHVzZVByb2plY3Rpb24pIHtcbiAgICBvcHRpb25zLnByb2plY3Rpb24gPSB0aGlzLl9maWVsZHNGb3JFeGVjKCk7XG4gIH0gZWxzZSB7XG4gICAgb3B0aW9ucy5maWVsZHMgPSB0aGlzLl9maWVsZHNGb3JFeGVjKCk7XG4gIH1cblxuICBkZWJ1ZygnX2ZpbmQnLCB0aGlzLl9jb2xsZWN0aW9uLmNvbGxlY3Rpb25OYW1lLCBjb25kcywgb3B0aW9ucyk7XG5cbiAgcmV0dXJuIHRoaXMuX2NvbGxlY3Rpb24uZmluZChjb25kcywgb3B0aW9ucyk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIHF1ZXJ5IGN1cnNvclxuICpcbiAqICMjIyMgRXhhbXBsZXM6XG4gKlxuICogICAgIHF1ZXJ5LmZpbmQoKS5jdXJzb3IoKTtcbiAqICAgICBxdWVyeS5jdXJzb3IoeyBuYW1lOiAnQnVybmluZyBMaWdodHMnIH0pO1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBbY3JpdGVyaWFdIG1vbmdvZGIgc2VsZWN0b3JcbiAqIEByZXR1cm4ge09iamVjdH0gY3Vyc29yXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblF1ZXJ5LnByb3RvdHlwZS5jdXJzb3IgPSBmdW5jdGlvbiBjdXJzb3IoY3JpdGVyaWEpIHtcbiAgaWYgKHRoaXMub3ApIHtcbiAgICBpZiAodGhpcy5vcCAhPT0gJ2ZpbmQnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCcuY3Vyc29yIG9ubHkgc3VwcG9ydCAuZmluZCBtZXRob2QnKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5maW5kKGNyaXRlcmlhKTtcbiAgfVxuXG4gIGNvbnN0IGNvbmRzID0gdGhpcy5fY29uZGl0aW9ucztcbiAgY29uc3Qgb3B0aW9ucyA9IHRoaXMuX29wdGlvbnNGb3JFeGVjKCk7XG5cbiAgaWYgKHRoaXMuJHVzZVByb2plY3Rpb24pIHtcbiAgICBvcHRpb25zLnByb2plY3Rpb24gPSB0aGlzLl9maWVsZHNGb3JFeGVjKCk7XG4gIH0gZWxzZSB7XG4gICAgb3B0aW9ucy5maWVsZHMgPSB0aGlzLl9maWVsZHNGb3JFeGVjKCk7XG4gIH1cblxuICBkZWJ1ZygnZmluZEN1cnNvcicsIHRoaXMuX2NvbGxlY3Rpb24uY29sbGVjdGlvbk5hbWUsIGNvbmRzLCBvcHRpb25zKTtcbiAgcmV0dXJuIHRoaXMuX2NvbGxlY3Rpb24uZmluZEN1cnNvcihjb25kcywgb3B0aW9ucyk7XG59O1xuXG4vKipcbiAqIEV4ZWN1dGVzIHRoZSBxdWVyeSBhcyBhIGZpbmRPbmUoKSBvcGVyYXRpb24uXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBxdWVyeS5maW5kT25lKCkud2hlcmUoJ25hbWUnLCAvXkJ1cm5pbmcvKTtcbiAqXG4gKiAgICAgcXVlcnkuZmluZE9uZSh7IG5hbWU6IC9eQnVybmluZy8gfSlcbiAqXG4gKiAgICAgYXdhaXQgcXVlcnkuZmluZE9uZSh7IG5hbWU6IC9eQnVybmluZy8gfSk7IC8vIGV4ZWN1dGVzXG4gKlxuICogQHBhcmFtIHtPYmplY3R8UXVlcnl9IFtjcml0ZXJpYV0gbW9uZ29kYiBzZWxlY3RvclxuICogQHJldHVybiB7UXVlcnl9IHRoaXNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUXVlcnkucHJvdG90eXBlLmZpbmRPbmUgPSBmdW5jdGlvbihjcml0ZXJpYSkge1xuICB0aGlzLm9wID0gJ2ZpbmRPbmUnO1xuXG4gIGlmIChRdWVyeS5jYW5NZXJnZShjcml0ZXJpYSkpIHtcbiAgICB0aGlzLm1lcmdlKGNyaXRlcmlhKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBFeGVjdXRlcyBhIGBmaW5kT25lYCBRdWVyeVxuICogQHJldHVybnMgdGhlIHJlc3VsdHNcbiAqL1xuUXVlcnkucHJvdG90eXBlLl9maW5kT25lID0gYXN5bmMgZnVuY3Rpb24gX2ZpbmRPbmUoKSB7XG4gIGNvbnN0IGNvbmRzID0gdGhpcy5fY29uZGl0aW9ucztcbiAgY29uc3Qgb3B0aW9ucyA9IHRoaXMuX29wdGlvbnNGb3JFeGVjKCk7XG5cbiAgaWYgKHRoaXMuJHVzZVByb2plY3Rpb24pIHtcbiAgICBvcHRpb25zLnByb2plY3Rpb24gPSB0aGlzLl9maWVsZHNGb3JFeGVjKCk7XG4gIH0gZWxzZSB7XG4gICAgb3B0aW9ucy5maWVsZHMgPSB0aGlzLl9maWVsZHNGb3JFeGVjKCk7XG4gIH1cblxuICBkZWJ1ZygnZmluZE9uZScsIHRoaXMuX2NvbGxlY3Rpb24uY29sbGVjdGlvbk5hbWUsIGNvbmRzLCBvcHRpb25zKTtcblxuICByZXR1cm4gdGhpcy5fY29sbGVjdGlvbi5maW5kT25lKGNvbmRzLCBvcHRpb25zKTtcbn07XG5cbi8qKlxuICogRXhlY3R1ZXMgdGhlIHF1ZXJ5IGFzIGEgY291bnQoKSBvcGVyYXRpb24uXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBxdWVyeS5jb3VudCgpLndoZXJlKCdjb2xvcicsICdibGFjaycpLmV4ZWMoKTtcbiAqXG4gKiAgICAgcXVlcnkuY291bnQoeyBjb2xvcjogJ2JsYWNrJyB9KVxuICpcbiAqICAgICBhd2FpdCBxdWVyeS5jb3VudCh7IGNvbG9yOiAnYmxhY2snIH0pO1xuICpcbiAqICAgICBjb25zdCBkb2MgPSBhd2FpdCBxdWVyeS53aGVyZSgnY29sb3InLCAnYmxhY2snKS5jb3VudCgpO1xuICogICAgIGNvbnNvbGUubG9nKCd0aGVyZSBhcmUgJWQga2l0dGVucycsIGNvdW50KTtcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gW2NyaXRlcmlhXSBtb25nb2RiIHNlbGVjdG9yXG4gKiBAcmV0dXJuIHtRdWVyeX0gdGhpc1xuICogQHNlZSBtb25nb2RiIGh0dHA6Ly93d3cubW9uZ29kYi5vcmcvZGlzcGxheS9ET0NTL0FnZ3JlZ2F0aW9uI0FnZ3JlZ2F0aW9uLUNvdW50XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblF1ZXJ5LnByb3RvdHlwZS5jb3VudCA9IGZ1bmN0aW9uKGNyaXRlcmlhKSB7XG4gIHRoaXMub3AgPSAnY291bnQnO1xuICB0aGlzLl92YWxpZGF0ZSgpO1xuXG4gIGlmIChRdWVyeS5jYW5NZXJnZShjcml0ZXJpYSkpIHtcbiAgICB0aGlzLm1lcmdlKGNyaXRlcmlhKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBFeGVjdXRlcyBhIGBjb3VudGAgUXVlcnlcbiAqIEByZXR1cm5zIHRoZSByZXN1bHRzXG4gKi9cblF1ZXJ5LnByb3RvdHlwZS5fY291bnQgPSBhc3luYyBmdW5jdGlvbiBfY291bnQoKSB7XG4gIGNvbnN0IGNvbmRzID0gdGhpcy5fY29uZGl0aW9ucyxcbiAgICAgIG9wdGlvbnMgPSB0aGlzLl9vcHRpb25zRm9yRXhlYygpO1xuXG4gIGRlYnVnKCdjb3VudCcsIHRoaXMuX2NvbGxlY3Rpb24uY29sbGVjdGlvbk5hbWUsIGNvbmRzLCBvcHRpb25zKTtcblxuICByZXR1cm4gdGhpcy5fY29sbGVjdGlvbi5jb3VudChjb25kcywgb3B0aW9ucyk7XG59O1xuXG4vKipcbiAqIERlY2xhcmVzIG9yIGV4ZWN1dGVzIGEgZGlzdGluY3QoKSBvcGVyYXRpb24uXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBhd2FpdCBkaXN0aW5jdChjcml0ZXJpYSwgZmllbGQpXG4gKiAgICAgZGlzdGluY3QoY3JpdGVyaWEsIGZpZWxkKVxuICogICAgIGF3YWl0IGRpc3RpbmN0KGZpZWxkKVxuICogICAgIGRpc3RpbmN0KGZpZWxkKVxuICogICAgIGF3YWl0IGRpc3RpbmN0KClcbiAqICAgICBkaXN0aW5jdCgpXG4gKlxuICogQHBhcmFtIHtPYmplY3R8UXVlcnl9IFtjcml0ZXJpYV1cbiAqIEBwYXJhbSB7U3RyaW5nfSBbZmllbGRdXG4gKiBAcmV0dXJuIHtRdWVyeX0gdGhpc1xuICogQHNlZSBtb25nb2RiIGh0dHA6Ly93d3cubW9uZ29kYi5vcmcvZGlzcGxheS9ET0NTL0FnZ3JlZ2F0aW9uI0FnZ3JlZ2F0aW9uLURpc3RpbmN0XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblF1ZXJ5LnByb3RvdHlwZS5kaXN0aW5jdCA9IGZ1bmN0aW9uKGNyaXRlcmlhLCBmaWVsZCkge1xuICB0aGlzLm9wID0gJ2Rpc3RpbmN0JztcbiAgdGhpcy5fdmFsaWRhdGUoKTtcblxuICBpZiAoIWZpZWxkICYmIHR5cGVvZiBjcml0ZXJpYSA9PT0gJ3N0cmluZycpIHtcbiAgICBmaWVsZCA9IGNyaXRlcmlhO1xuICAgIGNyaXRlcmlhID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgaWYgKCdzdHJpbmcnID09IHR5cGVvZiBmaWVsZCkge1xuICAgIHRoaXMuX2Rpc3RpbmN0RG9jID0gZmllbGQ7XG4gIH1cblxuICBpZiAoUXVlcnkuY2FuTWVyZ2UoY3JpdGVyaWEpKSB7XG4gICAgdGhpcy5tZXJnZShjcml0ZXJpYSk7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogRXhlY3V0ZXMgYSBgZGlzdGluY3RgIFF1ZXJ5XG4gKiBAcmV0dXJucyB0aGUgcmVzdWx0c1xuICovXG5RdWVyeS5wcm90b3R5cGUuX2Rpc3RpbmN0ID0gYXN5bmMgZnVuY3Rpb24gX2Rpc3RpbmN0KCkge1xuICBpZiAoIXRoaXMuX2Rpc3RpbmN0RG9jKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdObyB2YWx1ZSBmb3IgYGRpc3RpbmN0YCBoYXMgYmVlbiBkZWNsYXJlZCcpO1xuICB9XG5cbiAgY29uc3QgY29uZHMgPSB0aGlzLl9jb25kaXRpb25zLFxuICAgICAgb3B0aW9ucyA9IHRoaXMuX29wdGlvbnNGb3JFeGVjKCk7XG5cbiAgZGVidWcoJ2Rpc3RpbmN0JywgdGhpcy5fY29sbGVjdGlvbi5jb2xsZWN0aW9uTmFtZSwgY29uZHMsIG9wdGlvbnMpO1xuXG4gIHJldHVybiB0aGlzLl9jb2xsZWN0aW9uLmRpc3RpbmN0KHRoaXMuX2Rpc3RpbmN0RG9jLCBjb25kcywgb3B0aW9ucyk7XG59O1xuXG4vKipcbiAqIERlY2xhcmUgYW5kL29yIGV4ZWN1dGUgdGhpcyBxdWVyeSBhcyBhbiBgdXBkYXRlTWFueSgpYCBvcGVyYXRpb24uIFRoaXMgZnVuY3Rpb24gd2lsbCB1cGRhdGUgX2FsbF8gZG9jdW1lbnRzIHRoYXQgbWF0Y2hcbiAqIGBjcml0ZXJpYWAsIHJhdGhlciB0aGFuIGp1c3QgdGhlIGZpcnN0IG9uZS5cbiAqXG4gKiBfQWxsIHBhdGhzIHBhc3NlZCB0aGF0IGFyZSBub3QgJGF0b21pYyBvcGVyYXRpb25zIHdpbGwgYmVjb21lICRzZXQgb3BzLl9cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIC8vIFVwZGF0ZSBldmVyeSBkb2N1bWVudCB3aG9zZSBgdGl0bGVgIGNvbnRhaW5zICd0ZXN0J1xuICogICAgIG1xdWVyeSgpLnVwZGF0ZU1hbnkoeyB0aXRsZTogL3Rlc3QvIH0sIHsgeWVhcjogMjAxNyB9KVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBbY3JpdGVyaWFdXG4gKiBAcGFyYW0ge09iamVjdH0gW2RvY10gdGhlIHVwZGF0ZSBjb21tYW5kXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiBAcmV0dXJuIHtRdWVyeX0gdGhpc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5RdWVyeS5wcm90b3R5cGUudXBkYXRlTWFueSA9IGZ1bmN0aW9uIHVwZGF0ZU1hbnkoY3JpdGVyaWEsIGRvYywgb3B0aW9ucykge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgIGRvYyA9IGNyaXRlcmlhO1xuICAgIGNyaXRlcmlhID0gb3B0aW9ucyA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIHJldHVybiBfdXBkYXRlKHRoaXMsICd1cGRhdGVNYW55JywgY3JpdGVyaWEsIGRvYywgb3B0aW9ucyk7XG59O1xuXG4vKipcbiAqIEV4ZWN1dGVzIGEgYHVwZGF0ZU1hbnlgIFF1ZXJ5XG4gKiBAcmV0dXJucyB0aGUgcmVzdWx0c1xuICovXG5RdWVyeS5wcm90b3R5cGUuX3VwZGF0ZU1hbnkgPSBhc3luYyBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIF91cGRhdGVFeGVjKHRoaXMsICd1cGRhdGVNYW55Jyk7XG59O1xuXG4vKipcbiAqIERlY2xhcmUgYW5kL29yIGV4ZWN1dGUgdGhpcyBxdWVyeSBhcyBhbiBgdXBkYXRlT25lKClgIG9wZXJhdGlvbi4gVGhpcyBmdW5jdGlvbiB3aWxsIF9hbHdheXNfIHVwZGF0ZSBqdXN0IG9uZSBkb2N1bWVudCxcbiAqIHJlZ2FyZGxlc3Mgb2YgdGhlIGBtdWx0aWAgb3B0aW9uLlxuICpcbiAqIF9BbGwgcGF0aHMgcGFzc2VkIHRoYXQgYXJlIG5vdCAkYXRvbWljIG9wZXJhdGlvbnMgd2lsbCBiZWNvbWUgJHNldCBvcHMuX1xuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgLy8gVXBkYXRlIHRoZSBmaXJzdCBkb2N1bWVudCB3aG9zZSBgdGl0bGVgIGNvbnRhaW5zICd0ZXN0J1xuICogICAgIG1xdWVyeSgpLnVwZGF0ZU1hbnkoeyB0aXRsZTogL3Rlc3QvIH0sIHsgeWVhcjogMjAxNyB9KVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBbY3JpdGVyaWFdXG4gKiBAcGFyYW0ge09iamVjdH0gW2RvY10gdGhlIHVwZGF0ZSBjb21tYW5kXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiBAcmV0dXJuIHtRdWVyeX0gdGhpc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5RdWVyeS5wcm90b3R5cGUudXBkYXRlT25lID0gZnVuY3Rpb24gdXBkYXRlT25lKGNyaXRlcmlhLCBkb2MsIG9wdGlvbnMpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICBkb2MgPSBjcml0ZXJpYTtcbiAgICBjcml0ZXJpYSA9IG9wdGlvbnMgPSB1bmRlZmluZWQ7XG4gIH1cblxuICByZXR1cm4gX3VwZGF0ZSh0aGlzLCAndXBkYXRlT25lJywgY3JpdGVyaWEsIGRvYywgb3B0aW9ucyk7XG59O1xuXG4vKipcbiAqIEV4ZWN1dGVzIGEgYHVwZGF0ZU9uZWAgUXVlcnlcbiAqIEByZXR1cm5zIHRoZSByZXN1bHRzXG4gKi9cblF1ZXJ5LnByb3RvdHlwZS5fdXBkYXRlT25lID0gYXN5bmMgZnVuY3Rpb24oKSB7XG4gIHJldHVybiBfdXBkYXRlRXhlYyh0aGlzLCAndXBkYXRlT25lJyk7XG59O1xuXG4vKipcbiAqIERlY2xhcmUgYW5kL29yIGV4ZWN1dGUgdGhpcyBxdWVyeSBhcyBhbiBgcmVwbGFjZU9uZSgpYCBvcGVyYXRpb24uIFNpbWlsYXJcbiAqIHRvIGB1cGRhdGVPbmUoKWAsIGV4Y2VwdCBgcmVwbGFjZU9uZSgpYCBpcyBub3QgYWxsb3dlZCB0byB1c2UgYXRvbWljXG4gKiBtb2RpZmllcnMgKGAkc2V0YCwgYCRwdXNoYCwgZXRjLikuIENhbGxpbmcgYHJlcGxhY2VPbmUoKWAgd2lsbCBhbHdheXNcbiAqIHJlcGxhY2UgdGhlIGV4aXN0aW5nIGRvYy5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIC8vIFJlcGxhY2UgdGhlIGRvY3VtZW50IHdpdGggYF9pZGAgMSB3aXRoIGB7IF9pZDogMSwgeWVhcjogMjAxNyB9YFxuICogICAgIG1xdWVyeSgpLnJlcGxhY2VPbmUoeyBfaWQ6IDEgfSwgeyB5ZWFyOiAyMDE3IH0pXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IFtjcml0ZXJpYV1cbiAqIEBwYXJhbSB7T2JqZWN0fSBbZG9jXSB0aGUgdXBkYXRlIGNvbW1hbmRcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEByZXR1cm4ge1F1ZXJ5fSB0aGlzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblF1ZXJ5LnByb3RvdHlwZS5yZXBsYWNlT25lID0gZnVuY3Rpb24gcmVwbGFjZU9uZShjcml0ZXJpYSwgZG9jLCBvcHRpb25zKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgZG9jID0gY3JpdGVyaWE7XG4gICAgY3JpdGVyaWEgPSBvcHRpb25zID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgdGhpcy5zZXRPcHRpb25zKHsgb3ZlcndyaXRlOiB0cnVlIH0pO1xuICByZXR1cm4gX3VwZGF0ZSh0aGlzLCAncmVwbGFjZU9uZScsIGNyaXRlcmlhLCBkb2MsIG9wdGlvbnMpO1xufTtcblxuLyoqXG4gKiBFeGVjdXRlcyBhIGByZXBsYWNlT25lYCBRdWVyeVxuICogQHJldHVybnMgdGhlIHJlc3VsdHNcbiAqL1xuUXVlcnkucHJvdG90eXBlLl9yZXBsYWNlT25lID0gYXN5bmMgZnVuY3Rpb24oKSB7XG4gIHJldHVybiBfdXBkYXRlRXhlYyh0aGlzLCAncmVwbGFjZU9uZScpO1xufTtcblxuLyohXG4gKiBJbnRlcm5hbCBoZWxwZXIgZm9yIHVwZGF0ZU1hbnksIHVwZGF0ZU9uZVxuICovXG5cbmZ1bmN0aW9uIF91cGRhdGUocXVlcnksIG9wLCBjcml0ZXJpYSwgZG9jLCBvcHRpb25zKSB7XG4gIHF1ZXJ5Lm9wID0gb3A7XG5cbiAgaWYgKFF1ZXJ5LmNhbk1lcmdlKGNyaXRlcmlhKSkge1xuICAgIHF1ZXJ5Lm1lcmdlKGNyaXRlcmlhKTtcbiAgfVxuXG4gIGlmIChkb2MpIHtcbiAgICBxdWVyeS5fbWVyZ2VVcGRhdGUoZG9jKTtcbiAgfVxuXG4gIGlmICh1dGlscy5pc09iamVjdChvcHRpb25zKSkge1xuICAgIC8vIHsgb3ZlcndyaXRlOiB0cnVlIH1cbiAgICBxdWVyeS5zZXRPcHRpb25zKG9wdGlvbnMpO1xuICB9XG5cbiAgcmV0dXJuIHF1ZXJ5O1xufVxuXG4vKipcbiAqIEhlbHBlciBmb3IgZGUtZHVwbGljYXRpbmcgXCJ1cGRhdGUqXCIgZnVuY3Rpb25zXG4gKiBAcGFyYW0ge1F1ZXJ5fSBxdWVyeSBUaGUgUXVlcnkgT2JqZWN0IChyZXBsYWNlbWVudCBmb3IgXCJ0aGlzXCIpXG4gKiBAcGFyYW0ge1N0cmluZ30gb3AgVGhlIE9wZXJhdGlvbiB0byBiZSBkb25lXG4gKiBAcmV0dXJucyB0aGUgcmVzdWx0c1xuICovXG5hc3luYyBmdW5jdGlvbiBfdXBkYXRlRXhlYyhxdWVyeSwgb3ApIHtcbiAgY29uc3Qgb3B0aW9ucyA9IHF1ZXJ5Ll9vcHRpb25zRm9yRXhlYygpO1xuXG4gIGNvbnN0IGNyaXRlcmlhID0gcXVlcnkuX2NvbmRpdGlvbnM7XG4gIGNvbnN0IGRvYyA9IHF1ZXJ5Ll91cGRhdGVGb3JFeGVjKCk7XG5cbiAgZGVidWcoJ3VwZGF0ZScsIHF1ZXJ5Ll9jb2xsZWN0aW9uLmNvbGxlY3Rpb25OYW1lLCBjcml0ZXJpYSwgZG9jLCBvcHRpb25zKTtcblxuICByZXR1cm4gcXVlcnkuX2NvbGxlY3Rpb25bb3BdKGNyaXRlcmlhLCBkb2MsIG9wdGlvbnMpO1xufVxuXG4vKipcbiAqIERlY2xhcmUgYW5kL29yIGV4ZWN1dGUgdGhpcyBxdWVyeSBhcyBhIGBkZWxldGVPbmUoKWAgb3BlcmF0aW9uLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgYXdhaXQgbXF1ZXJ5KGNvbGxlY3Rpb24pLmRlbGV0ZU9uZSh7IGFydGlzdDogJ0FubmUgTXVycmF5JyB9KVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fFF1ZXJ5fSBbY3JpdGVyaWFdIG1vbmdvZGIgc2VsZWN0b3JcbiAqIEByZXR1cm4ge1F1ZXJ5fSB0aGlzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblF1ZXJ5LnByb3RvdHlwZS5kZWxldGVPbmUgPSBmdW5jdGlvbihjcml0ZXJpYSkge1xuICB0aGlzLm9wID0gJ2RlbGV0ZU9uZSc7XG5cbiAgaWYgKFF1ZXJ5LmNhbk1lcmdlKGNyaXRlcmlhKSkge1xuICAgIHRoaXMubWVyZ2UoY3JpdGVyaWEpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEV4ZWN1dGVzIGEgYGRlbGV0ZU9uZWAgUXVlcnlcbiAqIEByZXR1cm5zIHRoZSByZXN1bHRzXG4gKi9cblF1ZXJ5LnByb3RvdHlwZS5fZGVsZXRlT25lID0gYXN5bmMgZnVuY3Rpb24oKSB7XG4gIGNvbnN0IG9wdGlvbnMgPSB0aGlzLl9vcHRpb25zRm9yRXhlYygpO1xuICBkZWxldGUgb3B0aW9ucy5qdXN0T25lO1xuXG4gIGNvbnN0IGNvbmRzID0gdGhpcy5fY29uZGl0aW9ucztcblxuICBkZWJ1ZygnZGVsZXRlT25lJywgdGhpcy5fY29sbGVjdGlvbi5jb2xsZWN0aW9uTmFtZSwgY29uZHMsIG9wdGlvbnMpO1xuXG4gIHJldHVybiB0aGlzLl9jb2xsZWN0aW9uLmRlbGV0ZU9uZShjb25kcywgb3B0aW9ucyk7XG59O1xuXG4vKipcbiAqIERlY2xhcmUgYW5kL29yIGV4ZWN1dGUgdGhpcyBxdWVyeSBhcyBhIGBkZWxldGVNYW55KClgIG9wZXJhdGlvbi4gQWx3YXlzIGRlbGV0ZXNcbiAqIF9ldmVyeV8gZG9jdW1lbnQgdGhhdCBtYXRjaGVzIGBjcml0ZXJpYWAuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBhd2FpdCBtcXVlcnkoY29sbGVjdGlvbikuZGVsZXRlTWFueSh7IGFydGlzdDogJ0FubmUgTXVycmF5JyB9KVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fFF1ZXJ5fSBbY3JpdGVyaWFdIG1vbmdvZGIgc2VsZWN0b3JcbiAqIEByZXR1cm4ge1F1ZXJ5fSB0aGlzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblF1ZXJ5LnByb3RvdHlwZS5kZWxldGVNYW55ID0gZnVuY3Rpb24oY3JpdGVyaWEpIHtcbiAgdGhpcy5vcCA9ICdkZWxldGVNYW55JztcblxuICBpZiAoUXVlcnkuY2FuTWVyZ2UoY3JpdGVyaWEpKSB7XG4gICAgdGhpcy5tZXJnZShjcml0ZXJpYSk7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogRXhlY3V0ZXMgYSBgZGVsZXRlTWFueWAgUXVlcnlcbiAqIEByZXR1cm5zIHRoZSByZXN1bHRzXG4gKi9cblF1ZXJ5LnByb3RvdHlwZS5fZGVsZXRlTWFueSA9IGFzeW5jIGZ1bmN0aW9uKCkge1xuICBjb25zdCBvcHRpb25zID0gdGhpcy5fb3B0aW9uc0ZvckV4ZWMoKTtcbiAgZGVsZXRlIG9wdGlvbnMuanVzdE9uZTtcblxuICBjb25zdCBjb25kcyA9IHRoaXMuX2NvbmRpdGlvbnM7XG5cbiAgZGVidWcoJ2RlbGV0ZU9uZScsIHRoaXMuX2NvbGxlY3Rpb24uY29sbGVjdGlvbk5hbWUsIGNvbmRzLCBvcHRpb25zKTtcblxuICByZXR1cm4gdGhpcy5fY29sbGVjdGlvbi5kZWxldGVNYW55KGNvbmRzLCBvcHRpb25zKTtcbn07XG5cbi8qKlxuICogSXNzdWVzIGEgbW9uZ29kYiBbZmluZEFuZE1vZGlmeV0oaHR0cDovL3d3dy5tb25nb2RiLm9yZy9kaXNwbGF5L0RPQ1MvZmluZEFuZE1vZGlmeStDb21tYW5kKSB1cGRhdGUgY29tbWFuZC5cbiAqXG4gKiBGaW5kcyBhIG1hdGNoaW5nIGRvY3VtZW50LCB1cGRhdGVzIGl0IGFjY29yZGluZyB0byB0aGUgYHVwZGF0ZWAgYXJnLCBwYXNzaW5nIGFueSBgb3B0aW9uc2AsIGFuZCByZXR1cm5zIHRoZSBmb3VuZCBkb2N1bWVudCAoaWYgYW55KS5cbiAqXG4gKiAjIyMjIEF2YWlsYWJsZSBvcHRpb25zXG4gKlxuICogLSBgbmV3YDogYm9vbCAtIHRydWUgdG8gcmV0dXJuIHRoZSBtb2RpZmllZCBkb2N1bWVudCByYXRoZXIgdGhhbiB0aGUgb3JpZ2luYWwuIGRlZmF1bHRzIHRvIHRydWVcbiAqIC0gYHVwc2VydGA6IGJvb2wgLSBjcmVhdGVzIHRoZSBvYmplY3QgaWYgaXQgZG9lc24ndCBleGlzdC4gZGVmYXVsdHMgdG8gZmFsc2UuXG4gKiAtIGBzb3J0YDogaWYgbXVsdGlwbGUgZG9jcyBhcmUgZm91bmQgYnkgdGhlIGNvbmRpdGlvbnMsIHNldHMgdGhlIHNvcnQgb3JkZXIgdG8gY2hvb3NlIHdoaWNoIGRvYyB0byB1cGRhdGVcbiAqXG4gKiAjIyMjIEV4YW1wbGVzOlxuICpcbiAqICAgICBhd2FpdCBxdWVyeS5maW5kT25lQW5kVXBkYXRlKGNvbmRpdGlvbnMsIHVwZGF0ZSwgb3B0aW9ucykgLy8gZXhlY3V0ZXNcbiAqICAgICBxdWVyeS5maW5kT25lQW5kVXBkYXRlKGNvbmRpdGlvbnMsIHVwZGF0ZSwgb3B0aW9ucykgIC8vIHJldHVybnMgUXVlcnlcbiAqICAgICBhd2FpdCBxdWVyeS5maW5kT25lQW5kVXBkYXRlKGNvbmRpdGlvbnMsIHVwZGF0ZSkgLy8gZXhlY3V0ZXNcbiAqICAgICBxdWVyeS5maW5kT25lQW5kVXBkYXRlKGNvbmRpdGlvbnMsIHVwZGF0ZSkgICAgICAgICAgIC8vIHJldHVybnMgUXVlcnlcbiAqICAgICBhd2FpdCBxdWVyeS5maW5kT25lQW5kVXBkYXRlKHVwZGF0ZSkgICAgICAgICAgICAgLy8gcmV0dXJucyBRdWVyeVxuICogICAgIHF1ZXJ5LmZpbmRPbmVBbmRVcGRhdGUodXBkYXRlKSAgICAgICAgICAgICAgICAgICAgICAgLy8gcmV0dXJucyBRdWVyeVxuICogICAgIGF3YWl0IHF1ZXJ5LmZpbmRPbmVBbmRVcGRhdGUoKSAgICAgICAgICAgICAgICAgICAgIC8vIGV4ZWN1dGVzXG4gKiAgICAgcXVlcnkuZmluZE9uZUFuZFVwZGF0ZSgpICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyByZXR1cm5zIFF1ZXJ5XG4gKlxuICogQHBhcmFtIHtPYmplY3R8UXVlcnl9IFtxdWVyeV1cbiAqIEBwYXJhbSB7T2JqZWN0fSBbZG9jXVxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQHNlZSBtb25nb2RiIGh0dHA6Ly93d3cubW9uZ29kYi5vcmcvZGlzcGxheS9ET0NTL2ZpbmRBbmRNb2RpZnkrQ29tbWFuZFxuICogQHJldHVybiB7UXVlcnl9IHRoaXNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUXVlcnkucHJvdG90eXBlLmZpbmRPbmVBbmRVcGRhdGUgPSBmdW5jdGlvbihjcml0ZXJpYSwgZG9jLCBvcHRpb25zKSB7XG4gIHRoaXMub3AgPSAnZmluZE9uZUFuZFVwZGF0ZSc7XG4gIHRoaXMuX3ZhbGlkYXRlKCk7XG5cbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICBkb2MgPSBjcml0ZXJpYTtcbiAgICBjcml0ZXJpYSA9IG9wdGlvbnMgPSB1bmRlZmluZWQ7XG4gIH1cblxuICBpZiAoUXVlcnkuY2FuTWVyZ2UoY3JpdGVyaWEpKSB7XG4gICAgdGhpcy5tZXJnZShjcml0ZXJpYSk7XG4gIH1cblxuICAvLyBhcHBseSBkb2NcbiAgaWYgKGRvYykge1xuICAgIHRoaXMuX21lcmdlVXBkYXRlKGRvYyk7XG4gIH1cblxuICBvcHRpb25zICYmIHRoaXMuc2V0T3B0aW9ucyhvcHRpb25zKTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogRXhlY3V0ZXMgYSBgZmluZE9uZUFuZFVwZGF0ZWAgUXVlcnlcbiAqIEByZXR1cm5zIHRoZSByZXN1bHRzXG4gKi9cblF1ZXJ5LnByb3RvdHlwZS5fZmluZE9uZUFuZFVwZGF0ZSA9IGFzeW5jIGZ1bmN0aW9uKCkge1xuICBjb25zdCBjb25kcyA9IHRoaXMuX2NvbmRpdGlvbnM7XG4gIGNvbnN0IHVwZGF0ZSA9IHRoaXMuX3VwZGF0ZUZvckV4ZWMoKTtcbiAgY29uc3Qgb3B0aW9ucyA9IHRoaXMuX29wdGlvbnNGb3JFeGVjKCk7XG5cbiAgcmV0dXJuIHRoaXMuX2NvbGxlY3Rpb24uZmluZE9uZUFuZFVwZGF0ZShjb25kcywgdXBkYXRlLCBvcHRpb25zKTtcbn07XG5cbi8qKlxuICogSXNzdWVzIGEgbW9uZ29kYiBbZmluZEFuZE1vZGlmeV0oaHR0cDovL3d3dy5tb25nb2RiLm9yZy9kaXNwbGF5L0RPQ1MvZmluZEFuZE1vZGlmeStDb21tYW5kKSByZW1vdmUgY29tbWFuZC5cbiAqXG4gKiBGaW5kcyBhIG1hdGNoaW5nIGRvY3VtZW50LCByZW1vdmVzIGl0LCByZXR1cm5pbmcgdGhlIGZvdW5kIGRvY3VtZW50IChpZiBhbnkpLlxuICpcbiAqICMjIyMgQXZhaWxhYmxlIG9wdGlvbnNcbiAqXG4gKiAtIGBzb3J0YDogaWYgbXVsdGlwbGUgZG9jcyBhcmUgZm91bmQgYnkgdGhlIGNvbmRpdGlvbnMsIHNldHMgdGhlIHNvcnQgb3JkZXIgdG8gY2hvb3NlIHdoaWNoIGRvYyB0byB1cGRhdGVcbiAqXG4gKiAjIyMjIEV4YW1wbGVzOlxuICpcbiAqICAgICBhd2FpdCBBLndoZXJlKCkuZmluZE9uZUFuZFJlbW92ZShjb25kaXRpb25zLCBvcHRpb25zKSAvLyBleGVjdXRlc1xuICogICAgIEEud2hlcmUoKS5maW5kT25lQW5kUmVtb3ZlKGNvbmRpdGlvbnMsIG9wdGlvbnMpICAvLyByZXR1cm4gUXVlcnlcbiAqICAgICBhd2FpdCBBLndoZXJlKCkuZmluZE9uZUFuZFJlbW92ZShjb25kaXRpb25zKSAvLyBleGVjdXRlc1xuICogICAgIEEud2hlcmUoKS5maW5kT25lQW5kUmVtb3ZlKGNvbmRpdGlvbnMpIC8vIHJldHVybnMgUXVlcnlcbiAqICAgICBhd2FpdCBBLndoZXJlKCkuZmluZE9uZUFuZFJlbW92ZSgpICAgLy8gZXhlY3V0ZXNcbiAqICAgICBBLndoZXJlKCkuZmluZE9uZUFuZFJlbW92ZSgpICAgICAgICAgICAvLyByZXR1cm5zIFF1ZXJ5XG4gKiAgICAgQS53aGVyZSgpLmZpbmRPbmVBbmREZWxldGUoKSAgICAgICAgICAgLy8gYWxpYXMgb2YgLmZpbmRPbmVBbmRSZW1vdmUoKVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZGl0aW9uc11cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEByZXR1cm4ge1F1ZXJ5fSB0aGlzXG4gKiBAc2VlIG1vbmdvZGIgaHR0cDovL3d3dy5tb25nb2RiLm9yZy9kaXNwbGF5L0RPQ1MvZmluZEFuZE1vZGlmeStDb21tYW5kXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblF1ZXJ5LnByb3RvdHlwZS5maW5kT25lQW5kUmVtb3ZlID0gUXVlcnkucHJvdG90eXBlLmZpbmRPbmVBbmREZWxldGUgPSBmdW5jdGlvbihjb25kaXRpb25zLCBvcHRpb25zKSB7XG4gIHRoaXMub3AgPSAnZmluZE9uZUFuZFJlbW92ZSc7XG4gIHRoaXMuX3ZhbGlkYXRlKCk7XG5cbiAgLy8gYXBwbHkgY29uZGl0aW9uc1xuICBpZiAoUXVlcnkuY2FuTWVyZ2UoY29uZGl0aW9ucykpIHtcbiAgICB0aGlzLm1lcmdlKGNvbmRpdGlvbnMpO1xuICB9XG5cbiAgLy8gYXBwbHkgb3B0aW9uc1xuICBvcHRpb25zICYmIHRoaXMuc2V0T3B0aW9ucyhvcHRpb25zKTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogRXhlY3V0ZXMgYSBgZmluZE9uZUFuZFJlbW92ZWAgUXVlcnlcbiAqIEByZXR1cm5zIHRoZSByZXN1bHRzXG4gKi9cblF1ZXJ5LnByb3RvdHlwZS5fZmluZE9uZUFuZFJlbW92ZSA9IGFzeW5jIGZ1bmN0aW9uKCkge1xuICBjb25zdCBvcHRpb25zID0gdGhpcy5fb3B0aW9uc0ZvckV4ZWMoKTtcbiAgY29uc3QgY29uZHMgPSB0aGlzLl9jb25kaXRpb25zO1xuXG4gIHJldHVybiB0aGlzLl9jb2xsZWN0aW9uLmZpbmRPbmVBbmREZWxldGUoY29uZHMsIG9wdGlvbnMpO1xufTtcblxuLyoqXG4gKiBBZGQgdHJhY2UgZnVuY3Rpb24gdGhhdCBnZXRzIGNhbGxlZCB3aGVuIHRoZSBxdWVyeSBpcyBleGVjdXRlZC5cbiAqIFRoZSBmdW5jdGlvbiB3aWxsIGJlIGNhbGxlZCB3aXRoIChtZXRob2QsIHF1ZXJ5SW5mbywgcXVlcnkpIGFuZFxuICogc2hvdWxkIHJldHVybiBhIGNhbGxiYWNrIGZ1bmN0aW9uIHdoaWNoIHdpbGwgYmUgY2FsbGVkXG4gKiB3aXRoIChlcnIsIHJlc3VsdCwgbWlsbGlzKSB3aGVuIHRoZSBxdWVyeSBpcyBjb21wbGV0ZS5cbiAqXG4gKiBxdWVyeUluZm8gaXMgYW4gb2JqZWN0IGNvbnRhaW5pbmc6IHtcbiAqICAgY29sbGVjdGlvbk5hbWU6IDxuYW1lIG9mIHRoZSBjb2xsZWN0aW9uPixcbiAqICAgY29uZGl0aW9uczogPHF1ZXJ5IGNyaXRlcmlhPixcbiAqICAgb3B0aW9uczogPGNvbW1lbnQsIGZpZWxkcywgcmVhZFByZWZlcmVuY2UsIGV0Yz4sXG4gKiAgIGRvYzogW2RvY3VtZW50IHRvIHVwZGF0ZSwgaWYgYXBwbGljYWJsZV1cbiAqIH1cbiAqXG4gKiBOT1RFOiBEb2VzIG5vdCB0cmFjZSBzdHJlYW0gcXVlcmllcy5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSB0cmFjZUZ1bmN0aW9uXG4gKiBAcmV0dXJuIHtRdWVyeX0gdGhpc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuUXVlcnkucHJvdG90eXBlLnNldFRyYWNlRnVuY3Rpb24gPSBmdW5jdGlvbih0cmFjZUZ1bmN0aW9uKSB7XG4gIHRoaXMuX3RyYWNlRnVuY3Rpb24gPSB0cmFjZUZ1bmN0aW9uO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogRXhlY3V0ZXMgdGhlIHF1ZXJ5XG4gKlxuICogIyMjIyBFeGFtcGxlczpcbiAqXG4gKiAgICAgcXVlcnkuZXhlYygpO1xuICogICAgIGF3YWl0IHF1ZXJ5LmV4ZWMoKTtcbiAqICAgICBxdWVyeS5leGVjKCd1cGRhdGUnKTtcbiAqICAgICBhd2FpdCBxdWVyeS5leGVjKCdmaW5kJyk7XG4gKlxuICogQHBhcmFtIHtTdHJpbmd8RnVuY3Rpb259IFtvcGVyYXRpb25dXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblF1ZXJ5LnByb3RvdHlwZS5leGVjID0gYXN5bmMgZnVuY3Rpb24gZXhlYyhvcCkge1xuICBpZiAodHlwZW9mIG9wID09PSAnc3RyaW5nJykge1xuICAgIHRoaXMub3AgPSBvcDtcbiAgfVxuXG4gIGFzc2VydC5vayh0aGlzLm9wLCAnTWlzc2luZyBxdWVyeSB0eXBlOiAoZmluZCwgZXRjKScpO1xuXG4gIGNvbnN0IGZuTmFtZSA9ICdfJyArIHRoaXMub3A7XG5cbiAgLy8gYmV0dGVyIGVycm9yLCBiZWNhdXNlIGRlZmF1bHQgd291bGQgbGlzdCBpdCBhcyBcInRoaXNbZm5OYW1lXSBpcyBub3QgYSBmdW5jdGlvblwiXG4gIGlmICh0eXBlb2YgdGhpc1tmbk5hbWVdICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgdGhpc1ske2ZuTmFtZX1dIGlzIG5vdCBhIGZ1bmN0aW9uYCk7XG4gIH1cblxuICByZXR1cm4gdGhpc1tmbk5hbWVdKCk7XG59O1xuXG4vKipcbiAqIEV4ZWN1dGVzIHRoZSBxdWVyeSByZXR1cm5pbmcgYSBgUHJvbWlzZWAgd2hpY2ggd2lsbCBiZVxuICogcmVzb2x2ZWQgd2l0aCBlaXRoZXIgdGhlIGRvYyhzKSBvciByZWplY3RlZCB3aXRoIHRoZSBlcnJvci5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcmVzb2x2ZV1cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtyZWplY3RdXG4gKiBAcmV0dXJuIHtQcm9taXNlfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5RdWVyeS5wcm90b3R5cGUudGhlbiA9IGFzeW5jIGZ1bmN0aW9uKHJlcywgcmVqKSB7XG4gIHJldHVybiB0aGlzLmV4ZWMoKS50aGVuKHJlcywgcmVqKTtcbn07XG5cbi8qKlxuICogUmV0dXJucyBhIGN1cnNvciBmb3IgdGhlIGdpdmVuIGBmaW5kYCBxdWVyeS5cbiAqXG4gKiBAdGhyb3dzIEVycm9yIGlmIG9wZXJhdGlvbiBpcyBub3QgYSBmaW5kXG4gKiBAcmV0dXJucyB7Q3Vyc29yfSBNb25nb0RCIGRyaXZlciBjdXJzb3JcbiAqL1xuXG5RdWVyeS5wcm90b3R5cGUuY3Vyc29yID0gZnVuY3Rpb24oKSB7XG4gIGlmICgnZmluZCcgIT0gdGhpcy5vcClcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2N1cnNvcigpIGlzIG9ubHkgYXZhaWxhYmxlIGZvciBmaW5kJyk7XG5cbiAgY29uc3QgY29uZHMgPSB0aGlzLl9jb25kaXRpb25zO1xuXG4gIGNvbnN0IG9wdGlvbnMgPSB0aGlzLl9vcHRpb25zRm9yRXhlYygpO1xuICBpZiAodGhpcy4kdXNlUHJvamVjdGlvbikge1xuICAgIG9wdGlvbnMucHJvamVjdGlvbiA9IHRoaXMuX2ZpZWxkc0ZvckV4ZWMoKTtcbiAgfSBlbHNlIHtcbiAgICBvcHRpb25zLmZpZWxkcyA9IHRoaXMuX2ZpZWxkc0ZvckV4ZWMoKTtcbiAgfVxuXG4gIGRlYnVnKCdjdXJzb3InLCB0aGlzLl9jb2xsZWN0aW9uLmNvbGxlY3Rpb25OYW1lLCBjb25kcywgb3B0aW9ucyk7XG5cbiAgcmV0dXJuIHRoaXMuX2NvbGxlY3Rpb24uZmluZEN1cnNvcihjb25kcywgb3B0aW9ucyk7XG59O1xuXG4vKipcbiAqIERldGVybWluZXMgaWYgZmllbGQgc2VsZWN0aW9uIGhhcyBiZWVuIG1hZGUuXG4gKlxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUXVlcnkucHJvdG90eXBlLnNlbGVjdGVkID0gZnVuY3Rpb24gc2VsZWN0ZWQoKSB7XG4gIHJldHVybiAhISh0aGlzLl9maWVsZHMgJiYgT2JqZWN0LmtleXModGhpcy5fZmllbGRzKS5sZW5ndGggPiAwKTtcbn07XG5cbi8qKlxuICogRGV0ZXJtaW5lcyBpZiBpbmNsdXNpdmUgZmllbGQgc2VsZWN0aW9uIGhhcyBiZWVuIG1hZGUuXG4gKlxuICogICAgIHF1ZXJ5LnNlbGVjdGVkSW5jbHVzaXZlbHkoKSAvLyBmYWxzZVxuICogICAgIHF1ZXJ5LnNlbGVjdCgnbmFtZScpXG4gKiAgICAgcXVlcnkuc2VsZWN0ZWRJbmNsdXNpdmVseSgpIC8vIHRydWVcbiAqICAgICBxdWVyeS5zZWxlY3RlZEV4bHVzaXZlbHkoKSAvLyBmYWxzZVxuICpcbiAqIEByZXR1cm5zIHtCb29sZWFufVxuICovXG5cblF1ZXJ5LnByb3RvdHlwZS5zZWxlY3RlZEluY2x1c2l2ZWx5ID0gZnVuY3Rpb24gc2VsZWN0ZWRJbmNsdXNpdmVseSgpIHtcbiAgaWYgKCF0aGlzLl9maWVsZHMpIHJldHVybiBmYWxzZTtcblxuICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXModGhpcy5fZmllbGRzKTtcbiAgaWYgKDAgPT09IGtleXMubGVuZ3RoKSByZXR1cm4gZmFsc2U7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKSB7XG4gICAgY29uc3Qga2V5ID0ga2V5c1tpXTtcbiAgICBpZiAoMCA9PT0gdGhpcy5fZmllbGRzW2tleV0pIHJldHVybiBmYWxzZTtcbiAgICBpZiAodGhpcy5fZmllbGRzW2tleV0gJiZcbiAgICAgICAgdHlwZW9mIHRoaXMuX2ZpZWxkc1trZXldID09PSAnb2JqZWN0JyAmJlxuICAgICAgICB0aGlzLl9maWVsZHNba2V5XS4kbWV0YSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxuLyoqXG4gKiBEZXRlcm1pbmVzIGlmIGV4Y2x1c2l2ZSBmaWVsZCBzZWxlY3Rpb24gaGFzIGJlZW4gbWFkZS5cbiAqXG4gKiAgICAgcXVlcnkuc2VsZWN0ZWRFeGx1c2l2ZWx5KCkgLy8gZmFsc2VcbiAqICAgICBxdWVyeS5zZWxlY3QoJy1uYW1lJylcbiAqICAgICBxdWVyeS5zZWxlY3RlZEV4bHVzaXZlbHkoKSAvLyB0cnVlXG4gKiAgICAgcXVlcnkuc2VsZWN0ZWRJbmNsdXNpdmVseSgpIC8vIGZhbHNlXG4gKlxuICogQHJldHVybnMge0Jvb2xlYW59XG4gKi9cblxuUXVlcnkucHJvdG90eXBlLnNlbGVjdGVkRXhjbHVzaXZlbHkgPSBmdW5jdGlvbiBzZWxlY3RlZEV4Y2x1c2l2ZWx5KCkge1xuICBpZiAoIXRoaXMuX2ZpZWxkcykgcmV0dXJuIGZhbHNlO1xuXG4gIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyh0aGlzLl9maWVsZHMpO1xuICBpZiAoMCA9PT0ga2V5cy5sZW5ndGgpIHJldHVybiBmYWxzZTtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpIHtcbiAgICBjb25zdCBrZXkgPSBrZXlzW2ldO1xuICAgIGlmICgwID09PSB0aGlzLl9maWVsZHNba2V5XSkgcmV0dXJuIHRydWU7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59O1xuXG4vKipcbiAqIE1lcmdlcyBgZG9jYCB3aXRoIHRoZSBjdXJyZW50IHVwZGF0ZSBvYmplY3QuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGRvY1xuICovXG5cblF1ZXJ5LnByb3RvdHlwZS5fbWVyZ2VVcGRhdGUgPSBmdW5jdGlvbihkb2MpIHtcbiAgaWYgKCF0aGlzLl91cGRhdGVEb2MpIHRoaXMuX3VwZGF0ZURvYyA9IHt9O1xuICBpZiAoZG9jIGluc3RhbmNlb2YgUXVlcnkpIHtcbiAgICBpZiAoZG9jLl91cGRhdGVEb2MpIHtcbiAgICAgIHV0aWxzLm1lcmdlQ2xvbmUodGhpcy5fdXBkYXRlRG9jLCBkb2MuX3VwZGF0ZURvYyk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHV0aWxzLm1lcmdlQ2xvbmUodGhpcy5fdXBkYXRlRG9jLCBkb2MpO1xuICB9XG59O1xuXG4vKipcbiAqIFJldHVybnMgZGVmYXVsdCBvcHRpb25zLlxuICpcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblF1ZXJ5LnByb3RvdHlwZS5fb3B0aW9uc0ZvckV4ZWMgPSBmdW5jdGlvbigpIHtcbiAgY29uc3Qgb3B0aW9ucyA9IHV0aWxzLmNsb25lKHRoaXMub3B0aW9ucyk7XG4gIHJldHVybiBvcHRpb25zO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIGZpZWxkcyBzZWxlY3Rpb24gZm9yIHRoaXMgcXVlcnkuXG4gKlxuICogQHJldHVybiB7T2JqZWN0fVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuUXVlcnkucHJvdG90eXBlLl9maWVsZHNGb3JFeGVjID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB1dGlscy5jbG9uZSh0aGlzLl9maWVsZHMpO1xufTtcblxuLyoqXG4gKiBSZXR1cm4gYW4gdXBkYXRlIGRvY3VtZW50IHdpdGggY29ycmVjdGVkICRzZXQgb3BlcmF0aW9ucy5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5RdWVyeS5wcm90b3R5cGUuX3VwZGF0ZUZvckV4ZWMgPSBmdW5jdGlvbigpIHtcbiAgY29uc3QgdXBkYXRlID0gdXRpbHMuY2xvbmUodGhpcy5fdXBkYXRlRG9jKTtcbiAgY29uc3Qgb3BzID0gdXRpbHMua2V5cyh1cGRhdGUpO1xuICBjb25zdCByZXQgPSB7fTtcblxuICBmb3IgKGNvbnN0IG9wIG9mIG9wcykge1xuICAgIGlmICh0aGlzLm9wdGlvbnMub3ZlcndyaXRlKSB7XG4gICAgICByZXRbb3BdID0gdXBkYXRlW29wXTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGlmICgnJCcgIT09IG9wWzBdKSB7XG4gICAgICAvLyBmaXggdXAgJHNldCBzdWdhclxuICAgICAgaWYgKCFyZXQuJHNldCkge1xuICAgICAgICBpZiAodXBkYXRlLiRzZXQpIHtcbiAgICAgICAgICByZXQuJHNldCA9IHVwZGF0ZS4kc2V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldC4kc2V0ID0ge307XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldC4kc2V0W29wXSA9IHVwZGF0ZVtvcF07XG4gICAgICBpZiAoIX5vcHMuaW5kZXhPZignJHNldCcpKSBvcHMucHVzaCgnJHNldCcpO1xuICAgIH0gZWxzZSBpZiAoJyRzZXQnID09PSBvcCkge1xuICAgICAgaWYgKCFyZXQuJHNldCkge1xuICAgICAgICByZXRbb3BdID0gdXBkYXRlW29wXTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0W29wXSA9IHVwZGF0ZVtvcF07XG4gICAgfVxuICB9XG5cbiAgdGhpcy5fY29tcGlsZWRVcGRhdGUgPSByZXQ7XG4gIHJldHVybiByZXQ7XG59O1xuXG4vKipcbiAqIE1ha2Ugc3VyZSBfcGF0aCBpcyBzZXQuXG4gKlxuICogQHBhcm1hbSB7U3RyaW5nfSBtZXRob2RcbiAqL1xuXG5RdWVyeS5wcm90b3R5cGUuX2Vuc3VyZVBhdGggPSBmdW5jdGlvbihtZXRob2QpIHtcbiAgaWYgKCF0aGlzLl9wYXRoKSB7XG4gICAgY29uc3QgbXNnID0gbWV0aG9kICsgJygpIG11c3QgYmUgdXNlZCBhZnRlciB3aGVyZSgpICdcbiAgICAgICAgICAgICAgICAgICAgICsgJ3doZW4gY2FsbGVkIHdpdGggdGhlc2UgYXJndW1lbnRzJztcbiAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbiAgfVxufTtcblxuLyohXG4gKiBQZXJtaXNzaW9uc1xuICovXG5cblF1ZXJ5LnBlcm1pc3Npb25zID0gcmVxdWlyZSgnLi9wZXJtaXNzaW9ucycpO1xuXG5RdWVyeS5faXNQZXJtaXR0ZWQgPSBmdW5jdGlvbihhLCBiKSB7XG4gIGNvbnN0IGRlbmllZCA9IFF1ZXJ5LnBlcm1pc3Npb25zW2JdO1xuICBpZiAoIWRlbmllZCkgcmV0dXJuIHRydWU7XG4gIHJldHVybiB0cnVlICE9PSBkZW5pZWRbYV07XG59O1xuXG5RdWVyeS5wcm90b3R5cGUuX3ZhbGlkYXRlID0gZnVuY3Rpb24oYWN0aW9uKSB7XG4gIGxldCBmYWlsO1xuICBsZXQgdmFsaWRhdG9yO1xuXG4gIGlmICh1bmRlZmluZWQgPT09IGFjdGlvbikge1xuXG4gICAgdmFsaWRhdG9yID0gUXVlcnkucGVybWlzc2lvbnNbdGhpcy5vcF07XG4gICAgaWYgKCdmdW5jdGlvbicgIT0gdHlwZW9mIHZhbGlkYXRvcikgcmV0dXJuIHRydWU7XG5cbiAgICBmYWlsID0gdmFsaWRhdG9yKHRoaXMpO1xuXG4gIH0gZWxzZSBpZiAoIVF1ZXJ5Ll9pc1Blcm1pdHRlZChhY3Rpb24sIHRoaXMub3ApKSB7XG4gICAgZmFpbCA9IGFjdGlvbjtcbiAgfVxuXG4gIGlmIChmYWlsKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGZhaWwgKyAnIGNhbm5vdCBiZSB1c2VkIHdpdGggJyArIHRoaXMub3ApO1xuICB9XG59O1xuXG4vKipcbiAqIERldGVybWluZXMgaWYgYGNvbmRzYCBjYW4gYmUgbWVyZ2VkIHVzaW5nIGBtcXVlcnkoKS5tZXJnZSgpYFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb25kc1xuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuXG5RdWVyeS5jYW5NZXJnZSA9IGZ1bmN0aW9uKGNvbmRzKSB7XG4gIHJldHVybiBjb25kcyBpbnN0YW5jZW9mIFF1ZXJ5IHx8IHV0aWxzLmlzT2JqZWN0KGNvbmRzKTtcbn07XG5cbi8qKlxuICogU2V0IGEgdHJhY2UgZnVuY3Rpb24gdGhhdCB3aWxsIGdldCBjYWxsZWQgd2hlbmV2ZXIgYVxuICogcXVlcnkgaXMgZXhlY3V0ZWQuXG4gKlxuICogU2VlIGBzZXRUcmFjZUZ1bmN0aW9uKClgIGZvciBkZXRhaWxzLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb25kc1xuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuUXVlcnkuc2V0R2xvYmFsVHJhY2VGdW5jdGlvbiA9IGZ1bmN0aW9uKHRyYWNlRnVuY3Rpb24pIHtcbiAgUXVlcnkudHJhY2VGdW5jdGlvbiA9IHRyYWNlRnVuY3Rpb247XG59O1xuXG4vKiFcbiAqIEV4cG9ydHMuXG4gKi9cblxuUXVlcnkudXRpbHMgPSB1dGlscztcblF1ZXJ5LmVudiA9IHJlcXVpcmUoJy4vZW52Jyk7XG5RdWVyeS5Db2xsZWN0aW9uID0gcmVxdWlyZSgnLi9jb2xsZWN0aW9uJyk7XG5RdWVyeS5CYXNlQ29sbGVjdGlvbiA9IHJlcXVpcmUoJy4vY29sbGVjdGlvbi9jb2xsZWN0aW9uJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBRdWVyeTtcblxuLy8gVE9ET1xuLy8gdGVzdCB1dGlsc1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../server/node_modules/mquery/lib/mquery.js\n");

/***/ }),

/***/ "../server/node_modules/mquery/lib/permissions.js":
/*!********************************************************!*\
  !*** ../server/node_modules/mquery/lib/permissions.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\nconst denied = exports;\n\ndenied.distinct = function(self) {\n  if (self._fields && Object.keys(self._fields).length > 0) {\n    return 'field selection and slice';\n  }\n\n  const keys = Object.keys(denied.distinct);\n  let err;\n\n  keys.every(function(option) {\n    if (self.options[option]) {\n      err = option;\n      return false;\n    }\n    return true;\n  });\n\n  return err;\n};\ndenied.distinct.select =\ndenied.distinct.slice =\ndenied.distinct.sort =\ndenied.distinct.limit =\ndenied.distinct.skip =\ndenied.distinct.batchSize =\ndenied.distinct.hint =\ndenied.distinct.tailable = true;\n\n\n// aggregation integration\n\n\ndenied.findOneAndUpdate =\ndenied.findOneAndRemove = function(self) {\n  const keys = Object.keys(denied.findOneAndUpdate);\n  let err;\n\n  keys.every(function(option) {\n    if (self.options[option]) {\n      err = option;\n      return false;\n    }\n    return true;\n  });\n\n  return err;\n};\ndenied.findOneAndUpdate.limit =\ndenied.findOneAndUpdate.skip =\ndenied.findOneAndUpdate.batchSize =\ndenied.findOneAndUpdate.tailable = true;\n\n\ndenied.count = function(self) {\n  if (self._fields && Object.keys(self._fields).length > 0) {\n    return 'field selection and slice';\n  }\n\n  const keys = Object.keys(denied.count);\n  let err;\n\n  keys.every(function(option) {\n    if (self.options[option]) {\n      err = option;\n      return false;\n    }\n    return true;\n  });\n\n  return err;\n};\n\ndenied.count.slice =\ndenied.count.batchSize =\ndenied.count.tailable = true;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tcXVlcnkvbGliL3Blcm1pc3Npb25zLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbGllbnQvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tcXVlcnkvbGliL3Blcm1pc3Npb25zLmpzPzI2MjQiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBkZW5pZWQgPSBleHBvcnRzO1xuXG5kZW5pZWQuZGlzdGluY3QgPSBmdW5jdGlvbihzZWxmKSB7XG4gIGlmIChzZWxmLl9maWVsZHMgJiYgT2JqZWN0LmtleXMoc2VsZi5fZmllbGRzKS5sZW5ndGggPiAwKSB7XG4gICAgcmV0dXJuICdmaWVsZCBzZWxlY3Rpb24gYW5kIHNsaWNlJztcbiAgfVxuXG4gIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhkZW5pZWQuZGlzdGluY3QpO1xuICBsZXQgZXJyO1xuXG4gIGtleXMuZXZlcnkoZnVuY3Rpb24ob3B0aW9uKSB7XG4gICAgaWYgKHNlbGYub3B0aW9uc1tvcHRpb25dKSB7XG4gICAgICBlcnIgPSBvcHRpb247XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9KTtcblxuICByZXR1cm4gZXJyO1xufTtcbmRlbmllZC5kaXN0aW5jdC5zZWxlY3QgPVxuZGVuaWVkLmRpc3RpbmN0LnNsaWNlID1cbmRlbmllZC5kaXN0aW5jdC5zb3J0ID1cbmRlbmllZC5kaXN0aW5jdC5saW1pdCA9XG5kZW5pZWQuZGlzdGluY3Quc2tpcCA9XG5kZW5pZWQuZGlzdGluY3QuYmF0Y2hTaXplID1cbmRlbmllZC5kaXN0aW5jdC5oaW50ID1cbmRlbmllZC5kaXN0aW5jdC50YWlsYWJsZSA9IHRydWU7XG5cblxuLy8gYWdncmVnYXRpb24gaW50ZWdyYXRpb25cblxuXG5kZW5pZWQuZmluZE9uZUFuZFVwZGF0ZSA9XG5kZW5pZWQuZmluZE9uZUFuZFJlbW92ZSA9IGZ1bmN0aW9uKHNlbGYpIHtcbiAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKGRlbmllZC5maW5kT25lQW5kVXBkYXRlKTtcbiAgbGV0IGVycjtcblxuICBrZXlzLmV2ZXJ5KGZ1bmN0aW9uKG9wdGlvbikge1xuICAgIGlmIChzZWxmLm9wdGlvbnNbb3B0aW9uXSkge1xuICAgICAgZXJyID0gb3B0aW9uO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSk7XG5cbiAgcmV0dXJuIGVycjtcbn07XG5kZW5pZWQuZmluZE9uZUFuZFVwZGF0ZS5saW1pdCA9XG5kZW5pZWQuZmluZE9uZUFuZFVwZGF0ZS5za2lwID1cbmRlbmllZC5maW5kT25lQW5kVXBkYXRlLmJhdGNoU2l6ZSA9XG5kZW5pZWQuZmluZE9uZUFuZFVwZGF0ZS50YWlsYWJsZSA9IHRydWU7XG5cblxuZGVuaWVkLmNvdW50ID0gZnVuY3Rpb24oc2VsZikge1xuICBpZiAoc2VsZi5fZmllbGRzICYmIE9iamVjdC5rZXlzKHNlbGYuX2ZpZWxkcykubGVuZ3RoID4gMCkge1xuICAgIHJldHVybiAnZmllbGQgc2VsZWN0aW9uIGFuZCBzbGljZSc7XG4gIH1cblxuICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoZGVuaWVkLmNvdW50KTtcbiAgbGV0IGVycjtcblxuICBrZXlzLmV2ZXJ5KGZ1bmN0aW9uKG9wdGlvbikge1xuICAgIGlmIChzZWxmLm9wdGlvbnNbb3B0aW9uXSkge1xuICAgICAgZXJyID0gb3B0aW9uO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSk7XG5cbiAgcmV0dXJuIGVycjtcbn07XG5cbmRlbmllZC5jb3VudC5zbGljZSA9XG5kZW5pZWQuY291bnQuYmF0Y2hTaXplID1cbmRlbmllZC5jb3VudC50YWlsYWJsZSA9IHRydWU7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../server/node_modules/mquery/lib/permissions.js\n");

/***/ }),

/***/ "../server/node_modules/mquery/lib/utils.js":
/*!**************************************************!*\
  !*** ../server/node_modules/mquery/lib/utils.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\n/*!\n * Module dependencies.\n */\n\nconst specialProperties = ['__proto__', 'constructor', 'prototype'];\n\n/**\n * Clones objects\n *\n * @param {Object} obj the object to clone\n * @param {Object} options\n * @return {Object} the cloned object\n * @api private\n */\n\nconst clone = exports.clone = function clone(obj, options) {\n  if (obj === undefined || obj === null)\n    return obj;\n\n  if (Array.isArray(obj))\n    return exports.cloneArray(obj, options);\n\n  if (obj.constructor) {\n    if (/ObjectI[dD]$/.test(obj.constructor.name)) {\n      return 'function' == typeof obj.clone\n        ? obj.clone()\n        : new obj.constructor(obj.id);\n    }\n\n    if (obj.constructor.name === 'ReadPreference') {\n      return new obj.constructor(obj.mode, clone(obj.tags, options));\n    }\n\n    if ('Binary' == obj._bsontype && obj.buffer && obj.value) {\n      return 'function' == typeof obj.clone\n        ? obj.clone()\n        : new obj.constructor(obj.value(true), obj.sub_type);\n    }\n\n    if ('Date' === obj.constructor.name || 'Function' === obj.constructor.name)\n      return new obj.constructor(+obj);\n\n    if ('RegExp' === obj.constructor.name)\n      return new RegExp(obj);\n\n    if ('Buffer' === obj.constructor.name)\n      return Buffer.from(obj);\n  }\n\n  if (isObject(obj))\n    return exports.cloneObject(obj, options);\n\n  if (obj.valueOf)\n    return obj.valueOf();\n};\n\n/*!\n * ignore\n */\n\nexports.cloneObject = function cloneObject(obj, options) {\n  const minimize = options && options.minimize,\n      ret = {},\n      keys = Object.keys(obj),\n      len = keys.length;\n  let hasKeys = false,\n      val,\n      k = '',\n      i = 0;\n\n  for (i = 0; i < len; ++i) {\n    k = keys[i];\n    // Not technically prototype pollution because this wouldn't merge properties\n    // onto `Object.prototype`, but avoid properties like __proto__ as a precaution.\n    if (specialProperties.indexOf(k) !== -1) {\n      continue;\n    }\n\n    val = clone(obj[k], options);\n\n    if (!minimize || ('undefined' !== typeof val)) {\n      hasKeys || (hasKeys = true);\n      ret[k] = val;\n    }\n  }\n\n  return minimize\n    ? hasKeys && ret\n    : ret;\n};\n\nexports.cloneArray = function cloneArray(arr, options) {\n  const ret = [],\n      l = arr.length;\n  let i = 0;\n  for (; i < l; i++)\n    ret.push(clone(arr[i], options));\n  return ret;\n};\n\n/**\n * Merges `from` into `to` without overwriting existing properties.\n *\n * @param {Object} to\n * @param {Object} from\n * @api private\n */\n\nexports.merge = function merge(to, from) {\n  const keys = Object.keys(from);\n\n  for (const key of keys) {\n    if (specialProperties.indexOf(key) !== -1) {\n      continue;\n    }\n    if ('undefined' === typeof to[key]) {\n      to[key] = from[key];\n    } else {\n      if (exports.isObject(from[key])) {\n        merge(to[key], from[key]);\n      } else {\n        to[key] = from[key];\n      }\n    }\n  }\n};\n\n/**\n * Same as merge but clones the assigned values.\n *\n * @param {Object} to\n * @param {Object} from\n * @api private\n */\n\nexports.mergeClone = function mergeClone(to, from) {\n  const keys = Object.keys(from);\n\n  for (const key of keys) {\n    if (specialProperties.indexOf(key) !== -1) {\n      continue;\n    }\n    if ('undefined' === typeof to[key]) {\n      to[key] = clone(from[key]);\n    } else {\n      if (exports.isObject(from[key])) {\n        mergeClone(to[key], from[key]);\n      } else {\n        to[key] = clone(from[key]);\n      }\n    }\n  }\n};\n\n/**\n * Read pref helper (mongo 2.2 drivers support this)\n *\n * Allows using aliases instead of full preference names:\n *\n *     p   primary\n *     pp  primaryPreferred\n *     s   secondary\n *     sp  secondaryPreferred\n *     n   nearest\n *\n * @param {String} pref\n */\n\nexports.readPref = function readPref(pref) {\n  switch (pref) {\n    case 'p':\n      pref = 'primary';\n      break;\n    case 'pp':\n      pref = 'primaryPreferred';\n      break;\n    case 's':\n      pref = 'secondary';\n      break;\n    case 'sp':\n      pref = 'secondaryPreferred';\n      break;\n    case 'n':\n      pref = 'nearest';\n      break;\n  }\n\n  return pref;\n};\n\n\n/**\n * Read Concern helper (mongo 3.2 drivers support this)\n *\n * Allows using string to specify read concern level:\n *\n *     local          3.2+\n *     available      3.6+\n *     majority       3.2+\n *     linearizable   3.4+\n *     snapshot       4.0+\n *\n * @param {String|Object} concern\n */\n\nexports.readConcern = function readConcern(concern) {\n  if ('string' === typeof concern) {\n    switch (concern) {\n      case 'l':\n        concern = 'local';\n        break;\n      case 'a':\n        concern = 'available';\n        break;\n      case 'm':\n        concern = 'majority';\n        break;\n      case 'lz':\n        concern = 'linearizable';\n        break;\n      case 's':\n        concern = 'snapshot';\n        break;\n    }\n    concern = { level: concern };\n  }\n  return concern;\n};\n\n/**\n * Object.prototype.toString.call helper\n */\n\nconst _toString = Object.prototype.toString;\nexports.toString = function(arg) {\n  return _toString.call(arg);\n};\n\n/**\n * Determines if `arg` is an object.\n *\n * @param {Object|Array|String|Function|RegExp|any} arg\n * @return {Boolean}\n */\n\nconst isObject = exports.isObject = function(arg) {\n  return '[object Object]' == exports.toString(arg);\n};\n\n/**\n * Object.keys helper\n */\n\nexports.keys = Object.keys;\n\n/**\n * Basic Object.create polyfill.\n * Only one argument is supported.\n *\n * Based on https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Object/create\n */\n\nexports.create = 'function' == typeof Object.create\n  ? Object.create\n  : create;\n\nfunction create(proto) {\n  if (arguments.length > 1) {\n    throw new Error('Adding properties is not supported');\n  }\n\n  function F() { }\n  F.prototype = proto;\n  return new F;\n}\n\n/**\n * inheritance\n */\n\nexports.inherits = function(ctor, superCtor) {\n  ctor.prototype = exports.create(superCtor.prototype);\n  ctor.prototype.constructor = ctor;\n};\n\n/**\n * Check if this object is an arguments object\n *\n * @param {Any} v\n * @return {Boolean}\n */\n\nexports.isArgumentsObject = function(v) {\n  return Object.prototype.toString.call(v) === '[object Arguments]';\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tcXVlcnkvbGliL3V0aWxzLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFlBQVksUUFBUTtBQUNwQjtBQUNBOztBQUVBLGNBQWMsYUFBYTtBQUMzQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLG1CQUFtQjtBQUNuQjtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQSxTQUFTLE9BQU87QUFDaEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQTs7QUFFQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7O0FBRUEsa0JBQWtCO0FBQ2xCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjs7QUFFQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxlQUFlO0FBQzFCOztBQUVBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcseUNBQXlDO0FBQ3BELFlBQVk7QUFDWjs7QUFFQSxpQkFBaUIsZ0JBQWdCO0FBQ2pDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLFlBQVk7O0FBRVo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixZQUFZO0FBQ1o7O0FBRUEseUJBQXlCO0FBQ3pCO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbGllbnQvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tcXVlcnkvbGliL3V0aWxzLmpzPzMxYmMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG4vKiFcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxuY29uc3Qgc3BlY2lhbFByb3BlcnRpZXMgPSBbJ19fcHJvdG9fXycsICdjb25zdHJ1Y3RvcicsICdwcm90b3R5cGUnXTtcblxuLyoqXG4gKiBDbG9uZXMgb2JqZWN0c1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmogdGhlIG9iamVjdCB0byBjbG9uZVxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEByZXR1cm4ge09iamVjdH0gdGhlIGNsb25lZCBvYmplY3RcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmNvbnN0IGNsb25lID0gZXhwb3J0cy5jbG9uZSA9IGZ1bmN0aW9uIGNsb25lKG9iaiwgb3B0aW9ucykge1xuICBpZiAob2JqID09PSB1bmRlZmluZWQgfHwgb2JqID09PSBudWxsKVxuICAgIHJldHVybiBvYmo7XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkob2JqKSlcbiAgICByZXR1cm4gZXhwb3J0cy5jbG9uZUFycmF5KG9iaiwgb3B0aW9ucyk7XG5cbiAgaWYgKG9iai5jb25zdHJ1Y3Rvcikge1xuICAgIGlmICgvT2JqZWN0SVtkRF0kLy50ZXN0KG9iai5jb25zdHJ1Y3Rvci5uYW1lKSkge1xuICAgICAgcmV0dXJuICdmdW5jdGlvbicgPT0gdHlwZW9mIG9iai5jbG9uZVxuICAgICAgICA/IG9iai5jbG9uZSgpXG4gICAgICAgIDogbmV3IG9iai5jb25zdHJ1Y3RvcihvYmouaWQpO1xuICAgIH1cblxuICAgIGlmIChvYmouY29uc3RydWN0b3IubmFtZSA9PT0gJ1JlYWRQcmVmZXJlbmNlJykge1xuICAgICAgcmV0dXJuIG5ldyBvYmouY29uc3RydWN0b3Iob2JqLm1vZGUsIGNsb25lKG9iai50YWdzLCBvcHRpb25zKSk7XG4gICAgfVxuXG4gICAgaWYgKCdCaW5hcnknID09IG9iai5fYnNvbnR5cGUgJiYgb2JqLmJ1ZmZlciAmJiBvYmoudmFsdWUpIHtcbiAgICAgIHJldHVybiAnZnVuY3Rpb24nID09IHR5cGVvZiBvYmouY2xvbmVcbiAgICAgICAgPyBvYmouY2xvbmUoKVxuICAgICAgICA6IG5ldyBvYmouY29uc3RydWN0b3Iob2JqLnZhbHVlKHRydWUpLCBvYmouc3ViX3R5cGUpO1xuICAgIH1cblxuICAgIGlmICgnRGF0ZScgPT09IG9iai5jb25zdHJ1Y3Rvci5uYW1lIHx8ICdGdW5jdGlvbicgPT09IG9iai5jb25zdHJ1Y3Rvci5uYW1lKVxuICAgICAgcmV0dXJuIG5ldyBvYmouY29uc3RydWN0b3IoK29iaik7XG5cbiAgICBpZiAoJ1JlZ0V4cCcgPT09IG9iai5jb25zdHJ1Y3Rvci5uYW1lKVxuICAgICAgcmV0dXJuIG5ldyBSZWdFeHAob2JqKTtcblxuICAgIGlmICgnQnVmZmVyJyA9PT0gb2JqLmNvbnN0cnVjdG9yLm5hbWUpXG4gICAgICByZXR1cm4gQnVmZmVyLmZyb20ob2JqKTtcbiAgfVxuXG4gIGlmIChpc09iamVjdChvYmopKVxuICAgIHJldHVybiBleHBvcnRzLmNsb25lT2JqZWN0KG9iaiwgb3B0aW9ucyk7XG5cbiAgaWYgKG9iai52YWx1ZU9mKVxuICAgIHJldHVybiBvYmoudmFsdWVPZigpO1xufTtcblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5leHBvcnRzLmNsb25lT2JqZWN0ID0gZnVuY3Rpb24gY2xvbmVPYmplY3Qob2JqLCBvcHRpb25zKSB7XG4gIGNvbnN0IG1pbmltaXplID0gb3B0aW9ucyAmJiBvcHRpb25zLm1pbmltaXplLFxuICAgICAgcmV0ID0ge30sXG4gICAgICBrZXlzID0gT2JqZWN0LmtleXMob2JqKSxcbiAgICAgIGxlbiA9IGtleXMubGVuZ3RoO1xuICBsZXQgaGFzS2V5cyA9IGZhbHNlLFxuICAgICAgdmFsLFxuICAgICAgayA9ICcnLFxuICAgICAgaSA9IDA7XG5cbiAgZm9yIChpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgayA9IGtleXNbaV07XG4gICAgLy8gTm90IHRlY2huaWNhbGx5IHByb3RvdHlwZSBwb2xsdXRpb24gYmVjYXVzZSB0aGlzIHdvdWxkbid0IG1lcmdlIHByb3BlcnRpZXNcbiAgICAvLyBvbnRvIGBPYmplY3QucHJvdG90eXBlYCwgYnV0IGF2b2lkIHByb3BlcnRpZXMgbGlrZSBfX3Byb3RvX18gYXMgYSBwcmVjYXV0aW9uLlxuICAgIGlmIChzcGVjaWFsUHJvcGVydGllcy5pbmRleE9mKGspICE9PSAtMSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgdmFsID0gY2xvbmUob2JqW2tdLCBvcHRpb25zKTtcblxuICAgIGlmICghbWluaW1pemUgfHwgKCd1bmRlZmluZWQnICE9PSB0eXBlb2YgdmFsKSkge1xuICAgICAgaGFzS2V5cyB8fCAoaGFzS2V5cyA9IHRydWUpO1xuICAgICAgcmV0W2tdID0gdmFsO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBtaW5pbWl6ZVxuICAgID8gaGFzS2V5cyAmJiByZXRcbiAgICA6IHJldDtcbn07XG5cbmV4cG9ydHMuY2xvbmVBcnJheSA9IGZ1bmN0aW9uIGNsb25lQXJyYXkoYXJyLCBvcHRpb25zKSB7XG4gIGNvbnN0IHJldCA9IFtdLFxuICAgICAgbCA9IGFyci5sZW5ndGg7XG4gIGxldCBpID0gMDtcbiAgZm9yICg7IGkgPCBsOyBpKyspXG4gICAgcmV0LnB1c2goY2xvbmUoYXJyW2ldLCBvcHRpb25zKSk7XG4gIHJldHVybiByZXQ7XG59O1xuXG4vKipcbiAqIE1lcmdlcyBgZnJvbWAgaW50byBgdG9gIHdpdGhvdXQgb3ZlcndyaXRpbmcgZXhpc3RpbmcgcHJvcGVydGllcy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdG9cbiAqIEBwYXJhbSB7T2JqZWN0fSBmcm9tXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5leHBvcnRzLm1lcmdlID0gZnVuY3Rpb24gbWVyZ2UodG8sIGZyb20pIHtcbiAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKGZyb20pO1xuXG4gIGZvciAoY29uc3Qga2V5IG9mIGtleXMpIHtcbiAgICBpZiAoc3BlY2lhbFByb3BlcnRpZXMuaW5kZXhPZihrZXkpICE9PSAtMSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmICgndW5kZWZpbmVkJyA9PT0gdHlwZW9mIHRvW2tleV0pIHtcbiAgICAgIHRvW2tleV0gPSBmcm9tW2tleV07XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChleHBvcnRzLmlzT2JqZWN0KGZyb21ba2V5XSkpIHtcbiAgICAgICAgbWVyZ2UodG9ba2V5XSwgZnJvbVtrZXldKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRvW2tleV0gPSBmcm9tW2tleV07XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIFNhbWUgYXMgbWVyZ2UgYnV0IGNsb25lcyB0aGUgYXNzaWduZWQgdmFsdWVzLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB0b1xuICogQHBhcmFtIHtPYmplY3R9IGZyb21cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmV4cG9ydHMubWVyZ2VDbG9uZSA9IGZ1bmN0aW9uIG1lcmdlQ2xvbmUodG8sIGZyb20pIHtcbiAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKGZyb20pO1xuXG4gIGZvciAoY29uc3Qga2V5IG9mIGtleXMpIHtcbiAgICBpZiAoc3BlY2lhbFByb3BlcnRpZXMuaW5kZXhPZihrZXkpICE9PSAtMSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmICgndW5kZWZpbmVkJyA9PT0gdHlwZW9mIHRvW2tleV0pIHtcbiAgICAgIHRvW2tleV0gPSBjbG9uZShmcm9tW2tleV0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoZXhwb3J0cy5pc09iamVjdChmcm9tW2tleV0pKSB7XG4gICAgICAgIG1lcmdlQ2xvbmUodG9ba2V5XSwgZnJvbVtrZXldKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRvW2tleV0gPSBjbG9uZShmcm9tW2tleV0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBSZWFkIHByZWYgaGVscGVyIChtb25nbyAyLjIgZHJpdmVycyBzdXBwb3J0IHRoaXMpXG4gKlxuICogQWxsb3dzIHVzaW5nIGFsaWFzZXMgaW5zdGVhZCBvZiBmdWxsIHByZWZlcmVuY2UgbmFtZXM6XG4gKlxuICogICAgIHAgICBwcmltYXJ5XG4gKiAgICAgcHAgIHByaW1hcnlQcmVmZXJyZWRcbiAqICAgICBzICAgc2Vjb25kYXJ5XG4gKiAgICAgc3AgIHNlY29uZGFyeVByZWZlcnJlZFxuICogICAgIG4gICBuZWFyZXN0XG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHByZWZcbiAqL1xuXG5leHBvcnRzLnJlYWRQcmVmID0gZnVuY3Rpb24gcmVhZFByZWYocHJlZikge1xuICBzd2l0Y2ggKHByZWYpIHtcbiAgICBjYXNlICdwJzpcbiAgICAgIHByZWYgPSAncHJpbWFyeSc7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdwcCc6XG4gICAgICBwcmVmID0gJ3ByaW1hcnlQcmVmZXJyZWQnO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAncyc6XG4gICAgICBwcmVmID0gJ3NlY29uZGFyeSc7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdzcCc6XG4gICAgICBwcmVmID0gJ3NlY29uZGFyeVByZWZlcnJlZCc7XG4gICAgICBicmVhaztcbiAgICBjYXNlICduJzpcbiAgICAgIHByZWYgPSAnbmVhcmVzdCc7XG4gICAgICBicmVhaztcbiAgfVxuXG4gIHJldHVybiBwcmVmO1xufTtcblxuXG4vKipcbiAqIFJlYWQgQ29uY2VybiBoZWxwZXIgKG1vbmdvIDMuMiBkcml2ZXJzIHN1cHBvcnQgdGhpcylcbiAqXG4gKiBBbGxvd3MgdXNpbmcgc3RyaW5nIHRvIHNwZWNpZnkgcmVhZCBjb25jZXJuIGxldmVsOlxuICpcbiAqICAgICBsb2NhbCAgICAgICAgICAzLjIrXG4gKiAgICAgYXZhaWxhYmxlICAgICAgMy42K1xuICogICAgIG1ham9yaXR5ICAgICAgIDMuMitcbiAqICAgICBsaW5lYXJpemFibGUgICAzLjQrXG4gKiAgICAgc25hcHNob3QgICAgICAgNC4wK1xuICpcbiAqIEBwYXJhbSB7U3RyaW5nfE9iamVjdH0gY29uY2VyblxuICovXG5cbmV4cG9ydHMucmVhZENvbmNlcm4gPSBmdW5jdGlvbiByZWFkQ29uY2Vybihjb25jZXJuKSB7XG4gIGlmICgnc3RyaW5nJyA9PT0gdHlwZW9mIGNvbmNlcm4pIHtcbiAgICBzd2l0Y2ggKGNvbmNlcm4pIHtcbiAgICAgIGNhc2UgJ2wnOlxuICAgICAgICBjb25jZXJuID0gJ2xvY2FsJztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdhJzpcbiAgICAgICAgY29uY2VybiA9ICdhdmFpbGFibGUnO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ20nOlxuICAgICAgICBjb25jZXJuID0gJ21ham9yaXR5JztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdseic6XG4gICAgICAgIGNvbmNlcm4gPSAnbGluZWFyaXphYmxlJztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdzJzpcbiAgICAgICAgY29uY2VybiA9ICdzbmFwc2hvdCc7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjb25jZXJuID0geyBsZXZlbDogY29uY2VybiB9O1xuICB9XG4gIHJldHVybiBjb25jZXJuO1xufTtcblxuLyoqXG4gKiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwgaGVscGVyXG4gKi9cblxuY29uc3QgX3RvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcbmV4cG9ydHMudG9TdHJpbmcgPSBmdW5jdGlvbihhcmcpIHtcbiAgcmV0dXJuIF90b1N0cmluZy5jYWxsKGFyZyk7XG59O1xuXG4vKipcbiAqIERldGVybWluZXMgaWYgYGFyZ2AgaXMgYW4gb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fEFycmF5fFN0cmluZ3xGdW5jdGlvbnxSZWdFeHB8YW55fSBhcmdcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cblxuY29uc3QgaXNPYmplY3QgPSBleHBvcnRzLmlzT2JqZWN0ID0gZnVuY3Rpb24oYXJnKSB7XG4gIHJldHVybiAnW29iamVjdCBPYmplY3RdJyA9PSBleHBvcnRzLnRvU3RyaW5nKGFyZyk7XG59O1xuXG4vKipcbiAqIE9iamVjdC5rZXlzIGhlbHBlclxuICovXG5cbmV4cG9ydHMua2V5cyA9IE9iamVjdC5rZXlzO1xuXG4vKipcbiAqIEJhc2ljIE9iamVjdC5jcmVhdGUgcG9seWZpbGwuXG4gKiBPbmx5IG9uZSBhcmd1bWVudCBpcyBzdXBwb3J0ZWQuXG4gKlxuICogQmFzZWQgb24gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9PYmplY3QvY3JlYXRlXG4gKi9cblxuZXhwb3J0cy5jcmVhdGUgPSAnZnVuY3Rpb24nID09IHR5cGVvZiBPYmplY3QuY3JlYXRlXG4gID8gT2JqZWN0LmNyZWF0ZVxuICA6IGNyZWF0ZTtcblxuZnVuY3Rpb24gY3JlYXRlKHByb3RvKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgIHRocm93IG5ldyBFcnJvcignQWRkaW5nIHByb3BlcnRpZXMgaXMgbm90IHN1cHBvcnRlZCcpO1xuICB9XG5cbiAgZnVuY3Rpb24gRigpIHsgfVxuICBGLnByb3RvdHlwZSA9IHByb3RvO1xuICByZXR1cm4gbmV3IEY7XG59XG5cbi8qKlxuICogaW5oZXJpdGFuY2VcbiAqL1xuXG5leHBvcnRzLmluaGVyaXRzID0gZnVuY3Rpb24oY3Rvciwgc3VwZXJDdG9yKSB7XG4gIGN0b3IucHJvdG90eXBlID0gZXhwb3J0cy5jcmVhdGUoc3VwZXJDdG9yLnByb3RvdHlwZSk7XG4gIGN0b3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gY3Rvcjtcbn07XG5cbi8qKlxuICogQ2hlY2sgaWYgdGhpcyBvYmplY3QgaXMgYW4gYXJndW1lbnRzIG9iamVjdFxuICpcbiAqIEBwYXJhbSB7QW55fSB2XG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5cbmV4cG9ydHMuaXNBcmd1bWVudHNPYmplY3QgPSBmdW5jdGlvbih2KSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodikgPT09ICdbb2JqZWN0IEFyZ3VtZW50c10nO1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../server/node_modules/mquery/lib/utils.js\n");

/***/ }),

/***/ "../server/node_modules/mquery/node_modules/debug/src/browser.js":
/*!***********************************************************************!*\
  !*** ../server/node_modules/mquery/node_modules/debug/src/browser.js ***!
  \***********************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("/* eslint-env browser */\n\n/**\n * This is the web browser implementation of `debug()`.\n */\n\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\nexports.storage = localstorage();\nexports.destroy = (() => {\n\tlet warned = false;\n\n\treturn () => {\n\t\tif (!warned) {\n\t\t\twarned = true;\n\t\t\tconsole.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');\n\t\t}\n\t};\n})();\n\n/**\n * Colors.\n */\n\nexports.colors = [\n\t'#0000CC',\n\t'#0000FF',\n\t'#0033CC',\n\t'#0033FF',\n\t'#0066CC',\n\t'#0066FF',\n\t'#0099CC',\n\t'#0099FF',\n\t'#00CC00',\n\t'#00CC33',\n\t'#00CC66',\n\t'#00CC99',\n\t'#00CCCC',\n\t'#00CCFF',\n\t'#3300CC',\n\t'#3300FF',\n\t'#3333CC',\n\t'#3333FF',\n\t'#3366CC',\n\t'#3366FF',\n\t'#3399CC',\n\t'#3399FF',\n\t'#33CC00',\n\t'#33CC33',\n\t'#33CC66',\n\t'#33CC99',\n\t'#33CCCC',\n\t'#33CCFF',\n\t'#6600CC',\n\t'#6600FF',\n\t'#6633CC',\n\t'#6633FF',\n\t'#66CC00',\n\t'#66CC33',\n\t'#9900CC',\n\t'#9900FF',\n\t'#9933CC',\n\t'#9933FF',\n\t'#99CC00',\n\t'#99CC33',\n\t'#CC0000',\n\t'#CC0033',\n\t'#CC0066',\n\t'#CC0099',\n\t'#CC00CC',\n\t'#CC00FF',\n\t'#CC3300',\n\t'#CC3333',\n\t'#CC3366',\n\t'#CC3399',\n\t'#CC33CC',\n\t'#CC33FF',\n\t'#CC6600',\n\t'#CC6633',\n\t'#CC9900',\n\t'#CC9933',\n\t'#CCCC00',\n\t'#CCCC33',\n\t'#FF0000',\n\t'#FF0033',\n\t'#FF0066',\n\t'#FF0099',\n\t'#FF00CC',\n\t'#FF00FF',\n\t'#FF3300',\n\t'#FF3333',\n\t'#FF3366',\n\t'#FF3399',\n\t'#FF33CC',\n\t'#FF33FF',\n\t'#FF6600',\n\t'#FF6633',\n\t'#FF9900',\n\t'#FF9933',\n\t'#FFCC00',\n\t'#FFCC33'\n];\n\n/**\n * Currently only WebKit-based Web Inspectors, Firefox >= v31,\n * and the Firebug extension (any Firefox version) are known\n * to support \"%c\" CSS customizations.\n *\n * TODO: add a `localStorage` variable to explicitly enable/disable colors\n */\n\n// eslint-disable-next-line complexity\nfunction useColors() {\n\t// NB: In an Electron preload script, document will be defined but not fully\n\t// initialized. Since we know we're in Chrome, we'll just detect this case\n\t// explicitly\n\tif (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {\n\t\treturn true;\n\t}\n\n\t// Internet Explorer and Edge do not support colors.\n\tif (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\\/(\\d+)/)) {\n\t\treturn false;\n\t}\n\n\t// Is webkit? http://stackoverflow.com/a/16459606/376773\n\t// document is undefined in react-native: https://github.com/facebook/react-native/pull/1632\n\treturn (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||\n\t\t// Is firebug? http://stackoverflow.com/a/398120/376773\n\t\t(typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||\n\t\t// Is firefox >= v31?\n\t\t// https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages\n\t\t(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||\n\t\t// Double check webkit in userAgent just in case we are in a worker\n\t\t(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\\/(\\d+)/));\n}\n\n/**\n * Colorize log arguments if enabled.\n *\n * @api public\n */\n\nfunction formatArgs(args) {\n\targs[0] = (this.useColors ? '%c' : '') +\n\t\tthis.namespace +\n\t\t(this.useColors ? ' %c' : ' ') +\n\t\targs[0] +\n\t\t(this.useColors ? '%c ' : ' ') +\n\t\t'+' + module.exports.humanize(this.diff);\n\n\tif (!this.useColors) {\n\t\treturn;\n\t}\n\n\tconst c = 'color: ' + this.color;\n\targs.splice(1, 0, c, 'color: inherit');\n\n\t// The final \"%c\" is somewhat tricky, because there could be other\n\t// arguments passed either before or after the %c, so we need to\n\t// figure out the correct index to insert the CSS into\n\tlet index = 0;\n\tlet lastC = 0;\n\targs[0].replace(/%[a-zA-Z%]/g, match => {\n\t\tif (match === '%%') {\n\t\t\treturn;\n\t\t}\n\t\tindex++;\n\t\tif (match === '%c') {\n\t\t\t// We only are interested in the *last* %c\n\t\t\t// (the user may have provided their own)\n\t\t\tlastC = index;\n\t\t}\n\t});\n\n\targs.splice(lastC, 0, c);\n}\n\n/**\n * Invokes `console.debug()` when available.\n * No-op when `console.debug` is not a \"function\".\n * If `console.debug` is not available, falls back\n * to `console.log`.\n *\n * @api public\n */\nexports.log = console.debug || console.log || (() => {});\n\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */\nfunction save(namespaces) {\n\ttry {\n\t\tif (namespaces) {\n\t\t\texports.storage.setItem('debug', namespaces);\n\t\t} else {\n\t\t\texports.storage.removeItem('debug');\n\t\t}\n\t} catch (error) {\n\t\t// Swallow\n\t\t// XXX (@Qix-) should we be logging these?\n\t}\n}\n\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */\nfunction load() {\n\tlet r;\n\ttry {\n\t\tr = exports.storage.getItem('debug');\n\t} catch (error) {\n\t\t// Swallow\n\t\t// XXX (@Qix-) should we be logging these?\n\t}\n\n\t// If debug isn't set in LS, and we're in Electron, try to load $DEBUG\n\tif (!r && typeof process !== 'undefined' && 'env' in process) {\n\t\tr = process.env.DEBUG;\n\t}\n\n\treturn r;\n}\n\n/**\n * Localstorage attempts to return the localstorage.\n *\n * This is necessary because safari throws\n * when a user disables cookies/localstorage\n * and you attempt to access it.\n *\n * @return {LocalStorage}\n * @api private\n */\n\nfunction localstorage() {\n\ttry {\n\t\t// TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context\n\t\t// The Browser also has localStorage in the global context.\n\t\treturn localStorage;\n\t} catch (error) {\n\t\t// Swallow\n\t\t// XXX (@Qix-) should we be logging these?\n\t}\n}\n\nmodule.exports = __webpack_require__(/*! ./common */ \"../server/node_modules/mquery/node_modules/debug/src/common.js\")(exports);\n\nconst {formatters} = module.exports;\n\n/**\n * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.\n */\n\nformatters.j = function (v) {\n\ttry {\n\t\treturn JSON.stringify(v);\n\t} catch (error) {\n\t\treturn '[UnexpectedJSONParseError]: ' + error.message;\n\t}\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tcXVlcnkvbm9kZV9tb2R1bGVzL2RlYnVnL3NyYy9icm93c2VyLmpzIiwibWFwcGluZ3MiOiJBQUFBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0I7QUFDbEIsWUFBWTtBQUNaLFlBQVk7QUFDWixpQkFBaUI7QUFDakIsZUFBZTtBQUNmLGVBQWU7QUFDZjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsNENBQTRDOztBQUV2RDtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUJBQWlCLG1CQUFPLENBQUMsZ0ZBQVU7O0FBRW5DLE9BQU8sWUFBWTs7QUFFbkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbGllbnQvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tcXVlcnkvbm9kZV9tb2R1bGVzL2RlYnVnL3NyYy9icm93c2VyLmpzP2I5NzEiXSwic291cmNlc0NvbnRlbnQiOlsiLyogZXNsaW50LWVudiBicm93c2VyICovXG5cbi8qKlxuICogVGhpcyBpcyB0aGUgd2ViIGJyb3dzZXIgaW1wbGVtZW50YXRpb24gb2YgYGRlYnVnKClgLlxuICovXG5cbmV4cG9ydHMuZm9ybWF0QXJncyA9IGZvcm1hdEFyZ3M7XG5leHBvcnRzLnNhdmUgPSBzYXZlO1xuZXhwb3J0cy5sb2FkID0gbG9hZDtcbmV4cG9ydHMudXNlQ29sb3JzID0gdXNlQ29sb3JzO1xuZXhwb3J0cy5zdG9yYWdlID0gbG9jYWxzdG9yYWdlKCk7XG5leHBvcnRzLmRlc3Ryb3kgPSAoKCkgPT4ge1xuXHRsZXQgd2FybmVkID0gZmFsc2U7XG5cblx0cmV0dXJuICgpID0+IHtcblx0XHRpZiAoIXdhcm5lZCkge1xuXHRcdFx0d2FybmVkID0gdHJ1ZTtcblx0XHRcdGNvbnNvbGUud2FybignSW5zdGFuY2UgbWV0aG9kIGBkZWJ1Zy5kZXN0cm95KClgIGlzIGRlcHJlY2F0ZWQgYW5kIG5vIGxvbmdlciBkb2VzIGFueXRoaW5nLiBJdCB3aWxsIGJlIHJlbW92ZWQgaW4gdGhlIG5leHQgbWFqb3IgdmVyc2lvbiBvZiBgZGVidWdgLicpO1xuXHRcdH1cblx0fTtcbn0pKCk7XG5cbi8qKlxuICogQ29sb3JzLlxuICovXG5cbmV4cG9ydHMuY29sb3JzID0gW1xuXHQnIzAwMDBDQycsXG5cdCcjMDAwMEZGJyxcblx0JyMwMDMzQ0MnLFxuXHQnIzAwMzNGRicsXG5cdCcjMDA2NkNDJyxcblx0JyMwMDY2RkYnLFxuXHQnIzAwOTlDQycsXG5cdCcjMDA5OUZGJyxcblx0JyMwMENDMDAnLFxuXHQnIzAwQ0MzMycsXG5cdCcjMDBDQzY2Jyxcblx0JyMwMENDOTknLFxuXHQnIzAwQ0NDQycsXG5cdCcjMDBDQ0ZGJyxcblx0JyMzMzAwQ0MnLFxuXHQnIzMzMDBGRicsXG5cdCcjMzMzM0NDJyxcblx0JyMzMzMzRkYnLFxuXHQnIzMzNjZDQycsXG5cdCcjMzM2NkZGJyxcblx0JyMzMzk5Q0MnLFxuXHQnIzMzOTlGRicsXG5cdCcjMzNDQzAwJyxcblx0JyMzM0NDMzMnLFxuXHQnIzMzQ0M2NicsXG5cdCcjMzNDQzk5Jyxcblx0JyMzM0NDQ0MnLFxuXHQnIzMzQ0NGRicsXG5cdCcjNjYwMENDJyxcblx0JyM2NjAwRkYnLFxuXHQnIzY2MzNDQycsXG5cdCcjNjYzM0ZGJyxcblx0JyM2NkNDMDAnLFxuXHQnIzY2Q0MzMycsXG5cdCcjOTkwMENDJyxcblx0JyM5OTAwRkYnLFxuXHQnIzk5MzNDQycsXG5cdCcjOTkzM0ZGJyxcblx0JyM5OUNDMDAnLFxuXHQnIzk5Q0MzMycsXG5cdCcjQ0MwMDAwJyxcblx0JyNDQzAwMzMnLFxuXHQnI0NDMDA2NicsXG5cdCcjQ0MwMDk5Jyxcblx0JyNDQzAwQ0MnLFxuXHQnI0NDMDBGRicsXG5cdCcjQ0MzMzAwJyxcblx0JyNDQzMzMzMnLFxuXHQnI0NDMzM2NicsXG5cdCcjQ0MzMzk5Jyxcblx0JyNDQzMzQ0MnLFxuXHQnI0NDMzNGRicsXG5cdCcjQ0M2NjAwJyxcblx0JyNDQzY2MzMnLFxuXHQnI0NDOTkwMCcsXG5cdCcjQ0M5OTMzJyxcblx0JyNDQ0NDMDAnLFxuXHQnI0NDQ0MzMycsXG5cdCcjRkYwMDAwJyxcblx0JyNGRjAwMzMnLFxuXHQnI0ZGMDA2NicsXG5cdCcjRkYwMDk5Jyxcblx0JyNGRjAwQ0MnLFxuXHQnI0ZGMDBGRicsXG5cdCcjRkYzMzAwJyxcblx0JyNGRjMzMzMnLFxuXHQnI0ZGMzM2NicsXG5cdCcjRkYzMzk5Jyxcblx0JyNGRjMzQ0MnLFxuXHQnI0ZGMzNGRicsXG5cdCcjRkY2NjAwJyxcblx0JyNGRjY2MzMnLFxuXHQnI0ZGOTkwMCcsXG5cdCcjRkY5OTMzJyxcblx0JyNGRkNDMDAnLFxuXHQnI0ZGQ0MzMydcbl07XG5cbi8qKlxuICogQ3VycmVudGx5IG9ubHkgV2ViS2l0LWJhc2VkIFdlYiBJbnNwZWN0b3JzLCBGaXJlZm94ID49IHYzMSxcbiAqIGFuZCB0aGUgRmlyZWJ1ZyBleHRlbnNpb24gKGFueSBGaXJlZm94IHZlcnNpb24pIGFyZSBrbm93blxuICogdG8gc3VwcG9ydCBcIiVjXCIgQ1NTIGN1c3RvbWl6YXRpb25zLlxuICpcbiAqIFRPRE86IGFkZCBhIGBsb2NhbFN0b3JhZ2VgIHZhcmlhYmxlIHRvIGV4cGxpY2l0bHkgZW5hYmxlL2Rpc2FibGUgY29sb3JzXG4gKi9cblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbXBsZXhpdHlcbmZ1bmN0aW9uIHVzZUNvbG9ycygpIHtcblx0Ly8gTkI6IEluIGFuIEVsZWN0cm9uIHByZWxvYWQgc2NyaXB0LCBkb2N1bWVudCB3aWxsIGJlIGRlZmluZWQgYnV0IG5vdCBmdWxseVxuXHQvLyBpbml0aWFsaXplZC4gU2luY2Ugd2Uga25vdyB3ZSdyZSBpbiBDaHJvbWUsIHdlJ2xsIGp1c3QgZGV0ZWN0IHRoaXMgY2FzZVxuXHQvLyBleHBsaWNpdGx5XG5cdGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cucHJvY2VzcyAmJiAod2luZG93LnByb2Nlc3MudHlwZSA9PT0gJ3JlbmRlcmVyJyB8fCB3aW5kb3cucHJvY2Vzcy5fX253anMpKSB7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblxuXHQvLyBJbnRlcm5ldCBFeHBsb3JlciBhbmQgRWRnZSBkbyBub3Qgc3VwcG9ydCBjb2xvcnMuXG5cdGlmICh0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiBuYXZpZ2F0b3IudXNlckFnZW50ICYmIG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5tYXRjaCgvKGVkZ2V8dHJpZGVudClcXC8oXFxkKykvKSkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXG5cdC8vIElzIHdlYmtpdD8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMTY0NTk2MDYvMzc2NzczXG5cdC8vIGRvY3VtZW50IGlzIHVuZGVmaW5lZCBpbiByZWFjdC1uYXRpdmU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC1uYXRpdmUvcHVsbC8xNjMyXG5cdHJldHVybiAodHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZS5XZWJraXRBcHBlYXJhbmNlKSB8fFxuXHRcdC8vIElzIGZpcmVidWc/IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzM5ODEyMC8zNzY3NzNcblx0XHQodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LmNvbnNvbGUgJiYgKHdpbmRvdy5jb25zb2xlLmZpcmVidWcgfHwgKHdpbmRvdy5jb25zb2xlLmV4Y2VwdGlvbiAmJiB3aW5kb3cuY29uc29sZS50YWJsZSkpKSB8fFxuXHRcdC8vIElzIGZpcmVmb3ggPj0gdjMxP1xuXHRcdC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvVG9vbHMvV2ViX0NvbnNvbGUjU3R5bGluZ19tZXNzYWdlc1xuXHRcdCh0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiBuYXZpZ2F0b3IudXNlckFnZW50ICYmIG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5tYXRjaCgvZmlyZWZveFxcLyhcXGQrKS8pICYmIHBhcnNlSW50KFJlZ0V4cC4kMSwgMTApID49IDMxKSB8fFxuXHRcdC8vIERvdWJsZSBjaGVjayB3ZWJraXQgaW4gdXNlckFnZW50IGp1c3QgaW4gY2FzZSB3ZSBhcmUgaW4gYSB3b3JrZXJcblx0XHQodHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudCAmJiBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkubWF0Y2goL2FwcGxld2Via2l0XFwvKFxcZCspLykpO1xufVxuXG4vKipcbiAqIENvbG9yaXplIGxvZyBhcmd1bWVudHMgaWYgZW5hYmxlZC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGZvcm1hdEFyZ3MoYXJncykge1xuXHRhcmdzWzBdID0gKHRoaXMudXNlQ29sb3JzID8gJyVjJyA6ICcnKSArXG5cdFx0dGhpcy5uYW1lc3BhY2UgK1xuXHRcdCh0aGlzLnVzZUNvbG9ycyA/ICcgJWMnIDogJyAnKSArXG5cdFx0YXJnc1swXSArXG5cdFx0KHRoaXMudXNlQ29sb3JzID8gJyVjICcgOiAnICcpICtcblx0XHQnKycgKyBtb2R1bGUuZXhwb3J0cy5odW1hbml6ZSh0aGlzLmRpZmYpO1xuXG5cdGlmICghdGhpcy51c2VDb2xvcnMpIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHRjb25zdCBjID0gJ2NvbG9yOiAnICsgdGhpcy5jb2xvcjtcblx0YXJncy5zcGxpY2UoMSwgMCwgYywgJ2NvbG9yOiBpbmhlcml0Jyk7XG5cblx0Ly8gVGhlIGZpbmFsIFwiJWNcIiBpcyBzb21ld2hhdCB0cmlja3ksIGJlY2F1c2UgdGhlcmUgY291bGQgYmUgb3RoZXJcblx0Ly8gYXJndW1lbnRzIHBhc3NlZCBlaXRoZXIgYmVmb3JlIG9yIGFmdGVyIHRoZSAlYywgc28gd2UgbmVlZCB0b1xuXHQvLyBmaWd1cmUgb3V0IHRoZSBjb3JyZWN0IGluZGV4IHRvIGluc2VydCB0aGUgQ1NTIGludG9cblx0bGV0IGluZGV4ID0gMDtcblx0bGV0IGxhc3RDID0gMDtcblx0YXJnc1swXS5yZXBsYWNlKC8lW2EtekEtWiVdL2csIG1hdGNoID0+IHtcblx0XHRpZiAobWF0Y2ggPT09ICclJScpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0aW5kZXgrKztcblx0XHRpZiAobWF0Y2ggPT09ICclYycpIHtcblx0XHRcdC8vIFdlIG9ubHkgYXJlIGludGVyZXN0ZWQgaW4gdGhlICpsYXN0KiAlY1xuXHRcdFx0Ly8gKHRoZSB1c2VyIG1heSBoYXZlIHByb3ZpZGVkIHRoZWlyIG93bilcblx0XHRcdGxhc3RDID0gaW5kZXg7XG5cdFx0fVxuXHR9KTtcblxuXHRhcmdzLnNwbGljZShsYXN0QywgMCwgYyk7XG59XG5cbi8qKlxuICogSW52b2tlcyBgY29uc29sZS5kZWJ1ZygpYCB3aGVuIGF2YWlsYWJsZS5cbiAqIE5vLW9wIHdoZW4gYGNvbnNvbGUuZGVidWdgIGlzIG5vdCBhIFwiZnVuY3Rpb25cIi5cbiAqIElmIGBjb25zb2xlLmRlYnVnYCBpcyBub3QgYXZhaWxhYmxlLCBmYWxscyBiYWNrXG4gKiB0byBgY29uc29sZS5sb2dgLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cbmV4cG9ydHMubG9nID0gY29uc29sZS5kZWJ1ZyB8fCBjb25zb2xlLmxvZyB8fCAoKCkgPT4ge30pO1xuXG4vKipcbiAqIFNhdmUgYG5hbWVzcGFjZXNgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2VzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gc2F2ZShuYW1lc3BhY2VzKSB7XG5cdHRyeSB7XG5cdFx0aWYgKG5hbWVzcGFjZXMpIHtcblx0XHRcdGV4cG9ydHMuc3RvcmFnZS5zZXRJdGVtKCdkZWJ1ZycsIG5hbWVzcGFjZXMpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRleHBvcnRzLnN0b3JhZ2UucmVtb3ZlSXRlbSgnZGVidWcnKTtcblx0XHR9XG5cdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0Ly8gU3dhbGxvd1xuXHRcdC8vIFhYWCAoQFFpeC0pIHNob3VsZCB3ZSBiZSBsb2dnaW5nIHRoZXNlP1xuXHR9XG59XG5cbi8qKlxuICogTG9hZCBgbmFtZXNwYWNlc2AuXG4gKlxuICogQHJldHVybiB7U3RyaW5nfSByZXR1cm5zIHRoZSBwcmV2aW91c2x5IHBlcnNpc3RlZCBkZWJ1ZyBtb2Rlc1xuICogQGFwaSBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGxvYWQoKSB7XG5cdGxldCByO1xuXHR0cnkge1xuXHRcdHIgPSBleHBvcnRzLnN0b3JhZ2UuZ2V0SXRlbSgnZGVidWcnKTtcblx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHQvLyBTd2FsbG93XG5cdFx0Ly8gWFhYIChAUWl4LSkgc2hvdWxkIHdlIGJlIGxvZ2dpbmcgdGhlc2U/XG5cdH1cblxuXHQvLyBJZiBkZWJ1ZyBpc24ndCBzZXQgaW4gTFMsIGFuZCB3ZSdyZSBpbiBFbGVjdHJvbiwgdHJ5IHRvIGxvYWQgJERFQlVHXG5cdGlmICghciAmJiB0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgJiYgJ2VudicgaW4gcHJvY2Vzcykge1xuXHRcdHIgPSBwcm9jZXNzLmVudi5ERUJVRztcblx0fVxuXG5cdHJldHVybiByO1xufVxuXG4vKipcbiAqIExvY2Fsc3RvcmFnZSBhdHRlbXB0cyB0byByZXR1cm4gdGhlIGxvY2Fsc3RvcmFnZS5cbiAqXG4gKiBUaGlzIGlzIG5lY2Vzc2FyeSBiZWNhdXNlIHNhZmFyaSB0aHJvd3NcbiAqIHdoZW4gYSB1c2VyIGRpc2FibGVzIGNvb2tpZXMvbG9jYWxzdG9yYWdlXG4gKiBhbmQgeW91IGF0dGVtcHQgdG8gYWNjZXNzIGl0LlxuICpcbiAqIEByZXR1cm4ge0xvY2FsU3RvcmFnZX1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGxvY2Fsc3RvcmFnZSgpIHtcblx0dHJ5IHtcblx0XHQvLyBUVk1MS2l0IChBcHBsZSBUViBKUyBSdW50aW1lKSBkb2VzIG5vdCBoYXZlIGEgd2luZG93IG9iamVjdCwganVzdCBsb2NhbFN0b3JhZ2UgaW4gdGhlIGdsb2JhbCBjb250ZXh0XG5cdFx0Ly8gVGhlIEJyb3dzZXIgYWxzbyBoYXMgbG9jYWxTdG9yYWdlIGluIHRoZSBnbG9iYWwgY29udGV4dC5cblx0XHRyZXR1cm4gbG9jYWxTdG9yYWdlO1xuXHR9IGNhdGNoIChlcnJvcikge1xuXHRcdC8vIFN3YWxsb3dcblx0XHQvLyBYWFggKEBRaXgtKSBzaG91bGQgd2UgYmUgbG9nZ2luZyB0aGVzZT9cblx0fVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY29tbW9uJykoZXhwb3J0cyk7XG5cbmNvbnN0IHtmb3JtYXR0ZXJzfSA9IG1vZHVsZS5leHBvcnRzO1xuXG4vKipcbiAqIE1hcCAlaiB0byBgSlNPTi5zdHJpbmdpZnkoKWAsIHNpbmNlIG5vIFdlYiBJbnNwZWN0b3JzIGRvIHRoYXQgYnkgZGVmYXVsdC5cbiAqL1xuXG5mb3JtYXR0ZXJzLmogPSBmdW5jdGlvbiAodikge1xuXHR0cnkge1xuXHRcdHJldHVybiBKU09OLnN0cmluZ2lmeSh2KTtcblx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRyZXR1cm4gJ1tVbmV4cGVjdGVkSlNPTlBhcnNlRXJyb3JdOiAnICsgZXJyb3IubWVzc2FnZTtcblx0fVxufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../server/node_modules/mquery/node_modules/debug/src/browser.js\n");

/***/ }),

/***/ "../server/node_modules/mquery/node_modules/debug/src/common.js":
/*!**********************************************************************!*\
  !*** ../server/node_modules/mquery/node_modules/debug/src/common.js ***!
  \**********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n/**\n * This is the common logic for both the Node.js and web browser\n * implementations of `debug()`.\n */\n\nfunction setup(env) {\n\tcreateDebug.debug = createDebug;\n\tcreateDebug.default = createDebug;\n\tcreateDebug.coerce = coerce;\n\tcreateDebug.disable = disable;\n\tcreateDebug.enable = enable;\n\tcreateDebug.enabled = enabled;\n\tcreateDebug.humanize = __webpack_require__(/*! ms */ \"../server/node_modules/mquery/node_modules/ms/index.js\");\n\tcreateDebug.destroy = destroy;\n\n\tObject.keys(env).forEach(key => {\n\t\tcreateDebug[key] = env[key];\n\t});\n\n\t/**\n\t* The currently active debug mode names, and names to skip.\n\t*/\n\n\tcreateDebug.names = [];\n\tcreateDebug.skips = [];\n\n\t/**\n\t* Map of special \"%n\" handling functions, for the debug \"format\" argument.\n\t*\n\t* Valid key names are a single, lower or upper-case letter, i.e. \"n\" and \"N\".\n\t*/\n\tcreateDebug.formatters = {};\n\n\t/**\n\t* Selects a color for a debug namespace\n\t* @param {String} namespace The namespace string for the debug instance to be colored\n\t* @return {Number|String} An ANSI color code for the given namespace\n\t* @api private\n\t*/\n\tfunction selectColor(namespace) {\n\t\tlet hash = 0;\n\n\t\tfor (let i = 0; i < namespace.length; i++) {\n\t\t\thash = ((hash << 5) - hash) + namespace.charCodeAt(i);\n\t\t\thash |= 0; // Convert to 32bit integer\n\t\t}\n\n\t\treturn createDebug.colors[Math.abs(hash) % createDebug.colors.length];\n\t}\n\tcreateDebug.selectColor = selectColor;\n\n\t/**\n\t* Create a debugger with the given `namespace`.\n\t*\n\t* @param {String} namespace\n\t* @return {Function}\n\t* @api public\n\t*/\n\tfunction createDebug(namespace) {\n\t\tlet prevTime;\n\t\tlet enableOverride = null;\n\t\tlet namespacesCache;\n\t\tlet enabledCache;\n\n\t\tfunction debug(...args) {\n\t\t\t// Disabled?\n\t\t\tif (!debug.enabled) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst self = debug;\n\n\t\t\t// Set `diff` timestamp\n\t\t\tconst curr = Number(new Date());\n\t\t\tconst ms = curr - (prevTime || curr);\n\t\t\tself.diff = ms;\n\t\t\tself.prev = prevTime;\n\t\t\tself.curr = curr;\n\t\t\tprevTime = curr;\n\n\t\t\targs[0] = createDebug.coerce(args[0]);\n\n\t\t\tif (typeof args[0] !== 'string') {\n\t\t\t\t// Anything else let's inspect with %O\n\t\t\t\targs.unshift('%O');\n\t\t\t}\n\n\t\t\t// Apply any `formatters` transformations\n\t\t\tlet index = 0;\n\t\t\targs[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {\n\t\t\t\t// If we encounter an escaped % then don't increase the array index\n\t\t\t\tif (match === '%%') {\n\t\t\t\t\treturn '%';\n\t\t\t\t}\n\t\t\t\tindex++;\n\t\t\t\tconst formatter = createDebug.formatters[format];\n\t\t\t\tif (typeof formatter === 'function') {\n\t\t\t\t\tconst val = args[index];\n\t\t\t\t\tmatch = formatter.call(self, val);\n\n\t\t\t\t\t// Now we need to remove `args[index]` since it's inlined in the `format`\n\t\t\t\t\targs.splice(index, 1);\n\t\t\t\t\tindex--;\n\t\t\t\t}\n\t\t\t\treturn match;\n\t\t\t});\n\n\t\t\t// Apply env-specific formatting (colors, etc.)\n\t\t\tcreateDebug.formatArgs.call(self, args);\n\n\t\t\tconst logFn = self.log || createDebug.log;\n\t\t\tlogFn.apply(self, args);\n\t\t}\n\n\t\tdebug.namespace = namespace;\n\t\tdebug.useColors = createDebug.useColors();\n\t\tdebug.color = createDebug.selectColor(namespace);\n\t\tdebug.extend = extend;\n\t\tdebug.destroy = createDebug.destroy; // XXX Temporary. Will be removed in the next major release.\n\n\t\tObject.defineProperty(debug, 'enabled', {\n\t\t\tenumerable: true,\n\t\t\tconfigurable: false,\n\t\t\tget: () => {\n\t\t\t\tif (enableOverride !== null) {\n\t\t\t\t\treturn enableOverride;\n\t\t\t\t}\n\t\t\t\tif (namespacesCache !== createDebug.namespaces) {\n\t\t\t\t\tnamespacesCache = createDebug.namespaces;\n\t\t\t\t\tenabledCache = createDebug.enabled(namespace);\n\t\t\t\t}\n\n\t\t\t\treturn enabledCache;\n\t\t\t},\n\t\t\tset: v => {\n\t\t\t\tenableOverride = v;\n\t\t\t}\n\t\t});\n\n\t\t// Env-specific initialization logic for debug instances\n\t\tif (typeof createDebug.init === 'function') {\n\t\t\tcreateDebug.init(debug);\n\t\t}\n\n\t\treturn debug;\n\t}\n\n\tfunction extend(namespace, delimiter) {\n\t\tconst newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);\n\t\tnewDebug.log = this.log;\n\t\treturn newDebug;\n\t}\n\n\t/**\n\t* Enables a debug mode by namespaces. This can include modes\n\t* separated by a colon and wildcards.\n\t*\n\t* @param {String} namespaces\n\t* @api public\n\t*/\n\tfunction enable(namespaces) {\n\t\tcreateDebug.save(namespaces);\n\t\tcreateDebug.namespaces = namespaces;\n\n\t\tcreateDebug.names = [];\n\t\tcreateDebug.skips = [];\n\n\t\tlet i;\n\t\tconst split = (typeof namespaces === 'string' ? namespaces : '').split(/[\\s,]+/);\n\t\tconst len = split.length;\n\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tif (!split[i]) {\n\t\t\t\t// ignore empty strings\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tnamespaces = split[i].replace(/\\*/g, '.*?');\n\n\t\t\tif (namespaces[0] === '-') {\n\t\t\t\tcreateDebug.skips.push(new RegExp('^' + namespaces.slice(1) + '$'));\n\t\t\t} else {\n\t\t\t\tcreateDebug.names.push(new RegExp('^' + namespaces + '$'));\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t* Disable debug output.\n\t*\n\t* @return {String} namespaces\n\t* @api public\n\t*/\n\tfunction disable() {\n\t\tconst namespaces = [\n\t\t\t...createDebug.names.map(toNamespace),\n\t\t\t...createDebug.skips.map(toNamespace).map(namespace => '-' + namespace)\n\t\t].join(',');\n\t\tcreateDebug.enable('');\n\t\treturn namespaces;\n\t}\n\n\t/**\n\t* Returns true if the given mode name is enabled, false otherwise.\n\t*\n\t* @param {String} name\n\t* @return {Boolean}\n\t* @api public\n\t*/\n\tfunction enabled(name) {\n\t\tif (name[name.length - 1] === '*') {\n\t\t\treturn true;\n\t\t}\n\n\t\tlet i;\n\t\tlet len;\n\n\t\tfor (i = 0, len = createDebug.skips.length; i < len; i++) {\n\t\t\tif (createDebug.skips[i].test(name)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\tfor (i = 0, len = createDebug.names.length; i < len; i++) {\n\t\t\tif (createDebug.names[i].test(name)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t* Convert regexp to namespace\n\t*\n\t* @param {RegExp} regxep\n\t* @return {String} namespace\n\t* @api private\n\t*/\n\tfunction toNamespace(regexp) {\n\t\treturn regexp.toString()\n\t\t\t.substring(2, regexp.toString().length - 2)\n\t\t\t.replace(/\\.\\*\\?$/, '*');\n\t}\n\n\t/**\n\t* Coerce `val`.\n\t*\n\t* @param {Mixed} val\n\t* @return {Mixed}\n\t* @api private\n\t*/\n\tfunction coerce(val) {\n\t\tif (val instanceof Error) {\n\t\t\treturn val.stack || val.message;\n\t\t}\n\t\treturn val;\n\t}\n\n\t/**\n\t* XXX DO NOT USE. This is a temporary stub function.\n\t* XXX It WILL be removed in the next major release.\n\t*/\n\tfunction destroy() {\n\t\tconsole.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');\n\t}\n\n\tcreateDebug.enable(createDebug.load());\n\n\treturn createDebug;\n}\n\nmodule.exports = setup;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tcXVlcnkvbm9kZV9tb2R1bGVzL2RlYnVnL3NyYy9jb21tb24uanMiLCJtYXBwaW5ncyI6IjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLG1CQUFPLENBQUMsa0VBQUk7QUFDcEM7O0FBRUE7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsWUFBWSxlQUFlO0FBQzNCO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtCQUFrQixzQkFBc0I7QUFDeEM7QUFDQSxjQUFjO0FBQ2Q7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7O0FBRXZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxjQUFjLFNBQVM7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSw4Q0FBOEMsU0FBUztBQUN2RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw4Q0FBOEMsU0FBUztBQUN2RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbGllbnQvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tcXVlcnkvbm9kZV9tb2R1bGVzL2RlYnVnL3NyYy9jb21tb24uanM/ZTkwOSJdLCJzb3VyY2VzQ29udGVudCI6WyJcbi8qKlxuICogVGhpcyBpcyB0aGUgY29tbW9uIGxvZ2ljIGZvciBib3RoIHRoZSBOb2RlLmpzIGFuZCB3ZWIgYnJvd3NlclxuICogaW1wbGVtZW50YXRpb25zIG9mIGBkZWJ1ZygpYC5cbiAqL1xuXG5mdW5jdGlvbiBzZXR1cChlbnYpIHtcblx0Y3JlYXRlRGVidWcuZGVidWcgPSBjcmVhdGVEZWJ1Zztcblx0Y3JlYXRlRGVidWcuZGVmYXVsdCA9IGNyZWF0ZURlYnVnO1xuXHRjcmVhdGVEZWJ1Zy5jb2VyY2UgPSBjb2VyY2U7XG5cdGNyZWF0ZURlYnVnLmRpc2FibGUgPSBkaXNhYmxlO1xuXHRjcmVhdGVEZWJ1Zy5lbmFibGUgPSBlbmFibGU7XG5cdGNyZWF0ZURlYnVnLmVuYWJsZWQgPSBlbmFibGVkO1xuXHRjcmVhdGVEZWJ1Zy5odW1hbml6ZSA9IHJlcXVpcmUoJ21zJyk7XG5cdGNyZWF0ZURlYnVnLmRlc3Ryb3kgPSBkZXN0cm95O1xuXG5cdE9iamVjdC5rZXlzKGVudikuZm9yRWFjaChrZXkgPT4ge1xuXHRcdGNyZWF0ZURlYnVnW2tleV0gPSBlbnZba2V5XTtcblx0fSk7XG5cblx0LyoqXG5cdCogVGhlIGN1cnJlbnRseSBhY3RpdmUgZGVidWcgbW9kZSBuYW1lcywgYW5kIG5hbWVzIHRvIHNraXAuXG5cdCovXG5cblx0Y3JlYXRlRGVidWcubmFtZXMgPSBbXTtcblx0Y3JlYXRlRGVidWcuc2tpcHMgPSBbXTtcblxuXHQvKipcblx0KiBNYXAgb2Ygc3BlY2lhbCBcIiVuXCIgaGFuZGxpbmcgZnVuY3Rpb25zLCBmb3IgdGhlIGRlYnVnIFwiZm9ybWF0XCIgYXJndW1lbnQuXG5cdCpcblx0KiBWYWxpZCBrZXkgbmFtZXMgYXJlIGEgc2luZ2xlLCBsb3dlciBvciB1cHBlci1jYXNlIGxldHRlciwgaS5lLiBcIm5cIiBhbmQgXCJOXCIuXG5cdCovXG5cdGNyZWF0ZURlYnVnLmZvcm1hdHRlcnMgPSB7fTtcblxuXHQvKipcblx0KiBTZWxlY3RzIGEgY29sb3IgZm9yIGEgZGVidWcgbmFtZXNwYWNlXG5cdCogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZSBUaGUgbmFtZXNwYWNlIHN0cmluZyBmb3IgdGhlIGRlYnVnIGluc3RhbmNlIHRvIGJlIGNvbG9yZWRcblx0KiBAcmV0dXJuIHtOdW1iZXJ8U3RyaW5nfSBBbiBBTlNJIGNvbG9yIGNvZGUgZm9yIHRoZSBnaXZlbiBuYW1lc3BhY2Vcblx0KiBAYXBpIHByaXZhdGVcblx0Ki9cblx0ZnVuY3Rpb24gc2VsZWN0Q29sb3IobmFtZXNwYWNlKSB7XG5cdFx0bGV0IGhhc2ggPSAwO1xuXG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBuYW1lc3BhY2UubGVuZ3RoOyBpKyspIHtcblx0XHRcdGhhc2ggPSAoKGhhc2ggPDwgNSkgLSBoYXNoKSArIG5hbWVzcGFjZS5jaGFyQ29kZUF0KGkpO1xuXHRcdFx0aGFzaCB8PSAwOyAvLyBDb252ZXJ0IHRvIDMyYml0IGludGVnZXJcblx0XHR9XG5cblx0XHRyZXR1cm4gY3JlYXRlRGVidWcuY29sb3JzW01hdGguYWJzKGhhc2gpICUgY3JlYXRlRGVidWcuY29sb3JzLmxlbmd0aF07XG5cdH1cblx0Y3JlYXRlRGVidWcuc2VsZWN0Q29sb3IgPSBzZWxlY3RDb2xvcjtcblxuXHQvKipcblx0KiBDcmVhdGUgYSBkZWJ1Z2dlciB3aXRoIHRoZSBnaXZlbiBgbmFtZXNwYWNlYC5cblx0KlxuXHQqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2Vcblx0KiBAcmV0dXJuIHtGdW5jdGlvbn1cblx0KiBAYXBpIHB1YmxpY1xuXHQqL1xuXHRmdW5jdGlvbiBjcmVhdGVEZWJ1ZyhuYW1lc3BhY2UpIHtcblx0XHRsZXQgcHJldlRpbWU7XG5cdFx0bGV0IGVuYWJsZU92ZXJyaWRlID0gbnVsbDtcblx0XHRsZXQgbmFtZXNwYWNlc0NhY2hlO1xuXHRcdGxldCBlbmFibGVkQ2FjaGU7XG5cblx0XHRmdW5jdGlvbiBkZWJ1ZyguLi5hcmdzKSB7XG5cdFx0XHQvLyBEaXNhYmxlZD9cblx0XHRcdGlmICghZGVidWcuZW5hYmxlZCkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IHNlbGYgPSBkZWJ1ZztcblxuXHRcdFx0Ly8gU2V0IGBkaWZmYCB0aW1lc3RhbXBcblx0XHRcdGNvbnN0IGN1cnIgPSBOdW1iZXIobmV3IERhdGUoKSk7XG5cdFx0XHRjb25zdCBtcyA9IGN1cnIgLSAocHJldlRpbWUgfHwgY3Vycik7XG5cdFx0XHRzZWxmLmRpZmYgPSBtcztcblx0XHRcdHNlbGYucHJldiA9IHByZXZUaW1lO1xuXHRcdFx0c2VsZi5jdXJyID0gY3Vycjtcblx0XHRcdHByZXZUaW1lID0gY3VycjtcblxuXHRcdFx0YXJnc1swXSA9IGNyZWF0ZURlYnVnLmNvZXJjZShhcmdzWzBdKTtcblxuXHRcdFx0aWYgKHR5cGVvZiBhcmdzWzBdICE9PSAnc3RyaW5nJykge1xuXHRcdFx0XHQvLyBBbnl0aGluZyBlbHNlIGxldCdzIGluc3BlY3Qgd2l0aCAlT1xuXHRcdFx0XHRhcmdzLnVuc2hpZnQoJyVPJyk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEFwcGx5IGFueSBgZm9ybWF0dGVyc2AgdHJhbnNmb3JtYXRpb25zXG5cdFx0XHRsZXQgaW5kZXggPSAwO1xuXHRcdFx0YXJnc1swXSA9IGFyZ3NbMF0ucmVwbGFjZSgvJShbYS16QS1aJV0pL2csIChtYXRjaCwgZm9ybWF0KSA9PiB7XG5cdFx0XHRcdC8vIElmIHdlIGVuY291bnRlciBhbiBlc2NhcGVkICUgdGhlbiBkb24ndCBpbmNyZWFzZSB0aGUgYXJyYXkgaW5kZXhcblx0XHRcdFx0aWYgKG1hdGNoID09PSAnJSUnKSB7XG5cdFx0XHRcdFx0cmV0dXJuICclJztcblx0XHRcdFx0fVxuXHRcdFx0XHRpbmRleCsrO1xuXHRcdFx0XHRjb25zdCBmb3JtYXR0ZXIgPSBjcmVhdGVEZWJ1Zy5mb3JtYXR0ZXJzW2Zvcm1hdF07XG5cdFx0XHRcdGlmICh0eXBlb2YgZm9ybWF0dGVyID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRcdFx0Y29uc3QgdmFsID0gYXJnc1tpbmRleF07XG5cdFx0XHRcdFx0bWF0Y2ggPSBmb3JtYXR0ZXIuY2FsbChzZWxmLCB2YWwpO1xuXG5cdFx0XHRcdFx0Ly8gTm93IHdlIG5lZWQgdG8gcmVtb3ZlIGBhcmdzW2luZGV4XWAgc2luY2UgaXQncyBpbmxpbmVkIGluIHRoZSBgZm9ybWF0YFxuXHRcdFx0XHRcdGFyZ3Muc3BsaWNlKGluZGV4LCAxKTtcblx0XHRcdFx0XHRpbmRleC0tO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBtYXRjaDtcblx0XHRcdH0pO1xuXG5cdFx0XHQvLyBBcHBseSBlbnYtc3BlY2lmaWMgZm9ybWF0dGluZyAoY29sb3JzLCBldGMuKVxuXHRcdFx0Y3JlYXRlRGVidWcuZm9ybWF0QXJncy5jYWxsKHNlbGYsIGFyZ3MpO1xuXG5cdFx0XHRjb25zdCBsb2dGbiA9IHNlbGYubG9nIHx8IGNyZWF0ZURlYnVnLmxvZztcblx0XHRcdGxvZ0ZuLmFwcGx5KHNlbGYsIGFyZ3MpO1xuXHRcdH1cblxuXHRcdGRlYnVnLm5hbWVzcGFjZSA9IG5hbWVzcGFjZTtcblx0XHRkZWJ1Zy51c2VDb2xvcnMgPSBjcmVhdGVEZWJ1Zy51c2VDb2xvcnMoKTtcblx0XHRkZWJ1Zy5jb2xvciA9IGNyZWF0ZURlYnVnLnNlbGVjdENvbG9yKG5hbWVzcGFjZSk7XG5cdFx0ZGVidWcuZXh0ZW5kID0gZXh0ZW5kO1xuXHRcdGRlYnVnLmRlc3Ryb3kgPSBjcmVhdGVEZWJ1Zy5kZXN0cm95OyAvLyBYWFggVGVtcG9yYXJ5LiBXaWxsIGJlIHJlbW92ZWQgaW4gdGhlIG5leHQgbWFqb3IgcmVsZWFzZS5cblxuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShkZWJ1ZywgJ2VuYWJsZWQnLCB7XG5cdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdFx0Y29uZmlndXJhYmxlOiBmYWxzZSxcblx0XHRcdGdldDogKCkgPT4ge1xuXHRcdFx0XHRpZiAoZW5hYmxlT3ZlcnJpZGUgIT09IG51bGwpIHtcblx0XHRcdFx0XHRyZXR1cm4gZW5hYmxlT3ZlcnJpZGU7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKG5hbWVzcGFjZXNDYWNoZSAhPT0gY3JlYXRlRGVidWcubmFtZXNwYWNlcykge1xuXHRcdFx0XHRcdG5hbWVzcGFjZXNDYWNoZSA9IGNyZWF0ZURlYnVnLm5hbWVzcGFjZXM7XG5cdFx0XHRcdFx0ZW5hYmxlZENhY2hlID0gY3JlYXRlRGVidWcuZW5hYmxlZChuYW1lc3BhY2UpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIGVuYWJsZWRDYWNoZTtcblx0XHRcdH0sXG5cdFx0XHRzZXQ6IHYgPT4ge1xuXHRcdFx0XHRlbmFibGVPdmVycmlkZSA9IHY7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHQvLyBFbnYtc3BlY2lmaWMgaW5pdGlhbGl6YXRpb24gbG9naWMgZm9yIGRlYnVnIGluc3RhbmNlc1xuXHRcdGlmICh0eXBlb2YgY3JlYXRlRGVidWcuaW5pdCA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0Y3JlYXRlRGVidWcuaW5pdChkZWJ1Zyk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGRlYnVnO1xuXHR9XG5cblx0ZnVuY3Rpb24gZXh0ZW5kKG5hbWVzcGFjZSwgZGVsaW1pdGVyKSB7XG5cdFx0Y29uc3QgbmV3RGVidWcgPSBjcmVhdGVEZWJ1Zyh0aGlzLm5hbWVzcGFjZSArICh0eXBlb2YgZGVsaW1pdGVyID09PSAndW5kZWZpbmVkJyA/ICc6JyA6IGRlbGltaXRlcikgKyBuYW1lc3BhY2UpO1xuXHRcdG5ld0RlYnVnLmxvZyA9IHRoaXMubG9nO1xuXHRcdHJldHVybiBuZXdEZWJ1Zztcblx0fVxuXG5cdC8qKlxuXHQqIEVuYWJsZXMgYSBkZWJ1ZyBtb2RlIGJ5IG5hbWVzcGFjZXMuIFRoaXMgY2FuIGluY2x1ZGUgbW9kZXNcblx0KiBzZXBhcmF0ZWQgYnkgYSBjb2xvbiBhbmQgd2lsZGNhcmRzLlxuXHQqXG5cdCogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZXNcblx0KiBAYXBpIHB1YmxpY1xuXHQqL1xuXHRmdW5jdGlvbiBlbmFibGUobmFtZXNwYWNlcykge1xuXHRcdGNyZWF0ZURlYnVnLnNhdmUobmFtZXNwYWNlcyk7XG5cdFx0Y3JlYXRlRGVidWcubmFtZXNwYWNlcyA9IG5hbWVzcGFjZXM7XG5cblx0XHRjcmVhdGVEZWJ1Zy5uYW1lcyA9IFtdO1xuXHRcdGNyZWF0ZURlYnVnLnNraXBzID0gW107XG5cblx0XHRsZXQgaTtcblx0XHRjb25zdCBzcGxpdCA9ICh0eXBlb2YgbmFtZXNwYWNlcyA9PT0gJ3N0cmluZycgPyBuYW1lc3BhY2VzIDogJycpLnNwbGl0KC9bXFxzLF0rLyk7XG5cdFx0Y29uc3QgbGVuID0gc3BsaXQubGVuZ3RoO1xuXG5cdFx0Zm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRpZiAoIXNwbGl0W2ldKSB7XG5cdFx0XHRcdC8vIGlnbm9yZSBlbXB0eSBzdHJpbmdzXG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXG5cdFx0XHRuYW1lc3BhY2VzID0gc3BsaXRbaV0ucmVwbGFjZSgvXFwqL2csICcuKj8nKTtcblxuXHRcdFx0aWYgKG5hbWVzcGFjZXNbMF0gPT09ICctJykge1xuXHRcdFx0XHRjcmVhdGVEZWJ1Zy5za2lwcy5wdXNoKG5ldyBSZWdFeHAoJ14nICsgbmFtZXNwYWNlcy5zbGljZSgxKSArICckJykpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y3JlYXRlRGVidWcubmFtZXMucHVzaChuZXcgUmVnRXhwKCdeJyArIG5hbWVzcGFjZXMgKyAnJCcpKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvKipcblx0KiBEaXNhYmxlIGRlYnVnIG91dHB1dC5cblx0KlxuXHQqIEByZXR1cm4ge1N0cmluZ30gbmFtZXNwYWNlc1xuXHQqIEBhcGkgcHVibGljXG5cdCovXG5cdGZ1bmN0aW9uIGRpc2FibGUoKSB7XG5cdFx0Y29uc3QgbmFtZXNwYWNlcyA9IFtcblx0XHRcdC4uLmNyZWF0ZURlYnVnLm5hbWVzLm1hcCh0b05hbWVzcGFjZSksXG5cdFx0XHQuLi5jcmVhdGVEZWJ1Zy5za2lwcy5tYXAodG9OYW1lc3BhY2UpLm1hcChuYW1lc3BhY2UgPT4gJy0nICsgbmFtZXNwYWNlKVxuXHRcdF0uam9pbignLCcpO1xuXHRcdGNyZWF0ZURlYnVnLmVuYWJsZSgnJyk7XG5cdFx0cmV0dXJuIG5hbWVzcGFjZXM7XG5cdH1cblxuXHQvKipcblx0KiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIG1vZGUgbmFtZSBpcyBlbmFibGVkLCBmYWxzZSBvdGhlcndpc2UuXG5cdCpcblx0KiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuXHQqIEByZXR1cm4ge0Jvb2xlYW59XG5cdCogQGFwaSBwdWJsaWNcblx0Ki9cblx0ZnVuY3Rpb24gZW5hYmxlZChuYW1lKSB7XG5cdFx0aWYgKG5hbWVbbmFtZS5sZW5ndGggLSAxXSA9PT0gJyonKSB7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cblx0XHRsZXQgaTtcblx0XHRsZXQgbGVuO1xuXG5cdFx0Zm9yIChpID0gMCwgbGVuID0gY3JlYXRlRGVidWcuc2tpcHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdGlmIChjcmVhdGVEZWJ1Zy5za2lwc1tpXS50ZXN0KG5hbWUpKSB7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRmb3IgKGkgPSAwLCBsZW4gPSBjcmVhdGVEZWJ1Zy5uYW1lcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0aWYgKGNyZWF0ZURlYnVnLm5hbWVzW2ldLnRlc3QobmFtZSkpIHtcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cblx0LyoqXG5cdCogQ29udmVydCByZWdleHAgdG8gbmFtZXNwYWNlXG5cdCpcblx0KiBAcGFyYW0ge1JlZ0V4cH0gcmVneGVwXG5cdCogQHJldHVybiB7U3RyaW5nfSBuYW1lc3BhY2Vcblx0KiBAYXBpIHByaXZhdGVcblx0Ki9cblx0ZnVuY3Rpb24gdG9OYW1lc3BhY2UocmVnZXhwKSB7XG5cdFx0cmV0dXJuIHJlZ2V4cC50b1N0cmluZygpXG5cdFx0XHQuc3Vic3RyaW5nKDIsIHJlZ2V4cC50b1N0cmluZygpLmxlbmd0aCAtIDIpXG5cdFx0XHQucmVwbGFjZSgvXFwuXFwqXFw/JC8sICcqJyk7XG5cdH1cblxuXHQvKipcblx0KiBDb2VyY2UgYHZhbGAuXG5cdCpcblx0KiBAcGFyYW0ge01peGVkfSB2YWxcblx0KiBAcmV0dXJuIHtNaXhlZH1cblx0KiBAYXBpIHByaXZhdGVcblx0Ki9cblx0ZnVuY3Rpb24gY29lcmNlKHZhbCkge1xuXHRcdGlmICh2YWwgaW5zdGFuY2VvZiBFcnJvcikge1xuXHRcdFx0cmV0dXJuIHZhbC5zdGFjayB8fCB2YWwubWVzc2FnZTtcblx0XHR9XG5cdFx0cmV0dXJuIHZhbDtcblx0fVxuXG5cdC8qKlxuXHQqIFhYWCBETyBOT1QgVVNFLiBUaGlzIGlzIGEgdGVtcG9yYXJ5IHN0dWIgZnVuY3Rpb24uXG5cdCogWFhYIEl0IFdJTEwgYmUgcmVtb3ZlZCBpbiB0aGUgbmV4dCBtYWpvciByZWxlYXNlLlxuXHQqL1xuXHRmdW5jdGlvbiBkZXN0cm95KCkge1xuXHRcdGNvbnNvbGUud2FybignSW5zdGFuY2UgbWV0aG9kIGBkZWJ1Zy5kZXN0cm95KClgIGlzIGRlcHJlY2F0ZWQgYW5kIG5vIGxvbmdlciBkb2VzIGFueXRoaW5nLiBJdCB3aWxsIGJlIHJlbW92ZWQgaW4gdGhlIG5leHQgbWFqb3IgdmVyc2lvbiBvZiBgZGVidWdgLicpO1xuXHR9XG5cblx0Y3JlYXRlRGVidWcuZW5hYmxlKGNyZWF0ZURlYnVnLmxvYWQoKSk7XG5cblx0cmV0dXJuIGNyZWF0ZURlYnVnO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNldHVwO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../server/node_modules/mquery/node_modules/debug/src/common.js\n");

/***/ }),

/***/ "../server/node_modules/mquery/node_modules/debug/src/index.js":
/*!*********************************************************************!*\
  !*** ../server/node_modules/mquery/node_modules/debug/src/index.js ***!
  \*********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * Detect Electron renderer / nwjs process, which is node, but we should\n * treat as a browser.\n */\n\nif (typeof process === 'undefined' || process.type === 'renderer' || false === true || process.__nwjs) {\n\tmodule.exports = __webpack_require__(/*! ./browser.js */ \"../server/node_modules/mquery/node_modules/debug/src/browser.js\");\n} else {\n\tmodule.exports = __webpack_require__(/*! ./node.js */ \"../server/node_modules/mquery/node_modules/debug/src/node.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tcXVlcnkvbm9kZV9tb2R1bGVzL2RlYnVnL3NyYy9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxxRUFBcUUsS0FBZTtBQUNwRixDQUFDLDJIQUF3QztBQUN6QyxFQUFFO0FBQ0YsQ0FBQyxxSEFBcUM7QUFDdEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbGllbnQvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tcXVlcnkvbm9kZV9tb2R1bGVzL2RlYnVnL3NyYy9pbmRleC5qcz8yOWQ4Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogRGV0ZWN0IEVsZWN0cm9uIHJlbmRlcmVyIC8gbndqcyBwcm9jZXNzLCB3aGljaCBpcyBub2RlLCBidXQgd2Ugc2hvdWxkXG4gKiB0cmVhdCBhcyBhIGJyb3dzZXIuXG4gKi9cblxuaWYgKHR5cGVvZiBwcm9jZXNzID09PSAndW5kZWZpbmVkJyB8fCBwcm9jZXNzLnR5cGUgPT09ICdyZW5kZXJlcicgfHwgcHJvY2Vzcy5icm93c2VyID09PSB0cnVlIHx8IHByb2Nlc3MuX19ud2pzKSB7XG5cdG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9icm93c2VyLmpzJyk7XG59IGVsc2Uge1xuXHRtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbm9kZS5qcycpO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../server/node_modules/mquery/node_modules/debug/src/index.js\n");

/***/ }),

/***/ "../server/node_modules/mquery/node_modules/debug/src/node.js":
/*!********************************************************************!*\
  !*** ../server/node_modules/mquery/node_modules/debug/src/node.js ***!
  \********************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("/**\n * Module dependencies.\n */\n\nconst tty = __webpack_require__(/*! tty */ \"tty\");\nconst util = __webpack_require__(/*! util */ \"util\");\n\n/**\n * This is the Node.js implementation of `debug()`.\n */\n\nexports.init = init;\nexports.log = log;\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\nexports.destroy = util.deprecate(\n\t() => {},\n\t'Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.'\n);\n\n/**\n * Colors.\n */\n\nexports.colors = [6, 2, 3, 4, 5, 1];\n\ntry {\n\t// Optional dependency (as in, doesn't need to be installed, NOT like optionalDependencies in package.json)\n\t// eslint-disable-next-line import/no-extraneous-dependencies\n\tconst supportsColor = __webpack_require__(/*! supports-color */ \"../server/node_modules/supports-color/index.js\");\n\n\tif (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {\n\t\texports.colors = [\n\t\t\t20,\n\t\t\t21,\n\t\t\t26,\n\t\t\t27,\n\t\t\t32,\n\t\t\t33,\n\t\t\t38,\n\t\t\t39,\n\t\t\t40,\n\t\t\t41,\n\t\t\t42,\n\t\t\t43,\n\t\t\t44,\n\t\t\t45,\n\t\t\t56,\n\t\t\t57,\n\t\t\t62,\n\t\t\t63,\n\t\t\t68,\n\t\t\t69,\n\t\t\t74,\n\t\t\t75,\n\t\t\t76,\n\t\t\t77,\n\t\t\t78,\n\t\t\t79,\n\t\t\t80,\n\t\t\t81,\n\t\t\t92,\n\t\t\t93,\n\t\t\t98,\n\t\t\t99,\n\t\t\t112,\n\t\t\t113,\n\t\t\t128,\n\t\t\t129,\n\t\t\t134,\n\t\t\t135,\n\t\t\t148,\n\t\t\t149,\n\t\t\t160,\n\t\t\t161,\n\t\t\t162,\n\t\t\t163,\n\t\t\t164,\n\t\t\t165,\n\t\t\t166,\n\t\t\t167,\n\t\t\t168,\n\t\t\t169,\n\t\t\t170,\n\t\t\t171,\n\t\t\t172,\n\t\t\t173,\n\t\t\t178,\n\t\t\t179,\n\t\t\t184,\n\t\t\t185,\n\t\t\t196,\n\t\t\t197,\n\t\t\t198,\n\t\t\t199,\n\t\t\t200,\n\t\t\t201,\n\t\t\t202,\n\t\t\t203,\n\t\t\t204,\n\t\t\t205,\n\t\t\t206,\n\t\t\t207,\n\t\t\t208,\n\t\t\t209,\n\t\t\t214,\n\t\t\t215,\n\t\t\t220,\n\t\t\t221\n\t\t];\n\t}\n} catch (error) {\n\t// Swallow - we only care if `supports-color` is available; it doesn't have to be.\n}\n\n/**\n * Build up the default `inspectOpts` object from the environment variables.\n *\n *   $ DEBUG_COLORS=no DEBUG_DEPTH=10 DEBUG_SHOW_HIDDEN=enabled node script.js\n */\n\nexports.inspectOpts = Object.keys(process.env).filter(key => {\n\treturn /^debug_/i.test(key);\n}).reduce((obj, key) => {\n\t// Camel-case\n\tconst prop = key\n\t\t.substring(6)\n\t\t.toLowerCase()\n\t\t.replace(/_([a-z])/g, (_, k) => {\n\t\t\treturn k.toUpperCase();\n\t\t});\n\n\t// Coerce string value into JS value\n\tlet val = process.env[key];\n\tif (/^(yes|on|true|enabled)$/i.test(val)) {\n\t\tval = true;\n\t} else if (/^(no|off|false|disabled)$/i.test(val)) {\n\t\tval = false;\n\t} else if (val === 'null') {\n\t\tval = null;\n\t} else {\n\t\tval = Number(val);\n\t}\n\n\tobj[prop] = val;\n\treturn obj;\n}, {});\n\n/**\n * Is stdout a TTY? Colored output is enabled when `true`.\n */\n\nfunction useColors() {\n\treturn 'colors' in exports.inspectOpts ?\n\t\tBoolean(exports.inspectOpts.colors) :\n\t\ttty.isatty(process.stderr.fd);\n}\n\n/**\n * Adds ANSI color escape codes if enabled.\n *\n * @api public\n */\n\nfunction formatArgs(args) {\n\tconst {namespace: name, useColors} = this;\n\n\tif (useColors) {\n\t\tconst c = this.color;\n\t\tconst colorCode = '\\u001B[3' + (c < 8 ? c : '8;5;' + c);\n\t\tconst prefix = `  ${colorCode};1m${name} \\u001B[0m`;\n\n\t\targs[0] = prefix + args[0].split('\\n').join('\\n' + prefix);\n\t\targs.push(colorCode + 'm+' + module.exports.humanize(this.diff) + '\\u001B[0m');\n\t} else {\n\t\targs[0] = getDate() + name + ' ' + args[0];\n\t}\n}\n\nfunction getDate() {\n\tif (exports.inspectOpts.hideDate) {\n\t\treturn '';\n\t}\n\treturn new Date().toISOString() + ' ';\n}\n\n/**\n * Invokes `util.format()` with the specified arguments and writes to stderr.\n */\n\nfunction log(...args) {\n\treturn process.stderr.write(util.format(...args) + '\\n');\n}\n\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */\nfunction save(namespaces) {\n\tif (namespaces) {\n\t\tprocess.env.DEBUG = namespaces;\n\t} else {\n\t\t// If you set a process.env field to null or undefined, it gets cast to the\n\t\t// string 'null' or 'undefined'. Just delete instead.\n\t\tdelete process.env.DEBUG;\n\t}\n}\n\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */\n\nfunction load() {\n\treturn process.env.DEBUG;\n}\n\n/**\n * Init logic for `debug` instances.\n *\n * Create a new `inspectOpts` object in case `useColors` is set\n * differently for a particular `debug` instance.\n */\n\nfunction init(debug) {\n\tdebug.inspectOpts = {};\n\n\tconst keys = Object.keys(exports.inspectOpts);\n\tfor (let i = 0; i < keys.length; i++) {\n\t\tdebug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];\n\t}\n}\n\nmodule.exports = __webpack_require__(/*! ./common */ \"../server/node_modules/mquery/node_modules/debug/src/common.js\")(exports);\n\nconst {formatters} = module.exports;\n\n/**\n * Map %o to `util.inspect()`, all on a single line.\n */\n\nformatters.o = function (v) {\n\tthis.inspectOpts.colors = this.useColors;\n\treturn util.inspect(v, this.inspectOpts)\n\t\t.split('\\n')\n\t\t.map(str => str.trim())\n\t\t.join(' ');\n};\n\n/**\n * Map %O to `util.inspect()`, allowing multiple lines if needed.\n */\n\nformatters.O = function (v) {\n\tthis.inspectOpts.colors = this.useColors;\n\treturn util.inspect(v, this.inspectOpts);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tcXVlcnkvbm9kZV9tb2R1bGVzL2RlYnVnL3NyYy9ub2RlLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTs7QUFFQSxZQUFZLG1CQUFPLENBQUMsZ0JBQUs7QUFDekIsYUFBYSxtQkFBTyxDQUFDLGtCQUFNOztBQUUzQjtBQUNBO0FBQ0E7O0FBRUEsWUFBWTtBQUNaLFdBQVc7QUFDWCxrQkFBa0I7QUFDbEIsWUFBWTtBQUNaLFlBQVk7QUFDWixpQkFBaUI7QUFDakIsZUFBZTtBQUNmLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxjQUFjOztBQUVkO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixtQkFBTyxDQUFDLHNFQUFnQjs7QUFFL0M7QUFDQSxFQUFFLGNBQWM7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGLDZEQUE2RDtBQUM3RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1CQUFtQjtBQUNuQjtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUMsSUFBSTs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUSw0QkFBNEI7O0FBRXBDO0FBQ0E7QUFDQSxpREFBaUQsRUFBRTtBQUNuRCxzQkFBc0IsV0FBVyxJQUFJLE1BQU07O0FBRTNDO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLGlCQUFpQjtBQUNsQztBQUNBO0FBQ0E7O0FBRUEsaUJBQWlCLG1CQUFPLENBQUMsZ0ZBQVU7O0FBRW5DLE9BQU8sWUFBWTs7QUFFbkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2NsaWVudC8uLi9zZXJ2ZXIvbm9kZV9tb2R1bGVzL21xdWVyeS9ub2RlX21vZHVsZXMvZGVidWcvc3JjL25vZGUuanM/MjkxYSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxuY29uc3QgdHR5ID0gcmVxdWlyZSgndHR5Jyk7XG5jb25zdCB1dGlsID0gcmVxdWlyZSgndXRpbCcpO1xuXG4vKipcbiAqIFRoaXMgaXMgdGhlIE5vZGUuanMgaW1wbGVtZW50YXRpb24gb2YgYGRlYnVnKClgLlxuICovXG5cbmV4cG9ydHMuaW5pdCA9IGluaXQ7XG5leHBvcnRzLmxvZyA9IGxvZztcbmV4cG9ydHMuZm9ybWF0QXJncyA9IGZvcm1hdEFyZ3M7XG5leHBvcnRzLnNhdmUgPSBzYXZlO1xuZXhwb3J0cy5sb2FkID0gbG9hZDtcbmV4cG9ydHMudXNlQ29sb3JzID0gdXNlQ29sb3JzO1xuZXhwb3J0cy5kZXN0cm95ID0gdXRpbC5kZXByZWNhdGUoXG5cdCgpID0+IHt9LFxuXHQnSW5zdGFuY2UgbWV0aG9kIGBkZWJ1Zy5kZXN0cm95KClgIGlzIGRlcHJlY2F0ZWQgYW5kIG5vIGxvbmdlciBkb2VzIGFueXRoaW5nLiBJdCB3aWxsIGJlIHJlbW92ZWQgaW4gdGhlIG5leHQgbWFqb3IgdmVyc2lvbiBvZiBgZGVidWdgLidcbik7XG5cbi8qKlxuICogQ29sb3JzLlxuICovXG5cbmV4cG9ydHMuY29sb3JzID0gWzYsIDIsIDMsIDQsIDUsIDFdO1xuXG50cnkge1xuXHQvLyBPcHRpb25hbCBkZXBlbmRlbmN5IChhcyBpbiwgZG9lc24ndCBuZWVkIHRvIGJlIGluc3RhbGxlZCwgTk9UIGxpa2Ugb3B0aW9uYWxEZXBlbmRlbmNpZXMgaW4gcGFja2FnZS5qc29uKVxuXHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLWV4dHJhbmVvdXMtZGVwZW5kZW5jaWVzXG5cdGNvbnN0IHN1cHBvcnRzQ29sb3IgPSByZXF1aXJlKCdzdXBwb3J0cy1jb2xvcicpO1xuXG5cdGlmIChzdXBwb3J0c0NvbG9yICYmIChzdXBwb3J0c0NvbG9yLnN0ZGVyciB8fCBzdXBwb3J0c0NvbG9yKS5sZXZlbCA+PSAyKSB7XG5cdFx0ZXhwb3J0cy5jb2xvcnMgPSBbXG5cdFx0XHQyMCxcblx0XHRcdDIxLFxuXHRcdFx0MjYsXG5cdFx0XHQyNyxcblx0XHRcdDMyLFxuXHRcdFx0MzMsXG5cdFx0XHQzOCxcblx0XHRcdDM5LFxuXHRcdFx0NDAsXG5cdFx0XHQ0MSxcblx0XHRcdDQyLFxuXHRcdFx0NDMsXG5cdFx0XHQ0NCxcblx0XHRcdDQ1LFxuXHRcdFx0NTYsXG5cdFx0XHQ1Nyxcblx0XHRcdDYyLFxuXHRcdFx0NjMsXG5cdFx0XHQ2OCxcblx0XHRcdDY5LFxuXHRcdFx0NzQsXG5cdFx0XHQ3NSxcblx0XHRcdDc2LFxuXHRcdFx0NzcsXG5cdFx0XHQ3OCxcblx0XHRcdDc5LFxuXHRcdFx0ODAsXG5cdFx0XHQ4MSxcblx0XHRcdDkyLFxuXHRcdFx0OTMsXG5cdFx0XHQ5OCxcblx0XHRcdDk5LFxuXHRcdFx0MTEyLFxuXHRcdFx0MTEzLFxuXHRcdFx0MTI4LFxuXHRcdFx0MTI5LFxuXHRcdFx0MTM0LFxuXHRcdFx0MTM1LFxuXHRcdFx0MTQ4LFxuXHRcdFx0MTQ5LFxuXHRcdFx0MTYwLFxuXHRcdFx0MTYxLFxuXHRcdFx0MTYyLFxuXHRcdFx0MTYzLFxuXHRcdFx0MTY0LFxuXHRcdFx0MTY1LFxuXHRcdFx0MTY2LFxuXHRcdFx0MTY3LFxuXHRcdFx0MTY4LFxuXHRcdFx0MTY5LFxuXHRcdFx0MTcwLFxuXHRcdFx0MTcxLFxuXHRcdFx0MTcyLFxuXHRcdFx0MTczLFxuXHRcdFx0MTc4LFxuXHRcdFx0MTc5LFxuXHRcdFx0MTg0LFxuXHRcdFx0MTg1LFxuXHRcdFx0MTk2LFxuXHRcdFx0MTk3LFxuXHRcdFx0MTk4LFxuXHRcdFx0MTk5LFxuXHRcdFx0MjAwLFxuXHRcdFx0MjAxLFxuXHRcdFx0MjAyLFxuXHRcdFx0MjAzLFxuXHRcdFx0MjA0LFxuXHRcdFx0MjA1LFxuXHRcdFx0MjA2LFxuXHRcdFx0MjA3LFxuXHRcdFx0MjA4LFxuXHRcdFx0MjA5LFxuXHRcdFx0MjE0LFxuXHRcdFx0MjE1LFxuXHRcdFx0MjIwLFxuXHRcdFx0MjIxXG5cdFx0XTtcblx0fVxufSBjYXRjaCAoZXJyb3IpIHtcblx0Ly8gU3dhbGxvdyAtIHdlIG9ubHkgY2FyZSBpZiBgc3VwcG9ydHMtY29sb3JgIGlzIGF2YWlsYWJsZTsgaXQgZG9lc24ndCBoYXZlIHRvIGJlLlxufVxuXG4vKipcbiAqIEJ1aWxkIHVwIHRoZSBkZWZhdWx0IGBpbnNwZWN0T3B0c2Agb2JqZWN0IGZyb20gdGhlIGVudmlyb25tZW50IHZhcmlhYmxlcy5cbiAqXG4gKiAgICQgREVCVUdfQ09MT1JTPW5vIERFQlVHX0RFUFRIPTEwIERFQlVHX1NIT1dfSElEREVOPWVuYWJsZWQgbm9kZSBzY3JpcHQuanNcbiAqL1xuXG5leHBvcnRzLmluc3BlY3RPcHRzID0gT2JqZWN0LmtleXMocHJvY2Vzcy5lbnYpLmZpbHRlcihrZXkgPT4ge1xuXHRyZXR1cm4gL15kZWJ1Z18vaS50ZXN0KGtleSk7XG59KS5yZWR1Y2UoKG9iaiwga2V5KSA9PiB7XG5cdC8vIENhbWVsLWNhc2Vcblx0Y29uc3QgcHJvcCA9IGtleVxuXHRcdC5zdWJzdHJpbmcoNilcblx0XHQudG9Mb3dlckNhc2UoKVxuXHRcdC5yZXBsYWNlKC9fKFthLXpdKS9nLCAoXywgaykgPT4ge1xuXHRcdFx0cmV0dXJuIGsudG9VcHBlckNhc2UoKTtcblx0XHR9KTtcblxuXHQvLyBDb2VyY2Ugc3RyaW5nIHZhbHVlIGludG8gSlMgdmFsdWVcblx0bGV0IHZhbCA9IHByb2Nlc3MuZW52W2tleV07XG5cdGlmICgvXih5ZXN8b258dHJ1ZXxlbmFibGVkKSQvaS50ZXN0KHZhbCkpIHtcblx0XHR2YWwgPSB0cnVlO1xuXHR9IGVsc2UgaWYgKC9eKG5vfG9mZnxmYWxzZXxkaXNhYmxlZCkkL2kudGVzdCh2YWwpKSB7XG5cdFx0dmFsID0gZmFsc2U7XG5cdH0gZWxzZSBpZiAodmFsID09PSAnbnVsbCcpIHtcblx0XHR2YWwgPSBudWxsO1xuXHR9IGVsc2Uge1xuXHRcdHZhbCA9IE51bWJlcih2YWwpO1xuXHR9XG5cblx0b2JqW3Byb3BdID0gdmFsO1xuXHRyZXR1cm4gb2JqO1xufSwge30pO1xuXG4vKipcbiAqIElzIHN0ZG91dCBhIFRUWT8gQ29sb3JlZCBvdXRwdXQgaXMgZW5hYmxlZCB3aGVuIGB0cnVlYC5cbiAqL1xuXG5mdW5jdGlvbiB1c2VDb2xvcnMoKSB7XG5cdHJldHVybiAnY29sb3JzJyBpbiBleHBvcnRzLmluc3BlY3RPcHRzID9cblx0XHRCb29sZWFuKGV4cG9ydHMuaW5zcGVjdE9wdHMuY29sb3JzKSA6XG5cdFx0dHR5LmlzYXR0eShwcm9jZXNzLnN0ZGVyci5mZCk7XG59XG5cbi8qKlxuICogQWRkcyBBTlNJIGNvbG9yIGVzY2FwZSBjb2RlcyBpZiBlbmFibGVkLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZm9ybWF0QXJncyhhcmdzKSB7XG5cdGNvbnN0IHtuYW1lc3BhY2U6IG5hbWUsIHVzZUNvbG9yc30gPSB0aGlzO1xuXG5cdGlmICh1c2VDb2xvcnMpIHtcblx0XHRjb25zdCBjID0gdGhpcy5jb2xvcjtcblx0XHRjb25zdCBjb2xvckNvZGUgPSAnXFx1MDAxQlszJyArIChjIDwgOCA/IGMgOiAnODs1OycgKyBjKTtcblx0XHRjb25zdCBwcmVmaXggPSBgICAke2NvbG9yQ29kZX07MW0ke25hbWV9IFxcdTAwMUJbMG1gO1xuXG5cdFx0YXJnc1swXSA9IHByZWZpeCArIGFyZ3NbMF0uc3BsaXQoJ1xcbicpLmpvaW4oJ1xcbicgKyBwcmVmaXgpO1xuXHRcdGFyZ3MucHVzaChjb2xvckNvZGUgKyAnbSsnICsgbW9kdWxlLmV4cG9ydHMuaHVtYW5pemUodGhpcy5kaWZmKSArICdcXHUwMDFCWzBtJyk7XG5cdH0gZWxzZSB7XG5cdFx0YXJnc1swXSA9IGdldERhdGUoKSArIG5hbWUgKyAnICcgKyBhcmdzWzBdO1xuXHR9XG59XG5cbmZ1bmN0aW9uIGdldERhdGUoKSB7XG5cdGlmIChleHBvcnRzLmluc3BlY3RPcHRzLmhpZGVEYXRlKSB7XG5cdFx0cmV0dXJuICcnO1xuXHR9XG5cdHJldHVybiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCkgKyAnICc7XG59XG5cbi8qKlxuICogSW52b2tlcyBgdXRpbC5mb3JtYXQoKWAgd2l0aCB0aGUgc3BlY2lmaWVkIGFyZ3VtZW50cyBhbmQgd3JpdGVzIHRvIHN0ZGVyci5cbiAqL1xuXG5mdW5jdGlvbiBsb2coLi4uYXJncykge1xuXHRyZXR1cm4gcHJvY2Vzcy5zdGRlcnIud3JpdGUodXRpbC5mb3JtYXQoLi4uYXJncykgKyAnXFxuJyk7XG59XG5cbi8qKlxuICogU2F2ZSBgbmFtZXNwYWNlc2AuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZXNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBzYXZlKG5hbWVzcGFjZXMpIHtcblx0aWYgKG5hbWVzcGFjZXMpIHtcblx0XHRwcm9jZXNzLmVudi5ERUJVRyA9IG5hbWVzcGFjZXM7XG5cdH0gZWxzZSB7XG5cdFx0Ly8gSWYgeW91IHNldCBhIHByb2Nlc3MuZW52IGZpZWxkIHRvIG51bGwgb3IgdW5kZWZpbmVkLCBpdCBnZXRzIGNhc3QgdG8gdGhlXG5cdFx0Ly8gc3RyaW5nICdudWxsJyBvciAndW5kZWZpbmVkJy4gSnVzdCBkZWxldGUgaW5zdGVhZC5cblx0XHRkZWxldGUgcHJvY2Vzcy5lbnYuREVCVUc7XG5cdH1cbn1cblxuLyoqXG4gKiBMb2FkIGBuYW1lc3BhY2VzYC5cbiAqXG4gKiBAcmV0dXJuIHtTdHJpbmd9IHJldHVybnMgdGhlIHByZXZpb3VzbHkgcGVyc2lzdGVkIGRlYnVnIG1vZGVzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBsb2FkKCkge1xuXHRyZXR1cm4gcHJvY2Vzcy5lbnYuREVCVUc7XG59XG5cbi8qKlxuICogSW5pdCBsb2dpYyBmb3IgYGRlYnVnYCBpbnN0YW5jZXMuXG4gKlxuICogQ3JlYXRlIGEgbmV3IGBpbnNwZWN0T3B0c2Agb2JqZWN0IGluIGNhc2UgYHVzZUNvbG9yc2AgaXMgc2V0XG4gKiBkaWZmZXJlbnRseSBmb3IgYSBwYXJ0aWN1bGFyIGBkZWJ1Z2AgaW5zdGFuY2UuXG4gKi9cblxuZnVuY3Rpb24gaW5pdChkZWJ1Zykge1xuXHRkZWJ1Zy5pbnNwZWN0T3B0cyA9IHt9O1xuXG5cdGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhleHBvcnRzLmluc3BlY3RPcHRzKTtcblx0Zm9yIChsZXQgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG5cdFx0ZGVidWcuaW5zcGVjdE9wdHNba2V5c1tpXV0gPSBleHBvcnRzLmluc3BlY3RPcHRzW2tleXNbaV1dO1xuXHR9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9jb21tb24nKShleHBvcnRzKTtcblxuY29uc3Qge2Zvcm1hdHRlcnN9ID0gbW9kdWxlLmV4cG9ydHM7XG5cbi8qKlxuICogTWFwICVvIHRvIGB1dGlsLmluc3BlY3QoKWAsIGFsbCBvbiBhIHNpbmdsZSBsaW5lLlxuICovXG5cbmZvcm1hdHRlcnMubyA9IGZ1bmN0aW9uICh2KSB7XG5cdHRoaXMuaW5zcGVjdE9wdHMuY29sb3JzID0gdGhpcy51c2VDb2xvcnM7XG5cdHJldHVybiB1dGlsLmluc3BlY3QodiwgdGhpcy5pbnNwZWN0T3B0cylcblx0XHQuc3BsaXQoJ1xcbicpXG5cdFx0Lm1hcChzdHIgPT4gc3RyLnRyaW0oKSlcblx0XHQuam9pbignICcpO1xufTtcblxuLyoqXG4gKiBNYXAgJU8gdG8gYHV0aWwuaW5zcGVjdCgpYCwgYWxsb3dpbmcgbXVsdGlwbGUgbGluZXMgaWYgbmVlZGVkLlxuICovXG5cbmZvcm1hdHRlcnMuTyA9IGZ1bmN0aW9uICh2KSB7XG5cdHRoaXMuaW5zcGVjdE9wdHMuY29sb3JzID0gdGhpcy51c2VDb2xvcnM7XG5cdHJldHVybiB1dGlsLmluc3BlY3QodiwgdGhpcy5pbnNwZWN0T3B0cyk7XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../server/node_modules/mquery/node_modules/debug/src/node.js\n");

/***/ }),

/***/ "../server/node_modules/mquery/node_modules/ms/index.js":
/*!**************************************************************!*\
  !*** ../server/node_modules/mquery/node_modules/ms/index.js ***!
  \**************************************************************/
/***/ ((module) => {

eval("/**\n * Helpers.\n */\n\nvar s = 1000;\nvar m = s * 60;\nvar h = m * 60;\nvar d = h * 24;\nvar w = d * 7;\nvar y = d * 365.25;\n\n/**\n * Parse or format the given `val`.\n *\n * Options:\n *\n *  - `long` verbose formatting [false]\n *\n * @param {String|Number} val\n * @param {Object} [options]\n * @throws {Error} throw an error if val is not a non-empty string or a number\n * @return {String|Number}\n * @api public\n */\n\nmodule.exports = function(val, options) {\n  options = options || {};\n  var type = typeof val;\n  if (type === 'string' && val.length > 0) {\n    return parse(val);\n  } else if (type === 'number' && isFinite(val)) {\n    return options.long ? fmtLong(val) : fmtShort(val);\n  }\n  throw new Error(\n    'val is not a non-empty string or a valid number. val=' +\n      JSON.stringify(val)\n  );\n};\n\n/**\n * Parse the given `str` and return milliseconds.\n *\n * @param {String} str\n * @return {Number}\n * @api private\n */\n\nfunction parse(str) {\n  str = String(str);\n  if (str.length > 100) {\n    return;\n  }\n  var match = /^(-?(?:\\d+)?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(\n    str\n  );\n  if (!match) {\n    return;\n  }\n  var n = parseFloat(match[1]);\n  var type = (match[2] || 'ms').toLowerCase();\n  switch (type) {\n    case 'years':\n    case 'year':\n    case 'yrs':\n    case 'yr':\n    case 'y':\n      return n * y;\n    case 'weeks':\n    case 'week':\n    case 'w':\n      return n * w;\n    case 'days':\n    case 'day':\n    case 'd':\n      return n * d;\n    case 'hours':\n    case 'hour':\n    case 'hrs':\n    case 'hr':\n    case 'h':\n      return n * h;\n    case 'minutes':\n    case 'minute':\n    case 'mins':\n    case 'min':\n    case 'm':\n      return n * m;\n    case 'seconds':\n    case 'second':\n    case 'secs':\n    case 'sec':\n    case 's':\n      return n * s;\n    case 'milliseconds':\n    case 'millisecond':\n    case 'msecs':\n    case 'msec':\n    case 'ms':\n      return n;\n    default:\n      return undefined;\n  }\n}\n\n/**\n * Short format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtShort(ms) {\n  var msAbs = Math.abs(ms);\n  if (msAbs >= d) {\n    return Math.round(ms / d) + 'd';\n  }\n  if (msAbs >= h) {\n    return Math.round(ms / h) + 'h';\n  }\n  if (msAbs >= m) {\n    return Math.round(ms / m) + 'm';\n  }\n  if (msAbs >= s) {\n    return Math.round(ms / s) + 's';\n  }\n  return ms + 'ms';\n}\n\n/**\n * Long format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtLong(ms) {\n  var msAbs = Math.abs(ms);\n  if (msAbs >= d) {\n    return plural(ms, msAbs, d, 'day');\n  }\n  if (msAbs >= h) {\n    return plural(ms, msAbs, h, 'hour');\n  }\n  if (msAbs >= m) {\n    return plural(ms, msAbs, m, 'minute');\n  }\n  if (msAbs >= s) {\n    return plural(ms, msAbs, s, 'second');\n  }\n  return ms + ' ms';\n}\n\n/**\n * Pluralization helper.\n */\n\nfunction plural(ms, msAbs, n, name) {\n  var isPlural = msAbs >= n * 1.5;\n  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tcXVlcnkvbm9kZV9tb2R1bGVzL21zL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGVBQWU7QUFDMUIsV0FBVyxRQUFRO0FBQ25CLFlBQVksT0FBTztBQUNuQixZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2xpZW50Ly4uL3NlcnZlci9ub2RlX21vZHVsZXMvbXF1ZXJ5L25vZGVfbW9kdWxlcy9tcy9pbmRleC5qcz9mODAyIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogSGVscGVycy5cbiAqL1xuXG52YXIgcyA9IDEwMDA7XG52YXIgbSA9IHMgKiA2MDtcbnZhciBoID0gbSAqIDYwO1xudmFyIGQgPSBoICogMjQ7XG52YXIgdyA9IGQgKiA3O1xudmFyIHkgPSBkICogMzY1LjI1O1xuXG4vKipcbiAqIFBhcnNlIG9yIGZvcm1hdCB0aGUgZ2l2ZW4gYHZhbGAuXG4gKlxuICogT3B0aW9uczpcbiAqXG4gKiAgLSBgbG9uZ2AgdmVyYm9zZSBmb3JtYXR0aW5nIFtmYWxzZV1cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ3xOdW1iZXJ9IHZhbFxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQHRocm93cyB7RXJyb3J9IHRocm93IGFuIGVycm9yIGlmIHZhbCBpcyBub3QgYSBub24tZW1wdHkgc3RyaW5nIG9yIGEgbnVtYmVyXG4gKiBAcmV0dXJuIHtTdHJpbmd8TnVtYmVyfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHZhbCwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsO1xuICBpZiAodHlwZSA9PT0gJ3N0cmluZycgJiYgdmFsLmxlbmd0aCA+IDApIHtcbiAgICByZXR1cm4gcGFyc2UodmFsKTtcbiAgfSBlbHNlIGlmICh0eXBlID09PSAnbnVtYmVyJyAmJiBpc0Zpbml0ZSh2YWwpKSB7XG4gICAgcmV0dXJuIG9wdGlvbnMubG9uZyA/IGZtdExvbmcodmFsKSA6IGZtdFNob3J0KHZhbCk7XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKFxuICAgICd2YWwgaXMgbm90IGEgbm9uLWVtcHR5IHN0cmluZyBvciBhIHZhbGlkIG51bWJlci4gdmFsPScgK1xuICAgICAgSlNPTi5zdHJpbmdpZnkodmFsKVxuICApO1xufTtcblxuLyoqXG4gKiBQYXJzZSB0aGUgZ2l2ZW4gYHN0cmAgYW5kIHJldHVybiBtaWxsaXNlY29uZHMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybiB7TnVtYmVyfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gcGFyc2Uoc3RyKSB7XG4gIHN0ciA9IFN0cmluZyhzdHIpO1xuICBpZiAoc3RyLmxlbmd0aCA+IDEwMCkge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgbWF0Y2ggPSAvXigtPyg/OlxcZCspP1xcLj9cXGQrKSAqKG1pbGxpc2Vjb25kcz98bXNlY3M/fG1zfHNlY29uZHM/fHNlY3M/fHN8bWludXRlcz98bWlucz98bXxob3Vycz98aHJzP3xofGRheXM/fGR8d2Vla3M/fHd8eWVhcnM/fHlycz98eSk/JC9pLmV4ZWMoXG4gICAgc3RyXG4gICk7XG4gIGlmICghbWF0Y2gpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIG4gPSBwYXJzZUZsb2F0KG1hdGNoWzFdKTtcbiAgdmFyIHR5cGUgPSAobWF0Y2hbMl0gfHwgJ21zJykudG9Mb3dlckNhc2UoKTtcbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSAneWVhcnMnOlxuICAgIGNhc2UgJ3llYXInOlxuICAgIGNhc2UgJ3lycyc6XG4gICAgY2FzZSAneXInOlxuICAgIGNhc2UgJ3knOlxuICAgICAgcmV0dXJuIG4gKiB5O1xuICAgIGNhc2UgJ3dlZWtzJzpcbiAgICBjYXNlICd3ZWVrJzpcbiAgICBjYXNlICd3JzpcbiAgICAgIHJldHVybiBuICogdztcbiAgICBjYXNlICdkYXlzJzpcbiAgICBjYXNlICdkYXknOlxuICAgIGNhc2UgJ2QnOlxuICAgICAgcmV0dXJuIG4gKiBkO1xuICAgIGNhc2UgJ2hvdXJzJzpcbiAgICBjYXNlICdob3VyJzpcbiAgICBjYXNlICdocnMnOlxuICAgIGNhc2UgJ2hyJzpcbiAgICBjYXNlICdoJzpcbiAgICAgIHJldHVybiBuICogaDtcbiAgICBjYXNlICdtaW51dGVzJzpcbiAgICBjYXNlICdtaW51dGUnOlxuICAgIGNhc2UgJ21pbnMnOlxuICAgIGNhc2UgJ21pbic6XG4gICAgY2FzZSAnbSc6XG4gICAgICByZXR1cm4gbiAqIG07XG4gICAgY2FzZSAnc2Vjb25kcyc6XG4gICAgY2FzZSAnc2Vjb25kJzpcbiAgICBjYXNlICdzZWNzJzpcbiAgICBjYXNlICdzZWMnOlxuICAgIGNhc2UgJ3MnOlxuICAgICAgcmV0dXJuIG4gKiBzO1xuICAgIGNhc2UgJ21pbGxpc2Vjb25kcyc6XG4gICAgY2FzZSAnbWlsbGlzZWNvbmQnOlxuICAgIGNhc2UgJ21zZWNzJzpcbiAgICBjYXNlICdtc2VjJzpcbiAgICBjYXNlICdtcyc6XG4gICAgICByZXR1cm4gbjtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxufVxuXG4vKipcbiAqIFNob3J0IGZvcm1hdCBmb3IgYG1zYC5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gbXNcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGZtdFNob3J0KG1zKSB7XG4gIHZhciBtc0FicyA9IE1hdGguYWJzKG1zKTtcbiAgaWYgKG1zQWJzID49IGQpIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIGQpICsgJ2QnO1xuICB9XG4gIGlmIChtc0FicyA+PSBoKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBoKSArICdoJztcbiAgfVxuICBpZiAobXNBYnMgPj0gbSkge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gbSkgKyAnbSc7XG4gIH1cbiAgaWYgKG1zQWJzID49IHMpIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIHMpICsgJ3MnO1xuICB9XG4gIHJldHVybiBtcyArICdtcyc7XG59XG5cbi8qKlxuICogTG9uZyBmb3JtYXQgZm9yIGBtc2AuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IG1zXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBmbXRMb25nKG1zKSB7XG4gIHZhciBtc0FicyA9IE1hdGguYWJzKG1zKTtcbiAgaWYgKG1zQWJzID49IGQpIHtcbiAgICByZXR1cm4gcGx1cmFsKG1zLCBtc0FicywgZCwgJ2RheScpO1xuICB9XG4gIGlmIChtc0FicyA+PSBoKSB7XG4gICAgcmV0dXJuIHBsdXJhbChtcywgbXNBYnMsIGgsICdob3VyJyk7XG4gIH1cbiAgaWYgKG1zQWJzID49IG0pIHtcbiAgICByZXR1cm4gcGx1cmFsKG1zLCBtc0FicywgbSwgJ21pbnV0ZScpO1xuICB9XG4gIGlmIChtc0FicyA+PSBzKSB7XG4gICAgcmV0dXJuIHBsdXJhbChtcywgbXNBYnMsIHMsICdzZWNvbmQnKTtcbiAgfVxuICByZXR1cm4gbXMgKyAnIG1zJztcbn1cblxuLyoqXG4gKiBQbHVyYWxpemF0aW9uIGhlbHBlci5cbiAqL1xuXG5mdW5jdGlvbiBwbHVyYWwobXMsIG1zQWJzLCBuLCBuYW1lKSB7XG4gIHZhciBpc1BsdXJhbCA9IG1zQWJzID49IG4gKiAxLjU7XG4gIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gbikgKyAnICcgKyBuYW1lICsgKGlzUGx1cmFsID8gJ3MnIDogJycpO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../server/node_modules/mquery/node_modules/ms/index.js\n");

/***/ })

};
;
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/mongoose";
exports.ids = ["vendor-chunks/mongoose"];
exports.modules = {

/***/ "../server/node_modules/mongoose/index.js":
/*!************************************************!*\
  !*** ../server/node_modules/mongoose/index.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/**\n * Export lib/mongoose\n *\n */\n\n\n\nconst mongoose = __webpack_require__(/*! ./lib/ */ \"../server/node_modules/mongoose/lib/index.js\");\n\nmodule.exports = mongoose;\nmodule.exports[\"default\"] = mongoose;\nmodule.exports.mongoose = mongoose;\n\n// Re-export for ESM support\nmodule.exports.cast = mongoose.cast;\nmodule.exports.STATES = mongoose.STATES;\nmodule.exports.setDriver = mongoose.setDriver;\nmodule.exports.set = mongoose.set;\nmodule.exports.get = mongoose.get;\nmodule.exports.createConnection = mongoose.createConnection;\nmodule.exports.connect = mongoose.connect;\nmodule.exports.disconnect = mongoose.disconnect;\nmodule.exports.startSession = mongoose.startSession;\nmodule.exports.pluralize = mongoose.pluralize;\nmodule.exports.model = mongoose.model;\nmodule.exports.deleteModel = mongoose.deleteModel;\nmodule.exports.modelNames = mongoose.modelNames;\nmodule.exports.plugin = mongoose.plugin;\nmodule.exports.connections = mongoose.connections;\nmodule.exports.version = mongoose.version;\nmodule.exports.Mongoose = mongoose.Mongoose;\nmodule.exports.Schema = mongoose.Schema;\nmodule.exports.SchemaType = mongoose.SchemaType;\nmodule.exports.SchemaTypes = mongoose.SchemaTypes;\nmodule.exports.VirtualType = mongoose.VirtualType;\nmodule.exports.Types = mongoose.Types;\nmodule.exports.Query = mongoose.Query;\nmodule.exports.Model = mongoose.Model;\nmodule.exports.Document = mongoose.Document;\nmodule.exports.ObjectId = mongoose.ObjectId;\nmodule.exports.isValidObjectId = mongoose.isValidObjectId;\nmodule.exports.isObjectIdOrHexString = mongoose.isObjectIdOrHexString;\nmodule.exports.syncIndexes = mongoose.syncIndexes;\nmodule.exports.Decimal128 = mongoose.Decimal128;\nmodule.exports.Mixed = mongoose.Mixed;\nmodule.exports.Date = mongoose.Date;\nmodule.exports.Number = mongoose.Number;\nmodule.exports.Error = mongoose.Error;\nmodule.exports.MongooseError = mongoose.MongooseError;\nmodule.exports.now = mongoose.now;\nmodule.exports.CastError = mongoose.CastError;\nmodule.exports.SchemaTypeOptions = mongoose.SchemaTypeOptions;\nmodule.exports.mongo = mongoose.mongo;\nmodule.exports.mquery = mongoose.mquery;\nmodule.exports.sanitizeFilter = mongoose.sanitizeFilter;\nmodule.exports.trusted = mongoose.trusted;\nmodule.exports.skipMiddlewareFunction = mongoose.skipMiddlewareFunction;\nmodule.exports.overwriteMiddlewareResult = mongoose.overwriteMiddlewareResult;\n\n// The following properties are not exported using ESM because `setDriver()` can mutate these\n// module.exports.connection = mongoose.connection;\n// module.exports.Collection = mongoose.Collection;\n// module.exports.Connection = mongoose.Connection;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTs7QUFFYTs7QUFFYixpQkFBaUIsbUJBQU8sQ0FBQyw0REFBUTs7QUFFakM7QUFDQSx5QkFBc0I7QUFDdEIsdUJBQXVCOztBQUV2QjtBQUNBLG1CQUFtQjtBQUNuQixxQkFBcUI7QUFDckIsd0JBQXdCO0FBQ3hCLGtCQUFrQjtBQUNsQixrQkFBa0I7QUFDbEIsK0JBQStCO0FBQy9CLHNCQUFzQjtBQUN0Qix5QkFBeUI7QUFDekIsMkJBQTJCO0FBQzNCLHdCQUF3QjtBQUN4QixvQkFBb0I7QUFDcEIsMEJBQTBCO0FBQzFCLHlCQUF5QjtBQUN6QixxQkFBcUI7QUFDckIsMEJBQTBCO0FBQzFCLHNCQUFzQjtBQUN0Qix1QkFBdUI7QUFDdkIscUJBQXFCO0FBQ3JCLHlCQUF5QjtBQUN6QiwwQkFBMEI7QUFDMUIsMEJBQTBCO0FBQzFCLG9CQUFvQjtBQUNwQixvQkFBb0I7QUFDcEIsb0JBQW9CO0FBQ3BCLHVCQUF1QjtBQUN2Qix1QkFBdUI7QUFDdkIsOEJBQThCO0FBQzlCLG9DQUFvQztBQUNwQywwQkFBMEI7QUFDMUIseUJBQXlCO0FBQ3pCLG9CQUFvQjtBQUNwQixtQkFBbUI7QUFDbkIscUJBQXFCO0FBQ3JCLG9CQUFvQjtBQUNwQiw0QkFBNEI7QUFDNUIsa0JBQWtCO0FBQ2xCLHdCQUF3QjtBQUN4QixnQ0FBZ0M7QUFDaEMsb0JBQW9CO0FBQ3BCLHFCQUFxQjtBQUNyQiw2QkFBNkI7QUFDN0Isc0JBQXNCO0FBQ3RCLHFDQUFxQztBQUNyQyx3Q0FBd0M7O0FBRXhDO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2xpZW50Ly4uL3NlcnZlci9ub2RlX21vZHVsZXMvbW9uZ29vc2UvaW5kZXguanM/ZDYzNyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEV4cG9ydCBsaWIvbW9uZ29vc2VcbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBtb25nb29zZSA9IHJlcXVpcmUoJy4vbGliLycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IG1vbmdvb3NlO1xubW9kdWxlLmV4cG9ydHMuZGVmYXVsdCA9IG1vbmdvb3NlO1xubW9kdWxlLmV4cG9ydHMubW9uZ29vc2UgPSBtb25nb29zZTtcblxuLy8gUmUtZXhwb3J0IGZvciBFU00gc3VwcG9ydFxubW9kdWxlLmV4cG9ydHMuY2FzdCA9IG1vbmdvb3NlLmNhc3Q7XG5tb2R1bGUuZXhwb3J0cy5TVEFURVMgPSBtb25nb29zZS5TVEFURVM7XG5tb2R1bGUuZXhwb3J0cy5zZXREcml2ZXIgPSBtb25nb29zZS5zZXREcml2ZXI7XG5tb2R1bGUuZXhwb3J0cy5zZXQgPSBtb25nb29zZS5zZXQ7XG5tb2R1bGUuZXhwb3J0cy5nZXQgPSBtb25nb29zZS5nZXQ7XG5tb2R1bGUuZXhwb3J0cy5jcmVhdGVDb25uZWN0aW9uID0gbW9uZ29vc2UuY3JlYXRlQ29ubmVjdGlvbjtcbm1vZHVsZS5leHBvcnRzLmNvbm5lY3QgPSBtb25nb29zZS5jb25uZWN0O1xubW9kdWxlLmV4cG9ydHMuZGlzY29ubmVjdCA9IG1vbmdvb3NlLmRpc2Nvbm5lY3Q7XG5tb2R1bGUuZXhwb3J0cy5zdGFydFNlc3Npb24gPSBtb25nb29zZS5zdGFydFNlc3Npb247XG5tb2R1bGUuZXhwb3J0cy5wbHVyYWxpemUgPSBtb25nb29zZS5wbHVyYWxpemU7XG5tb2R1bGUuZXhwb3J0cy5tb2RlbCA9IG1vbmdvb3NlLm1vZGVsO1xubW9kdWxlLmV4cG9ydHMuZGVsZXRlTW9kZWwgPSBtb25nb29zZS5kZWxldGVNb2RlbDtcbm1vZHVsZS5leHBvcnRzLm1vZGVsTmFtZXMgPSBtb25nb29zZS5tb2RlbE5hbWVzO1xubW9kdWxlLmV4cG9ydHMucGx1Z2luID0gbW9uZ29vc2UucGx1Z2luO1xubW9kdWxlLmV4cG9ydHMuY29ubmVjdGlvbnMgPSBtb25nb29zZS5jb25uZWN0aW9ucztcbm1vZHVsZS5leHBvcnRzLnZlcnNpb24gPSBtb25nb29zZS52ZXJzaW9uO1xubW9kdWxlLmV4cG9ydHMuTW9uZ29vc2UgPSBtb25nb29zZS5Nb25nb29zZTtcbm1vZHVsZS5leHBvcnRzLlNjaGVtYSA9IG1vbmdvb3NlLlNjaGVtYTtcbm1vZHVsZS5leHBvcnRzLlNjaGVtYVR5cGUgPSBtb25nb29zZS5TY2hlbWFUeXBlO1xubW9kdWxlLmV4cG9ydHMuU2NoZW1hVHlwZXMgPSBtb25nb29zZS5TY2hlbWFUeXBlcztcbm1vZHVsZS5leHBvcnRzLlZpcnR1YWxUeXBlID0gbW9uZ29vc2UuVmlydHVhbFR5cGU7XG5tb2R1bGUuZXhwb3J0cy5UeXBlcyA9IG1vbmdvb3NlLlR5cGVzO1xubW9kdWxlLmV4cG9ydHMuUXVlcnkgPSBtb25nb29zZS5RdWVyeTtcbm1vZHVsZS5leHBvcnRzLk1vZGVsID0gbW9uZ29vc2UuTW9kZWw7XG5tb2R1bGUuZXhwb3J0cy5Eb2N1bWVudCA9IG1vbmdvb3NlLkRvY3VtZW50O1xubW9kdWxlLmV4cG9ydHMuT2JqZWN0SWQgPSBtb25nb29zZS5PYmplY3RJZDtcbm1vZHVsZS5leHBvcnRzLmlzVmFsaWRPYmplY3RJZCA9IG1vbmdvb3NlLmlzVmFsaWRPYmplY3RJZDtcbm1vZHVsZS5leHBvcnRzLmlzT2JqZWN0SWRPckhleFN0cmluZyA9IG1vbmdvb3NlLmlzT2JqZWN0SWRPckhleFN0cmluZztcbm1vZHVsZS5leHBvcnRzLnN5bmNJbmRleGVzID0gbW9uZ29vc2Uuc3luY0luZGV4ZXM7XG5tb2R1bGUuZXhwb3J0cy5EZWNpbWFsMTI4ID0gbW9uZ29vc2UuRGVjaW1hbDEyODtcbm1vZHVsZS5leHBvcnRzLk1peGVkID0gbW9uZ29vc2UuTWl4ZWQ7XG5tb2R1bGUuZXhwb3J0cy5EYXRlID0gbW9uZ29vc2UuRGF0ZTtcbm1vZHVsZS5leHBvcnRzLk51bWJlciA9IG1vbmdvb3NlLk51bWJlcjtcbm1vZHVsZS5leHBvcnRzLkVycm9yID0gbW9uZ29vc2UuRXJyb3I7XG5tb2R1bGUuZXhwb3J0cy5Nb25nb29zZUVycm9yID0gbW9uZ29vc2UuTW9uZ29vc2VFcnJvcjtcbm1vZHVsZS5leHBvcnRzLm5vdyA9IG1vbmdvb3NlLm5vdztcbm1vZHVsZS5leHBvcnRzLkNhc3RFcnJvciA9IG1vbmdvb3NlLkNhc3RFcnJvcjtcbm1vZHVsZS5leHBvcnRzLlNjaGVtYVR5cGVPcHRpb25zID0gbW9uZ29vc2UuU2NoZW1hVHlwZU9wdGlvbnM7XG5tb2R1bGUuZXhwb3J0cy5tb25nbyA9IG1vbmdvb3NlLm1vbmdvO1xubW9kdWxlLmV4cG9ydHMubXF1ZXJ5ID0gbW9uZ29vc2UubXF1ZXJ5O1xubW9kdWxlLmV4cG9ydHMuc2FuaXRpemVGaWx0ZXIgPSBtb25nb29zZS5zYW5pdGl6ZUZpbHRlcjtcbm1vZHVsZS5leHBvcnRzLnRydXN0ZWQgPSBtb25nb29zZS50cnVzdGVkO1xubW9kdWxlLmV4cG9ydHMuc2tpcE1pZGRsZXdhcmVGdW5jdGlvbiA9IG1vbmdvb3NlLnNraXBNaWRkbGV3YXJlRnVuY3Rpb247XG5tb2R1bGUuZXhwb3J0cy5vdmVyd3JpdGVNaWRkbGV3YXJlUmVzdWx0ID0gbW9uZ29vc2Uub3ZlcndyaXRlTWlkZGxld2FyZVJlc3VsdDtcblxuLy8gVGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzIGFyZSBub3QgZXhwb3J0ZWQgdXNpbmcgRVNNIGJlY2F1c2UgYHNldERyaXZlcigpYCBjYW4gbXV0YXRlIHRoZXNlXG4vLyBtb2R1bGUuZXhwb3J0cy5jb25uZWN0aW9uID0gbW9uZ29vc2UuY29ubmVjdGlvbjtcbi8vIG1vZHVsZS5leHBvcnRzLkNvbGxlY3Rpb24gPSBtb25nb29zZS5Db2xsZWN0aW9uO1xuLy8gbW9kdWxlLmV4cG9ydHMuQ29ubmVjdGlvbiA9IG1vbmdvb3NlLkNvbm5lY3Rpb247XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../server/node_modules/mongoose/index.js\n");

/***/ }),

/***/ "../server/node_modules/mongoose/lib/aggregate.js":
/*!********************************************************!*\
  !*** ../server/node_modules/mongoose/lib/aggregate.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\n/*!\n * Module dependencies\n */\n\nconst AggregationCursor = __webpack_require__(/*! ./cursor/aggregationCursor */ \"../server/node_modules/mongoose/lib/cursor/aggregationCursor.js\");\nconst MongooseError = __webpack_require__(/*! ./error/mongooseError */ \"../server/node_modules/mongoose/lib/error/mongooseError.js\");\nconst Query = __webpack_require__(/*! ./query */ \"../server/node_modules/mongoose/lib/query.js\");\nconst { applyGlobalMaxTimeMS, applyGlobalDiskUse } = __webpack_require__(/*! ./helpers/query/applyGlobalOption */ \"../server/node_modules/mongoose/lib/helpers/query/applyGlobalOption.js\");\nconst clone = __webpack_require__(/*! ./helpers/clone */ \"../server/node_modules/mongoose/lib/helpers/clone.js\");\nconst getConstructorName = __webpack_require__(/*! ./helpers/getConstructorName */ \"../server/node_modules/mongoose/lib/helpers/getConstructorName.js\");\nconst prepareDiscriminatorPipeline = __webpack_require__(/*! ./helpers/aggregate/prepareDiscriminatorPipeline */ \"../server/node_modules/mongoose/lib/helpers/aggregate/prepareDiscriminatorPipeline.js\");\nconst stringifyFunctionOperators = __webpack_require__(/*! ./helpers/aggregate/stringifyFunctionOperators */ \"../server/node_modules/mongoose/lib/helpers/aggregate/stringifyFunctionOperators.js\");\nconst utils = __webpack_require__(/*! ./utils */ \"../server/node_modules/mongoose/lib/utils.js\");\nconst read = Query.prototype.read;\nconst readConcern = Query.prototype.readConcern;\n\nconst validRedactStringValues = new Set(['$$DESCEND', '$$PRUNE', '$$KEEP']);\n\n/**\n * Aggregate constructor used for building aggregation pipelines. Do not\n * instantiate this class directly, use [Model.aggregate()](https://mongoosejs.com/docs/api/model.html#Model.aggregate()) instead.\n *\n * #### Example:\n *\n *     const aggregate = Model.aggregate([\n *       { $project: { a: 1, b: 1 } },\n *       { $skip: 5 }\n *     ]);\n *\n *     Model.\n *       aggregate([{ $match: { age: { $gte: 21 }}}]).\n *       unwind('tags').\n *       exec();\n *\n * #### Note:\n *\n * - The documents returned are plain javascript objects, not mongoose documents (since any shape of document can be returned).\n * - Mongoose does **not** cast pipeline stages. The below will **not** work unless `_id` is a string in the database\n *\n *     new Aggregate([{ $match: { _id: '00000000000000000000000a' } }]);\n *     // Do this instead to cast to an ObjectId\n *     new Aggregate([{ $match: { _id: new mongoose.Types.ObjectId('00000000000000000000000a') } }]);\n *\n * @see MongoDB https://www.mongodb.com/docs/manual/applications/aggregation/\n * @see driver https://mongodb.github.io/node-mongodb-native/4.9/classes/Collection.html#aggregate\n * @param {Array} [pipeline] aggregation pipeline as an array of objects\n * @param {Model} [model] the model to use with this aggregate.\n * @api public\n */\n\nfunction Aggregate(pipeline, model) {\n  this._pipeline = [];\n  this._model = model;\n  this.options = {};\n\n  if (arguments.length === 1 && Array.isArray(pipeline)) {\n    this.append.apply(this, pipeline);\n  }\n}\n\n/**\n * Contains options passed down to the [aggregate command](https://www.mongodb.com/docs/manual/reference/command/aggregate/).\n * Supported options are:\n *\n * - [`allowDiskUse`](https://mongoosejs.com/docs/api/aggregate.html#Aggregate.prototype.allowDiskUse())\n * - `bypassDocumentValidation`\n * - [`collation`](https://mongoosejs.com/docs/api/aggregate.html#Aggregate.prototype.collation())\n * - `comment`\n * - [`cursor`](https://mongoosejs.com/docs/api/aggregate.html#Aggregate.prototype.cursor())\n * - [`explain`](https://mongoosejs.com/docs/api/aggregate.html#Aggregate.prototype.explain())\n * - `fieldsAsRaw`\n * - [`hint`](https://mongoosejs.com/docs/api/aggregate.html#Aggregate.prototype.hint())\n * - `let`\n * - `maxTimeMS`\n * - `raw`\n * - [`readConcern`](https://mongoosejs.com/docs/api/aggregate.html#Aggregate.prototype.readConcern())\n * - `readPreference`\n * - [`session`](https://mongoosejs.com/docs/api/aggregate.html#Aggregate.prototype.session())\n * - `writeConcern`\n *\n * @property options\n * @memberOf Aggregate\n * @api public\n */\n\nAggregate.prototype.options;\n\n/**\n * Get/set the model that this aggregation will execute on.\n *\n * #### Example:\n *\n *     const aggregate = MyModel.aggregate([{ $match: { answer: 42 } }]);\n *     aggregate.model() === MyModel; // true\n *\n *     // Change the model. There's rarely any reason to do this.\n *     aggregate.model(SomeOtherModel);\n *     aggregate.model() === SomeOtherModel; // true\n *\n * @param {Model} [model] Set the model associated with this aggregate. If not provided, returns the already stored model.\n * @return {Model}\n * @api public\n */\n\nAggregate.prototype.model = function(model) {\n  if (arguments.length === 0) {\n    return this._model;\n  }\n\n  this._model = model;\n  if (model.schema != null) {\n    if (this.options.readPreference == null &&\n      model.schema.options.read != null) {\n      this.options.readPreference = model.schema.options.read;\n    }\n    if (this.options.collation == null &&\n      model.schema.options.collation != null) {\n      this.options.collation = model.schema.options.collation;\n    }\n  }\n\n  return model;\n};\n\n/**\n * Appends new operators to this aggregate pipeline\n *\n * #### Example:\n *\n *     aggregate.append({ $project: { field: 1 }}, { $limit: 2 });\n *\n *     // or pass an array\n *     const pipeline = [{ $match: { daw: 'Logic Audio X' }} ];\n *     aggregate.append(pipeline);\n *\n * @param {...Object|Object[]} ops operator(s) to append. Can either be a spread of objects or a single parameter of a object array.\n * @return {Aggregate}\n * @api public\n */\n\nAggregate.prototype.append = function() {\n  const args = (arguments.length === 1 && Array.isArray(arguments[0]))\n    ? arguments[0]\n    : [...arguments];\n\n  if (!args.every(isOperator)) {\n    throw new Error('Arguments must be aggregate pipeline operators');\n  }\n\n  this._pipeline = this._pipeline.concat(args);\n\n  return this;\n};\n\n/**\n * Appends a new $addFields operator to this aggregate pipeline.\n * Requires MongoDB v3.4+ to work\n *\n * #### Example:\n *\n *     // adding new fields based on existing fields\n *     aggregate.addFields({\n *         newField: '$b.nested'\n *       , plusTen: { $add: ['$val', 10]}\n *       , sub: {\n *            name: '$a'\n *         }\n *     })\n *\n *     // etc\n *     aggregate.addFields({ salary_k: { $divide: [ \"$salary\", 1000 ] } });\n *\n * @param {Object} arg field specification\n * @see $addFields https://www.mongodb.com/docs/manual/reference/operator/aggregation/addFields/\n * @return {Aggregate}\n * @api public\n */\nAggregate.prototype.addFields = function(arg) {\n  if (typeof arg !== 'object' || arg === null || Array.isArray(arg)) {\n    throw new Error('Invalid addFields() argument. Must be an object');\n  }\n  return this.append({ $addFields: Object.assign({}, arg) });\n};\n\n/**\n * Appends a new $project operator to this aggregate pipeline.\n *\n * Mongoose query [selection syntax](https://mongoosejs.com/docs/api/query.html#Query.prototype.select()) is also supported.\n *\n * #### Example:\n *\n *     // include a, include b, exclude _id\n *     aggregate.project(\"a b -_id\");\n *\n *     // or you may use object notation, useful when\n *     // you have keys already prefixed with a \"-\"\n *     aggregate.project({a: 1, b: 1, _id: 0});\n *\n *     // reshaping documents\n *     aggregate.project({\n *         newField: '$b.nested'\n *       , plusTen: { $add: ['$val', 10]}\n *       , sub: {\n *            name: '$a'\n *         }\n *     })\n *\n *     // etc\n *     aggregate.project({ salary_k: { $divide: [ \"$salary\", 1000 ] } });\n *\n * @param {Object|String} arg field specification\n * @see projection https://www.mongodb.com/docs/manual/reference/aggregation/project/\n * @return {Aggregate}\n * @api public\n */\n\nAggregate.prototype.project = function(arg) {\n  const fields = {};\n\n  if (typeof arg === 'object' && !Array.isArray(arg)) {\n    Object.keys(arg).forEach(function(field) {\n      fields[field] = arg[field];\n    });\n  } else if (arguments.length === 1 && typeof arg === 'string') {\n    arg.split(/\\s+/).forEach(function(field) {\n      if (!field) {\n        return;\n      }\n      const include = field[0] === '-' ? 0 : 1;\n      if (include === 0) {\n        field = field.substring(1);\n      }\n      fields[field] = include;\n    });\n  } else {\n    throw new Error('Invalid project() argument. Must be string or object');\n  }\n\n  return this.append({ $project: fields });\n};\n\n/**\n * Appends a new custom $group operator to this aggregate pipeline.\n *\n * #### Example:\n *\n *     aggregate.group({ _id: \"$department\" });\n *\n * @see $group https://www.mongodb.com/docs/manual/reference/aggregation/group/\n * @method group\n * @memberOf Aggregate\n * @instance\n * @param {Object} arg $group operator contents\n * @return {Aggregate}\n * @api public\n */\n\n/**\n * Appends a new custom $match operator to this aggregate pipeline.\n *\n * #### Example:\n *\n *     aggregate.match({ department: { $in: [ \"sales\", \"engineering\" ] } });\n *\n * @see $match https://www.mongodb.com/docs/manual/reference/aggregation/match/\n * @method match\n * @memberOf Aggregate\n * @instance\n * @param {Object} arg $match operator contents\n * @return {Aggregate}\n * @api public\n */\n\n/**\n * Appends a new $skip operator to this aggregate pipeline.\n *\n * #### Example:\n *\n *     aggregate.skip(10);\n *\n * @see $skip https://www.mongodb.com/docs/manual/reference/aggregation/skip/\n * @method skip\n * @memberOf Aggregate\n * @instance\n * @param {Number} num number of records to skip before next stage\n * @return {Aggregate}\n * @api public\n */\n\n/**\n * Appends a new $limit operator to this aggregate pipeline.\n *\n * #### Example:\n *\n *     aggregate.limit(10);\n *\n * @see $limit https://www.mongodb.com/docs/manual/reference/aggregation/limit/\n * @method limit\n * @memberOf Aggregate\n * @instance\n * @param {Number} num maximum number of records to pass to the next stage\n * @return {Aggregate}\n * @api public\n */\n\n\n/**\n * Appends a new $densify operator to this aggregate pipeline.\n *\n * #### Example:\n *\n *      aggregate.densify({\n *        field: 'timestamp',\n *        range: {\n *          step: 1,\n *          unit: 'hour',\n *          bounds: [new Date('2021-05-18T00:00:00.000Z'), new Date('2021-05-18T08:00:00.000Z')]\n *        }\n *      });\n *\n * @see $densify https://www.mongodb.com/docs/manual/reference/operator/aggregation/densify/\n * @method densify\n * @memberOf Aggregate\n * @instance\n * @param {Object} arg $densify operator contents\n * @return {Aggregate}\n * @api public\n */\n\n/**\n * Appends a new $fill operator to this aggregate pipeline.\n *\n * #### Example:\n *\n *      aggregate.fill({\n *        output: {\n *          bootsSold: { value: 0 },\n *          sandalsSold: { value: 0 },\n *          sneakersSold: { value: 0 }\n *        }\n *      });\n *\n * @see $fill https://www.mongodb.com/docs/manual/reference/operator/aggregation/fill/\n * @method fill\n * @memberOf Aggregate\n * @instance\n * @param {Object} arg $fill operator contents\n * @return {Aggregate}\n * @api public\n */\n\n/**\n * Appends a new $geoNear operator to this aggregate pipeline.\n *\n * #### Note:\n *\n * **MUST** be used as the first operator in the pipeline.\n *\n * #### Example:\n *\n *     aggregate.near({\n *       near: { type: 'Point', coordinates: [40.724, -73.997] },\n *       distanceField: \"dist.calculated\", // required\n *       maxDistance: 0.008,\n *       query: { type: \"public\" },\n *       includeLocs: \"dist.location\",\n *       spherical: true,\n *     });\n *\n * @see $geoNear https://www.mongodb.com/docs/manual/reference/aggregation/geoNear/\n * @method near\n * @memberOf Aggregate\n * @instance\n * @param {Object} arg\n * @return {Aggregate}\n * @api public\n */\n\nAggregate.prototype.near = function(arg) {\n  const op = {};\n  op.$geoNear = arg;\n  return this.append(op);\n};\n\n/*!\n * define methods\n */\n\n'group match skip limit out densify fill'.split(' ').forEach(function($operator) {\n  Aggregate.prototype[$operator] = function(arg) {\n    const op = {};\n    op['$' + $operator] = arg;\n    return this.append(op);\n  };\n});\n\n/**\n * Appends new custom $unwind operator(s) to this aggregate pipeline.\n *\n * Note that the `$unwind` operator requires the path name to start with '$'.\n * Mongoose will prepend '$' if the specified field doesn't start '$'.\n *\n * #### Example:\n *\n *     aggregate.unwind(\"tags\");\n *     aggregate.unwind(\"a\", \"b\", \"c\");\n *     aggregate.unwind({ path: '$tags', preserveNullAndEmptyArrays: true });\n *\n * @see $unwind https://www.mongodb.com/docs/manual/reference/aggregation/unwind/\n * @param {String|Object|String[]|Object[]} fields the field(s) to unwind, either as field names or as [objects with options](https://www.mongodb.com/docs/manual/reference/operator/aggregation/unwind/#document-operand-with-options). If passing a string, prefixing the field name with '$' is optional. If passing an object, `path` must start with '$'.\n * @return {Aggregate}\n * @api public\n */\n\nAggregate.prototype.unwind = function() {\n  const args = [...arguments];\n\n  const res = [];\n  for (const arg of args) {\n    if (arg && typeof arg === 'object') {\n      res.push({ $unwind: arg });\n    } else if (typeof arg === 'string') {\n      res.push({\n        $unwind: (arg[0] === '$') ? arg : '$' + arg\n      });\n    } else {\n      throw new Error('Invalid arg \"' + arg + '\" to unwind(), ' +\n        'must be string or object');\n    }\n  }\n\n  return this.append.apply(this, res);\n};\n\n/**\n * Appends a new $replaceRoot operator to this aggregate pipeline.\n *\n * Note that the `$replaceRoot` operator requires field strings to start with '$'.\n * If you are passing in a string Mongoose will prepend '$' if the specified field doesn't start '$'.\n * If you are passing in an object the strings in your expression will not be altered.\n *\n * #### Example:\n *\n *     aggregate.replaceRoot(\"user\");\n *\n *     aggregate.replaceRoot({ x: { $concat: ['$this', '$that'] } });\n *\n * @see $replaceRoot https://www.mongodb.com/docs/manual/reference/operator/aggregation/replaceRoot\n * @param {String|Object} newRoot the field or document which will become the new root document\n * @return {Aggregate}\n * @api public\n */\n\nAggregate.prototype.replaceRoot = function(newRoot) {\n  let ret;\n\n  if (typeof newRoot === 'string') {\n    ret = newRoot.startsWith('$') ? newRoot : '$' + newRoot;\n  } else {\n    ret = newRoot;\n  }\n\n  return this.append({\n    $replaceRoot: {\n      newRoot: ret\n    }\n  });\n};\n\n/**\n * Appends a new $count operator to this aggregate pipeline.\n *\n * #### Example:\n *\n *     aggregate.count(\"userCount\");\n *\n * @see $count https://www.mongodb.com/docs/manual/reference/operator/aggregation/count\n * @param {String} fieldName The name of the output field which has the count as its value. It must be a non-empty string, must not start with $ and must not contain the . character.\n * @return {Aggregate}\n * @api public\n */\n\nAggregate.prototype.count = function(fieldName) {\n  return this.append({ $count: fieldName });\n};\n\n/**\n * Appends a new $sortByCount operator to this aggregate pipeline. Accepts either a string field name\n * or a pipeline object.\n *\n * Note that the `$sortByCount` operator requires the new root to start with '$'.\n * Mongoose will prepend '$' if the specified field name doesn't start with '$'.\n *\n * #### Example:\n *\n *     aggregate.sortByCount('users');\n *     aggregate.sortByCount({ $mergeObjects: [ \"$employee\", \"$business\" ] })\n *\n * @see $sortByCount https://www.mongodb.com/docs/manual/reference/operator/aggregation/sortByCount/\n * @param {Object|String} arg\n * @return {Aggregate} this\n * @api public\n */\n\nAggregate.prototype.sortByCount = function(arg) {\n  if (arg && typeof arg === 'object') {\n    return this.append({ $sortByCount: arg });\n  } else if (typeof arg === 'string') {\n    return this.append({\n      $sortByCount: (arg[0] === '$') ? arg : '$' + arg\n    });\n  } else {\n    throw new TypeError('Invalid arg \"' + arg + '\" to sortByCount(), ' +\n      'must be string or object');\n  }\n};\n\n/**\n * Appends new custom $lookup operator to this aggregate pipeline.\n *\n * #### Example:\n *\n *     aggregate.lookup({ from: 'users', localField: 'userId', foreignField: '_id', as: 'users' });\n *\n * @see $lookup https://www.mongodb.com/docs/manual/reference/operator/aggregation/lookup/#pipe._S_lookup\n * @param {Object} options to $lookup as described in the above link\n * @return {Aggregate}\n * @api public\n */\n\nAggregate.prototype.lookup = function(options) {\n  return this.append({ $lookup: options });\n};\n\n/**\n * Appends new custom $graphLookup operator(s) to this aggregate pipeline, performing a recursive search on a collection.\n *\n * Note that graphLookup can only consume at most 100MB of memory, and does not allow disk use even if `{ allowDiskUse: true }` is specified.\n *\n * #### Example:\n *\n *      // Suppose we have a collection of courses, where a document might look like `{ _id: 0, name: 'Calculus', prerequisite: 'Trigonometry'}` and `{ _id: 0, name: 'Trigonometry', prerequisite: 'Algebra' }`\n *      aggregate.graphLookup({ from: 'courses', startWith: '$prerequisite', connectFromField: 'prerequisite', connectToField: 'name', as: 'prerequisites', maxDepth: 3 }) // this will recursively search the 'courses' collection up to 3 prerequisites\n *\n * @see $graphLookup https://www.mongodb.com/docs/manual/reference/operator/aggregation/graphLookup/#pipe._S_graphLookup\n * @param {Object} options to $graphLookup as described in the above link\n * @return {Aggregate}\n * @api public\n */\n\nAggregate.prototype.graphLookup = function(options) {\n  const cloneOptions = {};\n  if (options) {\n    if (!utils.isObject(options)) {\n      throw new TypeError('Invalid graphLookup() argument. Must be an object.');\n    }\n\n    utils.mergeClone(cloneOptions, options);\n    const startWith = cloneOptions.startWith;\n\n    if (startWith && typeof startWith === 'string') {\n      cloneOptions.startWith = cloneOptions.startWith.startsWith('$') ?\n        cloneOptions.startWith :\n        '$' + cloneOptions.startWith;\n    }\n\n  }\n  return this.append({ $graphLookup: cloneOptions });\n};\n\n/**\n * Appends new custom $sample operator to this aggregate pipeline.\n *\n * #### Example:\n *\n *     aggregate.sample(3); // Add a pipeline that picks 3 random documents\n *\n * @see $sample https://www.mongodb.com/docs/manual/reference/operator/aggregation/sample/#pipe._S_sample\n * @param {Number} size number of random documents to pick\n * @return {Aggregate}\n * @api public\n */\n\nAggregate.prototype.sample = function(size) {\n  return this.append({ $sample: { size: size } });\n};\n\n/**\n * Appends a new $sort operator to this aggregate pipeline.\n *\n * If an object is passed, values allowed are `asc`, `desc`, `ascending`, `descending`, `1`, and `-1`.\n *\n * If a string is passed, it must be a space delimited list of path names. The sort order of each path is ascending unless the path name is prefixed with `-` which will be treated as descending.\n *\n * #### Example:\n *\n *     // these are equivalent\n *     aggregate.sort({ field: 'asc', test: -1 });\n *     aggregate.sort('field -test');\n *\n * @see $sort https://www.mongodb.com/docs/manual/reference/aggregation/sort/\n * @param {Object|String} arg\n * @return {Aggregate} this\n * @api public\n */\n\nAggregate.prototype.sort = function(arg) {\n  // TODO refactor to reuse the query builder logic\n\n  const sort = {};\n\n  if (getConstructorName(arg) === 'Object') {\n    const desc = ['desc', 'descending', -1];\n    Object.keys(arg).forEach(function(field) {\n      // If sorting by text score, skip coercing into 1/-1\n      if (arg[field] instanceof Object && arg[field].$meta) {\n        sort[field] = arg[field];\n        return;\n      }\n      sort[field] = desc.indexOf(arg[field]) === -1 ? 1 : -1;\n    });\n  } else if (arguments.length === 1 && typeof arg === 'string') {\n    arg.split(/\\s+/).forEach(function(field) {\n      if (!field) {\n        return;\n      }\n      const ascend = field[0] === '-' ? -1 : 1;\n      if (ascend === -1) {\n        field = field.substring(1);\n      }\n      sort[field] = ascend;\n    });\n  } else {\n    throw new TypeError('Invalid sort() argument. Must be a string or object.');\n  }\n\n  return this.append({ $sort: sort });\n};\n\n/**\n * Appends new $unionWith operator to this aggregate pipeline.\n *\n * #### Example:\n *\n *     aggregate.unionWith({ coll: 'users', pipeline: [ { $match: { _id: 1 } } ] });\n *\n * @see $unionWith https://www.mongodb.com/docs/manual/reference/operator/aggregation/unionWith\n * @param {Object} options to $unionWith query as described in the above link\n * @return {Aggregate}\n * @api public\n */\n\nAggregate.prototype.unionWith = function(options) {\n  return this.append({ $unionWith: options });\n};\n\n\n/**\n * Sets the readPreference option for the aggregation query.\n *\n * #### Example:\n *\n *     await Model.aggregate(pipeline).read('primaryPreferred');\n *\n * @param {String|ReadPreference} pref one of the listed preference options or their aliases\n * @param {Array} [tags] optional tags for this query.\n * @return {Aggregate} this\n * @api public\n * @see mongodb https://www.mongodb.com/docs/manual/applications/replication/#read-preference\n */\n\nAggregate.prototype.read = function(pref, tags) {\n  read.call(this, pref, tags);\n  return this;\n};\n\n/**\n * Sets the readConcern level for the aggregation query.\n *\n * #### Example:\n *\n *     await Model.aggregate(pipeline).readConcern('majority');\n *\n * @param {String} level one of the listed read concern level or their aliases\n * @see mongodb https://www.mongodb.com/docs/manual/reference/read-concern/\n * @return {Aggregate} this\n * @api public\n */\n\nAggregate.prototype.readConcern = function(level) {\n  readConcern.call(this, level);\n  return this;\n};\n\n/**\n * Appends a new $redact operator to this aggregate pipeline.\n *\n * If 3 arguments are supplied, Mongoose will wrap them with if-then-else of $cond operator respectively\n * If `thenExpr` or `elseExpr` is string, make sure it starts with $$, like `$$DESCEND`, `$$PRUNE` or `$$KEEP`.\n *\n * #### Example:\n *\n *     await Model.aggregate(pipeline).redact({\n *       $cond: {\n *         if: { $eq: [ '$level', 5 ] },\n *         then: '$$PRUNE',\n *         else: '$$DESCEND'\n *       }\n *     });\n *\n *     // $redact often comes with $cond operator, you can also use the following syntax provided by mongoose\n *     await Model.aggregate(pipeline).redact({ $eq: [ '$level', 5 ] }, '$$PRUNE', '$$DESCEND');\n *\n * @param {Object} expression redact options or conditional expression\n * @param {String|Object} [thenExpr] true case for the condition\n * @param {String|Object} [elseExpr] false case for the condition\n * @return {Aggregate} this\n * @see $redact https://www.mongodb.com/docs/manual/reference/operator/aggregation/redact/\n * @api public\n */\n\nAggregate.prototype.redact = function(expression, thenExpr, elseExpr) {\n  if (arguments.length === 3) {\n    if ((typeof thenExpr === 'string' && !validRedactStringValues.has(thenExpr)) ||\n      (typeof elseExpr === 'string' && !validRedactStringValues.has(elseExpr))) {\n      throw new Error('If thenExpr or elseExpr is string, it must be either $$DESCEND, $$PRUNE or $$KEEP');\n    }\n\n    expression = {\n      $cond: {\n        if: expression,\n        then: thenExpr,\n        else: elseExpr\n      }\n    };\n  } else if (arguments.length !== 1) {\n    throw new TypeError('Invalid arguments');\n  }\n\n  return this.append({ $redact: expression });\n};\n\n/**\n * Execute the aggregation with explain\n *\n * #### Example:\n *\n *     Model.aggregate(..).explain()\n *\n * @param {String} [verbosity]\n * @return {Promise}\n */\n\nAggregate.prototype.explain = async function explain(verbosity) {\n  if (typeof verbosity === 'function' || typeof arguments[1] === 'function') {\n    throw new MongooseError('Aggregate.prototype.explain() no longer accepts a callback');\n  }\n  const model = this._model;\n\n  if (!this._pipeline.length) {\n    throw new Error('Aggregate has empty pipeline');\n  }\n\n  prepareDiscriminatorPipeline(this._pipeline, this._model.schema);\n\n  await new Promise((resolve, reject) => {\n    model.hooks.execPre('aggregate', this, error => {\n      if (error) {\n        const _opts = { error: error };\n        return model.hooks.execPost('aggregate', this, [null], _opts, error => {\n          reject(error);\n        });\n      } else {\n        resolve();\n      }\n    });\n  });\n\n  const cursor = model.collection.aggregate(this._pipeline, this.options);\n\n  if (verbosity == null) {\n    verbosity = true;\n  }\n\n  let result = null;\n  try {\n    result = await cursor.explain(verbosity);\n  } catch (error) {\n    await new Promise((resolve, reject) => {\n      const _opts = { error: error };\n      model.hooks.execPost('aggregate', this, [null], _opts, error => {\n        if (error) {\n          return reject(error);\n        }\n        return resolve();\n      });\n    });\n  }\n\n  const _opts = { error: null };\n  await new Promise((resolve, reject) => {\n    model.hooks.execPost('aggregate', this, [result], _opts, error => {\n      if (error) {\n        return reject(error);\n      }\n      return resolve();\n    });\n  });\n\n  return result;\n};\n\n/**\n * Sets the allowDiskUse option for the aggregation query\n *\n * #### Example:\n *\n *     await Model.aggregate([{ $match: { foo: 'bar' } }]).allowDiskUse(true);\n *\n * @param {Boolean} value Should tell server it can use hard drive to store data during aggregation.\n * @return {Aggregate} this\n * @see mongodb https://www.mongodb.com/docs/manual/reference/command/aggregate/\n */\n\nAggregate.prototype.allowDiskUse = function(value) {\n  this.options.allowDiskUse = value;\n  return this;\n};\n\n/**\n * Sets the hint option for the aggregation query\n *\n * #### Example:\n *\n *     Model.aggregate(..).hint({ qty: 1, category: 1 }).exec();\n *\n * @param {Object|String} value a hint object or the index name\n * @return {Aggregate} this\n * @see mongodb https://www.mongodb.com/docs/manual/reference/command/aggregate/\n */\n\nAggregate.prototype.hint = function(value) {\n  this.options.hint = value;\n  return this;\n};\n\n/**\n * Sets the session for this aggregation. Useful for [transactions](https://mongoosejs.com/docs/transactions.html).\n *\n * #### Example:\n *\n *     const session = await Model.startSession();\n *     await Model.aggregate(..).session(session);\n *\n * @param {ClientSession} session\n * @return {Aggregate} this\n * @see mongodb https://www.mongodb.com/docs/manual/reference/command/aggregate/\n */\n\nAggregate.prototype.session = function(session) {\n  if (session == null) {\n    delete this.options.session;\n  } else {\n    this.options.session = session;\n  }\n  return this;\n};\n\n/**\n * Lets you set arbitrary options, for middleware or plugins.\n *\n * #### Example:\n *\n *     const agg = Model.aggregate(..).option({ allowDiskUse: true }); // Set the `allowDiskUse` option\n *     agg.options; // `{ allowDiskUse: true }`\n *\n * @param {Object} options keys to merge into current options\n * @param {Number} [options.maxTimeMS] number limits the time this aggregation will run, see [MongoDB docs on `maxTimeMS`](https://www.mongodb.com/docs/manual/reference/operator/meta/maxTimeMS/)\n * @param {Boolean} [options.allowDiskUse] boolean if true, the MongoDB server will use the hard drive to store data during this aggregation\n * @param {Object} [options.collation] object see [`Aggregate.prototype.collation()`](https://mongoosejs.com/docs/api/aggregate.html#Aggregate.prototype.collation())\n * @param {ClientSession} [options.session] ClientSession see [`Aggregate.prototype.session()`](https://mongoosejs.com/docs/api/aggregate.html#Aggregate.prototype.session())\n * @see mongodb https://www.mongodb.com/docs/manual/reference/command/aggregate/\n * @return {Aggregate} this\n * @api public\n */\n\nAggregate.prototype.option = function(value) {\n  for (const key in value) {\n    this.options[key] = value[key];\n  }\n  return this;\n};\n\n/**\n * Sets the `cursor` option and executes this aggregation, returning an aggregation cursor.\n * Cursors are useful if you want to process the results of the aggregation one-at-a-time\n * because the aggregation result is too big to fit into memory.\n *\n * #### Example:\n *\n *     const cursor = Model.aggregate(..).cursor({ batchSize: 1000 });\n *     cursor.eachAsync(function(doc, i) {\n *       // use doc\n *     });\n *\n * @param {Object} options\n * @param {Number} [options.batchSize] set the cursor batch size\n * @param {Boolean} [options.useMongooseAggCursor] use experimental mongoose-specific aggregation cursor (for `eachAsync()` and other query cursor semantics)\n * @return {AggregationCursor} cursor representing this aggregation\n * @api public\n * @see mongodb https://mongodb.github.io/node-mongodb-native/4.9/classes/AggregationCursor.html\n */\n\nAggregate.prototype.cursor = function(options) {\n  this.options.cursor = options || {};\n  return new AggregationCursor(this); // return this;\n};\n\n/**\n * Adds a collation\n *\n * #### Example:\n *\n *     const res = await Model.aggregate(pipeline).collation({ locale: 'en_US', strength: 1 });\n *\n * @param {Object} collation options\n * @return {Aggregate} this\n * @api public\n * @see mongodb https://mongodb.github.io/node-mongodb-native/4.9/interfaces/CollationOptions.html\n */\n\nAggregate.prototype.collation = function(collation) {\n  this.options.collation = collation;\n  return this;\n};\n\n/**\n * Combines multiple aggregation pipelines.\n *\n * #### Example:\n *\n *     const res = await Model.aggregate().facet({\n *       books: [{ groupBy: '$author' }],\n *       price: [{ $bucketAuto: { groupBy: '$price', buckets: 2 } }]\n *     });\n *\n *     // Output: { books: [...], price: [{...}, {...}] }\n *\n * @param {Object} facet options\n * @return {Aggregate} this\n * @see $facet https://www.mongodb.com/docs/manual/reference/operator/aggregation/facet/\n * @api public\n */\n\nAggregate.prototype.facet = function(options) {\n  return this.append({ $facet: options });\n};\n\n/**\n * Helper for [Atlas Text Search](https://www.mongodb.com/docs/atlas/atlas-search/tutorial/)'s\n * `$search` stage.\n *\n * #### Example:\n *\n *     const res = await Model.aggregate().\n *      search({\n *        text: {\n *          query: 'baseball',\n *          path: 'plot'\n *        }\n *      });\n *\n *     // Output: [{ plot: '...', title: '...' }]\n *\n * @param {Object} $search options\n * @return {Aggregate} this\n * @see $search https://www.mongodb.com/docs/atlas/atlas-search/tutorial/\n * @api public\n */\n\nAggregate.prototype.search = function(options) {\n  return this.append({ $search: options });\n};\n\n/**\n * Returns the current pipeline\n *\n * #### Example:\n *\n *     MyModel.aggregate().match({ test: 1 }).pipeline(); // [{ $match: { test: 1 } }]\n *\n * @return {Array} The current pipeline similar to the operation that will be executed\n * @api public\n */\n\nAggregate.prototype.pipeline = function() {\n  return this._pipeline;\n};\n\n/**\n * Executes the aggregate pipeline on the currently bound Model.\n *\n * #### Example:\n *     const result = await aggregate.exec();\n *\n * @return {Promise}\n * @api public\n */\n\nAggregate.prototype.exec = async function exec() {\n  if (!this._model) {\n    throw new Error('Aggregate not bound to any Model');\n  }\n  if (typeof arguments[0] === 'function') {\n    throw new MongooseError('Aggregate.prototype.exec() no longer accepts a callback');\n  }\n  const model = this._model;\n  const collection = this._model.collection;\n\n  applyGlobalMaxTimeMS(this.options, model.db.options, model.base.options);\n  applyGlobalDiskUse(this.options, model.db.options, model.base.options);\n\n  if (this.options && this.options.cursor) {\n    return new AggregationCursor(this);\n  }\n\n  prepareDiscriminatorPipeline(this._pipeline, this._model.schema);\n  stringifyFunctionOperators(this._pipeline);\n\n  await new Promise((resolve, reject) => {\n    model.hooks.execPre('aggregate', this, error => {\n      if (error) {\n        const _opts = { error: error };\n        return model.hooks.execPost('aggregate', this, [null], _opts, error => {\n          reject(error);\n        });\n      } else {\n        resolve();\n      }\n    });\n  });\n\n  if (!this._pipeline.length) {\n    throw new MongooseError('Aggregate has empty pipeline');\n  }\n\n  const options = clone(this.options || {});\n  let result;\n  try {\n    const cursor = await collection.aggregate(this._pipeline, options);\n    result = await cursor.toArray();\n  } catch (error) {\n    await new Promise((resolve, reject) => {\n      const _opts = { error: error };\n      model.hooks.execPost('aggregate', this, [null], _opts, (error) => {\n        if (error) {\n          return reject(error);\n        }\n\n        resolve();\n      });\n    });\n  }\n\n  const _opts = { error: null };\n  await new Promise((resolve, reject) => {\n    model.hooks.execPost('aggregate', this, [result], _opts, error => {\n      if (error) {\n        return reject(error);\n      }\n      return resolve();\n    });\n  });\n\n  return result;\n};\n\n/**\n * Provides a Promise-like `then` function, which will call `.exec` without a callback\n * Compatible with `await`.\n *\n * #### Example:\n *\n *     Model.aggregate(..).then(successCallback, errorCallback);\n *\n * @param {Function} [resolve] successCallback\n * @param {Function} [reject]  errorCallback\n * @return {Promise}\n */\nAggregate.prototype.then = function(resolve, reject) {\n  return this.exec().then(resolve, reject);\n};\n\n/**\n * Executes the aggregation returning a `Promise` which will be\n * resolved with either the doc(s) or rejected with the error.\n * Like [`.then()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.then), but only takes a rejection handler.\n * Compatible with `await`.\n *\n * @param {Function} [reject]\n * @return {Promise}\n * @api public\n */\n\nAggregate.prototype.catch = function(reject) {\n  return this.exec().then(null, reject);\n};\n\n/**\n * Executes the aggregate returning a `Promise` which will be\n * resolved with `.finally()` chained.\n *\n * More about [Promise `finally()` in JavaScript](https://thecodebarbarian.com/using-promise-finally-in-node-js.html).\n *\n * @param {Function} [onFinally]\n * @return {Promise}\n * @api public\n */\n\nAggregate.prototype.finally = function(onFinally) {\n  return this.exec().finally(onFinally);\n};\n\n/**\n * Returns an asyncIterator for use with [`for/await/of` loops](https://thecodebarbarian.com/getting-started-with-async-iterators-in-node-js)\n * You do not need to call this function explicitly, the JavaScript runtime\n * will call it for you.\n *\n * #### Example:\n *\n *     const agg = Model.aggregate([{ $match: { age: { $gte: 25 } } }]);\n *     for await (const doc of agg) {\n *       console.log(doc.name);\n *     }\n *\n * Node.js 10.x supports async iterators natively without any flags. You can\n * enable async iterators in Node.js 8.x using the [`--harmony_async_iteration` flag](https://github.com/tc39/proposal-async-iteration/issues/117#issuecomment-346695187).\n *\n * **Note:** This function is not set if `Symbol.asyncIterator` is undefined. If\n * `Symbol.asyncIterator` is undefined, that means your Node.js version does not\n * support async iterators.\n *\n * @method [Symbol.asyncIterator]\n * @memberOf Aggregate\n * @instance\n * @api public\n */\n\nif (Symbol.asyncIterator != null) {\n  Aggregate.prototype[Symbol.asyncIterator] = function() {\n    return this.cursor({ useMongooseAggCursor: true }).transformNull()._transformForAsyncIterator();\n  };\n}\n\n/*!\n * Helpers\n */\n\n/**\n * Checks whether an object is likely a pipeline operator\n *\n * @param {Object} obj object to check\n * @return {Boolean}\n * @api private\n */\n\nfunction isOperator(obj) {\n  if (typeof obj !== 'object' || obj === null) {\n    return false;\n  }\n\n  const k = Object.keys(obj);\n\n  return k.length === 1 && k[0][0] === '$';\n}\n\n/**\n * Adds the appropriate `$match` pipeline step to the top of an aggregate's\n * pipeline, should it's model is a non-root discriminator type. This is\n * analogous to the `prepareDiscriminatorCriteria` function in `lib/query.js`.\n *\n * @param {Aggregate} aggregate Aggregate to prepare\n * @api private\n */\n\nAggregate._prepareDiscriminatorPipeline = prepareDiscriminatorPipeline;\n\n/*!\n * Exports\n */\n\nmodule.exports = Aggregate;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvYWdncmVnYXRlLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0E7QUFDQTs7QUFFQSwwQkFBMEIsbUJBQU8sQ0FBQyxtR0FBNEI7QUFDOUQsc0JBQXNCLG1CQUFPLENBQUMseUZBQXVCO0FBQ3JELGNBQWMsbUJBQU8sQ0FBQyw2REFBUztBQUMvQixRQUFRLDJDQUEyQyxFQUFFLG1CQUFPLENBQUMsaUhBQW1DO0FBQ2hHLGNBQWMsbUJBQU8sQ0FBQyw2RUFBaUI7QUFDdkMsMkJBQTJCLG1CQUFPLENBQUMsdUdBQThCO0FBQ2pFLHFDQUFxQyxtQkFBTyxDQUFDLCtJQUFrRDtBQUMvRixtQ0FBbUMsbUJBQU8sQ0FBQywySUFBZ0Q7QUFDM0YsY0FBYyxtQkFBTyxDQUFDLDZEQUFTO0FBQy9CO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFlBQVksY0FBYztBQUNyQyxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLFVBQVUsT0FBTyxZQUFZO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsVUFBVSxtQ0FBbUM7QUFDckU7QUFDQSx3QkFBd0IsVUFBVSxnRUFBZ0U7QUFDbEc7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLFVBQVUsY0FBYztBQUN0RSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLFlBQVksV0FBVyxJQUFJLFdBQVc7QUFDaEU7QUFDQTtBQUNBLDJCQUEyQixVQUFVLHdCQUF3QjtBQUM3RDtBQUNBO0FBQ0EsV0FBVyxvQkFBb0I7QUFDL0IsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsNkJBQTZCLFlBQVksZ0NBQWdDO0FBQ3pFO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qiw0QkFBNEIsUUFBUTtBQUMzRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsbUJBQW1CO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsMkJBQTJCLFlBQVksZ0NBQWdDO0FBQ3ZFO0FBQ0EsV0FBVyxlQUFlO0FBQzFCO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJO0FBQ0o7QUFDQTs7QUFFQSx1QkFBdUIsa0JBQWtCO0FBQ3pDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsb0JBQW9CO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixjQUFjLG1DQUFtQztBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZO0FBQ1o7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsVUFBVTtBQUNuQywyQkFBMkIsVUFBVTtBQUNyQyw0QkFBNEI7QUFDNUI7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQiwrQ0FBK0M7QUFDaEU7QUFDQTtBQUNBLGtCQUFrQixnQkFBZ0I7QUFDbEM7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsaURBQWlEO0FBQzNFO0FBQ0E7QUFDQSxXQUFXLGlDQUFpQztBQUM1QyxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixjQUFjO0FBQy9CLE1BQU07QUFDTjtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsS0FBSywrQkFBK0I7QUFDbkU7QUFDQTtBQUNBLFdBQVcsZUFBZTtBQUMxQixZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0EsdUJBQXVCLG1CQUFtQjtBQUMxQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQiw2Q0FBNkM7QUFDNUU7QUFDQTtBQUNBLFdBQVcsZUFBZTtBQUMxQixZQUFZLFdBQVc7QUFDdkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0EseUJBQXlCLG1CQUFtQjtBQUM1QyxJQUFJO0FBQ0o7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQix1RUFBdUU7QUFDakc7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBLHVCQUF1QixrQkFBa0I7QUFDekM7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMEdBQTBHLG9CQUFvQjtBQUM5SDtBQUNBO0FBQ0E7QUFDQSx3RkFBd0YsdURBQXVELFNBQVMsdURBQXVEO0FBQy9NLGdDQUFnQyx5SUFBeUk7QUFDeks7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsdUJBQXVCLDRCQUE0QjtBQUNuRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQSx1QkFBdUIsV0FBVyxjQUFjO0FBQ2hEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHdCQUF3QjtBQUNoRDtBQUNBO0FBQ0E7QUFDQSxXQUFXLGVBQWU7QUFDMUIsWUFBWSxXQUFXO0FBQ3ZCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJO0FBQ0o7QUFDQTs7QUFFQSx1QkFBdUIsYUFBYTtBQUNwQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLDZCQUE2QixVQUFVLFdBQVcsR0FBRztBQUNsRjtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0EsdUJBQXVCLHFCQUFxQjtBQUM1Qzs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHVCQUF1QjtBQUNsQyxXQUFXLE9BQU87QUFDbEIsWUFBWSxXQUFXO0FBQ3ZCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBLFlBQVksV0FBVztBQUN2QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLHNCQUFzQjtBQUN2QztBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLGdEQUFnRCxzQkFBc0I7QUFDdEU7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxlQUFlO0FBQzFCLFdBQVcsZUFBZTtBQUMxQixZQUFZLFdBQVc7QUFDdkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBLHVCQUF1QixxQkFBcUI7QUFDNUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsWUFBWTtBQUNaOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0EsU0FBUztBQUNULFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDs7QUFFQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLFVBQVUsY0FBYztBQUN4RDtBQUNBLFdBQVcsU0FBUztBQUNwQixZQUFZLFdBQVc7QUFDdkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLHFCQUFxQjtBQUN2RDtBQUNBLFdBQVcsZUFBZTtBQUMxQixZQUFZLFdBQVc7QUFDdkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxlQUFlO0FBQzFCLFlBQVksV0FBVztBQUN2QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELG9CQUFvQixHQUFHO0FBQ3ZFLG9CQUFvQixNQUFNLG9CQUFvQjtBQUM5QztBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsUUFBUTtBQUNuQixXQUFXLGVBQWU7QUFDMUI7QUFDQSxZQUFZLFdBQVc7QUFDdkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsaUJBQWlCO0FBQ3BFO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsU0FBUztBQUNwQixZQUFZLG1CQUFtQjtBQUMvQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHNDQUFzQztBQUN0Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0RBQStELDhCQUE4QjtBQUM3RjtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZLFdBQVc7QUFDdkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixvQkFBb0I7QUFDdkMsbUJBQW1CLGVBQWUsaUNBQWlDO0FBQ25FLFFBQVE7QUFDUjtBQUNBLG9CQUFvQix1QkFBdUIsSUFBSSxHQUFHLElBQUk7QUFDdEQ7QUFDQSxXQUFXLFFBQVE7QUFDbkIsWUFBWSxXQUFXO0FBQ3ZCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVCQUF1QixpQkFBaUI7QUFDeEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EscUJBQXFCLDJCQUEyQjtBQUNoRDtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZLFdBQVc7QUFDdkI7QUFDQTtBQUNBOztBQUVBO0FBQ0EsdUJBQXVCLGtCQUFrQjtBQUN6Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLFNBQVMsY0FBYyxNQUFNLFVBQVUsV0FBVztBQUNyRjtBQUNBLFlBQVksT0FBTztBQUNuQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMOztBQUVBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFVBQVU7QUFDckIsV0FBVyxVQUFVO0FBQ3JCLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFVBQVU7QUFDckIsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsVUFBVTtBQUNyQixZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsVUFBVSxPQUFPLGNBQWM7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHlCQUF5Qiw0QkFBNEI7QUFDckQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsV0FBVztBQUN0QjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL2NsaWVudC8uLi9zZXJ2ZXIvbm9kZV9tb2R1bGVzL21vbmdvb3NlL2xpYi9hZ2dyZWdhdGUuanM/ZGU5NSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbi8qIVxuICogTW9kdWxlIGRlcGVuZGVuY2llc1xuICovXG5cbmNvbnN0IEFnZ3JlZ2F0aW9uQ3Vyc29yID0gcmVxdWlyZSgnLi9jdXJzb3IvYWdncmVnYXRpb25DdXJzb3InKTtcbmNvbnN0IE1vbmdvb3NlRXJyb3IgPSByZXF1aXJlKCcuL2Vycm9yL21vbmdvb3NlRXJyb3InKTtcbmNvbnN0IFF1ZXJ5ID0gcmVxdWlyZSgnLi9xdWVyeScpO1xuY29uc3QgeyBhcHBseUdsb2JhbE1heFRpbWVNUywgYXBwbHlHbG9iYWxEaXNrVXNlIH0gPSByZXF1aXJlKCcuL2hlbHBlcnMvcXVlcnkvYXBwbHlHbG9iYWxPcHRpb24nKTtcbmNvbnN0IGNsb25lID0gcmVxdWlyZSgnLi9oZWxwZXJzL2Nsb25lJyk7XG5jb25zdCBnZXRDb25zdHJ1Y3Rvck5hbWUgPSByZXF1aXJlKCcuL2hlbHBlcnMvZ2V0Q29uc3RydWN0b3JOYW1lJyk7XG5jb25zdCBwcmVwYXJlRGlzY3JpbWluYXRvclBpcGVsaW5lID0gcmVxdWlyZSgnLi9oZWxwZXJzL2FnZ3JlZ2F0ZS9wcmVwYXJlRGlzY3JpbWluYXRvclBpcGVsaW5lJyk7XG5jb25zdCBzdHJpbmdpZnlGdW5jdGlvbk9wZXJhdG9ycyA9IHJlcXVpcmUoJy4vaGVscGVycy9hZ2dyZWdhdGUvc3RyaW5naWZ5RnVuY3Rpb25PcGVyYXRvcnMnKTtcbmNvbnN0IHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xuY29uc3QgcmVhZCA9IFF1ZXJ5LnByb3RvdHlwZS5yZWFkO1xuY29uc3QgcmVhZENvbmNlcm4gPSBRdWVyeS5wcm90b3R5cGUucmVhZENvbmNlcm47XG5cbmNvbnN0IHZhbGlkUmVkYWN0U3RyaW5nVmFsdWVzID0gbmV3IFNldChbJyQkREVTQ0VORCcsICckJFBSVU5FJywgJyQkS0VFUCddKTtcblxuLyoqXG4gKiBBZ2dyZWdhdGUgY29uc3RydWN0b3IgdXNlZCBmb3IgYnVpbGRpbmcgYWdncmVnYXRpb24gcGlwZWxpbmVzLiBEbyBub3RcbiAqIGluc3RhbnRpYXRlIHRoaXMgY2xhc3MgZGlyZWN0bHksIHVzZSBbTW9kZWwuYWdncmVnYXRlKCldKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvbW9kZWwuaHRtbCNNb2RlbC5hZ2dyZWdhdGUoKSkgaW5zdGVhZC5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IGFnZ3JlZ2F0ZSA9IE1vZGVsLmFnZ3JlZ2F0ZShbXG4gKiAgICAgICB7ICRwcm9qZWN0OiB7IGE6IDEsIGI6IDEgfSB9LFxuICogICAgICAgeyAkc2tpcDogNSB9XG4gKiAgICAgXSk7XG4gKlxuICogICAgIE1vZGVsLlxuICogICAgICAgYWdncmVnYXRlKFt7ICRtYXRjaDogeyBhZ2U6IHsgJGd0ZTogMjEgfX19XSkuXG4gKiAgICAgICB1bndpbmQoJ3RhZ3MnKS5cbiAqICAgICAgIGV4ZWMoKTtcbiAqXG4gKiAjIyMjIE5vdGU6XG4gKlxuICogLSBUaGUgZG9jdW1lbnRzIHJldHVybmVkIGFyZSBwbGFpbiBqYXZhc2NyaXB0IG9iamVjdHMsIG5vdCBtb25nb29zZSBkb2N1bWVudHMgKHNpbmNlIGFueSBzaGFwZSBvZiBkb2N1bWVudCBjYW4gYmUgcmV0dXJuZWQpLlxuICogLSBNb25nb29zZSBkb2VzICoqbm90KiogY2FzdCBwaXBlbGluZSBzdGFnZXMuIFRoZSBiZWxvdyB3aWxsICoqbm90Kiogd29yayB1bmxlc3MgYF9pZGAgaXMgYSBzdHJpbmcgaW4gdGhlIGRhdGFiYXNlXG4gKlxuICogICAgIG5ldyBBZ2dyZWdhdGUoW3sgJG1hdGNoOiB7IF9pZDogJzAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwYScgfSB9XSk7XG4gKiAgICAgLy8gRG8gdGhpcyBpbnN0ZWFkIHRvIGNhc3QgdG8gYW4gT2JqZWN0SWRcbiAqICAgICBuZXcgQWdncmVnYXRlKFt7ICRtYXRjaDogeyBfaWQ6IG5ldyBtb25nb29zZS5UeXBlcy5PYmplY3RJZCgnMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDBhJykgfSB9XSk7XG4gKlxuICogQHNlZSBNb25nb0RCIGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvbWFudWFsL2FwcGxpY2F0aW9ucy9hZ2dyZWdhdGlvbi9cbiAqIEBzZWUgZHJpdmVyIGh0dHBzOi8vbW9uZ29kYi5naXRodWIuaW8vbm9kZS1tb25nb2RiLW5hdGl2ZS80LjkvY2xhc3Nlcy9Db2xsZWN0aW9uLmh0bWwjYWdncmVnYXRlXG4gKiBAcGFyYW0ge0FycmF5fSBbcGlwZWxpbmVdIGFnZ3JlZ2F0aW9uIHBpcGVsaW5lIGFzIGFuIGFycmF5IG9mIG9iamVjdHNcbiAqIEBwYXJhbSB7TW9kZWx9IFttb2RlbF0gdGhlIG1vZGVsIHRvIHVzZSB3aXRoIHRoaXMgYWdncmVnYXRlLlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBBZ2dyZWdhdGUocGlwZWxpbmUsIG1vZGVsKSB7XG4gIHRoaXMuX3BpcGVsaW5lID0gW107XG4gIHRoaXMuX21vZGVsID0gbW9kZWw7XG4gIHRoaXMub3B0aW9ucyA9IHt9O1xuXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxICYmIEFycmF5LmlzQXJyYXkocGlwZWxpbmUpKSB7XG4gICAgdGhpcy5hcHBlbmQuYXBwbHkodGhpcywgcGlwZWxpbmUpO1xuICB9XG59XG5cbi8qKlxuICogQ29udGFpbnMgb3B0aW9ucyBwYXNzZWQgZG93biB0byB0aGUgW2FnZ3JlZ2F0ZSBjb21tYW5kXShodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9yZWZlcmVuY2UvY29tbWFuZC9hZ2dyZWdhdGUvKS5cbiAqIFN1cHBvcnRlZCBvcHRpb25zIGFyZTpcbiAqXG4gKiAtIFtgYWxsb3dEaXNrVXNlYF0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2FwaS9hZ2dyZWdhdGUuaHRtbCNBZ2dyZWdhdGUucHJvdG90eXBlLmFsbG93RGlza1VzZSgpKVxuICogLSBgYnlwYXNzRG9jdW1lbnRWYWxpZGF0aW9uYFxuICogLSBbYGNvbGxhdGlvbmBdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvYWdncmVnYXRlLmh0bWwjQWdncmVnYXRlLnByb3RvdHlwZS5jb2xsYXRpb24oKSlcbiAqIC0gYGNvbW1lbnRgXG4gKiAtIFtgY3Vyc29yYF0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2FwaS9hZ2dyZWdhdGUuaHRtbCNBZ2dyZWdhdGUucHJvdG90eXBlLmN1cnNvcigpKVxuICogLSBbYGV4cGxhaW5gXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvYXBpL2FnZ3JlZ2F0ZS5odG1sI0FnZ3JlZ2F0ZS5wcm90b3R5cGUuZXhwbGFpbigpKVxuICogLSBgZmllbGRzQXNSYXdgXG4gKiAtIFtgaGludGBdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvYWdncmVnYXRlLmh0bWwjQWdncmVnYXRlLnByb3RvdHlwZS5oaW50KCkpXG4gKiAtIGBsZXRgXG4gKiAtIGBtYXhUaW1lTVNgXG4gKiAtIGByYXdgXG4gKiAtIFtgcmVhZENvbmNlcm5gXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvYXBpL2FnZ3JlZ2F0ZS5odG1sI0FnZ3JlZ2F0ZS5wcm90b3R5cGUucmVhZENvbmNlcm4oKSlcbiAqIC0gYHJlYWRQcmVmZXJlbmNlYFxuICogLSBbYHNlc3Npb25gXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvYXBpL2FnZ3JlZ2F0ZS5odG1sI0FnZ3JlZ2F0ZS5wcm90b3R5cGUuc2Vzc2lvbigpKVxuICogLSBgd3JpdGVDb25jZXJuYFxuICpcbiAqIEBwcm9wZXJ0eSBvcHRpb25zXG4gKiBAbWVtYmVyT2YgQWdncmVnYXRlXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkFnZ3JlZ2F0ZS5wcm90b3R5cGUub3B0aW9ucztcblxuLyoqXG4gKiBHZXQvc2V0IHRoZSBtb2RlbCB0aGF0IHRoaXMgYWdncmVnYXRpb24gd2lsbCBleGVjdXRlIG9uLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgY29uc3QgYWdncmVnYXRlID0gTXlNb2RlbC5hZ2dyZWdhdGUoW3sgJG1hdGNoOiB7IGFuc3dlcjogNDIgfSB9XSk7XG4gKiAgICAgYWdncmVnYXRlLm1vZGVsKCkgPT09IE15TW9kZWw7IC8vIHRydWVcbiAqXG4gKiAgICAgLy8gQ2hhbmdlIHRoZSBtb2RlbC4gVGhlcmUncyByYXJlbHkgYW55IHJlYXNvbiB0byBkbyB0aGlzLlxuICogICAgIGFnZ3JlZ2F0ZS5tb2RlbChTb21lT3RoZXJNb2RlbCk7XG4gKiAgICAgYWdncmVnYXRlLm1vZGVsKCkgPT09IFNvbWVPdGhlck1vZGVsOyAvLyB0cnVlXG4gKlxuICogQHBhcmFtIHtNb2RlbH0gW21vZGVsXSBTZXQgdGhlIG1vZGVsIGFzc29jaWF0ZWQgd2l0aCB0aGlzIGFnZ3JlZ2F0ZS4gSWYgbm90IHByb3ZpZGVkLCByZXR1cm5zIHRoZSBhbHJlYWR5IHN0b3JlZCBtb2RlbC5cbiAqIEByZXR1cm4ge01vZGVsfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5BZ2dyZWdhdGUucHJvdG90eXBlLm1vZGVsID0gZnVuY3Rpb24obW9kZWwpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gdGhpcy5fbW9kZWw7XG4gIH1cblxuICB0aGlzLl9tb2RlbCA9IG1vZGVsO1xuICBpZiAobW9kZWwuc2NoZW1hICE9IG51bGwpIHtcbiAgICBpZiAodGhpcy5vcHRpb25zLnJlYWRQcmVmZXJlbmNlID09IG51bGwgJiZcbiAgICAgIG1vZGVsLnNjaGVtYS5vcHRpb25zLnJlYWQgIT0gbnVsbCkge1xuICAgICAgdGhpcy5vcHRpb25zLnJlYWRQcmVmZXJlbmNlID0gbW9kZWwuc2NoZW1hLm9wdGlvbnMucmVhZDtcbiAgICB9XG4gICAgaWYgKHRoaXMub3B0aW9ucy5jb2xsYXRpb24gPT0gbnVsbCAmJlxuICAgICAgbW9kZWwuc2NoZW1hLm9wdGlvbnMuY29sbGF0aW9uICE9IG51bGwpIHtcbiAgICAgIHRoaXMub3B0aW9ucy5jb2xsYXRpb24gPSBtb2RlbC5zY2hlbWEub3B0aW9ucy5jb2xsYXRpb247XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG1vZGVsO1xufTtcblxuLyoqXG4gKiBBcHBlbmRzIG5ldyBvcGVyYXRvcnMgdG8gdGhpcyBhZ2dyZWdhdGUgcGlwZWxpbmVcbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGFnZ3JlZ2F0ZS5hcHBlbmQoeyAkcHJvamVjdDogeyBmaWVsZDogMSB9fSwgeyAkbGltaXQ6IDIgfSk7XG4gKlxuICogICAgIC8vIG9yIHBhc3MgYW4gYXJyYXlcbiAqICAgICBjb25zdCBwaXBlbGluZSA9IFt7ICRtYXRjaDogeyBkYXc6ICdMb2dpYyBBdWRpbyBYJyB9fSBdO1xuICogICAgIGFnZ3JlZ2F0ZS5hcHBlbmQocGlwZWxpbmUpO1xuICpcbiAqIEBwYXJhbSB7Li4uT2JqZWN0fE9iamVjdFtdfSBvcHMgb3BlcmF0b3IocykgdG8gYXBwZW5kLiBDYW4gZWl0aGVyIGJlIGEgc3ByZWFkIG9mIG9iamVjdHMgb3IgYSBzaW5nbGUgcGFyYW1ldGVyIG9mIGEgb2JqZWN0IGFycmF5LlxuICogQHJldHVybiB7QWdncmVnYXRlfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5BZ2dyZWdhdGUucHJvdG90eXBlLmFwcGVuZCA9IGZ1bmN0aW9uKCkge1xuICBjb25zdCBhcmdzID0gKGFyZ3VtZW50cy5sZW5ndGggPT09IDEgJiYgQXJyYXkuaXNBcnJheShhcmd1bWVudHNbMF0pKVxuICAgID8gYXJndW1lbnRzWzBdXG4gICAgOiBbLi4uYXJndW1lbnRzXTtcblxuICBpZiAoIWFyZ3MuZXZlcnkoaXNPcGVyYXRvcikpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0FyZ3VtZW50cyBtdXN0IGJlIGFnZ3JlZ2F0ZSBwaXBlbGluZSBvcGVyYXRvcnMnKTtcbiAgfVxuXG4gIHRoaXMuX3BpcGVsaW5lID0gdGhpcy5fcGlwZWxpbmUuY29uY2F0KGFyZ3MpO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBBcHBlbmRzIGEgbmV3ICRhZGRGaWVsZHMgb3BlcmF0b3IgdG8gdGhpcyBhZ2dyZWdhdGUgcGlwZWxpbmUuXG4gKiBSZXF1aXJlcyBNb25nb0RCIHYzLjQrIHRvIHdvcmtcbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIC8vIGFkZGluZyBuZXcgZmllbGRzIGJhc2VkIG9uIGV4aXN0aW5nIGZpZWxkc1xuICogICAgIGFnZ3JlZ2F0ZS5hZGRGaWVsZHMoe1xuICogICAgICAgICBuZXdGaWVsZDogJyRiLm5lc3RlZCdcbiAqICAgICAgICwgcGx1c1RlbjogeyAkYWRkOiBbJyR2YWwnLCAxMF19XG4gKiAgICAgICAsIHN1Yjoge1xuICogICAgICAgICAgICBuYW1lOiAnJGEnXG4gKiAgICAgICAgIH1cbiAqICAgICB9KVxuICpcbiAqICAgICAvLyBldGNcbiAqICAgICBhZ2dyZWdhdGUuYWRkRmllbGRzKHsgc2FsYXJ5X2s6IHsgJGRpdmlkZTogWyBcIiRzYWxhcnlcIiwgMTAwMCBdIH0gfSk7XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGFyZyBmaWVsZCBzcGVjaWZpY2F0aW9uXG4gKiBAc2VlICRhZGRGaWVsZHMgaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvcmVmZXJlbmNlL29wZXJhdG9yL2FnZ3JlZ2F0aW9uL2FkZEZpZWxkcy9cbiAqIEByZXR1cm4ge0FnZ3JlZ2F0ZX1cbiAqIEBhcGkgcHVibGljXG4gKi9cbkFnZ3JlZ2F0ZS5wcm90b3R5cGUuYWRkRmllbGRzID0gZnVuY3Rpb24oYXJnKSB7XG4gIGlmICh0eXBlb2YgYXJnICE9PSAnb2JqZWN0JyB8fCBhcmcgPT09IG51bGwgfHwgQXJyYXkuaXNBcnJheShhcmcpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGFkZEZpZWxkcygpIGFyZ3VtZW50LiBNdXN0IGJlIGFuIG9iamVjdCcpO1xuICB9XG4gIHJldHVybiB0aGlzLmFwcGVuZCh7ICRhZGRGaWVsZHM6IE9iamVjdC5hc3NpZ24oe30sIGFyZykgfSk7XG59O1xuXG4vKipcbiAqIEFwcGVuZHMgYSBuZXcgJHByb2plY3Qgb3BlcmF0b3IgdG8gdGhpcyBhZ2dyZWdhdGUgcGlwZWxpbmUuXG4gKlxuICogTW9uZ29vc2UgcXVlcnkgW3NlbGVjdGlvbiBzeW50YXhdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvcXVlcnkuaHRtbCNRdWVyeS5wcm90b3R5cGUuc2VsZWN0KCkpIGlzIGFsc28gc3VwcG9ydGVkLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgLy8gaW5jbHVkZSBhLCBpbmNsdWRlIGIsIGV4Y2x1ZGUgX2lkXG4gKiAgICAgYWdncmVnYXRlLnByb2plY3QoXCJhIGIgLV9pZFwiKTtcbiAqXG4gKiAgICAgLy8gb3IgeW91IG1heSB1c2Ugb2JqZWN0IG5vdGF0aW9uLCB1c2VmdWwgd2hlblxuICogICAgIC8vIHlvdSBoYXZlIGtleXMgYWxyZWFkeSBwcmVmaXhlZCB3aXRoIGEgXCItXCJcbiAqICAgICBhZ2dyZWdhdGUucHJvamVjdCh7YTogMSwgYjogMSwgX2lkOiAwfSk7XG4gKlxuICogICAgIC8vIHJlc2hhcGluZyBkb2N1bWVudHNcbiAqICAgICBhZ2dyZWdhdGUucHJvamVjdCh7XG4gKiAgICAgICAgIG5ld0ZpZWxkOiAnJGIubmVzdGVkJ1xuICogICAgICAgLCBwbHVzVGVuOiB7ICRhZGQ6IFsnJHZhbCcsIDEwXX1cbiAqICAgICAgICwgc3ViOiB7XG4gKiAgICAgICAgICAgIG5hbWU6ICckYSdcbiAqICAgICAgICAgfVxuICogICAgIH0pXG4gKlxuICogICAgIC8vIGV0Y1xuICogICAgIGFnZ3JlZ2F0ZS5wcm9qZWN0KHsgc2FsYXJ5X2s6IHsgJGRpdmlkZTogWyBcIiRzYWxhcnlcIiwgMTAwMCBdIH0gfSk7XG4gKlxuICogQHBhcmFtIHtPYmplY3R8U3RyaW5nfSBhcmcgZmllbGQgc3BlY2lmaWNhdGlvblxuICogQHNlZSBwcm9qZWN0aW9uIGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvbWFudWFsL3JlZmVyZW5jZS9hZ2dyZWdhdGlvbi9wcm9qZWN0L1xuICogQHJldHVybiB7QWdncmVnYXRlfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5BZ2dyZWdhdGUucHJvdG90eXBlLnByb2plY3QgPSBmdW5jdGlvbihhcmcpIHtcbiAgY29uc3QgZmllbGRzID0ge307XG5cbiAgaWYgKHR5cGVvZiBhcmcgPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KGFyZykpIHtcbiAgICBPYmplY3Qua2V5cyhhcmcpLmZvckVhY2goZnVuY3Rpb24oZmllbGQpIHtcbiAgICAgIGZpZWxkc1tmaWVsZF0gPSBhcmdbZmllbGRdO1xuICAgIH0pO1xuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEgJiYgdHlwZW9mIGFyZyA9PT0gJ3N0cmluZycpIHtcbiAgICBhcmcuc3BsaXQoL1xccysvKS5mb3JFYWNoKGZ1bmN0aW9uKGZpZWxkKSB7XG4gICAgICBpZiAoIWZpZWxkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGluY2x1ZGUgPSBmaWVsZFswXSA9PT0gJy0nID8gMCA6IDE7XG4gICAgICBpZiAoaW5jbHVkZSA9PT0gMCkge1xuICAgICAgICBmaWVsZCA9IGZpZWxkLnN1YnN0cmluZygxKTtcbiAgICAgIH1cbiAgICAgIGZpZWxkc1tmaWVsZF0gPSBpbmNsdWRlO1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBwcm9qZWN0KCkgYXJndW1lbnQuIE11c3QgYmUgc3RyaW5nIG9yIG9iamVjdCcpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXMuYXBwZW5kKHsgJHByb2plY3Q6IGZpZWxkcyB9KTtcbn07XG5cbi8qKlxuICogQXBwZW5kcyBhIG5ldyBjdXN0b20gJGdyb3VwIG9wZXJhdG9yIHRvIHRoaXMgYWdncmVnYXRlIHBpcGVsaW5lLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgYWdncmVnYXRlLmdyb3VwKHsgX2lkOiBcIiRkZXBhcnRtZW50XCIgfSk7XG4gKlxuICogQHNlZSAkZ3JvdXAgaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvcmVmZXJlbmNlL2FnZ3JlZ2F0aW9uL2dyb3VwL1xuICogQG1ldGhvZCBncm91cFxuICogQG1lbWJlck9mIEFnZ3JlZ2F0ZVxuICogQGluc3RhbmNlXG4gKiBAcGFyYW0ge09iamVjdH0gYXJnICRncm91cCBvcGVyYXRvciBjb250ZW50c1xuICogQHJldHVybiB7QWdncmVnYXRlfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG4vKipcbiAqIEFwcGVuZHMgYSBuZXcgY3VzdG9tICRtYXRjaCBvcGVyYXRvciB0byB0aGlzIGFnZ3JlZ2F0ZSBwaXBlbGluZS5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGFnZ3JlZ2F0ZS5tYXRjaCh7IGRlcGFydG1lbnQ6IHsgJGluOiBbIFwic2FsZXNcIiwgXCJlbmdpbmVlcmluZ1wiIF0gfSB9KTtcbiAqXG4gKiBAc2VlICRtYXRjaCBodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9yZWZlcmVuY2UvYWdncmVnYXRpb24vbWF0Y2gvXG4gKiBAbWV0aG9kIG1hdGNoXG4gKiBAbWVtYmVyT2YgQWdncmVnYXRlXG4gKiBAaW5zdGFuY2VcbiAqIEBwYXJhbSB7T2JqZWN0fSBhcmcgJG1hdGNoIG9wZXJhdG9yIGNvbnRlbnRzXG4gKiBAcmV0dXJuIHtBZ2dyZWdhdGV9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbi8qKlxuICogQXBwZW5kcyBhIG5ldyAkc2tpcCBvcGVyYXRvciB0byB0aGlzIGFnZ3JlZ2F0ZSBwaXBlbGluZS5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGFnZ3JlZ2F0ZS5za2lwKDEwKTtcbiAqXG4gKiBAc2VlICRza2lwIGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvbWFudWFsL3JlZmVyZW5jZS9hZ2dyZWdhdGlvbi9za2lwL1xuICogQG1ldGhvZCBza2lwXG4gKiBAbWVtYmVyT2YgQWdncmVnYXRlXG4gKiBAaW5zdGFuY2VcbiAqIEBwYXJhbSB7TnVtYmVyfSBudW0gbnVtYmVyIG9mIHJlY29yZHMgdG8gc2tpcCBiZWZvcmUgbmV4dCBzdGFnZVxuICogQHJldHVybiB7QWdncmVnYXRlfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG4vKipcbiAqIEFwcGVuZHMgYSBuZXcgJGxpbWl0IG9wZXJhdG9yIHRvIHRoaXMgYWdncmVnYXRlIHBpcGVsaW5lLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgYWdncmVnYXRlLmxpbWl0KDEwKTtcbiAqXG4gKiBAc2VlICRsaW1pdCBodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9yZWZlcmVuY2UvYWdncmVnYXRpb24vbGltaXQvXG4gKiBAbWV0aG9kIGxpbWl0XG4gKiBAbWVtYmVyT2YgQWdncmVnYXRlXG4gKiBAaW5zdGFuY2VcbiAqIEBwYXJhbSB7TnVtYmVyfSBudW0gbWF4aW11bSBudW1iZXIgb2YgcmVjb3JkcyB0byBwYXNzIHRvIHRoZSBuZXh0IHN0YWdlXG4gKiBAcmV0dXJuIHtBZ2dyZWdhdGV9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblxuLyoqXG4gKiBBcHBlbmRzIGEgbmV3ICRkZW5zaWZ5IG9wZXJhdG9yIHRvIHRoaXMgYWdncmVnYXRlIHBpcGVsaW5lLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgIGFnZ3JlZ2F0ZS5kZW5zaWZ5KHtcbiAqICAgICAgICBmaWVsZDogJ3RpbWVzdGFtcCcsXG4gKiAgICAgICAgcmFuZ2U6IHtcbiAqICAgICAgICAgIHN0ZXA6IDEsXG4gKiAgICAgICAgICB1bml0OiAnaG91cicsXG4gKiAgICAgICAgICBib3VuZHM6IFtuZXcgRGF0ZSgnMjAyMS0wNS0xOFQwMDowMDowMC4wMDBaJyksIG5ldyBEYXRlKCcyMDIxLTA1LTE4VDA4OjAwOjAwLjAwMFonKV1cbiAqICAgICAgICB9XG4gKiAgICAgIH0pO1xuICpcbiAqIEBzZWUgJGRlbnNpZnkgaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvcmVmZXJlbmNlL29wZXJhdG9yL2FnZ3JlZ2F0aW9uL2RlbnNpZnkvXG4gKiBAbWV0aG9kIGRlbnNpZnlcbiAqIEBtZW1iZXJPZiBBZ2dyZWdhdGVcbiAqIEBpbnN0YW5jZVxuICogQHBhcmFtIHtPYmplY3R9IGFyZyAkZGVuc2lmeSBvcGVyYXRvciBjb250ZW50c1xuICogQHJldHVybiB7QWdncmVnYXRlfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG4vKipcbiAqIEFwcGVuZHMgYSBuZXcgJGZpbGwgb3BlcmF0b3IgdG8gdGhpcyBhZ2dyZWdhdGUgcGlwZWxpbmUuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICAgYWdncmVnYXRlLmZpbGwoe1xuICogICAgICAgIG91dHB1dDoge1xuICogICAgICAgICAgYm9vdHNTb2xkOiB7IHZhbHVlOiAwIH0sXG4gKiAgICAgICAgICBzYW5kYWxzU29sZDogeyB2YWx1ZTogMCB9LFxuICogICAgICAgICAgc25lYWtlcnNTb2xkOiB7IHZhbHVlOiAwIH1cbiAqICAgICAgICB9XG4gKiAgICAgIH0pO1xuICpcbiAqIEBzZWUgJGZpbGwgaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvcmVmZXJlbmNlL29wZXJhdG9yL2FnZ3JlZ2F0aW9uL2ZpbGwvXG4gKiBAbWV0aG9kIGZpbGxcbiAqIEBtZW1iZXJPZiBBZ2dyZWdhdGVcbiAqIEBpbnN0YW5jZVxuICogQHBhcmFtIHtPYmplY3R9IGFyZyAkZmlsbCBvcGVyYXRvciBjb250ZW50c1xuICogQHJldHVybiB7QWdncmVnYXRlfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG4vKipcbiAqIEFwcGVuZHMgYSBuZXcgJGdlb05lYXIgb3BlcmF0b3IgdG8gdGhpcyBhZ2dyZWdhdGUgcGlwZWxpbmUuXG4gKlxuICogIyMjIyBOb3RlOlxuICpcbiAqICoqTVVTVCoqIGJlIHVzZWQgYXMgdGhlIGZpcnN0IG9wZXJhdG9yIGluIHRoZSBwaXBlbGluZS5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGFnZ3JlZ2F0ZS5uZWFyKHtcbiAqICAgICAgIG5lYXI6IHsgdHlwZTogJ1BvaW50JywgY29vcmRpbmF0ZXM6IFs0MC43MjQsIC03My45OTddIH0sXG4gKiAgICAgICBkaXN0YW5jZUZpZWxkOiBcImRpc3QuY2FsY3VsYXRlZFwiLCAvLyByZXF1aXJlZFxuICogICAgICAgbWF4RGlzdGFuY2U6IDAuMDA4LFxuICogICAgICAgcXVlcnk6IHsgdHlwZTogXCJwdWJsaWNcIiB9LFxuICogICAgICAgaW5jbHVkZUxvY3M6IFwiZGlzdC5sb2NhdGlvblwiLFxuICogICAgICAgc3BoZXJpY2FsOiB0cnVlLFxuICogICAgIH0pO1xuICpcbiAqIEBzZWUgJGdlb05lYXIgaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvcmVmZXJlbmNlL2FnZ3JlZ2F0aW9uL2dlb05lYXIvXG4gKiBAbWV0aG9kIG5lYXJcbiAqIEBtZW1iZXJPZiBBZ2dyZWdhdGVcbiAqIEBpbnN0YW5jZVxuICogQHBhcmFtIHtPYmplY3R9IGFyZ1xuICogQHJldHVybiB7QWdncmVnYXRlfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5BZ2dyZWdhdGUucHJvdG90eXBlLm5lYXIgPSBmdW5jdGlvbihhcmcpIHtcbiAgY29uc3Qgb3AgPSB7fTtcbiAgb3AuJGdlb05lYXIgPSBhcmc7XG4gIHJldHVybiB0aGlzLmFwcGVuZChvcCk7XG59O1xuXG4vKiFcbiAqIGRlZmluZSBtZXRob2RzXG4gKi9cblxuJ2dyb3VwIG1hdGNoIHNraXAgbGltaXQgb3V0IGRlbnNpZnkgZmlsbCcuc3BsaXQoJyAnKS5mb3JFYWNoKGZ1bmN0aW9uKCRvcGVyYXRvcikge1xuICBBZ2dyZWdhdGUucHJvdG90eXBlWyRvcGVyYXRvcl0gPSBmdW5jdGlvbihhcmcpIHtcbiAgICBjb25zdCBvcCA9IHt9O1xuICAgIG9wWyckJyArICRvcGVyYXRvcl0gPSBhcmc7XG4gICAgcmV0dXJuIHRoaXMuYXBwZW5kKG9wKTtcbiAgfTtcbn0pO1xuXG4vKipcbiAqIEFwcGVuZHMgbmV3IGN1c3RvbSAkdW53aW5kIG9wZXJhdG9yKHMpIHRvIHRoaXMgYWdncmVnYXRlIHBpcGVsaW5lLlxuICpcbiAqIE5vdGUgdGhhdCB0aGUgYCR1bndpbmRgIG9wZXJhdG9yIHJlcXVpcmVzIHRoZSBwYXRoIG5hbWUgdG8gc3RhcnQgd2l0aCAnJCcuXG4gKiBNb25nb29zZSB3aWxsIHByZXBlbmQgJyQnIGlmIHRoZSBzcGVjaWZpZWQgZmllbGQgZG9lc24ndCBzdGFydCAnJCcuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBhZ2dyZWdhdGUudW53aW5kKFwidGFnc1wiKTtcbiAqICAgICBhZ2dyZWdhdGUudW53aW5kKFwiYVwiLCBcImJcIiwgXCJjXCIpO1xuICogICAgIGFnZ3JlZ2F0ZS51bndpbmQoeyBwYXRoOiAnJHRhZ3MnLCBwcmVzZXJ2ZU51bGxBbmRFbXB0eUFycmF5czogdHJ1ZSB9KTtcbiAqXG4gKiBAc2VlICR1bndpbmQgaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvcmVmZXJlbmNlL2FnZ3JlZ2F0aW9uL3Vud2luZC9cbiAqIEBwYXJhbSB7U3RyaW5nfE9iamVjdHxTdHJpbmdbXXxPYmplY3RbXX0gZmllbGRzIHRoZSBmaWVsZChzKSB0byB1bndpbmQsIGVpdGhlciBhcyBmaWVsZCBuYW1lcyBvciBhcyBbb2JqZWN0cyB3aXRoIG9wdGlvbnNdKGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvbWFudWFsL3JlZmVyZW5jZS9vcGVyYXRvci9hZ2dyZWdhdGlvbi91bndpbmQvI2RvY3VtZW50LW9wZXJhbmQtd2l0aC1vcHRpb25zKS4gSWYgcGFzc2luZyBhIHN0cmluZywgcHJlZml4aW5nIHRoZSBmaWVsZCBuYW1lIHdpdGggJyQnIGlzIG9wdGlvbmFsLiBJZiBwYXNzaW5nIGFuIG9iamVjdCwgYHBhdGhgIG11c3Qgc3RhcnQgd2l0aCAnJCcuXG4gKiBAcmV0dXJuIHtBZ2dyZWdhdGV9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkFnZ3JlZ2F0ZS5wcm90b3R5cGUudW53aW5kID0gZnVuY3Rpb24oKSB7XG4gIGNvbnN0IGFyZ3MgPSBbLi4uYXJndW1lbnRzXTtcblxuICBjb25zdCByZXMgPSBbXTtcbiAgZm9yIChjb25zdCBhcmcgb2YgYXJncykge1xuICAgIGlmIChhcmcgJiYgdHlwZW9mIGFyZyA9PT0gJ29iamVjdCcpIHtcbiAgICAgIHJlcy5wdXNoKHsgJHVud2luZDogYXJnIH0pO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGFyZyA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHJlcy5wdXNoKHtcbiAgICAgICAgJHVud2luZDogKGFyZ1swXSA9PT0gJyQnKSA/IGFyZyA6ICckJyArIGFyZ1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBhcmcgXCInICsgYXJnICsgJ1wiIHRvIHVud2luZCgpLCAnICtcbiAgICAgICAgJ211c3QgYmUgc3RyaW5nIG9yIG9iamVjdCcpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzLmFwcGVuZC5hcHBseSh0aGlzLCByZXMpO1xufTtcblxuLyoqXG4gKiBBcHBlbmRzIGEgbmV3ICRyZXBsYWNlUm9vdCBvcGVyYXRvciB0byB0aGlzIGFnZ3JlZ2F0ZSBwaXBlbGluZS5cbiAqXG4gKiBOb3RlIHRoYXQgdGhlIGAkcmVwbGFjZVJvb3RgIG9wZXJhdG9yIHJlcXVpcmVzIGZpZWxkIHN0cmluZ3MgdG8gc3RhcnQgd2l0aCAnJCcuXG4gKiBJZiB5b3UgYXJlIHBhc3NpbmcgaW4gYSBzdHJpbmcgTW9uZ29vc2Ugd2lsbCBwcmVwZW5kICckJyBpZiB0aGUgc3BlY2lmaWVkIGZpZWxkIGRvZXNuJ3Qgc3RhcnQgJyQnLlxuICogSWYgeW91IGFyZSBwYXNzaW5nIGluIGFuIG9iamVjdCB0aGUgc3RyaW5ncyBpbiB5b3VyIGV4cHJlc3Npb24gd2lsbCBub3QgYmUgYWx0ZXJlZC5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGFnZ3JlZ2F0ZS5yZXBsYWNlUm9vdChcInVzZXJcIik7XG4gKlxuICogICAgIGFnZ3JlZ2F0ZS5yZXBsYWNlUm9vdCh7IHg6IHsgJGNvbmNhdDogWyckdGhpcycsICckdGhhdCddIH0gfSk7XG4gKlxuICogQHNlZSAkcmVwbGFjZVJvb3QgaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvcmVmZXJlbmNlL29wZXJhdG9yL2FnZ3JlZ2F0aW9uL3JlcGxhY2VSb290XG4gKiBAcGFyYW0ge1N0cmluZ3xPYmplY3R9IG5ld1Jvb3QgdGhlIGZpZWxkIG9yIGRvY3VtZW50IHdoaWNoIHdpbGwgYmVjb21lIHRoZSBuZXcgcm9vdCBkb2N1bWVudFxuICogQHJldHVybiB7QWdncmVnYXRlfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5BZ2dyZWdhdGUucHJvdG90eXBlLnJlcGxhY2VSb290ID0gZnVuY3Rpb24obmV3Um9vdCkge1xuICBsZXQgcmV0O1xuXG4gIGlmICh0eXBlb2YgbmV3Um9vdCA9PT0gJ3N0cmluZycpIHtcbiAgICByZXQgPSBuZXdSb290LnN0YXJ0c1dpdGgoJyQnKSA/IG5ld1Jvb3QgOiAnJCcgKyBuZXdSb290O1xuICB9IGVsc2Uge1xuICAgIHJldCA9IG5ld1Jvb3Q7XG4gIH1cblxuICByZXR1cm4gdGhpcy5hcHBlbmQoe1xuICAgICRyZXBsYWNlUm9vdDoge1xuICAgICAgbmV3Um9vdDogcmV0XG4gICAgfVxuICB9KTtcbn07XG5cbi8qKlxuICogQXBwZW5kcyBhIG5ldyAkY291bnQgb3BlcmF0b3IgdG8gdGhpcyBhZ2dyZWdhdGUgcGlwZWxpbmUuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBhZ2dyZWdhdGUuY291bnQoXCJ1c2VyQ291bnRcIik7XG4gKlxuICogQHNlZSAkY291bnQgaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvcmVmZXJlbmNlL29wZXJhdG9yL2FnZ3JlZ2F0aW9uL2NvdW50XG4gKiBAcGFyYW0ge1N0cmluZ30gZmllbGROYW1lIFRoZSBuYW1lIG9mIHRoZSBvdXRwdXQgZmllbGQgd2hpY2ggaGFzIHRoZSBjb3VudCBhcyBpdHMgdmFsdWUuIEl0IG11c3QgYmUgYSBub24tZW1wdHkgc3RyaW5nLCBtdXN0IG5vdCBzdGFydCB3aXRoICQgYW5kIG11c3Qgbm90IGNvbnRhaW4gdGhlIC4gY2hhcmFjdGVyLlxuICogQHJldHVybiB7QWdncmVnYXRlfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5BZ2dyZWdhdGUucHJvdG90eXBlLmNvdW50ID0gZnVuY3Rpb24oZmllbGROYW1lKSB7XG4gIHJldHVybiB0aGlzLmFwcGVuZCh7ICRjb3VudDogZmllbGROYW1lIH0pO1xufTtcblxuLyoqXG4gKiBBcHBlbmRzIGEgbmV3ICRzb3J0QnlDb3VudCBvcGVyYXRvciB0byB0aGlzIGFnZ3JlZ2F0ZSBwaXBlbGluZS4gQWNjZXB0cyBlaXRoZXIgYSBzdHJpbmcgZmllbGQgbmFtZVxuICogb3IgYSBwaXBlbGluZSBvYmplY3QuXG4gKlxuICogTm90ZSB0aGF0IHRoZSBgJHNvcnRCeUNvdW50YCBvcGVyYXRvciByZXF1aXJlcyB0aGUgbmV3IHJvb3QgdG8gc3RhcnQgd2l0aCAnJCcuXG4gKiBNb25nb29zZSB3aWxsIHByZXBlbmQgJyQnIGlmIHRoZSBzcGVjaWZpZWQgZmllbGQgbmFtZSBkb2Vzbid0IHN0YXJ0IHdpdGggJyQnLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgYWdncmVnYXRlLnNvcnRCeUNvdW50KCd1c2VycycpO1xuICogICAgIGFnZ3JlZ2F0ZS5zb3J0QnlDb3VudCh7ICRtZXJnZU9iamVjdHM6IFsgXCIkZW1wbG95ZWVcIiwgXCIkYnVzaW5lc3NcIiBdIH0pXG4gKlxuICogQHNlZSAkc29ydEJ5Q291bnQgaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvcmVmZXJlbmNlL29wZXJhdG9yL2FnZ3JlZ2F0aW9uL3NvcnRCeUNvdW50L1xuICogQHBhcmFtIHtPYmplY3R8U3RyaW5nfSBhcmdcbiAqIEByZXR1cm4ge0FnZ3JlZ2F0ZX0gdGhpc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5BZ2dyZWdhdGUucHJvdG90eXBlLnNvcnRCeUNvdW50ID0gZnVuY3Rpb24oYXJnKSB7XG4gIGlmIChhcmcgJiYgdHlwZW9mIGFyZyA9PT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gdGhpcy5hcHBlbmQoeyAkc29ydEJ5Q291bnQ6IGFyZyB9KTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgYXJnID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB0aGlzLmFwcGVuZCh7XG4gICAgICAkc29ydEJ5Q291bnQ6IChhcmdbMF0gPT09ICckJykgPyBhcmcgOiAnJCcgKyBhcmdcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIGFyZyBcIicgKyBhcmcgKyAnXCIgdG8gc29ydEJ5Q291bnQoKSwgJyArXG4gICAgICAnbXVzdCBiZSBzdHJpbmcgb3Igb2JqZWN0Jyk7XG4gIH1cbn07XG5cbi8qKlxuICogQXBwZW5kcyBuZXcgY3VzdG9tICRsb29rdXAgb3BlcmF0b3IgdG8gdGhpcyBhZ2dyZWdhdGUgcGlwZWxpbmUuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBhZ2dyZWdhdGUubG9va3VwKHsgZnJvbTogJ3VzZXJzJywgbG9jYWxGaWVsZDogJ3VzZXJJZCcsIGZvcmVpZ25GaWVsZDogJ19pZCcsIGFzOiAndXNlcnMnIH0pO1xuICpcbiAqIEBzZWUgJGxvb2t1cCBodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9yZWZlcmVuY2Uvb3BlcmF0b3IvYWdncmVnYXRpb24vbG9va3VwLyNwaXBlLl9TX2xvb2t1cFxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgdG8gJGxvb2t1cCBhcyBkZXNjcmliZWQgaW4gdGhlIGFib3ZlIGxpbmtcbiAqIEByZXR1cm4ge0FnZ3JlZ2F0ZX1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuQWdncmVnYXRlLnByb3RvdHlwZS5sb29rdXAgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gIHJldHVybiB0aGlzLmFwcGVuZCh7ICRsb29rdXA6IG9wdGlvbnMgfSk7XG59O1xuXG4vKipcbiAqIEFwcGVuZHMgbmV3IGN1c3RvbSAkZ3JhcGhMb29rdXAgb3BlcmF0b3IocykgdG8gdGhpcyBhZ2dyZWdhdGUgcGlwZWxpbmUsIHBlcmZvcm1pbmcgYSByZWN1cnNpdmUgc2VhcmNoIG9uIGEgY29sbGVjdGlvbi5cbiAqXG4gKiBOb3RlIHRoYXQgZ3JhcGhMb29rdXAgY2FuIG9ubHkgY29uc3VtZSBhdCBtb3N0IDEwME1CIG9mIG1lbW9yeSwgYW5kIGRvZXMgbm90IGFsbG93IGRpc2sgdXNlIGV2ZW4gaWYgYHsgYWxsb3dEaXNrVXNlOiB0cnVlIH1gIGlzIHNwZWNpZmllZC5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgICAvLyBTdXBwb3NlIHdlIGhhdmUgYSBjb2xsZWN0aW9uIG9mIGNvdXJzZXMsIHdoZXJlIGEgZG9jdW1lbnQgbWlnaHQgbG9vayBsaWtlIGB7IF9pZDogMCwgbmFtZTogJ0NhbGN1bHVzJywgcHJlcmVxdWlzaXRlOiAnVHJpZ29ub21ldHJ5J31gIGFuZCBgeyBfaWQ6IDAsIG5hbWU6ICdUcmlnb25vbWV0cnknLCBwcmVyZXF1aXNpdGU6ICdBbGdlYnJhJyB9YFxuICogICAgICBhZ2dyZWdhdGUuZ3JhcGhMb29rdXAoeyBmcm9tOiAnY291cnNlcycsIHN0YXJ0V2l0aDogJyRwcmVyZXF1aXNpdGUnLCBjb25uZWN0RnJvbUZpZWxkOiAncHJlcmVxdWlzaXRlJywgY29ubmVjdFRvRmllbGQ6ICduYW1lJywgYXM6ICdwcmVyZXF1aXNpdGVzJywgbWF4RGVwdGg6IDMgfSkgLy8gdGhpcyB3aWxsIHJlY3Vyc2l2ZWx5IHNlYXJjaCB0aGUgJ2NvdXJzZXMnIGNvbGxlY3Rpb24gdXAgdG8gMyBwcmVyZXF1aXNpdGVzXG4gKlxuICogQHNlZSAkZ3JhcGhMb29rdXAgaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvcmVmZXJlbmNlL29wZXJhdG9yL2FnZ3JlZ2F0aW9uL2dyYXBoTG9va3VwLyNwaXBlLl9TX2dyYXBoTG9va3VwXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyB0byAkZ3JhcGhMb29rdXAgYXMgZGVzY3JpYmVkIGluIHRoZSBhYm92ZSBsaW5rXG4gKiBAcmV0dXJuIHtBZ2dyZWdhdGV9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkFnZ3JlZ2F0ZS5wcm90b3R5cGUuZ3JhcGhMb29rdXAgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gIGNvbnN0IGNsb25lT3B0aW9ucyA9IHt9O1xuICBpZiAob3B0aW9ucykge1xuICAgIGlmICghdXRpbHMuaXNPYmplY3Qob3B0aW9ucykpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgZ3JhcGhMb29rdXAoKSBhcmd1bWVudC4gTXVzdCBiZSBhbiBvYmplY3QuJyk7XG4gICAgfVxuXG4gICAgdXRpbHMubWVyZ2VDbG9uZShjbG9uZU9wdGlvbnMsIG9wdGlvbnMpO1xuICAgIGNvbnN0IHN0YXJ0V2l0aCA9IGNsb25lT3B0aW9ucy5zdGFydFdpdGg7XG5cbiAgICBpZiAoc3RhcnRXaXRoICYmIHR5cGVvZiBzdGFydFdpdGggPT09ICdzdHJpbmcnKSB7XG4gICAgICBjbG9uZU9wdGlvbnMuc3RhcnRXaXRoID0gY2xvbmVPcHRpb25zLnN0YXJ0V2l0aC5zdGFydHNXaXRoKCckJykgP1xuICAgICAgICBjbG9uZU9wdGlvbnMuc3RhcnRXaXRoIDpcbiAgICAgICAgJyQnICsgY2xvbmVPcHRpb25zLnN0YXJ0V2l0aDtcbiAgICB9XG5cbiAgfVxuICByZXR1cm4gdGhpcy5hcHBlbmQoeyAkZ3JhcGhMb29rdXA6IGNsb25lT3B0aW9ucyB9KTtcbn07XG5cbi8qKlxuICogQXBwZW5kcyBuZXcgY3VzdG9tICRzYW1wbGUgb3BlcmF0b3IgdG8gdGhpcyBhZ2dyZWdhdGUgcGlwZWxpbmUuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBhZ2dyZWdhdGUuc2FtcGxlKDMpOyAvLyBBZGQgYSBwaXBlbGluZSB0aGF0IHBpY2tzIDMgcmFuZG9tIGRvY3VtZW50c1xuICpcbiAqIEBzZWUgJHNhbXBsZSBodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9yZWZlcmVuY2Uvb3BlcmF0b3IvYWdncmVnYXRpb24vc2FtcGxlLyNwaXBlLl9TX3NhbXBsZVxuICogQHBhcmFtIHtOdW1iZXJ9IHNpemUgbnVtYmVyIG9mIHJhbmRvbSBkb2N1bWVudHMgdG8gcGlja1xuICogQHJldHVybiB7QWdncmVnYXRlfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5BZ2dyZWdhdGUucHJvdG90eXBlLnNhbXBsZSA9IGZ1bmN0aW9uKHNpemUpIHtcbiAgcmV0dXJuIHRoaXMuYXBwZW5kKHsgJHNhbXBsZTogeyBzaXplOiBzaXplIH0gfSk7XG59O1xuXG4vKipcbiAqIEFwcGVuZHMgYSBuZXcgJHNvcnQgb3BlcmF0b3IgdG8gdGhpcyBhZ2dyZWdhdGUgcGlwZWxpbmUuXG4gKlxuICogSWYgYW4gb2JqZWN0IGlzIHBhc3NlZCwgdmFsdWVzIGFsbG93ZWQgYXJlIGBhc2NgLCBgZGVzY2AsIGBhc2NlbmRpbmdgLCBgZGVzY2VuZGluZ2AsIGAxYCwgYW5kIGAtMWAuXG4gKlxuICogSWYgYSBzdHJpbmcgaXMgcGFzc2VkLCBpdCBtdXN0IGJlIGEgc3BhY2UgZGVsaW1pdGVkIGxpc3Qgb2YgcGF0aCBuYW1lcy4gVGhlIHNvcnQgb3JkZXIgb2YgZWFjaCBwYXRoIGlzIGFzY2VuZGluZyB1bmxlc3MgdGhlIHBhdGggbmFtZSBpcyBwcmVmaXhlZCB3aXRoIGAtYCB3aGljaCB3aWxsIGJlIHRyZWF0ZWQgYXMgZGVzY2VuZGluZy5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIC8vIHRoZXNlIGFyZSBlcXVpdmFsZW50XG4gKiAgICAgYWdncmVnYXRlLnNvcnQoeyBmaWVsZDogJ2FzYycsIHRlc3Q6IC0xIH0pO1xuICogICAgIGFnZ3JlZ2F0ZS5zb3J0KCdmaWVsZCAtdGVzdCcpO1xuICpcbiAqIEBzZWUgJHNvcnQgaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvcmVmZXJlbmNlL2FnZ3JlZ2F0aW9uL3NvcnQvXG4gKiBAcGFyYW0ge09iamVjdHxTdHJpbmd9IGFyZ1xuICogQHJldHVybiB7QWdncmVnYXRlfSB0aGlzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkFnZ3JlZ2F0ZS5wcm90b3R5cGUuc29ydCA9IGZ1bmN0aW9uKGFyZykge1xuICAvLyBUT0RPIHJlZmFjdG9yIHRvIHJldXNlIHRoZSBxdWVyeSBidWlsZGVyIGxvZ2ljXG5cbiAgY29uc3Qgc29ydCA9IHt9O1xuXG4gIGlmIChnZXRDb25zdHJ1Y3Rvck5hbWUoYXJnKSA9PT0gJ09iamVjdCcpIHtcbiAgICBjb25zdCBkZXNjID0gWydkZXNjJywgJ2Rlc2NlbmRpbmcnLCAtMV07XG4gICAgT2JqZWN0LmtleXMoYXJnKS5mb3JFYWNoKGZ1bmN0aW9uKGZpZWxkKSB7XG4gICAgICAvLyBJZiBzb3J0aW5nIGJ5IHRleHQgc2NvcmUsIHNraXAgY29lcmNpbmcgaW50byAxLy0xXG4gICAgICBpZiAoYXJnW2ZpZWxkXSBpbnN0YW5jZW9mIE9iamVjdCAmJiBhcmdbZmllbGRdLiRtZXRhKSB7XG4gICAgICAgIHNvcnRbZmllbGRdID0gYXJnW2ZpZWxkXTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgc29ydFtmaWVsZF0gPSBkZXNjLmluZGV4T2YoYXJnW2ZpZWxkXSkgPT09IC0xID8gMSA6IC0xO1xuICAgIH0pO1xuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEgJiYgdHlwZW9mIGFyZyA9PT0gJ3N0cmluZycpIHtcbiAgICBhcmcuc3BsaXQoL1xccysvKS5mb3JFYWNoKGZ1bmN0aW9uKGZpZWxkKSB7XG4gICAgICBpZiAoIWZpZWxkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGFzY2VuZCA9IGZpZWxkWzBdID09PSAnLScgPyAtMSA6IDE7XG4gICAgICBpZiAoYXNjZW5kID09PSAtMSkge1xuICAgICAgICBmaWVsZCA9IGZpZWxkLnN1YnN0cmluZygxKTtcbiAgICAgIH1cbiAgICAgIHNvcnRbZmllbGRdID0gYXNjZW5kO1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgc29ydCgpIGFyZ3VtZW50LiBNdXN0IGJlIGEgc3RyaW5nIG9yIG9iamVjdC4nKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzLmFwcGVuZCh7ICRzb3J0OiBzb3J0IH0pO1xufTtcblxuLyoqXG4gKiBBcHBlbmRzIG5ldyAkdW5pb25XaXRoIG9wZXJhdG9yIHRvIHRoaXMgYWdncmVnYXRlIHBpcGVsaW5lLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgYWdncmVnYXRlLnVuaW9uV2l0aCh7IGNvbGw6ICd1c2VycycsIHBpcGVsaW5lOiBbIHsgJG1hdGNoOiB7IF9pZDogMSB9IH0gXSB9KTtcbiAqXG4gKiBAc2VlICR1bmlvbldpdGggaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvcmVmZXJlbmNlL29wZXJhdG9yL2FnZ3JlZ2F0aW9uL3VuaW9uV2l0aFxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgdG8gJHVuaW9uV2l0aCBxdWVyeSBhcyBkZXNjcmliZWQgaW4gdGhlIGFib3ZlIGxpbmtcbiAqIEByZXR1cm4ge0FnZ3JlZ2F0ZX1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuQWdncmVnYXRlLnByb3RvdHlwZS51bmlvbldpdGggPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gIHJldHVybiB0aGlzLmFwcGVuZCh7ICR1bmlvbldpdGg6IG9wdGlvbnMgfSk7XG59O1xuXG5cbi8qKlxuICogU2V0cyB0aGUgcmVhZFByZWZlcmVuY2Ugb3B0aW9uIGZvciB0aGUgYWdncmVnYXRpb24gcXVlcnkuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBhd2FpdCBNb2RlbC5hZ2dyZWdhdGUocGlwZWxpbmUpLnJlYWQoJ3ByaW1hcnlQcmVmZXJyZWQnKTtcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ3xSZWFkUHJlZmVyZW5jZX0gcHJlZiBvbmUgb2YgdGhlIGxpc3RlZCBwcmVmZXJlbmNlIG9wdGlvbnMgb3IgdGhlaXIgYWxpYXNlc1xuICogQHBhcmFtIHtBcnJheX0gW3RhZ3NdIG9wdGlvbmFsIHRhZ3MgZm9yIHRoaXMgcXVlcnkuXG4gKiBAcmV0dXJuIHtBZ2dyZWdhdGV9IHRoaXNcbiAqIEBhcGkgcHVibGljXG4gKiBAc2VlIG1vbmdvZGIgaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvYXBwbGljYXRpb25zL3JlcGxpY2F0aW9uLyNyZWFkLXByZWZlcmVuY2VcbiAqL1xuXG5BZ2dyZWdhdGUucHJvdG90eXBlLnJlYWQgPSBmdW5jdGlvbihwcmVmLCB0YWdzKSB7XG4gIHJlYWQuY2FsbCh0aGlzLCBwcmVmLCB0YWdzKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNldHMgdGhlIHJlYWRDb25jZXJuIGxldmVsIGZvciB0aGUgYWdncmVnYXRpb24gcXVlcnkuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBhd2FpdCBNb2RlbC5hZ2dyZWdhdGUocGlwZWxpbmUpLnJlYWRDb25jZXJuKCdtYWpvcml0eScpO1xuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBsZXZlbCBvbmUgb2YgdGhlIGxpc3RlZCByZWFkIGNvbmNlcm4gbGV2ZWwgb3IgdGhlaXIgYWxpYXNlc1xuICogQHNlZSBtb25nb2RiIGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvbWFudWFsL3JlZmVyZW5jZS9yZWFkLWNvbmNlcm4vXG4gKiBAcmV0dXJuIHtBZ2dyZWdhdGV9IHRoaXNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuQWdncmVnYXRlLnByb3RvdHlwZS5yZWFkQ29uY2VybiA9IGZ1bmN0aW9uKGxldmVsKSB7XG4gIHJlYWRDb25jZXJuLmNhbGwodGhpcywgbGV2ZWwpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQXBwZW5kcyBhIG5ldyAkcmVkYWN0IG9wZXJhdG9yIHRvIHRoaXMgYWdncmVnYXRlIHBpcGVsaW5lLlxuICpcbiAqIElmIDMgYXJndW1lbnRzIGFyZSBzdXBwbGllZCwgTW9uZ29vc2Ugd2lsbCB3cmFwIHRoZW0gd2l0aCBpZi10aGVuLWVsc2Ugb2YgJGNvbmQgb3BlcmF0b3IgcmVzcGVjdGl2ZWx5XG4gKiBJZiBgdGhlbkV4cHJgIG9yIGBlbHNlRXhwcmAgaXMgc3RyaW5nLCBtYWtlIHN1cmUgaXQgc3RhcnRzIHdpdGggJCQsIGxpa2UgYCQkREVTQ0VORGAsIGAkJFBSVU5FYCBvciBgJCRLRUVQYC5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGF3YWl0IE1vZGVsLmFnZ3JlZ2F0ZShwaXBlbGluZSkucmVkYWN0KHtcbiAqICAgICAgICRjb25kOiB7XG4gKiAgICAgICAgIGlmOiB7ICRlcTogWyAnJGxldmVsJywgNSBdIH0sXG4gKiAgICAgICAgIHRoZW46ICckJFBSVU5FJyxcbiAqICAgICAgICAgZWxzZTogJyQkREVTQ0VORCdcbiAqICAgICAgIH1cbiAqICAgICB9KTtcbiAqXG4gKiAgICAgLy8gJHJlZGFjdCBvZnRlbiBjb21lcyB3aXRoICRjb25kIG9wZXJhdG9yLCB5b3UgY2FuIGFsc28gdXNlIHRoZSBmb2xsb3dpbmcgc3ludGF4IHByb3ZpZGVkIGJ5IG1vbmdvb3NlXG4gKiAgICAgYXdhaXQgTW9kZWwuYWdncmVnYXRlKHBpcGVsaW5lKS5yZWRhY3QoeyAkZXE6IFsgJyRsZXZlbCcsIDUgXSB9LCAnJCRQUlVORScsICckJERFU0NFTkQnKTtcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gZXhwcmVzc2lvbiByZWRhY3Qgb3B0aW9ucyBvciBjb25kaXRpb25hbCBleHByZXNzaW9uXG4gKiBAcGFyYW0ge1N0cmluZ3xPYmplY3R9IFt0aGVuRXhwcl0gdHJ1ZSBjYXNlIGZvciB0aGUgY29uZGl0aW9uXG4gKiBAcGFyYW0ge1N0cmluZ3xPYmplY3R9IFtlbHNlRXhwcl0gZmFsc2UgY2FzZSBmb3IgdGhlIGNvbmRpdGlvblxuICogQHJldHVybiB7QWdncmVnYXRlfSB0aGlzXG4gKiBAc2VlICRyZWRhY3QgaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvcmVmZXJlbmNlL29wZXJhdG9yL2FnZ3JlZ2F0aW9uL3JlZGFjdC9cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuQWdncmVnYXRlLnByb3RvdHlwZS5yZWRhY3QgPSBmdW5jdGlvbihleHByZXNzaW9uLCB0aGVuRXhwciwgZWxzZUV4cHIpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDMpIHtcbiAgICBpZiAoKHR5cGVvZiB0aGVuRXhwciA9PT0gJ3N0cmluZycgJiYgIXZhbGlkUmVkYWN0U3RyaW5nVmFsdWVzLmhhcyh0aGVuRXhwcikpIHx8XG4gICAgICAodHlwZW9mIGVsc2VFeHByID09PSAnc3RyaW5nJyAmJiAhdmFsaWRSZWRhY3RTdHJpbmdWYWx1ZXMuaGFzKGVsc2VFeHByKSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSWYgdGhlbkV4cHIgb3IgZWxzZUV4cHIgaXMgc3RyaW5nLCBpdCBtdXN0IGJlIGVpdGhlciAkJERFU0NFTkQsICQkUFJVTkUgb3IgJCRLRUVQJyk7XG4gICAgfVxuXG4gICAgZXhwcmVzc2lvbiA9IHtcbiAgICAgICRjb25kOiB7XG4gICAgICAgIGlmOiBleHByZXNzaW9uLFxuICAgICAgICB0aGVuOiB0aGVuRXhwcixcbiAgICAgICAgZWxzZTogZWxzZUV4cHJcbiAgICAgIH1cbiAgICB9O1xuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggIT09IDEpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIGFyZ3VtZW50cycpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXMuYXBwZW5kKHsgJHJlZGFjdDogZXhwcmVzc2lvbiB9KTtcbn07XG5cbi8qKlxuICogRXhlY3V0ZSB0aGUgYWdncmVnYXRpb24gd2l0aCBleHBsYWluXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBNb2RlbC5hZ2dyZWdhdGUoLi4pLmV4cGxhaW4oKVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBbdmVyYm9zaXR5XVxuICogQHJldHVybiB7UHJvbWlzZX1cbiAqL1xuXG5BZ2dyZWdhdGUucHJvdG90eXBlLmV4cGxhaW4gPSBhc3luYyBmdW5jdGlvbiBleHBsYWluKHZlcmJvc2l0eSkge1xuICBpZiAodHlwZW9mIHZlcmJvc2l0eSA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgYXJndW1lbnRzWzFdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IE1vbmdvb3NlRXJyb3IoJ0FnZ3JlZ2F0ZS5wcm90b3R5cGUuZXhwbGFpbigpIG5vIGxvbmdlciBhY2NlcHRzIGEgY2FsbGJhY2snKTtcbiAgfVxuICBjb25zdCBtb2RlbCA9IHRoaXMuX21vZGVsO1xuXG4gIGlmICghdGhpcy5fcGlwZWxpbmUubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdBZ2dyZWdhdGUgaGFzIGVtcHR5IHBpcGVsaW5lJyk7XG4gIH1cblxuICBwcmVwYXJlRGlzY3JpbWluYXRvclBpcGVsaW5lKHRoaXMuX3BpcGVsaW5lLCB0aGlzLl9tb2RlbC5zY2hlbWEpO1xuXG4gIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBtb2RlbC5ob29rcy5leGVjUHJlKCdhZ2dyZWdhdGUnLCB0aGlzLCBlcnJvciA9PiB7XG4gICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgY29uc3QgX29wdHMgPSB7IGVycm9yOiBlcnJvciB9O1xuICAgICAgICByZXR1cm4gbW9kZWwuaG9va3MuZXhlY1Bvc3QoJ2FnZ3JlZ2F0ZScsIHRoaXMsIFtudWxsXSwgX29wdHMsIGVycm9yID0+IHtcbiAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc29sdmUoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG5cbiAgY29uc3QgY3Vyc29yID0gbW9kZWwuY29sbGVjdGlvbi5hZ2dyZWdhdGUodGhpcy5fcGlwZWxpbmUsIHRoaXMub3B0aW9ucyk7XG5cbiAgaWYgKHZlcmJvc2l0eSA9PSBudWxsKSB7XG4gICAgdmVyYm9zaXR5ID0gdHJ1ZTtcbiAgfVxuXG4gIGxldCByZXN1bHQgPSBudWxsO1xuICB0cnkge1xuICAgIHJlc3VsdCA9IGF3YWl0IGN1cnNvci5leHBsYWluKHZlcmJvc2l0eSk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgY29uc3QgX29wdHMgPSB7IGVycm9yOiBlcnJvciB9O1xuICAgICAgbW9kZWwuaG9va3MuZXhlY1Bvc3QoJ2FnZ3JlZ2F0ZScsIHRoaXMsIFtudWxsXSwgX29wdHMsIGVycm9yID0+IHtcbiAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgcmV0dXJuIHJlamVjdChlcnJvcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc29sdmUoKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgY29uc3QgX29wdHMgPSB7IGVycm9yOiBudWxsIH07XG4gIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBtb2RlbC5ob29rcy5leGVjUG9zdCgnYWdncmVnYXRlJywgdGhpcywgW3Jlc3VsdF0sIF9vcHRzLCBlcnJvciA9PiB7XG4gICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIHJlamVjdChlcnJvcik7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzb2x2ZSgpO1xuICAgIH0pO1xuICB9KTtcblxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBTZXRzIHRoZSBhbGxvd0Rpc2tVc2Ugb3B0aW9uIGZvciB0aGUgYWdncmVnYXRpb24gcXVlcnlcbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGF3YWl0IE1vZGVsLmFnZ3JlZ2F0ZShbeyAkbWF0Y2g6IHsgZm9vOiAnYmFyJyB9IH1dKS5hbGxvd0Rpc2tVc2UodHJ1ZSk7XG4gKlxuICogQHBhcmFtIHtCb29sZWFufSB2YWx1ZSBTaG91bGQgdGVsbCBzZXJ2ZXIgaXQgY2FuIHVzZSBoYXJkIGRyaXZlIHRvIHN0b3JlIGRhdGEgZHVyaW5nIGFnZ3JlZ2F0aW9uLlxuICogQHJldHVybiB7QWdncmVnYXRlfSB0aGlzXG4gKiBAc2VlIG1vbmdvZGIgaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvcmVmZXJlbmNlL2NvbW1hbmQvYWdncmVnYXRlL1xuICovXG5cbkFnZ3JlZ2F0ZS5wcm90b3R5cGUuYWxsb3dEaXNrVXNlID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgdGhpcy5vcHRpb25zLmFsbG93RGlza1VzZSA9IHZhbHVlO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2V0cyB0aGUgaGludCBvcHRpb24gZm9yIHRoZSBhZ2dyZWdhdGlvbiBxdWVyeVxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgTW9kZWwuYWdncmVnYXRlKC4uKS5oaW50KHsgcXR5OiAxLCBjYXRlZ29yeTogMSB9KS5leGVjKCk7XG4gKlxuICogQHBhcmFtIHtPYmplY3R8U3RyaW5nfSB2YWx1ZSBhIGhpbnQgb2JqZWN0IG9yIHRoZSBpbmRleCBuYW1lXG4gKiBAcmV0dXJuIHtBZ2dyZWdhdGV9IHRoaXNcbiAqIEBzZWUgbW9uZ29kYiBodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9yZWZlcmVuY2UvY29tbWFuZC9hZ2dyZWdhdGUvXG4gKi9cblxuQWdncmVnYXRlLnByb3RvdHlwZS5oaW50ID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgdGhpcy5vcHRpb25zLmhpbnQgPSB2YWx1ZTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNldHMgdGhlIHNlc3Npb24gZm9yIHRoaXMgYWdncmVnYXRpb24uIFVzZWZ1bCBmb3IgW3RyYW5zYWN0aW9uc10oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL3RyYW5zYWN0aW9ucy5odG1sKS5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IHNlc3Npb24gPSBhd2FpdCBNb2RlbC5zdGFydFNlc3Npb24oKTtcbiAqICAgICBhd2FpdCBNb2RlbC5hZ2dyZWdhdGUoLi4pLnNlc3Npb24oc2Vzc2lvbik7XG4gKlxuICogQHBhcmFtIHtDbGllbnRTZXNzaW9ufSBzZXNzaW9uXG4gKiBAcmV0dXJuIHtBZ2dyZWdhdGV9IHRoaXNcbiAqIEBzZWUgbW9uZ29kYiBodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9yZWZlcmVuY2UvY29tbWFuZC9hZ2dyZWdhdGUvXG4gKi9cblxuQWdncmVnYXRlLnByb3RvdHlwZS5zZXNzaW9uID0gZnVuY3Rpb24oc2Vzc2lvbikge1xuICBpZiAoc2Vzc2lvbiA9PSBudWxsKSB7XG4gICAgZGVsZXRlIHRoaXMub3B0aW9ucy5zZXNzaW9uO1xuICB9IGVsc2Uge1xuICAgIHRoaXMub3B0aW9ucy5zZXNzaW9uID0gc2Vzc2lvbjtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogTGV0cyB5b3Ugc2V0IGFyYml0cmFyeSBvcHRpb25zLCBmb3IgbWlkZGxld2FyZSBvciBwbHVnaW5zLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgY29uc3QgYWdnID0gTW9kZWwuYWdncmVnYXRlKC4uKS5vcHRpb24oeyBhbGxvd0Rpc2tVc2U6IHRydWUgfSk7IC8vIFNldCB0aGUgYGFsbG93RGlza1VzZWAgb3B0aW9uXG4gKiAgICAgYWdnLm9wdGlvbnM7IC8vIGB7IGFsbG93RGlza1VzZTogdHJ1ZSB9YFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIGtleXMgdG8gbWVyZ2UgaW50byBjdXJyZW50IG9wdGlvbnNcbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5tYXhUaW1lTVNdIG51bWJlciBsaW1pdHMgdGhlIHRpbWUgdGhpcyBhZ2dyZWdhdGlvbiB3aWxsIHJ1biwgc2VlIFtNb25nb0RCIGRvY3Mgb24gYG1heFRpbWVNU2BdKGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvbWFudWFsL3JlZmVyZW5jZS9vcGVyYXRvci9tZXRhL21heFRpbWVNUy8pXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmFsbG93RGlza1VzZV0gYm9vbGVhbiBpZiB0cnVlLCB0aGUgTW9uZ29EQiBzZXJ2ZXIgd2lsbCB1c2UgdGhlIGhhcmQgZHJpdmUgdG8gc3RvcmUgZGF0YSBkdXJpbmcgdGhpcyBhZ2dyZWdhdGlvblxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLmNvbGxhdGlvbl0gb2JqZWN0IHNlZSBbYEFnZ3JlZ2F0ZS5wcm90b3R5cGUuY29sbGF0aW9uKClgXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvYXBpL2FnZ3JlZ2F0ZS5odG1sI0FnZ3JlZ2F0ZS5wcm90b3R5cGUuY29sbGF0aW9uKCkpXG4gKiBAcGFyYW0ge0NsaWVudFNlc3Npb259IFtvcHRpb25zLnNlc3Npb25dIENsaWVudFNlc3Npb24gc2VlIFtgQWdncmVnYXRlLnByb3RvdHlwZS5zZXNzaW9uKClgXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvYXBpL2FnZ3JlZ2F0ZS5odG1sI0FnZ3JlZ2F0ZS5wcm90b3R5cGUuc2Vzc2lvbigpKVxuICogQHNlZSBtb25nb2RiIGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvbWFudWFsL3JlZmVyZW5jZS9jb21tYW5kL2FnZ3JlZ2F0ZS9cbiAqIEByZXR1cm4ge0FnZ3JlZ2F0ZX0gdGhpc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5BZ2dyZWdhdGUucHJvdG90eXBlLm9wdGlvbiA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gIGZvciAoY29uc3Qga2V5IGluIHZhbHVlKSB7XG4gICAgdGhpcy5vcHRpb25zW2tleV0gPSB2YWx1ZVtrZXldO1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZXRzIHRoZSBgY3Vyc29yYCBvcHRpb24gYW5kIGV4ZWN1dGVzIHRoaXMgYWdncmVnYXRpb24sIHJldHVybmluZyBhbiBhZ2dyZWdhdGlvbiBjdXJzb3IuXG4gKiBDdXJzb3JzIGFyZSB1c2VmdWwgaWYgeW91IHdhbnQgdG8gcHJvY2VzcyB0aGUgcmVzdWx0cyBvZiB0aGUgYWdncmVnYXRpb24gb25lLWF0LWEtdGltZVxuICogYmVjYXVzZSB0aGUgYWdncmVnYXRpb24gcmVzdWx0IGlzIHRvbyBiaWcgdG8gZml0IGludG8gbWVtb3J5LlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgY29uc3QgY3Vyc29yID0gTW9kZWwuYWdncmVnYXRlKC4uKS5jdXJzb3IoeyBiYXRjaFNpemU6IDEwMDAgfSk7XG4gKiAgICAgY3Vyc29yLmVhY2hBc3luYyhmdW5jdGlvbihkb2MsIGkpIHtcbiAqICAgICAgIC8vIHVzZSBkb2NcbiAqICAgICB9KTtcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmJhdGNoU2l6ZV0gc2V0IHRoZSBjdXJzb3IgYmF0Y2ggc2l6ZVxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy51c2VNb25nb29zZUFnZ0N1cnNvcl0gdXNlIGV4cGVyaW1lbnRhbCBtb25nb29zZS1zcGVjaWZpYyBhZ2dyZWdhdGlvbiBjdXJzb3IgKGZvciBgZWFjaEFzeW5jKClgIGFuZCBvdGhlciBxdWVyeSBjdXJzb3Igc2VtYW50aWNzKVxuICogQHJldHVybiB7QWdncmVnYXRpb25DdXJzb3J9IGN1cnNvciByZXByZXNlbnRpbmcgdGhpcyBhZ2dyZWdhdGlvblxuICogQGFwaSBwdWJsaWNcbiAqIEBzZWUgbW9uZ29kYiBodHRwczovL21vbmdvZGIuZ2l0aHViLmlvL25vZGUtbW9uZ29kYi1uYXRpdmUvNC45L2NsYXNzZXMvQWdncmVnYXRpb25DdXJzb3IuaHRtbFxuICovXG5cbkFnZ3JlZ2F0ZS5wcm90b3R5cGUuY3Vyc29yID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICB0aGlzLm9wdGlvbnMuY3Vyc29yID0gb3B0aW9ucyB8fCB7fTtcbiAgcmV0dXJuIG5ldyBBZ2dyZWdhdGlvbkN1cnNvcih0aGlzKTsgLy8gcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEFkZHMgYSBjb2xsYXRpb25cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IHJlcyA9IGF3YWl0IE1vZGVsLmFnZ3JlZ2F0ZShwaXBlbGluZSkuY29sbGF0aW9uKHsgbG9jYWxlOiAnZW5fVVMnLCBzdHJlbmd0aDogMSB9KTtcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gY29sbGF0aW9uIG9wdGlvbnNcbiAqIEByZXR1cm4ge0FnZ3JlZ2F0ZX0gdGhpc1xuICogQGFwaSBwdWJsaWNcbiAqIEBzZWUgbW9uZ29kYiBodHRwczovL21vbmdvZGIuZ2l0aHViLmlvL25vZGUtbW9uZ29kYi1uYXRpdmUvNC45L2ludGVyZmFjZXMvQ29sbGF0aW9uT3B0aW9ucy5odG1sXG4gKi9cblxuQWdncmVnYXRlLnByb3RvdHlwZS5jb2xsYXRpb24gPSBmdW5jdGlvbihjb2xsYXRpb24pIHtcbiAgdGhpcy5vcHRpb25zLmNvbGxhdGlvbiA9IGNvbGxhdGlvbjtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIENvbWJpbmVzIG11bHRpcGxlIGFnZ3JlZ2F0aW9uIHBpcGVsaW5lcy5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IHJlcyA9IGF3YWl0IE1vZGVsLmFnZ3JlZ2F0ZSgpLmZhY2V0KHtcbiAqICAgICAgIGJvb2tzOiBbeyBncm91cEJ5OiAnJGF1dGhvcicgfV0sXG4gKiAgICAgICBwcmljZTogW3sgJGJ1Y2tldEF1dG86IHsgZ3JvdXBCeTogJyRwcmljZScsIGJ1Y2tldHM6IDIgfSB9XVxuICogICAgIH0pO1xuICpcbiAqICAgICAvLyBPdXRwdXQ6IHsgYm9va3M6IFsuLi5dLCBwcmljZTogW3suLi59LCB7Li4ufV0gfVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBmYWNldCBvcHRpb25zXG4gKiBAcmV0dXJuIHtBZ2dyZWdhdGV9IHRoaXNcbiAqIEBzZWUgJGZhY2V0IGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvbWFudWFsL3JlZmVyZW5jZS9vcGVyYXRvci9hZ2dyZWdhdGlvbi9mYWNldC9cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuQWdncmVnYXRlLnByb3RvdHlwZS5mYWNldCA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgcmV0dXJuIHRoaXMuYXBwZW5kKHsgJGZhY2V0OiBvcHRpb25zIH0pO1xufTtcblxuLyoqXG4gKiBIZWxwZXIgZm9yIFtBdGxhcyBUZXh0IFNlYXJjaF0oaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9hdGxhcy9hdGxhcy1zZWFyY2gvdHV0b3JpYWwvKSdzXG4gKiBgJHNlYXJjaGAgc3RhZ2UuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBjb25zdCByZXMgPSBhd2FpdCBNb2RlbC5hZ2dyZWdhdGUoKS5cbiAqICAgICAgc2VhcmNoKHtcbiAqICAgICAgICB0ZXh0OiB7XG4gKiAgICAgICAgICBxdWVyeTogJ2Jhc2ViYWxsJyxcbiAqICAgICAgICAgIHBhdGg6ICdwbG90J1xuICogICAgICAgIH1cbiAqICAgICAgfSk7XG4gKlxuICogICAgIC8vIE91dHB1dDogW3sgcGxvdDogJy4uLicsIHRpdGxlOiAnLi4uJyB9XVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSAkc2VhcmNoIG9wdGlvbnNcbiAqIEByZXR1cm4ge0FnZ3JlZ2F0ZX0gdGhpc1xuICogQHNlZSAkc2VhcmNoIGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvYXRsYXMvYXRsYXMtc2VhcmNoL3R1dG9yaWFsL1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5BZ2dyZWdhdGUucHJvdG90eXBlLnNlYXJjaCA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgcmV0dXJuIHRoaXMuYXBwZW5kKHsgJHNlYXJjaDogb3B0aW9ucyB9KTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgY3VycmVudCBwaXBlbGluZVxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgTXlNb2RlbC5hZ2dyZWdhdGUoKS5tYXRjaCh7IHRlc3Q6IDEgfSkucGlwZWxpbmUoKTsgLy8gW3sgJG1hdGNoOiB7IHRlc3Q6IDEgfSB9XVxuICpcbiAqIEByZXR1cm4ge0FycmF5fSBUaGUgY3VycmVudCBwaXBlbGluZSBzaW1pbGFyIHRvIHRoZSBvcGVyYXRpb24gdGhhdCB3aWxsIGJlIGV4ZWN1dGVkXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkFnZ3JlZ2F0ZS5wcm90b3R5cGUucGlwZWxpbmUgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX3BpcGVsaW5lO1xufTtcblxuLyoqXG4gKiBFeGVjdXRlcyB0aGUgYWdncmVnYXRlIHBpcGVsaW5lIG9uIHRoZSBjdXJyZW50bHkgYm91bmQgTW9kZWwuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICogICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGFnZ3JlZ2F0ZS5leGVjKCk7XG4gKlxuICogQHJldHVybiB7UHJvbWlzZX1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuQWdncmVnYXRlLnByb3RvdHlwZS5leGVjID0gYXN5bmMgZnVuY3Rpb24gZXhlYygpIHtcbiAgaWYgKCF0aGlzLl9tb2RlbCkge1xuICAgIHRocm93IG5ldyBFcnJvcignQWdncmVnYXRlIG5vdCBib3VuZCB0byBhbnkgTW9kZWwnKTtcbiAgfVxuICBpZiAodHlwZW9mIGFyZ3VtZW50c1swXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBNb25nb29zZUVycm9yKCdBZ2dyZWdhdGUucHJvdG90eXBlLmV4ZWMoKSBubyBsb25nZXIgYWNjZXB0cyBhIGNhbGxiYWNrJyk7XG4gIH1cbiAgY29uc3QgbW9kZWwgPSB0aGlzLl9tb2RlbDtcbiAgY29uc3QgY29sbGVjdGlvbiA9IHRoaXMuX21vZGVsLmNvbGxlY3Rpb247XG5cbiAgYXBwbHlHbG9iYWxNYXhUaW1lTVModGhpcy5vcHRpb25zLCBtb2RlbC5kYi5vcHRpb25zLCBtb2RlbC5iYXNlLm9wdGlvbnMpO1xuICBhcHBseUdsb2JhbERpc2tVc2UodGhpcy5vcHRpb25zLCBtb2RlbC5kYi5vcHRpb25zLCBtb2RlbC5iYXNlLm9wdGlvbnMpO1xuXG4gIGlmICh0aGlzLm9wdGlvbnMgJiYgdGhpcy5vcHRpb25zLmN1cnNvcikge1xuICAgIHJldHVybiBuZXcgQWdncmVnYXRpb25DdXJzb3IodGhpcyk7XG4gIH1cblxuICBwcmVwYXJlRGlzY3JpbWluYXRvclBpcGVsaW5lKHRoaXMuX3BpcGVsaW5lLCB0aGlzLl9tb2RlbC5zY2hlbWEpO1xuICBzdHJpbmdpZnlGdW5jdGlvbk9wZXJhdG9ycyh0aGlzLl9waXBlbGluZSk7XG5cbiAgYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIG1vZGVsLmhvb2tzLmV4ZWNQcmUoJ2FnZ3JlZ2F0ZScsIHRoaXMsIGVycm9yID0+IHtcbiAgICAgIGlmIChlcnJvcikge1xuICAgICAgICBjb25zdCBfb3B0cyA9IHsgZXJyb3I6IGVycm9yIH07XG4gICAgICAgIHJldHVybiBtb2RlbC5ob29rcy5leGVjUG9zdCgnYWdncmVnYXRlJywgdGhpcywgW251bGxdLCBfb3B0cywgZXJyb3IgPT4ge1xuICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcblxuICBpZiAoIXRoaXMuX3BpcGVsaW5lLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBNb25nb29zZUVycm9yKCdBZ2dyZWdhdGUgaGFzIGVtcHR5IHBpcGVsaW5lJyk7XG4gIH1cblxuICBjb25zdCBvcHRpb25zID0gY2xvbmUodGhpcy5vcHRpb25zIHx8IHt9KTtcbiAgbGV0IHJlc3VsdDtcbiAgdHJ5IHtcbiAgICBjb25zdCBjdXJzb3IgPSBhd2FpdCBjb2xsZWN0aW9uLmFnZ3JlZ2F0ZSh0aGlzLl9waXBlbGluZSwgb3B0aW9ucyk7XG4gICAgcmVzdWx0ID0gYXdhaXQgY3Vyc29yLnRvQXJyYXkoKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBjb25zdCBfb3B0cyA9IHsgZXJyb3I6IGVycm9yIH07XG4gICAgICBtb2RlbC5ob29rcy5leGVjUG9zdCgnYWdncmVnYXRlJywgdGhpcywgW251bGxdLCBfb3B0cywgKGVycm9yKSA9PiB7XG4gICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgIHJldHVybiByZWplY3QoZXJyb3IpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICBjb25zdCBfb3B0cyA9IHsgZXJyb3I6IG51bGwgfTtcbiAgYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIG1vZGVsLmhvb2tzLmV4ZWNQb3N0KCdhZ2dyZWdhdGUnLCB0aGlzLCBbcmVzdWx0XSwgX29wdHMsIGVycm9yID0+IHtcbiAgICAgIGlmIChlcnJvcikge1xuICAgICAgICByZXR1cm4gcmVqZWN0KGVycm9yKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXNvbHZlKCk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIFByb3ZpZGVzIGEgUHJvbWlzZS1saWtlIGB0aGVuYCBmdW5jdGlvbiwgd2hpY2ggd2lsbCBjYWxsIGAuZXhlY2Agd2l0aG91dCBhIGNhbGxiYWNrXG4gKiBDb21wYXRpYmxlIHdpdGggYGF3YWl0YC5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIE1vZGVsLmFnZ3JlZ2F0ZSguLikudGhlbihzdWNjZXNzQ2FsbGJhY2ssIGVycm9yQ2FsbGJhY2spO1xuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtyZXNvbHZlXSBzdWNjZXNzQ2FsbGJhY2tcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtyZWplY3RdICBlcnJvckNhbGxiYWNrXG4gKiBAcmV0dXJuIHtQcm9taXNlfVxuICovXG5BZ2dyZWdhdGUucHJvdG90eXBlLnRoZW4gPSBmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgcmV0dXJuIHRoaXMuZXhlYygpLnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcbn07XG5cbi8qKlxuICogRXhlY3V0ZXMgdGhlIGFnZ3JlZ2F0aW9uIHJldHVybmluZyBhIGBQcm9taXNlYCB3aGljaCB3aWxsIGJlXG4gKiByZXNvbHZlZCB3aXRoIGVpdGhlciB0aGUgZG9jKHMpIG9yIHJlamVjdGVkIHdpdGggdGhlIGVycm9yLlxuICogTGlrZSBbYC50aGVuKClgXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvYXBpL3F1ZXJ5Lmh0bWwjUXVlcnkucHJvdG90eXBlLnRoZW4pLCBidXQgb25seSB0YWtlcyBhIHJlamVjdGlvbiBoYW5kbGVyLlxuICogQ29tcGF0aWJsZSB3aXRoIGBhd2FpdGAuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW3JlamVjdF1cbiAqIEByZXR1cm4ge1Byb21pc2V9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkFnZ3JlZ2F0ZS5wcm90b3R5cGUuY2F0Y2ggPSBmdW5jdGlvbihyZWplY3QpIHtcbiAgcmV0dXJuIHRoaXMuZXhlYygpLnRoZW4obnVsbCwgcmVqZWN0KTtcbn07XG5cbi8qKlxuICogRXhlY3V0ZXMgdGhlIGFnZ3JlZ2F0ZSByZXR1cm5pbmcgYSBgUHJvbWlzZWAgd2hpY2ggd2lsbCBiZVxuICogcmVzb2x2ZWQgd2l0aCBgLmZpbmFsbHkoKWAgY2hhaW5lZC5cbiAqXG4gKiBNb3JlIGFib3V0IFtQcm9taXNlIGBmaW5hbGx5KClgIGluIEphdmFTY3JpcHRdKGh0dHBzOi8vdGhlY29kZWJhcmJhcmlhbi5jb20vdXNpbmctcHJvbWlzZS1maW5hbGx5LWluLW5vZGUtanMuaHRtbCkuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW29uRmluYWxseV1cbiAqIEByZXR1cm4ge1Byb21pc2V9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkFnZ3JlZ2F0ZS5wcm90b3R5cGUuZmluYWxseSA9IGZ1bmN0aW9uKG9uRmluYWxseSkge1xuICByZXR1cm4gdGhpcy5leGVjKCkuZmluYWxseShvbkZpbmFsbHkpO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIGFuIGFzeW5jSXRlcmF0b3IgZm9yIHVzZSB3aXRoIFtgZm9yL2F3YWl0L29mYCBsb29wc10oaHR0cHM6Ly90aGVjb2RlYmFyYmFyaWFuLmNvbS9nZXR0aW5nLXN0YXJ0ZWQtd2l0aC1hc3luYy1pdGVyYXRvcnMtaW4tbm9kZS1qcylcbiAqIFlvdSBkbyBub3QgbmVlZCB0byBjYWxsIHRoaXMgZnVuY3Rpb24gZXhwbGljaXRseSwgdGhlIEphdmFTY3JpcHQgcnVudGltZVxuICogd2lsbCBjYWxsIGl0IGZvciB5b3UuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBjb25zdCBhZ2cgPSBNb2RlbC5hZ2dyZWdhdGUoW3sgJG1hdGNoOiB7IGFnZTogeyAkZ3RlOiAyNSB9IH0gfV0pO1xuICogICAgIGZvciBhd2FpdCAoY29uc3QgZG9jIG9mIGFnZykge1xuICogICAgICAgY29uc29sZS5sb2coZG9jLm5hbWUpO1xuICogICAgIH1cbiAqXG4gKiBOb2RlLmpzIDEwLnggc3VwcG9ydHMgYXN5bmMgaXRlcmF0b3JzIG5hdGl2ZWx5IHdpdGhvdXQgYW55IGZsYWdzLiBZb3UgY2FuXG4gKiBlbmFibGUgYXN5bmMgaXRlcmF0b3JzIGluIE5vZGUuanMgOC54IHVzaW5nIHRoZSBbYC0taGFybW9ueV9hc3luY19pdGVyYXRpb25gIGZsYWddKGh0dHBzOi8vZ2l0aHViLmNvbS90YzM5L3Byb3Bvc2FsLWFzeW5jLWl0ZXJhdGlvbi9pc3N1ZXMvMTE3I2lzc3VlY29tbWVudC0zNDY2OTUxODcpLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIGZ1bmN0aW9uIGlzIG5vdCBzZXQgaWYgYFN5bWJvbC5hc3luY0l0ZXJhdG9yYCBpcyB1bmRlZmluZWQuIElmXG4gKiBgU3ltYm9sLmFzeW5jSXRlcmF0b3JgIGlzIHVuZGVmaW5lZCwgdGhhdCBtZWFucyB5b3VyIE5vZGUuanMgdmVyc2lvbiBkb2VzIG5vdFxuICogc3VwcG9ydCBhc3luYyBpdGVyYXRvcnMuXG4gKlxuICogQG1ldGhvZCBbU3ltYm9sLmFzeW5jSXRlcmF0b3JdXG4gKiBAbWVtYmVyT2YgQWdncmVnYXRlXG4gKiBAaW5zdGFuY2VcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuaWYgKFN5bWJvbC5hc3luY0l0ZXJhdG9yICE9IG51bGwpIHtcbiAgQWdncmVnYXRlLnByb3RvdHlwZVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5jdXJzb3IoeyB1c2VNb25nb29zZUFnZ0N1cnNvcjogdHJ1ZSB9KS50cmFuc2Zvcm1OdWxsKCkuX3RyYW5zZm9ybUZvckFzeW5jSXRlcmF0b3IoKTtcbiAgfTtcbn1cblxuLyohXG4gKiBIZWxwZXJzXG4gKi9cblxuLyoqXG4gKiBDaGVja3Mgd2hldGhlciBhbiBvYmplY3QgaXMgbGlrZWx5IGEgcGlwZWxpbmUgb3BlcmF0b3JcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqIG9iamVjdCB0byBjaGVja1xuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGlzT3BlcmF0b3Iob2JqKSB7XG4gIGlmICh0eXBlb2Ygb2JqICE9PSAnb2JqZWN0JyB8fCBvYmogPT09IG51bGwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBjb25zdCBrID0gT2JqZWN0LmtleXMob2JqKTtcblxuICByZXR1cm4gay5sZW5ndGggPT09IDEgJiYga1swXVswXSA9PT0gJyQnO1xufVxuXG4vKipcbiAqIEFkZHMgdGhlIGFwcHJvcHJpYXRlIGAkbWF0Y2hgIHBpcGVsaW5lIHN0ZXAgdG8gdGhlIHRvcCBvZiBhbiBhZ2dyZWdhdGUnc1xuICogcGlwZWxpbmUsIHNob3VsZCBpdCdzIG1vZGVsIGlzIGEgbm9uLXJvb3QgZGlzY3JpbWluYXRvciB0eXBlLiBUaGlzIGlzXG4gKiBhbmFsb2dvdXMgdG8gdGhlIGBwcmVwYXJlRGlzY3JpbWluYXRvckNyaXRlcmlhYCBmdW5jdGlvbiBpbiBgbGliL3F1ZXJ5LmpzYC5cbiAqXG4gKiBAcGFyYW0ge0FnZ3JlZ2F0ZX0gYWdncmVnYXRlIEFnZ3JlZ2F0ZSB0byBwcmVwYXJlXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5BZ2dyZWdhdGUuX3ByZXBhcmVEaXNjcmltaW5hdG9yUGlwZWxpbmUgPSBwcmVwYXJlRGlzY3JpbWluYXRvclBpcGVsaW5lO1xuXG4vKiFcbiAqIEV4cG9ydHNcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IEFnZ3JlZ2F0ZTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../server/node_modules/mongoose/lib/aggregate.js\n");

/***/ }),

/***/ "../server/node_modules/mongoose/lib/browserDocument.js":
/*!**************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/browserDocument.js ***!
  \**************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("/*!\n * Module dependencies.\n */\n\n\n\nconst NodeJSDocument = __webpack_require__(/*! ./document */ \"../server/node_modules/mongoose/lib/document.js\");\nconst EventEmitter = (__webpack_require__(/*! events */ \"events\").EventEmitter);\nconst MongooseError = __webpack_require__(/*! ./error/index */ \"../server/node_modules/mongoose/lib/error/index.js\");\nconst Schema = __webpack_require__(/*! ./schema */ \"../server/node_modules/mongoose/lib/schema.js\");\nconst ObjectId = __webpack_require__(/*! ./types/objectid */ \"../server/node_modules/mongoose/lib/types/objectid.js\");\nconst ValidationError = MongooseError.ValidationError;\nconst applyHooks = __webpack_require__(/*! ./helpers/model/applyHooks */ \"../server/node_modules/mongoose/lib/helpers/model/applyHooks.js\");\nconst isObject = __webpack_require__(/*! ./helpers/isObject */ \"../server/node_modules/mongoose/lib/helpers/isObject.js\");\n\n/**\n * Document constructor.\n *\n * @param {Object} obj the values to set\n * @param {Object} schema\n * @param {Object} [fields] optional object containing the fields which were selected in the query returning this document and any populated paths data\n * @param {Boolean} [skipId] bool, should we auto create an ObjectId _id\n * @inherits NodeJS EventEmitter https://nodejs.org/api/events.html#class-eventemitter\n * @event `init`: Emitted on a document after it has was retrieved from the db and fully hydrated by Mongoose.\n * @event `save`: Emitted when the document is successfully saved\n * @api private\n */\n\nfunction Document(obj, schema, fields, skipId, skipInit) {\n  if (!(this instanceof Document)) {\n    return new Document(obj, schema, fields, skipId, skipInit);\n  }\n\n  if (isObject(schema) && !schema.instanceOfSchema) {\n    schema = new Schema(schema);\n  }\n\n  // When creating EmbeddedDocument, it already has the schema and he doesn't need the _id\n  schema = this.schema || schema;\n\n  // Generate ObjectId if it is missing, but it requires a scheme\n  if (!this.schema && schema.options._id) {\n    obj = obj || {};\n\n    if (obj._id === undefined) {\n      obj._id = new ObjectId();\n    }\n  }\n\n  if (!schema) {\n    throw new MongooseError.MissingSchemaError();\n  }\n\n  this.$__setSchema(schema);\n\n  NodeJSDocument.call(this, obj, fields, skipId, skipInit);\n\n  applyHooks(this, schema, { decorateDoc: true });\n\n  // apply methods\n  for (const m in schema.methods) {\n    this[m] = schema.methods[m];\n  }\n  // apply statics\n  for (const s in schema.statics) {\n    this[s] = schema.statics[s];\n  }\n}\n\n/*!\n * Inherit from the NodeJS document\n */\n\nDocument.prototype = Object.create(NodeJSDocument.prototype);\nDocument.prototype.constructor = Document;\n\n/*!\n * ignore\n */\n\nDocument.events = new EventEmitter();\n\n/*!\n * Browser doc exposes the event emitter API\n */\n\nDocument.$emitter = new EventEmitter();\n\n['on', 'once', 'emit', 'listeners', 'removeListener', 'setMaxListeners',\n  'removeAllListeners', 'addListener'].forEach(function(emitterFn) {\n  Document[emitterFn] = function() {\n    return Document.$emitter[emitterFn].apply(Document.$emitter, arguments);\n  };\n});\n\n/*!\n * Module exports.\n */\n\nDocument.ValidationError = ValidationError;\nmodule.exports = exports = Document;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvYnJvd3NlckRvY3VtZW50LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTs7QUFFYTs7QUFFYix1QkFBdUIsbUJBQU8sQ0FBQyxtRUFBWTtBQUMzQyxxQkFBcUIsMERBQThCO0FBQ25ELHNCQUFzQixtQkFBTyxDQUFDLHlFQUFlO0FBQzdDLGVBQWUsbUJBQU8sQ0FBQywrREFBVTtBQUNqQyxpQkFBaUIsbUJBQU8sQ0FBQywrRUFBa0I7QUFDM0M7QUFDQSxtQkFBbUIsbUJBQU8sQ0FBQyxtR0FBNEI7QUFDdkQsaUJBQWlCLG1CQUFPLENBQUMsbUZBQW9COztBQUU3QztBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLDZCQUE2QixtQkFBbUI7O0FBRWhEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2xpZW50Ly4uL3NlcnZlci9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2Jyb3dzZXJEb2N1bWVudC5qcz84Zjk0Il0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbmNvbnN0IE5vZGVKU0RvY3VtZW50ID0gcmVxdWlyZSgnLi9kb2N1bWVudCcpO1xuY29uc3QgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyO1xuY29uc3QgTW9uZ29vc2VFcnJvciA9IHJlcXVpcmUoJy4vZXJyb3IvaW5kZXgnKTtcbmNvbnN0IFNjaGVtYSA9IHJlcXVpcmUoJy4vc2NoZW1hJyk7XG5jb25zdCBPYmplY3RJZCA9IHJlcXVpcmUoJy4vdHlwZXMvb2JqZWN0aWQnKTtcbmNvbnN0IFZhbGlkYXRpb25FcnJvciA9IE1vbmdvb3NlRXJyb3IuVmFsaWRhdGlvbkVycm9yO1xuY29uc3QgYXBwbHlIb29rcyA9IHJlcXVpcmUoJy4vaGVscGVycy9tb2RlbC9hcHBseUhvb2tzJyk7XG5jb25zdCBpc09iamVjdCA9IHJlcXVpcmUoJy4vaGVscGVycy9pc09iamVjdCcpO1xuXG4vKipcbiAqIERvY3VtZW50IGNvbnN0cnVjdG9yLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmogdGhlIHZhbHVlcyB0byBzZXRcbiAqIEBwYXJhbSB7T2JqZWN0fSBzY2hlbWFcbiAqIEBwYXJhbSB7T2JqZWN0fSBbZmllbGRzXSBvcHRpb25hbCBvYmplY3QgY29udGFpbmluZyB0aGUgZmllbGRzIHdoaWNoIHdlcmUgc2VsZWN0ZWQgaW4gdGhlIHF1ZXJ5IHJldHVybmluZyB0aGlzIGRvY3VtZW50IGFuZCBhbnkgcG9wdWxhdGVkIHBhdGhzIGRhdGFcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW3NraXBJZF0gYm9vbCwgc2hvdWxkIHdlIGF1dG8gY3JlYXRlIGFuIE9iamVjdElkIF9pZFxuICogQGluaGVyaXRzIE5vZGVKUyBFdmVudEVtaXR0ZXIgaHR0cHM6Ly9ub2RlanMub3JnL2FwaS9ldmVudHMuaHRtbCNjbGFzcy1ldmVudGVtaXR0ZXJcbiAqIEBldmVudCBgaW5pdGA6IEVtaXR0ZWQgb24gYSBkb2N1bWVudCBhZnRlciBpdCBoYXMgd2FzIHJldHJpZXZlZCBmcm9tIHRoZSBkYiBhbmQgZnVsbHkgaHlkcmF0ZWQgYnkgTW9uZ29vc2UuXG4gKiBAZXZlbnQgYHNhdmVgOiBFbWl0dGVkIHdoZW4gdGhlIGRvY3VtZW50IGlzIHN1Y2Nlc3NmdWxseSBzYXZlZFxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gRG9jdW1lbnQob2JqLCBzY2hlbWEsIGZpZWxkcywgc2tpcElkLCBza2lwSW5pdCkge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgRG9jdW1lbnQpKSB7XG4gICAgcmV0dXJuIG5ldyBEb2N1bWVudChvYmosIHNjaGVtYSwgZmllbGRzLCBza2lwSWQsIHNraXBJbml0KTtcbiAgfVxuXG4gIGlmIChpc09iamVjdChzY2hlbWEpICYmICFzY2hlbWEuaW5zdGFuY2VPZlNjaGVtYSkge1xuICAgIHNjaGVtYSA9IG5ldyBTY2hlbWEoc2NoZW1hKTtcbiAgfVxuXG4gIC8vIFdoZW4gY3JlYXRpbmcgRW1iZWRkZWREb2N1bWVudCwgaXQgYWxyZWFkeSBoYXMgdGhlIHNjaGVtYSBhbmQgaGUgZG9lc24ndCBuZWVkIHRoZSBfaWRcbiAgc2NoZW1hID0gdGhpcy5zY2hlbWEgfHwgc2NoZW1hO1xuXG4gIC8vIEdlbmVyYXRlIE9iamVjdElkIGlmIGl0IGlzIG1pc3NpbmcsIGJ1dCBpdCByZXF1aXJlcyBhIHNjaGVtZVxuICBpZiAoIXRoaXMuc2NoZW1hICYmIHNjaGVtYS5vcHRpb25zLl9pZCkge1xuICAgIG9iaiA9IG9iaiB8fCB7fTtcblxuICAgIGlmIChvYmouX2lkID09PSB1bmRlZmluZWQpIHtcbiAgICAgIG9iai5faWQgPSBuZXcgT2JqZWN0SWQoKTtcbiAgICB9XG4gIH1cblxuICBpZiAoIXNjaGVtYSkge1xuICAgIHRocm93IG5ldyBNb25nb29zZUVycm9yLk1pc3NpbmdTY2hlbWFFcnJvcigpO1xuICB9XG5cbiAgdGhpcy4kX19zZXRTY2hlbWEoc2NoZW1hKTtcblxuICBOb2RlSlNEb2N1bWVudC5jYWxsKHRoaXMsIG9iaiwgZmllbGRzLCBza2lwSWQsIHNraXBJbml0KTtcblxuICBhcHBseUhvb2tzKHRoaXMsIHNjaGVtYSwgeyBkZWNvcmF0ZURvYzogdHJ1ZSB9KTtcblxuICAvLyBhcHBseSBtZXRob2RzXG4gIGZvciAoY29uc3QgbSBpbiBzY2hlbWEubWV0aG9kcykge1xuICAgIHRoaXNbbV0gPSBzY2hlbWEubWV0aG9kc1ttXTtcbiAgfVxuICAvLyBhcHBseSBzdGF0aWNzXG4gIGZvciAoY29uc3QgcyBpbiBzY2hlbWEuc3RhdGljcykge1xuICAgIHRoaXNbc10gPSBzY2hlbWEuc3RhdGljc1tzXTtcbiAgfVxufVxuXG4vKiFcbiAqIEluaGVyaXQgZnJvbSB0aGUgTm9kZUpTIGRvY3VtZW50XG4gKi9cblxuRG9jdW1lbnQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShOb2RlSlNEb2N1bWVudC5wcm90b3R5cGUpO1xuRG9jdW1lbnQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gRG9jdW1lbnQ7XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxuRG9jdW1lbnQuZXZlbnRzID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuXG4vKiFcbiAqIEJyb3dzZXIgZG9jIGV4cG9zZXMgdGhlIGV2ZW50IGVtaXR0ZXIgQVBJXG4gKi9cblxuRG9jdW1lbnQuJGVtaXR0ZXIgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG5cblsnb24nLCAnb25jZScsICdlbWl0JywgJ2xpc3RlbmVycycsICdyZW1vdmVMaXN0ZW5lcicsICdzZXRNYXhMaXN0ZW5lcnMnLFxuICAncmVtb3ZlQWxsTGlzdGVuZXJzJywgJ2FkZExpc3RlbmVyJ10uZm9yRWFjaChmdW5jdGlvbihlbWl0dGVyRm4pIHtcbiAgRG9jdW1lbnRbZW1pdHRlckZuXSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBEb2N1bWVudC4kZW1pdHRlcltlbWl0dGVyRm5dLmFwcGx5KERvY3VtZW50LiRlbWl0dGVyLCBhcmd1bWVudHMpO1xuICB9O1xufSk7XG5cbi8qIVxuICogTW9kdWxlIGV4cG9ydHMuXG4gKi9cblxuRG9jdW1lbnQuVmFsaWRhdGlvbkVycm9yID0gVmFsaWRhdGlvbkVycm9yO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gRG9jdW1lbnQ7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../server/node_modules/mongoose/lib/browserDocument.js\n");

/***/ }),

/***/ "../server/node_modules/mongoose/lib/cast.js":
/*!***************************************************!*\
  !*** ../server/node_modules/mongoose/lib/cast.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\n/*!\n * Module dependencies.\n */\n\nconst CastError = __webpack_require__(/*! ./error/cast */ \"../server/node_modules/mongoose/lib/error/cast.js\");\nconst StrictModeError = __webpack_require__(/*! ./error/strict */ \"../server/node_modules/mongoose/lib/error/strict.js\");\nconst Types = __webpack_require__(/*! ./schema/index */ \"../server/node_modules/mongoose/lib/schema/index.js\");\nconst cast$expr = __webpack_require__(/*! ./helpers/query/cast$expr */ \"../server/node_modules/mongoose/lib/helpers/query/cast$expr.js\");\nconst castTextSearch = __webpack_require__(/*! ./schema/operators/text */ \"../server/node_modules/mongoose/lib/schema/operators/text.js\");\nconst get = __webpack_require__(/*! ./helpers/get */ \"../server/node_modules/mongoose/lib/helpers/get.js\");\nconst getSchemaDiscriminatorByValue = __webpack_require__(/*! ./helpers/discriminator/getSchemaDiscriminatorByValue */ \"../server/node_modules/mongoose/lib/helpers/discriminator/getSchemaDiscriminatorByValue.js\");\nconst isOperator = __webpack_require__(/*! ./helpers/query/isOperator */ \"../server/node_modules/mongoose/lib/helpers/query/isOperator.js\");\nconst util = __webpack_require__(/*! util */ \"util\");\nconst isObject = __webpack_require__(/*! ./helpers/isObject */ \"../server/node_modules/mongoose/lib/helpers/isObject.js\");\nconst isMongooseObject = __webpack_require__(/*! ./helpers/isMongooseObject */ \"../server/node_modules/mongoose/lib/helpers/isMongooseObject.js\");\nconst utils = __webpack_require__(/*! ./utils */ \"../server/node_modules/mongoose/lib/utils.js\");\n\nconst ALLOWED_GEOWITHIN_GEOJSON_TYPES = ['Polygon', 'MultiPolygon'];\n\n/**\n * Handles internal casting for query filters.\n *\n * @param {Schema} schema\n * @param {Object} obj Object to cast\n * @param {Object} [options] the query options\n * @param {Boolean|\"throw\"} [options.strict] Wheter to enable all strict options\n * @param {Boolean|\"throw\"} [options.strictQuery] Enable strict Queries\n * @param {Boolean} [options.upsert]\n * @param {Query} [context] passed to setters\n * @api private\n */\nmodule.exports = function cast(schema, obj, options, context) {\n  if (Array.isArray(obj)) {\n    throw new Error('Query filter must be an object, got an array ', util.inspect(obj));\n  }\n\n  if (obj == null) {\n    return obj;\n  }\n\n  if (schema != null && schema.discriminators != null && obj[schema.options.discriminatorKey] != null) {\n    schema = getSchemaDiscriminatorByValue(schema, obj[schema.options.discriminatorKey]) || schema;\n  }\n\n  const paths = Object.keys(obj);\n  let i = paths.length;\n  let _keys;\n  let any$conditionals;\n  let schematype;\n  let nested;\n  let path;\n  let type;\n  let val;\n\n  options = options || {};\n\n  while (i--) {\n    path = paths[i];\n    val = obj[path];\n\n    if (path === '$or' || path === '$nor' || path === '$and') {\n      if (!Array.isArray(val)) {\n        throw new CastError('Array', val, path);\n      }\n      for (let k = 0; k < val.length; ++k) {\n        if (val[k] == null || typeof val[k] !== 'object') {\n          throw new CastError('Object', val[k], path + '.' + k);\n        }\n        const discriminatorValue = val[k][schema.options.discriminatorKey];\n        if (discriminatorValue == null) {\n          val[k] = cast(schema, val[k], options, context);\n        } else {\n          const discriminatorSchema = getSchemaDiscriminatorByValue(context.schema, discriminatorValue);\n          val[k] = cast(discriminatorSchema ? discriminatorSchema : schema, val[k], options, context);\n        }\n      }\n    } else if (path === '$where') {\n      type = typeof val;\n\n      if (type !== 'string' && type !== 'function') {\n        throw new Error('Must have a string or function for $where');\n      }\n\n      if (type === 'function') {\n        obj[path] = val.toString();\n      }\n\n      continue;\n    } else if (path === '$expr') {\n      val = cast$expr(val, schema);\n      continue;\n    } else if (path === '$elemMatch') {\n      val = cast(schema, val, options, context);\n    } else if (path === '$text') {\n      val = castTextSearch(val, path);\n    } else {\n      if (!schema) {\n        // no casting for Mixed types\n        continue;\n      }\n\n      schematype = schema.path(path);\n\n      // Check for embedded discriminator paths\n      if (!schematype) {\n        const split = path.split('.');\n        let j = split.length;\n        while (j--) {\n          const pathFirstHalf = split.slice(0, j).join('.');\n          const pathLastHalf = split.slice(j).join('.');\n          const _schematype = schema.path(pathFirstHalf);\n          const discriminatorKey = _schematype &&\n            _schematype.schema &&\n            _schematype.schema.options &&\n            _schematype.schema.options.discriminatorKey;\n\n          // gh-6027: if we haven't found the schematype but this path is\n          // underneath an embedded discriminator and the embedded discriminator\n          // key is in the query, use the embedded discriminator schema\n          if (_schematype != null &&\n            (_schematype.schema && _schematype.schema.discriminators) != null &&\n            discriminatorKey != null &&\n            pathLastHalf !== discriminatorKey) {\n            const discriminatorVal = get(obj, pathFirstHalf + '.' + discriminatorKey);\n            const discriminators = _schematype.schema.discriminators;\n            if (typeof discriminatorVal === 'string' && discriminators[discriminatorVal] != null) {\n\n              schematype = discriminators[discriminatorVal].path(pathLastHalf);\n            } else if (discriminatorVal != null &&\n              Object.keys(discriminatorVal).length === 1 &&\n              Array.isArray(discriminatorVal.$in) &&\n              discriminatorVal.$in.length === 1 &&\n              typeof discriminatorVal.$in[0] === 'string' &&\n              discriminators[discriminatorVal.$in[0]] != null) {\n              schematype = discriminators[discriminatorVal.$in[0]].path(pathLastHalf);\n            }\n          }\n        }\n      }\n\n      if (!schematype) {\n        // Handle potential embedded array queries\n        const split = path.split('.');\n        let j = split.length;\n        let pathFirstHalf;\n        let pathLastHalf;\n        let remainingConds;\n\n        // Find the part of the var path that is a path of the Schema\n        while (j--) {\n          pathFirstHalf = split.slice(0, j).join('.');\n          schematype = schema.path(pathFirstHalf);\n          if (schematype) {\n            break;\n          }\n        }\n\n        // If a substring of the input path resolves to an actual real path...\n        if (schematype) {\n          // Apply the casting; similar code for $elemMatch in schema/array.js\n          if (schematype.caster && schematype.caster.schema) {\n            remainingConds = {};\n            pathLastHalf = split.slice(j).join('.');\n            remainingConds[pathLastHalf] = val;\n\n            const ret = cast(schematype.caster.schema, remainingConds, options, context)[pathLastHalf];\n            if (ret === void 0) {\n              delete obj[path];\n            } else {\n              obj[path] = ret;\n            }\n          } else {\n            obj[path] = val;\n          }\n          continue;\n        }\n\n        if (isObject(val)) {\n          // handle geo schemas that use object notation\n          // { loc: { long: Number, lat: Number }\n\n          let geo = '';\n          if (val.$near) {\n            geo = '$near';\n          } else if (val.$nearSphere) {\n            geo = '$nearSphere';\n          } else if (val.$within) {\n            geo = '$within';\n          } else if (val.$geoIntersects) {\n            geo = '$geoIntersects';\n          } else if (val.$geoWithin) {\n            geo = '$geoWithin';\n          }\n\n          if (geo) {\n            const numbertype = new Types.Number('__QueryCasting__');\n            let value = val[geo];\n\n            if (val.$maxDistance != null) {\n              val.$maxDistance = numbertype.castForQuery(\n                null,\n                val.$maxDistance,\n                context\n              );\n            }\n            if (val.$minDistance != null) {\n              val.$minDistance = numbertype.castForQuery(\n                null,\n                val.$minDistance,\n                context\n              );\n            }\n\n            if (geo === '$within') {\n              const withinType = value.$center\n                  || value.$centerSphere\n                  || value.$box\n                  || value.$polygon;\n\n              if (!withinType) {\n                throw new Error('Bad $within parameter: ' + JSON.stringify(val));\n              }\n\n              value = withinType;\n            } else if (geo === '$near' &&\n                typeof value.type === 'string' && Array.isArray(value.coordinates)) {\n              // geojson; cast the coordinates\n              value = value.coordinates;\n            } else if ((geo === '$near' || geo === '$nearSphere' || geo === '$geoIntersects') &&\n                value.$geometry && typeof value.$geometry.type === 'string' &&\n                Array.isArray(value.$geometry.coordinates)) {\n              if (value.$maxDistance != null) {\n                value.$maxDistance = numbertype.castForQuery(\n                  null,\n                  value.$maxDistance,\n                  context\n                );\n              }\n              if (value.$minDistance != null) {\n                value.$minDistance = numbertype.castForQuery(\n                  null,\n                  value.$minDistance,\n                  context\n                );\n              }\n              if (isMongooseObject(value.$geometry)) {\n                value.$geometry = value.$geometry.toObject({\n                  transform: false,\n                  virtuals: false\n                });\n              }\n              value = value.$geometry.coordinates;\n            } else if (geo === '$geoWithin') {\n              if (value.$geometry) {\n                if (isMongooseObject(value.$geometry)) {\n                  value.$geometry = value.$geometry.toObject({ virtuals: false });\n                }\n                const geoWithinType = value.$geometry.type;\n                if (ALLOWED_GEOWITHIN_GEOJSON_TYPES.indexOf(geoWithinType) === -1) {\n                  throw new Error('Invalid geoJSON type for $geoWithin \"' +\n                    geoWithinType + '\", must be \"Polygon\" or \"MultiPolygon\"');\n                }\n                value = value.$geometry.coordinates;\n              } else {\n                value = value.$box || value.$polygon || value.$center ||\n                  value.$centerSphere;\n                if (isMongooseObject(value)) {\n                  value = value.toObject({ virtuals: false });\n                }\n              }\n            }\n\n            _cast(value, numbertype, context);\n            continue;\n          }\n        }\n\n        if (schema.nested[path]) {\n          continue;\n        }\n\n        const strict = 'strict' in options ? options.strict : schema.options.strict;\n        const strictQuery = getStrictQuery(options, schema._userProvidedOptions, schema.options, context);\n        if (options.upsert && strict) {\n          if (strict === 'throw') {\n            throw new StrictModeError(path);\n          }\n          throw new StrictModeError(path, 'Path \"' + path + '\" is not in ' +\n            'schema, strict mode is `true`, and upsert is `true`.');\n        } if (strictQuery === 'throw') {\n          throw new StrictModeError(path, 'Path \"' + path + '\" is not in ' +\n            'schema and strictQuery is \\'throw\\'.');\n        } else if (strictQuery) {\n          delete obj[path];\n        }\n      } else if (val == null) {\n        continue;\n      } else if (utils.isPOJO(val)) {\n        any$conditionals = Object.keys(val).some(isOperator);\n\n        if (!any$conditionals) {\n          obj[path] = schematype.castForQuery(\n            null,\n            val,\n            context\n          );\n        } else {\n          const ks = Object.keys(val);\n          let $cond;\n          let k = ks.length;\n\n          while (k--) {\n            $cond = ks[k];\n            nested = val[$cond];\n            if ($cond === '$elemMatch') {\n              if (nested && schematype != null && schematype.schema != null) {\n                cast(schematype.schema, nested, options, context);\n              } else if (nested && schematype != null && schematype.$isMongooseArray) {\n                if (utils.isPOJO(nested) && nested.$not != null) {\n                  cast(schema, nested, options, context);\n                } else {\n                  val[$cond] = schematype.castForQuery(\n                    $cond,\n                    nested,\n                    context\n                  );\n                }\n              }\n            } else if ($cond === '$not') {\n              if (nested && schematype) {\n                _keys = Object.keys(nested);\n                if (_keys.length && isOperator(_keys[0])) {\n                  for (const key in nested) {\n                    nested[key] = schematype.castForQuery(\n                      key,\n                      nested[key],\n                      context\n                    );\n                  }\n                } else {\n                  val[$cond] = schematype.castForQuery(\n                    $cond,\n                    nested,\n                    context\n                  );\n                }\n                continue;\n              }\n            } else {\n              val[$cond] = schematype.castForQuery(\n                $cond,\n                nested,\n                context\n              );\n            }\n\n          }\n        }\n      } else if (Array.isArray(val) && ['Buffer', 'Array'].indexOf(schematype.instance) === -1) {\n        const casted = [];\n        const valuesArray = val;\n\n        for (const _val of valuesArray) {\n          casted.push(schematype.castForQuery(\n            null,\n            _val,\n            context\n          ));\n        }\n\n        obj[path] = { $in: casted };\n      } else {\n        obj[path] = schematype.castForQuery(\n          null,\n          val,\n          context\n        );\n      }\n    }\n  }\n\n  return obj;\n};\n\nfunction _cast(val, numbertype, context) {\n  if (Array.isArray(val)) {\n    val.forEach(function(item, i) {\n      if (Array.isArray(item) || isObject(item)) {\n        return _cast(item, numbertype, context);\n      }\n      val[i] = numbertype.castForQuery(null, item, context);\n    });\n  } else {\n    const nearKeys = Object.keys(val);\n    let nearLen = nearKeys.length;\n    while (nearLen--) {\n      const nkey = nearKeys[nearLen];\n      const item = val[nkey];\n      if (Array.isArray(item) || isObject(item)) {\n        _cast(item, numbertype, context);\n        val[nkey] = item;\n      } else {\n        val[nkey] = numbertype.castForQuery({ val: item, context: context });\n      }\n    }\n  }\n}\n\nfunction getStrictQuery(queryOptions, schemaUserProvidedOptions, schemaOptions, context) {\n  if ('strictQuery' in queryOptions) {\n    return queryOptions.strictQuery;\n  }\n  if ('strictQuery' in schemaUserProvidedOptions) {\n    return schemaUserProvidedOptions.strictQuery;\n  }\n  const mongooseOptions = context &&\n    context.mongooseCollection &&\n    context.mongooseCollection.conn &&\n    context.mongooseCollection.conn.base &&\n    context.mongooseCollection.conn.base.options;\n  if (mongooseOptions) {\n    if ('strictQuery' in mongooseOptions) {\n      return mongooseOptions.strictQuery;\n    }\n  }\n  return schemaOptions.strictQuery;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvY2FzdC5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLG1CQUFPLENBQUMsdUVBQWM7QUFDeEMsd0JBQXdCLG1CQUFPLENBQUMsMkVBQWdCO0FBQ2hELGNBQWMsbUJBQU8sQ0FBQywyRUFBZ0I7QUFDdEMsa0JBQWtCLG1CQUFPLENBQUMsaUdBQTJCO0FBQ3JELHVCQUF1QixtQkFBTyxDQUFDLDZGQUF5QjtBQUN4RCxZQUFZLG1CQUFPLENBQUMseUVBQWU7QUFDbkMsc0NBQXNDLG1CQUFPLENBQUMseUpBQXVEO0FBQ3JHLG1CQUFtQixtQkFBTyxDQUFDLG1HQUE0QjtBQUN2RCxhQUFhLG1CQUFPLENBQUMsa0JBQU07QUFDM0IsaUJBQWlCLG1CQUFPLENBQUMsbUZBQW9CO0FBQzdDLHlCQUF5QixtQkFBTyxDQUFDLG1HQUE0QjtBQUM3RCxjQUFjLG1CQUFPLENBQUMsNkRBQVM7O0FBRS9COztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsaUJBQWlCO0FBQzVCLFdBQVcsaUJBQWlCO0FBQzVCLFdBQVcsU0FBUztBQUNwQixXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixnQkFBZ0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNO0FBQ047QUFD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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2NsaWVudC8uLi9zZXJ2ZXIvbm9kZV9tb2R1bGVzL21vbmdvb3NlL2xpYi9jYXN0LmpzPzA4Y2EiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG4vKiFcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxuY29uc3QgQ2FzdEVycm9yID0gcmVxdWlyZSgnLi9lcnJvci9jYXN0Jyk7XG5jb25zdCBTdHJpY3RNb2RlRXJyb3IgPSByZXF1aXJlKCcuL2Vycm9yL3N0cmljdCcpO1xuY29uc3QgVHlwZXMgPSByZXF1aXJlKCcuL3NjaGVtYS9pbmRleCcpO1xuY29uc3QgY2FzdCRleHByID0gcmVxdWlyZSgnLi9oZWxwZXJzL3F1ZXJ5L2Nhc3QkZXhwcicpO1xuY29uc3QgY2FzdFRleHRTZWFyY2ggPSByZXF1aXJlKCcuL3NjaGVtYS9vcGVyYXRvcnMvdGV4dCcpO1xuY29uc3QgZ2V0ID0gcmVxdWlyZSgnLi9oZWxwZXJzL2dldCcpO1xuY29uc3QgZ2V0U2NoZW1hRGlzY3JpbWluYXRvckJ5VmFsdWUgPSByZXF1aXJlKCcuL2hlbHBlcnMvZGlzY3JpbWluYXRvci9nZXRTY2hlbWFEaXNjcmltaW5hdG9yQnlWYWx1ZScpO1xuY29uc3QgaXNPcGVyYXRvciA9IHJlcXVpcmUoJy4vaGVscGVycy9xdWVyeS9pc09wZXJhdG9yJyk7XG5jb25zdCB1dGlsID0gcmVxdWlyZSgndXRpbCcpO1xuY29uc3QgaXNPYmplY3QgPSByZXF1aXJlKCcuL2hlbHBlcnMvaXNPYmplY3QnKTtcbmNvbnN0IGlzTW9uZ29vc2VPYmplY3QgPSByZXF1aXJlKCcuL2hlbHBlcnMvaXNNb25nb29zZU9iamVjdCcpO1xuY29uc3QgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG5cbmNvbnN0IEFMTE9XRURfR0VPV0lUSElOX0dFT0pTT05fVFlQRVMgPSBbJ1BvbHlnb24nLCAnTXVsdGlQb2x5Z29uJ107XG5cbi8qKlxuICogSGFuZGxlcyBpbnRlcm5hbCBjYXN0aW5nIGZvciBxdWVyeSBmaWx0ZXJzLlxuICpcbiAqIEBwYXJhbSB7U2NoZW1hfSBzY2hlbWFcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmogT2JqZWN0IHRvIGNhc3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gdGhlIHF1ZXJ5IG9wdGlvbnNcbiAqIEBwYXJhbSB7Qm9vbGVhbnxcInRocm93XCJ9IFtvcHRpb25zLnN0cmljdF0gV2hldGVyIHRvIGVuYWJsZSBhbGwgc3RyaWN0IG9wdGlvbnNcbiAqIEBwYXJhbSB7Qm9vbGVhbnxcInRocm93XCJ9IFtvcHRpb25zLnN0cmljdFF1ZXJ5XSBFbmFibGUgc3RyaWN0IFF1ZXJpZXNcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMudXBzZXJ0XVxuICogQHBhcmFtIHtRdWVyeX0gW2NvbnRleHRdIHBhc3NlZCB0byBzZXR0ZXJzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBjYXN0KHNjaGVtYSwgb2JqLCBvcHRpb25zLCBjb250ZXh0KSB7XG4gIGlmIChBcnJheS5pc0FycmF5KG9iaikpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1F1ZXJ5IGZpbHRlciBtdXN0IGJlIGFuIG9iamVjdCwgZ290IGFuIGFycmF5ICcsIHV0aWwuaW5zcGVjdChvYmopKTtcbiAgfVxuXG4gIGlmIChvYmogPT0gbnVsbCkge1xuICAgIHJldHVybiBvYmo7XG4gIH1cblxuICBpZiAoc2NoZW1hICE9IG51bGwgJiYgc2NoZW1hLmRpc2NyaW1pbmF0b3JzICE9IG51bGwgJiYgb2JqW3NjaGVtYS5vcHRpb25zLmRpc2NyaW1pbmF0b3JLZXldICE9IG51bGwpIHtcbiAgICBzY2hlbWEgPSBnZXRTY2hlbWFEaXNjcmltaW5hdG9yQnlWYWx1ZShzY2hlbWEsIG9ialtzY2hlbWEub3B0aW9ucy5kaXNjcmltaW5hdG9yS2V5XSkgfHwgc2NoZW1hO1xuICB9XG5cbiAgY29uc3QgcGF0aHMgPSBPYmplY3Qua2V5cyhvYmopO1xuICBsZXQgaSA9IHBhdGhzLmxlbmd0aDtcbiAgbGV0IF9rZXlzO1xuICBsZXQgYW55JGNvbmRpdGlvbmFscztcbiAgbGV0IHNjaGVtYXR5cGU7XG4gIGxldCBuZXN0ZWQ7XG4gIGxldCBwYXRoO1xuICBsZXQgdHlwZTtcbiAgbGV0IHZhbDtcblxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICB3aGlsZSAoaS0tKSB7XG4gICAgcGF0aCA9IHBhdGhzW2ldO1xuICAgIHZhbCA9IG9ialtwYXRoXTtcblxuICAgIGlmIChwYXRoID09PSAnJG9yJyB8fCBwYXRoID09PSAnJG5vcicgfHwgcGF0aCA9PT0gJyRhbmQnKSB7XG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkodmFsKSkge1xuICAgICAgICB0aHJvdyBuZXcgQ2FzdEVycm9yKCdBcnJheScsIHZhbCwgcGF0aCk7XG4gICAgICB9XG4gICAgICBmb3IgKGxldCBrID0gMDsgayA8IHZhbC5sZW5ndGg7ICsraykge1xuICAgICAgICBpZiAodmFsW2tdID09IG51bGwgfHwgdHlwZW9mIHZhbFtrXSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgQ2FzdEVycm9yKCdPYmplY3QnLCB2YWxba10sIHBhdGggKyAnLicgKyBrKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkaXNjcmltaW5hdG9yVmFsdWUgPSB2YWxba11bc2NoZW1hLm9wdGlvbnMuZGlzY3JpbWluYXRvcktleV07XG4gICAgICAgIGlmIChkaXNjcmltaW5hdG9yVmFsdWUgPT0gbnVsbCkge1xuICAgICAgICAgIHZhbFtrXSA9IGNhc3Qoc2NoZW1hLCB2YWxba10sIG9wdGlvbnMsIGNvbnRleHQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnN0IGRpc2NyaW1pbmF0b3JTY2hlbWEgPSBnZXRTY2hlbWFEaXNjcmltaW5hdG9yQnlWYWx1ZShjb250ZXh0LnNjaGVtYSwgZGlzY3JpbWluYXRvclZhbHVlKTtcbiAgICAgICAgICB2YWxba10gPSBjYXN0KGRpc2NyaW1pbmF0b3JTY2hlbWEgPyBkaXNjcmltaW5hdG9yU2NoZW1hIDogc2NoZW1hLCB2YWxba10sIG9wdGlvbnMsIGNvbnRleHQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChwYXRoID09PSAnJHdoZXJlJykge1xuICAgICAgdHlwZSA9IHR5cGVvZiB2YWw7XG5cbiAgICAgIGlmICh0eXBlICE9PSAnc3RyaW5nJyAmJiB0eXBlICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTXVzdCBoYXZlIGEgc3RyaW5nIG9yIGZ1bmN0aW9uIGZvciAkd2hlcmUnKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgb2JqW3BhdGhdID0gdmFsLnRvU3RyaW5nKCk7XG4gICAgICB9XG5cbiAgICAgIGNvbnRpbnVlO1xuICAgIH0gZWxzZSBpZiAocGF0aCA9PT0gJyRleHByJykge1xuICAgICAgdmFsID0gY2FzdCRleHByKHZhbCwgc2NoZW1hKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH0gZWxzZSBpZiAocGF0aCA9PT0gJyRlbGVtTWF0Y2gnKSB7XG4gICAgICB2YWwgPSBjYXN0KHNjaGVtYSwgdmFsLCBvcHRpb25zLCBjb250ZXh0KTtcbiAgICB9IGVsc2UgaWYgKHBhdGggPT09ICckdGV4dCcpIHtcbiAgICAgIHZhbCA9IGNhc3RUZXh0U2VhcmNoKHZhbCwgcGF0aCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICghc2NoZW1hKSB7XG4gICAgICAgIC8vIG5vIGNhc3RpbmcgZm9yIE1peGVkIHR5cGVzXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBzY2hlbWF0eXBlID0gc2NoZW1hLnBhdGgocGF0aCk7XG5cbiAgICAgIC8vIENoZWNrIGZvciBlbWJlZGRlZCBkaXNjcmltaW5hdG9yIHBhdGhzXG4gICAgICBpZiAoIXNjaGVtYXR5cGUpIHtcbiAgICAgICAgY29uc3Qgc3BsaXQgPSBwYXRoLnNwbGl0KCcuJyk7XG4gICAgICAgIGxldCBqID0gc3BsaXQubGVuZ3RoO1xuICAgICAgICB3aGlsZSAoai0tKSB7XG4gICAgICAgICAgY29uc3QgcGF0aEZpcnN0SGFsZiA9IHNwbGl0LnNsaWNlKDAsIGopLmpvaW4oJy4nKTtcbiAgICAgICAgICBjb25zdCBwYXRoTGFzdEhhbGYgPSBzcGxpdC5zbGljZShqKS5qb2luKCcuJyk7XG4gICAgICAgICAgY29uc3QgX3NjaGVtYXR5cGUgPSBzY2hlbWEucGF0aChwYXRoRmlyc3RIYWxmKTtcbiAgICAgICAgICBjb25zdCBkaXNjcmltaW5hdG9yS2V5ID0gX3NjaGVtYXR5cGUgJiZcbiAgICAgICAgICAgIF9zY2hlbWF0eXBlLnNjaGVtYSAmJlxuICAgICAgICAgICAgX3NjaGVtYXR5cGUuc2NoZW1hLm9wdGlvbnMgJiZcbiAgICAgICAgICAgIF9zY2hlbWF0eXBlLnNjaGVtYS5vcHRpb25zLmRpc2NyaW1pbmF0b3JLZXk7XG5cbiAgICAgICAgICAvLyBnaC02MDI3OiBpZiB3ZSBoYXZlbid0IGZvdW5kIHRoZSBzY2hlbWF0eXBlIGJ1dCB0aGlzIHBhdGggaXNcbiAgICAgICAgICAvLyB1bmRlcm5lYXRoIGFuIGVtYmVkZGVkIGRpc2NyaW1pbmF0b3IgYW5kIHRoZSBlbWJlZGRlZCBkaXNjcmltaW5hdG9yXG4gICAgICAgICAgLy8ga2V5IGlzIGluIHRoZSBxdWVyeSwgdXNlIHRoZSBlbWJlZGRlZCBkaXNjcmltaW5hdG9yIHNjaGVtYVxuICAgICAgICAgIGlmIChfc2NoZW1hdHlwZSAhPSBudWxsICYmXG4gICAgICAgICAgICAoX3NjaGVtYXR5cGUuc2NoZW1hICYmIF9zY2hlbWF0eXBlLnNjaGVtYS5kaXNjcmltaW5hdG9ycykgIT0gbnVsbCAmJlxuICAgICAgICAgICAgZGlzY3JpbWluYXRvcktleSAhPSBudWxsICYmXG4gICAgICAgICAgICBwYXRoTGFzdEhhbGYgIT09IGRpc2NyaW1pbmF0b3JLZXkpIHtcbiAgICAgICAgICAgIGNvbnN0IGRpc2NyaW1pbmF0b3JWYWwgPSBnZXQob2JqLCBwYXRoRmlyc3RIYWxmICsgJy4nICsgZGlzY3JpbWluYXRvcktleSk7XG4gICAgICAgICAgICBjb25zdCBkaXNjcmltaW5hdG9ycyA9IF9zY2hlbWF0eXBlLnNjaGVtYS5kaXNjcmltaW5hdG9ycztcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZGlzY3JpbWluYXRvclZhbCA9PT0gJ3N0cmluZycgJiYgZGlzY3JpbWluYXRvcnNbZGlzY3JpbWluYXRvclZhbF0gIT0gbnVsbCkge1xuXG4gICAgICAgICAgICAgIHNjaGVtYXR5cGUgPSBkaXNjcmltaW5hdG9yc1tkaXNjcmltaW5hdG9yVmFsXS5wYXRoKHBhdGhMYXN0SGFsZik7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGRpc2NyaW1pbmF0b3JWYWwgIT0gbnVsbCAmJlxuICAgICAgICAgICAgICBPYmplY3Qua2V5cyhkaXNjcmltaW5hdG9yVmFsKS5sZW5ndGggPT09IDEgJiZcbiAgICAgICAgICAgICAgQXJyYXkuaXNBcnJheShkaXNjcmltaW5hdG9yVmFsLiRpbikgJiZcbiAgICAgICAgICAgICAgZGlzY3JpbWluYXRvclZhbC4kaW4ubGVuZ3RoID09PSAxICYmXG4gICAgICAgICAgICAgIHR5cGVvZiBkaXNjcmltaW5hdG9yVmFsLiRpblswXSA9PT0gJ3N0cmluZycgJiZcbiAgICAgICAgICAgICAgZGlzY3JpbWluYXRvcnNbZGlzY3JpbWluYXRvclZhbC4kaW5bMF1dICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgc2NoZW1hdHlwZSA9IGRpc2NyaW1pbmF0b3JzW2Rpc2NyaW1pbmF0b3JWYWwuJGluWzBdXS5wYXRoKHBhdGhMYXN0SGFsZik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICghc2NoZW1hdHlwZSkge1xuICAgICAgICAvLyBIYW5kbGUgcG90ZW50aWFsIGVtYmVkZGVkIGFycmF5IHF1ZXJpZXNcbiAgICAgICAgY29uc3Qgc3BsaXQgPSBwYXRoLnNwbGl0KCcuJyk7XG4gICAgICAgIGxldCBqID0gc3BsaXQubGVuZ3RoO1xuICAgICAgICBsZXQgcGF0aEZpcnN0SGFsZjtcbiAgICAgICAgbGV0IHBhdGhMYXN0SGFsZjtcbiAgICAgICAgbGV0IHJlbWFpbmluZ0NvbmRzO1xuXG4gICAgICAgIC8vIEZpbmQgdGhlIHBhcnQgb2YgdGhlIHZhciBwYXRoIHRoYXQgaXMgYSBwYXRoIG9mIHRoZSBTY2hlbWFcbiAgICAgICAgd2hpbGUgKGotLSkge1xuICAgICAgICAgIHBhdGhGaXJzdEhhbGYgPSBzcGxpdC5zbGljZSgwLCBqKS5qb2luKCcuJyk7XG4gICAgICAgICAgc2NoZW1hdHlwZSA9IHNjaGVtYS5wYXRoKHBhdGhGaXJzdEhhbGYpO1xuICAgICAgICAgIGlmIChzY2hlbWF0eXBlKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiBhIHN1YnN0cmluZyBvZiB0aGUgaW5wdXQgcGF0aCByZXNvbHZlcyB0byBhbiBhY3R1YWwgcmVhbCBwYXRoLi4uXG4gICAgICAgIGlmIChzY2hlbWF0eXBlKSB7XG4gICAgICAgICAgLy8gQXBwbHkgdGhlIGNhc3Rpbmc7IHNpbWlsYXIgY29kZSBmb3IgJGVsZW1NYXRjaCBpbiBzY2hlbWEvYXJyYXkuanNcbiAgICAgICAgICBpZiAoc2NoZW1hdHlwZS5jYXN0ZXIgJiYgc2NoZW1hdHlwZS5jYXN0ZXIuc2NoZW1hKSB7XG4gICAgICAgICAgICByZW1haW5pbmdDb25kcyA9IHt9O1xuICAgICAgICAgICAgcGF0aExhc3RIYWxmID0gc3BsaXQuc2xpY2Uoaikuam9pbignLicpO1xuICAgICAgICAgICAgcmVtYWluaW5nQ29uZHNbcGF0aExhc3RIYWxmXSA9IHZhbDtcblxuICAgICAgICAgICAgY29uc3QgcmV0ID0gY2FzdChzY2hlbWF0eXBlLmNhc3Rlci5zY2hlbWEsIHJlbWFpbmluZ0NvbmRzLCBvcHRpb25zLCBjb250ZXh0KVtwYXRoTGFzdEhhbGZdO1xuICAgICAgICAgICAgaWYgKHJldCA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgIGRlbGV0ZSBvYmpbcGF0aF07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBvYmpbcGF0aF0gPSByZXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG9ialtwYXRoXSA9IHZhbDtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNPYmplY3QodmFsKSkge1xuICAgICAgICAgIC8vIGhhbmRsZSBnZW8gc2NoZW1hcyB0aGF0IHVzZSBvYmplY3Qgbm90YXRpb25cbiAgICAgICAgICAvLyB7IGxvYzogeyBsb25nOiBOdW1iZXIsIGxhdDogTnVtYmVyIH1cblxuICAgICAgICAgIGxldCBnZW8gPSAnJztcbiAgICAgICAgICBpZiAodmFsLiRuZWFyKSB7XG4gICAgICAgICAgICBnZW8gPSAnJG5lYXInO1xuICAgICAgICAgIH0gZWxzZSBpZiAodmFsLiRuZWFyU3BoZXJlKSB7XG4gICAgICAgICAgICBnZW8gPSAnJG5lYXJTcGhlcmUnO1xuICAgICAgICAgIH0gZWxzZSBpZiAodmFsLiR3aXRoaW4pIHtcbiAgICAgICAgICAgIGdlbyA9ICckd2l0aGluJztcbiAgICAgICAgICB9IGVsc2UgaWYgKHZhbC4kZ2VvSW50ZXJzZWN0cykge1xuICAgICAgICAgICAgZ2VvID0gJyRnZW9JbnRlcnNlY3RzJztcbiAgICAgICAgICB9IGVsc2UgaWYgKHZhbC4kZ2VvV2l0aGluKSB7XG4gICAgICAgICAgICBnZW8gPSAnJGdlb1dpdGhpbic7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGdlbykge1xuICAgICAgICAgICAgY29uc3QgbnVtYmVydHlwZSA9IG5ldyBUeXBlcy5OdW1iZXIoJ19fUXVlcnlDYXN0aW5nX18nKTtcbiAgICAgICAgICAgIGxldCB2YWx1ZSA9IHZhbFtnZW9dO1xuXG4gICAgICAgICAgICBpZiAodmFsLiRtYXhEaXN0YW5jZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgIHZhbC4kbWF4RGlzdGFuY2UgPSBudW1iZXJ0eXBlLmNhc3RGb3JRdWVyeShcbiAgICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICAgIHZhbC4kbWF4RGlzdGFuY2UsXG4gICAgICAgICAgICAgICAgY29udGV4dFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHZhbC4kbWluRGlzdGFuY2UgIT0gbnVsbCkge1xuICAgICAgICAgICAgICB2YWwuJG1pbkRpc3RhbmNlID0gbnVtYmVydHlwZS5jYXN0Rm9yUXVlcnkoXG4gICAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAgICB2YWwuJG1pbkRpc3RhbmNlLFxuICAgICAgICAgICAgICAgIGNvbnRleHRcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGdlbyA9PT0gJyR3aXRoaW4nKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHdpdGhpblR5cGUgPSB2YWx1ZS4kY2VudGVyXG4gICAgICAgICAgICAgICAgICB8fCB2YWx1ZS4kY2VudGVyU3BoZXJlXG4gICAgICAgICAgICAgICAgICB8fCB2YWx1ZS4kYm94XG4gICAgICAgICAgICAgICAgICB8fCB2YWx1ZS4kcG9seWdvbjtcblxuICAgICAgICAgICAgICBpZiAoIXdpdGhpblR5cGUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0JhZCAkd2l0aGluIHBhcmFtZXRlcjogJyArIEpTT04uc3RyaW5naWZ5KHZhbCkpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgdmFsdWUgPSB3aXRoaW5UeXBlO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChnZW8gPT09ICckbmVhcicgJiZcbiAgICAgICAgICAgICAgICB0eXBlb2YgdmFsdWUudHlwZSA9PT0gJ3N0cmluZycgJiYgQXJyYXkuaXNBcnJheSh2YWx1ZS5jb29yZGluYXRlcykpIHtcbiAgICAgICAgICAgICAgLy8gZ2VvanNvbjsgY2FzdCB0aGUgY29vcmRpbmF0ZXNcbiAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS5jb29yZGluYXRlcztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoKGdlbyA9PT0gJyRuZWFyJyB8fCBnZW8gPT09ICckbmVhclNwaGVyZScgfHwgZ2VvID09PSAnJGdlb0ludGVyc2VjdHMnKSAmJlxuICAgICAgICAgICAgICAgIHZhbHVlLiRnZW9tZXRyeSAmJiB0eXBlb2YgdmFsdWUuJGdlb21ldHJ5LnR5cGUgPT09ICdzdHJpbmcnICYmXG4gICAgICAgICAgICAgICAgQXJyYXkuaXNBcnJheSh2YWx1ZS4kZ2VvbWV0cnkuY29vcmRpbmF0ZXMpKSB7XG4gICAgICAgICAgICAgIGlmICh2YWx1ZS4kbWF4RGlzdGFuY2UgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHZhbHVlLiRtYXhEaXN0YW5jZSA9IG51bWJlcnR5cGUuY2FzdEZvclF1ZXJ5KFxuICAgICAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAgICAgIHZhbHVlLiRtYXhEaXN0YW5jZSxcbiAgICAgICAgICAgICAgICAgIGNvbnRleHRcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmICh2YWx1ZS4kbWluRGlzdGFuY2UgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHZhbHVlLiRtaW5EaXN0YW5jZSA9IG51bWJlcnR5cGUuY2FzdEZvclF1ZXJ5KFxuICAgICAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAgICAgIHZhbHVlLiRtaW5EaXN0YW5jZSxcbiAgICAgICAgICAgICAgICAgIGNvbnRleHRcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChpc01vbmdvb3NlT2JqZWN0KHZhbHVlLiRnZW9tZXRyeSkpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZS4kZ2VvbWV0cnkgPSB2YWx1ZS4kZ2VvbWV0cnkudG9PYmplY3Qoe1xuICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgIHZpcnR1YWxzOiBmYWxzZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUuJGdlb21ldHJ5LmNvb3JkaW5hdGVzO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChnZW8gPT09ICckZ2VvV2l0aGluJykge1xuICAgICAgICAgICAgICBpZiAodmFsdWUuJGdlb21ldHJ5KSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzTW9uZ29vc2VPYmplY3QodmFsdWUuJGdlb21ldHJ5KSkge1xuICAgICAgICAgICAgICAgICAgdmFsdWUuJGdlb21ldHJ5ID0gdmFsdWUuJGdlb21ldHJ5LnRvT2JqZWN0KHsgdmlydHVhbHM6IGZhbHNlIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBnZW9XaXRoaW5UeXBlID0gdmFsdWUuJGdlb21ldHJ5LnR5cGU7XG4gICAgICAgICAgICAgICAgaWYgKEFMTE9XRURfR0VPV0lUSElOX0dFT0pTT05fVFlQRVMuaW5kZXhPZihnZW9XaXRoaW5UeXBlKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBnZW9KU09OIHR5cGUgZm9yICRnZW9XaXRoaW4gXCInICtcbiAgICAgICAgICAgICAgICAgICAgZ2VvV2l0aGluVHlwZSArICdcIiwgbXVzdCBiZSBcIlBvbHlnb25cIiBvciBcIk11bHRpUG9seWdvblwiJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUuJGdlb21ldHJ5LmNvb3JkaW5hdGVzO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUuJGJveCB8fCB2YWx1ZS4kcG9seWdvbiB8fCB2YWx1ZS4kY2VudGVyIHx8XG4gICAgICAgICAgICAgICAgICB2YWx1ZS4kY2VudGVyU3BoZXJlO1xuICAgICAgICAgICAgICAgIGlmIChpc01vbmdvb3NlT2JqZWN0KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS50b09iamVjdCh7IHZpcnR1YWxzOiBmYWxzZSB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX2Nhc3QodmFsdWUsIG51bWJlcnR5cGUsIGNvbnRleHQpO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNjaGVtYS5uZXN0ZWRbcGF0aF0pIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHN0cmljdCA9ICdzdHJpY3QnIGluIG9wdGlvbnMgPyBvcHRpb25zLnN0cmljdCA6IHNjaGVtYS5vcHRpb25zLnN0cmljdDtcbiAgICAgICAgY29uc3Qgc3RyaWN0UXVlcnkgPSBnZXRTdHJpY3RRdWVyeShvcHRpb25zLCBzY2hlbWEuX3VzZXJQcm92aWRlZE9wdGlvbnMsIHNjaGVtYS5vcHRpb25zLCBjb250ZXh0KTtcbiAgICAgICAgaWYgKG9wdGlvbnMudXBzZXJ0ICYmIHN0cmljdCkge1xuICAgICAgICAgIGlmIChzdHJpY3QgPT09ICd0aHJvdycpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBTdHJpY3RNb2RlRXJyb3IocGF0aCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRocm93IG5ldyBTdHJpY3RNb2RlRXJyb3IocGF0aCwgJ1BhdGggXCInICsgcGF0aCArICdcIiBpcyBub3QgaW4gJyArXG4gICAgICAgICAgICAnc2NoZW1hLCBzdHJpY3QgbW9kZSBpcyBgdHJ1ZWAsIGFuZCB1cHNlcnQgaXMgYHRydWVgLicpO1xuICAgICAgICB9IGlmIChzdHJpY3RRdWVyeSA9PT0gJ3Rocm93Jykge1xuICAgICAgICAgIHRocm93IG5ldyBTdHJpY3RNb2RlRXJyb3IocGF0aCwgJ1BhdGggXCInICsgcGF0aCArICdcIiBpcyBub3QgaW4gJyArXG4gICAgICAgICAgICAnc2NoZW1hIGFuZCBzdHJpY3RRdWVyeSBpcyBcXCd0aHJvd1xcJy4nKTtcbiAgICAgICAgfSBlbHNlIGlmIChzdHJpY3RRdWVyeSkge1xuICAgICAgICAgIGRlbGV0ZSBvYmpbcGF0aF07XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodmFsID09IG51bGwpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9IGVsc2UgaWYgKHV0aWxzLmlzUE9KTyh2YWwpKSB7XG4gICAgICAgIGFueSRjb25kaXRpb25hbHMgPSBPYmplY3Qua2V5cyh2YWwpLnNvbWUoaXNPcGVyYXRvcik7XG5cbiAgICAgICAgaWYgKCFhbnkkY29uZGl0aW9uYWxzKSB7XG4gICAgICAgICAgb2JqW3BhdGhdID0gc2NoZW1hdHlwZS5jYXN0Rm9yUXVlcnkoXG4gICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgdmFsLFxuICAgICAgICAgICAgY29udGV4dFxuICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc3Qga3MgPSBPYmplY3Qua2V5cyh2YWwpO1xuICAgICAgICAgIGxldCAkY29uZDtcbiAgICAgICAgICBsZXQgayA9IGtzLmxlbmd0aDtcblxuICAgICAgICAgIHdoaWxlIChrLS0pIHtcbiAgICAgICAgICAgICRjb25kID0ga3Nba107XG4gICAgICAgICAgICBuZXN0ZWQgPSB2YWxbJGNvbmRdO1xuICAgICAgICAgICAgaWYgKCRjb25kID09PSAnJGVsZW1NYXRjaCcpIHtcbiAgICAgICAgICAgICAgaWYgKG5lc3RlZCAmJiBzY2hlbWF0eXBlICE9IG51bGwgJiYgc2NoZW1hdHlwZS5zY2hlbWEgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGNhc3Qoc2NoZW1hdHlwZS5zY2hlbWEsIG5lc3RlZCwgb3B0aW9ucywgY29udGV4dCk7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAobmVzdGVkICYmIHNjaGVtYXR5cGUgIT0gbnVsbCAmJiBzY2hlbWF0eXBlLiRpc01vbmdvb3NlQXJyYXkpIHtcbiAgICAgICAgICAgICAgICBpZiAodXRpbHMuaXNQT0pPKG5lc3RlZCkgJiYgbmVzdGVkLiRub3QgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgY2FzdChzY2hlbWEsIG5lc3RlZCwgb3B0aW9ucywgY29udGV4dCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHZhbFskY29uZF0gPSBzY2hlbWF0eXBlLmNhc3RGb3JRdWVyeShcbiAgICAgICAgICAgICAgICAgICAgJGNvbmQsXG4gICAgICAgICAgICAgICAgICAgIG5lc3RlZCxcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dFxuICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoJGNvbmQgPT09ICckbm90Jykge1xuICAgICAgICAgICAgICBpZiAobmVzdGVkICYmIHNjaGVtYXR5cGUpIHtcbiAgICAgICAgICAgICAgICBfa2V5cyA9IE9iamVjdC5rZXlzKG5lc3RlZCk7XG4gICAgICAgICAgICAgICAgaWYgKF9rZXlzLmxlbmd0aCAmJiBpc09wZXJhdG9yKF9rZXlzWzBdKSkge1xuICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gbmVzdGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIG5lc3RlZFtrZXldID0gc2NoZW1hdHlwZS5jYXN0Rm9yUXVlcnkoXG4gICAgICAgICAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICAgICAgICAgIG5lc3RlZFtrZXldLFxuICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHRcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgdmFsWyRjb25kXSA9IHNjaGVtYXR5cGUuY2FzdEZvclF1ZXJ5KFxuICAgICAgICAgICAgICAgICAgICAkY29uZCxcbiAgICAgICAgICAgICAgICAgICAgbmVzdGVkLFxuICAgICAgICAgICAgICAgICAgICBjb250ZXh0XG4gICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdmFsWyRjb25kXSA9IHNjaGVtYXR5cGUuY2FzdEZvclF1ZXJ5KFxuICAgICAgICAgICAgICAgICRjb25kLFxuICAgICAgICAgICAgICAgIG5lc3RlZCxcbiAgICAgICAgICAgICAgICBjb250ZXh0XG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh2YWwpICYmIFsnQnVmZmVyJywgJ0FycmF5J10uaW5kZXhPZihzY2hlbWF0eXBlLmluc3RhbmNlKSA9PT0gLTEpIHtcbiAgICAgICAgY29uc3QgY2FzdGVkID0gW107XG4gICAgICAgIGNvbnN0IHZhbHVlc0FycmF5ID0gdmFsO1xuXG4gICAgICAgIGZvciAoY29uc3QgX3ZhbCBvZiB2YWx1ZXNBcnJheSkge1xuICAgICAgICAgIGNhc3RlZC5wdXNoKHNjaGVtYXR5cGUuY2FzdEZvclF1ZXJ5KFxuICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgIF92YWwsXG4gICAgICAgICAgICBjb250ZXh0XG4gICAgICAgICAgKSk7XG4gICAgICAgIH1cblxuICAgICAgICBvYmpbcGF0aF0gPSB7ICRpbjogY2FzdGVkIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvYmpbcGF0aF0gPSBzY2hlbWF0eXBlLmNhc3RGb3JRdWVyeShcbiAgICAgICAgICBudWxsLFxuICAgICAgICAgIHZhbCxcbiAgICAgICAgICBjb250ZXh0XG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG9iajtcbn07XG5cbmZ1bmN0aW9uIF9jYXN0KHZhbCwgbnVtYmVydHlwZSwgY29udGV4dCkge1xuICBpZiAoQXJyYXkuaXNBcnJheSh2YWwpKSB7XG4gICAgdmFsLmZvckVhY2goZnVuY3Rpb24oaXRlbSwgaSkge1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoaXRlbSkgfHwgaXNPYmplY3QoaXRlbSkpIHtcbiAgICAgICAgcmV0dXJuIF9jYXN0KGl0ZW0sIG51bWJlcnR5cGUsIGNvbnRleHQpO1xuICAgICAgfVxuICAgICAgdmFsW2ldID0gbnVtYmVydHlwZS5jYXN0Rm9yUXVlcnkobnVsbCwgaXRlbSwgY29udGV4dCk7XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgbmVhcktleXMgPSBPYmplY3Qua2V5cyh2YWwpO1xuICAgIGxldCBuZWFyTGVuID0gbmVhcktleXMubGVuZ3RoO1xuICAgIHdoaWxlIChuZWFyTGVuLS0pIHtcbiAgICAgIGNvbnN0IG5rZXkgPSBuZWFyS2V5c1tuZWFyTGVuXTtcbiAgICAgIGNvbnN0IGl0ZW0gPSB2YWxbbmtleV07XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShpdGVtKSB8fCBpc09iamVjdChpdGVtKSkge1xuICAgICAgICBfY2FzdChpdGVtLCBudW1iZXJ0eXBlLCBjb250ZXh0KTtcbiAgICAgICAgdmFsW25rZXldID0gaXRlbTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhbFtua2V5XSA9IG51bWJlcnR5cGUuY2FzdEZvclF1ZXJ5KHsgdmFsOiBpdGVtLCBjb250ZXh0OiBjb250ZXh0IH0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRTdHJpY3RRdWVyeShxdWVyeU9wdGlvbnMsIHNjaGVtYVVzZXJQcm92aWRlZE9wdGlvbnMsIHNjaGVtYU9wdGlvbnMsIGNvbnRleHQpIHtcbiAgaWYgKCdzdHJpY3RRdWVyeScgaW4gcXVlcnlPcHRpb25zKSB7XG4gICAgcmV0dXJuIHF1ZXJ5T3B0aW9ucy5zdHJpY3RRdWVyeTtcbiAgfVxuICBpZiAoJ3N0cmljdFF1ZXJ5JyBpbiBzY2hlbWFVc2VyUHJvdmlkZWRPcHRpb25zKSB7XG4gICAgcmV0dXJuIHNjaGVtYVVzZXJQcm92aWRlZE9wdGlvbnMuc3RyaWN0UXVlcnk7XG4gIH1cbiAgY29uc3QgbW9uZ29vc2VPcHRpb25zID0gY29udGV4dCAmJlxuICAgIGNvbnRleHQubW9uZ29vc2VDb2xsZWN0aW9uICYmXG4gICAgY29udGV4dC5tb25nb29zZUNvbGxlY3Rpb24uY29ubiAmJlxuICAgIGNvbnRleHQubW9uZ29vc2VDb2xsZWN0aW9uLmNvbm4uYmFzZSAmJlxuICAgIGNvbnRleHQubW9uZ29vc2VDb2xsZWN0aW9uLmNvbm4uYmFzZS5vcHRpb25zO1xuICBpZiAobW9uZ29vc2VPcHRpb25zKSB7XG4gICAgaWYgKCdzdHJpY3RRdWVyeScgaW4gbW9uZ29vc2VPcHRpb25zKSB7XG4gICAgICByZXR1cm4gbW9uZ29vc2VPcHRpb25zLnN0cmljdFF1ZXJ5O1xuICAgIH1cbiAgfVxuICByZXR1cm4gc2NoZW1hT3B0aW9ucy5zdHJpY3RRdWVyeTtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../server/node_modules/mongoose/lib/cast.js\n");

/***/ }),

/***/ "../server/node_modules/mongoose/lib/cast/bigint.js":
/*!**********************************************************!*\
  !*** ../server/node_modules/mongoose/lib/cast/bigint.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst assert = __webpack_require__(/*! assert */ \"assert\");\nconst { Long } = __webpack_require__(/*! bson */ \"../server/node_modules/bson/lib/bson.cjs\");\n\n/**\n * Given a value, cast it to a BigInt, or throw an `Error` if the value\n * cannot be casted. `null` and `undefined` are considered valid.\n *\n * @param {Any} value\n * @return {Number}\n * @throws {Error} if `value` is not one of the allowed values\n * @api private\n */\n\nmodule.exports = function castBigInt(val) {\n  if (val == null) {\n    return val;\n  }\n  if (val === '') {\n    return null;\n  }\n  if (typeof val === 'bigint') {\n    return val;\n  }\n\n  if (val instanceof Long) {\n    return val.toBigInt();\n  }\n\n  if (typeof val === 'string' || typeof val === 'number') {\n    return BigInt(val);\n  }\n\n  assert.ok(false);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvY2FzdC9iaWdpbnQuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsZUFBZSxtQkFBTyxDQUFDLHNCQUFRO0FBQy9CLFFBQVEsT0FBTyxFQUFFLG1CQUFPLENBQUMsc0RBQU07O0FBRS9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFlBQVk7QUFDWixZQUFZLE9BQU87QUFDbkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbGllbnQvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvY2FzdC9iaWdpbnQuanM/OTYxMyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IGFzc2VydCA9IHJlcXVpcmUoJ2Fzc2VydCcpO1xuY29uc3QgeyBMb25nIH0gPSByZXF1aXJlKCdic29uJyk7XG5cbi8qKlxuICogR2l2ZW4gYSB2YWx1ZSwgY2FzdCBpdCB0byBhIEJpZ0ludCwgb3IgdGhyb3cgYW4gYEVycm9yYCBpZiB0aGUgdmFsdWVcbiAqIGNhbm5vdCBiZSBjYXN0ZWQuIGBudWxsYCBhbmQgYHVuZGVmaW5lZGAgYXJlIGNvbnNpZGVyZWQgdmFsaWQuXG4gKlxuICogQHBhcmFtIHtBbnl9IHZhbHVlXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKiBAdGhyb3dzIHtFcnJvcn0gaWYgYHZhbHVlYCBpcyBub3Qgb25lIG9mIHRoZSBhbGxvd2VkIHZhbHVlc1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBjYXN0QmlnSW50KHZhbCkge1xuICBpZiAodmFsID09IG51bGwpIHtcbiAgICByZXR1cm4gdmFsO1xuICB9XG4gIGlmICh2YWwgPT09ICcnKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdiaWdpbnQnKSB7XG4gICAgcmV0dXJuIHZhbDtcbiAgfVxuXG4gIGlmICh2YWwgaW5zdGFuY2VvZiBMb25nKSB7XG4gICAgcmV0dXJuIHZhbC50b0JpZ0ludCgpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgcmV0dXJuIEJpZ0ludCh2YWwpO1xuICB9XG5cbiAgYXNzZXJ0Lm9rKGZhbHNlKTtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../server/node_modules/mongoose/lib/cast/bigint.js\n");

/***/ }),

/***/ "../server/node_modules/mongoose/lib/cast/boolean.js":
/*!***********************************************************!*\
  !*** ../server/node_modules/mongoose/lib/cast/boolean.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst CastError = __webpack_require__(/*! ../error/cast */ \"../server/node_modules/mongoose/lib/error/cast.js\");\n\n/**\n * Given a value, cast it to a boolean, or throw a `CastError` if the value\n * cannot be casted. `null` and `undefined` are considered valid.\n *\n * @param {Any} value\n * @param {String} [path] optional the path to set on the CastError\n * @return {Boolean|null|undefined}\n * @throws {CastError} if `value` is not one of the allowed values\n * @api private\n */\n\nmodule.exports = function castBoolean(value, path) {\n  if (module.exports.convertToTrue.has(value)) {\n    return true;\n  }\n  if (module.exports.convertToFalse.has(value)) {\n    return false;\n  }\n\n  if (value == null) {\n    return value;\n  }\n\n  throw new CastError('boolean', value, path);\n};\n\nmodule.exports.convertToTrue = new Set([true, 'true', 1, '1', 'yes']);\nmodule.exports.convertToFalse = new Set([false, 'false', 0, '0', 'no']);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvY2FzdC9ib29sZWFuLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLGtCQUFrQixtQkFBTyxDQUFDLHdFQUFlOztBQUV6QztBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLFFBQVE7QUFDbkIsWUFBWTtBQUNaLFlBQVksV0FBVztBQUN2QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLDRCQUE0QjtBQUM1Qiw2QkFBNkIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbGllbnQvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvY2FzdC9ib29sZWFuLmpzPzRkMzgiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBDYXN0RXJyb3IgPSByZXF1aXJlKCcuLi9lcnJvci9jYXN0Jyk7XG5cbi8qKlxuICogR2l2ZW4gYSB2YWx1ZSwgY2FzdCBpdCB0byBhIGJvb2xlYW4sIG9yIHRocm93IGEgYENhc3RFcnJvcmAgaWYgdGhlIHZhbHVlXG4gKiBjYW5ub3QgYmUgY2FzdGVkLiBgbnVsbGAgYW5kIGB1bmRlZmluZWRgIGFyZSBjb25zaWRlcmVkIHZhbGlkLlxuICpcbiAqIEBwYXJhbSB7QW55fSB2YWx1ZVxuICogQHBhcmFtIHtTdHJpbmd9IFtwYXRoXSBvcHRpb25hbCB0aGUgcGF0aCB0byBzZXQgb24gdGhlIENhc3RFcnJvclxuICogQHJldHVybiB7Qm9vbGVhbnxudWxsfHVuZGVmaW5lZH1cbiAqIEB0aHJvd3Mge0Nhc3RFcnJvcn0gaWYgYHZhbHVlYCBpcyBub3Qgb25lIG9mIHRoZSBhbGxvd2VkIHZhbHVlc1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBjYXN0Qm9vbGVhbih2YWx1ZSwgcGF0aCkge1xuICBpZiAobW9kdWxlLmV4cG9ydHMuY29udmVydFRvVHJ1ZS5oYXModmFsdWUpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKG1vZHVsZS5leHBvcnRzLmNvbnZlcnRUb0ZhbHNlLmhhcyh2YWx1ZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuXG4gIHRocm93IG5ldyBDYXN0RXJyb3IoJ2Jvb2xlYW4nLCB2YWx1ZSwgcGF0aCk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cy5jb252ZXJ0VG9UcnVlID0gbmV3IFNldChbdHJ1ZSwgJ3RydWUnLCAxLCAnMScsICd5ZXMnXSk7XG5tb2R1bGUuZXhwb3J0cy5jb252ZXJ0VG9GYWxzZSA9IG5ldyBTZXQoW2ZhbHNlLCAnZmFsc2UnLCAwLCAnMCcsICdubyddKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../server/node_modules/mongoose/lib/cast/boolean.js\n");

/***/ }),

/***/ "../server/node_modules/mongoose/lib/cast/date.js":
/*!********************************************************!*\
  !*** ../server/node_modules/mongoose/lib/cast/date.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst assert = __webpack_require__(/*! assert */ \"assert\");\n\nmodule.exports = function castDate(value) {\n  // Support empty string because of empty form values. Originally introduced\n  // in https://github.com/Automattic/mongoose/commit/efc72a1898fc3c33a319d915b8c5463a22938dfe\n  if (value == null || value === '') {\n    return null;\n  }\n\n  if (value instanceof Date) {\n    assert.ok(!isNaN(value.valueOf()));\n\n    return value;\n  }\n\n  let date;\n\n  assert.ok(typeof value !== 'boolean');\n\n  if (value instanceof Number || typeof value === 'number') {\n    date = new Date(value);\n  } else if (typeof value === 'string' && !isNaN(Number(value)) && (Number(value) >= 275761 || Number(value) < -271820)) {\n    // string representation of milliseconds take this path\n    date = new Date(Number(value));\n  } else if (typeof value.valueOf === 'function') {\n    // support for moment.js. This is also the path strings will take because\n    // strings have a `valueOf()`\n    date = new Date(value.valueOf());\n  } else {\n    // fallback\n    date = new Date(value);\n  }\n\n  if (!isNaN(date.valueOf())) {\n    return date;\n  }\n\n  assert.ok(false);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvY2FzdC9kYXRlLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLGVBQWUsbUJBQU8sQ0FBQyxzQkFBUTs7QUFFL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2NsaWVudC8uLi9zZXJ2ZXIvbm9kZV9tb2R1bGVzL21vbmdvb3NlL2xpYi9jYXN0L2RhdGUuanM/NTQxNiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IGFzc2VydCA9IHJlcXVpcmUoJ2Fzc2VydCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGNhc3REYXRlKHZhbHVlKSB7XG4gIC8vIFN1cHBvcnQgZW1wdHkgc3RyaW5nIGJlY2F1c2Ugb2YgZW1wdHkgZm9ybSB2YWx1ZXMuIE9yaWdpbmFsbHkgaW50cm9kdWNlZFxuICAvLyBpbiBodHRwczovL2dpdGh1Yi5jb20vQXV0b21hdHRpYy9tb25nb29zZS9jb21taXQvZWZjNzJhMTg5OGZjM2MzM2EzMTlkOTE1YjhjNTQ2M2EyMjkzOGRmZVxuICBpZiAodmFsdWUgPT0gbnVsbCB8fCB2YWx1ZSA9PT0gJycpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGlmICh2YWx1ZSBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICBhc3NlcnQub2soIWlzTmFOKHZhbHVlLnZhbHVlT2YoKSkpO1xuXG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG5cbiAgbGV0IGRhdGU7XG5cbiAgYXNzZXJ0Lm9rKHR5cGVvZiB2YWx1ZSAhPT0gJ2Jvb2xlYW4nKTtcblxuICBpZiAodmFsdWUgaW5zdGFuY2VvZiBOdW1iZXIgfHwgdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgIGRhdGUgPSBuZXcgRGF0ZSh2YWx1ZSk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyAmJiAhaXNOYU4oTnVtYmVyKHZhbHVlKSkgJiYgKE51bWJlcih2YWx1ZSkgPj0gMjc1NzYxIHx8IE51bWJlcih2YWx1ZSkgPCAtMjcxODIwKSkge1xuICAgIC8vIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBtaWxsaXNlY29uZHMgdGFrZSB0aGlzIHBhdGhcbiAgICBkYXRlID0gbmV3IERhdGUoTnVtYmVyKHZhbHVlKSk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlLnZhbHVlT2YgPT09ICdmdW5jdGlvbicpIHtcbiAgICAvLyBzdXBwb3J0IGZvciBtb21lbnQuanMuIFRoaXMgaXMgYWxzbyB0aGUgcGF0aCBzdHJpbmdzIHdpbGwgdGFrZSBiZWNhdXNlXG4gICAgLy8gc3RyaW5ncyBoYXZlIGEgYHZhbHVlT2YoKWBcbiAgICBkYXRlID0gbmV3IERhdGUodmFsdWUudmFsdWVPZigpKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBmYWxsYmFja1xuICAgIGRhdGUgPSBuZXcgRGF0ZSh2YWx1ZSk7XG4gIH1cblxuICBpZiAoIWlzTmFOKGRhdGUudmFsdWVPZigpKSkge1xuICAgIHJldHVybiBkYXRlO1xuICB9XG5cbiAgYXNzZXJ0Lm9rKGZhbHNlKTtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../server/node_modules/mongoose/lib/cast/date.js\n");

/***/ }),

/***/ "../server/node_modules/mongoose/lib/cast/decimal128.js":
/*!**************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/cast/decimal128.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst Decimal128Type = __webpack_require__(/*! ../types/decimal128 */ \"../server/node_modules/mongoose/lib/types/decimal128.js\");\nconst assert = __webpack_require__(/*! assert */ \"assert\");\n\nmodule.exports = function castDecimal128(value) {\n  if (value == null) {\n    return value;\n  }\n\n  if (typeof value === 'object' && typeof value.$numberDecimal === 'string') {\n    return Decimal128Type.fromString(value.$numberDecimal);\n  }\n\n  if (value instanceof Decimal128Type) {\n    return value;\n  }\n\n  if (typeof value === 'string') {\n    return Decimal128Type.fromString(value);\n  }\n\n  if (typeof Buffer === 'function' && Buffer.isBuffer(value)) {\n    return new Decimal128Type(value);\n  }\n  if (typeof Uint8Array === 'function' && value instanceof Uint8Array) {\n    return new Decimal128Type(value);\n  }\n\n  if (typeof value === 'number') {\n    return Decimal128Type.fromString(String(value));\n  }\n\n  if (typeof value.valueOf === 'function' && typeof value.valueOf() === 'string') {\n    return Decimal128Type.fromString(value.valueOf());\n  }\n\n  assert.ok(false);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvY2FzdC9kZWNpbWFsMTI4LmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLHVCQUF1QixtQkFBTyxDQUFDLG9GQUFxQjtBQUNwRCxlQUFlLG1CQUFPLENBQUMsc0JBQVE7O0FBRS9CO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbGllbnQvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvY2FzdC9kZWNpbWFsMTI4LmpzP2QyMTciXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBEZWNpbWFsMTI4VHlwZSA9IHJlcXVpcmUoJy4uL3R5cGVzL2RlY2ltYWwxMjgnKTtcbmNvbnN0IGFzc2VydCA9IHJlcXVpcmUoJ2Fzc2VydCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGNhc3REZWNpbWFsMTI4KHZhbHVlKSB7XG4gIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIHZhbHVlLiRudW1iZXJEZWNpbWFsID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBEZWNpbWFsMTI4VHlwZS5mcm9tU3RyaW5nKHZhbHVlLiRudW1iZXJEZWNpbWFsKTtcbiAgfVxuXG4gIGlmICh2YWx1ZSBpbnN0YW5jZW9mIERlY2ltYWwxMjhUeXBlKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gRGVjaW1hbDEyOFR5cGUuZnJvbVN0cmluZyh2YWx1ZSk7XG4gIH1cblxuICBpZiAodHlwZW9mIEJ1ZmZlciA9PT0gJ2Z1bmN0aW9uJyAmJiBCdWZmZXIuaXNCdWZmZXIodmFsdWUpKSB7XG4gICAgcmV0dXJuIG5ldyBEZWNpbWFsMTI4VHlwZSh2YWx1ZSk7XG4gIH1cbiAgaWYgKHR5cGVvZiBVaW50OEFycmF5ID09PSAnZnVuY3Rpb24nICYmIHZhbHVlIGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgIHJldHVybiBuZXcgRGVjaW1hbDEyOFR5cGUodmFsdWUpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICByZXR1cm4gRGVjaW1hbDEyOFR5cGUuZnJvbVN0cmluZyhTdHJpbmcodmFsdWUpKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgdmFsdWUudmFsdWVPZiA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgdmFsdWUudmFsdWVPZigpID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBEZWNpbWFsMTI4VHlwZS5mcm9tU3RyaW5nKHZhbHVlLnZhbHVlT2YoKSk7XG4gIH1cblxuICBhc3NlcnQub2soZmFsc2UpO1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../server/node_modules/mongoose/lib/cast/decimal128.js\n");

/***/ }),

/***/ "../server/node_modules/mongoose/lib/cast/number.js":
/*!**********************************************************!*\
  !*** ../server/node_modules/mongoose/lib/cast/number.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst assert = __webpack_require__(/*! assert */ \"assert\");\n\n/**\n * Given a value, cast it to a number, or throw an `Error` if the value\n * cannot be casted. `null` and `undefined` are considered valid.\n *\n * @param {Any} value\n * @return {Number}\n * @throws {Error} if `value` is not one of the allowed values\n * @api private\n */\n\nmodule.exports = function castNumber(val) {\n  if (val == null) {\n    return val;\n  }\n  if (val === '') {\n    return null;\n  }\n\n  if (typeof val === 'string' || typeof val === 'boolean') {\n    val = Number(val);\n  }\n\n  assert.ok(!isNaN(val));\n  if (val instanceof Number) {\n    return val.valueOf();\n  }\n  if (typeof val === 'number') {\n    return val;\n  }\n  if (!Array.isArray(val) && typeof val.valueOf === 'function') {\n    return Number(val.valueOf());\n  }\n  if (val.toString && !Array.isArray(val) && val.toString() == Number(val)) {\n    return Number(val);\n  }\n\n  assert.ok(false);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvY2FzdC9udW1iZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsZUFBZSxtQkFBTyxDQUFDLHNCQUFROztBQUUvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixZQUFZO0FBQ1osWUFBWSxPQUFPO0FBQ25CO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbGllbnQvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvY2FzdC9udW1iZXIuanM/OGU5NiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IGFzc2VydCA9IHJlcXVpcmUoJ2Fzc2VydCcpO1xuXG4vKipcbiAqIEdpdmVuIGEgdmFsdWUsIGNhc3QgaXQgdG8gYSBudW1iZXIsIG9yIHRocm93IGFuIGBFcnJvcmAgaWYgdGhlIHZhbHVlXG4gKiBjYW5ub3QgYmUgY2FzdGVkLiBgbnVsbGAgYW5kIGB1bmRlZmluZWRgIGFyZSBjb25zaWRlcmVkIHZhbGlkLlxuICpcbiAqIEBwYXJhbSB7QW55fSB2YWx1ZVxuICogQHJldHVybiB7TnVtYmVyfVxuICogQHRocm93cyB7RXJyb3J9IGlmIGB2YWx1ZWAgaXMgbm90IG9uZSBvZiB0aGUgYWxsb3dlZCB2YWx1ZXNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gY2FzdE51bWJlcih2YWwpIHtcbiAgaWYgKHZhbCA9PSBudWxsKSB7XG4gICAgcmV0dXJuIHZhbDtcbiAgfVxuICBpZiAodmFsID09PSAnJykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiB2YWwgPT09ICdib29sZWFuJykge1xuICAgIHZhbCA9IE51bWJlcih2YWwpO1xuICB9XG5cbiAgYXNzZXJ0Lm9rKCFpc05hTih2YWwpKTtcbiAgaWYgKHZhbCBpbnN0YW5jZW9mIE51bWJlcikge1xuICAgIHJldHVybiB2YWwudmFsdWVPZigpO1xuICB9XG4gIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIHJldHVybiB2YWw7XG4gIH1cbiAgaWYgKCFBcnJheS5pc0FycmF5KHZhbCkgJiYgdHlwZW9mIHZhbC52YWx1ZU9mID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIE51bWJlcih2YWwudmFsdWVPZigpKTtcbiAgfVxuICBpZiAodmFsLnRvU3RyaW5nICYmICFBcnJheS5pc0FycmF5KHZhbCkgJiYgdmFsLnRvU3RyaW5nKCkgPT0gTnVtYmVyKHZhbCkpIHtcbiAgICByZXR1cm4gTnVtYmVyKHZhbCk7XG4gIH1cblxuICBhc3NlcnQub2soZmFsc2UpO1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../server/node_modules/mongoose/lib/cast/number.js\n");

/***/ }),

/***/ "../server/node_modules/mongoose/lib/cast/objectid.js":
/*!************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/cast/objectid.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst isBsonType = __webpack_require__(/*! ../helpers/isBsonType */ \"../server/node_modules/mongoose/lib/helpers/isBsonType.js\");\nconst ObjectId = __webpack_require__(/*! ../types/objectid */ \"../server/node_modules/mongoose/lib/types/objectid.js\");\n\nmodule.exports = function castObjectId(value) {\n  if (value == null) {\n    return value;\n  }\n\n  if (isBsonType(value, 'ObjectId')) {\n    return value;\n  }\n\n  if (value._id) {\n    if (isBsonType(value._id, 'ObjectId')) {\n      return value._id;\n    }\n    if (value._id.toString instanceof Function) {\n      return new ObjectId(value._id.toString());\n    }\n  }\n\n  if (value.toString instanceof Function) {\n    return new ObjectId(value.toString());\n  }\n\n  return new ObjectId(value);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvY2FzdC9vYmplY3RpZC5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixtQkFBbUIsbUJBQU8sQ0FBQyx3RkFBdUI7QUFDbEQsaUJBQWlCLG1CQUFPLENBQUMsZ0ZBQW1COztBQUU1QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2NsaWVudC8uLi9zZXJ2ZXIvbm9kZV9tb2R1bGVzL21vbmdvb3NlL2xpYi9jYXN0L29iamVjdGlkLmpzP2I0ZjAiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBpc0Jzb25UeXBlID0gcmVxdWlyZSgnLi4vaGVscGVycy9pc0Jzb25UeXBlJyk7XG5jb25zdCBPYmplY3RJZCA9IHJlcXVpcmUoJy4uL3R5cGVzL29iamVjdGlkJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gY2FzdE9iamVjdElkKHZhbHVlKSB7XG4gIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG5cbiAgaWYgKGlzQnNvblR5cGUodmFsdWUsICdPYmplY3RJZCcpKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG5cbiAgaWYgKHZhbHVlLl9pZCkge1xuICAgIGlmIChpc0Jzb25UeXBlKHZhbHVlLl9pZCwgJ09iamVjdElkJykpIHtcbiAgICAgIHJldHVybiB2YWx1ZS5faWQ7XG4gICAgfVxuICAgIGlmICh2YWx1ZS5faWQudG9TdHJpbmcgaW5zdGFuY2VvZiBGdW5jdGlvbikge1xuICAgICAgcmV0dXJuIG5ldyBPYmplY3RJZCh2YWx1ZS5faWQudG9TdHJpbmcoKSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHZhbHVlLnRvU3RyaW5nIGluc3RhbmNlb2YgRnVuY3Rpb24pIHtcbiAgICByZXR1cm4gbmV3IE9iamVjdElkKHZhbHVlLnRvU3RyaW5nKCkpO1xuICB9XG5cbiAgcmV0dXJuIG5ldyBPYmplY3RJZCh2YWx1ZSk7XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../server/node_modules/mongoose/lib/cast/objectid.js\n");

/***/ }),

/***/ "../server/node_modules/mongoose/lib/cast/string.js":
/*!**********************************************************!*\
  !*** ../server/node_modules/mongoose/lib/cast/string.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst CastError = __webpack_require__(/*! ../error/cast */ \"../server/node_modules/mongoose/lib/error/cast.js\");\n\n/**\n * Given a value, cast it to a string, or throw a `CastError` if the value\n * cannot be casted. `null` and `undefined` are considered valid.\n *\n * @param {Any} value\n * @param {String} [path] optional the path to set on the CastError\n * @return {string|null|undefined}\n * @throws {CastError}\n * @api private\n */\n\nmodule.exports = function castString(value, path) {\n  // If null or undefined\n  if (value == null) {\n    return value;\n  }\n\n  // handle documents being passed\n  if (value._id && typeof value._id === 'string') {\n    return value._id;\n  }\n\n  // Re: gh-647 and gh-3030, we're ok with casting using `toString()`\n  // **unless** its the default Object.toString, because \"[object Object]\"\n  // doesn't really qualify as useful data\n  if (value.toString &&\n      value.toString !== Object.prototype.toString &&\n      !Array.isArray(value)) {\n    return value.toString();\n  }\n\n  throw new CastError('string', value, path);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvY2FzdC9zdHJpbmcuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsa0JBQWtCLG1CQUFPLENBQUMsd0VBQWU7O0FBRXpDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsUUFBUTtBQUNuQixZQUFZO0FBQ1osWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbGllbnQvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvY2FzdC9zdHJpbmcuanM/YTY1OCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IENhc3RFcnJvciA9IHJlcXVpcmUoJy4uL2Vycm9yL2Nhc3QnKTtcblxuLyoqXG4gKiBHaXZlbiBhIHZhbHVlLCBjYXN0IGl0IHRvIGEgc3RyaW5nLCBvciB0aHJvdyBhIGBDYXN0RXJyb3JgIGlmIHRoZSB2YWx1ZVxuICogY2Fubm90IGJlIGNhc3RlZC4gYG51bGxgIGFuZCBgdW5kZWZpbmVkYCBhcmUgY29uc2lkZXJlZCB2YWxpZC5cbiAqXG4gKiBAcGFyYW0ge0FueX0gdmFsdWVcbiAqIEBwYXJhbSB7U3RyaW5nfSBbcGF0aF0gb3B0aW9uYWwgdGhlIHBhdGggdG8gc2V0IG9uIHRoZSBDYXN0RXJyb3JcbiAqIEByZXR1cm4ge3N0cmluZ3xudWxsfHVuZGVmaW5lZH1cbiAqIEB0aHJvd3Mge0Nhc3RFcnJvcn1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gY2FzdFN0cmluZyh2YWx1ZSwgcGF0aCkge1xuICAvLyBJZiBudWxsIG9yIHVuZGVmaW5lZFxuICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuXG4gIC8vIGhhbmRsZSBkb2N1bWVudHMgYmVpbmcgcGFzc2VkXG4gIGlmICh2YWx1ZS5faWQgJiYgdHlwZW9mIHZhbHVlLl9pZCA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gdmFsdWUuX2lkO1xuICB9XG5cbiAgLy8gUmU6IGdoLTY0NyBhbmQgZ2gtMzAzMCwgd2UncmUgb2sgd2l0aCBjYXN0aW5nIHVzaW5nIGB0b1N0cmluZygpYFxuICAvLyAqKnVubGVzcyoqIGl0cyB0aGUgZGVmYXVsdCBPYmplY3QudG9TdHJpbmcsIGJlY2F1c2UgXCJbb2JqZWN0IE9iamVjdF1cIlxuICAvLyBkb2Vzbid0IHJlYWxseSBxdWFsaWZ5IGFzIHVzZWZ1bCBkYXRhXG4gIGlmICh2YWx1ZS50b1N0cmluZyAmJlxuICAgICAgdmFsdWUudG9TdHJpbmcgIT09IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcgJiZcbiAgICAgICFBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgIHJldHVybiB2YWx1ZS50b1N0cmluZygpO1xuICB9XG5cbiAgdGhyb3cgbmV3IENhc3RFcnJvcignc3RyaW5nJywgdmFsdWUsIHBhdGgpO1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../server/node_modules/mongoose/lib/cast/string.js\n");

/***/ }),

/***/ "../server/node_modules/mongoose/lib/collection.js":
/*!*********************************************************!*\
  !*** ../server/node_modules/mongoose/lib/collection.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\n/*!\n * Module dependencies.\n */\n\nconst EventEmitter = (__webpack_require__(/*! events */ \"events\").EventEmitter);\nconst STATES = __webpack_require__(/*! ./connectionState */ \"../server/node_modules/mongoose/lib/connectionState.js\");\nconst immediate = __webpack_require__(/*! ./helpers/immediate */ \"../server/node_modules/mongoose/lib/helpers/immediate.js\");\n\n/**\n * Abstract Collection constructor\n *\n * This is the base class that drivers inherit from and implement.\n *\n * @param {String} name name of the collection\n * @param {Connection} conn A MongooseConnection instance\n * @param {Object} [opts] optional collection options\n * @api public\n */\n\nfunction Collection(name, conn, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  this.opts = opts;\n  this.name = name;\n  this.collectionName = name;\n  this.conn = conn;\n  this.queue = [];\n  this.buffer = true;\n  this.emitter = new EventEmitter();\n\n  if (STATES.connected === this.conn.readyState) {\n    this.onOpen();\n  }\n}\n\n/**\n * The collection name\n *\n * @api public\n * @property name\n */\n\nCollection.prototype.name;\n\n/**\n * The collection name\n *\n * @api public\n * @property collectionName\n */\n\nCollection.prototype.collectionName;\n\n/**\n * The Connection instance\n *\n * @api public\n * @property conn\n */\n\nCollection.prototype.conn;\n\n/**\n * Called when the database connects\n *\n * @api private\n */\n\nCollection.prototype.onOpen = function() {\n  this.buffer = false;\n  immediate(() => this.doQueue());\n};\n\n/**\n * Called when the database disconnects\n *\n * @api private\n */\n\nCollection.prototype.onClose = function() {};\n\n/**\n * Queues a method for later execution when its\n * database connection opens.\n *\n * @param {String} name name of the method to queue\n * @param {Array} args arguments to pass to the method when executed\n * @api private\n */\n\nCollection.prototype.addQueue = function(name, args) {\n  this.queue.push([name, args]);\n  return this;\n};\n\n/**\n * Removes a queued method\n *\n * @param {String} name name of the method to queue\n * @param {Array} args arguments to pass to the method when executed\n * @api private\n */\n\nCollection.prototype.removeQueue = function(name, args) {\n  const index = this.queue.findIndex(v => v[0] === name && v[1] === args);\n  if (index === -1) {\n    return false;\n  }\n  this.queue.splice(index, 1);\n  return true;\n};\n\n/**\n * Executes all queued methods and clears the queue.\n *\n * @api private\n */\n\nCollection.prototype.doQueue = function() {\n  for (const method of this.queue) {\n    if (typeof method[0] === 'function') {\n      method[0].apply(this, method[1]);\n    } else {\n      this[method[0]].apply(this, method[1]);\n    }\n  }\n  this.queue = [];\n  const _this = this;\n  immediate(function() {\n    _this.emitter.emit('queue');\n  });\n  return this;\n};\n\n/**\n * Abstract method that drivers must implement.\n */\n\nCollection.prototype.ensureIndex = function() {\n  throw new Error('Collection#ensureIndex unimplemented by driver');\n};\n\n/**\n * Abstract method that drivers must implement.\n */\n\nCollection.prototype.createIndex = function() {\n  throw new Error('Collection#createIndex unimplemented by driver');\n};\n\n/**\n * Abstract method that drivers must implement.\n */\n\nCollection.prototype.findAndModify = function() {\n  throw new Error('Collection#findAndModify unimplemented by driver');\n};\n\n/**\n * Abstract method that drivers must implement.\n */\n\nCollection.prototype.findOneAndUpdate = function() {\n  throw new Error('Collection#findOneAndUpdate unimplemented by driver');\n};\n\n/**\n * Abstract method that drivers must implement.\n */\n\nCollection.prototype.findOneAndDelete = function() {\n  throw new Error('Collection#findOneAndDelete unimplemented by driver');\n};\n\n/**\n * Abstract method that drivers must implement.\n */\n\nCollection.prototype.findOneAndReplace = function() {\n  throw new Error('Collection#findOneAndReplace unimplemented by driver');\n};\n\n/**\n * Abstract method that drivers must implement.\n */\n\nCollection.prototype.findOne = function() {\n  throw new Error('Collection#findOne unimplemented by driver');\n};\n\n/**\n * Abstract method that drivers must implement.\n */\n\nCollection.prototype.find = function() {\n  throw new Error('Collection#find unimplemented by driver');\n};\n\n/**\n * Abstract method that drivers must implement.\n */\n\nCollection.prototype.insert = function() {\n  throw new Error('Collection#insert unimplemented by driver');\n};\n\n/**\n * Abstract method that drivers must implement.\n */\n\nCollection.prototype.insertOne = function() {\n  throw new Error('Collection#insertOne unimplemented by driver');\n};\n\n/**\n * Abstract method that drivers must implement.\n */\n\nCollection.prototype.insertMany = function() {\n  throw new Error('Collection#insertMany unimplemented by driver');\n};\n\n/**\n * Abstract method that drivers must implement.\n */\n\nCollection.prototype.save = function() {\n  throw new Error('Collection#save unimplemented by driver');\n};\n\n/**\n * Abstract method that drivers must implement.\n */\n\nCollection.prototype.updateOne = function() {\n  throw new Error('Collection#updateOne unimplemented by driver');\n};\n\n/**\n * Abstract method that drivers must implement.\n */\n\nCollection.prototype.updateMany = function() {\n  throw new Error('Collection#updateMany unimplemented by driver');\n};\n\n/**\n * Abstract method that drivers must implement.\n */\n\nCollection.prototype.deleteOne = function() {\n  throw new Error('Collection#deleteOne unimplemented by driver');\n};\n\n/**\n * Abstract method that drivers must implement.\n */\n\nCollection.prototype.deleteMany = function() {\n  throw new Error('Collection#deleteMany unimplemented by driver');\n};\n\n/**\n * Abstract method that drivers must implement.\n */\n\nCollection.prototype.getIndexes = function() {\n  throw new Error('Collection#getIndexes unimplemented by driver');\n};\n\n/**\n * Abstract method that drivers must implement.\n */\n\nCollection.prototype.watch = function() {\n  throw new Error('Collection#watch unimplemented by driver');\n};\n\n/*!\n * ignore\n */\n\nCollection.prototype._shouldBufferCommands = function _shouldBufferCommands() {\n  const opts = this.opts;\n\n  if (opts.bufferCommands != null) {\n    return opts.bufferCommands;\n  }\n  if (opts && opts.schemaUserProvidedOptions != null && opts.schemaUserProvidedOptions.bufferCommands != null) {\n    return opts.schemaUserProvidedOptions.bufferCommands;\n  }\n\n  return this.conn._shouldBufferCommands();\n};\n\n/*!\n * ignore\n */\n\nCollection.prototype._getBufferTimeoutMS = function _getBufferTimeoutMS() {\n  const conn = this.conn;\n  const opts = this.opts;\n\n  if (opts.bufferTimeoutMS != null) {\n    return opts.bufferTimeoutMS;\n  }\n  if (opts && opts.schemaUserProvidedOptions != null && opts.schemaUserProvidedOptions.bufferTimeoutMS != null) {\n    return opts.schemaUserProvidedOptions.bufferTimeoutMS;\n  }\n  if (conn.config.bufferTimeoutMS != null) {\n    return conn.config.bufferTimeoutMS;\n  }\n  if (conn.base != null && conn.base.get('bufferTimeoutMS') != null) {\n    return conn.base.get('bufferTimeoutMS');\n  }\n  return 10000;\n};\n\n/*!\n * Module exports.\n */\n\nmodule.exports = Collection;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvY29sbGVjdGlvbi5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBO0FBQ0E7O0FBRUEscUJBQXFCLDBEQUE4QjtBQUNuRCxlQUFlLG1CQUFPLENBQUMsaUZBQW1CO0FBQzFDLGtCQUFrQixtQkFBTyxDQUFDLHFGQUFxQjs7QUFFL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFlBQVk7QUFDdkIsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsT0FBTztBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLE9BQU87QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2xpZW50Ly4uL3NlcnZlci9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2NvbGxlY3Rpb24uanM/ODcxZSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbi8qIVxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG5jb25zdCBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXI7XG5jb25zdCBTVEFURVMgPSByZXF1aXJlKCcuL2Nvbm5lY3Rpb25TdGF0ZScpO1xuY29uc3QgaW1tZWRpYXRlID0gcmVxdWlyZSgnLi9oZWxwZXJzL2ltbWVkaWF0ZScpO1xuXG4vKipcbiAqIEFic3RyYWN0IENvbGxlY3Rpb24gY29uc3RydWN0b3JcbiAqXG4gKiBUaGlzIGlzIHRoZSBiYXNlIGNsYXNzIHRoYXQgZHJpdmVycyBpbmhlcml0IGZyb20gYW5kIGltcGxlbWVudC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBuYW1lIG9mIHRoZSBjb2xsZWN0aW9uXG4gKiBAcGFyYW0ge0Nvbm5lY3Rpb259IGNvbm4gQSBNb25nb29zZUNvbm5lY3Rpb24gaW5zdGFuY2VcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0c10gb3B0aW9uYWwgY29sbGVjdGlvbiBvcHRpb25zXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIENvbGxlY3Rpb24obmFtZSwgY29ubiwgb3B0cykge1xuICBpZiAob3B0cyA9PT0gdm9pZCAwKSB7XG4gICAgb3B0cyA9IHt9O1xuICB9XG5cbiAgdGhpcy5vcHRzID0gb3B0cztcbiAgdGhpcy5uYW1lID0gbmFtZTtcbiAgdGhpcy5jb2xsZWN0aW9uTmFtZSA9IG5hbWU7XG4gIHRoaXMuY29ubiA9IGNvbm47XG4gIHRoaXMucXVldWUgPSBbXTtcbiAgdGhpcy5idWZmZXIgPSB0cnVlO1xuICB0aGlzLmVtaXR0ZXIgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG5cbiAgaWYgKFNUQVRFUy5jb25uZWN0ZWQgPT09IHRoaXMuY29ubi5yZWFkeVN0YXRlKSB7XG4gICAgdGhpcy5vbk9wZW4oKTtcbiAgfVxufVxuXG4vKipcbiAqIFRoZSBjb2xsZWN0aW9uIG5hbWVcbiAqXG4gKiBAYXBpIHB1YmxpY1xuICogQHByb3BlcnR5IG5hbWVcbiAqL1xuXG5Db2xsZWN0aW9uLnByb3RvdHlwZS5uYW1lO1xuXG4vKipcbiAqIFRoZSBjb2xsZWN0aW9uIG5hbWVcbiAqXG4gKiBAYXBpIHB1YmxpY1xuICogQHByb3BlcnR5IGNvbGxlY3Rpb25OYW1lXG4gKi9cblxuQ29sbGVjdGlvbi5wcm90b3R5cGUuY29sbGVjdGlvbk5hbWU7XG5cbi8qKlxuICogVGhlIENvbm5lY3Rpb24gaW5zdGFuY2VcbiAqXG4gKiBAYXBpIHB1YmxpY1xuICogQHByb3BlcnR5IGNvbm5cbiAqL1xuXG5Db2xsZWN0aW9uLnByb3RvdHlwZS5jb25uO1xuXG4vKipcbiAqIENhbGxlZCB3aGVuIHRoZSBkYXRhYmFzZSBjb25uZWN0c1xuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbkNvbGxlY3Rpb24ucHJvdG90eXBlLm9uT3BlbiA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLmJ1ZmZlciA9IGZhbHNlO1xuICBpbW1lZGlhdGUoKCkgPT4gdGhpcy5kb1F1ZXVlKCkpO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgd2hlbiB0aGUgZGF0YWJhc2UgZGlzY29ubmVjdHNcbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Db2xsZWN0aW9uLnByb3RvdHlwZS5vbkNsb3NlID0gZnVuY3Rpb24oKSB7fTtcblxuLyoqXG4gKiBRdWV1ZXMgYSBtZXRob2QgZm9yIGxhdGVyIGV4ZWN1dGlvbiB3aGVuIGl0c1xuICogZGF0YWJhc2UgY29ubmVjdGlvbiBvcGVucy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBuYW1lIG9mIHRoZSBtZXRob2QgdG8gcXVldWVcbiAqIEBwYXJhbSB7QXJyYXl9IGFyZ3MgYXJndW1lbnRzIHRvIHBhc3MgdG8gdGhlIG1ldGhvZCB3aGVuIGV4ZWN1dGVkXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Db2xsZWN0aW9uLnByb3RvdHlwZS5hZGRRdWV1ZSA9IGZ1bmN0aW9uKG5hbWUsIGFyZ3MpIHtcbiAgdGhpcy5xdWV1ZS5wdXNoKFtuYW1lLCBhcmdzXSk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBSZW1vdmVzIGEgcXVldWVkIG1ldGhvZFxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIG5hbWUgb2YgdGhlIG1ldGhvZCB0byBxdWV1ZVxuICogQHBhcmFtIHtBcnJheX0gYXJncyBhcmd1bWVudHMgdG8gcGFzcyB0byB0aGUgbWV0aG9kIHdoZW4gZXhlY3V0ZWRcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbkNvbGxlY3Rpb24ucHJvdG90eXBlLnJlbW92ZVF1ZXVlID0gZnVuY3Rpb24obmFtZSwgYXJncykge1xuICBjb25zdCBpbmRleCA9IHRoaXMucXVldWUuZmluZEluZGV4KHYgPT4gdlswXSA9PT0gbmFtZSAmJiB2WzFdID09PSBhcmdzKTtcbiAgaWYgKGluZGV4ID09PSAtMSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB0aGlzLnF1ZXVlLnNwbGljZShpbmRleCwgMSk7XG4gIHJldHVybiB0cnVlO1xufTtcblxuLyoqXG4gKiBFeGVjdXRlcyBhbGwgcXVldWVkIG1ldGhvZHMgYW5kIGNsZWFycyB0aGUgcXVldWUuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuQ29sbGVjdGlvbi5wcm90b3R5cGUuZG9RdWV1ZSA9IGZ1bmN0aW9uKCkge1xuICBmb3IgKGNvbnN0IG1ldGhvZCBvZiB0aGlzLnF1ZXVlKSB7XG4gICAgaWYgKHR5cGVvZiBtZXRob2RbMF0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIG1ldGhvZFswXS5hcHBseSh0aGlzLCBtZXRob2RbMV0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzW21ldGhvZFswXV0uYXBwbHkodGhpcywgbWV0aG9kWzFdKTtcbiAgICB9XG4gIH1cbiAgdGhpcy5xdWV1ZSA9IFtdO1xuICBjb25zdCBfdGhpcyA9IHRoaXM7XG4gIGltbWVkaWF0ZShmdW5jdGlvbigpIHtcbiAgICBfdGhpcy5lbWl0dGVyLmVtaXQoJ3F1ZXVlJyk7XG4gIH0pO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQWJzdHJhY3QgbWV0aG9kIHRoYXQgZHJpdmVycyBtdXN0IGltcGxlbWVudC5cbiAqL1xuXG5Db2xsZWN0aW9uLnByb3RvdHlwZS5lbnN1cmVJbmRleCA9IGZ1bmN0aW9uKCkge1xuICB0aHJvdyBuZXcgRXJyb3IoJ0NvbGxlY3Rpb24jZW5zdXJlSW5kZXggdW5pbXBsZW1lbnRlZCBieSBkcml2ZXInKTtcbn07XG5cbi8qKlxuICogQWJzdHJhY3QgbWV0aG9kIHRoYXQgZHJpdmVycyBtdXN0IGltcGxlbWVudC5cbiAqL1xuXG5Db2xsZWN0aW9uLnByb3RvdHlwZS5jcmVhdGVJbmRleCA9IGZ1bmN0aW9uKCkge1xuICB0aHJvdyBuZXcgRXJyb3IoJ0NvbGxlY3Rpb24jY3JlYXRlSW5kZXggdW5pbXBsZW1lbnRlZCBieSBkcml2ZXInKTtcbn07XG5cbi8qKlxuICogQWJzdHJhY3QgbWV0aG9kIHRoYXQgZHJpdmVycyBtdXN0IGltcGxlbWVudC5cbiAqL1xuXG5Db2xsZWN0aW9uLnByb3RvdHlwZS5maW5kQW5kTW9kaWZ5ID0gZnVuY3Rpb24oKSB7XG4gIHRocm93IG5ldyBFcnJvcignQ29sbGVjdGlvbiNmaW5kQW5kTW9kaWZ5IHVuaW1wbGVtZW50ZWQgYnkgZHJpdmVyJyk7XG59O1xuXG4vKipcbiAqIEFic3RyYWN0IG1ldGhvZCB0aGF0IGRyaXZlcnMgbXVzdCBpbXBsZW1lbnQuXG4gKi9cblxuQ29sbGVjdGlvbi5wcm90b3R5cGUuZmluZE9uZUFuZFVwZGF0ZSA9IGZ1bmN0aW9uKCkge1xuICB0aHJvdyBuZXcgRXJyb3IoJ0NvbGxlY3Rpb24jZmluZE9uZUFuZFVwZGF0ZSB1bmltcGxlbWVudGVkIGJ5IGRyaXZlcicpO1xufTtcblxuLyoqXG4gKiBBYnN0cmFjdCBtZXRob2QgdGhhdCBkcml2ZXJzIG11c3QgaW1wbGVtZW50LlxuICovXG5cbkNvbGxlY3Rpb24ucHJvdG90eXBlLmZpbmRPbmVBbmREZWxldGUgPSBmdW5jdGlvbigpIHtcbiAgdGhyb3cgbmV3IEVycm9yKCdDb2xsZWN0aW9uI2ZpbmRPbmVBbmREZWxldGUgdW5pbXBsZW1lbnRlZCBieSBkcml2ZXInKTtcbn07XG5cbi8qKlxuICogQWJzdHJhY3QgbWV0aG9kIHRoYXQgZHJpdmVycyBtdXN0IGltcGxlbWVudC5cbiAqL1xuXG5Db2xsZWN0aW9uLnByb3RvdHlwZS5maW5kT25lQW5kUmVwbGFjZSA9IGZ1bmN0aW9uKCkge1xuICB0aHJvdyBuZXcgRXJyb3IoJ0NvbGxlY3Rpb24jZmluZE9uZUFuZFJlcGxhY2UgdW5pbXBsZW1lbnRlZCBieSBkcml2ZXInKTtcbn07XG5cbi8qKlxuICogQWJzdHJhY3QgbWV0aG9kIHRoYXQgZHJpdmVycyBtdXN0IGltcGxlbWVudC5cbiAqL1xuXG5Db2xsZWN0aW9uLnByb3RvdHlwZS5maW5kT25lID0gZnVuY3Rpb24oKSB7XG4gIHRocm93IG5ldyBFcnJvcignQ29sbGVjdGlvbiNmaW5kT25lIHVuaW1wbGVtZW50ZWQgYnkgZHJpdmVyJyk7XG59O1xuXG4vKipcbiAqIEFic3RyYWN0IG1ldGhvZCB0aGF0IGRyaXZlcnMgbXVzdCBpbXBsZW1lbnQuXG4gKi9cblxuQ29sbGVjdGlvbi5wcm90b3R5cGUuZmluZCA9IGZ1bmN0aW9uKCkge1xuICB0aHJvdyBuZXcgRXJyb3IoJ0NvbGxlY3Rpb24jZmluZCB1bmltcGxlbWVudGVkIGJ5IGRyaXZlcicpO1xufTtcblxuLyoqXG4gKiBBYnN0cmFjdCBtZXRob2QgdGhhdCBkcml2ZXJzIG11c3QgaW1wbGVtZW50LlxuICovXG5cbkNvbGxlY3Rpb24ucHJvdG90eXBlLmluc2VydCA9IGZ1bmN0aW9uKCkge1xuICB0aHJvdyBuZXcgRXJyb3IoJ0NvbGxlY3Rpb24jaW5zZXJ0IHVuaW1wbGVtZW50ZWQgYnkgZHJpdmVyJyk7XG59O1xuXG4vKipcbiAqIEFic3RyYWN0IG1ldGhvZCB0aGF0IGRyaXZlcnMgbXVzdCBpbXBsZW1lbnQuXG4gKi9cblxuQ29sbGVjdGlvbi5wcm90b3R5cGUuaW5zZXJ0T25lID0gZnVuY3Rpb24oKSB7XG4gIHRocm93IG5ldyBFcnJvcignQ29sbGVjdGlvbiNpbnNlcnRPbmUgdW5pbXBsZW1lbnRlZCBieSBkcml2ZXInKTtcbn07XG5cbi8qKlxuICogQWJzdHJhY3QgbWV0aG9kIHRoYXQgZHJpdmVycyBtdXN0IGltcGxlbWVudC5cbiAqL1xuXG5Db2xsZWN0aW9uLnByb3RvdHlwZS5pbnNlcnRNYW55ID0gZnVuY3Rpb24oKSB7XG4gIHRocm93IG5ldyBFcnJvcignQ29sbGVjdGlvbiNpbnNlcnRNYW55IHVuaW1wbGVtZW50ZWQgYnkgZHJpdmVyJyk7XG59O1xuXG4vKipcbiAqIEFic3RyYWN0IG1ldGhvZCB0aGF0IGRyaXZlcnMgbXVzdCBpbXBsZW1lbnQuXG4gKi9cblxuQ29sbGVjdGlvbi5wcm90b3R5cGUuc2F2ZSA9IGZ1bmN0aW9uKCkge1xuICB0aHJvdyBuZXcgRXJyb3IoJ0NvbGxlY3Rpb24jc2F2ZSB1bmltcGxlbWVudGVkIGJ5IGRyaXZlcicpO1xufTtcblxuLyoqXG4gKiBBYnN0cmFjdCBtZXRob2QgdGhhdCBkcml2ZXJzIG11c3QgaW1wbGVtZW50LlxuICovXG5cbkNvbGxlY3Rpb24ucHJvdG90eXBlLnVwZGF0ZU9uZSA9IGZ1bmN0aW9uKCkge1xuICB0aHJvdyBuZXcgRXJyb3IoJ0NvbGxlY3Rpb24jdXBkYXRlT25lIHVuaW1wbGVtZW50ZWQgYnkgZHJpdmVyJyk7XG59O1xuXG4vKipcbiAqIEFic3RyYWN0IG1ldGhvZCB0aGF0IGRyaXZlcnMgbXVzdCBpbXBsZW1lbnQuXG4gKi9cblxuQ29sbGVjdGlvbi5wcm90b3R5cGUudXBkYXRlTWFueSA9IGZ1bmN0aW9uKCkge1xuICB0aHJvdyBuZXcgRXJyb3IoJ0NvbGxlY3Rpb24jdXBkYXRlTWFueSB1bmltcGxlbWVudGVkIGJ5IGRyaXZlcicpO1xufTtcblxuLyoqXG4gKiBBYnN0cmFjdCBtZXRob2QgdGhhdCBkcml2ZXJzIG11c3QgaW1wbGVtZW50LlxuICovXG5cbkNvbGxlY3Rpb24ucHJvdG90eXBlLmRlbGV0ZU9uZSA9IGZ1bmN0aW9uKCkge1xuICB0aHJvdyBuZXcgRXJyb3IoJ0NvbGxlY3Rpb24jZGVsZXRlT25lIHVuaW1wbGVtZW50ZWQgYnkgZHJpdmVyJyk7XG59O1xuXG4vKipcbiAqIEFic3RyYWN0IG1ldGhvZCB0aGF0IGRyaXZlcnMgbXVzdCBpbXBsZW1lbnQuXG4gKi9cblxuQ29sbGVjdGlvbi5wcm90b3R5cGUuZGVsZXRlTWFueSA9IGZ1bmN0aW9uKCkge1xuICB0aHJvdyBuZXcgRXJyb3IoJ0NvbGxlY3Rpb24jZGVsZXRlTWFueSB1bmltcGxlbWVudGVkIGJ5IGRyaXZlcicpO1xufTtcblxuLyoqXG4gKiBBYnN0cmFjdCBtZXRob2QgdGhhdCBkcml2ZXJzIG11c3QgaW1wbGVtZW50LlxuICovXG5cbkNvbGxlY3Rpb24ucHJvdG90eXBlLmdldEluZGV4ZXMgPSBmdW5jdGlvbigpIHtcbiAgdGhyb3cgbmV3IEVycm9yKCdDb2xsZWN0aW9uI2dldEluZGV4ZXMgdW5pbXBsZW1lbnRlZCBieSBkcml2ZXInKTtcbn07XG5cbi8qKlxuICogQWJzdHJhY3QgbWV0aG9kIHRoYXQgZHJpdmVycyBtdXN0IGltcGxlbWVudC5cbiAqL1xuXG5Db2xsZWN0aW9uLnByb3RvdHlwZS53YXRjaCA9IGZ1bmN0aW9uKCkge1xuICB0aHJvdyBuZXcgRXJyb3IoJ0NvbGxlY3Rpb24jd2F0Y2ggdW5pbXBsZW1lbnRlZCBieSBkcml2ZXInKTtcbn07XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxuQ29sbGVjdGlvbi5wcm90b3R5cGUuX3Nob3VsZEJ1ZmZlckNvbW1hbmRzID0gZnVuY3Rpb24gX3Nob3VsZEJ1ZmZlckNvbW1hbmRzKCkge1xuICBjb25zdCBvcHRzID0gdGhpcy5vcHRzO1xuXG4gIGlmIChvcHRzLmJ1ZmZlckNvbW1hbmRzICE9IG51bGwpIHtcbiAgICByZXR1cm4gb3B0cy5idWZmZXJDb21tYW5kcztcbiAgfVxuICBpZiAob3B0cyAmJiBvcHRzLnNjaGVtYVVzZXJQcm92aWRlZE9wdGlvbnMgIT0gbnVsbCAmJiBvcHRzLnNjaGVtYVVzZXJQcm92aWRlZE9wdGlvbnMuYnVmZmVyQ29tbWFuZHMgIT0gbnVsbCkge1xuICAgIHJldHVybiBvcHRzLnNjaGVtYVVzZXJQcm92aWRlZE9wdGlvbnMuYnVmZmVyQ29tbWFuZHM7XG4gIH1cblxuICByZXR1cm4gdGhpcy5jb25uLl9zaG91bGRCdWZmZXJDb21tYW5kcygpO1xufTtcblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5Db2xsZWN0aW9uLnByb3RvdHlwZS5fZ2V0QnVmZmVyVGltZW91dE1TID0gZnVuY3Rpb24gX2dldEJ1ZmZlclRpbWVvdXRNUygpIHtcbiAgY29uc3QgY29ubiA9IHRoaXMuY29ubjtcbiAgY29uc3Qgb3B0cyA9IHRoaXMub3B0cztcblxuICBpZiAob3B0cy5idWZmZXJUaW1lb3V0TVMgIT0gbnVsbCkge1xuICAgIHJldHVybiBvcHRzLmJ1ZmZlclRpbWVvdXRNUztcbiAgfVxuICBpZiAob3B0cyAmJiBvcHRzLnNjaGVtYVVzZXJQcm92aWRlZE9wdGlvbnMgIT0gbnVsbCAmJiBvcHRzLnNjaGVtYVVzZXJQcm92aWRlZE9wdGlvbnMuYnVmZmVyVGltZW91dE1TICE9IG51bGwpIHtcbiAgICByZXR1cm4gb3B0cy5zY2hlbWFVc2VyUHJvdmlkZWRPcHRpb25zLmJ1ZmZlclRpbWVvdXRNUztcbiAgfVxuICBpZiAoY29ubi5jb25maWcuYnVmZmVyVGltZW91dE1TICE9IG51bGwpIHtcbiAgICByZXR1cm4gY29ubi5jb25maWcuYnVmZmVyVGltZW91dE1TO1xuICB9XG4gIGlmIChjb25uLmJhc2UgIT0gbnVsbCAmJiBjb25uLmJhc2UuZ2V0KCdidWZmZXJUaW1lb3V0TVMnKSAhPSBudWxsKSB7XG4gICAgcmV0dXJuIGNvbm4uYmFzZS5nZXQoJ2J1ZmZlclRpbWVvdXRNUycpO1xuICB9XG4gIHJldHVybiAxMDAwMDtcbn07XG5cbi8qIVxuICogTW9kdWxlIGV4cG9ydHMuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBDb2xsZWN0aW9uO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../server/node_modules/mongoose/lib/collection.js\n");

/***/ }),

/***/ "../server/node_modules/mongoose/lib/connection.js":
/*!*********************************************************!*\
  !*** ../server/node_modules/mongoose/lib/connection.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\n/*!\n * Module dependencies.\n */\n\nconst ChangeStream = __webpack_require__(/*! ./cursor/changeStream */ \"../server/node_modules/mongoose/lib/cursor/changeStream.js\");\nconst EventEmitter = (__webpack_require__(/*! events */ \"events\").EventEmitter);\nconst Schema = __webpack_require__(/*! ./schema */ \"../server/node_modules/mongoose/lib/schema.js\");\nconst STATES = __webpack_require__(/*! ./connectionState */ \"../server/node_modules/mongoose/lib/connectionState.js\");\nconst MongooseError = __webpack_require__(/*! ./error/index */ \"../server/node_modules/mongoose/lib/error/index.js\");\nconst ServerSelectionError = __webpack_require__(/*! ./error/serverSelection */ \"../server/node_modules/mongoose/lib/error/serverSelection.js\");\nconst SyncIndexesError = __webpack_require__(/*! ./error/syncIndexes */ \"../server/node_modules/mongoose/lib/error/syncIndexes.js\");\nconst applyPlugins = __webpack_require__(/*! ./helpers/schema/applyPlugins */ \"../server/node_modules/mongoose/lib/helpers/schema/applyPlugins.js\");\nconst clone = __webpack_require__(/*! ./helpers/clone */ \"../server/node_modules/mongoose/lib/helpers/clone.js\");\nconst driver = __webpack_require__(/*! ./driver */ \"../server/node_modules/mongoose/lib/driver.js\");\nconst get = __webpack_require__(/*! ./helpers/get */ \"../server/node_modules/mongoose/lib/helpers/get.js\");\nconst immediate = __webpack_require__(/*! ./helpers/immediate */ \"../server/node_modules/mongoose/lib/helpers/immediate.js\");\nconst utils = __webpack_require__(/*! ./utils */ \"../server/node_modules/mongoose/lib/utils.js\");\nconst CreateCollectionsError = __webpack_require__(/*! ./error/createCollectionsError */ \"../server/node_modules/mongoose/lib/error/createCollectionsError.js\");\n\nconst arrayAtomicsSymbol = (__webpack_require__(/*! ./helpers/symbols */ \"../server/node_modules/mongoose/lib/helpers/symbols.js\").arrayAtomicsSymbol);\nconst sessionNewDocuments = (__webpack_require__(/*! ./helpers/symbols */ \"../server/node_modules/mongoose/lib/helpers/symbols.js\").sessionNewDocuments);\n\n/**\n * A list of authentication mechanisms that don't require a password for authentication.\n * This is used by the authMechanismDoesNotRequirePassword method.\n *\n * @api private\n */\nconst noPasswordAuthMechanisms = [\n  'MONGODB-X509'\n];\n\n/**\n * Connection constructor\n *\n * For practical reasons, a Connection equals a Db.\n *\n * @param {Mongoose} base a mongoose instance\n * @inherits NodeJS EventEmitter https://nodejs.org/api/events.html#class-eventemitter\n * @event `connecting`: Emitted when `connection.openUri()` is executed on this connection.\n * @event `connected`: Emitted when this connection successfully connects to the db. May be emitted _multiple_ times in `reconnected` scenarios.\n * @event `open`: Emitted after we `connected` and `onOpen` is executed on all of this connection's models.\n * @event `disconnecting`: Emitted when `connection.close()` was executed.\n * @event `disconnected`: Emitted after getting disconnected from the db.\n * @event `close`: Emitted after we `disconnected` and `onClose` executed on all of this connection's models.\n * @event `reconnected`: Emitted after we `connected` and subsequently `disconnected`, followed by successfully another successful connection.\n * @event `error`: Emitted when an error occurs on this connection.\n * @event `fullsetup`: Emitted after the driver has connected to primary and all secondaries if specified in the connection string.\n * @api public\n */\n\nfunction Connection(base) {\n  this.base = base;\n  this.collections = {};\n  this.models = {};\n  this.config = {};\n  this.replica = false;\n  this.options = null;\n  this.otherDbs = []; // FIXME: To be replaced with relatedDbs\n  this.relatedDbs = {}; // Hashmap of other dbs that share underlying connection\n  this.states = STATES;\n  this._readyState = STATES.disconnected;\n  this._closeCalled = false;\n  this._hasOpened = false;\n  this.plugins = [];\n  if (typeof base === 'undefined' || !base.connections.length) {\n    this.id = 0;\n  } else {\n    this.id = base.nextConnectionId;\n  }\n  this._queue = [];\n}\n\n/*!\n * Inherit from EventEmitter\n */\n\nObject.setPrototypeOf(Connection.prototype, EventEmitter.prototype);\n\n/**\n * Connection ready state\n *\n * - 0 = disconnected\n * - 1 = connected\n * - 2 = connecting\n * - 3 = disconnecting\n *\n * Each state change emits its associated event name.\n *\n * #### Example:\n *\n *     conn.on('connected', callback);\n *     conn.on('disconnected', callback);\n *\n * @property readyState\n * @memberOf Connection\n * @instance\n * @api public\n */\n\nObject.defineProperty(Connection.prototype, 'readyState', {\n  get: function() {\n    return this._readyState;\n  },\n  set: function(val) {\n    if (!(val in STATES)) {\n      throw new Error('Invalid connection state: ' + val);\n    }\n\n    if (this._readyState !== val) {\n      this._readyState = val;\n      // [legacy] loop over the otherDbs on this connection and change their state\n      for (const db of this.otherDbs) {\n        db.readyState = val;\n      }\n\n      if (STATES.connected === val) {\n        this._hasOpened = true;\n      }\n\n      this.emit(STATES[val]);\n    }\n  }\n});\n\n/**\n * Gets the value of the option `key`. Equivalent to `conn.options[key]`\n *\n * #### Example:\n *\n *     conn.get('test'); // returns the 'test' value\n *\n * @param {String} key\n * @method get\n * @api public\n */\n\nConnection.prototype.get = function(key) {\n  if (this.config.hasOwnProperty(key)) {\n    return this.config[key];\n  }\n\n  return get(this.options, key);\n};\n\n/**\n * Sets the value of the option `key`. Equivalent to `conn.options[key] = val`\n *\n * Supported options include:\n *\n * - `maxTimeMS`: Set [`maxTimeMS`](https://mongoosejs.com/docs/api/query.html#Query.prototype.maxTimeMS()) for all queries on this connection.\n * - 'debug': If `true`, prints the operations mongoose sends to MongoDB to the console. If a writable stream is passed, it will log to that stream, without colorization. If a callback function is passed, it will receive the collection name, the method name, then all arugments passed to the method. For example, if you wanted to replicate the default logging, you could output from the callback `Mongoose: ${collectionName}.${methodName}(${methodArgs.join(', ')})`.\n *\n * #### Example:\n *\n *     conn.set('test', 'foo');\n *     conn.get('test'); // 'foo'\n *     conn.options.test; // 'foo'\n *\n * @param {String} key\n * @param {Any} val\n * @method set\n * @api public\n */\n\nConnection.prototype.set = function(key, val) {\n  if (this.config.hasOwnProperty(key)) {\n    this.config[key] = val;\n    return val;\n  }\n\n  this.options = this.options || {};\n  this.options[key] = val;\n  return val;\n};\n\n/**\n * A hash of the collections associated with this connection\n *\n * @property collections\n * @memberOf Connection\n * @instance\n * @api public\n */\n\nConnection.prototype.collections;\n\n/**\n * The name of the database this connection points to.\n *\n * #### Example:\n *\n *     mongoose.createConnection('mongodb://127.0.0.1:27017/mydb').name; // \"mydb\"\n *\n * @property name\n * @memberOf Connection\n * @instance\n * @api public\n */\n\nConnection.prototype.name;\n\n/**\n * A [POJO](https://masteringjs.io/tutorials/fundamentals/pojo) containing\n * a map from model names to models. Contains all models that have been\n * added to this connection using [`Connection#model()`](https://mongoosejs.com/docs/api/connection.html#Connection.prototype.model()).\n *\n * #### Example:\n *\n *     const conn = mongoose.createConnection();\n *     const Test = conn.model('Test', mongoose.Schema({ name: String }));\n *\n *     Object.keys(conn.models).length; // 1\n *     conn.models.Test === Test; // true\n *\n * @property models\n * @memberOf Connection\n * @instance\n * @api public\n */\n\nConnection.prototype.models;\n\n/**\n * A number identifier for this connection. Used for debugging when\n * you have [multiple connections](https://mongoosejs.com/docs/connections.html#multiple_connections).\n *\n * #### Example:\n *\n *     // The default connection has `id = 0`\n *     mongoose.connection.id; // 0\n *\n *     // If you create a new connection, Mongoose increments id\n *     const conn = mongoose.createConnection();\n *     conn.id; // 1\n *\n * @property id\n * @memberOf Connection\n * @instance\n * @api public\n */\n\nConnection.prototype.id;\n\n/**\n * The plugins that will be applied to all models created on this connection.\n *\n * #### Example:\n *\n *     const db = mongoose.createConnection('mongodb://127.0.0.1:27017/mydb');\n *     db.plugin(() => console.log('Applied'));\n *     db.plugins.length; // 1\n *\n *     db.model('Test', new Schema({})); // Prints \"Applied\"\n *\n * @property plugins\n * @memberOf Connection\n * @instance\n * @api public\n */\n\nObject.defineProperty(Connection.prototype, 'plugins', {\n  configurable: false,\n  enumerable: true,\n  writable: true\n});\n\n/**\n * The host name portion of the URI. If multiple hosts, such as a replica set,\n * this will contain the first host name in the URI\n *\n * #### Example:\n *\n *     mongoose.createConnection('mongodb://127.0.0.1:27017/mydb').host; // \"127.0.0.1\"\n *\n * @property host\n * @memberOf Connection\n * @instance\n * @api public\n */\n\nObject.defineProperty(Connection.prototype, 'host', {\n  configurable: true,\n  enumerable: true,\n  writable: true\n});\n\n/**\n * The port portion of the URI. If multiple hosts, such as a replica set,\n * this will contain the port from the first host name in the URI.\n *\n * #### Example:\n *\n *     mongoose.createConnection('mongodb://127.0.0.1:27017/mydb').port; // 27017\n *\n * @property port\n * @memberOf Connection\n * @instance\n * @api public\n */\n\nObject.defineProperty(Connection.prototype, 'port', {\n  configurable: true,\n  enumerable: true,\n  writable: true\n});\n\n/**\n * The username specified in the URI\n *\n * #### Example:\n *\n *     mongoose.createConnection('mongodb://val:psw@127.0.0.1:27017/mydb').user; // \"val\"\n *\n * @property user\n * @memberOf Connection\n * @instance\n * @api public\n */\n\nObject.defineProperty(Connection.prototype, 'user', {\n  configurable: true,\n  enumerable: true,\n  writable: true\n});\n\n/**\n * The password specified in the URI\n *\n * #### Example:\n *\n *     mongoose.createConnection('mongodb://val:psw@127.0.0.1:27017/mydb').pass; // \"psw\"\n *\n * @property pass\n * @memberOf Connection\n * @instance\n * @api public\n */\n\nObject.defineProperty(Connection.prototype, 'pass', {\n  configurable: true,\n  enumerable: true,\n  writable: true\n});\n\n/**\n * The mongodb.Db instance, set when the connection is opened\n *\n * @property db\n * @memberOf Connection\n * @instance\n * @api public\n */\n\nConnection.prototype.db;\n\n/**\n * The MongoClient instance this connection uses to talk to MongoDB. Mongoose automatically sets this property\n * when the connection is opened.\n *\n * @property client\n * @memberOf Connection\n * @instance\n * @api public\n */\n\nConnection.prototype.client;\n\n/**\n * A hash of the global options that are associated with this connection\n *\n * @property config\n * @memberOf Connection\n * @instance\n * @api public\n */\n\nConnection.prototype.config;\n\n/**\n * Helper for `createCollection()`. Will explicitly create the given collection\n * with specified options. Used to create [capped collections](https://www.mongodb.com/docs/manual/core/capped-collections/)\n * and [views](https://www.mongodb.com/docs/manual/core/views/) from mongoose.\n *\n * Options are passed down without modification to the [MongoDB driver's `createCollection()` function](https://mongodb.github.io/node-mongodb-native/4.9/classes/Db.html#createCollection)\n *\n * @method createCollection\n * @param {string} collection The collection to create\n * @param {Object} [options] see [MongoDB driver docs](https://mongodb.github.io/node-mongodb-native/4.9/classes/Db.html#createCollection)\n * @return {Promise}\n * @api public\n */\n\nConnection.prototype.createCollection = async function createCollection(collection, options) {\n  if (typeof options === 'function' || (arguments.length >= 3 && typeof arguments[2] === 'function')) {\n    throw new MongooseError('Connection.prototype.createCollection() no longer accepts a callback');\n  }\n\n  if ((this.readyState === STATES.connecting || this.readyState === STATES.disconnected) && this._shouldBufferCommands()) {\n    await new Promise(resolve => {\n      this._queue.push({ fn: resolve });\n    });\n  }\n\n  return this.db.createCollection(collection, options);\n};\n\n/**\n * Calls `createCollection()` on a models in a series.\n *\n * @method createCollections\n * @param {Boolean} continueOnError When true, will continue to create collections and create a new error class for the collections that errored.\n * @returns {Promise}\n * @api public\n */\n\nConnection.prototype.createCollections = async function createCollections(options = {}) {\n  const result = {};\n  const errorsMap = { };\n\n  const { continueOnError } = options;\n  delete options.continueOnError;\n  for (const model of Object.values(this.models)) {\n    try {\n      result[model.modelName] = await model.createCollection({});\n    } catch (err) {\n      if (!continueOnError) {\n        errorsMap[model.modelName] = err;\n        break;\n      } else {\n        result[model.modelName] = err;\n      }\n    }\n  }\n\n  if (!continueOnError && Object.keys(errorsMap).length) {\n    const message = Object.entries(errorsMap).map(([modelName, err]) => `${modelName}: ${err.message}`).join(', ');\n    const createCollectionsError = new CreateCollectionsError(message, errorsMap);\n    throw createCollectionsError;\n  }\n  return result;\n};\n\n/**\n * A convenience wrapper for `connection.client.withSession()`.\n *\n * #### Example:\n *\n *     await conn.withSession(async session => {\n *       const doc = await TestModel.findOne().session(session);\n *     });\n *\n * @method withSession\n * @param {Function} executor called with 1 argument: a `ClientSession` instance\n * @return {Promise} resolves to the return value of the executor function\n * @api public\n */\n\nConnection.prototype.withSession = async function withSession(executor) {\n  if (arguments.length === 0) {\n    throw new Error('Please provide an executor function');\n  }\n  return await this.client.withSession(executor);\n};\n\n/**\n * _Requires MongoDB >= 3.6.0._ Starts a [MongoDB session](https://www.mongodb.com/docs/manual/release-notes/3.6/#client-sessions)\n * for benefits like causal consistency, [retryable writes](https://www.mongodb.com/docs/manual/core/retryable-writes/),\n * and [transactions](https://thecodebarbarian.com/a-node-js-perspective-on-mongodb-4-transactions.html).\n *\n * #### Example:\n *\n *     const session = await conn.startSession();\n *     let doc = await Person.findOne({ name: 'Ned Stark' }, null, { session });\n *     await doc.remove();\n *     // `doc` will always be null, even if reading from a replica set\n *     // secondary. Without causal consistency, it is possible to\n *     // get a doc back from the below query if the query reads from a\n *     // secondary that is experiencing replication lag.\n *     doc = await Person.findOne({ name: 'Ned Stark' }, null, { session, readPreference: 'secondary' });\n *\n *\n * @method startSession\n * @param {Object} [options] see the [mongodb driver options](https://mongodb.github.io/node-mongodb-native/4.9/classes/MongoClient.html#startSession)\n * @param {Boolean} [options.causalConsistency=true] set to false to disable causal consistency\n * @return {Promise<ClientSession>} promise that resolves to a MongoDB driver `ClientSession`\n * @api public\n */\n\nConnection.prototype.startSession = async function startSession(options) {\n  if (arguments.length >= 2 && typeof arguments[1] === 'function') {\n    throw new MongooseError('Connection.prototype.startSession() no longer accepts a callback');\n  }\n\n  if ((this.readyState === STATES.connecting || this.readyState === STATES.disconnected) && this._shouldBufferCommands()) {\n    await new Promise(resolve => {\n      this._queue.push({ fn: resolve });\n    });\n  }\n\n  const session = this.client.startSession(options);\n  return session;\n};\n\n/**\n * _Requires MongoDB >= 3.6.0._ Executes the wrapped async function\n * in a transaction. Mongoose will commit the transaction if the\n * async function executes successfully and attempt to retry if\n * there was a retriable error.\n *\n * Calls the MongoDB driver's [`session.withTransaction()`](https://mongodb.github.io/node-mongodb-native/4.9/classes/ClientSession.html#withTransaction),\n * but also handles resetting Mongoose document state as shown below.\n *\n * #### Example:\n *\n *     const doc = new Person({ name: 'Will Riker' });\n *     await db.transaction(async function setRank(session) {\n *       doc.rank = 'Captain';\n *       await doc.save({ session });\n *       doc.isNew; // false\n *\n *       // Throw an error to abort the transaction\n *       throw new Error('Oops!');\n *     },{ readPreference: 'primary' }).catch(() => {});\n *\n *     // true, `transaction()` reset the document's state because the\n *     // transaction was aborted.\n *     doc.isNew;\n *\n * @method transaction\n * @param {Function} fn Function to execute in a transaction\n * @param {mongodb.TransactionOptions} [options] Optional settings for the transaction\n * @return {Promise<Any>} promise that is fulfilled if Mongoose successfully committed the transaction, or rejects if the transaction was aborted or if Mongoose failed to commit the transaction. If fulfilled, the promise resolves to a MongoDB command result.\n * @api public\n */\n\nConnection.prototype.transaction = function transaction(fn, options) {\n  return this.startSession().then(session => {\n    session[sessionNewDocuments] = new Map();\n    return session.withTransaction(() => _wrapUserTransaction(fn, session), options).\n      then(res => {\n        delete session[sessionNewDocuments];\n        return res;\n      }).\n      catch(err => {\n        delete session[sessionNewDocuments];\n        throw err;\n      }).\n      finally(() => {\n        session.endSession().catch(() => {});\n      });\n  });\n};\n\n/*!\n * Reset document state in between transaction retries re: gh-13698\n */\n\nasync function _wrapUserTransaction(fn, session) {\n  try {\n    const res = await fn(session);\n    return res;\n  } catch (err) {\n    _resetSessionDocuments(session);\n    throw err;\n  }\n}\n\n/*!\n * If transaction was aborted, we need to reset newly inserted documents' `isNew`.\n */\nfunction _resetSessionDocuments(session) {\n  for (const doc of session[sessionNewDocuments].keys()) {\n    const state = session[sessionNewDocuments].get(doc);\n    if (state.hasOwnProperty('isNew')) {\n      doc.$isNew = state.isNew;\n    }\n    if (state.hasOwnProperty('versionKey')) {\n      doc.set(doc.schema.options.versionKey, state.versionKey);\n    }\n\n    if (state.modifiedPaths.length > 0 && doc.$__.activePaths.states.modify == null) {\n      doc.$__.activePaths.states.modify = {};\n    }\n    for (const path of state.modifiedPaths) {\n      const currentState = doc.$__.activePaths.paths[path];\n      if (currentState != null) {\n        delete doc.$__.activePaths[currentState][path];\n      }\n      doc.$__.activePaths.paths[path] = 'modify';\n      doc.$__.activePaths.states.modify[path] = true;\n    }\n\n    for (const path of state.atomics.keys()) {\n      const val = doc.$__getValue(path);\n      if (val == null) {\n        continue;\n      }\n      val[arrayAtomicsSymbol] = state.atomics.get(path);\n    }\n  }\n}\n\n/**\n * Helper for `dropCollection()`. Will delete the given collection, including\n * all documents and indexes.\n *\n * @method dropCollection\n * @param {string} collection The collection to delete\n * @return {Promise}\n * @api public\n */\n\nConnection.prototype.dropCollection = async function dropCollection(collection) {\n  if (arguments.length >= 2 && typeof arguments[1] === 'function') {\n    throw new MongooseError('Connection.prototype.dropCollection() no longer accepts a callback');\n  }\n\n  if ((this.readyState === STATES.connecting || this.readyState === STATES.disconnected) && this._shouldBufferCommands()) {\n    await new Promise(resolve => {\n      this._queue.push({ fn: resolve });\n    });\n  }\n\n  return this.db.dropCollection(collection);\n};\n\n/**\n * Helper for MongoDB Node driver's `listCollections()`.\n * Returns an array of collection objects.\n *\n * @method listCollections\n * @return {Promise<Collection[]>}\n * @api public\n */\n\nConnection.prototype.listCollections = async function listCollections() {\n  if ((this.readyState === STATES.connecting || this.readyState === STATES.disconnected) && this._shouldBufferCommands()) {\n    await new Promise(resolve => {\n      this._queue.push({ fn: resolve });\n    });\n  }\n\n  const cursor = this.db.listCollections();\n  return await cursor.toArray();\n};\n\n/**\n * Helper for `dropDatabase()`. Deletes the given database, including all\n * collections, documents, and indexes.\n *\n * #### Example:\n *\n *     const conn = mongoose.createConnection('mongodb://127.0.0.1:27017/mydb');\n *     // Deletes the entire 'mydb' database\n *     await conn.dropDatabase();\n *\n * @method dropDatabase\n * @return {Promise}\n * @api public\n */\n\nConnection.prototype.dropDatabase = async function dropDatabase() {\n  if (arguments.length >= 1 && typeof arguments[0] === 'function') {\n    throw new MongooseError('Connection.prototype.dropDatabase() no longer accepts a callback');\n  }\n\n  if ((this.readyState === STATES.connecting || this.readyState === STATES.disconnected) && this._shouldBufferCommands()) {\n    await new Promise(resolve => {\n      this._queue.push({ fn: resolve });\n    });\n  }\n\n  // If `dropDatabase()` is called, this model's collection will not be\n  // init-ed. It is sufficiently common to call `dropDatabase()` after\n  // `mongoose.connect()` but before creating models that we want to\n  // support this. See gh-6796\n  for (const model of Object.values(this.models)) {\n    delete model.$init;\n  }\n\n  return this.db.dropDatabase();\n};\n\n/*!\n * ignore\n */\n\nConnection.prototype._shouldBufferCommands = function _shouldBufferCommands() {\n  if (this.config.bufferCommands != null) {\n    return this.config.bufferCommands;\n  }\n  if (this.base.get('bufferCommands') != null) {\n    return this.base.get('bufferCommands');\n  }\n  return true;\n};\n\n/**\n * error\n *\n * Graceful error handling, passes error to callback\n * if available, else emits error on the connection.\n *\n * @param {Error} err\n * @param {Function} callback optional\n * @emits \"error\" Emits the `error` event with the given `err`, unless a callback is specified\n * @returns {Promise|null} Returns a rejected Promise if no `callback` is given.\n * @api private\n */\n\nConnection.prototype.error = function(err, callback) {\n  if (callback) {\n    callback(err);\n    return null;\n  }\n  if (this.listeners('error').length > 0) {\n    this.emit('error', err);\n  }\n  return Promise.reject(err);\n};\n\n/**\n * Called when the connection is opened\n *\n * @api private\n */\n\nConnection.prototype.onOpen = function() {\n  this.readyState = STATES.connected;\n\n  for (const d of this._queue) {\n    d.fn.apply(d.ctx, d.args);\n  }\n  this._queue = [];\n\n  // avoid having the collection subscribe to our event emitter\n  // to prevent 0.3 warning\n  for (const i in this.collections) {\n    if (utils.object.hasOwnProperty(this.collections, i)) {\n      this.collections[i].onOpen();\n    }\n  }\n\n  this.emit('open');\n};\n\n/**\n * Opens the connection with a URI using `MongoClient.connect()`.\n *\n * @param {String} uri The URI to connect with.\n * @param {Object} [options] Passed on to [`MongoClient.connect`](https://mongodb.github.io/node-mongodb-native/4.9/classes/MongoClient.html#connect-1)\n * @param {Boolean} [options.bufferCommands=true] Mongoose specific option. Set to false to [disable buffering](https://mongoosejs.com/docs/faq.html#callback_never_executes) on all models associated with this connection.\n * @param {Number} [options.bufferTimeoutMS=10000] Mongoose specific option. If `bufferCommands` is true, Mongoose will throw an error after `bufferTimeoutMS` if the operation is still buffered.\n * @param {String} [options.dbName] The name of the database we want to use. If not provided, use database name from connection string.\n * @param {String} [options.user] username for authentication, equivalent to `options.auth.user`. Maintained for backwards compatibility.\n * @param {String} [options.pass] password for authentication, equivalent to `options.auth.password`. Maintained for backwards compatibility.\n * @param {Number} [options.maxPoolSize=100] The maximum number of sockets the MongoDB driver will keep open for this connection. Keep in mind that MongoDB only allows one operation per socket at a time, so you may want to increase this if you find you have a few slow queries that are blocking faster queries from proceeding. See [Slow Trains in MongoDB and Node.js](https://thecodebarbarian.com/slow-trains-in-mongodb-and-nodejs).\n * @param {Number} [options.minPoolSize=0] The minimum number of sockets the MongoDB driver will keep open for this connection. Keep in mind that MongoDB only allows one operation per socket at a time, so you may want to increase this if you find you have a few slow queries that are blocking faster queries from proceeding. See [Slow Trains in MongoDB and Node.js](https://thecodebarbarian.com/slow-trains-in-mongodb-and-nodejs).\n * @param {Number} [options.serverSelectionTimeoutMS] If `useUnifiedTopology = true`, the MongoDB driver will try to find a server to send any given operation to, and keep retrying for `serverSelectionTimeoutMS` milliseconds before erroring out. If not set, the MongoDB driver defaults to using `30000` (30 seconds).\n * @param {Number} [options.heartbeatFrequencyMS] If `useUnifiedTopology = true`, the MongoDB driver sends a heartbeat every `heartbeatFrequencyMS` to check on the status of the connection. A heartbeat is subject to `serverSelectionTimeoutMS`, so the MongoDB driver will retry failed heartbeats for up to 30 seconds by default. Mongoose only emits a `'disconnected'` event after a heartbeat has failed, so you may want to decrease this setting to reduce the time between when your server goes down and when Mongoose emits `'disconnected'`. We recommend you do **not** set this setting below 1000, too many heartbeats can lead to performance degradation.\n * @param {Boolean} [options.autoIndex=true] Mongoose-specific option. Set to false to disable automatic index creation for all models associated with this connection.\n * @param {Class} [options.promiseLibrary] Sets the [underlying driver's promise library](https://mongodb.github.io/node-mongodb-native/4.9/interfaces/MongoClientOptions.html#promiseLibrary).\n * @param {Number} [options.socketTimeoutMS=0] How long the MongoDB driver will wait before killing a socket due to inactivity _after initial connection_. A socket may be inactive because of either no activity or a long-running operation. `socketTimeoutMS` defaults to 0, which means Node.js will not time out the socket due to inactivity. This option is passed to [Node.js `socket#setTimeout()` function](https://nodejs.org/api/net.html#net_socket_settimeout_timeout_callback) after the MongoDB driver successfully completes.\n * @param {Number} [options.family=0] Passed transparently to [Node.js' `dns.lookup()`](https://nodejs.org/api/dns.html#dns_dns_lookup_hostname_options_callback) function. May be either `0, `4`, or `6`. `4` means use IPv4 only, `6` means use IPv6 only, `0` means try both.\n * @param {Boolean} [options.autoCreate=false] Set to `true` to make Mongoose automatically call `createCollection()` on every model created on this connection.\n * @returns {Promise<Connection>}\n * @api public\n */\n\nConnection.prototype.openUri = async function openUri(uri, options) {\n  if (this.readyState === STATES.connecting || this.readyState === STATES.connected) {\n    if (this._connectionString === uri) {\n      return this;\n    }\n  }\n\n  this._closeCalled = false;\n\n  // Internal option to skip `await this.$initialConnection` in\n  // this function for `createConnection()`. Because otherwise\n  // `createConnection()` would have an uncatchable error.\n  let _fireAndForget = false;\n  if (options && '_fireAndForget' in options) {\n    _fireAndForget = options._fireAndForget;\n    delete options._fireAndForget;\n  }\n\n  try {\n    _validateArgs.apply(arguments);\n  } catch (err) {\n    if (_fireAndForget) {\n      throw err;\n    }\n    this.$initialConnection = Promise.reject(err);\n    throw err;\n  }\n\n  this.$initialConnection = this.createClient(uri, options).\n    then(() => this).\n    catch(err => {\n      this.readyState = STATES.disconnected;\n      if (this.listeners('error').length > 0) {\n        immediate(() => this.emit('error', err));\n      }\n      throw err;\n    });\n\n  for (const model of Object.values(this.models)) {\n    // Errors handled internally, so safe to ignore error\n    model.init().catch(function $modelInitNoop() {});\n  }\n\n  // `createConnection()` calls this `openUri()` function without\n  // awaiting on the result, so we set this option to rely on\n  // `asPromise()` to handle any errors.\n  if (_fireAndForget) {\n    return this;\n  }\n\n  try {\n    await this.$initialConnection;\n  } catch (err) {\n    throw _handleConnectionErrors(err);\n  }\n\n  return this;\n};\n\n/*!\n * ignore\n */\n\nfunction _validateArgs(uri, options, callback) {\n  if (typeof options === 'function' && callback == null) {\n    throw new MongooseError('Connection.prototype.openUri() no longer accepts a callback');\n  } else if (typeof callback === 'function') {\n    throw new MongooseError('Connection.prototype.openUri() no longer accepts a callback');\n  }\n}\n\n/*!\n * ignore\n */\n\nfunction _handleConnectionErrors(err) {\n  if (err?.name === 'MongoServerSelectionError') {\n    const originalError = err;\n    err = new ServerSelectionError();\n    err.assimilateError(originalError);\n  }\n\n  return err;\n}\n\n/**\n * Destroy the connection. Similar to [`.close`](https://mongoosejs.com/docs/api/connection.html#Connection.prototype.close()),\n * but also removes the connection from Mongoose's `connections` list and prevents the\n * connection from ever being re-opened.\n *\n * @param {Boolean} [force]\n * @returns {Promise}\n */\n\nConnection.prototype.destroy = async function destroy(force) {\n  if (typeof force === 'function' || (arguments.length === 2 && typeof arguments[1] === 'function')) {\n    throw new MongooseError('Connection.prototype.destroy() no longer accepts a callback');\n  }\n\n  if (force != null && typeof force === 'object') {\n    this.$wasForceClosed = !!force.force;\n  } else {\n    this.$wasForceClosed = !!force;\n  }\n\n  return this._close(force, true);\n};\n\n/**\n * Closes the connection\n *\n * @param {Boolean} [force] optional\n * @return {Promise}\n * @api public\n */\n\nConnection.prototype.close = async function close(force) {\n  if (typeof force === 'function' || (arguments.length === 2 && typeof arguments[1] === 'function')) {\n    throw new MongooseError('Connection.prototype.close() no longer accepts a callback');\n  }\n\n  if (force != null && typeof force === 'object') {\n    this.$wasForceClosed = !!force.force;\n  } else {\n    this.$wasForceClosed = !!force;\n  }\n\n  for (const model of Object.values(this.models)) {\n    // If manually disconnecting, make sure to clear each model's `$init`\n    // promise, so Mongoose knows to re-run `init()` in case the\n    // connection is re-opened. See gh-12047.\n    delete model.$init;\n  }\n\n  return this._close(force, false);\n};\n\n/**\n * Handles closing the connection\n *\n * @param {Boolean} force\n * @param {Boolean} destroy\n * @returns {Connection} this\n * @api private\n */\nConnection.prototype._close = async function _close(force, destroy) {\n  const _this = this;\n  const closeCalled = this._closeCalled;\n  this._closeCalled = true;\n  this._destroyCalled = destroy;\n  if (this.client != null) {\n    this.client._closeCalled = true;\n    this.client._destroyCalled = destroy;\n  }\n\n  const conn = this;\n  switch (this.readyState) {\n    case STATES.disconnected:\n      if (destroy && this.base.connections.indexOf(conn) !== -1) {\n        this.base.connections.splice(this.base.connections.indexOf(conn), 1);\n      }\n      if (!closeCalled) {\n        await this.doClose(force);\n        this.onClose(force);\n      }\n      break;\n\n    case STATES.connected:\n      this.readyState = STATES.disconnecting;\n      await this.doClose(force);\n      if (destroy && _this.base.connections.indexOf(conn) !== -1) {\n        this.base.connections.splice(this.base.connections.indexOf(conn), 1);\n      }\n      this.onClose(force);\n\n      break;\n    case STATES.connecting:\n      return new Promise((resolve, reject) => {\n        const _rerunClose = () => {\n          this.removeListener('open', _rerunClose);\n          this.removeListener('error', _rerunClose);\n          if (destroy) {\n            this.destroy(force).then(resolve, reject);\n          } else {\n            this.close(force).then(resolve, reject);\n          }\n        };\n\n        this.once('open', _rerunClose);\n        this.once('error', _rerunClose);\n      });\n\n    case STATES.disconnecting:\n      return new Promise(resolve => {\n        this.once('close', () => {\n          if (destroy && this.base.connections.indexOf(conn) !== -1) {\n            this.base.connections.splice(this.base.connections.indexOf(conn), 1);\n          }\n          resolve();\n        });\n      });\n  }\n\n  return this;\n};\n\n/**\n * Abstract method that drivers must implement.\n *\n * @api private\n */\n\nConnection.prototype.doClose = function() {\n  throw new Error('Connection#doClose unimplemented by driver');\n};\n\n/**\n * Called when the connection closes\n *\n * @api private\n */\n\nConnection.prototype.onClose = function(force) {\n  this.readyState = STATES.disconnected;\n\n  // avoid having the collection subscribe to our event emitter\n  // to prevent 0.3 warning\n  for (const i in this.collections) {\n    if (utils.object.hasOwnProperty(this.collections, i)) {\n      this.collections[i].onClose(force);\n    }\n  }\n\n  this.emit('close', force);\n\n  for (const db of this.otherDbs) {\n    this._destroyCalled ? db.destroy({ force: force, skipCloseClient: true }) : db.close({ force: force, skipCloseClient: true });\n  }\n};\n\n/**\n * Retrieves a raw collection instance, creating it if not cached.\n * This method returns a thin wrapper around a [MongoDB Node.js driver collection]([MongoDB Node.js driver collection](https://mongodb.github.io/node-mongodb-native/Next/classes/Collection.html)).\n * Using a Collection bypasses Mongoose middleware, validation, and casting,\n * letting you use [MongoDB Node.js driver](https://mongodb.github.io/node-mongodb-native/) functionality directly.\n *\n * @param {String} name of the collection\n * @param {Object} [options] optional collection options\n * @return {Collection} collection instance\n * @api public\n */\n\nConnection.prototype.collection = function(name, options) {\n  const defaultOptions = {\n    autoIndex: this.config.autoIndex != null ? this.config.autoIndex : this.base.options.autoIndex,\n    autoCreate: this.config.autoCreate != null ? this.config.autoCreate : this.base.options.autoCreate,\n    autoSearchIndex: this.config.autoSearchIndex != null ? this.config.autoSearchIndex : this.base.options.autoSearchIndex\n  };\n  options = Object.assign({}, defaultOptions, options ? clone(options) : {});\n  options.$wasForceClosed = this.$wasForceClosed;\n  const Collection = this.base && this.base.__driver && this.base.__driver.Collection || driver.get().Collection;\n  if (!(name in this.collections)) {\n    this.collections[name] = new Collection(name, this, options);\n  }\n  return this.collections[name];\n};\n\n/**\n * Declares a plugin executed on all schemas you pass to `conn.model()`\n *\n * Equivalent to calling `.plugin(fn)` on each schema you create.\n *\n * #### Example:\n *\n *     const db = mongoose.createConnection('mongodb://127.0.0.1:27017/mydb');\n *     db.plugin(() => console.log('Applied'));\n *     db.plugins.length; // 1\n *\n *     db.model('Test', new Schema({})); // Prints \"Applied\"\n *\n * @param {Function} fn plugin callback\n * @param {Object} [opts] optional options\n * @return {Connection} this\n * @see plugins https://mongoosejs.com/docs/plugins.html\n * @api public\n */\n\nConnection.prototype.plugin = function(fn, opts) {\n  this.plugins.push([fn, opts]);\n  return this;\n};\n\n/**\n * Defines or retrieves a model.\n *\n *     const mongoose = require('mongoose');\n *     const db = mongoose.createConnection(..);\n *     db.model('Venue', new Schema(..));\n *     const Ticket = db.model('Ticket', new Schema(..));\n *     const Venue = db.model('Venue');\n *\n * _When no `collection` argument is passed, Mongoose produces a collection name by passing the model `name` to the `utils.toCollectionName` method. This method pluralizes the name. If you don't like this behavior, either pass a collection name or set your schemas collection name option._\n *\n * #### Example:\n *\n *     const schema = new Schema({ name: String }, { collection: 'actor' });\n *\n *     // or\n *\n *     schema.set('collection', 'actor');\n *\n *     // or\n *\n *     const collectionName = 'actor'\n *     const M = conn.model('Actor', schema, collectionName)\n *\n * @param {String|Function} name the model name or class extending Model\n * @param {Schema} [schema] a schema. necessary when defining a model\n * @param {String} [collection] name of mongodb collection (optional) if not given it will be induced from model name\n * @param {Object} [options]\n * @param {Boolean} [options.overwriteModels=false] If true, overwrite existing models with the same name to avoid `OverwriteModelError`\n * @see Mongoose#model https://mongoosejs.com/docs/api/mongoose.html#Mongoose.prototype.model()\n * @return {Model} The compiled model\n * @api public\n */\n\nConnection.prototype.model = function(name, schema, collection, options) {\n  if (!(this instanceof Connection)) {\n    throw new MongooseError('`connection.model()` should not be run with ' +\n      '`new`. If you are doing `new db.model(foo)(bar)`, use ' +\n      '`db.model(foo)(bar)` instead');\n  }\n\n  let fn;\n  if (typeof name === 'function') {\n    fn = name;\n    name = fn.name;\n  }\n\n  // collection name discovery\n  if (typeof schema === 'string') {\n    collection = schema;\n    schema = false;\n  }\n\n  if (utils.isObject(schema)) {\n    if (!schema.instanceOfSchema) {\n      schema = new Schema(schema);\n    } else if (!(schema instanceof this.base.Schema)) {\n      schema = schema._clone(this.base.Schema);\n    }\n  }\n  if (schema && !schema.instanceOfSchema) {\n    throw new Error('The 2nd parameter to `mongoose.model()` should be a ' +\n      'schema or a POJO');\n  }\n\n  const defaultOptions = { cache: false, overwriteModels: this.base.options.overwriteModels };\n  const opts = Object.assign(defaultOptions, options, { connection: this });\n  if (this.models[name] && !collection && opts.overwriteModels !== true) {\n    // model exists but we are not subclassing with custom collection\n    if (schema && schema.instanceOfSchema && schema !== this.models[name].schema) {\n      throw new MongooseError.OverwriteModelError(name);\n    }\n    return this.models[name];\n  }\n\n  let model;\n\n  if (schema && schema.instanceOfSchema) {\n    applyPlugins(schema, this.plugins, null, '$connectionPluginsApplied');\n\n    // compile a model\n    model = this.base._model(fn || name, schema, collection, opts);\n\n    // only the first model with this name is cached to allow\n    // for one-offs with custom collection names etc.\n    if (!this.models[name]) {\n      this.models[name] = model;\n    }\n\n    // Errors handled internally, so safe to ignore error\n    model.init().catch(function $modelInitNoop() {});\n\n    return model;\n  }\n\n  if (this.models[name] && collection) {\n    // subclassing current model with alternate collection\n    model = this.models[name];\n    schema = model.prototype.schema;\n    const sub = model.__subclass(this, schema, collection);\n    // do not cache the sub model\n    return sub;\n  }\n\n  if (arguments.length === 1) {\n    model = this.models[name];\n    if (!model) {\n      throw new MongooseError.MissingSchemaError(name);\n    }\n    return model;\n  }\n\n  if (!model) {\n    throw new MongooseError.MissingSchemaError(name);\n  }\n\n  if (this === model.prototype.db\n      && (!collection || collection === model.collection.name)) {\n    // model already uses this connection.\n\n    // only the first model with this name is cached to allow\n    // for one-offs with custom collection names etc.\n    if (!this.models[name]) {\n      this.models[name] = model;\n    }\n\n    return model;\n  }\n  this.models[name] = model.__subclass(this, schema, collection);\n  return this.models[name];\n};\n\n/**\n * Removes the model named `name` from this connection, if it exists. You can\n * use this function to clean up any models you created in your tests to\n * prevent OverwriteModelErrors.\n *\n * #### Example:\n *\n *     conn.model('User', new Schema({ name: String }));\n *     console.log(conn.model('User')); // Model object\n *     conn.deleteModel('User');\n *     console.log(conn.model('User')); // undefined\n *\n *     // Usually useful in a Mocha `afterEach()` hook\n *     afterEach(function() {\n *       conn.deleteModel(/.+/); // Delete every model\n *     });\n *\n * @api public\n * @param {String|RegExp} name if string, the name of the model to remove. If regexp, removes all models whose name matches the regexp.\n * @return {Connection} this\n */\n\nConnection.prototype.deleteModel = function(name) {\n  if (typeof name === 'string') {\n    const model = this.model(name);\n    if (model == null) {\n      return this;\n    }\n    const collectionName = model.collection.name;\n    delete this.models[name];\n    delete this.collections[collectionName];\n\n    this.emit('deleteModel', model);\n  } else if (name instanceof RegExp) {\n    const pattern = name;\n    const names = this.modelNames();\n    for (const name of names) {\n      if (pattern.test(name)) {\n        this.deleteModel(name);\n      }\n    }\n  } else {\n    throw new Error('First parameter to `deleteModel()` must be a string ' +\n      'or regexp, got \"' + name + '\"');\n  }\n\n  return this;\n};\n\n/**\n * Watches the entire underlying database for changes. Similar to\n * [`Model.watch()`](https://mongoosejs.com/docs/api/model.html#Model.watch()).\n *\n * This function does **not** trigger any middleware. In particular, it\n * does **not** trigger aggregate middleware.\n *\n * The ChangeStream object is an event emitter that emits the following events:\n *\n * - 'change': A change occurred, see below example\n * - 'error': An unrecoverable error occurred. In particular, change streams currently error out if they lose connection to the replica set primary. Follow [this GitHub issue](https://github.com/Automattic/mongoose/issues/6799) for updates.\n * - 'end': Emitted if the underlying stream is closed\n * - 'close': Emitted if the underlying stream is closed\n *\n * #### Example:\n *\n *     const User = conn.model('User', new Schema({ name: String }));\n *\n *     const changeStream = conn.watch().on('change', data => console.log(data));\n *\n *     // Triggers a 'change' event on the change stream.\n *     await User.create({ name: 'test' });\n *\n * @api public\n * @param {Array} [pipeline]\n * @param {Object} [options] passed without changes to [the MongoDB driver's `Db#watch()` function](https://mongodb.github.io/node-mongodb-native/4.9/classes/Db.html#watch)\n * @return {ChangeStream} mongoose-specific change stream wrapper, inherits from EventEmitter\n */\n\nConnection.prototype.watch = function(pipeline, options) {\n  const changeStreamThunk = cb => {\n    immediate(() => {\n      if (this.readyState === STATES.connecting) {\n        this.once('open', function() {\n          const driverChangeStream = this.db.watch(pipeline, options);\n          cb(null, driverChangeStream);\n        });\n      } else {\n        const driverChangeStream = this.db.watch(pipeline, options);\n        cb(null, driverChangeStream);\n      }\n    });\n  };\n\n  const changeStream = new ChangeStream(changeStreamThunk, pipeline, options);\n  return changeStream;\n};\n\n/**\n * Returns a promise that resolves when this connection\n * successfully connects to MongoDB, or rejects if this connection failed\n * to connect.\n *\n * #### Example:\n *\n *     const conn = await mongoose.createConnection('mongodb://127.0.0.1:27017/test').\n *       asPromise();\n *     conn.readyState; // 1, means Mongoose is connected\n *\n * @api public\n * @return {Promise}\n */\n\nConnection.prototype.asPromise = async function asPromise() {\n  try {\n    await this.$initialConnection;\n    return this;\n  } catch (err) {\n    throw _handleConnectionErrors(err);\n  }\n};\n\n/**\n * Returns an array of model names created on this connection.\n * @api public\n * @return {String[]}\n */\n\nConnection.prototype.modelNames = function() {\n  return Object.keys(this.models);\n};\n\n/**\n * Returns if the connection requires authentication after it is opened. Generally if a\n * username and password are both provided than authentication is needed, but in some cases a\n * password is not required.\n *\n * @api private\n * @return {Boolean} true if the connection should be authenticated after it is opened, otherwise false.\n */\nConnection.prototype.shouldAuthenticate = function() {\n  return this.user != null &&\n    (this.pass != null || this.authMechanismDoesNotRequirePassword());\n};\n\n/**\n * Returns a boolean value that specifies if the current authentication mechanism needs a\n * password to authenticate according to the auth objects passed into the openUri methods.\n *\n * @api private\n * @return {Boolean} true if the authentication mechanism specified in the options object requires\n *  a password, otherwise false.\n */\nConnection.prototype.authMechanismDoesNotRequirePassword = function() {\n  if (this.options && this.options.auth) {\n    return noPasswordAuthMechanisms.indexOf(this.options.auth.authMechanism) >= 0;\n  }\n  return true;\n};\n\n/**\n * Returns a boolean value that specifies if the provided objects object provides enough\n * data to authenticate with. Generally this is true if the username and password are both specified\n * but in some authentication methods, a password is not required for authentication so only a username\n * is required.\n *\n * @param {Object} [options] the options object passed into the openUri methods.\n * @api private\n * @return {Boolean} true if the provided options object provides enough data to authenticate with,\n *   otherwise false.\n */\nConnection.prototype.optionsProvideAuthenticationData = function(options) {\n  return (options) &&\n      (options.user) &&\n      ((options.pass) || this.authMechanismDoesNotRequirePassword());\n};\n\n/**\n * Returns the [MongoDB driver `MongoClient`](https://mongodb.github.io/node-mongodb-native/4.9/classes/MongoClient.html) instance\n * that this connection uses to talk to MongoDB.\n *\n * #### Example:\n *\n *     const conn = await mongoose.createConnection('mongodb://127.0.0.1:27017/test').\n *       asPromise();\n *\n *     conn.getClient(); // MongoClient { ... }\n *\n * @api public\n * @return {MongoClient}\n */\n\nConnection.prototype.getClient = function getClient() {\n  return this.client;\n};\n\n/**\n * Set the [MongoDB driver `MongoClient`](https://mongodb.github.io/node-mongodb-native/4.9/classes/MongoClient.html) instance\n * that this connection uses to talk to MongoDB. This is useful if you already have a MongoClient instance, and want to\n * reuse it.\n *\n * #### Example:\n *\n *     const client = await mongodb.MongoClient.connect('mongodb://127.0.0.1:27017/test');\n *\n *     const conn = mongoose.createConnection().setClient(client);\n *\n *     conn.getClient(); // MongoClient { ... }\n *     conn.readyState; // 1, means 'CONNECTED'\n *\n * @api public\n * @param {MongClient} client The Client to set to be used.\n * @return {Connection} this\n */\n\nConnection.prototype.setClient = function setClient() {\n  throw new MongooseError('Connection#setClient not implemented by driver');\n};\n\n/*!\n * Called internally by `openUri()` to create a MongoClient instance.\n */\n\nConnection.prototype.createClient = function createClient() {\n  throw new MongooseError('Connection#createClient not implemented by driver');\n};\n\n/**\n * Syncs all the indexes for the models registered with this connection.\n *\n * @param {Object} [options]\n * @param {Boolean} [options.continueOnError] `false` by default. If set to `true`, mongoose will not throw an error if one model syncing failed, and will return an object where the keys are the names of the models, and the values are the results/errors for each model.\n * @return {Promise<Object>} Returns a Promise, when the Promise resolves the value is a list of the dropped indexes.\n */\nConnection.prototype.syncIndexes = async function syncIndexes(options = {}) {\n  const result = {};\n  const errorsMap = { };\n\n  const { continueOnError } = options;\n  delete options.continueOnError;\n\n  for (const model of Object.values(this.models)) {\n    try {\n      result[model.modelName] = await model.syncIndexes(options);\n    } catch (err) {\n      if (!continueOnError) {\n        errorsMap[model.modelName] = err;\n        break;\n      } else {\n        result[model.modelName] = err;\n      }\n    }\n  }\n\n  if (!continueOnError && Object.keys(errorsMap).length) {\n    const message = Object.entries(errorsMap).map(([modelName, err]) => `${modelName}: ${err.message}`).join(', ');\n    const syncIndexesError = new SyncIndexesError(message, errorsMap);\n    throw syncIndexesError;\n  }\n\n  return result;\n};\n\n/**\n * Switches to a different database using the same [connection pool](https://mongoosejs.com/docs/api/connectionshtml#connection_pools).\n *\n * Returns a new connection object, with the new db.\n *\n * #### Example:\n *\n *     // Connect to `initialdb` first\n *     const conn = await mongoose.createConnection('mongodb://127.0.0.1:27017/initialdb').asPromise();\n *\n *     // Creates an un-cached connection to `mydb`\n *     const db = conn.useDb('mydb');\n *     // Creates a cached connection to `mydb2`. All calls to `conn.useDb('mydb2', { useCache: true })` will return the same\n *     // connection instance as opposed to creating a new connection instance\n *     const db2 = conn.useDb('mydb2', { useCache: true });\n *\n * @method useDb\n * @memberOf Connection\n * @param {String} name The database name\n * @param {Object} [options]\n * @param {Boolean} [options.useCache=false] If true, cache results so calling `useDb()` multiple times with the same name only creates 1 connection object.\n * @param {Boolean} [options.noListener=false] If true, the connection object will not make the db listen to events on the original connection. See [issue #9961](https://github.com/Automattic/mongoose/issues/9961).\n * @return {Connection} New Connection Object\n * @api public\n */\n\n/**\n * Removes the database connection with the given name created with with `useDb()`.\n *\n * Throws an error if the database connection was not found.\n *\n * #### Example:\n *\n *     // Connect to `initialdb` first\n *     const conn = await mongoose.createConnection('mongodb://127.0.0.1:27017/initialdb').asPromise();\n *\n *     // Creates an un-cached connection to `mydb`\n *     const db = conn.useDb('mydb');\n *\n *     // Closes `db`, and removes `db` from `conn.relatedDbs` and `conn.otherDbs`\n *     await conn.removeDb('mydb');\n *\n * @method removeDb\n * @memberOf Connection\n * @param {String} name The database name\n * @return {Connection} this\n * @api public\n */\n\n/*!\n * Module exports.\n */\n\nConnection.STATES = STATES;\nmodule.exports = Connection;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvY29ubmVjdGlvbi5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBO0FBQ0E7O0FBRUEscUJBQXFCLG1CQUFPLENBQUMseUZBQXVCO0FBQ3BELHFCQUFxQiwwREFBOEI7QUFDbkQsZUFBZSxtQkFBTyxDQUFDLCtEQUFVO0FBQ2pDLGVBQWUsbUJBQU8sQ0FBQyxpRkFBbUI7QUFDMUMsc0JBQXNCLG1CQUFPLENBQUMseUVBQWU7QUFDN0MsNkJBQTZCLG1CQUFPLENBQUMsNkZBQXlCO0FBQzlELHlCQUF5QixtQkFBTyxDQUFDLHFGQUFxQjtBQUN0RCxxQkFBcUIsbUJBQU8sQ0FBQyx5R0FBK0I7QUFDNUQsY0FBYyxtQkFBTyxDQUFDLDZFQUFpQjtBQUN2QyxlQUFlLG1CQUFPLENBQUMsK0RBQVU7QUFDakMsWUFBWSxtQkFBTyxDQUFDLHlFQUFlO0FBQ25DLGtCQUFrQixtQkFBTyxDQUFDLHFGQUFxQjtBQUMvQyxjQUFjLG1CQUFPLENBQUMsNkRBQVM7QUFDL0IsK0JBQStCLG1CQUFPLENBQUMsMkdBQWdDOztBQUV2RSwyQkFBMkIsMkhBQStDO0FBQzFFLDRCQUE0Qiw0SEFBZ0Q7O0FBRTVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0Qix3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsT0FBTztBQUNsQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsU0FBUztBQUNwQixhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsbURBQW1EO0FBQ25EOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQixhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEIsV0FBVyxTQUFTO0FBQ3BCLGFBQWEsWUFBWTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsdUNBQXVDLHFDQUFxQyxlQUFlLHFDQUFxQztBQUNoSTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsWUFBWSxZQUFZO0FBQ3hCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLCtDQUErQztBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQSxxQ0FBcUMsSUFBSTtBQUN6QztBQUNBLFdBQVcsVUFBVTtBQUNyQixXQUFXLFFBQVE7QUFDbkIsWUFBWSxZQUFZO0FBQ3hCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxjQUFjLElBQUkscUJBQXFCO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxpQkFBaUI7QUFDNUIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxTQUFTO0FBQ3BCO0FBQ0EsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMkJBQTJCO0FBQzNCLHdEQUF3RCxrQkFBa0I7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtREFBbUQ7O0FBRW5EO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxjQUFjO0FBQ3JELHdDQUF3QztBQUN4QztBQUNBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakMsUUFBUTtBQUNSO0FBQ0E7QUFDQSxXQUFXLGVBQWU7QUFDMUIsWUFBWSxZQUFZO0FBQ3hCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxjQUFjO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGNBQWM7QUFDekM7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLFFBQVE7QUFDbkIsWUFBWSxjQUFjO0FBQzFCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0EsWUFBWTtBQUNaOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksU0FBUztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFNBQVM7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQSxZQUFZLFNBQVM7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLGlCQUFpQjtBQUMxQztBQUNBO0FBQ0EsWUFBWTtBQUNaOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLGlCQUFpQjtBQUMxQyx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBLFdBQVcsWUFBWTtBQUN2QixZQUFZLFlBQVk7QUFDeEI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsU0FBUztBQUNwQixZQUFZLGlCQUFpQjtBQUM3QjtBQUNBLDBFQUEwRTtBQUMxRTtBQUNBOztBQUVBLFVBQVUsa0JBQWtCO0FBQzVCOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyRUFBMkUsVUFBVSxJQUFJLFlBQVk7QUFDckc7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0ZBQXNGLGdCQUFnQjtBQUN0RztBQUNBLHlDQUF5QyxnQkFBZ0I7QUFDekQ7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFNBQVM7QUFDcEIsV0FBVyxTQUFTO0FBQ3BCLFlBQVksWUFBWTtBQUN4QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZLFlBQVk7QUFDeEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2NsaWVudC8uLi9zZXJ2ZXIvbm9kZV9tb2R1bGVzL21vbmdvb3NlL2xpYi9jb25uZWN0aW9uLmpzPzdjMjUiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG4vKiFcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxuY29uc3QgQ2hhbmdlU3RyZWFtID0gcmVxdWlyZSgnLi9jdXJzb3IvY2hhbmdlU3RyZWFtJyk7XG5jb25zdCBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXI7XG5jb25zdCBTY2hlbWEgPSByZXF1aXJlKCcuL3NjaGVtYScpO1xuY29uc3QgU1RBVEVTID0gcmVxdWlyZSgnLi9jb25uZWN0aW9uU3RhdGUnKTtcbmNvbnN0IE1vbmdvb3NlRXJyb3IgPSByZXF1aXJlKCcuL2Vycm9yL2luZGV4Jyk7XG5jb25zdCBTZXJ2ZXJTZWxlY3Rpb25FcnJvciA9IHJlcXVpcmUoJy4vZXJyb3Ivc2VydmVyU2VsZWN0aW9uJyk7XG5jb25zdCBTeW5jSW5kZXhlc0Vycm9yID0gcmVxdWlyZSgnLi9lcnJvci9zeW5jSW5kZXhlcycpO1xuY29uc3QgYXBwbHlQbHVnaW5zID0gcmVxdWlyZSgnLi9oZWxwZXJzL3NjaGVtYS9hcHBseVBsdWdpbnMnKTtcbmNvbnN0IGNsb25lID0gcmVxdWlyZSgnLi9oZWxwZXJzL2Nsb25lJyk7XG5jb25zdCBkcml2ZXIgPSByZXF1aXJlKCcuL2RyaXZlcicpO1xuY29uc3QgZ2V0ID0gcmVxdWlyZSgnLi9oZWxwZXJzL2dldCcpO1xuY29uc3QgaW1tZWRpYXRlID0gcmVxdWlyZSgnLi9oZWxwZXJzL2ltbWVkaWF0ZScpO1xuY29uc3QgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG5jb25zdCBDcmVhdGVDb2xsZWN0aW9uc0Vycm9yID0gcmVxdWlyZSgnLi9lcnJvci9jcmVhdGVDb2xsZWN0aW9uc0Vycm9yJyk7XG5cbmNvbnN0IGFycmF5QXRvbWljc1N5bWJvbCA9IHJlcXVpcmUoJy4vaGVscGVycy9zeW1ib2xzJykuYXJyYXlBdG9taWNzU3ltYm9sO1xuY29uc3Qgc2Vzc2lvbk5ld0RvY3VtZW50cyA9IHJlcXVpcmUoJy4vaGVscGVycy9zeW1ib2xzJykuc2Vzc2lvbk5ld0RvY3VtZW50cztcblxuLyoqXG4gKiBBIGxpc3Qgb2YgYXV0aGVudGljYXRpb24gbWVjaGFuaXNtcyB0aGF0IGRvbid0IHJlcXVpcmUgYSBwYXNzd29yZCBmb3IgYXV0aGVudGljYXRpb24uXG4gKiBUaGlzIGlzIHVzZWQgYnkgdGhlIGF1dGhNZWNoYW5pc21Eb2VzTm90UmVxdWlyZVBhc3N3b3JkIG1ldGhvZC5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuY29uc3Qgbm9QYXNzd29yZEF1dGhNZWNoYW5pc21zID0gW1xuICAnTU9OR09EQi1YNTA5J1xuXTtcblxuLyoqXG4gKiBDb25uZWN0aW9uIGNvbnN0cnVjdG9yXG4gKlxuICogRm9yIHByYWN0aWNhbCByZWFzb25zLCBhIENvbm5lY3Rpb24gZXF1YWxzIGEgRGIuXG4gKlxuICogQHBhcmFtIHtNb25nb29zZX0gYmFzZSBhIG1vbmdvb3NlIGluc3RhbmNlXG4gKiBAaW5oZXJpdHMgTm9kZUpTIEV2ZW50RW1pdHRlciBodHRwczovL25vZGVqcy5vcmcvYXBpL2V2ZW50cy5odG1sI2NsYXNzLWV2ZW50ZW1pdHRlclxuICogQGV2ZW50IGBjb25uZWN0aW5nYDogRW1pdHRlZCB3aGVuIGBjb25uZWN0aW9uLm9wZW5VcmkoKWAgaXMgZXhlY3V0ZWQgb24gdGhpcyBjb25uZWN0aW9uLlxuICogQGV2ZW50IGBjb25uZWN0ZWRgOiBFbWl0dGVkIHdoZW4gdGhpcyBjb25uZWN0aW9uIHN1Y2Nlc3NmdWxseSBjb25uZWN0cyB0byB0aGUgZGIuIE1heSBiZSBlbWl0dGVkIF9tdWx0aXBsZV8gdGltZXMgaW4gYHJlY29ubmVjdGVkYCBzY2VuYXJpb3MuXG4gKiBAZXZlbnQgYG9wZW5gOiBFbWl0dGVkIGFmdGVyIHdlIGBjb25uZWN0ZWRgIGFuZCBgb25PcGVuYCBpcyBleGVjdXRlZCBvbiBhbGwgb2YgdGhpcyBjb25uZWN0aW9uJ3MgbW9kZWxzLlxuICogQGV2ZW50IGBkaXNjb25uZWN0aW5nYDogRW1pdHRlZCB3aGVuIGBjb25uZWN0aW9uLmNsb3NlKClgIHdhcyBleGVjdXRlZC5cbiAqIEBldmVudCBgZGlzY29ubmVjdGVkYDogRW1pdHRlZCBhZnRlciBnZXR0aW5nIGRpc2Nvbm5lY3RlZCBmcm9tIHRoZSBkYi5cbiAqIEBldmVudCBgY2xvc2VgOiBFbWl0dGVkIGFmdGVyIHdlIGBkaXNjb25uZWN0ZWRgIGFuZCBgb25DbG9zZWAgZXhlY3V0ZWQgb24gYWxsIG9mIHRoaXMgY29ubmVjdGlvbidzIG1vZGVscy5cbiAqIEBldmVudCBgcmVjb25uZWN0ZWRgOiBFbWl0dGVkIGFmdGVyIHdlIGBjb25uZWN0ZWRgIGFuZCBzdWJzZXF1ZW50bHkgYGRpc2Nvbm5lY3RlZGAsIGZvbGxvd2VkIGJ5IHN1Y2Nlc3NmdWxseSBhbm90aGVyIHN1Y2Nlc3NmdWwgY29ubmVjdGlvbi5cbiAqIEBldmVudCBgZXJyb3JgOiBFbWl0dGVkIHdoZW4gYW4gZXJyb3Igb2NjdXJzIG9uIHRoaXMgY29ubmVjdGlvbi5cbiAqIEBldmVudCBgZnVsbHNldHVwYDogRW1pdHRlZCBhZnRlciB0aGUgZHJpdmVyIGhhcyBjb25uZWN0ZWQgdG8gcHJpbWFyeSBhbmQgYWxsIHNlY29uZGFyaWVzIGlmIHNwZWNpZmllZCBpbiB0aGUgY29ubmVjdGlvbiBzdHJpbmcuXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIENvbm5lY3Rpb24oYmFzZSkge1xuICB0aGlzLmJhc2UgPSBiYXNlO1xuICB0aGlzLmNvbGxlY3Rpb25zID0ge307XG4gIHRoaXMubW9kZWxzID0ge307XG4gIHRoaXMuY29uZmlnID0ge307XG4gIHRoaXMucmVwbGljYSA9IGZhbHNlO1xuICB0aGlzLm9wdGlvbnMgPSBudWxsO1xuICB0aGlzLm90aGVyRGJzID0gW107IC8vIEZJWE1FOiBUbyBiZSByZXBsYWNlZCB3aXRoIHJlbGF0ZWREYnNcbiAgdGhpcy5yZWxhdGVkRGJzID0ge307IC8vIEhhc2htYXAgb2Ygb3RoZXIgZGJzIHRoYXQgc2hhcmUgdW5kZXJseWluZyBjb25uZWN0aW9uXG4gIHRoaXMuc3RhdGVzID0gU1RBVEVTO1xuICB0aGlzLl9yZWFkeVN0YXRlID0gU1RBVEVTLmRpc2Nvbm5lY3RlZDtcbiAgdGhpcy5fY2xvc2VDYWxsZWQgPSBmYWxzZTtcbiAgdGhpcy5faGFzT3BlbmVkID0gZmFsc2U7XG4gIHRoaXMucGx1Z2lucyA9IFtdO1xuICBpZiAodHlwZW9mIGJhc2UgPT09ICd1bmRlZmluZWQnIHx8ICFiYXNlLmNvbm5lY3Rpb25zLmxlbmd0aCkge1xuICAgIHRoaXMuaWQgPSAwO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuaWQgPSBiYXNlLm5leHRDb25uZWN0aW9uSWQ7XG4gIH1cbiAgdGhpcy5fcXVldWUgPSBbXTtcbn1cblxuLyohXG4gKiBJbmhlcml0IGZyb20gRXZlbnRFbWl0dGVyXG4gKi9cblxuT2JqZWN0LnNldFByb3RvdHlwZU9mKENvbm5lY3Rpb24ucHJvdG90eXBlLCBFdmVudEVtaXR0ZXIucHJvdG90eXBlKTtcblxuLyoqXG4gKiBDb25uZWN0aW9uIHJlYWR5IHN0YXRlXG4gKlxuICogLSAwID0gZGlzY29ubmVjdGVkXG4gKiAtIDEgPSBjb25uZWN0ZWRcbiAqIC0gMiA9IGNvbm5lY3RpbmdcbiAqIC0gMyA9IGRpc2Nvbm5lY3RpbmdcbiAqXG4gKiBFYWNoIHN0YXRlIGNoYW5nZSBlbWl0cyBpdHMgYXNzb2NpYXRlZCBldmVudCBuYW1lLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgY29ubi5vbignY29ubmVjdGVkJywgY2FsbGJhY2spO1xuICogICAgIGNvbm4ub24oJ2Rpc2Nvbm5lY3RlZCcsIGNhbGxiYWNrKTtcbiAqXG4gKiBAcHJvcGVydHkgcmVhZHlTdGF0ZVxuICogQG1lbWJlck9mIENvbm5lY3Rpb25cbiAqIEBpbnN0YW5jZVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoQ29ubmVjdGlvbi5wcm90b3R5cGUsICdyZWFkeVN0YXRlJywge1xuICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl9yZWFkeVN0YXRlO1xuICB9LFxuICBzZXQ6IGZ1bmN0aW9uKHZhbCkge1xuICAgIGlmICghKHZhbCBpbiBTVEFURVMpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgY29ubmVjdGlvbiBzdGF0ZTogJyArIHZhbCk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX3JlYWR5U3RhdGUgIT09IHZhbCkge1xuICAgICAgdGhpcy5fcmVhZHlTdGF0ZSA9IHZhbDtcbiAgICAgIC8vIFtsZWdhY3ldIGxvb3Agb3ZlciB0aGUgb3RoZXJEYnMgb24gdGhpcyBjb25uZWN0aW9uIGFuZCBjaGFuZ2UgdGhlaXIgc3RhdGVcbiAgICAgIGZvciAoY29uc3QgZGIgb2YgdGhpcy5vdGhlckRicykge1xuICAgICAgICBkYi5yZWFkeVN0YXRlID0gdmFsO1xuICAgICAgfVxuXG4gICAgICBpZiAoU1RBVEVTLmNvbm5lY3RlZCA9PT0gdmFsKSB7XG4gICAgICAgIHRoaXMuX2hhc09wZW5lZCA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuZW1pdChTVEFURVNbdmFsXSk7XG4gICAgfVxuICB9XG59KTtcblxuLyoqXG4gKiBHZXRzIHRoZSB2YWx1ZSBvZiB0aGUgb3B0aW9uIGBrZXlgLiBFcXVpdmFsZW50IHRvIGBjb25uLm9wdGlvbnNba2V5XWBcbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbm4uZ2V0KCd0ZXN0Jyk7IC8vIHJldHVybnMgdGhlICd0ZXN0JyB2YWx1ZVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBrZXlcbiAqIEBtZXRob2QgZ2V0XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkNvbm5lY3Rpb24ucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uKGtleSkge1xuICBpZiAodGhpcy5jb25maWcuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgIHJldHVybiB0aGlzLmNvbmZpZ1trZXldO1xuICB9XG5cbiAgcmV0dXJuIGdldCh0aGlzLm9wdGlvbnMsIGtleSk7XG59O1xuXG4vKipcbiAqIFNldHMgdGhlIHZhbHVlIG9mIHRoZSBvcHRpb24gYGtleWAuIEVxdWl2YWxlbnQgdG8gYGNvbm4ub3B0aW9uc1trZXldID0gdmFsYFxuICpcbiAqIFN1cHBvcnRlZCBvcHRpb25zIGluY2x1ZGU6XG4gKlxuICogLSBgbWF4VGltZU1TYDogU2V0IFtgbWF4VGltZU1TYF0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2FwaS9xdWVyeS5odG1sI1F1ZXJ5LnByb3RvdHlwZS5tYXhUaW1lTVMoKSkgZm9yIGFsbCBxdWVyaWVzIG9uIHRoaXMgY29ubmVjdGlvbi5cbiAqIC0gJ2RlYnVnJzogSWYgYHRydWVgLCBwcmludHMgdGhlIG9wZXJhdGlvbnMgbW9uZ29vc2Ugc2VuZHMgdG8gTW9uZ29EQiB0byB0aGUgY29uc29sZS4gSWYgYSB3cml0YWJsZSBzdHJlYW0gaXMgcGFzc2VkLCBpdCB3aWxsIGxvZyB0byB0aGF0IHN0cmVhbSwgd2l0aG91dCBjb2xvcml6YXRpb24uIElmIGEgY2FsbGJhY2sgZnVuY3Rpb24gaXMgcGFzc2VkLCBpdCB3aWxsIHJlY2VpdmUgdGhlIGNvbGxlY3Rpb24gbmFtZSwgdGhlIG1ldGhvZCBuYW1lLCB0aGVuIGFsbCBhcnVnbWVudHMgcGFzc2VkIHRvIHRoZSBtZXRob2QuIEZvciBleGFtcGxlLCBpZiB5b3Ugd2FudGVkIHRvIHJlcGxpY2F0ZSB0aGUgZGVmYXVsdCBsb2dnaW5nLCB5b3UgY291bGQgb3V0cHV0IGZyb20gdGhlIGNhbGxiYWNrIGBNb25nb29zZTogJHtjb2xsZWN0aW9uTmFtZX0uJHttZXRob2ROYW1lfSgke21ldGhvZEFyZ3Muam9pbignLCAnKX0pYC5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbm4uc2V0KCd0ZXN0JywgJ2ZvbycpO1xuICogICAgIGNvbm4uZ2V0KCd0ZXN0Jyk7IC8vICdmb28nXG4gKiAgICAgY29ubi5vcHRpb25zLnRlc3Q7IC8vICdmb28nXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGtleVxuICogQHBhcmFtIHtBbnl9IHZhbFxuICogQG1ldGhvZCBzZXRcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuQ29ubmVjdGlvbi5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24oa2V5LCB2YWwpIHtcbiAgaWYgKHRoaXMuY29uZmlnLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICB0aGlzLmNvbmZpZ1trZXldID0gdmFsO1xuICAgIHJldHVybiB2YWw7XG4gIH1cblxuICB0aGlzLm9wdGlvbnMgPSB0aGlzLm9wdGlvbnMgfHwge307XG4gIHRoaXMub3B0aW9uc1trZXldID0gdmFsO1xuICByZXR1cm4gdmFsO1xufTtcblxuLyoqXG4gKiBBIGhhc2ggb2YgdGhlIGNvbGxlY3Rpb25zIGFzc29jaWF0ZWQgd2l0aCB0aGlzIGNvbm5lY3Rpb25cbiAqXG4gKiBAcHJvcGVydHkgY29sbGVjdGlvbnNcbiAqIEBtZW1iZXJPZiBDb25uZWN0aW9uXG4gKiBAaW5zdGFuY2VcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuQ29ubmVjdGlvbi5wcm90b3R5cGUuY29sbGVjdGlvbnM7XG5cbi8qKlxuICogVGhlIG5hbWUgb2YgdGhlIGRhdGFiYXNlIHRoaXMgY29ubmVjdGlvbiBwb2ludHMgdG8uXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBtb25nb29zZS5jcmVhdGVDb25uZWN0aW9uKCdtb25nb2RiOi8vMTI3LjAuMC4xOjI3MDE3L215ZGInKS5uYW1lOyAvLyBcIm15ZGJcIlxuICpcbiAqIEBwcm9wZXJ0eSBuYW1lXG4gKiBAbWVtYmVyT2YgQ29ubmVjdGlvblxuICogQGluc3RhbmNlXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkNvbm5lY3Rpb24ucHJvdG90eXBlLm5hbWU7XG5cbi8qKlxuICogQSBbUE9KT10oaHR0cHM6Ly9tYXN0ZXJpbmdqcy5pby90dXRvcmlhbHMvZnVuZGFtZW50YWxzL3Bvam8pIGNvbnRhaW5pbmdcbiAqIGEgbWFwIGZyb20gbW9kZWwgbmFtZXMgdG8gbW9kZWxzLiBDb250YWlucyBhbGwgbW9kZWxzIHRoYXQgaGF2ZSBiZWVuXG4gKiBhZGRlZCB0byB0aGlzIGNvbm5lY3Rpb24gdXNpbmcgW2BDb25uZWN0aW9uI21vZGVsKClgXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvYXBpL2Nvbm5lY3Rpb24uaHRtbCNDb25uZWN0aW9uLnByb3RvdHlwZS5tb2RlbCgpKS5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IGNvbm4gPSBtb25nb29zZS5jcmVhdGVDb25uZWN0aW9uKCk7XG4gKiAgICAgY29uc3QgVGVzdCA9IGNvbm4ubW9kZWwoJ1Rlc3QnLCBtb25nb29zZS5TY2hlbWEoeyBuYW1lOiBTdHJpbmcgfSkpO1xuICpcbiAqICAgICBPYmplY3Qua2V5cyhjb25uLm1vZGVscykubGVuZ3RoOyAvLyAxXG4gKiAgICAgY29ubi5tb2RlbHMuVGVzdCA9PT0gVGVzdDsgLy8gdHJ1ZVxuICpcbiAqIEBwcm9wZXJ0eSBtb2RlbHNcbiAqIEBtZW1iZXJPZiBDb25uZWN0aW9uXG4gKiBAaW5zdGFuY2VcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuQ29ubmVjdGlvbi5wcm90b3R5cGUubW9kZWxzO1xuXG4vKipcbiAqIEEgbnVtYmVyIGlkZW50aWZpZXIgZm9yIHRoaXMgY29ubmVjdGlvbi4gVXNlZCBmb3IgZGVidWdnaW5nIHdoZW5cbiAqIHlvdSBoYXZlIFttdWx0aXBsZSBjb25uZWN0aW9uc10oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2Nvbm5lY3Rpb25zLmh0bWwjbXVsdGlwbGVfY29ubmVjdGlvbnMpLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgLy8gVGhlIGRlZmF1bHQgY29ubmVjdGlvbiBoYXMgYGlkID0gMGBcbiAqICAgICBtb25nb29zZS5jb25uZWN0aW9uLmlkOyAvLyAwXG4gKlxuICogICAgIC8vIElmIHlvdSBjcmVhdGUgYSBuZXcgY29ubmVjdGlvbiwgTW9uZ29vc2UgaW5jcmVtZW50cyBpZFxuICogICAgIGNvbnN0IGNvbm4gPSBtb25nb29zZS5jcmVhdGVDb25uZWN0aW9uKCk7XG4gKiAgICAgY29ubi5pZDsgLy8gMVxuICpcbiAqIEBwcm9wZXJ0eSBpZFxuICogQG1lbWJlck9mIENvbm5lY3Rpb25cbiAqIEBpbnN0YW5jZVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Db25uZWN0aW9uLnByb3RvdHlwZS5pZDtcblxuLyoqXG4gKiBUaGUgcGx1Z2lucyB0aGF0IHdpbGwgYmUgYXBwbGllZCB0byBhbGwgbW9kZWxzIGNyZWF0ZWQgb24gdGhpcyBjb25uZWN0aW9uLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgY29uc3QgZGIgPSBtb25nb29zZS5jcmVhdGVDb25uZWN0aW9uKCdtb25nb2RiOi8vMTI3LjAuMC4xOjI3MDE3L215ZGInKTtcbiAqICAgICBkYi5wbHVnaW4oKCkgPT4gY29uc29sZS5sb2coJ0FwcGxpZWQnKSk7XG4gKiAgICAgZGIucGx1Z2lucy5sZW5ndGg7IC8vIDFcbiAqXG4gKiAgICAgZGIubW9kZWwoJ1Rlc3QnLCBuZXcgU2NoZW1hKHt9KSk7IC8vIFByaW50cyBcIkFwcGxpZWRcIlxuICpcbiAqIEBwcm9wZXJ0eSBwbHVnaW5zXG4gKiBAbWVtYmVyT2YgQ29ubmVjdGlvblxuICogQGluc3RhbmNlXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb25uZWN0aW9uLnByb3RvdHlwZSwgJ3BsdWdpbnMnLCB7XG4gIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gIGVudW1lcmFibGU6IHRydWUsXG4gIHdyaXRhYmxlOiB0cnVlXG59KTtcblxuLyoqXG4gKiBUaGUgaG9zdCBuYW1lIHBvcnRpb24gb2YgdGhlIFVSSS4gSWYgbXVsdGlwbGUgaG9zdHMsIHN1Y2ggYXMgYSByZXBsaWNhIHNldCxcbiAqIHRoaXMgd2lsbCBjb250YWluIHRoZSBmaXJzdCBob3N0IG5hbWUgaW4gdGhlIFVSSVxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgbW9uZ29vc2UuY3JlYXRlQ29ubmVjdGlvbignbW9uZ29kYjovLzEyNy4wLjAuMToyNzAxNy9teWRiJykuaG9zdDsgLy8gXCIxMjcuMC4wLjFcIlxuICpcbiAqIEBwcm9wZXJ0eSBob3N0XG4gKiBAbWVtYmVyT2YgQ29ubmVjdGlvblxuICogQGluc3RhbmNlXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb25uZWN0aW9uLnByb3RvdHlwZSwgJ2hvc3QnLCB7XG4gIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgd3JpdGFibGU6IHRydWVcbn0pO1xuXG4vKipcbiAqIFRoZSBwb3J0IHBvcnRpb24gb2YgdGhlIFVSSS4gSWYgbXVsdGlwbGUgaG9zdHMsIHN1Y2ggYXMgYSByZXBsaWNhIHNldCxcbiAqIHRoaXMgd2lsbCBjb250YWluIHRoZSBwb3J0IGZyb20gdGhlIGZpcnN0IGhvc3QgbmFtZSBpbiB0aGUgVVJJLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgbW9uZ29vc2UuY3JlYXRlQ29ubmVjdGlvbignbW9uZ29kYjovLzEyNy4wLjAuMToyNzAxNy9teWRiJykucG9ydDsgLy8gMjcwMTdcbiAqXG4gKiBAcHJvcGVydHkgcG9ydFxuICogQG1lbWJlck9mIENvbm5lY3Rpb25cbiAqIEBpbnN0YW5jZVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoQ29ubmVjdGlvbi5wcm90b3R5cGUsICdwb3J0Jywge1xuICBjb25maWd1cmFibGU6IHRydWUsXG4gIGVudW1lcmFibGU6IHRydWUsXG4gIHdyaXRhYmxlOiB0cnVlXG59KTtcblxuLyoqXG4gKiBUaGUgdXNlcm5hbWUgc3BlY2lmaWVkIGluIHRoZSBVUklcbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIG1vbmdvb3NlLmNyZWF0ZUNvbm5lY3Rpb24oJ21vbmdvZGI6Ly92YWw6cHN3QDEyNy4wLjAuMToyNzAxNy9teWRiJykudXNlcjsgLy8gXCJ2YWxcIlxuICpcbiAqIEBwcm9wZXJ0eSB1c2VyXG4gKiBAbWVtYmVyT2YgQ29ubmVjdGlvblxuICogQGluc3RhbmNlXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb25uZWN0aW9uLnByb3RvdHlwZSwgJ3VzZXInLCB7XG4gIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgd3JpdGFibGU6IHRydWVcbn0pO1xuXG4vKipcbiAqIFRoZSBwYXNzd29yZCBzcGVjaWZpZWQgaW4gdGhlIFVSSVxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgbW9uZ29vc2UuY3JlYXRlQ29ubmVjdGlvbignbW9uZ29kYjovL3ZhbDpwc3dAMTI3LjAuMC4xOjI3MDE3L215ZGInKS5wYXNzOyAvLyBcInBzd1wiXG4gKlxuICogQHByb3BlcnR5IHBhc3NcbiAqIEBtZW1iZXJPZiBDb25uZWN0aW9uXG4gKiBAaW5zdGFuY2VcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbm5lY3Rpb24ucHJvdG90eXBlLCAncGFzcycsIHtcbiAgY29uZmlndXJhYmxlOiB0cnVlLFxuICBlbnVtZXJhYmxlOiB0cnVlLFxuICB3cml0YWJsZTogdHJ1ZVxufSk7XG5cbi8qKlxuICogVGhlIG1vbmdvZGIuRGIgaW5zdGFuY2UsIHNldCB3aGVuIHRoZSBjb25uZWN0aW9uIGlzIG9wZW5lZFxuICpcbiAqIEBwcm9wZXJ0eSBkYlxuICogQG1lbWJlck9mIENvbm5lY3Rpb25cbiAqIEBpbnN0YW5jZVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Db25uZWN0aW9uLnByb3RvdHlwZS5kYjtcblxuLyoqXG4gKiBUaGUgTW9uZ29DbGllbnQgaW5zdGFuY2UgdGhpcyBjb25uZWN0aW9uIHVzZXMgdG8gdGFsayB0byBNb25nb0RCLiBNb25nb29zZSBhdXRvbWF0aWNhbGx5IHNldHMgdGhpcyBwcm9wZXJ0eVxuICogd2hlbiB0aGUgY29ubmVjdGlvbiBpcyBvcGVuZWQuXG4gKlxuICogQHByb3BlcnR5IGNsaWVudFxuICogQG1lbWJlck9mIENvbm5lY3Rpb25cbiAqIEBpbnN0YW5jZVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Db25uZWN0aW9uLnByb3RvdHlwZS5jbGllbnQ7XG5cbi8qKlxuICogQSBoYXNoIG9mIHRoZSBnbG9iYWwgb3B0aW9ucyB0aGF0IGFyZSBhc3NvY2lhdGVkIHdpdGggdGhpcyBjb25uZWN0aW9uXG4gKlxuICogQHByb3BlcnR5IGNvbmZpZ1xuICogQG1lbWJlck9mIENvbm5lY3Rpb25cbiAqIEBpbnN0YW5jZVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Db25uZWN0aW9uLnByb3RvdHlwZS5jb25maWc7XG5cbi8qKlxuICogSGVscGVyIGZvciBgY3JlYXRlQ29sbGVjdGlvbigpYC4gV2lsbCBleHBsaWNpdGx5IGNyZWF0ZSB0aGUgZ2l2ZW4gY29sbGVjdGlvblxuICogd2l0aCBzcGVjaWZpZWQgb3B0aW9ucy4gVXNlZCB0byBjcmVhdGUgW2NhcHBlZCBjb2xsZWN0aW9uc10oaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvY29yZS9jYXBwZWQtY29sbGVjdGlvbnMvKVxuICogYW5kIFt2aWV3c10oaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvY29yZS92aWV3cy8pIGZyb20gbW9uZ29vc2UuXG4gKlxuICogT3B0aW9ucyBhcmUgcGFzc2VkIGRvd24gd2l0aG91dCBtb2RpZmljYXRpb24gdG8gdGhlIFtNb25nb0RCIGRyaXZlcidzIGBjcmVhdGVDb2xsZWN0aW9uKClgIGZ1bmN0aW9uXShodHRwczovL21vbmdvZGIuZ2l0aHViLmlvL25vZGUtbW9uZ29kYi1uYXRpdmUvNC45L2NsYXNzZXMvRGIuaHRtbCNjcmVhdGVDb2xsZWN0aW9uKVxuICpcbiAqIEBtZXRob2QgY3JlYXRlQ29sbGVjdGlvblxuICogQHBhcmFtIHtzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gY3JlYXRlXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIHNlZSBbTW9uZ29EQiBkcml2ZXIgZG9jc10oaHR0cHM6Ly9tb25nb2RiLmdpdGh1Yi5pby9ub2RlLW1vbmdvZGItbmF0aXZlLzQuOS9jbGFzc2VzL0RiLmh0bWwjY3JlYXRlQ29sbGVjdGlvbilcbiAqIEByZXR1cm4ge1Byb21pc2V9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkNvbm5lY3Rpb24ucHJvdG90eXBlLmNyZWF0ZUNvbGxlY3Rpb24gPSBhc3luYyBmdW5jdGlvbiBjcmVhdGVDb2xsZWN0aW9uKGNvbGxlY3Rpb24sIG9wdGlvbnMpIHtcbiAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nIHx8IChhcmd1bWVudHMubGVuZ3RoID49IDMgJiYgdHlwZW9mIGFyZ3VtZW50c1syXSA9PT0gJ2Z1bmN0aW9uJykpIHtcbiAgICB0aHJvdyBuZXcgTW9uZ29vc2VFcnJvcignQ29ubmVjdGlvbi5wcm90b3R5cGUuY3JlYXRlQ29sbGVjdGlvbigpIG5vIGxvbmdlciBhY2NlcHRzIGEgY2FsbGJhY2snKTtcbiAgfVxuXG4gIGlmICgodGhpcy5yZWFkeVN0YXRlID09PSBTVEFURVMuY29ubmVjdGluZyB8fCB0aGlzLnJlYWR5U3RhdGUgPT09IFNUQVRFUy5kaXNjb25uZWN0ZWQpICYmIHRoaXMuX3Nob3VsZEJ1ZmZlckNvbW1hbmRzKCkpIHtcbiAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgIHRoaXMuX3F1ZXVlLnB1c2goeyBmbjogcmVzb2x2ZSB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiB0aGlzLmRiLmNyZWF0ZUNvbGxlY3Rpb24oY29sbGVjdGlvbiwgb3B0aW9ucyk7XG59O1xuXG4vKipcbiAqIENhbGxzIGBjcmVhdGVDb2xsZWN0aW9uKClgIG9uIGEgbW9kZWxzIGluIGEgc2VyaWVzLlxuICpcbiAqIEBtZXRob2QgY3JlYXRlQ29sbGVjdGlvbnNcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gY29udGludWVPbkVycm9yIFdoZW4gdHJ1ZSwgd2lsbCBjb250aW51ZSB0byBjcmVhdGUgY29sbGVjdGlvbnMgYW5kIGNyZWF0ZSBhIG5ldyBlcnJvciBjbGFzcyBmb3IgdGhlIGNvbGxlY3Rpb25zIHRoYXQgZXJyb3JlZC5cbiAqIEByZXR1cm5zIHtQcm9taXNlfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Db25uZWN0aW9uLnByb3RvdHlwZS5jcmVhdGVDb2xsZWN0aW9ucyA9IGFzeW5jIGZ1bmN0aW9uIGNyZWF0ZUNvbGxlY3Rpb25zKG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCByZXN1bHQgPSB7fTtcbiAgY29uc3QgZXJyb3JzTWFwID0geyB9O1xuXG4gIGNvbnN0IHsgY29udGludWVPbkVycm9yIH0gPSBvcHRpb25zO1xuICBkZWxldGUgb3B0aW9ucy5jb250aW51ZU9uRXJyb3I7XG4gIGZvciAoY29uc3QgbW9kZWwgb2YgT2JqZWN0LnZhbHVlcyh0aGlzLm1vZGVscykpIHtcbiAgICB0cnkge1xuICAgICAgcmVzdWx0W21vZGVsLm1vZGVsTmFtZV0gPSBhd2FpdCBtb2RlbC5jcmVhdGVDb2xsZWN0aW9uKHt9KTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGlmICghY29udGludWVPbkVycm9yKSB7XG4gICAgICAgIGVycm9yc01hcFttb2RlbC5tb2RlbE5hbWVdID0gZXJyO1xuICAgICAgICBicmVhaztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdFttb2RlbC5tb2RlbE5hbWVdID0gZXJyO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmICghY29udGludWVPbkVycm9yICYmIE9iamVjdC5rZXlzKGVycm9yc01hcCkubGVuZ3RoKSB7XG4gICAgY29uc3QgbWVzc2FnZSA9IE9iamVjdC5lbnRyaWVzKGVycm9yc01hcCkubWFwKChbbW9kZWxOYW1lLCBlcnJdKSA9PiBgJHttb2RlbE5hbWV9OiAke2Vyci5tZXNzYWdlfWApLmpvaW4oJywgJyk7XG4gICAgY29uc3QgY3JlYXRlQ29sbGVjdGlvbnNFcnJvciA9IG5ldyBDcmVhdGVDb2xsZWN0aW9uc0Vycm9yKG1lc3NhZ2UsIGVycm9yc01hcCk7XG4gICAgdGhyb3cgY3JlYXRlQ29sbGVjdGlvbnNFcnJvcjtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBBIGNvbnZlbmllbmNlIHdyYXBwZXIgZm9yIGBjb25uZWN0aW9uLmNsaWVudC53aXRoU2Vzc2lvbigpYC5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGF3YWl0IGNvbm4ud2l0aFNlc3Npb24oYXN5bmMgc2Vzc2lvbiA9PiB7XG4gKiAgICAgICBjb25zdCBkb2MgPSBhd2FpdCBUZXN0TW9kZWwuZmluZE9uZSgpLnNlc3Npb24oc2Vzc2lvbik7XG4gKiAgICAgfSk7XG4gKlxuICogQG1ldGhvZCB3aXRoU2Vzc2lvblxuICogQHBhcmFtIHtGdW5jdGlvbn0gZXhlY3V0b3IgY2FsbGVkIHdpdGggMSBhcmd1bWVudDogYSBgQ2xpZW50U2Vzc2lvbmAgaW5zdGFuY2VcbiAqIEByZXR1cm4ge1Byb21pc2V9IHJlc29sdmVzIHRvIHRoZSByZXR1cm4gdmFsdWUgb2YgdGhlIGV4ZWN1dG9yIGZ1bmN0aW9uXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkNvbm5lY3Rpb24ucHJvdG90eXBlLndpdGhTZXNzaW9uID0gYXN5bmMgZnVuY3Rpb24gd2l0aFNlc3Npb24oZXhlY3V0b3IpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1BsZWFzZSBwcm92aWRlIGFuIGV4ZWN1dG9yIGZ1bmN0aW9uJyk7XG4gIH1cbiAgcmV0dXJuIGF3YWl0IHRoaXMuY2xpZW50LndpdGhTZXNzaW9uKGV4ZWN1dG9yKTtcbn07XG5cbi8qKlxuICogX1JlcXVpcmVzIE1vbmdvREIgPj0gMy42LjAuXyBTdGFydHMgYSBbTW9uZ29EQiBzZXNzaW9uXShodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9yZWxlYXNlLW5vdGVzLzMuNi8jY2xpZW50LXNlc3Npb25zKVxuICogZm9yIGJlbmVmaXRzIGxpa2UgY2F1c2FsIGNvbnNpc3RlbmN5LCBbcmV0cnlhYmxlIHdyaXRlc10oaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvY29yZS9yZXRyeWFibGUtd3JpdGVzLyksXG4gKiBhbmQgW3RyYW5zYWN0aW9uc10oaHR0cHM6Ly90aGVjb2RlYmFyYmFyaWFuLmNvbS9hLW5vZGUtanMtcGVyc3BlY3RpdmUtb24tbW9uZ29kYi00LXRyYW5zYWN0aW9ucy5odG1sKS5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IHNlc3Npb24gPSBhd2FpdCBjb25uLnN0YXJ0U2Vzc2lvbigpO1xuICogICAgIGxldCBkb2MgPSBhd2FpdCBQZXJzb24uZmluZE9uZSh7IG5hbWU6ICdOZWQgU3RhcmsnIH0sIG51bGwsIHsgc2Vzc2lvbiB9KTtcbiAqICAgICBhd2FpdCBkb2MucmVtb3ZlKCk7XG4gKiAgICAgLy8gYGRvY2Agd2lsbCBhbHdheXMgYmUgbnVsbCwgZXZlbiBpZiByZWFkaW5nIGZyb20gYSByZXBsaWNhIHNldFxuICogICAgIC8vIHNlY29uZGFyeS4gV2l0aG91dCBjYXVzYWwgY29uc2lzdGVuY3ksIGl0IGlzIHBvc3NpYmxlIHRvXG4gKiAgICAgLy8gZ2V0IGEgZG9jIGJhY2sgZnJvbSB0aGUgYmVsb3cgcXVlcnkgaWYgdGhlIHF1ZXJ5IHJlYWRzIGZyb20gYVxuICogICAgIC8vIHNlY29uZGFyeSB0aGF0IGlzIGV4cGVyaWVuY2luZyByZXBsaWNhdGlvbiBsYWcuXG4gKiAgICAgZG9jID0gYXdhaXQgUGVyc29uLmZpbmRPbmUoeyBuYW1lOiAnTmVkIFN0YXJrJyB9LCBudWxsLCB7IHNlc3Npb24sIHJlYWRQcmVmZXJlbmNlOiAnc2Vjb25kYXJ5JyB9KTtcbiAqXG4gKlxuICogQG1ldGhvZCBzdGFydFNlc3Npb25cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gc2VlIHRoZSBbbW9uZ29kYiBkcml2ZXIgb3B0aW9uc10oaHR0cHM6Ly9tb25nb2RiLmdpdGh1Yi5pby9ub2RlLW1vbmdvZGItbmF0aXZlLzQuOS9jbGFzc2VzL01vbmdvQ2xpZW50Lmh0bWwjc3RhcnRTZXNzaW9uKVxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5jYXVzYWxDb25zaXN0ZW5jeT10cnVlXSBzZXQgdG8gZmFsc2UgdG8gZGlzYWJsZSBjYXVzYWwgY29uc2lzdGVuY3lcbiAqIEByZXR1cm4ge1Byb21pc2U8Q2xpZW50U2Vzc2lvbj59IHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIE1vbmdvREIgZHJpdmVyIGBDbGllbnRTZXNzaW9uYFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Db25uZWN0aW9uLnByb3RvdHlwZS5zdGFydFNlc3Npb24gPSBhc3luYyBmdW5jdGlvbiBzdGFydFNlc3Npb24ob3B0aW9ucykge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+PSAyICYmIHR5cGVvZiBhcmd1bWVudHNbMV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgTW9uZ29vc2VFcnJvcignQ29ubmVjdGlvbi5wcm90b3R5cGUuc3RhcnRTZXNzaW9uKCkgbm8gbG9uZ2VyIGFjY2VwdHMgYSBjYWxsYmFjaycpO1xuICB9XG5cbiAgaWYgKCh0aGlzLnJlYWR5U3RhdGUgPT09IFNUQVRFUy5jb25uZWN0aW5nIHx8IHRoaXMucmVhZHlTdGF0ZSA9PT0gU1RBVEVTLmRpc2Nvbm5lY3RlZCkgJiYgdGhpcy5fc2hvdWxkQnVmZmVyQ29tbWFuZHMoKSkge1xuICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgdGhpcy5fcXVldWUucHVzaCh7IGZuOiByZXNvbHZlIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgY29uc3Qgc2Vzc2lvbiA9IHRoaXMuY2xpZW50LnN0YXJ0U2Vzc2lvbihvcHRpb25zKTtcbiAgcmV0dXJuIHNlc3Npb247XG59O1xuXG4vKipcbiAqIF9SZXF1aXJlcyBNb25nb0RCID49IDMuNi4wLl8gRXhlY3V0ZXMgdGhlIHdyYXBwZWQgYXN5bmMgZnVuY3Rpb25cbiAqIGluIGEgdHJhbnNhY3Rpb24uIE1vbmdvb3NlIHdpbGwgY29tbWl0IHRoZSB0cmFuc2FjdGlvbiBpZiB0aGVcbiAqIGFzeW5jIGZ1bmN0aW9uIGV4ZWN1dGVzIHN1Y2Nlc3NmdWxseSBhbmQgYXR0ZW1wdCB0byByZXRyeSBpZlxuICogdGhlcmUgd2FzIGEgcmV0cmlhYmxlIGVycm9yLlxuICpcbiAqIENhbGxzIHRoZSBNb25nb0RCIGRyaXZlcidzIFtgc2Vzc2lvbi53aXRoVHJhbnNhY3Rpb24oKWBdKGh0dHBzOi8vbW9uZ29kYi5naXRodWIuaW8vbm9kZS1tb25nb2RiLW5hdGl2ZS80LjkvY2xhc3Nlcy9DbGllbnRTZXNzaW9uLmh0bWwjd2l0aFRyYW5zYWN0aW9uKSxcbiAqIGJ1dCBhbHNvIGhhbmRsZXMgcmVzZXR0aW5nIE1vbmdvb3NlIGRvY3VtZW50IHN0YXRlIGFzIHNob3duIGJlbG93LlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgY29uc3QgZG9jID0gbmV3IFBlcnNvbih7IG5hbWU6ICdXaWxsIFJpa2VyJyB9KTtcbiAqICAgICBhd2FpdCBkYi50cmFuc2FjdGlvbihhc3luYyBmdW5jdGlvbiBzZXRSYW5rKHNlc3Npb24pIHtcbiAqICAgICAgIGRvYy5yYW5rID0gJ0NhcHRhaW4nO1xuICogICAgICAgYXdhaXQgZG9jLnNhdmUoeyBzZXNzaW9uIH0pO1xuICogICAgICAgZG9jLmlzTmV3OyAvLyBmYWxzZVxuICpcbiAqICAgICAgIC8vIFRocm93IGFuIGVycm9yIHRvIGFib3J0IHRoZSB0cmFuc2FjdGlvblxuICogICAgICAgdGhyb3cgbmV3IEVycm9yKCdPb3BzIScpO1xuICogICAgIH0seyByZWFkUHJlZmVyZW5jZTogJ3ByaW1hcnknIH0pLmNhdGNoKCgpID0+IHt9KTtcbiAqXG4gKiAgICAgLy8gdHJ1ZSwgYHRyYW5zYWN0aW9uKClgIHJlc2V0IHRoZSBkb2N1bWVudCdzIHN0YXRlIGJlY2F1c2UgdGhlXG4gKiAgICAgLy8gdHJhbnNhY3Rpb24gd2FzIGFib3J0ZWQuXG4gKiAgICAgZG9jLmlzTmV3O1xuICpcbiAqIEBtZXRob2QgdHJhbnNhY3Rpb25cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIEZ1bmN0aW9uIHRvIGV4ZWN1dGUgaW4gYSB0cmFuc2FjdGlvblxuICogQHBhcmFtIHttb25nb2RiLlRyYW5zYWN0aW9uT3B0aW9uc30gW29wdGlvbnNdIE9wdGlvbmFsIHNldHRpbmdzIGZvciB0aGUgdHJhbnNhY3Rpb25cbiAqIEByZXR1cm4ge1Byb21pc2U8QW55Pn0gcHJvbWlzZSB0aGF0IGlzIGZ1bGZpbGxlZCBpZiBNb25nb29zZSBzdWNjZXNzZnVsbHkgY29tbWl0dGVkIHRoZSB0cmFuc2FjdGlvbiwgb3IgcmVqZWN0cyBpZiB0aGUgdHJhbnNhY3Rpb24gd2FzIGFib3J0ZWQgb3IgaWYgTW9uZ29vc2UgZmFpbGVkIHRvIGNvbW1pdCB0aGUgdHJhbnNhY3Rpb24uIElmIGZ1bGZpbGxlZCwgdGhlIHByb21pc2UgcmVzb2x2ZXMgdG8gYSBNb25nb0RCIGNvbW1hbmQgcmVzdWx0LlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Db25uZWN0aW9uLnByb3RvdHlwZS50cmFuc2FjdGlvbiA9IGZ1bmN0aW9uIHRyYW5zYWN0aW9uKGZuLCBvcHRpb25zKSB7XG4gIHJldHVybiB0aGlzLnN0YXJ0U2Vzc2lvbigpLnRoZW4oc2Vzc2lvbiA9PiB7XG4gICAgc2Vzc2lvbltzZXNzaW9uTmV3RG9jdW1lbnRzXSA9IG5ldyBNYXAoKTtcbiAgICByZXR1cm4gc2Vzc2lvbi53aXRoVHJhbnNhY3Rpb24oKCkgPT4gX3dyYXBVc2VyVHJhbnNhY3Rpb24oZm4sIHNlc3Npb24pLCBvcHRpb25zKS5cbiAgICAgIHRoZW4ocmVzID0+IHtcbiAgICAgICAgZGVsZXRlIHNlc3Npb25bc2Vzc2lvbk5ld0RvY3VtZW50c107XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgICB9KS5cbiAgICAgIGNhdGNoKGVyciA9PiB7XG4gICAgICAgIGRlbGV0ZSBzZXNzaW9uW3Nlc3Npb25OZXdEb2N1bWVudHNdO1xuICAgICAgICB0aHJvdyBlcnI7XG4gICAgICB9KS5cbiAgICAgIGZpbmFsbHkoKCkgPT4ge1xuICAgICAgICBzZXNzaW9uLmVuZFNlc3Npb24oKS5jYXRjaCgoKSA9PiB7fSk7XG4gICAgICB9KTtcbiAgfSk7XG59O1xuXG4vKiFcbiAqIFJlc2V0IGRvY3VtZW50IHN0YXRlIGluIGJldHdlZW4gdHJhbnNhY3Rpb24gcmV0cmllcyByZTogZ2gtMTM2OThcbiAqL1xuXG5hc3luYyBmdW5jdGlvbiBfd3JhcFVzZXJUcmFuc2FjdGlvbihmbiwgc2Vzc2lvbikge1xuICB0cnkge1xuICAgIGNvbnN0IHJlcyA9IGF3YWl0IGZuKHNlc3Npb24pO1xuICAgIHJldHVybiByZXM7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIF9yZXNldFNlc3Npb25Eb2N1bWVudHMoc2Vzc2lvbik7XG4gICAgdGhyb3cgZXJyO1xuICB9XG59XG5cbi8qIVxuICogSWYgdHJhbnNhY3Rpb24gd2FzIGFib3J0ZWQsIHdlIG5lZWQgdG8gcmVzZXQgbmV3bHkgaW5zZXJ0ZWQgZG9jdW1lbnRzJyBgaXNOZXdgLlxuICovXG5mdW5jdGlvbiBfcmVzZXRTZXNzaW9uRG9jdW1lbnRzKHNlc3Npb24pIHtcbiAgZm9yIChjb25zdCBkb2Mgb2Ygc2Vzc2lvbltzZXNzaW9uTmV3RG9jdW1lbnRzXS5rZXlzKCkpIHtcbiAgICBjb25zdCBzdGF0ZSA9IHNlc3Npb25bc2Vzc2lvbk5ld0RvY3VtZW50c10uZ2V0KGRvYyk7XG4gICAgaWYgKHN0YXRlLmhhc093blByb3BlcnR5KCdpc05ldycpKSB7XG4gICAgICBkb2MuJGlzTmV3ID0gc3RhdGUuaXNOZXc7XG4gICAgfVxuICAgIGlmIChzdGF0ZS5oYXNPd25Qcm9wZXJ0eSgndmVyc2lvbktleScpKSB7XG4gICAgICBkb2Muc2V0KGRvYy5zY2hlbWEub3B0aW9ucy52ZXJzaW9uS2V5LCBzdGF0ZS52ZXJzaW9uS2V5KTtcbiAgICB9XG5cbiAgICBpZiAoc3RhdGUubW9kaWZpZWRQYXRocy5sZW5ndGggPiAwICYmIGRvYy4kX18uYWN0aXZlUGF0aHMuc3RhdGVzLm1vZGlmeSA9PSBudWxsKSB7XG4gICAgICBkb2MuJF9fLmFjdGl2ZVBhdGhzLnN0YXRlcy5tb2RpZnkgPSB7fTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBwYXRoIG9mIHN0YXRlLm1vZGlmaWVkUGF0aHMpIHtcbiAgICAgIGNvbnN0IGN1cnJlbnRTdGF0ZSA9IGRvYy4kX18uYWN0aXZlUGF0aHMucGF0aHNbcGF0aF07XG4gICAgICBpZiAoY3VycmVudFN0YXRlICE9IG51bGwpIHtcbiAgICAgICAgZGVsZXRlIGRvYy4kX18uYWN0aXZlUGF0aHNbY3VycmVudFN0YXRlXVtwYXRoXTtcbiAgICAgIH1cbiAgICAgIGRvYy4kX18uYWN0aXZlUGF0aHMucGF0aHNbcGF0aF0gPSAnbW9kaWZ5JztcbiAgICAgIGRvYy4kX18uYWN0aXZlUGF0aHMuc3RhdGVzLm1vZGlmeVtwYXRoXSA9IHRydWU7XG4gICAgfVxuXG4gICAgZm9yIChjb25zdCBwYXRoIG9mIHN0YXRlLmF0b21pY3Mua2V5cygpKSB7XG4gICAgICBjb25zdCB2YWwgPSBkb2MuJF9fZ2V0VmFsdWUocGF0aCk7XG4gICAgICBpZiAodmFsID09IG51bGwpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICB2YWxbYXJyYXlBdG9taWNzU3ltYm9sXSA9IHN0YXRlLmF0b21pY3MuZ2V0KHBhdGgpO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEhlbHBlciBmb3IgYGRyb3BDb2xsZWN0aW9uKClgLiBXaWxsIGRlbGV0ZSB0aGUgZ2l2ZW4gY29sbGVjdGlvbiwgaW5jbHVkaW5nXG4gKiBhbGwgZG9jdW1lbnRzIGFuZCBpbmRleGVzLlxuICpcbiAqIEBtZXRob2QgZHJvcENvbGxlY3Rpb25cbiAqIEBwYXJhbSB7c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGRlbGV0ZVxuICogQHJldHVybiB7UHJvbWlzZX1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuQ29ubmVjdGlvbi5wcm90b3R5cGUuZHJvcENvbGxlY3Rpb24gPSBhc3luYyBmdW5jdGlvbiBkcm9wQ29sbGVjdGlvbihjb2xsZWN0aW9uKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID49IDIgJiYgdHlwZW9mIGFyZ3VtZW50c1sxXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBNb25nb29zZUVycm9yKCdDb25uZWN0aW9uLnByb3RvdHlwZS5kcm9wQ29sbGVjdGlvbigpIG5vIGxvbmdlciBhY2NlcHRzIGEgY2FsbGJhY2snKTtcbiAgfVxuXG4gIGlmICgodGhpcy5yZWFkeVN0YXRlID09PSBTVEFURVMuY29ubmVjdGluZyB8fCB0aGlzLnJlYWR5U3RhdGUgPT09IFNUQVRFUy5kaXNjb25uZWN0ZWQpICYmIHRoaXMuX3Nob3VsZEJ1ZmZlckNvbW1hbmRzKCkpIHtcbiAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgIHRoaXMuX3F1ZXVlLnB1c2goeyBmbjogcmVzb2x2ZSB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiB0aGlzLmRiLmRyb3BDb2xsZWN0aW9uKGNvbGxlY3Rpb24pO1xufTtcblxuLyoqXG4gKiBIZWxwZXIgZm9yIE1vbmdvREIgTm9kZSBkcml2ZXIncyBgbGlzdENvbGxlY3Rpb25zKClgLlxuICogUmV0dXJucyBhbiBhcnJheSBvZiBjb2xsZWN0aW9uIG9iamVjdHMuXG4gKlxuICogQG1ldGhvZCBsaXN0Q29sbGVjdGlvbnNcbiAqIEByZXR1cm4ge1Byb21pc2U8Q29sbGVjdGlvbltdPn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuQ29ubmVjdGlvbi5wcm90b3R5cGUubGlzdENvbGxlY3Rpb25zID0gYXN5bmMgZnVuY3Rpb24gbGlzdENvbGxlY3Rpb25zKCkge1xuICBpZiAoKHRoaXMucmVhZHlTdGF0ZSA9PT0gU1RBVEVTLmNvbm5lY3RpbmcgfHwgdGhpcy5yZWFkeVN0YXRlID09PSBTVEFURVMuZGlzY29ubmVjdGVkKSAmJiB0aGlzLl9zaG91bGRCdWZmZXJDb21tYW5kcygpKSB7XG4gICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICB0aGlzLl9xdWV1ZS5wdXNoKHsgZm46IHJlc29sdmUgfSk7XG4gICAgfSk7XG4gIH1cblxuICBjb25zdCBjdXJzb3IgPSB0aGlzLmRiLmxpc3RDb2xsZWN0aW9ucygpO1xuICByZXR1cm4gYXdhaXQgY3Vyc29yLnRvQXJyYXkoKTtcbn07XG5cbi8qKlxuICogSGVscGVyIGZvciBgZHJvcERhdGFiYXNlKClgLiBEZWxldGVzIHRoZSBnaXZlbiBkYXRhYmFzZSwgaW5jbHVkaW5nIGFsbFxuICogY29sbGVjdGlvbnMsIGRvY3VtZW50cywgYW5kIGluZGV4ZXMuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBjb25zdCBjb25uID0gbW9uZ29vc2UuY3JlYXRlQ29ubmVjdGlvbignbW9uZ29kYjovLzEyNy4wLjAuMToyNzAxNy9teWRiJyk7XG4gKiAgICAgLy8gRGVsZXRlcyB0aGUgZW50aXJlICdteWRiJyBkYXRhYmFzZVxuICogICAgIGF3YWl0IGNvbm4uZHJvcERhdGFiYXNlKCk7XG4gKlxuICogQG1ldGhvZCBkcm9wRGF0YWJhc2VcbiAqIEByZXR1cm4ge1Byb21pc2V9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkNvbm5lY3Rpb24ucHJvdG90eXBlLmRyb3BEYXRhYmFzZSA9IGFzeW5jIGZ1bmN0aW9uIGRyb3BEYXRhYmFzZSgpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPj0gMSAmJiB0eXBlb2YgYXJndW1lbnRzWzBdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IE1vbmdvb3NlRXJyb3IoJ0Nvbm5lY3Rpb24ucHJvdG90eXBlLmRyb3BEYXRhYmFzZSgpIG5vIGxvbmdlciBhY2NlcHRzIGEgY2FsbGJhY2snKTtcbiAgfVxuXG4gIGlmICgodGhpcy5yZWFkeVN0YXRlID09PSBTVEFURVMuY29ubmVjdGluZyB8fCB0aGlzLnJlYWR5U3RhdGUgPT09IFNUQVRFUy5kaXNjb25uZWN0ZWQpICYmIHRoaXMuX3Nob3VsZEJ1ZmZlckNvbW1hbmRzKCkpIHtcbiAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgIHRoaXMuX3F1ZXVlLnB1c2goeyBmbjogcmVzb2x2ZSB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIC8vIElmIGBkcm9wRGF0YWJhc2UoKWAgaXMgY2FsbGVkLCB0aGlzIG1vZGVsJ3MgY29sbGVjdGlvbiB3aWxsIG5vdCBiZVxuICAvLyBpbml0LWVkLiBJdCBpcyBzdWZmaWNpZW50bHkgY29tbW9uIHRvIGNhbGwgYGRyb3BEYXRhYmFzZSgpYCBhZnRlclxuICAvLyBgbW9uZ29vc2UuY29ubmVjdCgpYCBidXQgYmVmb3JlIGNyZWF0aW5nIG1vZGVscyB0aGF0IHdlIHdhbnQgdG9cbiAgLy8gc3VwcG9ydCB0aGlzLiBTZWUgZ2gtNjc5NlxuICBmb3IgKGNvbnN0IG1vZGVsIG9mIE9iamVjdC52YWx1ZXModGhpcy5tb2RlbHMpKSB7XG4gICAgZGVsZXRlIG1vZGVsLiRpbml0O1xuICB9XG5cbiAgcmV0dXJuIHRoaXMuZGIuZHJvcERhdGFiYXNlKCk7XG59O1xuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cbkNvbm5lY3Rpb24ucHJvdG90eXBlLl9zaG91bGRCdWZmZXJDb21tYW5kcyA9IGZ1bmN0aW9uIF9zaG91bGRCdWZmZXJDb21tYW5kcygpIHtcbiAgaWYgKHRoaXMuY29uZmlnLmJ1ZmZlckNvbW1hbmRzICE9IG51bGwpIHtcbiAgICByZXR1cm4gdGhpcy5jb25maWcuYnVmZmVyQ29tbWFuZHM7XG4gIH1cbiAgaWYgKHRoaXMuYmFzZS5nZXQoJ2J1ZmZlckNvbW1hbmRzJykgIT0gbnVsbCkge1xuICAgIHJldHVybiB0aGlzLmJhc2UuZ2V0KCdidWZmZXJDb21tYW5kcycpO1xuICB9XG4gIHJldHVybiB0cnVlO1xufTtcblxuLyoqXG4gKiBlcnJvclxuICpcbiAqIEdyYWNlZnVsIGVycm9yIGhhbmRsaW5nLCBwYXNzZXMgZXJyb3IgdG8gY2FsbGJhY2tcbiAqIGlmIGF2YWlsYWJsZSwgZWxzZSBlbWl0cyBlcnJvciBvbiB0aGUgY29ubmVjdGlvbi5cbiAqXG4gKiBAcGFyYW0ge0Vycm9yfSBlcnJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIG9wdGlvbmFsXG4gKiBAZW1pdHMgXCJlcnJvclwiIEVtaXRzIHRoZSBgZXJyb3JgIGV2ZW50IHdpdGggdGhlIGdpdmVuIGBlcnJgLCB1bmxlc3MgYSBjYWxsYmFjayBpcyBzcGVjaWZpZWRcbiAqIEByZXR1cm5zIHtQcm9taXNlfG51bGx9IFJldHVybnMgYSByZWplY3RlZCBQcm9taXNlIGlmIG5vIGBjYWxsYmFja2AgaXMgZ2l2ZW4uXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Db25uZWN0aW9uLnByb3RvdHlwZS5lcnJvciA9IGZ1bmN0aW9uKGVyciwgY2FsbGJhY2spIHtcbiAgaWYgKGNhbGxiYWNrKSB7XG4gICAgY2FsbGJhY2soZXJyKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBpZiAodGhpcy5saXN0ZW5lcnMoJ2Vycm9yJykubGVuZ3RoID4gMCkge1xuICAgIHRoaXMuZW1pdCgnZXJyb3InLCBlcnIpO1xuICB9XG4gIHJldHVybiBQcm9taXNlLnJlamVjdChlcnIpO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgd2hlbiB0aGUgY29ubmVjdGlvbiBpcyBvcGVuZWRcbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Db25uZWN0aW9uLnByb3RvdHlwZS5vbk9wZW4gPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5yZWFkeVN0YXRlID0gU1RBVEVTLmNvbm5lY3RlZDtcblxuICBmb3IgKGNvbnN0IGQgb2YgdGhpcy5fcXVldWUpIHtcbiAgICBkLmZuLmFwcGx5KGQuY3R4LCBkLmFyZ3MpO1xuICB9XG4gIHRoaXMuX3F1ZXVlID0gW107XG5cbiAgLy8gYXZvaWQgaGF2aW5nIHRoZSBjb2xsZWN0aW9uIHN1YnNjcmliZSB0byBvdXIgZXZlbnQgZW1pdHRlclxuICAvLyB0byBwcmV2ZW50IDAuMyB3YXJuaW5nXG4gIGZvciAoY29uc3QgaSBpbiB0aGlzLmNvbGxlY3Rpb25zKSB7XG4gICAgaWYgKHV0aWxzLm9iamVjdC5oYXNPd25Qcm9wZXJ0eSh0aGlzLmNvbGxlY3Rpb25zLCBpKSkge1xuICAgICAgdGhpcy5jb2xsZWN0aW9uc1tpXS5vbk9wZW4oKTtcbiAgICB9XG4gIH1cblxuICB0aGlzLmVtaXQoJ29wZW4nKTtcbn07XG5cbi8qKlxuICogT3BlbnMgdGhlIGNvbm5lY3Rpb24gd2l0aCBhIFVSSSB1c2luZyBgTW9uZ29DbGllbnQuY29ubmVjdCgpYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdXJpIFRoZSBVUkkgdG8gY29ubmVjdCB3aXRoLlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBQYXNzZWQgb24gdG8gW2BNb25nb0NsaWVudC5jb25uZWN0YF0oaHR0cHM6Ly9tb25nb2RiLmdpdGh1Yi5pby9ub2RlLW1vbmdvZGItbmF0aXZlLzQuOS9jbGFzc2VzL01vbmdvQ2xpZW50Lmh0bWwjY29ubmVjdC0xKVxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5idWZmZXJDb21tYW5kcz10cnVlXSBNb25nb29zZSBzcGVjaWZpYyBvcHRpb24uIFNldCB0byBmYWxzZSB0byBbZGlzYWJsZSBidWZmZXJpbmddKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9mYXEuaHRtbCNjYWxsYmFja19uZXZlcl9leGVjdXRlcykgb24gYWxsIG1vZGVscyBhc3NvY2lhdGVkIHdpdGggdGhpcyBjb25uZWN0aW9uLlxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmJ1ZmZlclRpbWVvdXRNUz0xMDAwMF0gTW9uZ29vc2Ugc3BlY2lmaWMgb3B0aW9uLiBJZiBgYnVmZmVyQ29tbWFuZHNgIGlzIHRydWUsIE1vbmdvb3NlIHdpbGwgdGhyb3cgYW4gZXJyb3IgYWZ0ZXIgYGJ1ZmZlclRpbWVvdXRNU2AgaWYgdGhlIG9wZXJhdGlvbiBpcyBzdGlsbCBidWZmZXJlZC5cbiAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5kYk5hbWVdIFRoZSBuYW1lIG9mIHRoZSBkYXRhYmFzZSB3ZSB3YW50IHRvIHVzZS4gSWYgbm90IHByb3ZpZGVkLCB1c2UgZGF0YWJhc2UgbmFtZSBmcm9tIGNvbm5lY3Rpb24gc3RyaW5nLlxuICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLnVzZXJdIHVzZXJuYW1lIGZvciBhdXRoZW50aWNhdGlvbiwgZXF1aXZhbGVudCB0byBgb3B0aW9ucy5hdXRoLnVzZXJgLiBNYWludGFpbmVkIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eS5cbiAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5wYXNzXSBwYXNzd29yZCBmb3IgYXV0aGVudGljYXRpb24sIGVxdWl2YWxlbnQgdG8gYG9wdGlvbnMuYXV0aC5wYXNzd29yZGAuIE1haW50YWluZWQgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LlxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLm1heFBvb2xTaXplPTEwMF0gVGhlIG1heGltdW0gbnVtYmVyIG9mIHNvY2tldHMgdGhlIE1vbmdvREIgZHJpdmVyIHdpbGwga2VlcCBvcGVuIGZvciB0aGlzIGNvbm5lY3Rpb24uIEtlZXAgaW4gbWluZCB0aGF0IE1vbmdvREIgb25seSBhbGxvd3Mgb25lIG9wZXJhdGlvbiBwZXIgc29ja2V0IGF0IGEgdGltZSwgc28geW91IG1heSB3YW50IHRvIGluY3JlYXNlIHRoaXMgaWYgeW91IGZpbmQgeW91IGhhdmUgYSBmZXcgc2xvdyBxdWVyaWVzIHRoYXQgYXJlIGJsb2NraW5nIGZhc3RlciBxdWVyaWVzIGZyb20gcHJvY2VlZGluZy4gU2VlIFtTbG93IFRyYWlucyBpbiBNb25nb0RCIGFuZCBOb2RlLmpzXShodHRwczovL3RoZWNvZGViYXJiYXJpYW4uY29tL3Nsb3ctdHJhaW5zLWluLW1vbmdvZGItYW5kLW5vZGVqcykuXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMubWluUG9vbFNpemU9MF0gVGhlIG1pbmltdW0gbnVtYmVyIG9mIHNvY2tldHMgdGhlIE1vbmdvREIgZHJpdmVyIHdpbGwga2VlcCBvcGVuIGZvciB0aGlzIGNvbm5lY3Rpb24uIEtlZXAgaW4gbWluZCB0aGF0IE1vbmdvREIgb25seSBhbGxvd3Mgb25lIG9wZXJhdGlvbiBwZXIgc29ja2V0IGF0IGEgdGltZSwgc28geW91IG1heSB3YW50IHRvIGluY3JlYXNlIHRoaXMgaWYgeW91IGZpbmQgeW91IGhhdmUgYSBmZXcgc2xvdyBxdWVyaWVzIHRoYXQgYXJlIGJsb2NraW5nIGZhc3RlciBxdWVyaWVzIGZyb20gcHJvY2VlZGluZy4gU2VlIFtTbG93IFRyYWlucyBpbiBNb25nb0RCIGFuZCBOb2RlLmpzXShodHRwczovL3RoZWNvZGViYXJiYXJpYW4uY29tL3Nsb3ctdHJhaW5zLWluLW1vbmdvZGItYW5kLW5vZGVqcykuXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuc2VydmVyU2VsZWN0aW9uVGltZW91dE1TXSBJZiBgdXNlVW5pZmllZFRvcG9sb2d5ID0gdHJ1ZWAsIHRoZSBNb25nb0RCIGRyaXZlciB3aWxsIHRyeSB0byBmaW5kIGEgc2VydmVyIHRvIHNlbmQgYW55IGdpdmVuIG9wZXJhdGlvbiB0bywgYW5kIGtlZXAgcmV0cnlpbmcgZm9yIGBzZXJ2ZXJTZWxlY3Rpb25UaW1lb3V0TVNgIG1pbGxpc2Vjb25kcyBiZWZvcmUgZXJyb3Jpbmcgb3V0LiBJZiBub3Qgc2V0LCB0aGUgTW9uZ29EQiBkcml2ZXIgZGVmYXVsdHMgdG8gdXNpbmcgYDMwMDAwYCAoMzAgc2Vjb25kcykuXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuaGVhcnRiZWF0RnJlcXVlbmN5TVNdIElmIGB1c2VVbmlmaWVkVG9wb2xvZ3kgPSB0cnVlYCwgdGhlIE1vbmdvREIgZHJpdmVyIHNlbmRzIGEgaGVhcnRiZWF0IGV2ZXJ5IGBoZWFydGJlYXRGcmVxdWVuY3lNU2AgdG8gY2hlY2sgb24gdGhlIHN0YXR1cyBvZiB0aGUgY29ubmVjdGlvbi4gQSBoZWFydGJlYXQgaXMgc3ViamVjdCB0byBgc2VydmVyU2VsZWN0aW9uVGltZW91dE1TYCwgc28gdGhlIE1vbmdvREIgZHJpdmVyIHdpbGwgcmV0cnkgZmFpbGVkIGhlYXJ0YmVhdHMgZm9yIHVwIHRvIDMwIHNlY29uZHMgYnkgZGVmYXVsdC4gTW9uZ29vc2Ugb25seSBlbWl0cyBhIGAnZGlzY29ubmVjdGVkJ2AgZXZlbnQgYWZ0ZXIgYSBoZWFydGJlYXQgaGFzIGZhaWxlZCwgc28geW91IG1heSB3YW50IHRvIGRlY3JlYXNlIHRoaXMgc2V0dGluZyB0byByZWR1Y2UgdGhlIHRpbWUgYmV0d2VlbiB3aGVuIHlvdXIgc2VydmVyIGdvZXMgZG93biBhbmQgd2hlbiBNb25nb29zZSBlbWl0cyBgJ2Rpc2Nvbm5lY3RlZCdgLiBXZSByZWNvbW1lbmQgeW91IGRvICoqbm90Kiogc2V0IHRoaXMgc2V0dGluZyBiZWxvdyAxMDAwLCB0b28gbWFueSBoZWFydGJlYXRzIGNhbiBsZWFkIHRvIHBlcmZvcm1hbmNlIGRlZ3JhZGF0aW9uLlxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5hdXRvSW5kZXg9dHJ1ZV0gTW9uZ29vc2Utc3BlY2lmaWMgb3B0aW9uLiBTZXQgdG8gZmFsc2UgdG8gZGlzYWJsZSBhdXRvbWF0aWMgaW5kZXggY3JlYXRpb24gZm9yIGFsbCBtb2RlbHMgYXNzb2NpYXRlZCB3aXRoIHRoaXMgY29ubmVjdGlvbi5cbiAqIEBwYXJhbSB7Q2xhc3N9IFtvcHRpb25zLnByb21pc2VMaWJyYXJ5XSBTZXRzIHRoZSBbdW5kZXJseWluZyBkcml2ZXIncyBwcm9taXNlIGxpYnJhcnldKGh0dHBzOi8vbW9uZ29kYi5naXRodWIuaW8vbm9kZS1tb25nb2RiLW5hdGl2ZS80LjkvaW50ZXJmYWNlcy9Nb25nb0NsaWVudE9wdGlvbnMuaHRtbCNwcm9taXNlTGlicmFyeSkuXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuc29ja2V0VGltZW91dE1TPTBdIEhvdyBsb25nIHRoZSBNb25nb0RCIGRyaXZlciB3aWxsIHdhaXQgYmVmb3JlIGtpbGxpbmcgYSBzb2NrZXQgZHVlIHRvIGluYWN0aXZpdHkgX2FmdGVyIGluaXRpYWwgY29ubmVjdGlvbl8uIEEgc29ja2V0IG1heSBiZSBpbmFjdGl2ZSBiZWNhdXNlIG9mIGVpdGhlciBubyBhY3Rpdml0eSBvciBhIGxvbmctcnVubmluZyBvcGVyYXRpb24uIGBzb2NrZXRUaW1lb3V0TVNgIGRlZmF1bHRzIHRvIDAsIHdoaWNoIG1lYW5zIE5vZGUuanMgd2lsbCBub3QgdGltZSBvdXQgdGhlIHNvY2tldCBkdWUgdG8gaW5hY3Rpdml0eS4gVGhpcyBvcHRpb24gaXMgcGFzc2VkIHRvIFtOb2RlLmpzIGBzb2NrZXQjc2V0VGltZW91dCgpYCBmdW5jdGlvbl0oaHR0cHM6Ly9ub2RlanMub3JnL2FwaS9uZXQuaHRtbCNuZXRfc29ja2V0X3NldHRpbWVvdXRfdGltZW91dF9jYWxsYmFjaykgYWZ0ZXIgdGhlIE1vbmdvREIgZHJpdmVyIHN1Y2Nlc3NmdWxseSBjb21wbGV0ZXMuXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuZmFtaWx5PTBdIFBhc3NlZCB0cmFuc3BhcmVudGx5IHRvIFtOb2RlLmpzJyBgZG5zLmxvb2t1cCgpYF0oaHR0cHM6Ly9ub2RlanMub3JnL2FwaS9kbnMuaHRtbCNkbnNfZG5zX2xvb2t1cF9ob3N0bmFtZV9vcHRpb25zX2NhbGxiYWNrKSBmdW5jdGlvbi4gTWF5IGJlIGVpdGhlciBgMCwgYDRgLCBvciBgNmAuIGA0YCBtZWFucyB1c2UgSVB2NCBvbmx5LCBgNmAgbWVhbnMgdXNlIElQdjYgb25seSwgYDBgIG1lYW5zIHRyeSBib3RoLlxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5hdXRvQ3JlYXRlPWZhbHNlXSBTZXQgdG8gYHRydWVgIHRvIG1ha2UgTW9uZ29vc2UgYXV0b21hdGljYWxseSBjYWxsIGBjcmVhdGVDb2xsZWN0aW9uKClgIG9uIGV2ZXJ5IG1vZGVsIGNyZWF0ZWQgb24gdGhpcyBjb25uZWN0aW9uLlxuICogQHJldHVybnMge1Byb21pc2U8Q29ubmVjdGlvbj59XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkNvbm5lY3Rpb24ucHJvdG90eXBlLm9wZW5VcmkgPSBhc3luYyBmdW5jdGlvbiBvcGVuVXJpKHVyaSwgb3B0aW9ucykge1xuICBpZiAodGhpcy5yZWFkeVN0YXRlID09PSBTVEFURVMuY29ubmVjdGluZyB8fCB0aGlzLnJlYWR5U3RhdGUgPT09IFNUQVRFUy5jb25uZWN0ZWQpIHtcbiAgICBpZiAodGhpcy5fY29ubmVjdGlvblN0cmluZyA9PT0gdXJpKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH1cblxuICB0aGlzLl9jbG9zZUNhbGxlZCA9IGZhbHNlO1xuXG4gIC8vIEludGVybmFsIG9wdGlvbiB0byBza2lwIGBhd2FpdCB0aGlzLiRpbml0aWFsQ29ubmVjdGlvbmAgaW5cbiAgLy8gdGhpcyBmdW5jdGlvbiBmb3IgYGNyZWF0ZUNvbm5lY3Rpb24oKWAuIEJlY2F1c2Ugb3RoZXJ3aXNlXG4gIC8vIGBjcmVhdGVDb25uZWN0aW9uKClgIHdvdWxkIGhhdmUgYW4gdW5jYXRjaGFibGUgZXJyb3IuXG4gIGxldCBfZmlyZUFuZEZvcmdldCA9IGZhbHNlO1xuICBpZiAob3B0aW9ucyAmJiAnX2ZpcmVBbmRGb3JnZXQnIGluIG9wdGlvbnMpIHtcbiAgICBfZmlyZUFuZEZvcmdldCA9IG9wdGlvbnMuX2ZpcmVBbmRGb3JnZXQ7XG4gICAgZGVsZXRlIG9wdGlvbnMuX2ZpcmVBbmRGb3JnZXQ7XG4gIH1cblxuICB0cnkge1xuICAgIF92YWxpZGF0ZUFyZ3MuYXBwbHkoYXJndW1lbnRzKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgaWYgKF9maXJlQW5kRm9yZ2V0KSB7XG4gICAgICB0aHJvdyBlcnI7XG4gICAgfVxuICAgIHRoaXMuJGluaXRpYWxDb25uZWN0aW9uID0gUHJvbWlzZS5yZWplY3QoZXJyKTtcbiAgICB0aHJvdyBlcnI7XG4gIH1cblxuICB0aGlzLiRpbml0aWFsQ29ubmVjdGlvbiA9IHRoaXMuY3JlYXRlQ2xpZW50KHVyaSwgb3B0aW9ucykuXG4gICAgdGhlbigoKSA9PiB0aGlzKS5cbiAgICBjYXRjaChlcnIgPT4ge1xuICAgICAgdGhpcy5yZWFkeVN0YXRlID0gU1RBVEVTLmRpc2Nvbm5lY3RlZDtcbiAgICAgIGlmICh0aGlzLmxpc3RlbmVycygnZXJyb3InKS5sZW5ndGggPiAwKSB7XG4gICAgICAgIGltbWVkaWF0ZSgoKSA9PiB0aGlzLmVtaXQoJ2Vycm9yJywgZXJyKSk7XG4gICAgICB9XG4gICAgICB0aHJvdyBlcnI7XG4gICAgfSk7XG5cbiAgZm9yIChjb25zdCBtb2RlbCBvZiBPYmplY3QudmFsdWVzKHRoaXMubW9kZWxzKSkge1xuICAgIC8vIEVycm9ycyBoYW5kbGVkIGludGVybmFsbHksIHNvIHNhZmUgdG8gaWdub3JlIGVycm9yXG4gICAgbW9kZWwuaW5pdCgpLmNhdGNoKGZ1bmN0aW9uICRtb2RlbEluaXROb29wKCkge30pO1xuICB9XG5cbiAgLy8gYGNyZWF0ZUNvbm5lY3Rpb24oKWAgY2FsbHMgdGhpcyBgb3BlblVyaSgpYCBmdW5jdGlvbiB3aXRob3V0XG4gIC8vIGF3YWl0aW5nIG9uIHRoZSByZXN1bHQsIHNvIHdlIHNldCB0aGlzIG9wdGlvbiB0byByZWx5IG9uXG4gIC8vIGBhc1Byb21pc2UoKWAgdG8gaGFuZGxlIGFueSBlcnJvcnMuXG4gIGlmIChfZmlyZUFuZEZvcmdldCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgdHJ5IHtcbiAgICBhd2FpdCB0aGlzLiRpbml0aWFsQ29ubmVjdGlvbjtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgdGhyb3cgX2hhbmRsZUNvbm5lY3Rpb25FcnJvcnMoZXJyKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5mdW5jdGlvbiBfdmFsaWRhdGVBcmdzKHVyaSwgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nICYmIGNhbGxiYWNrID09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgTW9uZ29vc2VFcnJvcignQ29ubmVjdGlvbi5wcm90b3R5cGUub3BlblVyaSgpIG5vIGxvbmdlciBhY2NlcHRzIGEgY2FsbGJhY2snKTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgTW9uZ29vc2VFcnJvcignQ29ubmVjdGlvbi5wcm90b3R5cGUub3BlblVyaSgpIG5vIGxvbmdlciBhY2NlcHRzIGEgY2FsbGJhY2snKTtcbiAgfVxufVxuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cbmZ1bmN0aW9uIF9oYW5kbGVDb25uZWN0aW9uRXJyb3JzKGVycikge1xuICBpZiAoZXJyPy5uYW1lID09PSAnTW9uZ29TZXJ2ZXJTZWxlY3Rpb25FcnJvcicpIHtcbiAgICBjb25zdCBvcmlnaW5hbEVycm9yID0gZXJyO1xuICAgIGVyciA9IG5ldyBTZXJ2ZXJTZWxlY3Rpb25FcnJvcigpO1xuICAgIGVyci5hc3NpbWlsYXRlRXJyb3Iob3JpZ2luYWxFcnJvcik7XG4gIH1cblxuICByZXR1cm4gZXJyO1xufVxuXG4vKipcbiAqIERlc3Ryb3kgdGhlIGNvbm5lY3Rpb24uIFNpbWlsYXIgdG8gW2AuY2xvc2VgXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvYXBpL2Nvbm5lY3Rpb24uaHRtbCNDb25uZWN0aW9uLnByb3RvdHlwZS5jbG9zZSgpKSxcbiAqIGJ1dCBhbHNvIHJlbW92ZXMgdGhlIGNvbm5lY3Rpb24gZnJvbSBNb25nb29zZSdzIGBjb25uZWN0aW9uc2AgbGlzdCBhbmQgcHJldmVudHMgdGhlXG4gKiBjb25uZWN0aW9uIGZyb20gZXZlciBiZWluZyByZS1vcGVuZWQuXG4gKlxuICogQHBhcmFtIHtCb29sZWFufSBbZm9yY2VdXG4gKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAqL1xuXG5Db25uZWN0aW9uLnByb3RvdHlwZS5kZXN0cm95ID0gYXN5bmMgZnVuY3Rpb24gZGVzdHJveShmb3JjZSkge1xuICBpZiAodHlwZW9mIGZvcmNlID09PSAnZnVuY3Rpb24nIHx8IChhcmd1bWVudHMubGVuZ3RoID09PSAyICYmIHR5cGVvZiBhcmd1bWVudHNbMV0gPT09ICdmdW5jdGlvbicpKSB7XG4gICAgdGhyb3cgbmV3IE1vbmdvb3NlRXJyb3IoJ0Nvbm5lY3Rpb24ucHJvdG90eXBlLmRlc3Ryb3koKSBubyBsb25nZXIgYWNjZXB0cyBhIGNhbGxiYWNrJyk7XG4gIH1cblxuICBpZiAoZm9yY2UgIT0gbnVsbCAmJiB0eXBlb2YgZm9yY2UgPT09ICdvYmplY3QnKSB7XG4gICAgdGhpcy4kd2FzRm9yY2VDbG9zZWQgPSAhIWZvcmNlLmZvcmNlO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuJHdhc0ZvcmNlQ2xvc2VkID0gISFmb3JjZTtcbiAgfVxuXG4gIHJldHVybiB0aGlzLl9jbG9zZShmb3JjZSwgdHJ1ZSk7XG59O1xuXG4vKipcbiAqIENsb3NlcyB0aGUgY29ubmVjdGlvblxuICpcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW2ZvcmNlXSBvcHRpb25hbFxuICogQHJldHVybiB7UHJvbWlzZX1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuQ29ubmVjdGlvbi5wcm90b3R5cGUuY2xvc2UgPSBhc3luYyBmdW5jdGlvbiBjbG9zZShmb3JjZSkge1xuICBpZiAodHlwZW9mIGZvcmNlID09PSAnZnVuY3Rpb24nIHx8IChhcmd1bWVudHMubGVuZ3RoID09PSAyICYmIHR5cGVvZiBhcmd1bWVudHNbMV0gPT09ICdmdW5jdGlvbicpKSB7XG4gICAgdGhyb3cgbmV3IE1vbmdvb3NlRXJyb3IoJ0Nvbm5lY3Rpb24ucHJvdG90eXBlLmNsb3NlKCkgbm8gbG9uZ2VyIGFjY2VwdHMgYSBjYWxsYmFjaycpO1xuICB9XG5cbiAgaWYgKGZvcmNlICE9IG51bGwgJiYgdHlwZW9mIGZvcmNlID09PSAnb2JqZWN0Jykge1xuICAgIHRoaXMuJHdhc0ZvcmNlQ2xvc2VkID0gISFmb3JjZS5mb3JjZTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLiR3YXNGb3JjZUNsb3NlZCA9ICEhZm9yY2U7XG4gIH1cblxuICBmb3IgKGNvbnN0IG1vZGVsIG9mIE9iamVjdC52YWx1ZXModGhpcy5tb2RlbHMpKSB7XG4gICAgLy8gSWYgbWFudWFsbHkgZGlzY29ubmVjdGluZywgbWFrZSBzdXJlIHRvIGNsZWFyIGVhY2ggbW9kZWwncyBgJGluaXRgXG4gICAgLy8gcHJvbWlzZSwgc28gTW9uZ29vc2Uga25vd3MgdG8gcmUtcnVuIGBpbml0KClgIGluIGNhc2UgdGhlXG4gICAgLy8gY29ubmVjdGlvbiBpcyByZS1vcGVuZWQuIFNlZSBnaC0xMjA0Ny5cbiAgICBkZWxldGUgbW9kZWwuJGluaXQ7XG4gIH1cblxuICByZXR1cm4gdGhpcy5fY2xvc2UoZm9yY2UsIGZhbHNlKTtcbn07XG5cbi8qKlxuICogSGFuZGxlcyBjbG9zaW5nIHRoZSBjb25uZWN0aW9uXG4gKlxuICogQHBhcmFtIHtCb29sZWFufSBmb3JjZVxuICogQHBhcmFtIHtCb29sZWFufSBkZXN0cm95XG4gKiBAcmV0dXJucyB7Q29ubmVjdGlvbn0gdGhpc1xuICogQGFwaSBwcml2YXRlXG4gKi9cbkNvbm5lY3Rpb24ucHJvdG90eXBlLl9jbG9zZSA9IGFzeW5jIGZ1bmN0aW9uIF9jbG9zZShmb3JjZSwgZGVzdHJveSkge1xuICBjb25zdCBfdGhpcyA9IHRoaXM7XG4gIGNvbnN0IGNsb3NlQ2FsbGVkID0gdGhpcy5fY2xvc2VDYWxsZWQ7XG4gIHRoaXMuX2Nsb3NlQ2FsbGVkID0gdHJ1ZTtcbiAgdGhpcy5fZGVzdHJveUNhbGxlZCA9IGRlc3Ryb3k7XG4gIGlmICh0aGlzLmNsaWVudCAhPSBudWxsKSB7XG4gICAgdGhpcy5jbGllbnQuX2Nsb3NlQ2FsbGVkID0gdHJ1ZTtcbiAgICB0aGlzLmNsaWVudC5fZGVzdHJveUNhbGxlZCA9IGRlc3Ryb3k7XG4gIH1cblxuICBjb25zdCBjb25uID0gdGhpcztcbiAgc3dpdGNoICh0aGlzLnJlYWR5U3RhdGUpIHtcbiAgICBjYXNlIFNUQVRFUy5kaXNjb25uZWN0ZWQ6XG4gICAgICBpZiAoZGVzdHJveSAmJiB0aGlzLmJhc2UuY29ubmVjdGlvbnMuaW5kZXhPZihjb25uKSAhPT0gLTEpIHtcbiAgICAgICAgdGhpcy5iYXNlLmNvbm5lY3Rpb25zLnNwbGljZSh0aGlzLmJhc2UuY29ubmVjdGlvbnMuaW5kZXhPZihjb25uKSwgMSk7XG4gICAgICB9XG4gICAgICBpZiAoIWNsb3NlQ2FsbGVkKSB7XG4gICAgICAgIGF3YWl0IHRoaXMuZG9DbG9zZShmb3JjZSk7XG4gICAgICAgIHRoaXMub25DbG9zZShmb3JjZSk7XG4gICAgICB9XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgU1RBVEVTLmNvbm5lY3RlZDpcbiAgICAgIHRoaXMucmVhZHlTdGF0ZSA9IFNUQVRFUy5kaXNjb25uZWN0aW5nO1xuICAgICAgYXdhaXQgdGhpcy5kb0Nsb3NlKGZvcmNlKTtcbiAgICAgIGlmIChkZXN0cm95ICYmIF90aGlzLmJhc2UuY29ubmVjdGlvbnMuaW5kZXhPZihjb25uKSAhPT0gLTEpIHtcbiAgICAgICAgdGhpcy5iYXNlLmNvbm5lY3Rpb25zLnNwbGljZSh0aGlzLmJhc2UuY29ubmVjdGlvbnMuaW5kZXhPZihjb25uKSwgMSk7XG4gICAgICB9XG4gICAgICB0aGlzLm9uQ2xvc2UoZm9yY2UpO1xuXG4gICAgICBicmVhaztcbiAgICBjYXNlIFNUQVRFUy5jb25uZWN0aW5nOlxuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgY29uc3QgX3JlcnVuQ2xvc2UgPSAoKSA9PiB7XG4gICAgICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcignb3BlbicsIF9yZXJ1bkNsb3NlKTtcbiAgICAgICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIF9yZXJ1bkNsb3NlKTtcbiAgICAgICAgICBpZiAoZGVzdHJveSkge1xuICAgICAgICAgICAgdGhpcy5kZXN0cm95KGZvcmNlKS50aGVuKHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY2xvc2UoZm9yY2UpLnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5vbmNlKCdvcGVuJywgX3JlcnVuQ2xvc2UpO1xuICAgICAgICB0aGlzLm9uY2UoJ2Vycm9yJywgX3JlcnVuQ2xvc2UpO1xuICAgICAgfSk7XG5cbiAgICBjYXNlIFNUQVRFUy5kaXNjb25uZWN0aW5nOlxuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgICB0aGlzLm9uY2UoJ2Nsb3NlJywgKCkgPT4ge1xuICAgICAgICAgIGlmIChkZXN0cm95ICYmIHRoaXMuYmFzZS5jb25uZWN0aW9ucy5pbmRleE9mKGNvbm4pICE9PSAtMSkge1xuICAgICAgICAgICAgdGhpcy5iYXNlLmNvbm5lY3Rpb25zLnNwbGljZSh0aGlzLmJhc2UuY29ubmVjdGlvbnMuaW5kZXhPZihjb25uKSwgMSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBBYnN0cmFjdCBtZXRob2QgdGhhdCBkcml2ZXJzIG11c3QgaW1wbGVtZW50LlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbkNvbm5lY3Rpb24ucHJvdG90eXBlLmRvQ2xvc2UgPSBmdW5jdGlvbigpIHtcbiAgdGhyb3cgbmV3IEVycm9yKCdDb25uZWN0aW9uI2RvQ2xvc2UgdW5pbXBsZW1lbnRlZCBieSBkcml2ZXInKTtcbn07XG5cbi8qKlxuICogQ2FsbGVkIHdoZW4gdGhlIGNvbm5lY3Rpb24gY2xvc2VzXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuQ29ubmVjdGlvbi5wcm90b3R5cGUub25DbG9zZSA9IGZ1bmN0aW9uKGZvcmNlKSB7XG4gIHRoaXMucmVhZHlTdGF0ZSA9IFNUQVRFUy5kaXNjb25uZWN0ZWQ7XG5cbiAgLy8gYXZvaWQgaGF2aW5nIHRoZSBjb2xsZWN0aW9uIHN1YnNjcmliZSB0byBvdXIgZXZlbnQgZW1pdHRlclxuICAvLyB0byBwcmV2ZW50IDAuMyB3YXJuaW5nXG4gIGZvciAoY29uc3QgaSBpbiB0aGlzLmNvbGxlY3Rpb25zKSB7XG4gICAgaWYgKHV0aWxzLm9iamVjdC5oYXNPd25Qcm9wZXJ0eSh0aGlzLmNvbGxlY3Rpb25zLCBpKSkge1xuICAgICAgdGhpcy5jb2xsZWN0aW9uc1tpXS5vbkNsb3NlKGZvcmNlKTtcbiAgICB9XG4gIH1cblxuICB0aGlzLmVtaXQoJ2Nsb3NlJywgZm9yY2UpO1xuXG4gIGZvciAoY29uc3QgZGIgb2YgdGhpcy5vdGhlckRicykge1xuICAgIHRoaXMuX2Rlc3Ryb3lDYWxsZWQgPyBkYi5kZXN0cm95KHsgZm9yY2U6IGZvcmNlLCBza2lwQ2xvc2VDbGllbnQ6IHRydWUgfSkgOiBkYi5jbG9zZSh7IGZvcmNlOiBmb3JjZSwgc2tpcENsb3NlQ2xpZW50OiB0cnVlIH0pO1xuICB9XG59O1xuXG4vKipcbiAqIFJldHJpZXZlcyBhIHJhdyBjb2xsZWN0aW9uIGluc3RhbmNlLCBjcmVhdGluZyBpdCBpZiBub3QgY2FjaGVkLlxuICogVGhpcyBtZXRob2QgcmV0dXJucyBhIHRoaW4gd3JhcHBlciBhcm91bmQgYSBbTW9uZ29EQiBOb2RlLmpzIGRyaXZlciBjb2xsZWN0aW9uXShbTW9uZ29EQiBOb2RlLmpzIGRyaXZlciBjb2xsZWN0aW9uXShodHRwczovL21vbmdvZGIuZ2l0aHViLmlvL25vZGUtbW9uZ29kYi1uYXRpdmUvTmV4dC9jbGFzc2VzL0NvbGxlY3Rpb24uaHRtbCkpLlxuICogVXNpbmcgYSBDb2xsZWN0aW9uIGJ5cGFzc2VzIE1vbmdvb3NlIG1pZGRsZXdhcmUsIHZhbGlkYXRpb24sIGFuZCBjYXN0aW5nLFxuICogbGV0dGluZyB5b3UgdXNlIFtNb25nb0RCIE5vZGUuanMgZHJpdmVyXShodHRwczovL21vbmdvZGIuZ2l0aHViLmlvL25vZGUtbW9uZ29kYi1uYXRpdmUvKSBmdW5jdGlvbmFsaXR5IGRpcmVjdGx5LlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIG9mIHRoZSBjb2xsZWN0aW9uXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIG9wdGlvbmFsIGNvbGxlY3Rpb24gb3B0aW9uc1xuICogQHJldHVybiB7Q29sbGVjdGlvbn0gY29sbGVjdGlvbiBpbnN0YW5jZVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Db25uZWN0aW9uLnByb3RvdHlwZS5jb2xsZWN0aW9uID0gZnVuY3Rpb24obmFtZSwgb3B0aW9ucykge1xuICBjb25zdCBkZWZhdWx0T3B0aW9ucyA9IHtcbiAgICBhdXRvSW5kZXg6IHRoaXMuY29uZmlnLmF1dG9JbmRleCAhPSBudWxsID8gdGhpcy5jb25maWcuYXV0b0luZGV4IDogdGhpcy5iYXNlLm9wdGlvbnMuYXV0b0luZGV4LFxuICAgIGF1dG9DcmVhdGU6IHRoaXMuY29uZmlnLmF1dG9DcmVhdGUgIT0gbnVsbCA/IHRoaXMuY29uZmlnLmF1dG9DcmVhdGUgOiB0aGlzLmJhc2Uub3B0aW9ucy5hdXRvQ3JlYXRlLFxuICAgIGF1dG9TZWFyY2hJbmRleDogdGhpcy5jb25maWcuYXV0b1NlYXJjaEluZGV4ICE9IG51bGwgPyB0aGlzLmNvbmZpZy5hdXRvU2VhcmNoSW5kZXggOiB0aGlzLmJhc2Uub3B0aW9ucy5hdXRvU2VhcmNoSW5kZXhcbiAgfTtcbiAgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRPcHRpb25zLCBvcHRpb25zID8gY2xvbmUob3B0aW9ucykgOiB7fSk7XG4gIG9wdGlvbnMuJHdhc0ZvcmNlQ2xvc2VkID0gdGhpcy4kd2FzRm9yY2VDbG9zZWQ7XG4gIGNvbnN0IENvbGxlY3Rpb24gPSB0aGlzLmJhc2UgJiYgdGhpcy5iYXNlLl9fZHJpdmVyICYmIHRoaXMuYmFzZS5fX2RyaXZlci5Db2xsZWN0aW9uIHx8IGRyaXZlci5nZXQoKS5Db2xsZWN0aW9uO1xuICBpZiAoIShuYW1lIGluIHRoaXMuY29sbGVjdGlvbnMpKSB7XG4gICAgdGhpcy5jb2xsZWN0aW9uc1tuYW1lXSA9IG5ldyBDb2xsZWN0aW9uKG5hbWUsIHRoaXMsIG9wdGlvbnMpO1xuICB9XG4gIHJldHVybiB0aGlzLmNvbGxlY3Rpb25zW25hbWVdO1xufTtcblxuLyoqXG4gKiBEZWNsYXJlcyBhIHBsdWdpbiBleGVjdXRlZCBvbiBhbGwgc2NoZW1hcyB5b3UgcGFzcyB0byBgY29ubi5tb2RlbCgpYFxuICpcbiAqIEVxdWl2YWxlbnQgdG8gY2FsbGluZyBgLnBsdWdpbihmbilgIG9uIGVhY2ggc2NoZW1hIHlvdSBjcmVhdGUuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBjb25zdCBkYiA9IG1vbmdvb3NlLmNyZWF0ZUNvbm5lY3Rpb24oJ21vbmdvZGI6Ly8xMjcuMC4wLjE6MjcwMTcvbXlkYicpO1xuICogICAgIGRiLnBsdWdpbigoKSA9PiBjb25zb2xlLmxvZygnQXBwbGllZCcpKTtcbiAqICAgICBkYi5wbHVnaW5zLmxlbmd0aDsgLy8gMVxuICpcbiAqICAgICBkYi5tb2RlbCgnVGVzdCcsIG5ldyBTY2hlbWEoe30pKTsgLy8gUHJpbnRzIFwiQXBwbGllZFwiXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gcGx1Z2luIGNhbGxiYWNrXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdHNdIG9wdGlvbmFsIG9wdGlvbnNcbiAqIEByZXR1cm4ge0Nvbm5lY3Rpb259IHRoaXNcbiAqIEBzZWUgcGx1Z2lucyBodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvcGx1Z2lucy5odG1sXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkNvbm5lY3Rpb24ucHJvdG90eXBlLnBsdWdpbiA9IGZ1bmN0aW9uKGZuLCBvcHRzKSB7XG4gIHRoaXMucGx1Z2lucy5wdXNoKFtmbiwgb3B0c10pO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogRGVmaW5lcyBvciByZXRyaWV2ZXMgYSBtb2RlbC5cbiAqXG4gKiAgICAgY29uc3QgbW9uZ29vc2UgPSByZXF1aXJlKCdtb25nb29zZScpO1xuICogICAgIGNvbnN0IGRiID0gbW9uZ29vc2UuY3JlYXRlQ29ubmVjdGlvbiguLik7XG4gKiAgICAgZGIubW9kZWwoJ1ZlbnVlJywgbmV3IFNjaGVtYSguLikpO1xuICogICAgIGNvbnN0IFRpY2tldCA9IGRiLm1vZGVsKCdUaWNrZXQnLCBuZXcgU2NoZW1hKC4uKSk7XG4gKiAgICAgY29uc3QgVmVudWUgPSBkYi5tb2RlbCgnVmVudWUnKTtcbiAqXG4gKiBfV2hlbiBubyBgY29sbGVjdGlvbmAgYXJndW1lbnQgaXMgcGFzc2VkLCBNb25nb29zZSBwcm9kdWNlcyBhIGNvbGxlY3Rpb24gbmFtZSBieSBwYXNzaW5nIHRoZSBtb2RlbCBgbmFtZWAgdG8gdGhlIGB1dGlscy50b0NvbGxlY3Rpb25OYW1lYCBtZXRob2QuIFRoaXMgbWV0aG9kIHBsdXJhbGl6ZXMgdGhlIG5hbWUuIElmIHlvdSBkb24ndCBsaWtlIHRoaXMgYmVoYXZpb3IsIGVpdGhlciBwYXNzIGEgY29sbGVjdGlvbiBuYW1lIG9yIHNldCB5b3VyIHNjaGVtYXMgY29sbGVjdGlvbiBuYW1lIG9wdGlvbi5fXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBjb25zdCBzY2hlbWEgPSBuZXcgU2NoZW1hKHsgbmFtZTogU3RyaW5nIH0sIHsgY29sbGVjdGlvbjogJ2FjdG9yJyB9KTtcbiAqXG4gKiAgICAgLy8gb3JcbiAqXG4gKiAgICAgc2NoZW1hLnNldCgnY29sbGVjdGlvbicsICdhY3RvcicpO1xuICpcbiAqICAgICAvLyBvclxuICpcbiAqICAgICBjb25zdCBjb2xsZWN0aW9uTmFtZSA9ICdhY3RvcidcbiAqICAgICBjb25zdCBNID0gY29ubi5tb2RlbCgnQWN0b3InLCBzY2hlbWEsIGNvbGxlY3Rpb25OYW1lKVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfEZ1bmN0aW9ufSBuYW1lIHRoZSBtb2RlbCBuYW1lIG9yIGNsYXNzIGV4dGVuZGluZyBNb2RlbFxuICogQHBhcmFtIHtTY2hlbWF9IFtzY2hlbWFdIGEgc2NoZW1hLiBuZWNlc3Nhcnkgd2hlbiBkZWZpbmluZyBhIG1vZGVsXG4gKiBAcGFyYW0ge1N0cmluZ30gW2NvbGxlY3Rpb25dIG5hbWUgb2YgbW9uZ29kYiBjb2xsZWN0aW9uIChvcHRpb25hbCkgaWYgbm90IGdpdmVuIGl0IHdpbGwgYmUgaW5kdWNlZCBmcm9tIG1vZGVsIG5hbWVcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMub3ZlcndyaXRlTW9kZWxzPWZhbHNlXSBJZiB0cnVlLCBvdmVyd3JpdGUgZXhpc3RpbmcgbW9kZWxzIHdpdGggdGhlIHNhbWUgbmFtZSB0byBhdm9pZCBgT3ZlcndyaXRlTW9kZWxFcnJvcmBcbiAqIEBzZWUgTW9uZ29vc2UjbW9kZWwgaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2FwaS9tb25nb29zZS5odG1sI01vbmdvb3NlLnByb3RvdHlwZS5tb2RlbCgpXG4gKiBAcmV0dXJuIHtNb2RlbH0gVGhlIGNvbXBpbGVkIG1vZGVsXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkNvbm5lY3Rpb24ucHJvdG90eXBlLm1vZGVsID0gZnVuY3Rpb24obmFtZSwgc2NoZW1hLCBjb2xsZWN0aW9uLCBvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBDb25uZWN0aW9uKSkge1xuICAgIHRocm93IG5ldyBNb25nb29zZUVycm9yKCdgY29ubmVjdGlvbi5tb2RlbCgpYCBzaG91bGQgbm90IGJlIHJ1biB3aXRoICcgK1xuICAgICAgJ2BuZXdgLiBJZiB5b3UgYXJlIGRvaW5nIGBuZXcgZGIubW9kZWwoZm9vKShiYXIpYCwgdXNlICcgK1xuICAgICAgJ2BkYi5tb2RlbChmb28pKGJhcilgIGluc3RlYWQnKTtcbiAgfVxuXG4gIGxldCBmbjtcbiAgaWYgKHR5cGVvZiBuYW1lID09PSAnZnVuY3Rpb24nKSB7XG4gICAgZm4gPSBuYW1lO1xuICAgIG5hbWUgPSBmbi5uYW1lO1xuICB9XG5cbiAgLy8gY29sbGVjdGlvbiBuYW1lIGRpc2NvdmVyeVxuICBpZiAodHlwZW9mIHNjaGVtYSA9PT0gJ3N0cmluZycpIHtcbiAgICBjb2xsZWN0aW9uID0gc2NoZW1hO1xuICAgIHNjaGVtYSA9IGZhbHNlO1xuICB9XG5cbiAgaWYgKHV0aWxzLmlzT2JqZWN0KHNjaGVtYSkpIHtcbiAgICBpZiAoIXNjaGVtYS5pbnN0YW5jZU9mU2NoZW1hKSB7XG4gICAgICBzY2hlbWEgPSBuZXcgU2NoZW1hKHNjaGVtYSk7XG4gICAgfSBlbHNlIGlmICghKHNjaGVtYSBpbnN0YW5jZW9mIHRoaXMuYmFzZS5TY2hlbWEpKSB7XG4gICAgICBzY2hlbWEgPSBzY2hlbWEuX2Nsb25lKHRoaXMuYmFzZS5TY2hlbWEpO1xuICAgIH1cbiAgfVxuICBpZiAoc2NoZW1hICYmICFzY2hlbWEuaW5zdGFuY2VPZlNjaGVtYSkge1xuICAgIHRocm93IG5ldyBFcnJvcignVGhlIDJuZCBwYXJhbWV0ZXIgdG8gYG1vbmdvb3NlLm1vZGVsKClgIHNob3VsZCBiZSBhICcgK1xuICAgICAgJ3NjaGVtYSBvciBhIFBPSk8nKTtcbiAgfVxuXG4gIGNvbnN0IGRlZmF1bHRPcHRpb25zID0geyBjYWNoZTogZmFsc2UsIG92ZXJ3cml0ZU1vZGVsczogdGhpcy5iYXNlLm9wdGlvbnMub3ZlcndyaXRlTW9kZWxzIH07XG4gIGNvbnN0IG9wdHMgPSBPYmplY3QuYXNzaWduKGRlZmF1bHRPcHRpb25zLCBvcHRpb25zLCB7IGNvbm5lY3Rpb246IHRoaXMgfSk7XG4gIGlmICh0aGlzLm1vZGVsc1tuYW1lXSAmJiAhY29sbGVjdGlvbiAmJiBvcHRzLm92ZXJ3cml0ZU1vZGVscyAhPT0gdHJ1ZSkge1xuICAgIC8vIG1vZGVsIGV4aXN0cyBidXQgd2UgYXJlIG5vdCBzdWJjbGFzc2luZyB3aXRoIGN1c3RvbSBjb2xsZWN0aW9uXG4gICAgaWYgKHNjaGVtYSAmJiBzY2hlbWEuaW5zdGFuY2VPZlNjaGVtYSAmJiBzY2hlbWEgIT09IHRoaXMubW9kZWxzW25hbWVdLnNjaGVtYSkge1xuICAgICAgdGhyb3cgbmV3IE1vbmdvb3NlRXJyb3IuT3ZlcndyaXRlTW9kZWxFcnJvcihuYW1lKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMubW9kZWxzW25hbWVdO1xuICB9XG5cbiAgbGV0IG1vZGVsO1xuXG4gIGlmIChzY2hlbWEgJiYgc2NoZW1hLmluc3RhbmNlT2ZTY2hlbWEpIHtcbiAgICBhcHBseVBsdWdpbnMoc2NoZW1hLCB0aGlzLnBsdWdpbnMsIG51bGwsICckY29ubmVjdGlvblBsdWdpbnNBcHBsaWVkJyk7XG5cbiAgICAvLyBjb21waWxlIGEgbW9kZWxcbiAgICBtb2RlbCA9IHRoaXMuYmFzZS5fbW9kZWwoZm4gfHwgbmFtZSwgc2NoZW1hLCBjb2xsZWN0aW9uLCBvcHRzKTtcblxuICAgIC8vIG9ubHkgdGhlIGZpcnN0IG1vZGVsIHdpdGggdGhpcyBuYW1lIGlzIGNhY2hlZCB0byBhbGxvd1xuICAgIC8vIGZvciBvbmUtb2ZmcyB3aXRoIGN1c3RvbSBjb2xsZWN0aW9uIG5hbWVzIGV0Yy5cbiAgICBpZiAoIXRoaXMubW9kZWxzW25hbWVdKSB7XG4gICAgICB0aGlzLm1vZGVsc1tuYW1lXSA9IG1vZGVsO1xuICAgIH1cblxuICAgIC8vIEVycm9ycyBoYW5kbGVkIGludGVybmFsbHksIHNvIHNhZmUgdG8gaWdub3JlIGVycm9yXG4gICAgbW9kZWwuaW5pdCgpLmNhdGNoKGZ1bmN0aW9uICRtb2RlbEluaXROb29wKCkge30pO1xuXG4gICAgcmV0dXJuIG1vZGVsO1xuICB9XG5cbiAgaWYgKHRoaXMubW9kZWxzW25hbWVdICYmIGNvbGxlY3Rpb24pIHtcbiAgICAvLyBzdWJjbGFzc2luZyBjdXJyZW50IG1vZGVsIHdpdGggYWx0ZXJuYXRlIGNvbGxlY3Rpb25cbiAgICBtb2RlbCA9IHRoaXMubW9kZWxzW25hbWVdO1xuICAgIHNjaGVtYSA9IG1vZGVsLnByb3RvdHlwZS5zY2hlbWE7XG4gICAgY29uc3Qgc3ViID0gbW9kZWwuX19zdWJjbGFzcyh0aGlzLCBzY2hlbWEsIGNvbGxlY3Rpb24pO1xuICAgIC8vIGRvIG5vdCBjYWNoZSB0aGUgc3ViIG1vZGVsXG4gICAgcmV0dXJuIHN1YjtcbiAgfVxuXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgbW9kZWwgPSB0aGlzLm1vZGVsc1tuYW1lXTtcbiAgICBpZiAoIW1vZGVsKSB7XG4gICAgICB0aHJvdyBuZXcgTW9uZ29vc2VFcnJvci5NaXNzaW5nU2NoZW1hRXJyb3IobmFtZSk7XG4gICAgfVxuICAgIHJldHVybiBtb2RlbDtcbiAgfVxuXG4gIGlmICghbW9kZWwpIHtcbiAgICB0aHJvdyBuZXcgTW9uZ29vc2VFcnJvci5NaXNzaW5nU2NoZW1hRXJyb3IobmFtZSk7XG4gIH1cblxuICBpZiAodGhpcyA9PT0gbW9kZWwucHJvdG90eXBlLmRiXG4gICAgICAmJiAoIWNvbGxlY3Rpb24gfHwgY29sbGVjdGlvbiA9PT0gbW9kZWwuY29sbGVjdGlvbi5uYW1lKSkge1xuICAgIC8vIG1vZGVsIGFscmVhZHkgdXNlcyB0aGlzIGNvbm5lY3Rpb24uXG5cbiAgICAvLyBvbmx5IHRoZSBmaXJzdCBtb2RlbCB3aXRoIHRoaXMgbmFtZSBpcyBjYWNoZWQgdG8gYWxsb3dcbiAgICAvLyBmb3Igb25lLW9mZnMgd2l0aCBjdXN0b20gY29sbGVjdGlvbiBuYW1lcyBldGMuXG4gICAgaWYgKCF0aGlzLm1vZGVsc1tuYW1lXSkge1xuICAgICAgdGhpcy5tb2RlbHNbbmFtZV0gPSBtb2RlbDtcbiAgICB9XG5cbiAgICByZXR1cm4gbW9kZWw7XG4gIH1cbiAgdGhpcy5tb2RlbHNbbmFtZV0gPSBtb2RlbC5fX3N1YmNsYXNzKHRoaXMsIHNjaGVtYSwgY29sbGVjdGlvbik7XG4gIHJldHVybiB0aGlzLm1vZGVsc1tuYW1lXTtcbn07XG5cbi8qKlxuICogUmVtb3ZlcyB0aGUgbW9kZWwgbmFtZWQgYG5hbWVgIGZyb20gdGhpcyBjb25uZWN0aW9uLCBpZiBpdCBleGlzdHMuIFlvdSBjYW5cbiAqIHVzZSB0aGlzIGZ1bmN0aW9uIHRvIGNsZWFuIHVwIGFueSBtb2RlbHMgeW91IGNyZWF0ZWQgaW4geW91ciB0ZXN0cyB0b1xuICogcHJldmVudCBPdmVyd3JpdGVNb2RlbEVycm9ycy5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbm4ubW9kZWwoJ1VzZXInLCBuZXcgU2NoZW1hKHsgbmFtZTogU3RyaW5nIH0pKTtcbiAqICAgICBjb25zb2xlLmxvZyhjb25uLm1vZGVsKCdVc2VyJykpOyAvLyBNb2RlbCBvYmplY3RcbiAqICAgICBjb25uLmRlbGV0ZU1vZGVsKCdVc2VyJyk7XG4gKiAgICAgY29uc29sZS5sb2coY29ubi5tb2RlbCgnVXNlcicpKTsgLy8gdW5kZWZpbmVkXG4gKlxuICogICAgIC8vIFVzdWFsbHkgdXNlZnVsIGluIGEgTW9jaGEgYGFmdGVyRWFjaCgpYCBob29rXG4gKiAgICAgYWZ0ZXJFYWNoKGZ1bmN0aW9uKCkge1xuICogICAgICAgY29ubi5kZWxldGVNb2RlbCgvLisvKTsgLy8gRGVsZXRlIGV2ZXJ5IG1vZGVsXG4gKiAgICAgfSk7XG4gKlxuICogQGFwaSBwdWJsaWNcbiAqIEBwYXJhbSB7U3RyaW5nfFJlZ0V4cH0gbmFtZSBpZiBzdHJpbmcsIHRoZSBuYW1lIG9mIHRoZSBtb2RlbCB0byByZW1vdmUuIElmIHJlZ2V4cCwgcmVtb3ZlcyBhbGwgbW9kZWxzIHdob3NlIG5hbWUgbWF0Y2hlcyB0aGUgcmVnZXhwLlxuICogQHJldHVybiB7Q29ubmVjdGlvbn0gdGhpc1xuICovXG5cbkNvbm5lY3Rpb24ucHJvdG90eXBlLmRlbGV0ZU1vZGVsID0gZnVuY3Rpb24obmFtZSkge1xuICBpZiAodHlwZW9mIG5hbWUgPT09ICdzdHJpbmcnKSB7XG4gICAgY29uc3QgbW9kZWwgPSB0aGlzLm1vZGVsKG5hbWUpO1xuICAgIGlmIChtb2RlbCA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgY29uc3QgY29sbGVjdGlvbk5hbWUgPSBtb2RlbC5jb2xsZWN0aW9uLm5hbWU7XG4gICAgZGVsZXRlIHRoaXMubW9kZWxzW25hbWVdO1xuICAgIGRlbGV0ZSB0aGlzLmNvbGxlY3Rpb25zW2NvbGxlY3Rpb25OYW1lXTtcblxuICAgIHRoaXMuZW1pdCgnZGVsZXRlTW9kZWwnLCBtb2RlbCk7XG4gIH0gZWxzZSBpZiAobmFtZSBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgIGNvbnN0IHBhdHRlcm4gPSBuYW1lO1xuICAgIGNvbnN0IG5hbWVzID0gdGhpcy5tb2RlbE5hbWVzKCk7XG4gICAgZm9yIChjb25zdCBuYW1lIG9mIG5hbWVzKSB7XG4gICAgICBpZiAocGF0dGVybi50ZXN0KG5hbWUpKSB7XG4gICAgICAgIHRoaXMuZGVsZXRlTW9kZWwobmFtZSk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcignRmlyc3QgcGFyYW1ldGVyIHRvIGBkZWxldGVNb2RlbCgpYCBtdXN0IGJlIGEgc3RyaW5nICcgK1xuICAgICAgJ29yIHJlZ2V4cCwgZ290IFwiJyArIG5hbWUgKyAnXCInKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBXYXRjaGVzIHRoZSBlbnRpcmUgdW5kZXJseWluZyBkYXRhYmFzZSBmb3IgY2hhbmdlcy4gU2ltaWxhciB0b1xuICogW2BNb2RlbC53YXRjaCgpYF0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2FwaS9tb2RlbC5odG1sI01vZGVsLndhdGNoKCkpLlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gZG9lcyAqKm5vdCoqIHRyaWdnZXIgYW55IG1pZGRsZXdhcmUuIEluIHBhcnRpY3VsYXIsIGl0XG4gKiBkb2VzICoqbm90KiogdHJpZ2dlciBhZ2dyZWdhdGUgbWlkZGxld2FyZS5cbiAqXG4gKiBUaGUgQ2hhbmdlU3RyZWFtIG9iamVjdCBpcyBhbiBldmVudCBlbWl0dGVyIHRoYXQgZW1pdHMgdGhlIGZvbGxvd2luZyBldmVudHM6XG4gKlxuICogLSAnY2hhbmdlJzogQSBjaGFuZ2Ugb2NjdXJyZWQsIHNlZSBiZWxvdyBleGFtcGxlXG4gKiAtICdlcnJvcic6IEFuIHVucmVjb3ZlcmFibGUgZXJyb3Igb2NjdXJyZWQuIEluIHBhcnRpY3VsYXIsIGNoYW5nZSBzdHJlYW1zIGN1cnJlbnRseSBlcnJvciBvdXQgaWYgdGhleSBsb3NlIGNvbm5lY3Rpb24gdG8gdGhlIHJlcGxpY2Egc2V0IHByaW1hcnkuIEZvbGxvdyBbdGhpcyBHaXRIdWIgaXNzdWVdKGh0dHBzOi8vZ2l0aHViLmNvbS9BdXRvbWF0dGljL21vbmdvb3NlL2lzc3Vlcy82Nzk5KSBmb3IgdXBkYXRlcy5cbiAqIC0gJ2VuZCc6IEVtaXR0ZWQgaWYgdGhlIHVuZGVybHlpbmcgc3RyZWFtIGlzIGNsb3NlZFxuICogLSAnY2xvc2UnOiBFbWl0dGVkIGlmIHRoZSB1bmRlcmx5aW5nIHN0cmVhbSBpcyBjbG9zZWRcbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IFVzZXIgPSBjb25uLm1vZGVsKCdVc2VyJywgbmV3IFNjaGVtYSh7IG5hbWU6IFN0cmluZyB9KSk7XG4gKlxuICogICAgIGNvbnN0IGNoYW5nZVN0cmVhbSA9IGNvbm4ud2F0Y2goKS5vbignY2hhbmdlJywgZGF0YSA9PiBjb25zb2xlLmxvZyhkYXRhKSk7XG4gKlxuICogICAgIC8vIFRyaWdnZXJzIGEgJ2NoYW5nZScgZXZlbnQgb24gdGhlIGNoYW5nZSBzdHJlYW0uXG4gKiAgICAgYXdhaXQgVXNlci5jcmVhdGUoeyBuYW1lOiAndGVzdCcgfSk7XG4gKlxuICogQGFwaSBwdWJsaWNcbiAqIEBwYXJhbSB7QXJyYXl9IFtwaXBlbGluZV1cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gcGFzc2VkIHdpdGhvdXQgY2hhbmdlcyB0byBbdGhlIE1vbmdvREIgZHJpdmVyJ3MgYERiI3dhdGNoKClgIGZ1bmN0aW9uXShodHRwczovL21vbmdvZGIuZ2l0aHViLmlvL25vZGUtbW9uZ29kYi1uYXRpdmUvNC45L2NsYXNzZXMvRGIuaHRtbCN3YXRjaClcbiAqIEByZXR1cm4ge0NoYW5nZVN0cmVhbX0gbW9uZ29vc2Utc3BlY2lmaWMgY2hhbmdlIHN0cmVhbSB3cmFwcGVyLCBpbmhlcml0cyBmcm9tIEV2ZW50RW1pdHRlclxuICovXG5cbkNvbm5lY3Rpb24ucHJvdG90eXBlLndhdGNoID0gZnVuY3Rpb24ocGlwZWxpbmUsIG9wdGlvbnMpIHtcbiAgY29uc3QgY2hhbmdlU3RyZWFtVGh1bmsgPSBjYiA9PiB7XG4gICAgaW1tZWRpYXRlKCgpID0+IHtcbiAgICAgIGlmICh0aGlzLnJlYWR5U3RhdGUgPT09IFNUQVRFUy5jb25uZWN0aW5nKSB7XG4gICAgICAgIHRoaXMub25jZSgnb3BlbicsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGNvbnN0IGRyaXZlckNoYW5nZVN0cmVhbSA9IHRoaXMuZGIud2F0Y2gocGlwZWxpbmUsIG9wdGlvbnMpO1xuICAgICAgICAgIGNiKG51bGwsIGRyaXZlckNoYW5nZVN0cmVhbSk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgZHJpdmVyQ2hhbmdlU3RyZWFtID0gdGhpcy5kYi53YXRjaChwaXBlbGluZSwgb3B0aW9ucyk7XG4gICAgICAgIGNiKG51bGwsIGRyaXZlckNoYW5nZVN0cmVhbSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgY29uc3QgY2hhbmdlU3RyZWFtID0gbmV3IENoYW5nZVN0cmVhbShjaGFuZ2VTdHJlYW1UaHVuaywgcGlwZWxpbmUsIG9wdGlvbnMpO1xuICByZXR1cm4gY2hhbmdlU3RyZWFtO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIGEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHdoZW4gdGhpcyBjb25uZWN0aW9uXG4gKiBzdWNjZXNzZnVsbHkgY29ubmVjdHMgdG8gTW9uZ29EQiwgb3IgcmVqZWN0cyBpZiB0aGlzIGNvbm5lY3Rpb24gZmFpbGVkXG4gKiB0byBjb25uZWN0LlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgY29uc3QgY29ubiA9IGF3YWl0IG1vbmdvb3NlLmNyZWF0ZUNvbm5lY3Rpb24oJ21vbmdvZGI6Ly8xMjcuMC4wLjE6MjcwMTcvdGVzdCcpLlxuICogICAgICAgYXNQcm9taXNlKCk7XG4gKiAgICAgY29ubi5yZWFkeVN0YXRlOyAvLyAxLCBtZWFucyBNb25nb29zZSBpcyBjb25uZWN0ZWRcbiAqXG4gKiBAYXBpIHB1YmxpY1xuICogQHJldHVybiB7UHJvbWlzZX1cbiAqL1xuXG5Db25uZWN0aW9uLnByb3RvdHlwZS5hc1Byb21pc2UgPSBhc3luYyBmdW5jdGlvbiBhc1Byb21pc2UoKSB7XG4gIHRyeSB7XG4gICAgYXdhaXQgdGhpcy4kaW5pdGlhbENvbm5lY3Rpb247XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHRocm93IF9oYW5kbGVDb25uZWN0aW9uRXJyb3JzKGVycik7XG4gIH1cbn07XG5cbi8qKlxuICogUmV0dXJucyBhbiBhcnJheSBvZiBtb2RlbCBuYW1lcyBjcmVhdGVkIG9uIHRoaXMgY29ubmVjdGlvbi5cbiAqIEBhcGkgcHVibGljXG4gKiBAcmV0dXJuIHtTdHJpbmdbXX1cbiAqL1xuXG5Db25uZWN0aW9uLnByb3RvdHlwZS5tb2RlbE5hbWVzID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBPYmplY3Qua2V5cyh0aGlzLm1vZGVscyk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgaWYgdGhlIGNvbm5lY3Rpb24gcmVxdWlyZXMgYXV0aGVudGljYXRpb24gYWZ0ZXIgaXQgaXMgb3BlbmVkLiBHZW5lcmFsbHkgaWYgYVxuICogdXNlcm5hbWUgYW5kIHBhc3N3b3JkIGFyZSBib3RoIHByb3ZpZGVkIHRoYW4gYXV0aGVudGljYXRpb24gaXMgbmVlZGVkLCBidXQgaW4gc29tZSBjYXNlcyBhXG4gKiBwYXNzd29yZCBpcyBub3QgcmVxdWlyZWQuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKiBAcmV0dXJuIHtCb29sZWFufSB0cnVlIGlmIHRoZSBjb25uZWN0aW9uIHNob3VsZCBiZSBhdXRoZW50aWNhdGVkIGFmdGVyIGl0IGlzIG9wZW5lZCwgb3RoZXJ3aXNlIGZhbHNlLlxuICovXG5Db25uZWN0aW9uLnByb3RvdHlwZS5zaG91bGRBdXRoZW50aWNhdGUgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMudXNlciAhPSBudWxsICYmXG4gICAgKHRoaXMucGFzcyAhPSBudWxsIHx8IHRoaXMuYXV0aE1lY2hhbmlzbURvZXNOb3RSZXF1aXJlUGFzc3dvcmQoKSk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgYSBib29sZWFuIHZhbHVlIHRoYXQgc3BlY2lmaWVzIGlmIHRoZSBjdXJyZW50IGF1dGhlbnRpY2F0aW9uIG1lY2hhbmlzbSBuZWVkcyBhXG4gKiBwYXNzd29yZCB0byBhdXRoZW50aWNhdGUgYWNjb3JkaW5nIHRvIHRoZSBhdXRoIG9iamVjdHMgcGFzc2VkIGludG8gdGhlIG9wZW5VcmkgbWV0aG9kcy5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqIEByZXR1cm4ge0Jvb2xlYW59IHRydWUgaWYgdGhlIGF1dGhlbnRpY2F0aW9uIG1lY2hhbmlzbSBzcGVjaWZpZWQgaW4gdGhlIG9wdGlvbnMgb2JqZWN0IHJlcXVpcmVzXG4gKiAgYSBwYXNzd29yZCwgb3RoZXJ3aXNlIGZhbHNlLlxuICovXG5Db25uZWN0aW9uLnByb3RvdHlwZS5hdXRoTWVjaGFuaXNtRG9lc05vdFJlcXVpcmVQYXNzd29yZCA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5vcHRpb25zICYmIHRoaXMub3B0aW9ucy5hdXRoKSB7XG4gICAgcmV0dXJuIG5vUGFzc3dvcmRBdXRoTWVjaGFuaXNtcy5pbmRleE9mKHRoaXMub3B0aW9ucy5hdXRoLmF1dGhNZWNoYW5pc20pID49IDA7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59O1xuXG4vKipcbiAqIFJldHVybnMgYSBib29sZWFuIHZhbHVlIHRoYXQgc3BlY2lmaWVzIGlmIHRoZSBwcm92aWRlZCBvYmplY3RzIG9iamVjdCBwcm92aWRlcyBlbm91Z2hcbiAqIGRhdGEgdG8gYXV0aGVudGljYXRlIHdpdGguIEdlbmVyYWxseSB0aGlzIGlzIHRydWUgaWYgdGhlIHVzZXJuYW1lIGFuZCBwYXNzd29yZCBhcmUgYm90aCBzcGVjaWZpZWRcbiAqIGJ1dCBpbiBzb21lIGF1dGhlbnRpY2F0aW9uIG1ldGhvZHMsIGEgcGFzc3dvcmQgaXMgbm90IHJlcXVpcmVkIGZvciBhdXRoZW50aWNhdGlvbiBzbyBvbmx5IGEgdXNlcm5hbWVcbiAqIGlzIHJlcXVpcmVkLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gdGhlIG9wdGlvbnMgb2JqZWN0IHBhc3NlZCBpbnRvIHRoZSBvcGVuVXJpIG1ldGhvZHMuXG4gKiBAYXBpIHByaXZhdGVcbiAqIEByZXR1cm4ge0Jvb2xlYW59IHRydWUgaWYgdGhlIHByb3ZpZGVkIG9wdGlvbnMgb2JqZWN0IHByb3ZpZGVzIGVub3VnaCBkYXRhIHRvIGF1dGhlbnRpY2F0ZSB3aXRoLFxuICogICBvdGhlcndpc2UgZmFsc2UuXG4gKi9cbkNvbm5lY3Rpb24ucHJvdG90eXBlLm9wdGlvbnNQcm92aWRlQXV0aGVudGljYXRpb25EYXRhID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICByZXR1cm4gKG9wdGlvbnMpICYmXG4gICAgICAob3B0aW9ucy51c2VyKSAmJlxuICAgICAgKChvcHRpb25zLnBhc3MpIHx8IHRoaXMuYXV0aE1lY2hhbmlzbURvZXNOb3RSZXF1aXJlUGFzc3dvcmQoKSk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIFtNb25nb0RCIGRyaXZlciBgTW9uZ29DbGllbnRgXShodHRwczovL21vbmdvZGIuZ2l0aHViLmlvL25vZGUtbW9uZ29kYi1uYXRpdmUvNC45L2NsYXNzZXMvTW9uZ29DbGllbnQuaHRtbCkgaW5zdGFuY2VcbiAqIHRoYXQgdGhpcyBjb25uZWN0aW9uIHVzZXMgdG8gdGFsayB0byBNb25nb0RCLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgY29uc3QgY29ubiA9IGF3YWl0IG1vbmdvb3NlLmNyZWF0ZUNvbm5lY3Rpb24oJ21vbmdvZGI6Ly8xMjcuMC4wLjE6MjcwMTcvdGVzdCcpLlxuICogICAgICAgYXNQcm9taXNlKCk7XG4gKlxuICogICAgIGNvbm4uZ2V0Q2xpZW50KCk7IC8vIE1vbmdvQ2xpZW50IHsgLi4uIH1cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICogQHJldHVybiB7TW9uZ29DbGllbnR9XG4gKi9cblxuQ29ubmVjdGlvbi5wcm90b3R5cGUuZ2V0Q2xpZW50ID0gZnVuY3Rpb24gZ2V0Q2xpZW50KCkge1xuICByZXR1cm4gdGhpcy5jbGllbnQ7XG59O1xuXG4vKipcbiAqIFNldCB0aGUgW01vbmdvREIgZHJpdmVyIGBNb25nb0NsaWVudGBdKGh0dHBzOi8vbW9uZ29kYi5naXRodWIuaW8vbm9kZS1tb25nb2RiLW5hdGl2ZS80LjkvY2xhc3Nlcy9Nb25nb0NsaWVudC5odG1sKSBpbnN0YW5jZVxuICogdGhhdCB0aGlzIGNvbm5lY3Rpb24gdXNlcyB0byB0YWxrIHRvIE1vbmdvREIuIFRoaXMgaXMgdXNlZnVsIGlmIHlvdSBhbHJlYWR5IGhhdmUgYSBNb25nb0NsaWVudCBpbnN0YW5jZSwgYW5kIHdhbnQgdG9cbiAqIHJldXNlIGl0LlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgY29uc3QgY2xpZW50ID0gYXdhaXQgbW9uZ29kYi5Nb25nb0NsaWVudC5jb25uZWN0KCdtb25nb2RiOi8vMTI3LjAuMC4xOjI3MDE3L3Rlc3QnKTtcbiAqXG4gKiAgICAgY29uc3QgY29ubiA9IG1vbmdvb3NlLmNyZWF0ZUNvbm5lY3Rpb24oKS5zZXRDbGllbnQoY2xpZW50KTtcbiAqXG4gKiAgICAgY29ubi5nZXRDbGllbnQoKTsgLy8gTW9uZ29DbGllbnQgeyAuLi4gfVxuICogICAgIGNvbm4ucmVhZHlTdGF0ZTsgLy8gMSwgbWVhbnMgJ0NPTk5FQ1RFRCdcbiAqXG4gKiBAYXBpIHB1YmxpY1xuICogQHBhcmFtIHtNb25nQ2xpZW50fSBjbGllbnQgVGhlIENsaWVudCB0byBzZXQgdG8gYmUgdXNlZC5cbiAqIEByZXR1cm4ge0Nvbm5lY3Rpb259IHRoaXNcbiAqL1xuXG5Db25uZWN0aW9uLnByb3RvdHlwZS5zZXRDbGllbnQgPSBmdW5jdGlvbiBzZXRDbGllbnQoKSB7XG4gIHRocm93IG5ldyBNb25nb29zZUVycm9yKCdDb25uZWN0aW9uI3NldENsaWVudCBub3QgaW1wbGVtZW50ZWQgYnkgZHJpdmVyJyk7XG59O1xuXG4vKiFcbiAqIENhbGxlZCBpbnRlcm5hbGx5IGJ5IGBvcGVuVXJpKClgIHRvIGNyZWF0ZSBhIE1vbmdvQ2xpZW50IGluc3RhbmNlLlxuICovXG5cbkNvbm5lY3Rpb24ucHJvdG90eXBlLmNyZWF0ZUNsaWVudCA9IGZ1bmN0aW9uIGNyZWF0ZUNsaWVudCgpIHtcbiAgdGhyb3cgbmV3IE1vbmdvb3NlRXJyb3IoJ0Nvbm5lY3Rpb24jY3JlYXRlQ2xpZW50IG5vdCBpbXBsZW1lbnRlZCBieSBkcml2ZXInKTtcbn07XG5cbi8qKlxuICogU3luY3MgYWxsIHRoZSBpbmRleGVzIGZvciB0aGUgbW9kZWxzIHJlZ2lzdGVyZWQgd2l0aCB0aGlzIGNvbm5lY3Rpb24uXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5jb250aW51ZU9uRXJyb3JdIGBmYWxzZWAgYnkgZGVmYXVsdC4gSWYgc2V0IHRvIGB0cnVlYCwgbW9uZ29vc2Ugd2lsbCBub3QgdGhyb3cgYW4gZXJyb3IgaWYgb25lIG1vZGVsIHN5bmNpbmcgZmFpbGVkLCBhbmQgd2lsbCByZXR1cm4gYW4gb2JqZWN0IHdoZXJlIHRoZSBrZXlzIGFyZSB0aGUgbmFtZXMgb2YgdGhlIG1vZGVscywgYW5kIHRoZSB2YWx1ZXMgYXJlIHRoZSByZXN1bHRzL2Vycm9ycyBmb3IgZWFjaCBtb2RlbC5cbiAqIEByZXR1cm4ge1Byb21pc2U8T2JqZWN0Pn0gUmV0dXJucyBhIFByb21pc2UsIHdoZW4gdGhlIFByb21pc2UgcmVzb2x2ZXMgdGhlIHZhbHVlIGlzIGEgbGlzdCBvZiB0aGUgZHJvcHBlZCBpbmRleGVzLlxuICovXG5Db25uZWN0aW9uLnByb3RvdHlwZS5zeW5jSW5kZXhlcyA9IGFzeW5jIGZ1bmN0aW9uIHN5bmNJbmRleGVzKG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCByZXN1bHQgPSB7fTtcbiAgY29uc3QgZXJyb3JzTWFwID0geyB9O1xuXG4gIGNvbnN0IHsgY29udGludWVPbkVycm9yIH0gPSBvcHRpb25zO1xuICBkZWxldGUgb3B0aW9ucy5jb250aW51ZU9uRXJyb3I7XG5cbiAgZm9yIChjb25zdCBtb2RlbCBvZiBPYmplY3QudmFsdWVzKHRoaXMubW9kZWxzKSkge1xuICAgIHRyeSB7XG4gICAgICByZXN1bHRbbW9kZWwubW9kZWxOYW1lXSA9IGF3YWl0IG1vZGVsLnN5bmNJbmRleGVzKG9wdGlvbnMpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgaWYgKCFjb250aW51ZU9uRXJyb3IpIHtcbiAgICAgICAgZXJyb3JzTWFwW21vZGVsLm1vZGVsTmFtZV0gPSBlcnI7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdWx0W21vZGVsLm1vZGVsTmFtZV0gPSBlcnI7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKCFjb250aW51ZU9uRXJyb3IgJiYgT2JqZWN0LmtleXMoZXJyb3JzTWFwKS5sZW5ndGgpIHtcbiAgICBjb25zdCBtZXNzYWdlID0gT2JqZWN0LmVudHJpZXMoZXJyb3JzTWFwKS5tYXAoKFttb2RlbE5hbWUsIGVycl0pID0+IGAke21vZGVsTmFtZX06ICR7ZXJyLm1lc3NhZ2V9YCkuam9pbignLCAnKTtcbiAgICBjb25zdCBzeW5jSW5kZXhlc0Vycm9yID0gbmV3IFN5bmNJbmRleGVzRXJyb3IobWVzc2FnZSwgZXJyb3JzTWFwKTtcbiAgICB0aHJvdyBzeW5jSW5kZXhlc0Vycm9yO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKlxuICogU3dpdGNoZXMgdG8gYSBkaWZmZXJlbnQgZGF0YWJhc2UgdXNpbmcgdGhlIHNhbWUgW2Nvbm5lY3Rpb24gcG9vbF0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2FwaS9jb25uZWN0aW9uc2h0bWwjY29ubmVjdGlvbl9wb29scykuXG4gKlxuICogUmV0dXJucyBhIG5ldyBjb25uZWN0aW9uIG9iamVjdCwgd2l0aCB0aGUgbmV3IGRiLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgLy8gQ29ubmVjdCB0byBgaW5pdGlhbGRiYCBmaXJzdFxuICogICAgIGNvbnN0IGNvbm4gPSBhd2FpdCBtb25nb29zZS5jcmVhdGVDb25uZWN0aW9uKCdtb25nb2RiOi8vMTI3LjAuMC4xOjI3MDE3L2luaXRpYWxkYicpLmFzUHJvbWlzZSgpO1xuICpcbiAqICAgICAvLyBDcmVhdGVzIGFuIHVuLWNhY2hlZCBjb25uZWN0aW9uIHRvIGBteWRiYFxuICogICAgIGNvbnN0IGRiID0gY29ubi51c2VEYignbXlkYicpO1xuICogICAgIC8vIENyZWF0ZXMgYSBjYWNoZWQgY29ubmVjdGlvbiB0byBgbXlkYjJgLiBBbGwgY2FsbHMgdG8gYGNvbm4udXNlRGIoJ215ZGIyJywgeyB1c2VDYWNoZTogdHJ1ZSB9KWAgd2lsbCByZXR1cm4gdGhlIHNhbWVcbiAqICAgICAvLyBjb25uZWN0aW9uIGluc3RhbmNlIGFzIG9wcG9zZWQgdG8gY3JlYXRpbmcgYSBuZXcgY29ubmVjdGlvbiBpbnN0YW5jZVxuICogICAgIGNvbnN0IGRiMiA9IGNvbm4udXNlRGIoJ215ZGIyJywgeyB1c2VDYWNoZTogdHJ1ZSB9KTtcbiAqXG4gKiBAbWV0aG9kIHVzZURiXG4gKiBAbWVtYmVyT2YgQ29ubmVjdGlvblxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgVGhlIGRhdGFiYXNlIG5hbWVcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMudXNlQ2FjaGU9ZmFsc2VdIElmIHRydWUsIGNhY2hlIHJlc3VsdHMgc28gY2FsbGluZyBgdXNlRGIoKWAgbXVsdGlwbGUgdGltZXMgd2l0aCB0aGUgc2FtZSBuYW1lIG9ubHkgY3JlYXRlcyAxIGNvbm5lY3Rpb24gb2JqZWN0LlxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5ub0xpc3RlbmVyPWZhbHNlXSBJZiB0cnVlLCB0aGUgY29ubmVjdGlvbiBvYmplY3Qgd2lsbCBub3QgbWFrZSB0aGUgZGIgbGlzdGVuIHRvIGV2ZW50cyBvbiB0aGUgb3JpZ2luYWwgY29ubmVjdGlvbi4gU2VlIFtpc3N1ZSAjOTk2MV0oaHR0cHM6Ly9naXRodWIuY29tL0F1dG9tYXR0aWMvbW9uZ29vc2UvaXNzdWVzLzk5NjEpLlxuICogQHJldHVybiB7Q29ubmVjdGlvbn0gTmV3IENvbm5lY3Rpb24gT2JqZWN0XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbi8qKlxuICogUmVtb3ZlcyB0aGUgZGF0YWJhc2UgY29ubmVjdGlvbiB3aXRoIHRoZSBnaXZlbiBuYW1lIGNyZWF0ZWQgd2l0aCB3aXRoIGB1c2VEYigpYC5cbiAqXG4gKiBUaHJvd3MgYW4gZXJyb3IgaWYgdGhlIGRhdGFiYXNlIGNvbm5lY3Rpb24gd2FzIG5vdCBmb3VuZC5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIC8vIENvbm5lY3QgdG8gYGluaXRpYWxkYmAgZmlyc3RcbiAqICAgICBjb25zdCBjb25uID0gYXdhaXQgbW9uZ29vc2UuY3JlYXRlQ29ubmVjdGlvbignbW9uZ29kYjovLzEyNy4wLjAuMToyNzAxNy9pbml0aWFsZGInKS5hc1Byb21pc2UoKTtcbiAqXG4gKiAgICAgLy8gQ3JlYXRlcyBhbiB1bi1jYWNoZWQgY29ubmVjdGlvbiB0byBgbXlkYmBcbiAqICAgICBjb25zdCBkYiA9IGNvbm4udXNlRGIoJ215ZGInKTtcbiAqXG4gKiAgICAgLy8gQ2xvc2VzIGBkYmAsIGFuZCByZW1vdmVzIGBkYmAgZnJvbSBgY29ubi5yZWxhdGVkRGJzYCBhbmQgYGNvbm4ub3RoZXJEYnNgXG4gKiAgICAgYXdhaXQgY29ubi5yZW1vdmVEYignbXlkYicpO1xuICpcbiAqIEBtZXRob2QgcmVtb3ZlRGJcbiAqIEBtZW1iZXJPZiBDb25uZWN0aW9uXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBUaGUgZGF0YWJhc2UgbmFtZVxuICogQHJldHVybiB7Q29ubmVjdGlvbn0gdGhpc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG4vKiFcbiAqIE1vZHVsZSBleHBvcnRzLlxuICovXG5cbkNvbm5lY3Rpb24uU1RBVEVTID0gU1RBVEVTO1xubW9kdWxlLmV4cG9ydHMgPSBDb25uZWN0aW9uO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../server/node_modules/mongoose/lib/connection.js\n");

/***/ }),

/***/ "../server/node_modules/mongoose/lib/connectionState.js":
/*!**************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/connectionState.js ***!
  \**************************************************************/
/***/ ((module, exports) => {

"use strict";
eval("\n/*!\n * Connection states\n */\n\n\n\nconst STATES = module.exports = exports = Object.create(null);\n\nconst disconnected = 'disconnected';\nconst connected = 'connected';\nconst connecting = 'connecting';\nconst disconnecting = 'disconnecting';\nconst uninitialized = 'uninitialized';\n\nSTATES[0] = disconnected;\nSTATES[1] = connected;\nSTATES[2] = connecting;\nSTATES[3] = disconnecting;\nSTATES[99] = uninitialized;\n\nSTATES[disconnected] = 0;\nSTATES[connected] = 1;\nSTATES[connecting] = 2;\nSTATES[disconnecting] = 3;\nSTATES[uninitialized] = 99;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvY29ubmVjdGlvblN0YXRlLmpzIiwibWFwcGluZ3MiOiI7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7O0FBRWI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbGllbnQvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvY29ubmVjdGlvblN0YXRlLmpzPzE0NjIiXSwic291cmNlc0NvbnRlbnQiOlsiXG4vKiFcbiAqIENvbm5lY3Rpb24gc3RhdGVzXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBTVEFURVMgPSBtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG5jb25zdCBkaXNjb25uZWN0ZWQgPSAnZGlzY29ubmVjdGVkJztcbmNvbnN0IGNvbm5lY3RlZCA9ICdjb25uZWN0ZWQnO1xuY29uc3QgY29ubmVjdGluZyA9ICdjb25uZWN0aW5nJztcbmNvbnN0IGRpc2Nvbm5lY3RpbmcgPSAnZGlzY29ubmVjdGluZyc7XG5jb25zdCB1bmluaXRpYWxpemVkID0gJ3VuaW5pdGlhbGl6ZWQnO1xuXG5TVEFURVNbMF0gPSBkaXNjb25uZWN0ZWQ7XG5TVEFURVNbMV0gPSBjb25uZWN0ZWQ7XG5TVEFURVNbMl0gPSBjb25uZWN0aW5nO1xuU1RBVEVTWzNdID0gZGlzY29ubmVjdGluZztcblNUQVRFU1s5OV0gPSB1bmluaXRpYWxpemVkO1xuXG5TVEFURVNbZGlzY29ubmVjdGVkXSA9IDA7XG5TVEFURVNbY29ubmVjdGVkXSA9IDE7XG5TVEFURVNbY29ubmVjdGluZ10gPSAyO1xuU1RBVEVTW2Rpc2Nvbm5lY3RpbmddID0gMztcblNUQVRFU1t1bmluaXRpYWxpemVkXSA9IDk5O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../server/node_modules/mongoose/lib/connectionState.js\n");

/***/ }),

/***/ "../server/node_modules/mongoose/lib/constants.js":
/*!********************************************************!*\
  !*** ../server/node_modules/mongoose/lib/constants.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\n/*!\n * ignore\n */\n\nconst queryOperations = Object.freeze([\n  // Read\n  'countDocuments',\n  'distinct',\n  'estimatedDocumentCount',\n  'find',\n  'findOne',\n  // Update\n  'findOneAndReplace',\n  'findOneAndUpdate',\n  'replaceOne',\n  'updateMany',\n  'updateOne',\n  // Delete\n  'deleteMany',\n  'deleteOne',\n  'findOneAndDelete'\n]);\n\nexports.queryOperations = queryOperations;\n\n/*!\n * ignore\n */\n\nconst queryMiddlewareFunctions = queryOperations.concat([\n  'validate'\n]);\n\nexports.queryMiddlewareFunctions = queryMiddlewareFunctions;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvY29uc3RhbnRzLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsdUJBQXVCOztBQUV2QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGdDQUFnQyIsInNvdXJjZXMiOlsid2VicGFjazovL2NsaWVudC8uLi9zZXJ2ZXIvbm9kZV9tb2R1bGVzL21vbmdvb3NlL2xpYi9jb25zdGFudHMuanM/OTBkOCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxuY29uc3QgcXVlcnlPcGVyYXRpb25zID0gT2JqZWN0LmZyZWV6ZShbXG4gIC8vIFJlYWRcbiAgJ2NvdW50RG9jdW1lbnRzJyxcbiAgJ2Rpc3RpbmN0JyxcbiAgJ2VzdGltYXRlZERvY3VtZW50Q291bnQnLFxuICAnZmluZCcsXG4gICdmaW5kT25lJyxcbiAgLy8gVXBkYXRlXG4gICdmaW5kT25lQW5kUmVwbGFjZScsXG4gICdmaW5kT25lQW5kVXBkYXRlJyxcbiAgJ3JlcGxhY2VPbmUnLFxuICAndXBkYXRlTWFueScsXG4gICd1cGRhdGVPbmUnLFxuICAvLyBEZWxldGVcbiAgJ2RlbGV0ZU1hbnknLFxuICAnZGVsZXRlT25lJyxcbiAgJ2ZpbmRPbmVBbmREZWxldGUnXG5dKTtcblxuZXhwb3J0cy5xdWVyeU9wZXJhdGlvbnMgPSBxdWVyeU9wZXJhdGlvbnM7XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxuY29uc3QgcXVlcnlNaWRkbGV3YXJlRnVuY3Rpb25zID0gcXVlcnlPcGVyYXRpb25zLmNvbmNhdChbXG4gICd2YWxpZGF0ZSdcbl0pO1xuXG5leHBvcnRzLnF1ZXJ5TWlkZGxld2FyZUZ1bmN0aW9ucyA9IHF1ZXJ5TWlkZGxld2FyZUZ1bmN0aW9ucztcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../server/node_modules/mongoose/lib/constants.js\n");

/***/ }),

/***/ "../server/node_modules/mongoose/lib/cursor/aggregationCursor.js":
/*!***********************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/cursor/aggregationCursor.js ***!
  \***********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*!\n * Module dependencies.\n */\n\n\n\nconst MongooseError = __webpack_require__(/*! ../error/mongooseError */ \"../server/node_modules/mongoose/lib/error/mongooseError.js\");\nconst Readable = (__webpack_require__(/*! stream */ \"stream\").Readable);\nconst eachAsync = __webpack_require__(/*! ../helpers/cursor/eachAsync */ \"../server/node_modules/mongoose/lib/helpers/cursor/eachAsync.js\");\nconst immediate = __webpack_require__(/*! ../helpers/immediate */ \"../server/node_modules/mongoose/lib/helpers/immediate.js\");\nconst util = __webpack_require__(/*! util */ \"util\");\n\n/**\n * An AggregationCursor is a concurrency primitive for processing aggregation\n * results one document at a time. It is analogous to QueryCursor.\n *\n * An AggregationCursor fulfills the Node.js streams3 API,\n * in addition to several other mechanisms for loading documents from MongoDB\n * one at a time.\n *\n * Creating an AggregationCursor executes the model's pre aggregate hooks,\n * but **not** the model's post aggregate hooks.\n *\n * Unless you're an advanced user, do **not** instantiate this class directly.\n * Use [`Aggregate#cursor()`](https://mongoosejs.com/docs/api/aggregate.html#Aggregate.prototype.cursor()) instead.\n *\n * @param {Aggregate} agg\n * @inherits Readable https://nodejs.org/api/stream.html#class-streamreadable\n * @event `cursor`: Emitted when the cursor is created\n * @event `error`: Emitted when an error occurred\n * @event `data`: Emitted when the stream is flowing and the next doc is ready\n * @event `end`: Emitted when the stream is exhausted\n * @api public\n */\n\nfunction AggregationCursor(agg) {\n  // set autoDestroy=true because on node 12 it's by default false\n  // gh-10902 need autoDestroy to destroy correctly and emit 'close' event\n  Readable.call(this, { autoDestroy: true, objectMode: true });\n\n  this.cursor = null;\n  this.agg = agg;\n  this._transforms = [];\n  const model = agg._model;\n  delete agg.options.cursor.useMongooseAggCursor;\n  this._mongooseOptions = {};\n\n  _init(model, this, agg);\n}\n\nutil.inherits(AggregationCursor, Readable);\n\n/*!\n * ignore\n */\n\nfunction _init(model, c, agg) {\n  if (!model.collection.buffer) {\n    model.hooks.execPre('aggregate', agg, function() {\n      if (typeof agg.options?.cursor?.transform === 'function') {\n        c._transforms.push(agg.options.cursor.transform);\n      }\n\n      c.cursor = model.collection.aggregate(agg._pipeline, agg.options || {});\n      c.emit('cursor', c.cursor);\n    });\n  } else {\n    model.collection.emitter.once('queue', function() {\n      model.hooks.execPre('aggregate', agg, function() {\n        if (typeof agg.options?.cursor?.transform === 'function') {\n          c._transforms.push(agg.options.cursor.transform);\n        }\n\n        c.cursor = model.collection.aggregate(agg._pipeline, agg.options || {});\n        c.emit('cursor', c.cursor);\n      });\n    });\n  }\n}\n\n/**\n * Necessary to satisfy the Readable API\n * @method _read\n * @memberOf AggregationCursor\n * @instance\n * @api private\n */\n\nAggregationCursor.prototype._read = function() {\n  const _this = this;\n  _next(this, function(error, doc) {\n    if (error) {\n      return _this.emit('error', error);\n    }\n    if (!doc) {\n      _this.push(null);\n      _this.cursor.close(function(error) {\n        if (error) {\n          return _this.emit('error', error);\n        }\n      });\n      return;\n    }\n    _this.push(doc);\n  });\n};\n\nif (Symbol.asyncIterator != null) {\n  const msg = 'Mongoose does not support using async iterators with an ' +\n    'existing aggregation cursor. See https://bit.ly/mongoose-async-iterate-aggregation';\n\n  AggregationCursor.prototype[Symbol.asyncIterator] = function() {\n    throw new MongooseError(msg);\n  };\n}\n\n/**\n * Registers a transform function which subsequently maps documents retrieved\n * via the streams interface or `.next()`\n *\n * #### Example:\n *\n *     // Map documents returned by `data` events\n *     Thing.\n *       find({ name: /^hello/ }).\n *       cursor().\n *       map(function (doc) {\n *        doc.foo = \"bar\";\n *        return doc;\n *       })\n *       on('data', function(doc) { console.log(doc.foo); });\n *\n *     // Or map documents returned by `.next()`\n *     const cursor = Thing.find({ name: /^hello/ }).\n *       cursor().\n *       map(function (doc) {\n *         doc.foo = \"bar\";\n *         return doc;\n *       });\n *     cursor.next(function(error, doc) {\n *       console.log(doc.foo);\n *     });\n *\n * @param {Function} fn\n * @return {AggregationCursor}\n * @memberOf AggregationCursor\n * @api public\n * @method map\n */\n\nObject.defineProperty(AggregationCursor.prototype, 'map', {\n  value: function(fn) {\n    this._transforms.push(fn);\n    return this;\n  },\n  enumerable: true,\n  configurable: true,\n  writable: true\n});\n\n/**\n * Marks this cursor as errored\n * @method _markError\n * @instance\n * @memberOf AggregationCursor\n * @api private\n */\n\nAggregationCursor.prototype._markError = function(error) {\n  this._error = error;\n  return this;\n};\n\n/**\n * Marks this cursor as closed. Will stop streaming and subsequent calls to\n * `next()` will error.\n *\n * @param {Function} callback\n * @return {Promise}\n * @api public\n * @method close\n * @emits close\n * @see AggregationCursor.close https://mongodb.github.io/node-mongodb-native/4.9/classes/AggregationCursor.html#close\n */\n\nAggregationCursor.prototype.close = async function close() {\n  if (typeof arguments[0] === 'function') {\n    throw new MongooseError('AggregationCursor.prototype.close() no longer accepts a callback');\n  }\n  try {\n    await this.cursor.close();\n  } catch (error) {\n    this.listeners('error').length > 0 && this.emit('error', error);\n    throw error;\n  }\n  this.emit('close');\n};\n\n/**\n * Get the next document from this cursor. Will return `null` when there are\n * no documents left.\n *\n * @return {Promise}\n * @api public\n * @method next\n */\n\nAggregationCursor.prototype.next = async function next() {\n  if (typeof arguments[0] === 'function') {\n    throw new MongooseError('AggregationCursor.prototype.next() no longer accepts a callback');\n  }\n  return new Promise((resolve, reject) => {\n    _next(this, (err, res) => {\n      if (err != null) {\n        return reject(err);\n      }\n      resolve(res);\n    });\n  });\n};\n\n/**\n * Execute `fn` for every document in the cursor. If `fn` returns a promise,\n * will wait for the promise to resolve before iterating on to the next one.\n * Returns a promise that resolves when done.\n *\n * @param {Function} fn\n * @param {Object} [options]\n * @param {Number} [options.parallel] the number of promises to execute in parallel. Defaults to 1.\n * @param {Number} [options.batchSize=null] if set, Mongoose will call `fn` with an array of at most `batchSize` documents, instead of a single document\n * @param {Boolean} [options.continueOnError=false] if true, `eachAsync()` iterates through all docs even if `fn` throws an error. If false, `eachAsync()` throws an error immediately if the given function `fn()` throws an error.\n * @return {Promise}\n * @api public\n * @method eachAsync\n */\n\nAggregationCursor.prototype.eachAsync = function(fn, opts) {\n  if (typeof arguments[2] === 'function') {\n    throw new MongooseError('AggregationCursor.prototype.eachAsync() no longer accepts a callback');\n  }\n  const _this = this;\n  if (typeof opts === 'function') {\n    opts = {};\n  }\n  opts = opts || {};\n\n  return eachAsync(function(cb) { return _next(_this, cb); }, fn, opts);\n};\n\n/**\n * Returns an asyncIterator for use with [`for/await/of` loops](https://thecodebarbarian.com/getting-started-with-async-iterators-in-node-js)\n * You do not need to call this function explicitly, the JavaScript runtime\n * will call it for you.\n *\n * #### Example:\n *\n *     // Async iterator without explicitly calling `cursor()`. Mongoose still\n *     // creates an AggregationCursor instance internally.\n *     const agg = Model.aggregate([{ $match: { age: { $gte: 25 } } }]);\n *     for await (const doc of agg) {\n *       console.log(doc.name);\n *     }\n *\n *     // You can also use an AggregationCursor instance for async iteration\n *     const cursor = Model.aggregate([{ $match: { age: { $gte: 25 } } }]).cursor();\n *     for await (const doc of cursor) {\n *       console.log(doc.name);\n *     }\n *\n * Node.js 10.x supports async iterators natively without any flags. You can\n * enable async iterators in Node.js 8.x using the [`--harmony_async_iteration` flag](https://github.com/tc39/proposal-async-iteration/issues/117#issuecomment-346695187).\n *\n * **Note:** This function is not set if `Symbol.asyncIterator` is undefined. If\n * `Symbol.asyncIterator` is undefined, that means your Node.js version does not\n * support async iterators.\n *\n * @method [Symbol.asyncIterator]\n * @memberOf AggregationCursor\n * @instance\n * @api public\n */\n\nif (Symbol.asyncIterator != null) {\n  AggregationCursor.prototype[Symbol.asyncIterator] = function() {\n    return this.transformNull()._transformForAsyncIterator();\n  };\n}\n\n/*!\n * ignore\n */\n\nAggregationCursor.prototype._transformForAsyncIterator = function() {\n  if (this._transforms.indexOf(_transformForAsyncIterator) === -1) {\n    this.map(_transformForAsyncIterator);\n  }\n  return this;\n};\n\n/*!\n * ignore\n */\n\nAggregationCursor.prototype.transformNull = function(val) {\n  if (arguments.length === 0) {\n    val = true;\n  }\n  this._mongooseOptions.transformNull = val;\n  return this;\n};\n\n/*!\n * ignore\n */\n\nfunction _transformForAsyncIterator(doc) {\n  return doc == null ? { done: true } : { value: doc, done: false };\n}\n\n/**\n * Adds a [cursor flag](https://mongodb.github.io/node-mongodb-native/4.9/classes/AggregationCursor.html#addCursorFlag).\n * Useful for setting the `noCursorTimeout` and `tailable` flags.\n *\n * @param {String} flag\n * @param {Boolean} value\n * @return {AggregationCursor} this\n * @api public\n * @method addCursorFlag\n */\n\nAggregationCursor.prototype.addCursorFlag = function(flag, value) {\n  const _this = this;\n  _waitForCursor(this, function() {\n    _this.cursor.addCursorFlag(flag, value);\n  });\n  return this;\n};\n\n/*!\n * ignore\n */\n\nfunction _waitForCursor(ctx, cb) {\n  if (ctx.cursor) {\n    return cb();\n  }\n  ctx.once('cursor', function() {\n    cb();\n  });\n}\n\n/**\n * Get the next doc from the underlying cursor and mongooseify it\n * (populate, etc.)\n * @param {Any} ctx\n * @param {Function} cb\n * @api private\n */\n\nfunction _next(ctx, cb) {\n  let callback = cb;\n  if (ctx._transforms.length) {\n    callback = function(err, doc) {\n      if (err || (doc === null && !ctx._mongooseOptions.transformNull)) {\n        return cb(err, doc);\n      }\n      cb(err, ctx._transforms.reduce(function(doc, fn) {\n        return fn(doc);\n      }, doc));\n    };\n  }\n\n  if (ctx._error) {\n    return immediate(function() {\n      callback(ctx._error);\n    });\n  }\n\n  if (ctx.cursor) {\n    return ctx.cursor.next().then(\n      doc => {\n        if (!doc) {\n          return callback(null, null);\n        }\n\n        callback(null, doc);\n      },\n      err => callback(err)\n    );\n  } else {\n    ctx.once('cursor', function() {\n      _next(ctx, cb);\n    });\n  }\n}\n\nmodule.exports = AggregationCursor;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvY3Vyc29yL2FnZ3JlZ2F0aW9uQ3Vyc29yLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTs7QUFFYTs7QUFFYixzQkFBc0IsbUJBQU8sQ0FBQywwRkFBd0I7QUFDdEQsaUJBQWlCLHNEQUEwQjtBQUMzQyxrQkFBa0IsbUJBQU8sQ0FBQyxvR0FBNkI7QUFDdkQsa0JBQWtCLG1CQUFPLENBQUMsc0ZBQXNCO0FBQ2hELGFBQWEsbUJBQU8sQ0FBQyxrQkFBTTs7QUFFM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsV0FBVztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IscUNBQXFDOztBQUU3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDRFQUE0RTtBQUM1RTtBQUNBLEtBQUs7QUFDTCxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw4RUFBOEU7QUFDOUU7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixnQkFBZ0I7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Ysb0NBQW9DLHVCQUF1QjtBQUMzRDtBQUNBO0FBQ0EsbUNBQW1DLGdCQUFnQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsVUFBVTtBQUNyQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFNBQVM7QUFDcEIsWUFBWTtBQUNaO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0NBQWtDLDBCQUEwQjtBQUM1RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsVUFBVSxPQUFPLGNBQWM7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxVQUFVLE9BQU8sY0FBYztBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHlCQUF5QixhQUFhLElBQUk7QUFDMUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxTQUFTO0FBQ3BCLFlBQVksbUJBQW1CO0FBQy9CO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsVUFBVTtBQUNyQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbGllbnQvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvY3Vyc29yL2FnZ3JlZ2F0aW9uQ3Vyc29yLmpzPzk1MzciXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuY29uc3QgTW9uZ29vc2VFcnJvciA9IHJlcXVpcmUoJy4uL2Vycm9yL21vbmdvb3NlRXJyb3InKTtcbmNvbnN0IFJlYWRhYmxlID0gcmVxdWlyZSgnc3RyZWFtJykuUmVhZGFibGU7XG5jb25zdCBlYWNoQXN5bmMgPSByZXF1aXJlKCcuLi9oZWxwZXJzL2N1cnNvci9lYWNoQXN5bmMnKTtcbmNvbnN0IGltbWVkaWF0ZSA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvaW1tZWRpYXRlJyk7XG5jb25zdCB1dGlsID0gcmVxdWlyZSgndXRpbCcpO1xuXG4vKipcbiAqIEFuIEFnZ3JlZ2F0aW9uQ3Vyc29yIGlzIGEgY29uY3VycmVuY3kgcHJpbWl0aXZlIGZvciBwcm9jZXNzaW5nIGFnZ3JlZ2F0aW9uXG4gKiByZXN1bHRzIG9uZSBkb2N1bWVudCBhdCBhIHRpbWUuIEl0IGlzIGFuYWxvZ291cyB0byBRdWVyeUN1cnNvci5cbiAqXG4gKiBBbiBBZ2dyZWdhdGlvbkN1cnNvciBmdWxmaWxscyB0aGUgTm9kZS5qcyBzdHJlYW1zMyBBUEksXG4gKiBpbiBhZGRpdGlvbiB0byBzZXZlcmFsIG90aGVyIG1lY2hhbmlzbXMgZm9yIGxvYWRpbmcgZG9jdW1lbnRzIGZyb20gTW9uZ29EQlxuICogb25lIGF0IGEgdGltZS5cbiAqXG4gKiBDcmVhdGluZyBhbiBBZ2dyZWdhdGlvbkN1cnNvciBleGVjdXRlcyB0aGUgbW9kZWwncyBwcmUgYWdncmVnYXRlIGhvb2tzLFxuICogYnV0ICoqbm90KiogdGhlIG1vZGVsJ3MgcG9zdCBhZ2dyZWdhdGUgaG9va3MuXG4gKlxuICogVW5sZXNzIHlvdSdyZSBhbiBhZHZhbmNlZCB1c2VyLCBkbyAqKm5vdCoqIGluc3RhbnRpYXRlIHRoaXMgY2xhc3MgZGlyZWN0bHkuXG4gKiBVc2UgW2BBZ2dyZWdhdGUjY3Vyc29yKClgXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvYXBpL2FnZ3JlZ2F0ZS5odG1sI0FnZ3JlZ2F0ZS5wcm90b3R5cGUuY3Vyc29yKCkpIGluc3RlYWQuXG4gKlxuICogQHBhcmFtIHtBZ2dyZWdhdGV9IGFnZ1xuICogQGluaGVyaXRzIFJlYWRhYmxlIGh0dHBzOi8vbm9kZWpzLm9yZy9hcGkvc3RyZWFtLmh0bWwjY2xhc3Mtc3RyZWFtcmVhZGFibGVcbiAqIEBldmVudCBgY3Vyc29yYDogRW1pdHRlZCB3aGVuIHRoZSBjdXJzb3IgaXMgY3JlYXRlZFxuICogQGV2ZW50IGBlcnJvcmA6IEVtaXR0ZWQgd2hlbiBhbiBlcnJvciBvY2N1cnJlZFxuICogQGV2ZW50IGBkYXRhYDogRW1pdHRlZCB3aGVuIHRoZSBzdHJlYW0gaXMgZmxvd2luZyBhbmQgdGhlIG5leHQgZG9jIGlzIHJlYWR5XG4gKiBAZXZlbnQgYGVuZGA6IEVtaXR0ZWQgd2hlbiB0aGUgc3RyZWFtIGlzIGV4aGF1c3RlZFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBBZ2dyZWdhdGlvbkN1cnNvcihhZ2cpIHtcbiAgLy8gc2V0IGF1dG9EZXN0cm95PXRydWUgYmVjYXVzZSBvbiBub2RlIDEyIGl0J3MgYnkgZGVmYXVsdCBmYWxzZVxuICAvLyBnaC0xMDkwMiBuZWVkIGF1dG9EZXN0cm95IHRvIGRlc3Ryb3kgY29ycmVjdGx5IGFuZCBlbWl0ICdjbG9zZScgZXZlbnRcbiAgUmVhZGFibGUuY2FsbCh0aGlzLCB7IGF1dG9EZXN0cm95OiB0cnVlLCBvYmplY3RNb2RlOiB0cnVlIH0pO1xuXG4gIHRoaXMuY3Vyc29yID0gbnVsbDtcbiAgdGhpcy5hZ2cgPSBhZ2c7XG4gIHRoaXMuX3RyYW5zZm9ybXMgPSBbXTtcbiAgY29uc3QgbW9kZWwgPSBhZ2cuX21vZGVsO1xuICBkZWxldGUgYWdnLm9wdGlvbnMuY3Vyc29yLnVzZU1vbmdvb3NlQWdnQ3Vyc29yO1xuICB0aGlzLl9tb25nb29zZU9wdGlvbnMgPSB7fTtcblxuICBfaW5pdChtb2RlbCwgdGhpcywgYWdnKTtcbn1cblxudXRpbC5pbmhlcml0cyhBZ2dyZWdhdGlvbkN1cnNvciwgUmVhZGFibGUpO1xuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cbmZ1bmN0aW9uIF9pbml0KG1vZGVsLCBjLCBhZ2cpIHtcbiAgaWYgKCFtb2RlbC5jb2xsZWN0aW9uLmJ1ZmZlcikge1xuICAgIG1vZGVsLmhvb2tzLmV4ZWNQcmUoJ2FnZ3JlZ2F0ZScsIGFnZywgZnVuY3Rpb24oKSB7XG4gICAgICBpZiAodHlwZW9mIGFnZy5vcHRpb25zPy5jdXJzb3I/LnRyYW5zZm9ybSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBjLl90cmFuc2Zvcm1zLnB1c2goYWdnLm9wdGlvbnMuY3Vyc29yLnRyYW5zZm9ybSk7XG4gICAgICB9XG5cbiAgICAgIGMuY3Vyc29yID0gbW9kZWwuY29sbGVjdGlvbi5hZ2dyZWdhdGUoYWdnLl9waXBlbGluZSwgYWdnLm9wdGlvbnMgfHwge30pO1xuICAgICAgYy5lbWl0KCdjdXJzb3InLCBjLmN1cnNvcik7XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgbW9kZWwuY29sbGVjdGlvbi5lbWl0dGVyLm9uY2UoJ3F1ZXVlJywgZnVuY3Rpb24oKSB7XG4gICAgICBtb2RlbC5ob29rcy5leGVjUHJlKCdhZ2dyZWdhdGUnLCBhZ2csIGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodHlwZW9mIGFnZy5vcHRpb25zPy5jdXJzb3I/LnRyYW5zZm9ybSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIGMuX3RyYW5zZm9ybXMucHVzaChhZ2cub3B0aW9ucy5jdXJzb3IudHJhbnNmb3JtKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGMuY3Vyc29yID0gbW9kZWwuY29sbGVjdGlvbi5hZ2dyZWdhdGUoYWdnLl9waXBlbGluZSwgYWdnLm9wdGlvbnMgfHwge30pO1xuICAgICAgICBjLmVtaXQoJ2N1cnNvcicsIGMuY3Vyc29yKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG59XG5cbi8qKlxuICogTmVjZXNzYXJ5IHRvIHNhdGlzZnkgdGhlIFJlYWRhYmxlIEFQSVxuICogQG1ldGhvZCBfcmVhZFxuICogQG1lbWJlck9mIEFnZ3JlZ2F0aW9uQ3Vyc29yXG4gKiBAaW5zdGFuY2VcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbkFnZ3JlZ2F0aW9uQ3Vyc29yLnByb3RvdHlwZS5fcmVhZCA9IGZ1bmN0aW9uKCkge1xuICBjb25zdCBfdGhpcyA9IHRoaXM7XG4gIF9uZXh0KHRoaXMsIGZ1bmN0aW9uKGVycm9yLCBkb2MpIHtcbiAgICBpZiAoZXJyb3IpIHtcbiAgICAgIHJldHVybiBfdGhpcy5lbWl0KCdlcnJvcicsIGVycm9yKTtcbiAgICB9XG4gICAgaWYgKCFkb2MpIHtcbiAgICAgIF90aGlzLnB1c2gobnVsbCk7XG4gICAgICBfdGhpcy5jdXJzb3IuY2xvc2UoZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgcmV0dXJuIF90aGlzLmVtaXQoJ2Vycm9yJywgZXJyb3IpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgX3RoaXMucHVzaChkb2MpO1xuICB9KTtcbn07XG5cbmlmIChTeW1ib2wuYXN5bmNJdGVyYXRvciAhPSBudWxsKSB7XG4gIGNvbnN0IG1zZyA9ICdNb25nb29zZSBkb2VzIG5vdCBzdXBwb3J0IHVzaW5nIGFzeW5jIGl0ZXJhdG9ycyB3aXRoIGFuICcgK1xuICAgICdleGlzdGluZyBhZ2dyZWdhdGlvbiBjdXJzb3IuIFNlZSBodHRwczovL2JpdC5seS9tb25nb29zZS1hc3luYy1pdGVyYXRlLWFnZ3JlZ2F0aW9uJztcblxuICBBZ2dyZWdhdGlvbkN1cnNvci5wcm90b3R5cGVbU3ltYm9sLmFzeW5jSXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7XG4gICAgdGhyb3cgbmV3IE1vbmdvb3NlRXJyb3IobXNnKTtcbiAgfTtcbn1cblxuLyoqXG4gKiBSZWdpc3RlcnMgYSB0cmFuc2Zvcm0gZnVuY3Rpb24gd2hpY2ggc3Vic2VxdWVudGx5IG1hcHMgZG9jdW1lbnRzIHJldHJpZXZlZFxuICogdmlhIHRoZSBzdHJlYW1zIGludGVyZmFjZSBvciBgLm5leHQoKWBcbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIC8vIE1hcCBkb2N1bWVudHMgcmV0dXJuZWQgYnkgYGRhdGFgIGV2ZW50c1xuICogICAgIFRoaW5nLlxuICogICAgICAgZmluZCh7IG5hbWU6IC9eaGVsbG8vIH0pLlxuICogICAgICAgY3Vyc29yKCkuXG4gKiAgICAgICBtYXAoZnVuY3Rpb24gKGRvYykge1xuICogICAgICAgIGRvYy5mb28gPSBcImJhclwiO1xuICogICAgICAgIHJldHVybiBkb2M7XG4gKiAgICAgICB9KVxuICogICAgICAgb24oJ2RhdGEnLCBmdW5jdGlvbihkb2MpIHsgY29uc29sZS5sb2coZG9jLmZvbyk7IH0pO1xuICpcbiAqICAgICAvLyBPciBtYXAgZG9jdW1lbnRzIHJldHVybmVkIGJ5IGAubmV4dCgpYFxuICogICAgIGNvbnN0IGN1cnNvciA9IFRoaW5nLmZpbmQoeyBuYW1lOiAvXmhlbGxvLyB9KS5cbiAqICAgICAgIGN1cnNvcigpLlxuICogICAgICAgbWFwKGZ1bmN0aW9uIChkb2MpIHtcbiAqICAgICAgICAgZG9jLmZvbyA9IFwiYmFyXCI7XG4gKiAgICAgICAgIHJldHVybiBkb2M7XG4gKiAgICAgICB9KTtcbiAqICAgICBjdXJzb3IubmV4dChmdW5jdGlvbihlcnJvciwgZG9jKSB7XG4gKiAgICAgICBjb25zb2xlLmxvZyhkb2MuZm9vKTtcbiAqICAgICB9KTtcbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICogQHJldHVybiB7QWdncmVnYXRpb25DdXJzb3J9XG4gKiBAbWVtYmVyT2YgQWdncmVnYXRpb25DdXJzb3JcbiAqIEBhcGkgcHVibGljXG4gKiBAbWV0aG9kIG1hcFxuICovXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShBZ2dyZWdhdGlvbkN1cnNvci5wcm90b3R5cGUsICdtYXAnLCB7XG4gIHZhbHVlOiBmdW5jdGlvbihmbikge1xuICAgIHRoaXMuX3RyYW5zZm9ybXMucHVzaChmbik7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgd3JpdGFibGU6IHRydWVcbn0pO1xuXG4vKipcbiAqIE1hcmtzIHRoaXMgY3Vyc29yIGFzIGVycm9yZWRcbiAqIEBtZXRob2QgX21hcmtFcnJvclxuICogQGluc3RhbmNlXG4gKiBAbWVtYmVyT2YgQWdncmVnYXRpb25DdXJzb3JcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbkFnZ3JlZ2F0aW9uQ3Vyc29yLnByb3RvdHlwZS5fbWFya0Vycm9yID0gZnVuY3Rpb24oZXJyb3IpIHtcbiAgdGhpcy5fZXJyb3IgPSBlcnJvcjtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIE1hcmtzIHRoaXMgY3Vyc29yIGFzIGNsb3NlZC4gV2lsbCBzdG9wIHN0cmVhbWluZyBhbmQgc3Vic2VxdWVudCBjYWxscyB0b1xuICogYG5leHQoKWAgd2lsbCBlcnJvci5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICogQHJldHVybiB7UHJvbWlzZX1cbiAqIEBhcGkgcHVibGljXG4gKiBAbWV0aG9kIGNsb3NlXG4gKiBAZW1pdHMgY2xvc2VcbiAqIEBzZWUgQWdncmVnYXRpb25DdXJzb3IuY2xvc2UgaHR0cHM6Ly9tb25nb2RiLmdpdGh1Yi5pby9ub2RlLW1vbmdvZGItbmF0aXZlLzQuOS9jbGFzc2VzL0FnZ3JlZ2F0aW9uQ3Vyc29yLmh0bWwjY2xvc2VcbiAqL1xuXG5BZ2dyZWdhdGlvbkN1cnNvci5wcm90b3R5cGUuY2xvc2UgPSBhc3luYyBmdW5jdGlvbiBjbG9zZSgpIHtcbiAgaWYgKHR5cGVvZiBhcmd1bWVudHNbMF0gPT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgTW9uZ29vc2VFcnJvcignQWdncmVnYXRpb25DdXJzb3IucHJvdG90eXBlLmNsb3NlKCkgbm8gbG9uZ2VyIGFjY2VwdHMgYSBjYWxsYmFjaycpO1xuICB9XG4gIHRyeSB7XG4gICAgYXdhaXQgdGhpcy5jdXJzb3IuY2xvc2UoKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICB0aGlzLmxpc3RlbmVycygnZXJyb3InKS5sZW5ndGggPiAwICYmIHRoaXMuZW1pdCgnZXJyb3InLCBlcnJvcik7XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbiAgdGhpcy5lbWl0KCdjbG9zZScpO1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIG5leHQgZG9jdW1lbnQgZnJvbSB0aGlzIGN1cnNvci4gV2lsbCByZXR1cm4gYG51bGxgIHdoZW4gdGhlcmUgYXJlXG4gKiBubyBkb2N1bWVudHMgbGVmdC5cbiAqXG4gKiBAcmV0dXJuIHtQcm9taXNlfVxuICogQGFwaSBwdWJsaWNcbiAqIEBtZXRob2QgbmV4dFxuICovXG5cbkFnZ3JlZ2F0aW9uQ3Vyc29yLnByb3RvdHlwZS5uZXh0ID0gYXN5bmMgZnVuY3Rpb24gbmV4dCgpIHtcbiAgaWYgKHR5cGVvZiBhcmd1bWVudHNbMF0gPT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgTW9uZ29vc2VFcnJvcignQWdncmVnYXRpb25DdXJzb3IucHJvdG90eXBlLm5leHQoKSBubyBsb25nZXIgYWNjZXB0cyBhIGNhbGxiYWNrJyk7XG4gIH1cbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBfbmV4dCh0aGlzLCAoZXJyLCByZXMpID0+IHtcbiAgICAgIGlmIChlcnIgIT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gcmVqZWN0KGVycik7XG4gICAgICB9XG4gICAgICByZXNvbHZlKHJlcyk7XG4gICAgfSk7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBFeGVjdXRlIGBmbmAgZm9yIGV2ZXJ5IGRvY3VtZW50IGluIHRoZSBjdXJzb3IuIElmIGBmbmAgcmV0dXJucyBhIHByb21pc2UsXG4gKiB3aWxsIHdhaXQgZm9yIHRoZSBwcm9taXNlIHRvIHJlc29sdmUgYmVmb3JlIGl0ZXJhdGluZyBvbiB0byB0aGUgbmV4dCBvbmUuXG4gKiBSZXR1cm5zIGEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHdoZW4gZG9uZS5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnBhcmFsbGVsXSB0aGUgbnVtYmVyIG9mIHByb21pc2VzIHRvIGV4ZWN1dGUgaW4gcGFyYWxsZWwuIERlZmF1bHRzIHRvIDEuXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuYmF0Y2hTaXplPW51bGxdIGlmIHNldCwgTW9uZ29vc2Ugd2lsbCBjYWxsIGBmbmAgd2l0aCBhbiBhcnJheSBvZiBhdCBtb3N0IGBiYXRjaFNpemVgIGRvY3VtZW50cywgaW5zdGVhZCBvZiBhIHNpbmdsZSBkb2N1bWVudFxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5jb250aW51ZU9uRXJyb3I9ZmFsc2VdIGlmIHRydWUsIGBlYWNoQXN5bmMoKWAgaXRlcmF0ZXMgdGhyb3VnaCBhbGwgZG9jcyBldmVuIGlmIGBmbmAgdGhyb3dzIGFuIGVycm9yLiBJZiBmYWxzZSwgYGVhY2hBc3luYygpYCB0aHJvd3MgYW4gZXJyb3IgaW1tZWRpYXRlbHkgaWYgdGhlIGdpdmVuIGZ1bmN0aW9uIGBmbigpYCB0aHJvd3MgYW4gZXJyb3IuXG4gKiBAcmV0dXJuIHtQcm9taXNlfVxuICogQGFwaSBwdWJsaWNcbiAqIEBtZXRob2QgZWFjaEFzeW5jXG4gKi9cblxuQWdncmVnYXRpb25DdXJzb3IucHJvdG90eXBlLmVhY2hBc3luYyA9IGZ1bmN0aW9uKGZuLCBvcHRzKSB7XG4gIGlmICh0eXBlb2YgYXJndW1lbnRzWzJdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IE1vbmdvb3NlRXJyb3IoJ0FnZ3JlZ2F0aW9uQ3Vyc29yLnByb3RvdHlwZS5lYWNoQXN5bmMoKSBubyBsb25nZXIgYWNjZXB0cyBhIGNhbGxiYWNrJyk7XG4gIH1cbiAgY29uc3QgX3RoaXMgPSB0aGlzO1xuICBpZiAodHlwZW9mIG9wdHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBvcHRzID0ge307XG4gIH1cbiAgb3B0cyA9IG9wdHMgfHwge307XG5cbiAgcmV0dXJuIGVhY2hBc3luYyhmdW5jdGlvbihjYikgeyByZXR1cm4gX25leHQoX3RoaXMsIGNiKTsgfSwgZm4sIG9wdHMpO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIGFuIGFzeW5jSXRlcmF0b3IgZm9yIHVzZSB3aXRoIFtgZm9yL2F3YWl0L29mYCBsb29wc10oaHR0cHM6Ly90aGVjb2RlYmFyYmFyaWFuLmNvbS9nZXR0aW5nLXN0YXJ0ZWQtd2l0aC1hc3luYy1pdGVyYXRvcnMtaW4tbm9kZS1qcylcbiAqIFlvdSBkbyBub3QgbmVlZCB0byBjYWxsIHRoaXMgZnVuY3Rpb24gZXhwbGljaXRseSwgdGhlIEphdmFTY3JpcHQgcnVudGltZVxuICogd2lsbCBjYWxsIGl0IGZvciB5b3UuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICAvLyBBc3luYyBpdGVyYXRvciB3aXRob3V0IGV4cGxpY2l0bHkgY2FsbGluZyBgY3Vyc29yKClgLiBNb25nb29zZSBzdGlsbFxuICogICAgIC8vIGNyZWF0ZXMgYW4gQWdncmVnYXRpb25DdXJzb3IgaW5zdGFuY2UgaW50ZXJuYWxseS5cbiAqICAgICBjb25zdCBhZ2cgPSBNb2RlbC5hZ2dyZWdhdGUoW3sgJG1hdGNoOiB7IGFnZTogeyAkZ3RlOiAyNSB9IH0gfV0pO1xuICogICAgIGZvciBhd2FpdCAoY29uc3QgZG9jIG9mIGFnZykge1xuICogICAgICAgY29uc29sZS5sb2coZG9jLm5hbWUpO1xuICogICAgIH1cbiAqXG4gKiAgICAgLy8gWW91IGNhbiBhbHNvIHVzZSBhbiBBZ2dyZWdhdGlvbkN1cnNvciBpbnN0YW5jZSBmb3IgYXN5bmMgaXRlcmF0aW9uXG4gKiAgICAgY29uc3QgY3Vyc29yID0gTW9kZWwuYWdncmVnYXRlKFt7ICRtYXRjaDogeyBhZ2U6IHsgJGd0ZTogMjUgfSB9IH1dKS5jdXJzb3IoKTtcbiAqICAgICBmb3IgYXdhaXQgKGNvbnN0IGRvYyBvZiBjdXJzb3IpIHtcbiAqICAgICAgIGNvbnNvbGUubG9nKGRvYy5uYW1lKTtcbiAqICAgICB9XG4gKlxuICogTm9kZS5qcyAxMC54IHN1cHBvcnRzIGFzeW5jIGl0ZXJhdG9ycyBuYXRpdmVseSB3aXRob3V0IGFueSBmbGFncy4gWW91IGNhblxuICogZW5hYmxlIGFzeW5jIGl0ZXJhdG9ycyBpbiBOb2RlLmpzIDgueCB1c2luZyB0aGUgW2AtLWhhcm1vbnlfYXN5bmNfaXRlcmF0aW9uYCBmbGFnXShodHRwczovL2dpdGh1Yi5jb20vdGMzOS9wcm9wb3NhbC1hc3luYy1pdGVyYXRpb24vaXNzdWVzLzExNyNpc3N1ZWNvbW1lbnQtMzQ2Njk1MTg3KS5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBmdW5jdGlvbiBpcyBub3Qgc2V0IGlmIGBTeW1ib2wuYXN5bmNJdGVyYXRvcmAgaXMgdW5kZWZpbmVkLiBJZlxuICogYFN5bWJvbC5hc3luY0l0ZXJhdG9yYCBpcyB1bmRlZmluZWQsIHRoYXQgbWVhbnMgeW91ciBOb2RlLmpzIHZlcnNpb24gZG9lcyBub3RcbiAqIHN1cHBvcnQgYXN5bmMgaXRlcmF0b3JzLlxuICpcbiAqIEBtZXRob2QgW1N5bWJvbC5hc3luY0l0ZXJhdG9yXVxuICogQG1lbWJlck9mIEFnZ3JlZ2F0aW9uQ3Vyc29yXG4gKiBAaW5zdGFuY2VcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuaWYgKFN5bWJvbC5hc3luY0l0ZXJhdG9yICE9IG51bGwpIHtcbiAgQWdncmVnYXRpb25DdXJzb3IucHJvdG90eXBlW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybU51bGwoKS5fdHJhbnNmb3JtRm9yQXN5bmNJdGVyYXRvcigpO1xuICB9O1xufVxuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cbkFnZ3JlZ2F0aW9uQ3Vyc29yLnByb3RvdHlwZS5fdHJhbnNmb3JtRm9yQXN5bmNJdGVyYXRvciA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5fdHJhbnNmb3Jtcy5pbmRleE9mKF90cmFuc2Zvcm1Gb3JBc3luY0l0ZXJhdG9yKSA9PT0gLTEpIHtcbiAgICB0aGlzLm1hcChfdHJhbnNmb3JtRm9yQXN5bmNJdGVyYXRvcik7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cbkFnZ3JlZ2F0aW9uQ3Vyc29yLnByb3RvdHlwZS50cmFuc2Zvcm1OdWxsID0gZnVuY3Rpb24odmFsKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgdmFsID0gdHJ1ZTtcbiAgfVxuICB0aGlzLl9tb25nb29zZU9wdGlvbnMudHJhbnNmb3JtTnVsbCA9IHZhbDtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cbmZ1bmN0aW9uIF90cmFuc2Zvcm1Gb3JBc3luY0l0ZXJhdG9yKGRvYykge1xuICByZXR1cm4gZG9jID09IG51bGwgPyB7IGRvbmU6IHRydWUgfSA6IHsgdmFsdWU6IGRvYywgZG9uZTogZmFsc2UgfTtcbn1cblxuLyoqXG4gKiBBZGRzIGEgW2N1cnNvciBmbGFnXShodHRwczovL21vbmdvZGIuZ2l0aHViLmlvL25vZGUtbW9uZ29kYi1uYXRpdmUvNC45L2NsYXNzZXMvQWdncmVnYXRpb25DdXJzb3IuaHRtbCNhZGRDdXJzb3JGbGFnKS5cbiAqIFVzZWZ1bCBmb3Igc2V0dGluZyB0aGUgYG5vQ3Vyc29yVGltZW91dGAgYW5kIGB0YWlsYWJsZWAgZmxhZ3MuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGZsYWdcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gdmFsdWVcbiAqIEByZXR1cm4ge0FnZ3JlZ2F0aW9uQ3Vyc29yfSB0aGlzXG4gKiBAYXBpIHB1YmxpY1xuICogQG1ldGhvZCBhZGRDdXJzb3JGbGFnXG4gKi9cblxuQWdncmVnYXRpb25DdXJzb3IucHJvdG90eXBlLmFkZEN1cnNvckZsYWcgPSBmdW5jdGlvbihmbGFnLCB2YWx1ZSkge1xuICBjb25zdCBfdGhpcyA9IHRoaXM7XG4gIF93YWl0Rm9yQ3Vyc29yKHRoaXMsIGZ1bmN0aW9uKCkge1xuICAgIF90aGlzLmN1cnNvci5hZGRDdXJzb3JGbGFnKGZsYWcsIHZhbHVlKTtcbiAgfSk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5mdW5jdGlvbiBfd2FpdEZvckN1cnNvcihjdHgsIGNiKSB7XG4gIGlmIChjdHguY3Vyc29yKSB7XG4gICAgcmV0dXJuIGNiKCk7XG4gIH1cbiAgY3R4Lm9uY2UoJ2N1cnNvcicsIGZ1bmN0aW9uKCkge1xuICAgIGNiKCk7XG4gIH0pO1xufVxuXG4vKipcbiAqIEdldCB0aGUgbmV4dCBkb2MgZnJvbSB0aGUgdW5kZXJseWluZyBjdXJzb3IgYW5kIG1vbmdvb3NlaWZ5IGl0XG4gKiAocG9wdWxhdGUsIGV0Yy4pXG4gKiBAcGFyYW0ge0FueX0gY3R4XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gX25leHQoY3R4LCBjYikge1xuICBsZXQgY2FsbGJhY2sgPSBjYjtcbiAgaWYgKGN0eC5fdHJhbnNmb3Jtcy5sZW5ndGgpIHtcbiAgICBjYWxsYmFjayA9IGZ1bmN0aW9uKGVyciwgZG9jKSB7XG4gICAgICBpZiAoZXJyIHx8IChkb2MgPT09IG51bGwgJiYgIWN0eC5fbW9uZ29vc2VPcHRpb25zLnRyYW5zZm9ybU51bGwpKSB7XG4gICAgICAgIHJldHVybiBjYihlcnIsIGRvYyk7XG4gICAgICB9XG4gICAgICBjYihlcnIsIGN0eC5fdHJhbnNmb3Jtcy5yZWR1Y2UoZnVuY3Rpb24oZG9jLCBmbikge1xuICAgICAgICByZXR1cm4gZm4oZG9jKTtcbiAgICAgIH0sIGRvYykpO1xuICAgIH07XG4gIH1cblxuICBpZiAoY3R4Ll9lcnJvcikge1xuICAgIHJldHVybiBpbW1lZGlhdGUoZnVuY3Rpb24oKSB7XG4gICAgICBjYWxsYmFjayhjdHguX2Vycm9yKTtcbiAgICB9KTtcbiAgfVxuXG4gIGlmIChjdHguY3Vyc29yKSB7XG4gICAgcmV0dXJuIGN0eC5jdXJzb3IubmV4dCgpLnRoZW4oXG4gICAgICBkb2MgPT4ge1xuICAgICAgICBpZiAoIWRvYykge1xuICAgICAgICAgIHJldHVybiBjYWxsYmFjayhudWxsLCBudWxsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNhbGxiYWNrKG51bGwsIGRvYyk7XG4gICAgICB9LFxuICAgICAgZXJyID0+IGNhbGxiYWNrKGVycilcbiAgICApO1xuICB9IGVsc2Uge1xuICAgIGN0eC5vbmNlKCdjdXJzb3InLCBmdW5jdGlvbigpIHtcbiAgICAgIF9uZXh0KGN0eCwgY2IpO1xuICAgIH0pO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gQWdncmVnYXRpb25DdXJzb3I7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../server/node_modules/mongoose/lib/cursor/aggregationCursor.js\n");

/***/ }),

/***/ "../server/node_modules/mongoose/lib/cursor/changeStream.js":
/*!******************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/cursor/changeStream.js ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\n/*!\n * Module dependencies.\n */\n\nconst EventEmitter = (__webpack_require__(/*! events */ \"events\").EventEmitter);\n\n/*!\n * ignore\n */\n\nconst driverChangeStreamEvents = ['close', 'change', 'end', 'error', 'resumeTokenChanged'];\n\n/*!\n * ignore\n */\n\nclass ChangeStream extends EventEmitter {\n  constructor(changeStreamThunk, pipeline, options) {\n    super();\n\n    this.driverChangeStream = null;\n    this.closed = false;\n    this.bindedEvents = false;\n    this.pipeline = pipeline;\n    this.options = options;\n\n    if (options && options.hydrate && !options.model) {\n      throw new Error(\n        'Cannot create change stream with `hydrate: true` ' +\n        'unless calling `Model.watch()`'\n      );\n    }\n\n    // This wrapper is necessary because of buffering.\n    changeStreamThunk((err, driverChangeStream) => {\n      if (err != null) {\n        this.emit('error', err);\n        return;\n      }\n\n      this.driverChangeStream = driverChangeStream;\n      this.emit('ready');\n    });\n  }\n\n  _bindEvents() {\n    if (this.bindedEvents) {\n      return;\n    }\n\n    this.bindedEvents = true;\n\n    if (this.driverChangeStream == null) {\n      this.once('ready', () => {\n        this.driverChangeStream.on('close', () => {\n          this.closed = true;\n        });\n\n        driverChangeStreamEvents.forEach(ev => {\n          this.driverChangeStream.on(ev, data => {\n            if (data != null && data.fullDocument != null && this.options && this.options.hydrate) {\n              data.fullDocument = this.options.model.hydrate(data.fullDocument);\n            }\n            this.emit(ev, data);\n          });\n        });\n      });\n\n      return;\n    }\n\n    this.driverChangeStream.on('close', () => {\n      this.closed = true;\n    });\n\n    driverChangeStreamEvents.forEach(ev => {\n      this.driverChangeStream.on(ev, data => {\n        if (data != null && data.fullDocument != null && this.options && this.options.hydrate) {\n          data.fullDocument = this.options.model.hydrate(data.fullDocument);\n        }\n        this.emit(ev, data);\n      });\n    });\n  }\n\n  hasNext(cb) {\n    return this.driverChangeStream.hasNext(cb);\n  }\n\n  next(cb) {\n    if (this.options && this.options.hydrate) {\n      if (cb != null) {\n        const originalCb = cb;\n        cb = (err, data) => {\n          if (err != null) {\n            return originalCb(err);\n          }\n          if (data.fullDocument != null) {\n            data.fullDocument = this.options.model.hydrate(data.fullDocument);\n          }\n          return originalCb(null, data);\n        };\n      }\n\n      let maybePromise = this.driverChangeStream.next(cb);\n      if (maybePromise && typeof maybePromise.then === 'function') {\n        maybePromise = maybePromise.then(data => {\n          if (data.fullDocument != null) {\n            data.fullDocument = this.options.model.hydrate(data.fullDocument);\n          }\n          return data;\n        });\n      }\n      return maybePromise;\n    }\n\n    return this.driverChangeStream.next(cb);\n  }\n\n  addListener(event, handler) {\n    this._bindEvents();\n    return super.addListener(event, handler);\n  }\n\n  on(event, handler) {\n    this._bindEvents();\n    return super.on(event, handler);\n  }\n\n  once(event, handler) {\n    this._bindEvents();\n    return super.once(event, handler);\n  }\n\n  _queue(cb) {\n    this.once('ready', () => cb());\n  }\n\n  close() {\n    this.closed = true;\n    if (this.driverChangeStream) {\n      this.driverChangeStream.close();\n    }\n  }\n}\n\n/*!\n * ignore\n */\n\nmodule.exports = ChangeStream;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvY3Vyc29yL2NoYW5nZVN0cmVhbS5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBO0FBQ0E7O0FBRUEscUJBQXFCLDBEQUE4Qjs7QUFFbkQ7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1QsT0FBTzs7QUFFUDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL2NsaWVudC8uLi9zZXJ2ZXIvbm9kZV9tb2R1bGVzL21vbmdvb3NlL2xpYi9jdXJzb3IvY2hhbmdlU3RyZWFtLmpzP2VmNDMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG4vKiFcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxuY29uc3QgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyO1xuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cbmNvbnN0IGRyaXZlckNoYW5nZVN0cmVhbUV2ZW50cyA9IFsnY2xvc2UnLCAnY2hhbmdlJywgJ2VuZCcsICdlcnJvcicsICdyZXN1bWVUb2tlbkNoYW5nZWQnXTtcblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5jbGFzcyBDaGFuZ2VTdHJlYW0gZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuICBjb25zdHJ1Y3RvcihjaGFuZ2VTdHJlYW1UaHVuaywgcGlwZWxpbmUsIG9wdGlvbnMpIHtcbiAgICBzdXBlcigpO1xuXG4gICAgdGhpcy5kcml2ZXJDaGFuZ2VTdHJlYW0gPSBudWxsO1xuICAgIHRoaXMuY2xvc2VkID0gZmFsc2U7XG4gICAgdGhpcy5iaW5kZWRFdmVudHMgPSBmYWxzZTtcbiAgICB0aGlzLnBpcGVsaW5lID0gcGlwZWxpbmU7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcblxuICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMuaHlkcmF0ZSAmJiAhb3B0aW9ucy5tb2RlbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnQ2Fubm90IGNyZWF0ZSBjaGFuZ2Ugc3RyZWFtIHdpdGggYGh5ZHJhdGU6IHRydWVgICcgK1xuICAgICAgICAndW5sZXNzIGNhbGxpbmcgYE1vZGVsLndhdGNoKClgJ1xuICAgICAgKTtcbiAgICB9XG5cbiAgICAvLyBUaGlzIHdyYXBwZXIgaXMgbmVjZXNzYXJ5IGJlY2F1c2Ugb2YgYnVmZmVyaW5nLlxuICAgIGNoYW5nZVN0cmVhbVRodW5rKChlcnIsIGRyaXZlckNoYW5nZVN0cmVhbSkgPT4ge1xuICAgICAgaWYgKGVyciAhPSBudWxsKSB7XG4gICAgICAgIHRoaXMuZW1pdCgnZXJyb3InLCBlcnIpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHRoaXMuZHJpdmVyQ2hhbmdlU3RyZWFtID0gZHJpdmVyQ2hhbmdlU3RyZWFtO1xuICAgICAgdGhpcy5lbWl0KCdyZWFkeScpO1xuICAgIH0pO1xuICB9XG5cbiAgX2JpbmRFdmVudHMoKSB7XG4gICAgaWYgKHRoaXMuYmluZGVkRXZlbnRzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5iaW5kZWRFdmVudHMgPSB0cnVlO1xuXG4gICAgaWYgKHRoaXMuZHJpdmVyQ2hhbmdlU3RyZWFtID09IG51bGwpIHtcbiAgICAgIHRoaXMub25jZSgncmVhZHknLCAoKSA9PiB7XG4gICAgICAgIHRoaXMuZHJpdmVyQ2hhbmdlU3RyZWFtLm9uKCdjbG9zZScsICgpID0+IHtcbiAgICAgICAgICB0aGlzLmNsb3NlZCA9IHRydWU7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGRyaXZlckNoYW5nZVN0cmVhbUV2ZW50cy5mb3JFYWNoKGV2ID0+IHtcbiAgICAgICAgICB0aGlzLmRyaXZlckNoYW5nZVN0cmVhbS5vbihldiwgZGF0YSA9PiB7XG4gICAgICAgICAgICBpZiAoZGF0YSAhPSBudWxsICYmIGRhdGEuZnVsbERvY3VtZW50ICE9IG51bGwgJiYgdGhpcy5vcHRpb25zICYmIHRoaXMub3B0aW9ucy5oeWRyYXRlKSB7XG4gICAgICAgICAgICAgIGRhdGEuZnVsbERvY3VtZW50ID0gdGhpcy5vcHRpb25zLm1vZGVsLmh5ZHJhdGUoZGF0YS5mdWxsRG9jdW1lbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5lbWl0KGV2LCBkYXRhKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuZHJpdmVyQ2hhbmdlU3RyZWFtLm9uKCdjbG9zZScsICgpID0+IHtcbiAgICAgIHRoaXMuY2xvc2VkID0gdHJ1ZTtcbiAgICB9KTtcblxuICAgIGRyaXZlckNoYW5nZVN0cmVhbUV2ZW50cy5mb3JFYWNoKGV2ID0+IHtcbiAgICAgIHRoaXMuZHJpdmVyQ2hhbmdlU3RyZWFtLm9uKGV2LCBkYXRhID0+IHtcbiAgICAgICAgaWYgKGRhdGEgIT0gbnVsbCAmJiBkYXRhLmZ1bGxEb2N1bWVudCAhPSBudWxsICYmIHRoaXMub3B0aW9ucyAmJiB0aGlzLm9wdGlvbnMuaHlkcmF0ZSkge1xuICAgICAgICAgIGRhdGEuZnVsbERvY3VtZW50ID0gdGhpcy5vcHRpb25zLm1vZGVsLmh5ZHJhdGUoZGF0YS5mdWxsRG9jdW1lbnQpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZW1pdChldiwgZGF0YSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIGhhc05leHQoY2IpIHtcbiAgICByZXR1cm4gdGhpcy5kcml2ZXJDaGFuZ2VTdHJlYW0uaGFzTmV4dChjYik7XG4gIH1cblxuICBuZXh0KGNiKSB7XG4gICAgaWYgKHRoaXMub3B0aW9ucyAmJiB0aGlzLm9wdGlvbnMuaHlkcmF0ZSkge1xuICAgICAgaWYgKGNiICE9IG51bGwpIHtcbiAgICAgICAgY29uc3Qgb3JpZ2luYWxDYiA9IGNiO1xuICAgICAgICBjYiA9IChlcnIsIGRhdGEpID0+IHtcbiAgICAgICAgICBpZiAoZXJyICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBvcmlnaW5hbENiKGVycik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChkYXRhLmZ1bGxEb2N1bWVudCAhPSBudWxsKSB7XG4gICAgICAgICAgICBkYXRhLmZ1bGxEb2N1bWVudCA9IHRoaXMub3B0aW9ucy5tb2RlbC5oeWRyYXRlKGRhdGEuZnVsbERvY3VtZW50KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG9yaWdpbmFsQ2IobnVsbCwgZGF0YSk7XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIGxldCBtYXliZVByb21pc2UgPSB0aGlzLmRyaXZlckNoYW5nZVN0cmVhbS5uZXh0KGNiKTtcbiAgICAgIGlmIChtYXliZVByb21pc2UgJiYgdHlwZW9mIG1heWJlUHJvbWlzZS50aGVuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIG1heWJlUHJvbWlzZSA9IG1heWJlUHJvbWlzZS50aGVuKGRhdGEgPT4ge1xuICAgICAgICAgIGlmIChkYXRhLmZ1bGxEb2N1bWVudCAhPSBudWxsKSB7XG4gICAgICAgICAgICBkYXRhLmZ1bGxEb2N1bWVudCA9IHRoaXMub3B0aW9ucy5tb2RlbC5oeWRyYXRlKGRhdGEuZnVsbERvY3VtZW50KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG1heWJlUHJvbWlzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5kcml2ZXJDaGFuZ2VTdHJlYW0ubmV4dChjYik7XG4gIH1cblxuICBhZGRMaXN0ZW5lcihldmVudCwgaGFuZGxlcikge1xuICAgIHRoaXMuX2JpbmRFdmVudHMoKTtcbiAgICByZXR1cm4gc3VwZXIuYWRkTGlzdGVuZXIoZXZlbnQsIGhhbmRsZXIpO1xuICB9XG5cbiAgb24oZXZlbnQsIGhhbmRsZXIpIHtcbiAgICB0aGlzLl9iaW5kRXZlbnRzKCk7XG4gICAgcmV0dXJuIHN1cGVyLm9uKGV2ZW50LCBoYW5kbGVyKTtcbiAgfVxuXG4gIG9uY2UoZXZlbnQsIGhhbmRsZXIpIHtcbiAgICB0aGlzLl9iaW5kRXZlbnRzKCk7XG4gICAgcmV0dXJuIHN1cGVyLm9uY2UoZXZlbnQsIGhhbmRsZXIpO1xuICB9XG5cbiAgX3F1ZXVlKGNiKSB7XG4gICAgdGhpcy5vbmNlKCdyZWFkeScsICgpID0+IGNiKCkpO1xuICB9XG5cbiAgY2xvc2UoKSB7XG4gICAgdGhpcy5jbG9zZWQgPSB0cnVlO1xuICAgIGlmICh0aGlzLmRyaXZlckNoYW5nZVN0cmVhbSkge1xuICAgICAgdGhpcy5kcml2ZXJDaGFuZ2VTdHJlYW0uY2xvc2UoKTtcbiAgICB9XG4gIH1cbn1cblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IENoYW5nZVN0cmVhbTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../server/node_modules/mongoose/lib/cursor/changeStream.js\n");

/***/ }),

/***/ "../server/node_modules/mongoose/lib/cursor/queryCursor.js":
/*!*****************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/cursor/queryCursor.js ***!
  \*****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*!\n * Module dependencies.\n */\n\n\n\nconst MongooseError = __webpack_require__(/*! ../error/mongooseError */ \"../server/node_modules/mongoose/lib/error/mongooseError.js\");\nconst Readable = (__webpack_require__(/*! stream */ \"stream\").Readable);\nconst eachAsync = __webpack_require__(/*! ../helpers/cursor/eachAsync */ \"../server/node_modules/mongoose/lib/helpers/cursor/eachAsync.js\");\nconst helpers = __webpack_require__(/*! ../queryHelpers */ \"../server/node_modules/mongoose/lib/queryHelpers.js\");\nconst kareem = __webpack_require__(/*! kareem */ \"../server/node_modules/kareem/index.js\");\nconst immediate = __webpack_require__(/*! ../helpers/immediate */ \"../server/node_modules/mongoose/lib/helpers/immediate.js\");\nconst util = __webpack_require__(/*! util */ \"util\");\n\n/**\n * A QueryCursor is a concurrency primitive for processing query results\n * one document at a time. A QueryCursor fulfills the Node.js streams3 API,\n * in addition to several other mechanisms for loading documents from MongoDB\n * one at a time.\n *\n * QueryCursors execute the model's pre `find` hooks before loading any documents\n * from MongoDB, and the model's post `find` hooks after loading each document.\n *\n * Unless you're an advanced user, do **not** instantiate this class directly.\n * Use [`Query#cursor()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.cursor()) instead.\n *\n * @param {Query} query\n * @param {Object} options query options passed to `.find()`\n * @inherits Readable https://nodejs.org/api/stream.html#class-streamreadable\n * @event `cursor`: Emitted when the cursor is created\n * @event `error`: Emitted when an error occurred\n * @event `data`: Emitted when the stream is flowing and the next doc is ready\n * @event `end`: Emitted when the stream is exhausted\n * @api public\n */\n\nfunction QueryCursor(query) {\n  // set autoDestroy=true because on node 12 it's by default false\n  // gh-10902 need autoDestroy to destroy correctly and emit 'close' event\n  Readable.call(this, { autoDestroy: true, objectMode: true });\n\n  this.cursor = null;\n  this.skipped = false;\n  this.query = query;\n  const model = query.model;\n  this._mongooseOptions = {};\n  this._transforms = [];\n  this.model = model;\n  this.options = {};\n  model.hooks.execPre('find', query, (err) => {\n    if (err != null) {\n      if (err instanceof kareem.skipWrappedFunction) {\n        const resultValue = err.args[0];\n        if (resultValue != null && (!Array.isArray(resultValue) || resultValue.length)) {\n          const err = new MongooseError(\n            'Cannot `skipMiddlewareFunction()` with a value when using ' +\n            '`.find().cursor()`, value must be nullish or empty array, got \"' +\n            util.inspect(resultValue) +\n            '\".'\n          );\n          this._markError(err);\n          this.listeners('error').length > 0 && this.emit('error', err);\n          return;\n        }\n        this.skipped = true;\n        this.emit('cursor', null);\n        return;\n      }\n      this._markError(err);\n      this.listeners('error').length > 0 && this.emit('error', err);\n      return;\n    }\n    Object.assign(this.options, query._optionsForExec());\n    this._transforms = this._transforms.concat(query._transforms.slice());\n    if (this.options.transform) {\n      this._transforms.push(this.options.transform);\n    }\n    // Re: gh-8039, you need to set the `cursor.batchSize` option, top-level\n    // `batchSize` option doesn't work.\n    if (this.options.batchSize) {\n      // Max out the number of documents we'll populate in parallel at 5000.\n      this.options._populateBatchSize = Math.min(this.options.batchSize, 5000);\n    }\n\n    if (model.collection._shouldBufferCommands() && model.collection.buffer) {\n      model.collection.queue.push([\n        () => _getRawCursor(query, this)\n      ]);\n    } else {\n      _getRawCursor(query, this);\n    }\n  });\n}\n\nutil.inherits(QueryCursor, Readable);\n\n/*!\n * ignore\n */\n\nfunction _getRawCursor(query, queryCursor) {\n  try {\n    const cursor = query.model.collection.find(query._conditions, queryCursor.options);\n    queryCursor.cursor = cursor;\n    queryCursor.emit('cursor', cursor);\n  } catch (err) {\n    queryCursor._markError(err);\n    queryCursor.listeners('error').length > 0 && queryCursor.emit('error', queryCursor._error);\n  }\n}\n\n/**\n * Necessary to satisfy the Readable API\n * @method _read\n * @memberOf QueryCursor\n * @instance\n * @api private\n */\n\nQueryCursor.prototype._read = function() {\n  _next(this, (error, doc) => {\n    if (error) {\n      return this.emit('error', error);\n    }\n    if (!doc) {\n      this.push(null);\n      this.cursor.close(function(error) {\n        if (error) {\n          return this.emit('error', error);\n        }\n      });\n      return;\n    }\n    this.push(doc);\n  });\n};\n\n/**\n * Registers a transform function which subsequently maps documents retrieved\n * via the streams interface or `.next()`\n *\n * #### Example:\n *\n *     // Map documents returned by `data` events\n *     Thing.\n *       find({ name: /^hello/ }).\n *       cursor().\n *       map(function (doc) {\n *        doc.foo = \"bar\";\n *        return doc;\n *       })\n *       on('data', function(doc) { console.log(doc.foo); });\n *\n *     // Or map documents returned by `.next()`\n *     const cursor = Thing.find({ name: /^hello/ }).\n *       cursor().\n *       map(function (doc) {\n *         doc.foo = \"bar\";\n *         return doc;\n *       });\n *     cursor.next(function(error, doc) {\n *       console.log(doc.foo);\n *     });\n *\n * @param {Function} fn\n * @return {QueryCursor}\n * @memberOf QueryCursor\n * @api public\n * @method map\n */\n\nObject.defineProperty(QueryCursor.prototype, 'map', {\n  value: function(fn) {\n    this._transforms.push(fn);\n    return this;\n  },\n  enumerable: true,\n  configurable: true,\n  writable: true\n});\n\n/**\n * Marks this cursor as errored\n * @method _markError\n * @memberOf QueryCursor\n * @instance\n * @api private\n */\n\nQueryCursor.prototype._markError = function(error) {\n  this._error = error;\n  return this;\n};\n\n/**\n * Marks this cursor as closed. Will stop streaming and subsequent calls to\n * `next()` will error.\n *\n * @return {Promise}\n * @api public\n * @method close\n * @emits close\n * @see AggregationCursor.close https://mongodb.github.io/node-mongodb-native/4.9/classes/AggregationCursor.html#close\n */\n\nQueryCursor.prototype.close = async function close() {\n  if (typeof arguments[0] === 'function') {\n    throw new MongooseError('QueryCursor.prototype.close() no longer accepts a callback');\n  }\n  try {\n    await this.cursor.close();\n    this.emit('close');\n  } catch (error) {\n    this.listeners('error').length > 0 && this.emit('error', error);\n    throw error;\n  }\n};\n\n/**\n * Rewind this cursor to its uninitialized state. Any options that are present on the cursor will\n * remain in effect. Iterating this cursor will cause new queries to be sent to the server, even\n * if the resultant data has already been retrieved by this cursor.\n *\n * @return {AggregationCursor} this\n * @api public\n * @method rewind\n */\n\nQueryCursor.prototype.rewind = function() {\n  _waitForCursor(this, () => {\n    this.cursor.rewind();\n  });\n  return this;\n};\n\n/**\n * Get the next document from this cursor. Will return `null` when there are\n * no documents left.\n *\n * @return {Promise}\n * @api public\n * @method next\n */\n\nQueryCursor.prototype.next = async function next() {\n  if (typeof arguments[0] === 'function') {\n    throw new MongooseError('QueryCursor.prototype.next() no longer accepts a callback');\n  }\n  return new Promise((resolve, reject) => {\n    _next(this, function(error, doc) {\n      if (error) {\n        return reject(error);\n      }\n      resolve(doc);\n    });\n  });\n};\n\n/**\n * Execute `fn` for every document in the cursor. If `fn` returns a promise,\n * will wait for the promise to resolve before iterating on to the next one.\n * Returns a promise that resolves when done.\n *\n * #### Example:\n *\n *     // Iterate over documents asynchronously\n *     Thing.\n *       find({ name: /^hello/ }).\n *       cursor().\n *       eachAsync(async function (doc, i) {\n *         doc.foo = doc.bar + i;\n *         await doc.save();\n *       })\n *\n * @param {Function} fn\n * @param {Object} [options]\n * @param {Number} [options.parallel] the number of promises to execute in parallel. Defaults to 1.\n * @param {Number} [options.batchSize] if set, will call `fn()` with arrays of documents with length at most `batchSize`\n * @param {Boolean} [options.continueOnError=false] if true, `eachAsync()` iterates through all docs even if `fn` throws an error. If false, `eachAsync()` throws an error immediately if the given function `fn()` throws an error.\n * @return {Promise}\n * @api public\n * @method eachAsync\n */\n\nQueryCursor.prototype.eachAsync = function(fn, opts) {\n  if (typeof arguments[2] === 'function') {\n    throw new MongooseError('QueryCursor.prototype.eachAsync() no longer accepts a callback');\n  }\n  if (typeof opts === 'function') {\n    opts = {};\n  }\n  opts = opts || {};\n\n  return eachAsync((cb) => _next(this, cb), fn, opts);\n};\n\n/**\n * The `options` passed in to the `QueryCursor` constructor.\n *\n * @api public\n * @property options\n */\n\nQueryCursor.prototype.options;\n\n/**\n * Adds a [cursor flag](https://mongodb.github.io/node-mongodb-native/4.9/classes/FindCursor.html#addCursorFlag).\n * Useful for setting the `noCursorTimeout` and `tailable` flags.\n *\n * @param {String} flag\n * @param {Boolean} value\n * @return {AggregationCursor} this\n * @api public\n * @method addCursorFlag\n */\n\nQueryCursor.prototype.addCursorFlag = function(flag, value) {\n  _waitForCursor(this, () => {\n    this.cursor.addCursorFlag(flag, value);\n  });\n  return this;\n};\n\n/*!\n * ignore\n */\n\nQueryCursor.prototype.transformNull = function(val) {\n  if (arguments.length === 0) {\n    val = true;\n  }\n  this._mongooseOptions.transformNull = val;\n  return this;\n};\n\n/*!\n * ignore\n */\n\nQueryCursor.prototype._transformForAsyncIterator = function() {\n  if (this._transforms.indexOf(_transformForAsyncIterator) === -1) {\n    this.map(_transformForAsyncIterator);\n  }\n  return this;\n};\n\n/**\n * Returns an asyncIterator for use with [`for/await/of` loops](https://thecodebarbarian.com/getting-started-with-async-iterators-in-node-js).\n * You do not need to call this function explicitly, the JavaScript runtime\n * will call it for you.\n *\n * #### Example:\n *\n *     // Works without using `cursor()`\n *     for await (const doc of Model.find([{ $sort: { name: 1 } }])) {\n *       console.log(doc.name);\n *     }\n *\n *     // Can also use `cursor()`\n *     for await (const doc of Model.find([{ $sort: { name: 1 } }]).cursor()) {\n *       console.log(doc.name);\n *     }\n *\n * Node.js 10.x supports async iterators natively without any flags. You can\n * enable async iterators in Node.js 8.x using the [`--harmony_async_iteration` flag](https://github.com/tc39/proposal-async-iteration/issues/117#issuecomment-346695187).\n *\n * **Note:** This function is not if `Symbol.asyncIterator` is undefined. If\n * `Symbol.asyncIterator` is undefined, that means your Node.js version does not\n * support async iterators.\n *\n * @method [Symbol.asyncIterator]\n * @memberOf QueryCursor\n * @instance\n * @api public\n */\n\nif (Symbol.asyncIterator != null) {\n  QueryCursor.prototype[Symbol.asyncIterator] = function() {\n    return this.transformNull()._transformForAsyncIterator();\n  };\n}\n\n/*!\n * ignore\n */\n\nfunction _transformForAsyncIterator(doc) {\n  return doc == null ? { done: true } : { value: doc, done: false };\n}\n\n/**\n * Get the next doc from the underlying cursor and mongooseify it\n * (populate, etc.)\n * @param {Any} ctx\n * @param {Function} cb\n * @api private\n */\n\nfunction _next(ctx, cb) {\n  let callback = cb;\n  if (ctx._transforms.length) {\n    callback = function(err, doc) {\n      if (err || (doc === null && !ctx._mongooseOptions.transformNull)) {\n        return cb(err, doc);\n      }\n      cb(err, ctx._transforms.reduce(function(doc, fn) {\n        return fn.call(ctx, doc);\n      }, doc));\n    };\n  }\n\n  if (ctx._error) {\n    return immediate(function() {\n      callback(ctx._error);\n    });\n  }\n  if (ctx.skipped) {\n    return immediate(() => callback(null, null));\n  }\n\n  if (ctx.cursor) {\n    if (ctx.query._mongooseOptions.populate && !ctx._pop) {\n      ctx._pop = helpers.preparePopulationOptionsMQ(ctx.query,\n        ctx.query._mongooseOptions);\n      ctx._pop.__noPromise = true;\n    }\n    if (ctx.query._mongooseOptions.populate && ctx.options._populateBatchSize > 1) {\n      if (ctx._batchDocs && ctx._batchDocs.length) {\n        // Return a cached populated doc\n        return _nextDoc(ctx, ctx._batchDocs.shift(), ctx._pop, callback);\n      } else if (ctx._batchExhausted) {\n        // Internal cursor reported no more docs. Act the same here\n        return callback(null, null);\n      } else {\n        // Request as many docs as batchSize, to populate them also in batch\n        ctx._batchDocs = [];\n        ctx.cursor.next().then(\n          res => { _onNext.call({ ctx, callback }, null, res); },\n          err => { _onNext.call({ ctx, callback }, err); }\n        );\n        return;\n      }\n    } else {\n      return ctx.cursor.next().then(\n        doc => {\n          if (!doc) {\n            callback(null, null);\n            return;\n          }\n\n          if (!ctx.query._mongooseOptions.populate) {\n            return _nextDoc(ctx, doc, null, callback);\n          }\n\n          ctx.query.model.populate(doc, ctx._pop).then(\n            doc => {\n              _nextDoc(ctx, doc, ctx._pop, callback);\n            },\n            err => {\n              callback(err);\n            }\n          );\n        },\n        error => {\n          callback(error);\n        }\n      );\n    }\n  } else {\n    ctx.once('error', cb);\n\n    ctx.once('cursor', function(cursor) {\n      ctx.removeListener('error', cb);\n      if (cursor == null) {\n        if (ctx.skipped) {\n          return cb(null, null);\n        }\n        return;\n      }\n      _next(ctx, cb);\n    });\n  }\n}\n\n/*!\n * ignore\n */\n\nfunction _onNext(error, doc) {\n  if (error) {\n    return this.callback(error);\n  }\n  if (!doc) {\n    this.ctx._batchExhausted = true;\n    return _populateBatch.call(this);\n  }\n\n  this.ctx._batchDocs.push(doc);\n\n  if (this.ctx._batchDocs.length < this.ctx.options._populateBatchSize) {\n    // If both `batchSize` and `_populateBatchSize` are huge, calling `next()` repeatedly may\n    // cause a stack overflow. So make sure we clear the stack regularly.\n    if (this.ctx._batchDocs.length > 0 && this.ctx._batchDocs.length % 1000 === 0) {\n      return immediate(() => this.ctx.cursor.next().then(\n        res => { _onNext.call(this, null, res); },\n        err => { _onNext.call(this, err); }\n      ));\n    }\n    this.ctx.cursor.next().then(\n      res => { _onNext.call(this, null, res); },\n      err => { _onNext.call(this, err); }\n    );\n  } else {\n    _populateBatch.call(this);\n  }\n}\n\n/*!\n * ignore\n */\n\nfunction _populateBatch() {\n  if (!this.ctx._batchDocs.length) {\n    return this.callback(null, null);\n  }\n  this.ctx.query.model.populate(this.ctx._batchDocs, this.ctx._pop).then(\n    () => {\n      _nextDoc(this.ctx, this.ctx._batchDocs.shift(), this.ctx._pop, this.callback);\n    },\n    err => {\n      this.callback(err);\n    }\n  );\n}\n\n/*!\n * ignore\n */\n\nfunction _nextDoc(ctx, doc, pop, callback) {\n  if (ctx.query._mongooseOptions.lean) {\n    return ctx.model.hooks.execPost('find', ctx.query, [[doc]], err => {\n      if (err != null) {\n        return callback(err);\n      }\n      callback(null, doc);\n    });\n  }\n\n  const { model, _fields, _userProvidedFields, options } = ctx.query;\n  helpers.createModelAndInit(model, doc, _fields, _userProvidedFields, options, pop, (err, doc) => {\n    if (err != null) {\n      return callback(err);\n    }\n    ctx.model.hooks.execPost('find', ctx.query, [[doc]], err => {\n      if (err != null) {\n        return callback(err);\n      }\n      callback(null, doc);\n    });\n  });\n}\n\n/*!\n * ignore\n */\n\nfunction _waitForCursor(ctx, cb) {\n  if (ctx.cursor) {\n    return cb();\n  }\n  ctx.once('cursor', function(cursor) {\n    if (cursor == null) {\n      return;\n    }\n    cb();\n  });\n}\n\nmodule.exports = QueryCursor;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvY3Vyc29yL3F1ZXJ5Q3Vyc29yLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTs7QUFFYTs7QUFFYixzQkFBc0IsbUJBQU8sQ0FBQywwRkFBd0I7QUFDdEQsaUJBQWlCLHNEQUEwQjtBQUMzQyxrQkFBa0IsbUJBQU8sQ0FBQyxvR0FBNkI7QUFDdkQsZ0JBQWdCLG1CQUFPLENBQUMsNEVBQWlCO0FBQ3pDLGVBQWUsbUJBQU8sQ0FBQyxzREFBUTtBQUMvQixrQkFBa0IsbUJBQU8sQ0FBQyxzRkFBc0I7QUFDaEQsYUFBYSxtQkFBTyxDQUFDLGtCQUFNOztBQUUzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixxQ0FBcUM7O0FBRTdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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LGVBQWUsZUFBZSxlQUFlO0FBQ2hFLG1CQUFtQixlQUFlLGVBQWU7QUFDakQ7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixnQ0FBZ0M7QUFDakQsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZ0NBQWdDO0FBQy9DLGVBQWU7QUFDZjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBLFVBQVUsK0NBQStDO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL2NsaWVudC8uLi9zZXJ2ZXIvbm9kZV9tb2R1bGVzL21vbmdvb3NlL2xpYi9jdXJzb3IvcXVlcnlDdXJzb3IuanM/OTU0OCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBNb25nb29zZUVycm9yID0gcmVxdWlyZSgnLi4vZXJyb3IvbW9uZ29vc2VFcnJvcicpO1xuY29uc3QgUmVhZGFibGUgPSByZXF1aXJlKCdzdHJlYW0nKS5SZWFkYWJsZTtcbmNvbnN0IGVhY2hBc3luYyA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvY3Vyc29yL2VhY2hBc3luYycpO1xuY29uc3QgaGVscGVycyA9IHJlcXVpcmUoJy4uL3F1ZXJ5SGVscGVycycpO1xuY29uc3Qga2FyZWVtID0gcmVxdWlyZSgna2FyZWVtJyk7XG5jb25zdCBpbW1lZGlhdGUgPSByZXF1aXJlKCcuLi9oZWxwZXJzL2ltbWVkaWF0ZScpO1xuY29uc3QgdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcblxuLyoqXG4gKiBBIFF1ZXJ5Q3Vyc29yIGlzIGEgY29uY3VycmVuY3kgcHJpbWl0aXZlIGZvciBwcm9jZXNzaW5nIHF1ZXJ5IHJlc3VsdHNcbiAqIG9uZSBkb2N1bWVudCBhdCBhIHRpbWUuIEEgUXVlcnlDdXJzb3IgZnVsZmlsbHMgdGhlIE5vZGUuanMgc3RyZWFtczMgQVBJLFxuICogaW4gYWRkaXRpb24gdG8gc2V2ZXJhbCBvdGhlciBtZWNoYW5pc21zIGZvciBsb2FkaW5nIGRvY3VtZW50cyBmcm9tIE1vbmdvREJcbiAqIG9uZSBhdCBhIHRpbWUuXG4gKlxuICogUXVlcnlDdXJzb3JzIGV4ZWN1dGUgdGhlIG1vZGVsJ3MgcHJlIGBmaW5kYCBob29rcyBiZWZvcmUgbG9hZGluZyBhbnkgZG9jdW1lbnRzXG4gKiBmcm9tIE1vbmdvREIsIGFuZCB0aGUgbW9kZWwncyBwb3N0IGBmaW5kYCBob29rcyBhZnRlciBsb2FkaW5nIGVhY2ggZG9jdW1lbnQuXG4gKlxuICogVW5sZXNzIHlvdSdyZSBhbiBhZHZhbmNlZCB1c2VyLCBkbyAqKm5vdCoqIGluc3RhbnRpYXRlIHRoaXMgY2xhc3MgZGlyZWN0bHkuXG4gKiBVc2UgW2BRdWVyeSNjdXJzb3IoKWBdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvcXVlcnkuaHRtbCNRdWVyeS5wcm90b3R5cGUuY3Vyc29yKCkpIGluc3RlYWQuXG4gKlxuICogQHBhcmFtIHtRdWVyeX0gcXVlcnlcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIHF1ZXJ5IG9wdGlvbnMgcGFzc2VkIHRvIGAuZmluZCgpYFxuICogQGluaGVyaXRzIFJlYWRhYmxlIGh0dHBzOi8vbm9kZWpzLm9yZy9hcGkvc3RyZWFtLmh0bWwjY2xhc3Mtc3RyZWFtcmVhZGFibGVcbiAqIEBldmVudCBgY3Vyc29yYDogRW1pdHRlZCB3aGVuIHRoZSBjdXJzb3IgaXMgY3JlYXRlZFxuICogQGV2ZW50IGBlcnJvcmA6IEVtaXR0ZWQgd2hlbiBhbiBlcnJvciBvY2N1cnJlZFxuICogQGV2ZW50IGBkYXRhYDogRW1pdHRlZCB3aGVuIHRoZSBzdHJlYW0gaXMgZmxvd2luZyBhbmQgdGhlIG5leHQgZG9jIGlzIHJlYWR5XG4gKiBAZXZlbnQgYGVuZGA6IEVtaXR0ZWQgd2hlbiB0aGUgc3RyZWFtIGlzIGV4aGF1c3RlZFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBRdWVyeUN1cnNvcihxdWVyeSkge1xuICAvLyBzZXQgYXV0b0Rlc3Ryb3k9dHJ1ZSBiZWNhdXNlIG9uIG5vZGUgMTIgaXQncyBieSBkZWZhdWx0IGZhbHNlXG4gIC8vIGdoLTEwOTAyIG5lZWQgYXV0b0Rlc3Ryb3kgdG8gZGVzdHJveSBjb3JyZWN0bHkgYW5kIGVtaXQgJ2Nsb3NlJyBldmVudFxuICBSZWFkYWJsZS5jYWxsKHRoaXMsIHsgYXV0b0Rlc3Ryb3k6IHRydWUsIG9iamVjdE1vZGU6IHRydWUgfSk7XG5cbiAgdGhpcy5jdXJzb3IgPSBudWxsO1xuICB0aGlzLnNraXBwZWQgPSBmYWxzZTtcbiAgdGhpcy5xdWVyeSA9IHF1ZXJ5O1xuICBjb25zdCBtb2RlbCA9IHF1ZXJ5Lm1vZGVsO1xuICB0aGlzLl9tb25nb29zZU9wdGlvbnMgPSB7fTtcbiAgdGhpcy5fdHJhbnNmb3JtcyA9IFtdO1xuICB0aGlzLm1vZGVsID0gbW9kZWw7XG4gIHRoaXMub3B0aW9ucyA9IHt9O1xuICBtb2RlbC5ob29rcy5leGVjUHJlKCdmaW5kJywgcXVlcnksIChlcnIpID0+IHtcbiAgICBpZiAoZXJyICE9IG51bGwpIHtcbiAgICAgIGlmIChlcnIgaW5zdGFuY2VvZiBrYXJlZW0uc2tpcFdyYXBwZWRGdW5jdGlvbikge1xuICAgICAgICBjb25zdCByZXN1bHRWYWx1ZSA9IGVyci5hcmdzWzBdO1xuICAgICAgICBpZiAocmVzdWx0VmFsdWUgIT0gbnVsbCAmJiAoIUFycmF5LmlzQXJyYXkocmVzdWx0VmFsdWUpIHx8IHJlc3VsdFZhbHVlLmxlbmd0aCkpIHtcbiAgICAgICAgICBjb25zdCBlcnIgPSBuZXcgTW9uZ29vc2VFcnJvcihcbiAgICAgICAgICAgICdDYW5ub3QgYHNraXBNaWRkbGV3YXJlRnVuY3Rpb24oKWAgd2l0aCBhIHZhbHVlIHdoZW4gdXNpbmcgJyArXG4gICAgICAgICAgICAnYC5maW5kKCkuY3Vyc29yKClgLCB2YWx1ZSBtdXN0IGJlIG51bGxpc2ggb3IgZW1wdHkgYXJyYXksIGdvdCBcIicgK1xuICAgICAgICAgICAgdXRpbC5pbnNwZWN0KHJlc3VsdFZhbHVlKSArXG4gICAgICAgICAgICAnXCIuJ1xuICAgICAgICAgICk7XG4gICAgICAgICAgdGhpcy5fbWFya0Vycm9yKGVycik7XG4gICAgICAgICAgdGhpcy5saXN0ZW5lcnMoJ2Vycm9yJykubGVuZ3RoID4gMCAmJiB0aGlzLmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5za2lwcGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5lbWl0KCdjdXJzb3InLCBudWxsKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5fbWFya0Vycm9yKGVycik7XG4gICAgICB0aGlzLmxpc3RlbmVycygnZXJyb3InKS5sZW5ndGggPiAwICYmIHRoaXMuZW1pdCgnZXJyb3InLCBlcnIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBPYmplY3QuYXNzaWduKHRoaXMub3B0aW9ucywgcXVlcnkuX29wdGlvbnNGb3JFeGVjKCkpO1xuICAgIHRoaXMuX3RyYW5zZm9ybXMgPSB0aGlzLl90cmFuc2Zvcm1zLmNvbmNhdChxdWVyeS5fdHJhbnNmb3Jtcy5zbGljZSgpKTtcbiAgICBpZiAodGhpcy5vcHRpb25zLnRyYW5zZm9ybSkge1xuICAgICAgdGhpcy5fdHJhbnNmb3Jtcy5wdXNoKHRoaXMub3B0aW9ucy50cmFuc2Zvcm0pO1xuICAgIH1cbiAgICAvLyBSZTogZ2gtODAzOSwgeW91IG5lZWQgdG8gc2V0IHRoZSBgY3Vyc29yLmJhdGNoU2l6ZWAgb3B0aW9uLCB0b3AtbGV2ZWxcbiAgICAvLyBgYmF0Y2hTaXplYCBvcHRpb24gZG9lc24ndCB3b3JrLlxuICAgIGlmICh0aGlzLm9wdGlvbnMuYmF0Y2hTaXplKSB7XG4gICAgICAvLyBNYXggb3V0IHRoZSBudW1iZXIgb2YgZG9jdW1lbnRzIHdlJ2xsIHBvcHVsYXRlIGluIHBhcmFsbGVsIGF0IDUwMDAuXG4gICAgICB0aGlzLm9wdGlvbnMuX3BvcHVsYXRlQmF0Y2hTaXplID0gTWF0aC5taW4odGhpcy5vcHRpb25zLmJhdGNoU2l6ZSwgNTAwMCk7XG4gICAgfVxuXG4gICAgaWYgKG1vZGVsLmNvbGxlY3Rpb24uX3Nob3VsZEJ1ZmZlckNvbW1hbmRzKCkgJiYgbW9kZWwuY29sbGVjdGlvbi5idWZmZXIpIHtcbiAgICAgIG1vZGVsLmNvbGxlY3Rpb24ucXVldWUucHVzaChbXG4gICAgICAgICgpID0+IF9nZXRSYXdDdXJzb3IocXVlcnksIHRoaXMpXG4gICAgICBdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgX2dldFJhd0N1cnNvcihxdWVyeSwgdGhpcyk7XG4gICAgfVxuICB9KTtcbn1cblxudXRpbC5pbmhlcml0cyhRdWVyeUN1cnNvciwgUmVhZGFibGUpO1xuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cbmZ1bmN0aW9uIF9nZXRSYXdDdXJzb3IocXVlcnksIHF1ZXJ5Q3Vyc29yKSB7XG4gIHRyeSB7XG4gICAgY29uc3QgY3Vyc29yID0gcXVlcnkubW9kZWwuY29sbGVjdGlvbi5maW5kKHF1ZXJ5Ll9jb25kaXRpb25zLCBxdWVyeUN1cnNvci5vcHRpb25zKTtcbiAgICBxdWVyeUN1cnNvci5jdXJzb3IgPSBjdXJzb3I7XG4gICAgcXVlcnlDdXJzb3IuZW1pdCgnY3Vyc29yJywgY3Vyc29yKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgcXVlcnlDdXJzb3IuX21hcmtFcnJvcihlcnIpO1xuICAgIHF1ZXJ5Q3Vyc29yLmxpc3RlbmVycygnZXJyb3InKS5sZW5ndGggPiAwICYmIHF1ZXJ5Q3Vyc29yLmVtaXQoJ2Vycm9yJywgcXVlcnlDdXJzb3IuX2Vycm9yKTtcbiAgfVxufVxuXG4vKipcbiAqIE5lY2Vzc2FyeSB0byBzYXRpc2Z5IHRoZSBSZWFkYWJsZSBBUElcbiAqIEBtZXRob2QgX3JlYWRcbiAqIEBtZW1iZXJPZiBRdWVyeUN1cnNvclxuICogQGluc3RhbmNlXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5RdWVyeUN1cnNvci5wcm90b3R5cGUuX3JlYWQgPSBmdW5jdGlvbigpIHtcbiAgX25leHQodGhpcywgKGVycm9yLCBkb2MpID0+IHtcbiAgICBpZiAoZXJyb3IpIHtcbiAgICAgIHJldHVybiB0aGlzLmVtaXQoJ2Vycm9yJywgZXJyb3IpO1xuICAgIH1cbiAgICBpZiAoIWRvYykge1xuICAgICAgdGhpcy5wdXNoKG51bGwpO1xuICAgICAgdGhpcy5jdXJzb3IuY2xvc2UoZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZW1pdCgnZXJyb3InLCBlcnJvcik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnB1c2goZG9jKTtcbiAgfSk7XG59O1xuXG4vKipcbiAqIFJlZ2lzdGVycyBhIHRyYW5zZm9ybSBmdW5jdGlvbiB3aGljaCBzdWJzZXF1ZW50bHkgbWFwcyBkb2N1bWVudHMgcmV0cmlldmVkXG4gKiB2aWEgdGhlIHN0cmVhbXMgaW50ZXJmYWNlIG9yIGAubmV4dCgpYFxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgLy8gTWFwIGRvY3VtZW50cyByZXR1cm5lZCBieSBgZGF0YWAgZXZlbnRzXG4gKiAgICAgVGhpbmcuXG4gKiAgICAgICBmaW5kKHsgbmFtZTogL15oZWxsby8gfSkuXG4gKiAgICAgICBjdXJzb3IoKS5cbiAqICAgICAgIG1hcChmdW5jdGlvbiAoZG9jKSB7XG4gKiAgICAgICAgZG9jLmZvbyA9IFwiYmFyXCI7XG4gKiAgICAgICAgcmV0dXJuIGRvYztcbiAqICAgICAgIH0pXG4gKiAgICAgICBvbignZGF0YScsIGZ1bmN0aW9uKGRvYykgeyBjb25zb2xlLmxvZyhkb2MuZm9vKTsgfSk7XG4gKlxuICogICAgIC8vIE9yIG1hcCBkb2N1bWVudHMgcmV0dXJuZWQgYnkgYC5uZXh0KClgXG4gKiAgICAgY29uc3QgY3Vyc29yID0gVGhpbmcuZmluZCh7IG5hbWU6IC9eaGVsbG8vIH0pLlxuICogICAgICAgY3Vyc29yKCkuXG4gKiAgICAgICBtYXAoZnVuY3Rpb24gKGRvYykge1xuICogICAgICAgICBkb2MuZm9vID0gXCJiYXJcIjtcbiAqICAgICAgICAgcmV0dXJuIGRvYztcbiAqICAgICAgIH0pO1xuICogICAgIGN1cnNvci5uZXh0KGZ1bmN0aW9uKGVycm9yLCBkb2MpIHtcbiAqICAgICAgIGNvbnNvbGUubG9nKGRvYy5mb28pO1xuICogICAgIH0pO1xuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKiBAcmV0dXJuIHtRdWVyeUN1cnNvcn1cbiAqIEBtZW1iZXJPZiBRdWVyeUN1cnNvclxuICogQGFwaSBwdWJsaWNcbiAqIEBtZXRob2QgbWFwXG4gKi9cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFF1ZXJ5Q3Vyc29yLnByb3RvdHlwZSwgJ21hcCcsIHtcbiAgdmFsdWU6IGZ1bmN0aW9uKGZuKSB7XG4gICAgdGhpcy5fdHJhbnNmb3Jtcy5wdXNoKGZuKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgY29uZmlndXJhYmxlOiB0cnVlLFxuICB3cml0YWJsZTogdHJ1ZVxufSk7XG5cbi8qKlxuICogTWFya3MgdGhpcyBjdXJzb3IgYXMgZXJyb3JlZFxuICogQG1ldGhvZCBfbWFya0Vycm9yXG4gKiBAbWVtYmVyT2YgUXVlcnlDdXJzb3JcbiAqIEBpbnN0YW5jZVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuUXVlcnlDdXJzb3IucHJvdG90eXBlLl9tYXJrRXJyb3IgPSBmdW5jdGlvbihlcnJvcikge1xuICB0aGlzLl9lcnJvciA9IGVycm9yO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogTWFya3MgdGhpcyBjdXJzb3IgYXMgY2xvc2VkLiBXaWxsIHN0b3Agc3RyZWFtaW5nIGFuZCBzdWJzZXF1ZW50IGNhbGxzIHRvXG4gKiBgbmV4dCgpYCB3aWxsIGVycm9yLlxuICpcbiAqIEByZXR1cm4ge1Byb21pc2V9XG4gKiBAYXBpIHB1YmxpY1xuICogQG1ldGhvZCBjbG9zZVxuICogQGVtaXRzIGNsb3NlXG4gKiBAc2VlIEFnZ3JlZ2F0aW9uQ3Vyc29yLmNsb3NlIGh0dHBzOi8vbW9uZ29kYi5naXRodWIuaW8vbm9kZS1tb25nb2RiLW5hdGl2ZS80LjkvY2xhc3Nlcy9BZ2dyZWdhdGlvbkN1cnNvci5odG1sI2Nsb3NlXG4gKi9cblxuUXVlcnlDdXJzb3IucHJvdG90eXBlLmNsb3NlID0gYXN5bmMgZnVuY3Rpb24gY2xvc2UoKSB7XG4gIGlmICh0eXBlb2YgYXJndW1lbnRzWzBdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IE1vbmdvb3NlRXJyb3IoJ1F1ZXJ5Q3Vyc29yLnByb3RvdHlwZS5jbG9zZSgpIG5vIGxvbmdlciBhY2NlcHRzIGEgY2FsbGJhY2snKTtcbiAgfVxuICB0cnkge1xuICAgIGF3YWl0IHRoaXMuY3Vyc29yLmNsb3NlKCk7XG4gICAgdGhpcy5lbWl0KCdjbG9zZScpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHRoaXMubGlzdGVuZXJzKCdlcnJvcicpLmxlbmd0aCA+IDAgJiYgdGhpcy5lbWl0KCdlcnJvcicsIGVycm9yKTtcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxufTtcblxuLyoqXG4gKiBSZXdpbmQgdGhpcyBjdXJzb3IgdG8gaXRzIHVuaW5pdGlhbGl6ZWQgc3RhdGUuIEFueSBvcHRpb25zIHRoYXQgYXJlIHByZXNlbnQgb24gdGhlIGN1cnNvciB3aWxsXG4gKiByZW1haW4gaW4gZWZmZWN0LiBJdGVyYXRpbmcgdGhpcyBjdXJzb3Igd2lsbCBjYXVzZSBuZXcgcXVlcmllcyB0byBiZSBzZW50IHRvIHRoZSBzZXJ2ZXIsIGV2ZW5cbiAqIGlmIHRoZSByZXN1bHRhbnQgZGF0YSBoYXMgYWxyZWFkeSBiZWVuIHJldHJpZXZlZCBieSB0aGlzIGN1cnNvci5cbiAqXG4gKiBAcmV0dXJuIHtBZ2dyZWdhdGlvbkN1cnNvcn0gdGhpc1xuICogQGFwaSBwdWJsaWNcbiAqIEBtZXRob2QgcmV3aW5kXG4gKi9cblxuUXVlcnlDdXJzb3IucHJvdG90eXBlLnJld2luZCA9IGZ1bmN0aW9uKCkge1xuICBfd2FpdEZvckN1cnNvcih0aGlzLCAoKSA9PiB7XG4gICAgdGhpcy5jdXJzb3IucmV3aW5kKCk7XG4gIH0pO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogR2V0IHRoZSBuZXh0IGRvY3VtZW50IGZyb20gdGhpcyBjdXJzb3IuIFdpbGwgcmV0dXJuIGBudWxsYCB3aGVuIHRoZXJlIGFyZVxuICogbm8gZG9jdW1lbnRzIGxlZnQuXG4gKlxuICogQHJldHVybiB7UHJvbWlzZX1cbiAqIEBhcGkgcHVibGljXG4gKiBAbWV0aG9kIG5leHRcbiAqL1xuXG5RdWVyeUN1cnNvci5wcm90b3R5cGUubmV4dCA9IGFzeW5jIGZ1bmN0aW9uIG5leHQoKSB7XG4gIGlmICh0eXBlb2YgYXJndW1lbnRzWzBdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IE1vbmdvb3NlRXJyb3IoJ1F1ZXJ5Q3Vyc29yLnByb3RvdHlwZS5uZXh0KCkgbm8gbG9uZ2VyIGFjY2VwdHMgYSBjYWxsYmFjaycpO1xuICB9XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgX25leHQodGhpcywgZnVuY3Rpb24oZXJyb3IsIGRvYykge1xuICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgIHJldHVybiByZWplY3QoZXJyb3IpO1xuICAgICAgfVxuICAgICAgcmVzb2x2ZShkb2MpO1xuICAgIH0pO1xuICB9KTtcbn07XG5cbi8qKlxuICogRXhlY3V0ZSBgZm5gIGZvciBldmVyeSBkb2N1bWVudCBpbiB0aGUgY3Vyc29yLiBJZiBgZm5gIHJldHVybnMgYSBwcm9taXNlLFxuICogd2lsbCB3YWl0IGZvciB0aGUgcHJvbWlzZSB0byByZXNvbHZlIGJlZm9yZSBpdGVyYXRpbmcgb24gdG8gdGhlIG5leHQgb25lLlxuICogUmV0dXJucyBhIHByb21pc2UgdGhhdCByZXNvbHZlcyB3aGVuIGRvbmUuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICAvLyBJdGVyYXRlIG92ZXIgZG9jdW1lbnRzIGFzeW5jaHJvbm91c2x5XG4gKiAgICAgVGhpbmcuXG4gKiAgICAgICBmaW5kKHsgbmFtZTogL15oZWxsby8gfSkuXG4gKiAgICAgICBjdXJzb3IoKS5cbiAqICAgICAgIGVhY2hBc3luYyhhc3luYyBmdW5jdGlvbiAoZG9jLCBpKSB7XG4gKiAgICAgICAgIGRvYy5mb28gPSBkb2MuYmFyICsgaTtcbiAqICAgICAgICAgYXdhaXQgZG9jLnNhdmUoKTtcbiAqICAgICAgIH0pXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5wYXJhbGxlbF0gdGhlIG51bWJlciBvZiBwcm9taXNlcyB0byBleGVjdXRlIGluIHBhcmFsbGVsLiBEZWZhdWx0cyB0byAxLlxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmJhdGNoU2l6ZV0gaWYgc2V0LCB3aWxsIGNhbGwgYGZuKClgIHdpdGggYXJyYXlzIG9mIGRvY3VtZW50cyB3aXRoIGxlbmd0aCBhdCBtb3N0IGBiYXRjaFNpemVgXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmNvbnRpbnVlT25FcnJvcj1mYWxzZV0gaWYgdHJ1ZSwgYGVhY2hBc3luYygpYCBpdGVyYXRlcyB0aHJvdWdoIGFsbCBkb2NzIGV2ZW4gaWYgYGZuYCB0aHJvd3MgYW4gZXJyb3IuIElmIGZhbHNlLCBgZWFjaEFzeW5jKClgIHRocm93cyBhbiBlcnJvciBpbW1lZGlhdGVseSBpZiB0aGUgZ2l2ZW4gZnVuY3Rpb24gYGZuKClgIHRocm93cyBhbiBlcnJvci5cbiAqIEByZXR1cm4ge1Byb21pc2V9XG4gKiBAYXBpIHB1YmxpY1xuICogQG1ldGhvZCBlYWNoQXN5bmNcbiAqL1xuXG5RdWVyeUN1cnNvci5wcm90b3R5cGUuZWFjaEFzeW5jID0gZnVuY3Rpb24oZm4sIG9wdHMpIHtcbiAgaWYgKHR5cGVvZiBhcmd1bWVudHNbMl0gPT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgTW9uZ29vc2VFcnJvcignUXVlcnlDdXJzb3IucHJvdG90eXBlLmVhY2hBc3luYygpIG5vIGxvbmdlciBhY2NlcHRzIGEgY2FsbGJhY2snKTtcbiAgfVxuICBpZiAodHlwZW9mIG9wdHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBvcHRzID0ge307XG4gIH1cbiAgb3B0cyA9IG9wdHMgfHwge307XG5cbiAgcmV0dXJuIGVhY2hBc3luYygoY2IpID0+IF9uZXh0KHRoaXMsIGNiKSwgZm4sIG9wdHMpO1xufTtcblxuLyoqXG4gKiBUaGUgYG9wdGlvbnNgIHBhc3NlZCBpbiB0byB0aGUgYFF1ZXJ5Q3Vyc29yYCBjb25zdHJ1Y3Rvci5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICogQHByb3BlcnR5IG9wdGlvbnNcbiAqL1xuXG5RdWVyeUN1cnNvci5wcm90b3R5cGUub3B0aW9ucztcblxuLyoqXG4gKiBBZGRzIGEgW2N1cnNvciBmbGFnXShodHRwczovL21vbmdvZGIuZ2l0aHViLmlvL25vZGUtbW9uZ29kYi1uYXRpdmUvNC45L2NsYXNzZXMvRmluZEN1cnNvci5odG1sI2FkZEN1cnNvckZsYWcpLlxuICogVXNlZnVsIGZvciBzZXR0aW5nIHRoZSBgbm9DdXJzb3JUaW1lb3V0YCBhbmQgYHRhaWxhYmxlYCBmbGFncy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZmxhZ1xuICogQHBhcmFtIHtCb29sZWFufSB2YWx1ZVxuICogQHJldHVybiB7QWdncmVnYXRpb25DdXJzb3J9IHRoaXNcbiAqIEBhcGkgcHVibGljXG4gKiBAbWV0aG9kIGFkZEN1cnNvckZsYWdcbiAqL1xuXG5RdWVyeUN1cnNvci5wcm90b3R5cGUuYWRkQ3Vyc29yRmxhZyA9IGZ1bmN0aW9uKGZsYWcsIHZhbHVlKSB7XG4gIF93YWl0Rm9yQ3Vyc29yKHRoaXMsICgpID0+IHtcbiAgICB0aGlzLmN1cnNvci5hZGRDdXJzb3JGbGFnKGZsYWcsIHZhbHVlKTtcbiAgfSk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5RdWVyeUN1cnNvci5wcm90b3R5cGUudHJhbnNmb3JtTnVsbCA9IGZ1bmN0aW9uKHZhbCkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgIHZhbCA9IHRydWU7XG4gIH1cbiAgdGhpcy5fbW9uZ29vc2VPcHRpb25zLnRyYW5zZm9ybU51bGwgPSB2YWw7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5RdWVyeUN1cnNvci5wcm90b3R5cGUuX3RyYW5zZm9ybUZvckFzeW5jSXRlcmF0b3IgPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMuX3RyYW5zZm9ybXMuaW5kZXhPZihfdHJhbnNmb3JtRm9yQXN5bmNJdGVyYXRvcikgPT09IC0xKSB7XG4gICAgdGhpcy5tYXAoX3RyYW5zZm9ybUZvckFzeW5jSXRlcmF0b3IpO1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIGFuIGFzeW5jSXRlcmF0b3IgZm9yIHVzZSB3aXRoIFtgZm9yL2F3YWl0L29mYCBsb29wc10oaHR0cHM6Ly90aGVjb2RlYmFyYmFyaWFuLmNvbS9nZXR0aW5nLXN0YXJ0ZWQtd2l0aC1hc3luYy1pdGVyYXRvcnMtaW4tbm9kZS1qcykuXG4gKiBZb3UgZG8gbm90IG5lZWQgdG8gY2FsbCB0aGlzIGZ1bmN0aW9uIGV4cGxpY2l0bHksIHRoZSBKYXZhU2NyaXB0IHJ1bnRpbWVcbiAqIHdpbGwgY2FsbCBpdCBmb3IgeW91LlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgLy8gV29ya3Mgd2l0aG91dCB1c2luZyBgY3Vyc29yKClgXG4gKiAgICAgZm9yIGF3YWl0IChjb25zdCBkb2Mgb2YgTW9kZWwuZmluZChbeyAkc29ydDogeyBuYW1lOiAxIH0gfV0pKSB7XG4gKiAgICAgICBjb25zb2xlLmxvZyhkb2MubmFtZSk7XG4gKiAgICAgfVxuICpcbiAqICAgICAvLyBDYW4gYWxzbyB1c2UgYGN1cnNvcigpYFxuICogICAgIGZvciBhd2FpdCAoY29uc3QgZG9jIG9mIE1vZGVsLmZpbmQoW3sgJHNvcnQ6IHsgbmFtZTogMSB9IH1dKS5jdXJzb3IoKSkge1xuICogICAgICAgY29uc29sZS5sb2coZG9jLm5hbWUpO1xuICogICAgIH1cbiAqXG4gKiBOb2RlLmpzIDEwLnggc3VwcG9ydHMgYXN5bmMgaXRlcmF0b3JzIG5hdGl2ZWx5IHdpdGhvdXQgYW55IGZsYWdzLiBZb3UgY2FuXG4gKiBlbmFibGUgYXN5bmMgaXRlcmF0b3JzIGluIE5vZGUuanMgOC54IHVzaW5nIHRoZSBbYC0taGFybW9ueV9hc3luY19pdGVyYXRpb25gIGZsYWddKGh0dHBzOi8vZ2l0aHViLmNvbS90YzM5L3Byb3Bvc2FsLWFzeW5jLWl0ZXJhdGlvbi9pc3N1ZXMvMTE3I2lzc3VlY29tbWVudC0zNDY2OTUxODcpLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIGZ1bmN0aW9uIGlzIG5vdCBpZiBgU3ltYm9sLmFzeW5jSXRlcmF0b3JgIGlzIHVuZGVmaW5lZC4gSWZcbiAqIGBTeW1ib2wuYXN5bmNJdGVyYXRvcmAgaXMgdW5kZWZpbmVkLCB0aGF0IG1lYW5zIHlvdXIgTm9kZS5qcyB2ZXJzaW9uIGRvZXMgbm90XG4gKiBzdXBwb3J0IGFzeW5jIGl0ZXJhdG9ycy5cbiAqXG4gKiBAbWV0aG9kIFtTeW1ib2wuYXN5bmNJdGVyYXRvcl1cbiAqIEBtZW1iZXJPZiBRdWVyeUN1cnNvclxuICogQGluc3RhbmNlXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmlmIChTeW1ib2wuYXN5bmNJdGVyYXRvciAhPSBudWxsKSB7XG4gIFF1ZXJ5Q3Vyc29yLnByb3RvdHlwZVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm1OdWxsKCkuX3RyYW5zZm9ybUZvckFzeW5jSXRlcmF0b3IoKTtcbiAgfTtcbn1cblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5mdW5jdGlvbiBfdHJhbnNmb3JtRm9yQXN5bmNJdGVyYXRvcihkb2MpIHtcbiAgcmV0dXJuIGRvYyA9PSBudWxsID8geyBkb25lOiB0cnVlIH0gOiB7IHZhbHVlOiBkb2MsIGRvbmU6IGZhbHNlIH07XG59XG5cbi8qKlxuICogR2V0IHRoZSBuZXh0IGRvYyBmcm9tIHRoZSB1bmRlcmx5aW5nIGN1cnNvciBhbmQgbW9uZ29vc2VpZnkgaXRcbiAqIChwb3B1bGF0ZSwgZXRjLilcbiAqIEBwYXJhbSB7QW55fSBjdHhcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNiXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBfbmV4dChjdHgsIGNiKSB7XG4gIGxldCBjYWxsYmFjayA9IGNiO1xuICBpZiAoY3R4Ll90cmFuc2Zvcm1zLmxlbmd0aCkge1xuICAgIGNhbGxiYWNrID0gZnVuY3Rpb24oZXJyLCBkb2MpIHtcbiAgICAgIGlmIChlcnIgfHwgKGRvYyA9PT0gbnVsbCAmJiAhY3R4Ll9tb25nb29zZU9wdGlvbnMudHJhbnNmb3JtTnVsbCkpIHtcbiAgICAgICAgcmV0dXJuIGNiKGVyciwgZG9jKTtcbiAgICAgIH1cbiAgICAgIGNiKGVyciwgY3R4Ll90cmFuc2Zvcm1zLnJlZHVjZShmdW5jdGlvbihkb2MsIGZuKSB7XG4gICAgICAgIHJldHVybiBmbi5jYWxsKGN0eCwgZG9jKTtcbiAgICAgIH0sIGRvYykpO1xuICAgIH07XG4gIH1cblxuICBpZiAoY3R4Ll9lcnJvcikge1xuICAgIHJldHVybiBpbW1lZGlhdGUoZnVuY3Rpb24oKSB7XG4gICAgICBjYWxsYmFjayhjdHguX2Vycm9yKTtcbiAgICB9KTtcbiAgfVxuICBpZiAoY3R4LnNraXBwZWQpIHtcbiAgICByZXR1cm4gaW1tZWRpYXRlKCgpID0+IGNhbGxiYWNrKG51bGwsIG51bGwpKTtcbiAgfVxuXG4gIGlmIChjdHguY3Vyc29yKSB7XG4gICAgaWYgKGN0eC5xdWVyeS5fbW9uZ29vc2VPcHRpb25zLnBvcHVsYXRlICYmICFjdHguX3BvcCkge1xuICAgICAgY3R4Ll9wb3AgPSBoZWxwZXJzLnByZXBhcmVQb3B1bGF0aW9uT3B0aW9uc01RKGN0eC5xdWVyeSxcbiAgICAgICAgY3R4LnF1ZXJ5Ll9tb25nb29zZU9wdGlvbnMpO1xuICAgICAgY3R4Ll9wb3AuX19ub1Byb21pc2UgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAoY3R4LnF1ZXJ5Ll9tb25nb29zZU9wdGlvbnMucG9wdWxhdGUgJiYgY3R4Lm9wdGlvbnMuX3BvcHVsYXRlQmF0Y2hTaXplID4gMSkge1xuICAgICAgaWYgKGN0eC5fYmF0Y2hEb2NzICYmIGN0eC5fYmF0Y2hEb2NzLmxlbmd0aCkge1xuICAgICAgICAvLyBSZXR1cm4gYSBjYWNoZWQgcG9wdWxhdGVkIGRvY1xuICAgICAgICByZXR1cm4gX25leHREb2MoY3R4LCBjdHguX2JhdGNoRG9jcy5zaGlmdCgpLCBjdHguX3BvcCwgY2FsbGJhY2spO1xuICAgICAgfSBlbHNlIGlmIChjdHguX2JhdGNoRXhoYXVzdGVkKSB7XG4gICAgICAgIC8vIEludGVybmFsIGN1cnNvciByZXBvcnRlZCBubyBtb3JlIGRvY3MuIEFjdCB0aGUgc2FtZSBoZXJlXG4gICAgICAgIHJldHVybiBjYWxsYmFjayhudWxsLCBudWxsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFJlcXVlc3QgYXMgbWFueSBkb2NzIGFzIGJhdGNoU2l6ZSwgdG8gcG9wdWxhdGUgdGhlbSBhbHNvIGluIGJhdGNoXG4gICAgICAgIGN0eC5fYmF0Y2hEb2NzID0gW107XG4gICAgICAgIGN0eC5jdXJzb3IubmV4dCgpLnRoZW4oXG4gICAgICAgICAgcmVzID0+IHsgX29uTmV4dC5jYWxsKHsgY3R4LCBjYWxsYmFjayB9LCBudWxsLCByZXMpOyB9LFxuICAgICAgICAgIGVyciA9PiB7IF9vbk5leHQuY2FsbCh7IGN0eCwgY2FsbGJhY2sgfSwgZXJyKTsgfVxuICAgICAgICApO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBjdHguY3Vyc29yLm5leHQoKS50aGVuKFxuICAgICAgICBkb2MgPT4ge1xuICAgICAgICAgIGlmICghZG9jKSB7XG4gICAgICAgICAgICBjYWxsYmFjayhudWxsLCBudWxsKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoIWN0eC5xdWVyeS5fbW9uZ29vc2VPcHRpb25zLnBvcHVsYXRlKSB7XG4gICAgICAgICAgICByZXR1cm4gX25leHREb2MoY3R4LCBkb2MsIG51bGwsIGNhbGxiYWNrKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjdHgucXVlcnkubW9kZWwucG9wdWxhdGUoZG9jLCBjdHguX3BvcCkudGhlbihcbiAgICAgICAgICAgIGRvYyA9PiB7XG4gICAgICAgICAgICAgIF9uZXh0RG9jKGN0eCwgZG9jLCBjdHguX3BvcCwgY2FsbGJhY2spO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVyciA9PiB7XG4gICAgICAgICAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgKTtcbiAgICAgICAgfSxcbiAgICAgICAgZXJyb3IgPT4ge1xuICAgICAgICAgIGNhbGxiYWNrKGVycm9yKTtcbiAgICAgICAgfVxuICAgICAgKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgY3R4Lm9uY2UoJ2Vycm9yJywgY2IpO1xuXG4gICAgY3R4Lm9uY2UoJ2N1cnNvcicsIGZ1bmN0aW9uKGN1cnNvcikge1xuICAgICAgY3R4LnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIGNiKTtcbiAgICAgIGlmIChjdXJzb3IgPT0gbnVsbCkge1xuICAgICAgICBpZiAoY3R4LnNraXBwZWQpIHtcbiAgICAgICAgICByZXR1cm4gY2IobnVsbCwgbnVsbCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgX25leHQoY3R4LCBjYik7XG4gICAgfSk7XG4gIH1cbn1cblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5mdW5jdGlvbiBfb25OZXh0KGVycm9yLCBkb2MpIHtcbiAgaWYgKGVycm9yKSB7XG4gICAgcmV0dXJuIHRoaXMuY2FsbGJhY2soZXJyb3IpO1xuICB9XG4gIGlmICghZG9jKSB7XG4gICAgdGhpcy5jdHguX2JhdGNoRXhoYXVzdGVkID0gdHJ1ZTtcbiAgICByZXR1cm4gX3BvcHVsYXRlQmF0Y2guY2FsbCh0aGlzKTtcbiAgfVxuXG4gIHRoaXMuY3R4Ll9iYXRjaERvY3MucHVzaChkb2MpO1xuXG4gIGlmICh0aGlzLmN0eC5fYmF0Y2hEb2NzLmxlbmd0aCA8IHRoaXMuY3R4Lm9wdGlvbnMuX3BvcHVsYXRlQmF0Y2hTaXplKSB7XG4gICAgLy8gSWYgYm90aCBgYmF0Y2hTaXplYCBhbmQgYF9wb3B1bGF0ZUJhdGNoU2l6ZWAgYXJlIGh1Z2UsIGNhbGxpbmcgYG5leHQoKWAgcmVwZWF0ZWRseSBtYXlcbiAgICAvLyBjYXVzZSBhIHN0YWNrIG92ZXJmbG93LiBTbyBtYWtlIHN1cmUgd2UgY2xlYXIgdGhlIHN0YWNrIHJlZ3VsYXJseS5cbiAgICBpZiAodGhpcy5jdHguX2JhdGNoRG9jcy5sZW5ndGggPiAwICYmIHRoaXMuY3R4Ll9iYXRjaERvY3MubGVuZ3RoICUgMTAwMCA9PT0gMCkge1xuICAgICAgcmV0dXJuIGltbWVkaWF0ZSgoKSA9PiB0aGlzLmN0eC5jdXJzb3IubmV4dCgpLnRoZW4oXG4gICAgICAgIHJlcyA9PiB7IF9vbk5leHQuY2FsbCh0aGlzLCBudWxsLCByZXMpOyB9LFxuICAgICAgICBlcnIgPT4geyBfb25OZXh0LmNhbGwodGhpcywgZXJyKTsgfVxuICAgICAgKSk7XG4gICAgfVxuICAgIHRoaXMuY3R4LmN1cnNvci5uZXh0KCkudGhlbihcbiAgICAgIHJlcyA9PiB7IF9vbk5leHQuY2FsbCh0aGlzLCBudWxsLCByZXMpOyB9LFxuICAgICAgZXJyID0+IHsgX29uTmV4dC5jYWxsKHRoaXMsIGVycik7IH1cbiAgICApO1xuICB9IGVsc2Uge1xuICAgIF9wb3B1bGF0ZUJhdGNoLmNhbGwodGhpcyk7XG4gIH1cbn1cblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5mdW5jdGlvbiBfcG9wdWxhdGVCYXRjaCgpIHtcbiAgaWYgKCF0aGlzLmN0eC5fYmF0Y2hEb2NzLmxlbmd0aCkge1xuICAgIHJldHVybiB0aGlzLmNhbGxiYWNrKG51bGwsIG51bGwpO1xuICB9XG4gIHRoaXMuY3R4LnF1ZXJ5Lm1vZGVsLnBvcHVsYXRlKHRoaXMuY3R4Ll9iYXRjaERvY3MsIHRoaXMuY3R4Ll9wb3ApLnRoZW4oXG4gICAgKCkgPT4ge1xuICAgICAgX25leHREb2ModGhpcy5jdHgsIHRoaXMuY3R4Ll9iYXRjaERvY3Muc2hpZnQoKSwgdGhpcy5jdHguX3BvcCwgdGhpcy5jYWxsYmFjayk7XG4gICAgfSxcbiAgICBlcnIgPT4ge1xuICAgICAgdGhpcy5jYWxsYmFjayhlcnIpO1xuICAgIH1cbiAgKTtcbn1cblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5mdW5jdGlvbiBfbmV4dERvYyhjdHgsIGRvYywgcG9wLCBjYWxsYmFjaykge1xuICBpZiAoY3R4LnF1ZXJ5Ll9tb25nb29zZU9wdGlvbnMubGVhbikge1xuICAgIHJldHVybiBjdHgubW9kZWwuaG9va3MuZXhlY1Bvc3QoJ2ZpbmQnLCBjdHgucXVlcnksIFtbZG9jXV0sIGVyciA9PiB7XG4gICAgICBpZiAoZXJyICE9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgICB9XG4gICAgICBjYWxsYmFjayhudWxsLCBkb2MpO1xuICAgIH0pO1xuICB9XG5cbiAgY29uc3QgeyBtb2RlbCwgX2ZpZWxkcywgX3VzZXJQcm92aWRlZEZpZWxkcywgb3B0aW9ucyB9ID0gY3R4LnF1ZXJ5O1xuICBoZWxwZXJzLmNyZWF0ZU1vZGVsQW5kSW5pdChtb2RlbCwgZG9jLCBfZmllbGRzLCBfdXNlclByb3ZpZGVkRmllbGRzLCBvcHRpb25zLCBwb3AsIChlcnIsIGRvYykgPT4ge1xuICAgIGlmIChlcnIgIT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgfVxuICAgIGN0eC5tb2RlbC5ob29rcy5leGVjUG9zdCgnZmluZCcsIGN0eC5xdWVyeSwgW1tkb2NdXSwgZXJyID0+IHtcbiAgICAgIGlmIChlcnIgIT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICAgIH1cbiAgICAgIGNhbGxiYWNrKG51bGwsIGRvYyk7XG4gICAgfSk7XG4gIH0pO1xufVxuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cbmZ1bmN0aW9uIF93YWl0Rm9yQ3Vyc29yKGN0eCwgY2IpIHtcbiAgaWYgKGN0eC5jdXJzb3IpIHtcbiAgICByZXR1cm4gY2IoKTtcbiAgfVxuICBjdHgub25jZSgnY3Vyc29yJywgZnVuY3Rpb24oY3Vyc29yKSB7XG4gICAgaWYgKGN1cnNvciA9PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNiKCk7XG4gIH0pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFF1ZXJ5Q3Vyc29yO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../server/node_modules/mongoose/lib/cursor/queryCursor.js\n");

/***/ }),

/***/ "../server/node_modules/mongoose/lib/document.js":
/*!*******************************************************!*\
  !*** ../server/node_modules/mongoose/lib/document.js ***!
  \*******************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("\n\n/*!\n * Module dependencies.\n */\n\nconst EventEmitter = (__webpack_require__(/*! events */ \"events\").EventEmitter);\nconst InternalCache = __webpack_require__(/*! ./internal */ \"../server/node_modules/mongoose/lib/internal.js\");\nconst MongooseError = __webpack_require__(/*! ./error/index */ \"../server/node_modules/mongoose/lib/error/index.js\");\nconst MixedSchema = __webpack_require__(/*! ./schema/mixed */ \"../server/node_modules/mongoose/lib/schema/mixed.js\");\nconst ObjectExpectedError = __webpack_require__(/*! ./error/objectExpected */ \"../server/node_modules/mongoose/lib/error/objectExpected.js\");\nconst ObjectParameterError = __webpack_require__(/*! ./error/objectParameter */ \"../server/node_modules/mongoose/lib/error/objectParameter.js\");\nconst ParallelValidateError = __webpack_require__(/*! ./error/parallelValidate */ \"../server/node_modules/mongoose/lib/error/parallelValidate.js\");\nconst Schema = __webpack_require__(/*! ./schema */ \"../server/node_modules/mongoose/lib/schema.js\");\nconst StrictModeError = __webpack_require__(/*! ./error/strict */ \"../server/node_modules/mongoose/lib/error/strict.js\");\nconst ValidationError = __webpack_require__(/*! ./error/validation */ \"../server/node_modules/mongoose/lib/error/validation.js\");\nconst ValidatorError = __webpack_require__(/*! ./error/validator */ \"../server/node_modules/mongoose/lib/error/validator.js\");\nconst $__hasIncludedChildren = __webpack_require__(/*! ./helpers/projection/hasIncludedChildren */ \"../server/node_modules/mongoose/lib/helpers/projection/hasIncludedChildren.js\");\nconst applyDefaults = __webpack_require__(/*! ./helpers/document/applyDefaults */ \"../server/node_modules/mongoose/lib/helpers/document/applyDefaults.js\");\nconst cleanModifiedSubpaths = __webpack_require__(/*! ./helpers/document/cleanModifiedSubpaths */ \"../server/node_modules/mongoose/lib/helpers/document/cleanModifiedSubpaths.js\");\nconst clone = __webpack_require__(/*! ./helpers/clone */ \"../server/node_modules/mongoose/lib/helpers/clone.js\");\nconst compile = (__webpack_require__(/*! ./helpers/document/compile */ \"../server/node_modules/mongoose/lib/helpers/document/compile.js\").compile);\nconst defineKey = (__webpack_require__(/*! ./helpers/document/compile */ \"../server/node_modules/mongoose/lib/helpers/document/compile.js\").defineKey);\nconst flatten = (__webpack_require__(/*! ./helpers/common */ \"../server/node_modules/mongoose/lib/helpers/common.js\").flatten);\nconst get = __webpack_require__(/*! ./helpers/get */ \"../server/node_modules/mongoose/lib/helpers/get.js\");\nconst getEmbeddedDiscriminatorPath = __webpack_require__(/*! ./helpers/document/getEmbeddedDiscriminatorPath */ \"../server/node_modules/mongoose/lib/helpers/document/getEmbeddedDiscriminatorPath.js\");\nconst getKeysInSchemaOrder = __webpack_require__(/*! ./helpers/schema/getKeysInSchemaOrder */ \"../server/node_modules/mongoose/lib/helpers/schema/getKeysInSchemaOrder.js\");\nconst getSubdocumentStrictValue = __webpack_require__(/*! ./helpers/schema/getSubdocumentStrictValue */ \"../server/node_modules/mongoose/lib/helpers/schema/getSubdocumentStrictValue.js\");\nconst handleSpreadDoc = __webpack_require__(/*! ./helpers/document/handleSpreadDoc */ \"../server/node_modules/mongoose/lib/helpers/document/handleSpreadDoc.js\");\nconst immediate = __webpack_require__(/*! ./helpers/immediate */ \"../server/node_modules/mongoose/lib/helpers/immediate.js\");\nconst isDefiningProjection = __webpack_require__(/*! ./helpers/projection/isDefiningProjection */ \"../server/node_modules/mongoose/lib/helpers/projection/isDefiningProjection.js\");\nconst isExclusive = __webpack_require__(/*! ./helpers/projection/isExclusive */ \"../server/node_modules/mongoose/lib/helpers/projection/isExclusive.js\");\nconst inspect = (__webpack_require__(/*! util */ \"util\").inspect);\nconst internalToObjectOptions = (__webpack_require__(/*! ./options */ \"../server/node_modules/mongoose/lib/options.js\").internalToObjectOptions);\nconst markArraySubdocsPopulated = __webpack_require__(/*! ./helpers/populate/markArraySubdocsPopulated */ \"../server/node_modules/mongoose/lib/helpers/populate/markArraySubdocsPopulated.js\");\nconst minimize = __webpack_require__(/*! ./helpers/minimize */ \"../server/node_modules/mongoose/lib/helpers/minimize.js\");\nconst mpath = __webpack_require__(/*! mpath */ \"../server/node_modules/mpath/index.js\");\nconst queryhelpers = __webpack_require__(/*! ./queryHelpers */ \"../server/node_modules/mongoose/lib/queryHelpers.js\");\nconst utils = __webpack_require__(/*! ./utils */ \"../server/node_modules/mongoose/lib/utils.js\");\nconst isPromise = __webpack_require__(/*! ./helpers/isPromise */ \"../server/node_modules/mongoose/lib/helpers/isPromise.js\");\n\nconst deepEqual = utils.deepEqual;\nconst isMongooseObject = utils.isMongooseObject;\n\nconst arrayAtomicsBackupSymbol = (__webpack_require__(/*! ./helpers/symbols */ \"../server/node_modules/mongoose/lib/helpers/symbols.js\").arrayAtomicsBackupSymbol);\nconst arrayAtomicsSymbol = (__webpack_require__(/*! ./helpers/symbols */ \"../server/node_modules/mongoose/lib/helpers/symbols.js\").arrayAtomicsSymbol);\nconst documentArrayParent = (__webpack_require__(/*! ./helpers/symbols */ \"../server/node_modules/mongoose/lib/helpers/symbols.js\").documentArrayParent);\nconst documentIsModified = (__webpack_require__(/*! ./helpers/symbols */ \"../server/node_modules/mongoose/lib/helpers/symbols.js\").documentIsModified);\nconst documentModifiedPaths = (__webpack_require__(/*! ./helpers/symbols */ \"../server/node_modules/mongoose/lib/helpers/symbols.js\").documentModifiedPaths);\nconst documentSchemaSymbol = (__webpack_require__(/*! ./helpers/symbols */ \"../server/node_modules/mongoose/lib/helpers/symbols.js\").documentSchemaSymbol);\nconst getSymbol = (__webpack_require__(/*! ./helpers/symbols */ \"../server/node_modules/mongoose/lib/helpers/symbols.js\").getSymbol);\nconst populateModelSymbol = (__webpack_require__(/*! ./helpers/symbols */ \"../server/node_modules/mongoose/lib/helpers/symbols.js\").populateModelSymbol);\nconst scopeSymbol = (__webpack_require__(/*! ./helpers/symbols */ \"../server/node_modules/mongoose/lib/helpers/symbols.js\").scopeSymbol);\nconst schemaMixedSymbol = (__webpack_require__(/*! ./schema/symbols */ \"../server/node_modules/mongoose/lib/schema/symbols.js\").schemaMixedSymbol);\nconst parentPaths = __webpack_require__(/*! ./helpers/path/parentPaths */ \"../server/node_modules/mongoose/lib/helpers/path/parentPaths.js\");\nconst getDeepestSubdocumentForPath = __webpack_require__(/*! ./helpers/document/getDeepestSubdocumentForPath */ \"../server/node_modules/mongoose/lib/helpers/document/getDeepestSubdocumentForPath.js\");\nconst sessionNewDocuments = (__webpack_require__(/*! ./helpers/symbols */ \"../server/node_modules/mongoose/lib/helpers/symbols.js\").sessionNewDocuments);\n\nlet DocumentArray;\nlet MongooseArray;\nlet Embedded;\n\nconst specialProperties = utils.specialProperties;\n\n/**\n * The core Mongoose document constructor. You should not call this directly,\n * the Mongoose [Model constructor](./api/model.html#Model) calls this for you.\n *\n * @param {Object} obj the values to set\n * @param {Object} [fields] optional object containing the fields which were selected in the query returning this document and any populated paths data\n * @param {Object} [options] various configuration options for the document\n * @param {Boolean} [options.defaults=true] if `false`, skip applying default values to this document.\n * @inherits NodeJS EventEmitter https://nodejs.org/api/events.html#class-eventemitter\n * @event `init`: Emitted on a document after it has been retrieved from the db and fully hydrated by Mongoose.\n * @event `save`: Emitted when the document is successfully saved\n * @api private\n */\n\nfunction Document(obj, fields, skipId, options) {\n  if (typeof skipId === 'object' && skipId != null) {\n    options = skipId;\n    skipId = options.skipId;\n  }\n  options = Object.assign({}, options);\n\n  // Support `browserDocument.js` syntax\n  if (this.$__schema == null) {\n    const _schema = utils.isObject(fields) && !fields.instanceOfSchema ?\n      new Schema(fields) :\n      fields;\n    this.$__setSchema(_schema);\n    fields = skipId;\n    skipId = options;\n    options = arguments[4] || {};\n  }\n\n  this.$__ = new InternalCache();\n\n  // Avoid setting `isNew` to `true`, because it is `true` by default\n  if (options.isNew != null && options.isNew !== true) {\n    this.$isNew = options.isNew;\n  }\n\n  if (options.priorDoc != null) {\n    this.$__.priorDoc = options.priorDoc;\n  }\n\n  if (skipId) {\n    this.$__.skipId = skipId;\n  }\n\n  if (obj != null && typeof obj !== 'object') {\n    throw new ObjectParameterError(obj, 'obj', 'Document');\n  }\n\n  let defaults = true;\n  if (options.defaults !== undefined) {\n    this.$__.defaults = options.defaults;\n    defaults = options.defaults;\n  }\n\n  const schema = this.$__schema;\n\n  if (typeof fields === 'boolean' || fields === 'throw') {\n    if (fields !== true) {\n      this.$__.strictMode = fields;\n    }\n    fields = undefined;\n  } else if (schema.options.strict !== true) {\n    this.$__.strictMode = schema.options.strict;\n  }\n\n  const requiredPaths = schema.requiredPaths(true);\n  for (const path of requiredPaths) {\n    this.$__.activePaths.require(path);\n  }\n\n  let exclude = null;\n\n  // determine if this doc is a result of a query with\n  // excluded fields\n  if (utils.isPOJO(fields) && Object.keys(fields).length > 0) {\n    exclude = isExclusive(fields);\n    this.$__.selected = fields;\n    this.$__.exclude = exclude;\n  }\n\n  const hasIncludedChildren = exclude === false && fields ?\n    $__hasIncludedChildren(fields) :\n    null;\n\n  if (this._doc == null) {\n    this.$__buildDoc(obj, fields, skipId, exclude, hasIncludedChildren, false);\n\n    // By default, defaults get applied **before** setting initial values\n    // Re: gh-6155\n    if (defaults) {\n      applyDefaults(this, fields, exclude, hasIncludedChildren, true, null);\n    }\n  }\n  if (obj) {\n    // Skip set hooks\n    if (this.$__original_set) {\n      this.$__original_set(obj, undefined, true, options);\n    } else {\n      this.$set(obj, undefined, true, options);\n    }\n\n    if (obj instanceof Document) {\n      this.$isNew = obj.$isNew;\n    }\n  }\n\n  // Function defaults get applied **after** setting initial values so they\n  // see the full doc rather than an empty one, unless they opt out.\n  // Re: gh-3781, gh-6155\n  if (options.willInit && defaults) {\n    if (options.skipDefaults) {\n      this.$__.skipDefaults = options.skipDefaults;\n    }\n  } else if (defaults) {\n    applyDefaults(this, fields, exclude, hasIncludedChildren, false, options.skipDefaults);\n  }\n\n  if (!this.$__.strictMode && obj) {\n    const _this = this;\n    const keys = Object.keys(this._doc);\n\n    keys.forEach(function(key) {\n      // Avoid methods, virtuals, existing fields, and `$` keys. The latter is to avoid overwriting\n      // Mongoose internals.\n      if (!(key in schema.tree) && !(key in schema.methods) && !(key in schema.virtuals) && !key.startsWith('$')) {\n        defineKey({ prop: key, subprops: null, prototype: _this });\n      }\n    });\n  }\n\n  applyQueue(this);\n}\n\nDocument.prototype.$isMongooseDocumentPrototype = true;\n\n/**\n * Boolean flag specifying if the document is new. If you create a document\n * using `new`, this document will be considered \"new\". `$isNew` is how\n * Mongoose determines whether `save()` should use `insertOne()` to create\n * a new document or `updateOne()` to update an existing document.\n *\n * #### Example:\n *\n *     const user = new User({ name: 'John Smith' });\n *     user.$isNew; // true\n *\n *     await user.save(); // Sends an `insertOne` to MongoDB\n *\n * On the other hand, if you load an existing document from the database\n * using `findOne()` or another [query operation](https://mongoosejs.com/docs/queries.html),\n * `$isNew` will be false.\n *\n * #### Example:\n *\n *     const user = await User.findOne({ name: 'John Smith' });\n *     user.$isNew; // false\n *\n * Mongoose sets `$isNew` to `false` immediately after `save()` succeeds.\n * That means Mongoose sets `$isNew` to false **before** `post('save')` hooks run.\n * In `post('save')` hooks, `$isNew` will be `false` if `save()` succeeded.\n *\n * #### Example:\n *\n *     userSchema.post('save', function() {\n *       this.$isNew; // false\n *     });\n *     await User.create({ name: 'John Smith' });\n *\n * For subdocuments, `$isNew` is true if either the parent has `$isNew` set,\n * or if you create a new subdocument.\n *\n * #### Example:\n *\n *     // Assume `Group` has a document array `users`\n *     const group = await Group.findOne();\n *     group.users[0].$isNew; // false\n *\n *     group.users.push({ name: 'John Smith' });\n *     group.users[1].$isNew; // true\n *\n * @api public\n * @property $isNew\n * @memberOf Document\n * @instance\n */\n\nObject.defineProperty(Document.prototype, 'isNew', {\n  get: function() {\n    return this.$isNew;\n  },\n  set: function(value) {\n    this.$isNew = value;\n  }\n});\n\n/**\n * Hash containing current validation errors.\n *\n * @api public\n * @property errors\n * @memberOf Document\n * @instance\n */\n\nObject.defineProperty(Document.prototype, 'errors', {\n  get: function() {\n    return this.$errors;\n  },\n  set: function(value) {\n    this.$errors = value;\n  }\n});\n\n/*!\n * ignore\n */\n\nDocument.prototype.$isNew = true;\n\n/*!\n * Document exposes the NodeJS event emitter API, so you can use\n * `on`, `once`, etc.\n */\nutils.each(\n  ['on', 'once', 'emit', 'listeners', 'removeListener', 'setMaxListeners',\n    'removeAllListeners', 'addListener'],\n  function(emitterFn) {\n    Document.prototype[emitterFn] = function() {\n      // Delay creating emitter until necessary because emitters take up a lot of memory,\n      // especially for subdocuments.\n      if (!this.$__.emitter) {\n        if (emitterFn === 'emit') {\n          return;\n        }\n        this.$__.emitter = new EventEmitter();\n        this.$__.emitter.setMaxListeners(0);\n      }\n      return this.$__.emitter[emitterFn].apply(this.$__.emitter, arguments);\n    };\n    Document.prototype[`$${emitterFn}`] = Document.prototype[emitterFn];\n  });\n\nDocument.prototype.constructor = Document;\n\nfor (const i in EventEmitter.prototype) {\n  Document[i] = EventEmitter.prototype[i];\n}\n\n/**\n * The document's internal schema.\n *\n * @api private\n * @property schema\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.$__schema;\n\n/**\n * The document's schema.\n *\n * @api public\n * @property schema\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.schema;\n\n/**\n * Empty object that you can use for storing properties on the document. This\n * is handy for passing data to middleware without conflicting with Mongoose\n * internals.\n *\n * #### Example:\n *\n *     schema.pre('save', function() {\n *       // Mongoose will set `isNew` to `false` if `save()` succeeds\n *       this.$locals.wasNew = this.isNew;\n *     });\n *\n *     schema.post('save', function() {\n *       // Prints true if `isNew` was set before `save()`\n *       console.log(this.$locals.wasNew);\n *     });\n *\n * @api public\n * @property $locals\n * @memberOf Document\n * @instance\n */\n\nObject.defineProperty(Document.prototype, '$locals', {\n  configurable: false,\n  enumerable: false,\n  get: function() {\n    if (this.$__.locals == null) {\n      this.$__.locals = {};\n    }\n    return this.$__.locals;\n  },\n  set: function(v) {\n    this.$__.locals = v;\n  }\n});\n\n/**\n * Legacy alias for `$isNew`.\n *\n * @api public\n * @property isNew\n * @memberOf Document\n * @see $isNew https://mongoosejs.com/docs/api/document.html#Document.prototype.$isNew\n * @instance\n */\n\nDocument.prototype.isNew;\n\n/**\n * Set this property to add additional query filters when Mongoose saves this document and `isNew` is false.\n *\n * #### Example:\n *\n *     // Make sure `save()` never updates a soft deleted document.\n *     schema.pre('save', function() {\n *       this.$where = { isDeleted: false };\n *     });\n *\n * @api public\n * @property $where\n * @memberOf Document\n * @instance\n */\n\nObject.defineProperty(Document.prototype, '$where', {\n  configurable: false,\n  enumerable: false,\n  writable: true\n});\n\n/**\n * The string version of this documents _id.\n *\n * #### Note:\n *\n * This getter exists on all documents by default. The getter can be disabled by setting the `id` [option](https://mongoosejs.com/docs/guide.html#id) of its `Schema` to false at construction time.\n *\n *     new Schema({ name: String }, { id: false });\n *\n * @api public\n * @see Schema options https://mongoosejs.com/docs/guide.html#options\n * @property id\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.id;\n\n/**\n * Hash containing current validation $errors.\n *\n * @api public\n * @property $errors\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.$errors;\n\n/**\n * A string containing the current operation that Mongoose is executing\n * on this document. May be `null`, `'save'`, `'validate'`, or `'remove'`.\n *\n * #### Example:\n *\n *     const doc = new Model({ name: 'test' });\n *     doc.$op; // null\n *\n *     const promise = doc.save();\n *     doc.$op; // 'save'\n *\n *     await promise;\n *     doc.$op; // null\n *\n * @api public\n * @property $op\n * @memberOf Document\n * @instance\n */\n\nObject.defineProperty(Document.prototype, '$op', {\n  get: function() {\n    return this.$__.op || null;\n  },\n  set: function(value) {\n    this.$__.op = value;\n  }\n});\n\n/*!\n * ignore\n */\n\nfunction $applyDefaultsToNested(val, path, doc) {\n  if (val == null) {\n    return;\n  }\n\n  const paths = Object.keys(doc.$__schema.paths);\n  const plen = paths.length;\n\n  const pathPieces = path.indexOf('.') === -1 ? [path] : path.split('.');\n\n  for (let i = 0; i < plen; ++i) {\n    let curPath = '';\n    const p = paths[i];\n\n    if (!p.startsWith(path + '.')) {\n      continue;\n    }\n\n    const type = doc.$__schema.paths[p];\n    const pieces = type.splitPath().slice(pathPieces.length);\n    const len = pieces.length;\n\n    if (type.defaultValue === void 0) {\n      continue;\n    }\n\n    let cur = val;\n\n    for (let j = 0; j < len; ++j) {\n      if (cur == null) {\n        break;\n      }\n\n      const piece = pieces[j];\n\n      if (j === len - 1) {\n        if (cur[piece] !== void 0) {\n          break;\n        }\n\n        try {\n          const def = type.getDefault(doc, false);\n          if (def !== void 0) {\n            cur[piece] = def;\n          }\n        } catch (err) {\n          doc.invalidate(path + '.' + curPath, err);\n          break;\n        }\n\n        break;\n      }\n\n      curPath += (!curPath.length ? '' : '.') + piece;\n\n      cur[piece] = cur[piece] || {};\n      cur = cur[piece];\n    }\n  }\n}\n\n/**\n * Builds the default doc structure\n *\n * @param {Object} obj\n * @param {Object} [fields]\n * @param {Boolean} [skipId]\n * @param {Boolean} [exclude]\n * @param {Object} [hasIncludedChildren]\n * @api private\n * @method $__buildDoc\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.$__buildDoc = function(obj, fields, skipId, exclude, hasIncludedChildren) {\n  const doc = {};\n\n  const paths = Object.keys(this.$__schema.paths).\n    // Don't build up any paths that are underneath a map, we don't know\n    // what the keys will be\n    filter(p => !p.includes('$*'));\n  const plen = paths.length;\n  let ii = 0;\n\n  for (; ii < plen; ++ii) {\n    const p = paths[ii];\n\n    if (p === '_id') {\n      if (skipId) {\n        continue;\n      }\n      if (obj && '_id' in obj) {\n        continue;\n      }\n    }\n\n    const path = this.$__schema.paths[p].splitPath();\n    const len = path.length;\n    const last = len - 1;\n    let curPath = '';\n    let doc_ = doc;\n    let included = false;\n\n    for (let i = 0; i < len; ++i) {\n      const piece = path[i];\n\n      if (!curPath.length) {\n        curPath = piece;\n      } else {\n        curPath += '.' + piece;\n      }\n\n      // support excluding intermediary levels\n      if (exclude === true) {\n        if (curPath in fields) {\n          break;\n        }\n      } else if (exclude === false && fields && !included) {\n        if (curPath in fields) {\n          included = true;\n        } else if (!hasIncludedChildren[curPath]) {\n          break;\n        }\n      }\n\n      if (i < last) {\n        doc_ = doc_[piece] || (doc_[piece] = {});\n      }\n    }\n  }\n\n  this._doc = doc;\n};\n\n/*!\n * Converts to POJO when you use the document for querying\n */\n\nDocument.prototype.toBSON = function() {\n  return this.toObject(internalToObjectOptions);\n};\n\n/**\n * Initializes the document without setters or marking anything modified.\n *\n * Called internally after a document is returned from mongodb. Normally,\n * you do **not** need to call this function on your own.\n *\n * This function triggers `init` [middleware](https://mongoosejs.com/docs/middleware.html).\n * Note that `init` hooks are [synchronous](https://mongoosejs.com/docs/middleware.html#synchronous).\n *\n * @param {Object} doc document returned by mongo\n * @param {Object} [opts]\n * @param {Function} [fn]\n * @api public\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.init = function(doc, opts, fn) {\n  if (typeof opts === 'function') {\n    fn = opts;\n    opts = null;\n  }\n\n  this.$__init(doc, opts);\n\n  if (fn) {\n    fn(null, this);\n  }\n\n  return this;\n};\n\n/**\n * Alias for [`.init`](https://mongoosejs.com/docs/api/document.html#Document.prototype.init())\n *\n * @api public\n */\n\nDocument.prototype.$init = function() {\n  return this.constructor.prototype.init.apply(this, arguments);\n};\n\n/**\n * Internal \"init\" function\n *\n * @param {Document} doc\n * @param {Object} [opts]\n * @returns {Document} this\n * @api private\n */\n\nDocument.prototype.$__init = function(doc, opts) {\n  this.$isNew = false;\n  opts = opts || {};\n\n  // handle docs with populated paths\n  // If doc._id is not null or undefined\n  if (doc._id != null && opts.populated && opts.populated.length) {\n    const id = String(doc._id);\n    for (const item of opts.populated) {\n      if (item.isVirtual) {\n        this.$populated(item.path, utils.getValue(item.path, doc), item);\n      } else {\n        this.$populated(item.path, item._docs[id], item);\n      }\n\n      if (item._childDocs == null) {\n        continue;\n      }\n      for (const child of item._childDocs) {\n        if (child == null || child.$__ == null) {\n          continue;\n        }\n        child.$__.parent = this;\n      }\n      item._childDocs = [];\n    }\n  }\n\n  init(this, doc, this._doc, opts);\n\n  markArraySubdocsPopulated(this, opts.populated);\n  this.$emit('init', this);\n  this.constructor.emit('init', this);\n\n  const hasIncludedChildren = this.$__.exclude === false && this.$__.selected ?\n    $__hasIncludedChildren(this.$__.selected) :\n    null;\n\n  applyDefaults(this, this.$__.selected, this.$__.exclude, hasIncludedChildren, false, this.$__.skipDefaults);\n  return this;\n};\n\n/**\n * Init helper.\n *\n * @param {Object} self document instance\n * @param {Object} obj raw mongodb doc\n * @param {Object} doc object we are initializing\n * @param {Object} [opts] Optional Options\n * @param {Boolean} [opts.setters] Call `applySetters` instead of `cast`\n * @param {String} [prefix] Prefix to add to each path\n * @api private\n */\n\nfunction init(self, obj, doc, opts, prefix) {\n  prefix = prefix || '';\n\n  if (obj.$__ != null) {\n    obj = obj._doc;\n  }\n  const keys = Object.keys(obj);\n  const len = keys.length;\n  let schemaType;\n  let path;\n  let i;\n  let index = 0;\n  const strict = self.$__.strictMode;\n  const docSchema = self.$__schema;\n\n  while (index < len) {\n    _init(index++);\n  }\n\n  function _init(index) {\n    i = keys[index];\n    // avoid prototype pollution\n    if (i === '__proto__' || i === 'constructor') {\n      return;\n    }\n    path = prefix + i;\n    schemaType = docSchema.path(path);\n    // Should still work if not a model-level discriminator, but should not be\n    // necessary. This is *only* to catch the case where we queried using the\n    // base model and the discriminated model has a projection\n    if (docSchema.$isRootDiscriminator && !self.$__isSelected(path)) {\n      return;\n    }\n\n    if (!schemaType && utils.isPOJO(obj[i])) {\n      // assume nested object\n      if (!doc[i]) {\n        doc[i] = {};\n        if (!strict && !(i in docSchema.tree) && !(i in docSchema.methods) && !(i in docSchema.virtuals)) {\n          self[i] = doc[i];\n        }\n      }\n      init(self, obj[i], doc[i], opts, path + '.');\n    } else if (!schemaType) {\n      doc[i] = obj[i];\n      if (!strict && !prefix) {\n        self[i] = obj[i];\n      }\n    } else {\n      // Retain order when overwriting defaults\n      if (doc.hasOwnProperty(i) && obj[i] !== void 0 && !opts.hydratedPopulatedDocs) {\n        delete doc[i];\n      }\n      if (obj[i] === null) {\n        doc[i] = schemaType._castNullish(null);\n      } else if (obj[i] !== undefined) {\n        const wasPopulated = obj[i].$__ == null ? null : obj[i].$__.wasPopulated;\n        if ((schemaType && !wasPopulated) && !opts.hydratedPopulatedDocs) {\n          try {\n            if (opts && opts.setters) {\n              // Call applySetters with `init = false` because otherwise setters are a noop\n              const overrideInit = false;\n              doc[i] = schemaType.applySetters(obj[i], self, overrideInit);\n            } else {\n              doc[i] = schemaType.cast(obj[i], self, true);\n            }\n          } catch (e) {\n            self.invalidate(e.path, new ValidatorError({\n              path: e.path,\n              message: e.message,\n              type: 'cast',\n              value: e.value,\n              reason: e\n            }));\n          }\n        } else {\n          doc[i] = obj[i];\n        }\n      }\n      // mark as hydrated\n      if (!self.$isModified(path)) {\n        self.$__.activePaths.init(path);\n      }\n    }\n  }\n}\n\n/**\n * Sends an updateOne command with this document `_id` as the query selector.\n *\n * #### Example:\n *\n *     weirdCar.updateOne({$inc: {wheels:1}}, { w: 1 }, callback);\n *\n * #### Valid options:\n *\n *  - same as in [Model.updateOne](https://mongoosejs.com/docs/api/model.html#Model.updateOne)\n *\n * @see Model.updateOne https://mongoosejs.com/docs/api/model.html#Model.updateOne\n * @param {Object} doc\n * @param {Object} [options] optional see [`Query.prototype.setOptions()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.setOptions())\n * @param {Object} [options.lean] if truthy, mongoose will return the document as a plain JavaScript object rather than a mongoose document. See [`Query.lean()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.lean()) and the [Mongoose lean tutorial](https://mongoosejs.com/docs/tutorials/lean.html).\n * @param {Boolean|String} [options.strict] overwrites the schema's [strict mode option](https://mongoosejs.com/docs/guide.html#strict)\n * @param {Boolean} [options.timestamps=null] If set to `false` and [schema-level timestamps](https://mongoosejs.com/docs/guide.html#timestamps) are enabled, skip timestamps for this update. Note that this allows you to overwrite timestamps. Does nothing if schema-level timestamps are not set.\n * @param {Function} [callback]\n * @return {Query}\n * @api public\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.updateOne = function updateOne(doc, options, callback) {\n  const query = this.constructor.updateOne({ _id: this._id }, doc, options);\n  const self = this;\n  query.pre(function queryPreUpdateOne(cb) {\n    self.constructor._middleware.execPre('updateOne', self, [self], cb);\n  });\n  query.post(function queryPostUpdateOne(cb) {\n    self.constructor._middleware.execPost('updateOne', self, [self], {}, cb);\n  });\n\n  if (this.$session() != null) {\n    if (!('session' in query.options)) {\n      query.options.session = this.$session();\n    }\n  }\n\n  if (callback != null) {\n    return query.exec(callback);\n  }\n\n  return query;\n};\n\n/**\n * Sends a replaceOne command with this document `_id` as the query selector.\n *\n * #### Valid options:\n *\n *  - same as in [Model.replaceOne](https://mongoosejs.com/docs/api/model.html#Model.replaceOne())\n *\n * @see Model.replaceOne https://mongoosejs.com/docs/api/model.html#Model.replaceOne()\n * @param {Object} doc\n * @param {Object} [options]\n * @param {Function} [callback]\n * @return {Query}\n * @api public\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.replaceOne = function replaceOne() {\n  const args = [...arguments];\n  args.unshift({ _id: this._id });\n  return this.constructor.replaceOne.apply(this.constructor, args);\n};\n\n/**\n * Getter/setter around the session associated with this document. Used to\n * automatically set `session` if you `save()` a doc that you got from a\n * query with an associated session.\n *\n * #### Example:\n *\n *     const session = MyModel.startSession();\n *     const doc = await MyModel.findOne().session(session);\n *     doc.$session() === session; // true\n *     doc.$session(null);\n *     doc.$session() === null; // true\n *\n * If this is a top-level document, setting the session propagates to all child\n * docs.\n *\n * @param {ClientSession} [session] overwrite the current session\n * @return {ClientSession}\n * @method $session\n * @api public\n * @memberOf Document\n */\n\nDocument.prototype.$session = function $session(session) {\n  if (arguments.length === 0) {\n    if (this.$__.session != null && this.$__.session.hasEnded) {\n      this.$__.session = null;\n      return null;\n    }\n    return this.$__.session;\n  }\n\n  if (session != null && session.hasEnded) {\n    throw new MongooseError('Cannot set a document\\'s session to a session that has ended. Make sure you haven\\'t ' +\n      'called `endSession()` on the session you are passing to `$session()`.');\n  }\n\n  if (session == null && this.$__.session == null) {\n    return;\n  }\n\n  this.$__.session = session;\n\n  if (!this.$isSubdocument) {\n    const subdocs = this.$getAllSubdocs();\n    for (const child of subdocs) {\n      child.$session(session);\n    }\n  }\n\n  return session;\n};\n\n/**\n * Getter/setter around whether this document will apply timestamps by\n * default when using `save()` and `bulkSave()`.\n *\n * #### Example:\n *\n *     const TestModel = mongoose.model('Test', new Schema({ name: String }, { timestamps: true }));\n *     const doc = new TestModel({ name: 'John Smith' });\n *\n *     doc.$timestamps(); // true\n *\n *     doc.$timestamps(false);\n *     await doc.save(); // Does **not** apply timestamps\n *\n * @param {Boolean} [value] overwrite the current session\n * @return {Document|boolean|undefined} When used as a getter (no argument), a boolean will be returned indicating the timestamps option state or if unset \"undefined\" will be used, otherwise will return \"this\"\n * @method $timestamps\n * @api public\n * @memberOf Document\n */\n\nDocument.prototype.$timestamps = function $timestamps(value) {\n  if (arguments.length === 0) {\n    if (this.$__.timestamps != null) {\n      return this.$__.timestamps;\n    }\n\n    if (this.$__schema) {\n      return this.$__schema.options.timestamps;\n    }\n\n    return undefined;\n  }\n\n  const currentValue = this.$timestamps();\n  if (value !== currentValue) {\n    this.$__.timestamps = value;\n  }\n\n  return this;\n};\n\n/**\n * Overwrite all values in this document with the values of `obj`, except\n * for immutable properties. Behaves similarly to `set()`, except for it\n * unsets all properties that aren't in `obj`.\n *\n * @param {Object} obj the object to overwrite this document with\n * @method overwrite\n * @memberOf Document\n * @instance\n * @api public\n * @return {Document} this\n */\n\nDocument.prototype.overwrite = function overwrite(obj) {\n  const keys = Array.from(new Set(Object.keys(this._doc).concat(Object.keys(obj))));\n\n  for (const key of keys) {\n    if (key === '_id') {\n      continue;\n    }\n    // Explicitly skip version key\n    if (this.$__schema.options.versionKey && key === this.$__schema.options.versionKey) {\n      continue;\n    }\n    if (this.$__schema.options.discriminatorKey && key === this.$__schema.options.discriminatorKey) {\n      continue;\n    }\n    this.$set(key, obj[key]);\n  }\n\n  return this;\n};\n\n/**\n * Alias for `set()`, used internally to avoid conflicts\n *\n * @param {String|Object} path path or object of key/vals to set\n * @param {Any} val the value to set\n * @param {Schema|String|Number|Buffer|*} [type] optionally specify a type for \"on-the-fly\" attributes\n * @param {Object} [options] optionally specify options that modify the behavior of the set\n * @param {Boolean} [options.merge=false] if true, setting a [nested path](https://mongoosejs.com/docs/subdocs.html#subdocuments-versus-nested-paths) will merge existing values rather than overwrite the whole object. So `doc.set('nested', { a: 1, b: 2 })` becomes `doc.set('nested.a', 1); doc.set('nested.b', 2);`\n * @return {Document} this\n * @method $set\n * @memberOf Document\n * @instance\n * @api public\n */\n\nDocument.prototype.$set = function $set(path, val, type, options) {\n  if (utils.isPOJO(type)) {\n    options = type;\n    type = undefined;\n  }\n\n  const merge = options && options.merge;\n  const adhoc = type && type !== true;\n  const constructing = type === true;\n  let adhocs;\n  let keys;\n  let i = 0;\n  let pathtype;\n  let key;\n  let prefix;\n\n  const userSpecifiedStrict = options && 'strict' in options;\n  let strict = userSpecifiedStrict\n    ? options.strict\n    : this.$__.strictMode;\n\n  if (adhoc) {\n    adhocs = this.$__.adhocPaths || (this.$__.adhocPaths = {});\n    adhocs[path] = this.$__schema.interpretAsType(path, type, this.$__schema.options);\n  }\n\n  if (path == null) {\n    [path, val] = [val, path];\n  } else if (typeof path !== 'string') {\n    // new Document({ key: val })\n    if (path instanceof Document) {\n      if (path.$__isNested) {\n        path = path.toObject();\n      } else {\n        path = path._doc;\n      }\n    }\n    if (path == null) {\n      [path, val] = [val, path];\n    }\n\n    prefix = val ? val + '.' : '';\n    keys = getKeysInSchemaOrder(this.$__schema, path);\n\n    const len = keys.length;\n\n    // `_skipMinimizeTopLevel` is because we may have deleted the top-level\n    // nested key to ensure key order.\n    const _skipMinimizeTopLevel = options && options._skipMinimizeTopLevel || false;\n    if (len === 0 && _skipMinimizeTopLevel) {\n      delete options._skipMinimizeTopLevel;\n      if (val) {\n        this.$set(val, {});\n      }\n      return this;\n    }\n\n    options = Object.assign({}, options, { _skipMinimizeTopLevel: false });\n\n    for (let i = 0; i < len; ++i) {\n      key = keys[i];\n      const pathName = prefix ? prefix + key : key;\n      pathtype = this.$__schema.pathType(pathName);\n      const valForKey = path[key];\n\n      // On initial set, delete any nested keys if we're going to overwrite\n      // them to ensure we keep the user's key order.\n      if (type === true &&\n          !prefix &&\n          valForKey != null &&\n          pathtype === 'nested' &&\n          this._doc[key] != null) {\n        delete this._doc[key];\n      }\n\n      if (utils.isNonBuiltinObject(valForKey) && pathtype === 'nested') {\n        this.$set(pathName, valForKey, constructing, Object.assign({}, options, { _skipMarkModified: true }));\n        $applyDefaultsToNested(this.$get(pathName), pathName, this);\n        continue;\n      } else if (strict) {\n        // Don't overwrite defaults with undefined keys (gh-3981) (gh-9039)\n        if (constructing && valForKey === void 0 &&\n            this.$get(pathName) !== void 0) {\n          continue;\n        }\n\n        if (pathtype === 'adhocOrUndefined') {\n          pathtype = getEmbeddedDiscriminatorPath(this, pathName, { typeOnly: true });\n        }\n\n        if (pathtype === 'real' || pathtype === 'virtual') {\n          this.$set(pathName, valForKey, constructing, options);\n        } else if (pathtype === 'nested' && valForKey instanceof Document) {\n          this.$set(pathName,\n            valForKey.toObject({ transform: false }), constructing, options);\n        } else if (strict === 'throw') {\n          if (pathtype === 'nested') {\n            throw new ObjectExpectedError(key, valForKey);\n          } else {\n            throw new StrictModeError(key);\n          }\n        } else if (pathtype === 'nested' && valForKey == null) {\n          this.$set(pathName, valForKey, constructing, options);\n        }\n      } else if (valForKey !== void 0) {\n        this.$set(pathName, valForKey, constructing, options);\n      }\n    }\n\n    // Ensure all properties are in correct order\n    const orderedDoc = {};\n    const orderedKeys = Object.keys(this.$__schema.tree);\n    for (let i = 0, len = orderedKeys.length; i < len; ++i) {\n      (key = orderedKeys[i]) &&\n      (this._doc.hasOwnProperty(key)) &&\n      (orderedDoc[key] = undefined);\n    }\n    this._doc = Object.assign(orderedDoc, this._doc);\n\n    return this;\n  }\n\n  let pathType = this.$__schema.pathType(path);\n  let parts = null;\n  if (pathType === 'adhocOrUndefined') {\n    parts = path.indexOf('.') === -1 ? [path] : path.split('.');\n    pathType = getEmbeddedDiscriminatorPath(this, parts, { typeOnly: true });\n  }\n  if (pathType === 'adhocOrUndefined' && !userSpecifiedStrict) {\n    // May be path underneath non-strict schema\n    if (parts == null) {\n      parts = path.indexOf('.') === -1 ? [path] : path.split('.');\n    }\n    const subdocStrict = getSubdocumentStrictValue(this.$__schema, parts);\n    if (subdocStrict !== undefined) {\n      strict = subdocStrict;\n    }\n  }\n\n  // Assume this is a Mongoose document that was copied into a POJO using\n  // `Object.assign()` or `{...doc}`\n  val = handleSpreadDoc(val, true);\n\n  // if this doc is being constructed we should not trigger getters\n  const priorVal = (() => {\n    if (this.$__.priorDoc != null) {\n      return this.$__.priorDoc.$__getValue(path);\n    }\n    if (constructing) {\n      return void 0;\n    }\n    return this.$__getValue(path);\n  })();\n\n  if (pathType === 'nested' && val) {\n    if (typeof val === 'object' && val != null) {\n      if (val.$__ != null) {\n        val = val.toObject(internalToObjectOptions);\n      }\n      if (val == null) {\n        this.invalidate(path, new MongooseError.CastError('Object', val, path));\n        return this;\n      }\n      const wasModified = this.$isModified(path);\n      const hasInitialVal = this.$__.savedState != null && this.$__.savedState.hasOwnProperty(path);\n      if (this.$__.savedState != null && !this.$isNew && !this.$__.savedState.hasOwnProperty(path)) {\n        const initialVal = this.$__getValue(path);\n        this.$__.savedState[path] = initialVal;\n\n        const keys = Object.keys(initialVal || {});\n        for (const key of keys) {\n          this.$__.savedState[path + '.' + key] = initialVal[key];\n        }\n      }\n\n      if (!merge) {\n        this.$__setValue(path, null);\n        cleanModifiedSubpaths(this, path);\n      } else {\n        return this.$set(val, path, constructing);\n      }\n\n      const keys = getKeysInSchemaOrder(this.$__schema, val, path);\n\n      this.$__setValue(path, {});\n      for (const key of keys) {\n        this.$set(path + '.' + key, val[key], constructing, { ...options, _skipMarkModified: true });\n      }\n      if (priorVal != null &&\n          (!wasModified || hasInitialVal) &&\n          utils.deepEqual(hasInitialVal ? this.$__.savedState[path] : priorVal, val)) {\n        this.unmarkModified(path);\n      } else {\n        this.markModified(path);\n      }\n      return this;\n    }\n    this.invalidate(path, new MongooseError.CastError('Object', val, path));\n    return this;\n  }\n\n  let schema;\n  if (parts == null) {\n    parts = path.indexOf('.') === -1 ? [path] : path.split('.');\n  }\n\n  // Might need to change path for top-level alias\n  if (typeof this.$__schema.aliases[parts[0]] === 'string') {\n    parts[0] = this.$__schema.aliases[parts[0]];\n  }\n\n  if (pathType === 'adhocOrUndefined' && strict) {\n    // check for roots that are Mixed types\n    let mixed;\n\n    for (i = 0; i < parts.length; ++i) {\n      const subpath = parts.slice(0, i + 1).join('.');\n\n      // If path is underneath a virtual, bypass everything and just set it.\n      if (i + 1 < parts.length && this.$__schema.pathType(subpath) === 'virtual') {\n        mpath.set(path, val, this);\n        return this;\n      }\n\n      schema = this.$__schema.path(subpath);\n      if (schema == null) {\n        continue;\n      }\n\n      if (schema instanceof MixedSchema) {\n        // allow changes to sub paths of mixed types\n        mixed = true;\n        break;\n      } else if (schema.$isSchemaMap && schema.$__schemaType instanceof MixedSchema && i < parts.length - 1) {\n        // Map of mixed and not the last element in the path resolves to mixed\n        mixed = true;\n        schema = schema.$__schemaType;\n        break;\n      }\n    }\n\n    if (schema == null) {\n      // Check for embedded discriminators\n      schema = getEmbeddedDiscriminatorPath(this, path);\n    }\n\n    if (!mixed && !schema) {\n      if (strict === 'throw') {\n        throw new StrictModeError(path);\n      }\n      return this;\n    }\n  } else if (pathType === 'virtual') {\n    schema = this.$__schema.virtualpath(path);\n    schema.applySetters(val, this);\n    return this;\n  } else {\n    schema = this.$__path(path);\n  }\n\n  // gh-4578, if setting a deeply nested path that doesn't exist yet, create it\n  let cur = this._doc;\n  let curPath = '';\n  for (i = 0; i < parts.length - 1; ++i) {\n    cur = cur[parts[i]];\n    curPath += (curPath.length !== 0 ? '.' : '') + parts[i];\n    if (!cur) {\n      this.$set(curPath, {});\n      // Hack re: gh-5800. If nested field is not selected, it probably exists\n      // so `MongoServerError: cannot use the part (nested of nested.num) to\n      // traverse the element ({nested: null})` is not likely. If user gets\n      // that error, its their fault for now. We should reconsider disallowing\n      // modifying not selected paths for 6.x\n      if (!this.$__isSelected(curPath)) {\n        this.unmarkModified(curPath);\n      }\n      cur = this.$__getValue(curPath);\n    }\n  }\n\n  let pathToMark;\n\n  // When using the $set operator the path to the field must already exist.\n  // Else mongodb throws: \"LEFT_SUBFIELD only supports Object\"\n\n  if (parts.length <= 1) {\n    pathToMark = path;\n  } else {\n    const len = parts.length;\n    for (i = 0; i < len; ++i) {\n      const subpath = parts.slice(0, i + 1).join('.');\n      if (this.$get(subpath, null, { getters: false }) === null) {\n        pathToMark = subpath;\n        break;\n      }\n    }\n\n    if (!pathToMark) {\n      pathToMark = path;\n    }\n  }\n\n  if (!schema) {\n    this.$__set(pathToMark, path, options, constructing, parts, schema, val, priorVal);\n\n    if (pathType === 'nested' && val == null) {\n      cleanModifiedSubpaths(this, path);\n    }\n    return this;\n  }\n\n  // If overwriting a subdocument path, make sure to clear out\n  // any errors _before_ setting, so new errors that happen\n  // get persisted. Re: #9080\n  if (schema.$isSingleNested || schema.$isMongooseArray) {\n    _markValidSubpaths(this, path);\n  }\n\n  if (val != null && merge && schema.$isSingleNested) {\n    if (val instanceof Document) {\n      val = val.toObject({ virtuals: false, transform: false });\n    }\n    const keys = Object.keys(val);\n    for (const key of keys) {\n      this.$set(path + '.' + key, val[key], constructing, options);\n    }\n\n    return this;\n  }\n\n  let shouldSet = true;\n  try {\n    // If the user is trying to set a ref path to a document with\n    // the correct model name, treat it as populated\n    const refMatches = (() => {\n      if (schema.options == null) {\n        return false;\n      }\n      if (!(val instanceof Document)) {\n        return false;\n      }\n      const model = val.constructor;\n\n      // Check ref\n      const ref = schema.options.ref;\n      if (ref != null && (ref === model.modelName || ref === model.baseModelName)) {\n        return true;\n      }\n\n      // Check refPath\n      const refPath = schema.options.refPath;\n      if (refPath == null) {\n        return false;\n      }\n      const modelName = val.get(refPath);\n      return modelName === model.modelName || modelName === model.baseModelName;\n    })();\n\n    let didPopulate = false;\n    if (refMatches && val instanceof Document && (!val.$__.wasPopulated || utils.deepEqual(val.$__.wasPopulated.value, val._id))) {\n      const unpopulatedValue = (schema && schema.$isSingleNested) ? schema.cast(val, this) : val._id;\n      this.$populated(path, unpopulatedValue, { [populateModelSymbol]: val.constructor });\n      val.$__.wasPopulated = { value: unpopulatedValue };\n      didPopulate = true;\n    }\n\n    let popOpts;\n    const typeKey = this.$__schema.options.typeKey;\n    if (schema.options &&\n        Array.isArray(schema.options[typeKey]) &&\n        schema.options[typeKey].length &&\n        schema.options[typeKey][0].ref &&\n        _isManuallyPopulatedArray(val, schema.options[typeKey][0].ref)) {\n      popOpts = { [populateModelSymbol]: val[0].constructor };\n      this.$populated(path, val.map(function(v) { return v._id; }), popOpts);\n\n      for (const doc of val) {\n        doc.$__.wasPopulated = { value: doc._id };\n      }\n      didPopulate = true;\n    }\n\n    if (!refMatches || !schema.$isSingleNested || !val.$__) {\n      // If this path is underneath a single nested schema, we'll call the setter\n      // later in `$__set()` because we don't take `_doc` when we iterate through\n      // a single nested doc. That's to make sure we get the correct context.\n      // Otherwise we would double-call the setter, see gh-7196.\n      let setterContext = this;\n      if (this.$__schema.singleNestedPaths[path] != null && parts.length > 1) {\n        setterContext = getDeepestSubdocumentForPath(this, parts, this.schema);\n      }\n      if (options != null && options.overwriteImmutable) {\n        val = schema.applySetters(val, setterContext, false, priorVal, { overwriteImmutable: true });\n      } else {\n        val = schema.applySetters(val, setterContext, false, priorVal);\n      }\n    }\n\n    if (Array.isArray(val) &&\n        !Array.isArray(schema) &&\n        schema.$isMongooseDocumentArray &&\n        val.length !== 0 &&\n        val[0] != null &&\n        val[0].$__ != null &&\n        val[0].$__.populated != null) {\n      const populatedPaths = Object.keys(val[0].$__.populated);\n      for (const populatedPath of populatedPaths) {\n        this.$populated(path + '.' + populatedPath,\n          val.map(v => v.$populated(populatedPath)),\n          val[0].$__.populated[populatedPath].options);\n      }\n      didPopulate = true;\n    }\n\n    if (!didPopulate && this.$__.populated) {\n      // If this array partially contains populated documents, convert them\n      // all to ObjectIds re: #8443\n      if (Array.isArray(val) && this.$__.populated[path]) {\n        for (let i = 0; i < val.length; ++i) {\n          if (val[i] instanceof Document) {\n            val.set(i, val[i]._id, true);\n          }\n        }\n      }\n      delete this.$__.populated[path];\n    }\n\n    if (val != null && schema.$isSingleNested) {\n      _checkImmutableSubpaths(val, schema, priorVal);\n    }\n\n    this.$markValid(path);\n  } catch (e) {\n    if (e instanceof MongooseError.StrictModeError && e.isImmutableError) {\n      this.invalidate(path, e);\n    } else if (e instanceof MongooseError.CastError) {\n      this.invalidate(e.path, e);\n      if (e.$originalErrorPath) {\n        this.invalidate(path,\n          new MongooseError.CastError(schema.instance, val, path, e.$originalErrorPath));\n      }\n    } else {\n      this.invalidate(path,\n        new MongooseError.CastError(schema.instance, val, path, e));\n    }\n    shouldSet = false;\n  }\n\n  if (shouldSet) {\n    let savedState = null;\n    let savedStatePath = null;\n    if (!constructing) {\n      const doc = this.$isSubdocument ? this.ownerDocument() : this;\n      savedState = doc.$__.savedState;\n      savedStatePath = this.$isSubdocument ? this.$__.fullPath + '.' + path : path;\n      doc.$__saveInitialState(savedStatePath);\n    }\n\n    this.$__set(pathToMark, path, options, constructing, parts, schema, val, priorVal);\n\n    const isInTransaction = !!this.$__.session?.transaction;\n    const isModifiedWithinTransaction = this.$__.session &&\n      this.$__.session[sessionNewDocuments] &&\n      this.$__.session[sessionNewDocuments].has(this) &&\n      this.$__.session[sessionNewDocuments].get(this).modifiedPaths &&\n      !this.$__.session[sessionNewDocuments].get(this).modifiedPaths.has(savedStatePath);\n    if (savedState != null &&\n        savedState.hasOwnProperty(savedStatePath) &&\n        (!isInTransaction || isModifiedWithinTransaction) &&\n        utils.deepEqual(val, savedState[savedStatePath])) {\n      this.unmarkModified(path);\n    }\n  }\n\n  if (schema.$isSingleNested && (this.isDirectModified(path) || val == null)) {\n    cleanModifiedSubpaths(this, path);\n  }\n\n  return this;\n};\n\n/*!\n * ignore\n */\n\nfunction _isManuallyPopulatedArray(val, ref) {\n  if (!Array.isArray(val)) {\n    return false;\n  }\n  if (val.length === 0) {\n    return false;\n  }\n\n  for (const el of val) {\n    if (!(el instanceof Document)) {\n      return false;\n    }\n    const modelName = el.constructor.modelName;\n    if (modelName == null) {\n      return false;\n    }\n    if (el.constructor.modelName != ref && el.constructor.baseModelName != ref) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n/**\n * Sets the value of a path, or many paths.\n * Alias for [`.$set`](https://mongoosejs.com/docs/api/document.html#Document.prototype.$set()).\n *\n * #### Example:\n *\n *     // path, value\n *     doc.set(path, value)\n *\n *     // object\n *     doc.set({\n *         path  : value\n *       , path2 : {\n *            path  : value\n *         }\n *     })\n *\n *     // on-the-fly cast to number\n *     doc.set(path, value, Number)\n *\n *     // on-the-fly cast to string\n *     doc.set(path, value, String)\n *\n *     // changing strict mode behavior\n *     doc.set(path, value, { strict: false });\n *\n * @param {String|Object} path path or object of key/vals to set\n * @param {Any} val the value to set\n * @param {Schema|String|Number|Buffer|*} [type] optionally specify a type for \"on-the-fly\" attributes\n * @param {Object} [options] optionally specify options that modify the behavior of the set\n * @return {Document} this\n * @api public\n * @method set\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.set = Document.prototype.$set;\n\n/**\n * Determine if we should mark this change as modified.\n *\n * @param {never} pathToMark UNUSED\n * @param {String|Symbol} path\n * @param {Object} options\n * @param {Any} constructing\n * @param {never} parts UNUSED\n * @param {Schema} schema\n * @param {Any} val\n * @param {Any} priorVal\n * @return {Boolean}\n * @api private\n * @method $__shouldModify\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.$__shouldModify = function(pathToMark, path, options, constructing, parts, schema, val, priorVal) {\n  if (options && options._skipMarkModified) {\n    return false;\n  }\n  if (this.$isNew) {\n    return true;\n  }\n  // Is path already modified? If so, always modify. We may unmark modified later.\n  if (path in this.$__.activePaths.getStatePaths('modify')) {\n    return true;\n  }\n\n  if (val === void 0 && !this.$__isSelected(path)) {\n    // when a path is not selected in a query, its initial\n    // value will be undefined.\n    return true;\n  }\n\n  if (val === void 0 && path in this.$__.activePaths.getStatePaths('default')) {\n    // we're just unsetting the default value which was never saved\n    return false;\n  }\n\n  // gh-3992: if setting a populated field to a doc, don't mark modified\n  // if they have the same _id\n  if (this.$populated(path) &&\n      val instanceof Document &&\n      deepEqual(val._id, priorVal)) {\n    return false;\n  }\n\n  if (!deepEqual(val, priorVal !== undefined ? priorVal : utils.getValue(path, this))) {\n    return true;\n  }\n\n  if (!constructing &&\n      val !== null &&\n      val !== undefined &&\n      path in this.$__.activePaths.getStatePaths('default') &&\n      deepEqual(val, schema.getDefault(this, constructing))) {\n    // a path with a default was $unset on the server\n    // and the user is setting it to the same value again\n    return true;\n  }\n  return false;\n};\n\n/**\n * Handles the actual setting of the value and marking the path modified if appropriate.\n *\n * @param {String} pathToMark\n * @param {String|Symbol} path\n * @param {Object} options\n * @param {Any} constructing\n * @param {Array} parts\n * @param {Schema} schema\n * @param {Any} val\n * @param {Any} priorVal\n * @api private\n * @method $__set\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.$__set = function(pathToMark, path, options, constructing, parts, schema, val, priorVal) {\n  Embedded = Embedded || __webpack_require__(/*! ./types/arraySubdocument */ \"../server/node_modules/mongoose/lib/types/arraySubdocument.js\");\n\n  const shouldModify = this.$__shouldModify(pathToMark, path, options, constructing, parts,\n    schema, val, priorVal);\n\n  if (shouldModify) {\n    if (this.$__.primitiveAtomics && this.$__.primitiveAtomics[path]) {\n      delete this.$__.primitiveAtomics[path];\n      if (Object.keys(this.$__.primitiveAtomics).length === 0) {\n        delete this.$__.primitiveAtomics;\n      }\n    }\n    this.markModified(pathToMark);\n\n    // handle directly setting arrays (gh-1126)\n    MongooseArray || (MongooseArray = __webpack_require__(/*! ./types/array */ \"../server/node_modules/mongoose/lib/types/array/index.js\"));\n    if (val && utils.isMongooseArray(val)) {\n      val._registerAtomic('$set', val);\n\n      // Update embedded document parent references (gh-5189)\n      if (utils.isMongooseDocumentArray(val)) {\n        val.forEach(function(item) {\n          item && item.__parentArray && (item.__parentArray = val);\n        });\n      }\n    }\n  } else if (Array.isArray(val) && Array.isArray(priorVal) && utils.isMongooseArray(val) && utils.isMongooseArray(priorVal)) {\n    val[arrayAtomicsSymbol] = priorVal[arrayAtomicsSymbol];\n    val[arrayAtomicsBackupSymbol] = priorVal[arrayAtomicsBackupSymbol];\n    if (utils.isMongooseDocumentArray(val)) {\n      val.forEach(doc => {\n        if (doc != null) {\n          doc.$isNew = false;\n        }\n      });\n    }\n  }\n\n  let obj = this._doc;\n  let i = 0;\n  const l = parts.length;\n  let cur = '';\n\n  for (; i < l; i++) {\n    const next = i + 1;\n    const last = next === l;\n    cur += (cur ? '.' + parts[i] : parts[i]);\n    if (specialProperties.has(parts[i])) {\n      return;\n    }\n\n    if (last) {\n      if (obj instanceof Map) {\n        obj.set(parts[i], val);\n      } else if (obj.$isSingleNested) {\n        if (!(parts[i] in obj)) {\n          obj[parts[i]] = val;\n          obj._doc[parts[i]] = val;\n        } else {\n          obj._doc[parts[i]] = val;\n        }\n      } else {\n        obj[parts[i]] = val;\n      }\n    } else {\n      const isMap = obj instanceof Map;\n      let value = isMap ? obj.get(parts[i]) : obj[parts[i]];\n      if (utils.isPOJO(value)) {\n        obj = value;\n      } else if (value && value instanceof Embedded) {\n        obj = value;\n      } else if (value && !Array.isArray(value) && value.$isSingleNested) {\n        obj = value;\n      } else if (value && Array.isArray(value)) {\n        obj = value;\n      } else if (value == null) {\n        value = {};\n        if (isMap) {\n          obj.set(parts[i], value);\n        } else {\n          obj[parts[i]] = value;\n        }\n        obj = value;\n      } else {\n        obj = value;\n      }\n    }\n  }\n};\n\n/**\n * Gets a raw value from a path (no getters)\n *\n * @param {String} path\n * @return {Any} Returns the value from the given `path`.\n * @api private\n */\n\nDocument.prototype.$__getValue = function(path) {\n  return utils.getValue(path, this._doc);\n};\n\n/**\n * Increments the numeric value at `path` by the given `val`.\n * When you call `save()` on this document, Mongoose will send a\n * [`$inc`](https://www.mongodb.com/docs/manual/reference/operator/update/inc/)\n * as opposed to a `$set`.\n *\n * #### Example:\n *\n *     const schema = new Schema({ counter: Number });\n *     const Test = db.model('Test', schema);\n *\n *     const doc = await Test.create({ counter: 0 });\n *     doc.$inc('counter', 2);\n *     await doc.save(); // Sends a `{ $inc: { counter: 2 } }` to MongoDB\n *     doc.counter; // 2\n *\n *     doc.counter += 2;\n *     await doc.save(); // Sends a `{ $set: { counter: 2 } }` to MongoDB\n *\n * @param {String|Array} path path or paths to update\n * @param {Number} val increment `path` by this value\n * @return {Document} this\n */\n\nDocument.prototype.$inc = function $inc(path, val) {\n  if (val == null) {\n    val = 1;\n  }\n\n  if (Array.isArray(path)) {\n    path.forEach((p) => this.$inc(p, val));\n    return this;\n  }\n\n  const schemaType = this.$__path(path);\n  if (schemaType == null) {\n    if (this.$__.strictMode === 'throw') {\n      throw new StrictModeError(path);\n    } else if (this.$__.strictMode === true) {\n      return this;\n    }\n  } else if (schemaType.instance !== 'Number') {\n    this.invalidate(path, new MongooseError.CastError(schemaType.instance, val, path));\n    return this;\n  }\n\n  const currentValue = this.$__getValue(path) || 0;\n  let shouldSet = false;\n  let valToSet = null;\n  let valToInc = val;\n\n  try {\n    val = schemaType.cast(val);\n    valToSet = schemaType.applySetters(currentValue + val, this);\n    valToInc = valToSet - currentValue;\n    shouldSet = true;\n  } catch (err) {\n    this.invalidate(path, new MongooseError.CastError('number', val, path, err));\n  }\n\n  if (shouldSet) {\n    this.$__.primitiveAtomics = this.$__.primitiveAtomics || {};\n    if (this.$__.primitiveAtomics[path] == null) {\n      this.$__.primitiveAtomics[path] = { $inc: valToInc };\n    } else {\n      this.$__.primitiveAtomics[path].$inc += valToInc;\n    }\n    this.markModified(path);\n    this.$__setValue(path, valToSet);\n  }\n\n  return this;\n};\n\n/**\n * Sets a raw value for a path (no casting, setters, transformations)\n *\n * @param {String} path\n * @param {Object} value\n * @return {Document} this\n * @api private\n */\n\nDocument.prototype.$__setValue = function(path, val) {\n  utils.setValue(path, val, this._doc);\n  return this;\n};\n\n/**\n * Returns the value of a path.\n *\n * #### Example:\n *\n *     // path\n *     doc.get('age') // 47\n *\n *     // dynamic casting to a string\n *     doc.get('age', String) // \"47\"\n *\n * @param {String} path\n * @param {Schema|String|Number|Buffer|*} [type] optionally specify a type for on-the-fly attributes\n * @param {Object} [options]\n * @param {Boolean} [options.virtuals=false] Apply virtuals before getting this path\n * @param {Boolean} [options.getters=true] If false, skip applying getters and just get the raw value\n * @return {Any}\n * @api public\n */\n\nDocument.prototype.get = function(path, type, options) {\n  let adhoc;\n  if (options == null) {\n    options = {};\n  }\n  if (type) {\n    adhoc = this.$__schema.interpretAsType(path, type, this.$__schema.options);\n  }\n  const noDottedPath = options.noDottedPath;\n\n  // Fast path if we know we're just accessing top-level path on the document:\n  // just get the schema path, avoid `$__path()` because that does string manipulation\n  let schema = noDottedPath ? this.$__schema.paths[path] : this.$__path(path);\n  if (schema == null) {\n    schema = this.$__schema.virtualpath(path);\n\n    if (schema != null) {\n      return schema.applyGetters(void 0, this);\n    }\n  }\n\n  if (noDottedPath) {\n    let obj = this._doc[path];\n    if (adhoc) {\n      obj = adhoc.cast(obj);\n    }\n    if (schema != null && options.getters !== false) {\n      return schema.applyGetters(obj, this);\n    }\n    return obj;\n  }\n\n  if (schema != null && schema.instance === 'Mixed') {\n    const virtual = this.$__schema.virtualpath(path);\n    if (virtual != null) {\n      schema = virtual;\n    }\n  }\n\n  const hasDot = path.indexOf('.') !== -1;\n  let obj = this._doc;\n\n  const pieces = hasDot ? path.split('.') : [path];\n  // Might need to change path for top-level alias\n  if (typeof this.$__schema.aliases[pieces[0]] === 'string') {\n    pieces[0] = this.$__schema.aliases[pieces[0]];\n  }\n\n  for (let i = 0, l = pieces.length; i < l; i++) {\n    if (obj && obj._doc) {\n      obj = obj._doc;\n    }\n\n    if (obj == null) {\n      obj = void 0;\n    } else if (obj instanceof Map) {\n      obj = obj.get(pieces[i], { getters: false });\n    } else if (i === l - 1) {\n      obj = utils.getValue(pieces[i], obj);\n    } else {\n      obj = obj[pieces[i]];\n    }\n  }\n\n  if (adhoc) {\n    obj = adhoc.cast(obj);\n  }\n\n  if (schema != null && options.getters !== false) {\n    obj = schema.applyGetters(obj, this);\n  } else if (this.$__schema.nested[path] && options.virtuals) {\n    // Might need to apply virtuals if this is a nested path\n    return applyVirtuals(this, clone(obj) || {}, { path: path });\n  }\n\n  return obj;\n};\n\n/*!\n * ignore\n */\n\nDocument.prototype[getSymbol] = Document.prototype.get;\nDocument.prototype.$get = Document.prototype.get;\n\n/**\n * Returns the schematype for the given `path`.\n *\n * @param {String} path\n * @return {SchemaPath}\n * @api private\n * @method $__path\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.$__path = function(path) {\n  const adhocs = this.$__.adhocPaths;\n  const adhocType = adhocs && adhocs.hasOwnProperty(path) ? adhocs[path] : null;\n\n  if (adhocType) {\n    return adhocType;\n  }\n  return this.$__schema.path(path);\n};\n\n/**\n * Marks the path as having pending changes to write to the db.\n *\n * _Very helpful when using [Mixed](https://mongoosejs.com/docs/schematypes.html#mixed) types._\n *\n * #### Example:\n *\n *     doc.mixed.type = 'changed';\n *     doc.markModified('mixed.type');\n *     doc.save() // changes to mixed.type are now persisted\n *\n * @param {String} path the path to mark modified\n * @param {Document} [scope] the scope to run validators with\n * @api public\n */\n\nDocument.prototype.markModified = function(path, scope) {\n  this.$__saveInitialState(path);\n\n  this.$__.activePaths.modify(path);\n  if (scope != null && !this.$isSubdocument) {\n    this.$__.pathsToScopes = this.$__pathsToScopes || {};\n    this.$__.pathsToScopes[path] = scope;\n  }\n};\n\n/*!\n * ignore\n */\n\nDocument.prototype.$__saveInitialState = function $__saveInitialState(path) {\n  const savedState = this.$__.savedState;\n  const savedStatePath = path;\n  if (savedState != null) {\n    const firstDot = savedStatePath.indexOf('.');\n    const topLevelPath = firstDot === -1 ? savedStatePath : savedStatePath.slice(0, firstDot);\n    if (!savedState.hasOwnProperty(topLevelPath)) {\n      savedState[topLevelPath] = clone(this.$__getValue(topLevelPath));\n    }\n  }\n};\n\n/**\n * Clears the modified state on the specified path.\n *\n * #### Example:\n *\n *     doc.foo = 'bar';\n *     doc.unmarkModified('foo');\n *     doc.save(); // changes to foo will not be persisted\n *\n * @param {String} path the path to unmark modified\n * @api public\n */\n\nDocument.prototype.unmarkModified = function(path) {\n  this.$__.activePaths.init(path);\n  if (this.$__.pathsToScopes != null) {\n    delete this.$__.pathsToScopes[path];\n  }\n};\n\n/**\n * Don't run validation on this path or persist changes to this path.\n *\n * #### Example:\n *\n *     doc.foo = null;\n *     doc.$ignore('foo');\n *     doc.save(); // changes to foo will not be persisted and validators won't be run\n *\n * @memberOf Document\n * @instance\n * @method $ignore\n * @param {String} path the path to ignore\n * @api public\n */\n\nDocument.prototype.$ignore = function(path) {\n  this.$__.activePaths.ignore(path);\n};\n\n/**\n * Returns the list of paths that have been directly modified. A direct\n * modified path is a path that you explicitly set, whether via `doc.foo = 'bar'`,\n * `Object.assign(doc, { foo: 'bar' })`, or `doc.set('foo', 'bar')`.\n *\n * A path `a` may be in `modifiedPaths()` but not in `directModifiedPaths()`\n * because a child of `a` was directly modified.\n *\n * #### Example:\n *\n *     const schema = new Schema({ foo: String, nested: { bar: String } });\n *     const Model = mongoose.model('Test', schema);\n *     await Model.create({ foo: 'original', nested: { bar: 'original' } });\n *\n *     const doc = await Model.findOne();\n *     doc.nested.bar = 'modified';\n *     doc.directModifiedPaths(); // ['nested.bar']\n *     doc.modifiedPaths(); // ['nested', 'nested.bar']\n *\n * @return {String[]}\n * @api public\n */\n\nDocument.prototype.directModifiedPaths = function() {\n  return Object.keys(this.$__.activePaths.getStatePaths('modify'));\n};\n\n/**\n * Returns true if the given path is nullish or only contains empty objects.\n * Useful for determining whether this subdoc will get stripped out by the\n * [minimize option](https://mongoosejs.com/docs/guide.html#minimize).\n *\n * #### Example:\n *\n *     const schema = new Schema({ nested: { foo: String } });\n *     const Model = mongoose.model('Test', schema);\n *     const doc = new Model({});\n *     doc.$isEmpty('nested'); // true\n *     doc.nested.$isEmpty(); // true\n *\n *     doc.nested.foo = 'bar';\n *     doc.$isEmpty('nested'); // false\n *     doc.nested.$isEmpty(); // false\n *\n * @param {String} [path]\n * @memberOf Document\n * @instance\n * @api public\n * @method $isEmpty\n * @return {Boolean}\n */\n\nDocument.prototype.$isEmpty = function(path) {\n  const isEmptyOptions = {\n    minimize: true,\n    virtuals: false,\n    getters: false,\n    transform: false\n  };\n\n  if (arguments.length !== 0) {\n    const v = this.$get(path);\n    if (v == null) {\n      return true;\n    }\n    if (typeof v !== 'object') {\n      return false;\n    }\n    if (utils.isPOJO(v)) {\n      return _isEmpty(v);\n    }\n    return Object.keys(v.toObject(isEmptyOptions)).length === 0;\n  }\n\n  return Object.keys(this.toObject(isEmptyOptions)).length === 0;\n};\n\n/*!\n * ignore\n */\n\nfunction _isEmpty(v) {\n  if (v == null) {\n    return true;\n  }\n  if (typeof v !== 'object' || Array.isArray(v)) {\n    return false;\n  }\n  for (const key of Object.keys(v)) {\n    if (!_isEmpty(v[key])) {\n      return false;\n    }\n  }\n  return true;\n}\n\n/**\n * Returns the list of paths that have been modified.\n *\n * @param {Object} [options]\n * @param {Boolean} [options.includeChildren=false] if true, returns children of modified paths as well. For example, if false, the list of modified paths for `doc.colors = { primary: 'blue' };` will **not** contain `colors.primary`. If true, `modifiedPaths()` will return an array that contains `colors.primary`.\n * @return {String[]}\n * @api public\n */\n\nDocument.prototype.modifiedPaths = function(options) {\n  options = options || {};\n\n  const directModifiedPaths = Object.keys(this.$__.activePaths.getStatePaths('modify'));\n  const result = new Set();\n\n  let i = 0;\n  let j = 0;\n  const len = directModifiedPaths.length;\n\n  for (i = 0; i < len; ++i) {\n    const path = directModifiedPaths[i];\n    const parts = parentPaths(path);\n    const pLen = parts.length;\n\n    for (j = 0; j < pLen; ++j) {\n      result.add(parts[j]);\n    }\n\n    if (!options.includeChildren) {\n      continue;\n    }\n\n    let ii = 0;\n    let cur = this.$get(path);\n    if (typeof cur === 'object' && cur !== null) {\n      if (cur._doc) {\n        cur = cur._doc;\n      }\n      const len = cur.length;\n      if (Array.isArray(cur)) {\n        for (ii = 0; ii < len; ++ii) {\n          const subPath = path + '.' + ii;\n          if (!result.has(subPath)) {\n            result.add(subPath);\n            if (cur[ii] != null && cur[ii].$__) {\n              const modified = cur[ii].modifiedPaths();\n              let iii = 0;\n              const iiiLen = modified.length;\n              for (iii = 0; iii < iiiLen; ++iii) {\n                result.add(subPath + '.' + modified[iii]);\n              }\n            }\n          }\n        }\n      } else {\n        const keys = Object.keys(cur);\n        let ii = 0;\n        const len = keys.length;\n        for (ii = 0; ii < len; ++ii) {\n          result.add(path + '.' + keys[ii]);\n        }\n      }\n    }\n  }\n  return Array.from(result);\n};\n\nDocument.prototype[documentModifiedPaths] = Document.prototype.modifiedPaths;\n\n/**\n * Returns true if any of the given paths is modified, else false. If no arguments, returns `true` if any path\n * in this document is modified.\n *\n * If `path` is given, checks if a path or any full path containing `path` as part of its path chain has been modified.\n *\n * #### Example:\n *\n *     doc.set('documents.0.title', 'changed');\n *     doc.isModified()                      // true\n *     doc.isModified('documents')           // true\n *     doc.isModified('documents.0.title')   // true\n *     doc.isModified('documents otherProp') // true\n *     doc.isDirectModified('documents')     // false\n *\n * @param {String} [path] optional\n * @param {Object} [options]\n * @param {Boolean} [options.ignoreAtomics=false] If true, doesn't return true if path is underneath an array that was modified with atomic operations like `push()`\n * @return {Boolean}\n * @api public\n */\n\nDocument.prototype.isModified = function(paths, options, modifiedPaths) {\n  if (paths) {\n    const ignoreAtomics = options && options.ignoreAtomics;\n    const directModifiedPathsObj = this.$__.activePaths.states.modify;\n    if (directModifiedPathsObj == null) {\n      return false;\n    }\n\n    if (typeof paths === 'string') {\n      paths = paths.indexOf(' ') === -1 ? [paths] : paths.split(' ');\n    }\n\n    for (const path of paths) {\n      if (directModifiedPathsObj[path] != null) {\n        return true;\n      }\n    }\n\n    const modified = modifiedPaths || this[documentModifiedPaths]();\n    const isModifiedChild = paths.some(function(path) {\n      return !!~modified.indexOf(path);\n    });\n\n    let directModifiedPaths = Object.keys(directModifiedPathsObj);\n    if (ignoreAtomics) {\n      directModifiedPaths = directModifiedPaths.filter(path => {\n        const value = this.$__getValue(path);\n        if (value != null && value[arrayAtomicsSymbol] != null && value[arrayAtomicsSymbol].$set === undefined) {\n          return false;\n        }\n        return true;\n      });\n    }\n    return isModifiedChild || paths.some(function(path) {\n      return directModifiedPaths.some(function(mod) {\n        return mod === path || path.startsWith(mod + '.');\n      });\n    });\n  }\n\n  return this.$__.activePaths.some('modify');\n};\n\n/**\n * Alias of [`.isModified`](https://mongoosejs.com/docs/api/document.html#Document.prototype.isModified())\n *\n * @method $isModified\n * @memberOf Document\n * @api public\n */\n\nDocument.prototype.$isModified = Document.prototype.isModified;\n\nDocument.prototype[documentIsModified] = Document.prototype.isModified;\n\n/**\n * Checks if a path is set to its default.\n *\n * #### Example:\n *\n *     MyModel = mongoose.model('test', { name: { type: String, default: 'Val '} });\n *     const m = new MyModel();\n *     m.$isDefault('name'); // true\n *\n * @memberOf Document\n * @instance\n * @method $isDefault\n * @param {String} [path]\n * @return {Boolean}\n * @api public\n */\n\nDocument.prototype.$isDefault = function(path) {\n  if (path == null) {\n    return this.$__.activePaths.some('default');\n  }\n\n  if (typeof path === 'string' && path.indexOf(' ') === -1) {\n    return this.$__.activePaths.getStatePaths('default').hasOwnProperty(path);\n  }\n\n  let paths = path;\n  if (!Array.isArray(paths)) {\n    paths = paths.split(' ');\n  }\n\n  return paths.some(path => this.$__.activePaths.getStatePaths('default').hasOwnProperty(path));\n};\n\n/**\n * Getter/setter, determines whether the document was removed or not.\n *\n * #### Example:\n *\n *     const product = await product.remove();\n *     product.$isDeleted(); // true\n *     product.remove(); // no-op, doesn't send anything to the db\n *\n *     product.$isDeleted(false);\n *     product.$isDeleted(); // false\n *     product.remove(); // will execute a remove against the db\n *\n *\n * @param {Boolean} [val] optional, overrides whether mongoose thinks the doc is deleted\n * @return {Boolean|Document} whether mongoose thinks this doc is deleted.\n * @method $isDeleted\n * @memberOf Document\n * @instance\n * @api public\n */\n\nDocument.prototype.$isDeleted = function(val) {\n  if (arguments.length === 0) {\n    return !!this.$__.isDeleted;\n  }\n\n  this.$__.isDeleted = !!val;\n  return this;\n};\n\n/**\n * Returns true if `path` was directly set and modified, else false.\n *\n * #### Example:\n *\n *     doc.set('documents.0.title', 'changed');\n *     doc.isDirectModified('documents.0.title') // true\n *     doc.isDirectModified('documents') // false\n *\n * @param {String|String[]} [path]\n * @return {Boolean}\n * @api public\n */\n\nDocument.prototype.isDirectModified = function(path) {\n  if (path == null) {\n    return this.$__.activePaths.some('modify');\n  }\n\n  if (typeof path === 'string' && path.indexOf(' ') === -1) {\n    return this.$__.activePaths.getStatePaths('modify').hasOwnProperty(path);\n  }\n\n  let paths = path;\n  if (!Array.isArray(paths)) {\n    paths = paths.split(' ');\n  }\n\n  return paths.some(path => this.$__.activePaths.getStatePaths('modify').hasOwnProperty(path));\n};\n\n/**\n * Checks if `path` is in the `init` state, that is, it was set by `Document#init()` and not modified since.\n *\n * @param {String} [path]\n * @return {Boolean}\n * @api public\n */\n\nDocument.prototype.isInit = function(path) {\n  if (path == null) {\n    return this.$__.activePaths.some('init');\n  }\n\n  if (typeof path === 'string' && path.indexOf(' ') === -1) {\n    return this.$__.activePaths.getStatePaths('init').hasOwnProperty(path);\n  }\n\n  let paths = path;\n  if (!Array.isArray(paths)) {\n    paths = paths.split(' ');\n  }\n\n  return paths.some(path => this.$__.activePaths.getStatePaths('init').hasOwnProperty(path));\n};\n\n/**\n * Checks if `path` was selected in the source query which initialized this document.\n *\n * #### Example:\n *\n *     const doc = await Thing.findOne().select('name');\n *     doc.isSelected('name') // true\n *     doc.isSelected('age')  // false\n *\n * @param {String|String[]} path\n * @return {Boolean}\n * @api public\n */\n\nDocument.prototype.isSelected = function isSelected(path) {\n  if (this.$__.selected == null) {\n    return true;\n  }\n  if (!path) {\n    return false;\n  }\n  if (path === '_id') {\n    return this.$__.selected._id !== 0;\n  }\n\n  if (path.indexOf(' ') !== -1) {\n    path = path.split(' ');\n  }\n  if (Array.isArray(path)) {\n    return path.some(p => this.$__isSelected(p));\n  }\n\n  const paths = Object.keys(this.$__.selected);\n  let inclusive = null;\n\n  if (paths.length === 1 && paths[0] === '_id') {\n    // only _id was selected.\n    return this.$__.selected._id === 0;\n  }\n\n  for (const cur of paths) {\n    if (cur === '_id') {\n      continue;\n    }\n    if (!isDefiningProjection(this.$__.selected[cur])) {\n      continue;\n    }\n    inclusive = !!this.$__.selected[cur];\n    break;\n  }\n\n  if (inclusive === null) {\n    return true;\n  }\n\n  if (path in this.$__.selected) {\n    return inclusive;\n  }\n\n  const pathDot = path + '.';\n\n  for (const cur of paths) {\n    if (cur === '_id') {\n      continue;\n    }\n\n    if (cur.startsWith(pathDot)) {\n      return inclusive || cur !== pathDot;\n    }\n\n    if (pathDot.startsWith(cur + '.')) {\n      return inclusive;\n    }\n  }\n  return !inclusive;\n};\n\nDocument.prototype.$__isSelected = Document.prototype.isSelected;\n\n/**\n * Checks if `path` was explicitly selected. If no projection, always returns\n * true.\n *\n * #### Example:\n *\n *     Thing.findOne().select('nested.name').exec(function (err, doc) {\n *        doc.isDirectSelected('nested.name') // true\n *        doc.isDirectSelected('nested.otherName') // false\n *        doc.isDirectSelected('nested')  // false\n *     })\n *\n * @param {String} path\n * @return {Boolean}\n * @api public\n */\n\nDocument.prototype.isDirectSelected = function isDirectSelected(path) {\n  if (this.$__.selected == null) {\n    return true;\n  }\n\n  if (path === '_id') {\n    return this.$__.selected._id !== 0;\n  }\n\n  if (path.indexOf(' ') !== -1) {\n    path = path.split(' ');\n  }\n  if (Array.isArray(path)) {\n    return path.some(p => this.isDirectSelected(p));\n  }\n\n  const paths = Object.keys(this.$__.selected);\n  let inclusive = null;\n\n  if (paths.length === 1 && paths[0] === '_id') {\n    // only _id was selected.\n    return this.$__.selected._id === 0;\n  }\n\n  for (const cur of paths) {\n    if (cur === '_id') {\n      continue;\n    }\n    if (!isDefiningProjection(this.$__.selected[cur])) {\n      continue;\n    }\n    inclusive = !!this.$__.selected[cur];\n    break;\n  }\n\n  if (inclusive === null) {\n    return true;\n  }\n\n  if (this.$__.selected.hasOwnProperty(path)) {\n    return inclusive;\n  }\n\n  return !inclusive;\n};\n\n/**\n * Executes registered validation rules for this document.\n *\n * #### Note:\n *\n * This method is called `pre` save and if a validation rule is violated, [save](https://mongoosejs.com/docs/api/model.html#Model.prototype.save()) is aborted and the error is thrown.\n *\n * #### Example:\n *\n *     await doc.validate({ validateModifiedOnly: false, pathsToSkip: ['name', 'email']});\n *\n * @param {Array|String} [pathsToValidate] list of paths to validate. If set, Mongoose will validate only the modified paths that are in the given list.\n * @param {Object} [options] internal options\n * @param {Boolean} [options.validateModifiedOnly=false] if `true` mongoose validates only modified paths.\n * @param {Array|string} [options.pathsToSkip] list of paths to skip. If set, Mongoose will validate every modified path that is not in this list.\n * @return {Promise} Returns a Promise.\n * @api public\n */\n\nDocument.prototype.validate = async function validate(pathsToValidate, options) {\n  if (typeof pathsToValidate === 'function' || typeof options === 'function' || typeof arguments[2] === 'function') {\n    throw new MongooseError('Document.prototype.validate() no longer accepts a callback');\n  }\n  let parallelValidate;\n  this.$op = 'validate';\n\n  if (this.$isSubdocument != null) {\n    // Skip parallel validate check for subdocuments\n  } else if (this.$__.validating) {\n    parallelValidate = new ParallelValidateError(this, {\n      parentStack: options && options.parentStack,\n      conflictStack: this.$__.validating.stack\n    });\n  } else {\n    this.$__.validating = new ParallelValidateError(this, { parentStack: options && options.parentStack });\n  }\n\n  if (arguments.length === 1) {\n    if (typeof arguments[0] === 'object' && !Array.isArray(arguments[0])) {\n      options = arguments[0];\n      pathsToValidate = null;\n    }\n  }\n  if (options && typeof options.pathsToSkip === 'string') {\n    const isOnePathOnly = options.pathsToSkip.indexOf(' ') === -1;\n    options.pathsToSkip = isOnePathOnly ? [options.pathsToSkip] : options.pathsToSkip.split(' ');\n  }\n\n  if (parallelValidate != null) {\n    throw parallelValidate;\n  }\n\n  return new Promise((resolve, reject) => {\n    this.$__validate(pathsToValidate, options, (error) => {\n      this.$op = null;\n      this.$__.validating = null;\n      if (error != null) {\n        return reject(error);\n      }\n      resolve();\n    });\n  });\n};\n\n/**\n * Alias of [`.validate`](https://mongoosejs.com/docs/api/document.html#Document.prototype.validate())\n *\n * @method $validate\n * @memberOf Document\n * @api public\n */\n\nDocument.prototype.$validate = Document.prototype.validate;\n\n/*!\n * ignore\n */\n\nfunction _evaluateRequiredFunctions(doc) {\n  const requiredFields = Object.keys(doc.$__.activePaths.getStatePaths('require'));\n  let i = 0;\n  const len = requiredFields.length;\n  for (i = 0; i < len; ++i) {\n    const path = requiredFields[i];\n\n    const p = doc.$__schema.path(path);\n\n    if (p != null && typeof p.originalRequiredValue === 'function') {\n      doc.$__.cachedRequired = doc.$__.cachedRequired || {};\n      try {\n        doc.$__.cachedRequired[path] = p.originalRequiredValue.call(doc, doc);\n      } catch (err) {\n        doc.invalidate(path, err);\n      }\n    }\n  }\n}\n\n/*!\n * ignore\n */\n\nfunction _getPathsToValidate(doc, pathsToValidate, pathsToSkip) {\n  const doValidateOptions = {};\n\n  _evaluateRequiredFunctions(doc);\n  // only validate required fields when necessary\n  let paths = new Set(Object.keys(doc.$__.activePaths.getStatePaths('require')).filter(function(path) {\n    if (!doc.$__isSelected(path) && !doc.$isModified(path)) {\n      return false;\n    }\n    if (doc.$__.cachedRequired != null && path in doc.$__.cachedRequired) {\n      return doc.$__.cachedRequired[path];\n    }\n    return true;\n  }));\n\n  Object.keys(doc.$__.activePaths.getStatePaths('init')).forEach(addToPaths);\n  Object.keys(doc.$__.activePaths.getStatePaths('modify')).forEach(addToPaths);\n  Object.keys(doc.$__.activePaths.getStatePaths('default')).forEach(addToPaths);\n  function addToPaths(p) { paths.add(p); }\n\n  const subdocs = doc.$getAllSubdocs();\n  const modifiedPaths = doc.modifiedPaths();\n  for (const subdoc of subdocs) {\n    if (subdoc.$basePath) {\n      const fullPathToSubdoc = subdoc.$isSingleNested ? subdoc.$__pathRelativeToParent() : subdoc.$__fullPathWithIndexes();\n\n      // Remove child paths for now, because we'll be validating the whole\n      // subdoc.\n      // The following is a faster take on looping through every path in `paths`\n      // and checking if the path starts with `fullPathToSubdoc` re: gh-13191\n      for (const modifiedPath of subdoc.modifiedPaths()) {\n        paths.delete(fullPathToSubdoc + '.' + modifiedPath);\n      }\n\n      if (doc.$isModified(fullPathToSubdoc, null, modifiedPaths) &&\n            !doc.isDirectModified(fullPathToSubdoc) &&\n            !doc.$isDefault(fullPathToSubdoc)) {\n        paths.add(fullPathToSubdoc);\n        if (doc.$__.pathsToScopes == null) {\n          doc.$__.pathsToScopes = {};\n        }\n        doc.$__.pathsToScopes[fullPathToSubdoc] = subdoc.$isDocumentArrayElement ?\n          subdoc.__parentArray :\n          subdoc.$parent();\n\n        doValidateOptions[fullPathToSubdoc] = { skipSchemaValidators: true };\n        if (subdoc.$isDocumentArrayElement && subdoc.__index != null) {\n          doValidateOptions[fullPathToSubdoc].index = subdoc.__index;\n        }\n      }\n    }\n  }\n\n  for (const path of paths) {\n    const _pathType = doc.$__schema.path(path);\n    if (!_pathType) {\n      continue;\n    }\n\n    if (_pathType.$isMongooseDocumentArray) {\n      for (const p of paths) {\n        if (p == null || p.startsWith(_pathType.path + '.')) {\n          paths.delete(p);\n        }\n      }\n    }\n\n    // Optimization: if primitive path with no validators, or array of primitives\n    // with no validators, skip validating this path entirely.\n    if (!_pathType.caster && _pathType.validators.length === 0 && !_pathType.$parentSchemaDocArray) {\n      paths.delete(path);\n    } else if (_pathType.$isMongooseArray &&\n      !_pathType.$isMongooseDocumentArray && // Skip document arrays...\n      !_pathType.$embeddedSchemaType.$isMongooseArray && // and arrays of arrays\n      _pathType.validators.length === 0 && // and arrays with top-level validators\n      _pathType.$embeddedSchemaType.validators.length === 0) {\n      paths.delete(path);\n    }\n  }\n\n  for (const path of paths) {\n    // Single nested paths (paths embedded under single nested subdocs) will\n    // be validated on their own when we call `validate()` on the subdoc itself.\n    // Re: gh-8468\n    if (doc.$__schema.singleNestedPaths.hasOwnProperty(path)) {\n      paths.delete(path);\n      continue;\n    }\n  }\n\n  if (Array.isArray(pathsToValidate)) {\n    paths = _handlePathsToValidate(paths, pathsToValidate);\n  } else if (Array.isArray(pathsToSkip)) {\n    paths = _handlePathsToSkip(paths, pathsToSkip);\n  }\n\n  // from here on we're not removing items from paths\n\n  // gh-661: if a whole array is modified, make sure to run validation on all\n  // the children as well\n  for (const path of paths) {\n    const _pathType = doc.$__schema.path(path);\n    if (!_pathType) {\n      continue;\n    }\n\n    if (!_pathType.$isMongooseArray ||\n        // To avoid potential performance issues, skip doc arrays whose children\n        // are not required. `getPositionalPathType()` may be slow, so avoid\n        // it unless we have a case of #6364\n        (!Array.isArray(_pathType) &&\n          _pathType.$isMongooseDocumentArray &&\n          !(_pathType && _pathType.schemaOptions && _pathType.schemaOptions.required))) {\n      continue;\n    }\n\n    // gh-11380: optimization. If the array isn't a document array and there's no validators\n    // on the array type, there's no need to run validation on the individual array elements.\n    if (_pathType.$isMongooseArray &&\n        !_pathType.$isMongooseDocumentArray && // Skip document arrays...\n        !_pathType.$embeddedSchemaType.$isMongooseArray && // and arrays of arrays\n        _pathType.$embeddedSchemaType.validators.length === 0) {\n      continue;\n    }\n\n    const val = doc.$__getValue(path);\n    _pushNestedArrayPaths(val, paths, path);\n  }\n\n  function _pushNestedArrayPaths(val, paths, path) {\n    if (val != null) {\n      const numElements = val.length;\n      for (let j = 0; j < numElements; ++j) {\n        if (Array.isArray(val[j])) {\n          _pushNestedArrayPaths(val[j], paths, path + '.' + j);\n        } else {\n          paths.add(path + '.' + j);\n        }\n      }\n    }\n  }\n\n  const flattenOptions = { skipArrays: true };\n  for (const pathToCheck of paths) {\n    if (doc.$__schema.nested[pathToCheck]) {\n      let _v = doc.$__getValue(pathToCheck);\n      if (isMongooseObject(_v)) {\n        _v = _v.toObject({ transform: false });\n      }\n      const flat = flatten(_v, pathToCheck, flattenOptions, doc.$__schema);\n      Object.keys(flat).forEach(addToPaths);\n    }\n  }\n\n  for (const path of paths) {\n    const _pathType = doc.$__schema.path(path);\n\n    if (!_pathType) {\n      continue;\n    }\n\n    // If underneath a document array, may need to re-validate the parent\n    // array re: gh-6818. Do this _after_ adding subpaths, because\n    // we don't want to add every array subpath.\n    if (_pathType.$parentSchemaDocArray && typeof _pathType.$parentSchemaDocArray.path === 'string') {\n      paths.add(_pathType.$parentSchemaDocArray.path);\n    }\n\n    if (!_pathType.$isSchemaMap) {\n      continue;\n    }\n\n    const val = doc.$__getValue(path);\n    if (val == null) {\n      continue;\n    }\n    for (const key of val.keys()) {\n      paths.add(path + '.' + key);\n    }\n  }\n\n  paths = Array.from(paths);\n  return [paths, doValidateOptions];\n}\n\n/*!\n * ignore\n */\n\nDocument.prototype.$__validate = function(pathsToValidate, options, callback) {\n  if (typeof pathsToValidate === 'function') {\n    callback = pathsToValidate;\n    options = null;\n    pathsToValidate = null;\n  } else if (typeof options === 'function') {\n    callback = options;\n    options = null;\n  }\n\n  const hasValidateModifiedOnlyOption = options &&\n      (typeof options === 'object') &&\n      ('validateModifiedOnly' in options);\n\n  const pathsToSkip = (options && options.pathsToSkip) || null;\n\n  let shouldValidateModifiedOnly;\n  if (hasValidateModifiedOnlyOption) {\n    shouldValidateModifiedOnly = !!options.validateModifiedOnly;\n  } else {\n    shouldValidateModifiedOnly = this.$__schema.options.validateModifiedOnly;\n  }\n\n  const _this = this;\n  const _complete = () => {\n    let validationError = this.$__.validationError;\n    this.$__.validationError = null;\n    this.$__.validating = null;\n\n    if (shouldValidateModifiedOnly && validationError != null) {\n      // Remove any validation errors that aren't from modified paths\n      const errors = Object.keys(validationError.errors);\n      for (const errPath of errors) {\n        if (!this.$isModified(errPath)) {\n          delete validationError.errors[errPath];\n        }\n      }\n      if (Object.keys(validationError.errors).length === 0) {\n        validationError = void 0;\n      }\n    }\n\n    this.$__.cachedRequired = {};\n    this.$emit('validate', _this);\n    this.constructor.emit('validate', _this);\n\n    if (validationError) {\n      for (const key in validationError.errors) {\n        // Make sure cast errors persist\n        if (!this[documentArrayParent] &&\n            validationError.errors[key] instanceof MongooseError.CastError) {\n          this.invalidate(key, validationError.errors[key]);\n        }\n      }\n\n      return validationError;\n    }\n  };\n\n  // only validate required fields when necessary\n  const pathDetails = _getPathsToValidate(this, pathsToValidate, pathsToSkip);\n  const paths = shouldValidateModifiedOnly ?\n    pathDetails[0].filter((path) => this.$isModified(path)) :\n    pathDetails[0];\n  const doValidateOptionsByPath = pathDetails[1];\n  if (typeof pathsToValidate === 'string') {\n    pathsToValidate = pathsToValidate.split(' ');\n  }\n\n  if (paths.length === 0) {\n    return immediate(function() {\n      const error = _complete();\n      if (error) {\n        return _this.$__schema.s.hooks.execPost('validate:error', _this, [_this], { error: error }, function(error) {\n          callback(error);\n        });\n      }\n      callback(null, _this);\n    });\n  }\n\n  const validated = {};\n  let total = 0;\n\n  for (const path of paths) {\n    validatePath(path);\n  }\n\n  function validatePath(path) {\n    if (path == null || validated[path]) {\n      return;\n    }\n\n    validated[path] = true;\n    total++;\n\n    immediate(function() {\n      const schemaType = _this.$__schema.path(path);\n\n      if (!schemaType) {\n        return --total || complete();\n      }\n\n      // If user marked as invalid or there was a cast error, don't validate\n      if (!_this.$isValid(path)) {\n        --total || complete();\n        return;\n      }\n\n      // If setting a path under a mixed path, avoid using the mixed path validator (gh-10141)\n      if (schemaType[schemaMixedSymbol] != null && path !== schemaType.path) {\n        return --total || complete();\n      }\n\n      let val = _this.$__getValue(path);\n\n      // If you `populate()` and get back a null value, required validators\n      // shouldn't fail (gh-8018). We should always fall back to the populated\n      // value.\n      let pop;\n      if ((pop = _this.$populated(path))) {\n        val = pop;\n      } else if (val != null && val.$__ != null && val.$__.wasPopulated) {\n        // Array paths, like `somearray.1`, do not show up as populated with `$populated()`,\n        // so in that case pull out the document's id\n        val = val._id;\n      }\n      const scope = _this.$__.pathsToScopes != null && path in _this.$__.pathsToScopes ?\n        _this.$__.pathsToScopes[path] :\n        _this;\n\n      const doValidateOptions = {\n        ...doValidateOptionsByPath[path],\n        path: path,\n        validateModifiedOnly: shouldValidateModifiedOnly\n      };\n\n      schemaType.doValidate(val, function(err) {\n        if (err) {\n          const isSubdoc = schemaType.$isSingleNested ||\n              schemaType.$isArraySubdocument ||\n              schemaType.$isMongooseDocumentArray;\n          if (isSubdoc && err instanceof ValidationError) {\n            return --total || complete();\n          }\n          _this.invalidate(path, err, undefined, true);\n        }\n        --total || complete();\n      }, scope, doValidateOptions);\n    });\n  }\n\n  function complete() {\n    const error = _complete();\n    if (error) {\n      return _this.$__schema.s.hooks.execPost('validate:error', _this, [_this], { error: error }, function(error) {\n        callback(error);\n      });\n    }\n    callback(null, _this);\n  }\n\n};\n\n/*!\n * ignore\n */\n\nfunction _handlePathsToValidate(paths, pathsToValidate) {\n  const _pathsToValidate = new Set(pathsToValidate);\n  const parentPaths = new Map([]);\n  for (const path of pathsToValidate) {\n    if (path.indexOf('.') === -1) {\n      continue;\n    }\n    const pieces = path.split('.');\n    let cur = pieces[0];\n    for (let i = 1; i < pieces.length; ++i) {\n      // Since we skip subpaths under single nested subdocs to\n      // avoid double validation, we need to add back the\n      // single nested subpath if the user asked for it (gh-8626)\n      parentPaths.set(cur, path);\n      cur = cur + '.' + pieces[i];\n    }\n  }\n\n  const ret = new Set();\n  for (const path of paths) {\n    if (_pathsToValidate.has(path)) {\n      ret.add(path);\n    } else if (parentPaths.has(path)) {\n      ret.add(parentPaths.get(path));\n    }\n  }\n  return ret;\n}\n\n/*!\n * ignore\n */\n\nfunction _handlePathsToSkip(paths, pathsToSkip) {\n  pathsToSkip = new Set(pathsToSkip);\n  paths = Array.from(paths).filter(p => !pathsToSkip.has(p));\n  return new Set(paths);\n}\n\n/**\n * Executes registered validation rules (skipping asynchronous validators) for this document.\n *\n * #### Note:\n *\n * This method is useful if you need synchronous validation.\n *\n * #### Example:\n *\n *     const err = doc.validateSync();\n *     if (err) {\n *       handleError(err);\n *     } else {\n *       // validation passed\n *     }\n *\n * @param {Array|string} [pathsToValidate] only validate the given paths\n * @param {Object} [options] options for validation\n * @param {Boolean} [options.validateModifiedOnly=false] If `true`, Mongoose will only validate modified paths, as opposed to modified paths and `required` paths.\n * @param {Array|string} [options.pathsToSkip] list of paths to skip. If set, Mongoose will validate every modified path that is not in this list.\n * @return {ValidationError|undefined} ValidationError if there are errors during validation, or undefined if there is no error.\n * @api public\n */\n\nDocument.prototype.validateSync = function(pathsToValidate, options) {\n  const _this = this;\n\n  if (arguments.length === 1 && typeof arguments[0] === 'object' && !Array.isArray(arguments[0])) {\n    options = arguments[0];\n    pathsToValidate = null;\n  }\n\n  const hasValidateModifiedOnlyOption = options &&\n      (typeof options === 'object') &&\n      ('validateModifiedOnly' in options);\n\n  let shouldValidateModifiedOnly;\n  if (hasValidateModifiedOnlyOption) {\n    shouldValidateModifiedOnly = !!options.validateModifiedOnly;\n  } else {\n    shouldValidateModifiedOnly = this.$__schema.options.validateModifiedOnly;\n  }\n\n  let pathsToSkip = options && options.pathsToSkip;\n\n  if (typeof pathsToValidate === 'string') {\n    const isOnePathOnly = pathsToValidate.indexOf(' ') === -1;\n    pathsToValidate = isOnePathOnly ? [pathsToValidate] : pathsToValidate.split(' ');\n  } else if (typeof pathsToSkip === 'string' && pathsToSkip.indexOf(' ') !== -1) {\n    pathsToSkip = pathsToSkip.split(' ');\n  }\n\n  // only validate required fields when necessary\n  const pathDetails = _getPathsToValidate(this, pathsToValidate, pathsToSkip);\n  const paths = shouldValidateModifiedOnly ?\n    pathDetails[0].filter((path) => this.$isModified(path)) :\n    pathDetails[0];\n  const skipSchemaValidators = pathDetails[1];\n\n  const validating = {};\n\n  for (let i = 0, len = paths.length; i < len; ++i) {\n    const path = paths[i];\n\n    if (validating[path]) {\n      continue;\n    }\n\n    validating[path] = true;\n\n    const p = _this.$__schema.path(path);\n    if (!p) {\n      continue;\n    }\n    if (!_this.$isValid(path)) {\n      continue;\n    }\n\n    const val = _this.$__getValue(path);\n    const err = p.doValidateSync(val, _this, {\n      skipSchemaValidators: skipSchemaValidators[path],\n      path: path,\n      validateModifiedOnly: shouldValidateModifiedOnly\n    });\n    if (err) {\n      const isSubdoc = p.$isSingleNested ||\n        p.$isArraySubdocument ||\n        p.$isMongooseDocumentArray;\n      if (isSubdoc && err instanceof ValidationError) {\n        continue;\n      }\n      _this.invalidate(path, err, undefined, true);\n    }\n  }\n\n  const err = _this.$__.validationError;\n  _this.$__.validationError = undefined;\n  _this.$emit('validate', _this);\n  _this.constructor.emit('validate', _this);\n\n  if (err) {\n    for (const key in err.errors) {\n      // Make sure cast errors persist\n      if (err.errors[key] instanceof MongooseError.CastError) {\n        _this.invalidate(key, err.errors[key]);\n      }\n    }\n  }\n\n  return err;\n};\n\n/**\n * Marks a path as invalid, causing validation to fail.\n *\n * The `errorMsg` argument will become the message of the `ValidationError`.\n *\n * The `value` argument (if passed) will be available through the `ValidationError.value` property.\n *\n *     doc.invalidate('size', 'must be less than 20', 14);\n *\n *     doc.validate(function (err) {\n *       console.log(err)\n *       // prints\n *       { message: 'Validation failed',\n *         name: 'ValidationError',\n *         errors:\n *          { size:\n *             { message: 'must be less than 20',\n *               name: 'ValidatorError',\n *               path: 'size',\n *               type: 'user defined',\n *               value: 14 } } }\n *     })\n *\n * @param {String} path the field to invalidate. For array elements, use the `array.i.field` syntax, where `i` is the 0-based index in the array.\n * @param {String|Error} err the error which states the reason `path` was invalid\n * @param {Object|String|Number|any} val optional invalid value\n * @param {String} [kind] optional `kind` property for the error\n * @return {ValidationError} the current ValidationError, with all currently invalidated paths\n * @api public\n */\n\nDocument.prototype.invalidate = function(path, err, val, kind) {\n  if (!this.$__.validationError) {\n    this.$__.validationError = new ValidationError(this);\n  }\n\n  if (this.$__.validationError.errors[path]) {\n    return;\n  }\n\n  if (!err || typeof err === 'string') {\n    err = new ValidatorError({\n      path: path,\n      message: err,\n      type: kind || 'user defined',\n      value: val\n    });\n  }\n\n  if (this.$__.validationError === err) {\n    return this.$__.validationError;\n  }\n\n  this.$__.validationError.addError(path, err);\n  return this.$__.validationError;\n};\n\n/**\n * Marks a path as valid, removing existing validation errors.\n *\n * @param {String} path the field to mark as valid\n * @api public\n * @memberOf Document\n * @instance\n * @method $markValid\n */\n\nDocument.prototype.$markValid = function(path) {\n  if (!this.$__.validationError || !this.$__.validationError.errors[path]) {\n    return;\n  }\n\n  delete this.$__.validationError.errors[path];\n  if (Object.keys(this.$__.validationError.errors).length === 0) {\n    this.$__.validationError = null;\n  }\n};\n\n/*!\n * ignore\n */\n\nfunction _markValidSubpaths(doc, path) {\n  if (!doc.$__.validationError) {\n    return;\n  }\n\n  const keys = Object.keys(doc.$__.validationError.errors);\n  for (const key of keys) {\n    if (key.startsWith(path + '.')) {\n      delete doc.$__.validationError.errors[key];\n    }\n  }\n  if (Object.keys(doc.$__.validationError.errors).length === 0) {\n    doc.$__.validationError = null;\n  }\n}\n\n/*!\n * ignore\n */\n\nfunction _checkImmutableSubpaths(subdoc, schematype, priorVal) {\n  const schema = schematype.schema;\n  if (schema == null) {\n    return;\n  }\n\n  for (const key of Object.keys(schema.paths)) {\n    const path = schema.paths[key];\n    if (path.$immutableSetter == null) {\n      continue;\n    }\n    const oldVal = priorVal == null ? void 0 : priorVal.$__getValue(key);\n    // Calling immutableSetter with `oldVal` even though it expects `newVal`\n    // is intentional. That's because `$immutableSetter` compares its param\n    // to the current value.\n    path.$immutableSetter.call(subdoc, oldVal);\n  }\n}\n\n/**\n * Saves this document by inserting a new document into the database if [document.isNew](https://mongoosejs.com/docs/api/document.html#Document.prototype.isNew()) is `true`,\n * or sends an [updateOne](https://mongoosejs.com/docs/api/document.html#Document.prototype.updateOne()) operation **only** with the modifications to the database, it does not replace the whole document in the latter case.\n *\n * #### Example:\n *\n *     product.sold = Date.now();\n *     product = await product.save();\n *\n * If save is successful, the returned promise will fulfill with the document\n * saved.\n *\n * #### Example:\n *\n *     const newProduct = await product.save();\n *     newProduct === product; // true\n *\n * @param {Object} [options] options optional options\n * @param {Session} [options.session=null] the [session](https://www.mongodb.com/docs/manual/reference/server-sessions/) associated with this save operation. If not specified, defaults to the [document's associated session](https://mongoosejs.com/docs/api/document.html#Document.prototype.$session()).\n * @param {Object} [options.safe] (DEPRECATED) overrides [schema's safe option](https://mongoosejs.com/docs/guide.html#safe). Use the `w` option instead.\n * @param {Boolean} [options.validateBeforeSave] set to false to save without validating.\n * @param {Boolean} [options.validateModifiedOnly=false] If `true`, Mongoose will only validate modified paths, as opposed to modified paths and `required` paths.\n * @param {Number|String} [options.w] set the [write concern](https://www.mongodb.com/docs/manual/reference/write-concern/#w-option). Overrides the [schema-level `writeConcern` option](https://mongoosejs.com/docs/guide.html#writeConcern)\n * @param {Boolean} [options.j] set to true for MongoDB to wait until this `save()` has been [journaled before resolving the returned promise](https://www.mongodb.com/docs/manual/reference/write-concern/#j-option). Overrides the [schema-level `writeConcern` option](https://mongoosejs.com/docs/guide.html#writeConcern)\n * @param {Number} [options.wtimeout] sets a [timeout for the write concern](https://www.mongodb.com/docs/manual/reference/write-concern/#wtimeout). Overrides the [schema-level `writeConcern` option](https://mongoosejs.com/docs/guide.html#writeConcern).\n * @param {Boolean} [options.checkKeys=true] the MongoDB driver prevents you from saving keys that start with '$' or contain '.' by default. Set this option to `false` to skip that check. See [restrictions on field names](https://www.mongodb.com/docs/manual/reference/limits/#Restrictions-on-Field-Names)\n * @param {Boolean} [options.timestamps=true] if `false` and [timestamps](https://mongoosejs.com/docs/guide.html#timestamps) are enabled, skip timestamps for this `save()`.\n * @param {Function} [fn] optional callback\n * @method save\n * @memberOf Document\n * @instance\n * @throws {DocumentNotFoundError} if this [save updates an existing document](https://mongoosejs.com/docs/api/document.html#Document.prototype.isNew()) but the document doesn't exist in the database. For example, you will get this error if the document is [deleted between when you retrieved the document and when you saved it](documents.html#updating).\n * @return {Promise|undefined} Returns undefined if used with callback or a Promise otherwise.\n * @api public\n * @see middleware https://mongoosejs.com/docs/middleware.html\n */\n\n/**\n * Checks if a path is invalid\n *\n * @param {String|String[]} [path] the field to check. If unset will always return \"false\"\n * @method $isValid\n * @memberOf Document\n * @instance\n * @api private\n */\n\nDocument.prototype.$isValid = function(path) {\n  if (this.$__.validationError == null || Object.keys(this.$__.validationError.errors).length === 0) {\n    return true;\n  }\n  if (path == null) {\n    return false;\n  }\n\n  if (path.indexOf(' ') !== -1) {\n    path = path.split(' ');\n  }\n  if (Array.isArray(path)) {\n    return path.some(p => this.$__.validationError.errors[p] == null);\n  }\n\n  return this.$__.validationError.errors[path] == null;\n};\n\n/**\n * Resets the internal modified state of this document.\n *\n * @api private\n * @return {Document} this\n * @method $__reset\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.$__reset = function reset() {\n  let _this = this;\n\n  // Skip for subdocuments\n  const subdocs = this.$parent() === this ? this.$getAllSubdocs() : [];\n  const resetArrays = new Set();\n  for (const subdoc of subdocs) {\n    const fullPathWithIndexes = subdoc.$__fullPathWithIndexes();\n    subdoc.$__reset();\n    if (this.isModified(fullPathWithIndexes) || isParentInit(fullPathWithIndexes)) {\n      if (subdoc.$isDocumentArrayElement) {\n        resetArrays.add(subdoc.parentArray());\n      } else {\n        const parent = subdoc.$parent();\n        if (parent === this) {\n          this.$__.activePaths.clearPath(subdoc.$basePath);\n        } else if (parent != null && parent.$isSubdocument) {\n          // If map path underneath subdocument, may end up with a case where\n          // map path is modified but parent still needs to be reset. See gh-10295\n          parent.$__reset();\n        }\n      }\n    }\n  }\n\n  for (const array of resetArrays) {\n    this.$__.activePaths.clearPath(array.$path());\n    array[arrayAtomicsBackupSymbol] = array[arrayAtomicsSymbol];\n    array[arrayAtomicsSymbol] = {};\n  }\n\n  function isParentInit(path) {\n    path = path.indexOf('.') === -1 ? [path] : path.split('.');\n    let cur = '';\n    for (let i = 0; i < path.length; ++i) {\n      cur += (cur.length ? '.' : '') + path[i];\n      if (_this.$__.activePaths[cur] === 'init') {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  // clear atomics\n  this.$__dirty().forEach(function(dirt) {\n    const type = dirt.value;\n\n    if (type && type[arrayAtomicsSymbol]) {\n      type[arrayAtomicsBackupSymbol] = type[arrayAtomicsSymbol];\n      type[arrayAtomicsSymbol] = {};\n    }\n  });\n\n  this.$__.backup = {};\n  this.$__.backup.activePaths = {\n    modify: Object.assign({}, this.$__.activePaths.getStatePaths('modify')),\n    default: Object.assign({}, this.$__.activePaths.getStatePaths('default'))\n  };\n  this.$__.backup.validationError = this.$__.validationError;\n  this.$__.backup.errors = this.$errors;\n\n  // Clear 'dirty' cache\n  this.$__.activePaths.clear('modify');\n  this.$__.activePaths.clear('default');\n  this.$__.validationError = undefined;\n  this.$errors = undefined;\n  _this = this;\n  this.$__schema.requiredPaths().forEach(function(path) {\n    _this.$__.activePaths.require(path);\n  });\n\n  return this;\n};\n\n/*!\n * ignore\n */\n\nDocument.prototype.$__undoReset = function $__undoReset() {\n  if (this.$__.backup == null || this.$__.backup.activePaths == null) {\n    return;\n  }\n\n  this.$__.activePaths.states.modify = this.$__.backup.activePaths.modify;\n  this.$__.activePaths.states.default = this.$__.backup.activePaths.default;\n\n  this.$__.validationError = this.$__.backup.validationError;\n  this.$errors = this.$__.backup.errors;\n\n  for (const dirt of this.$__dirty()) {\n    const type = dirt.value;\n\n    if (type && type[arrayAtomicsSymbol] && type[arrayAtomicsBackupSymbol]) {\n      type[arrayAtomicsSymbol] = type[arrayAtomicsBackupSymbol];\n    }\n  }\n\n  for (const subdoc of this.$getAllSubdocs()) {\n    subdoc.$__undoReset();\n  }\n};\n\n/**\n * Returns this documents dirty paths / vals.\n *\n * @return {Array}\n * @api private\n * @method $__dirty\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.$__dirty = function() {\n  const _this = this;\n  let all = this.$__.activePaths.map('modify', function(path) {\n    return {\n      path: path,\n      value: _this.$__getValue(path),\n      schema: _this.$__path(path)\n    };\n  });\n\n  // gh-2558: if we had to set a default and the value is not undefined,\n  // we have to save as well\n  all = all.concat(this.$__.activePaths.map('default', function(path) {\n    if (path === '_id' || _this.$__getValue(path) == null) {\n      return;\n    }\n    return {\n      path: path,\n      value: _this.$__getValue(path),\n      schema: _this.$__path(path)\n    };\n  }));\n\n  const allPaths = new Map(all.filter((el) => el != null).map((el) => [el.path, el.value]));\n  // Ignore \"foo.a\" if \"foo\" is dirty already.\n  const minimal = [];\n\n  all.forEach(function(item) {\n    if (!item) {\n      return;\n    }\n\n    let top = null;\n\n    const array = parentPaths(item.path);\n    for (let i = 0; i < array.length - 1; i++) {\n      if (allPaths.has(array[i])) {\n        top = allPaths.get(array[i]);\n        break;\n      }\n    }\n    if (top == null) {\n      minimal.push(item);\n    } else if (top != null &&\n        top[arrayAtomicsSymbol] != null &&\n        top.hasAtomics()) {\n      // special case for top level MongooseArrays\n      // the `top` array itself and a sub path of `top` are being set.\n      // the only way to honor all of both modifications is through a $set\n      // of entire array.\n      top[arrayAtomicsSymbol] = {};\n      top[arrayAtomicsSymbol].$set = top;\n    }\n  });\n  return minimal;\n};\n\n/**\n * Assigns/compiles `schema` into this documents prototype.\n *\n * @param {Schema} schema\n * @api private\n * @method $__setSchema\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.$__setSchema = function(schema) {\n  compile(schema.tree, this, undefined, schema.options);\n\n  // Apply default getters if virtual doesn't have any (gh-6262)\n  for (const key of Object.keys(schema.virtuals)) {\n    schema.virtuals[key]._applyDefaultGetters();\n  }\n  if (schema.path('schema') == null) {\n    this.schema = schema;\n  }\n  this.$__schema = schema;\n  this[documentSchemaSymbol] = schema;\n};\n\n\n/**\n * Get active path that were changed and are arrays\n *\n * @return {Array}\n * @api private\n * @method $__getArrayPathsToValidate\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.$__getArrayPathsToValidate = function() {\n  DocumentArray || (DocumentArray = __webpack_require__(/*! ./types/documentArray */ \"../server/node_modules/mongoose/lib/types/documentArray/index.js\"));\n\n  // validate all document arrays.\n  return this.$__.activePaths\n    .map('init', 'modify', function(i) {\n      return this.$__getValue(i);\n    }.bind(this))\n    .filter(function(val) {\n      return val && Array.isArray(val) && utils.isMongooseDocumentArray(val) && val.length;\n    }).reduce(function(seed, array) {\n      return seed.concat(array);\n    }, [])\n    .filter(function(doc) {\n      return doc;\n    });\n};\n\n\n/**\n * Get all subdocs (by bfs)\n *\n * @return {Array}\n * @api public\n * @method $getAllSubdocs\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.$getAllSubdocs = function() {\n  DocumentArray || (DocumentArray = __webpack_require__(/*! ./types/documentArray */ \"../server/node_modules/mongoose/lib/types/documentArray/index.js\"));\n  Embedded = Embedded || __webpack_require__(/*! ./types/arraySubdocument */ \"../server/node_modules/mongoose/lib/types/arraySubdocument.js\");\n\n  function docReducer(doc, seed, path) {\n    let val = doc;\n    let isNested = false;\n    if (path) {\n      if (doc instanceof Document && doc[documentSchemaSymbol].paths[path]) {\n        val = doc._doc[path];\n      } else if (doc instanceof Document && doc[documentSchemaSymbol].nested[path]) {\n        val = doc._doc[path];\n        isNested = true;\n      } else {\n        val = doc[path];\n      }\n    }\n    if (val instanceof Embedded) {\n      seed.push(val);\n    } else if (val instanceof Map) {\n      seed = Array.from(val.keys()).reduce(function(seed, path) {\n        return docReducer(val.get(path), seed, null);\n      }, seed);\n    } else if (val && !Array.isArray(val) && val.$isSingleNested) {\n      seed = Object.keys(val._doc).reduce(function(seed, path) {\n        return docReducer(val, seed, path);\n      }, seed);\n      seed.push(val);\n    } else if (val && utils.isMongooseDocumentArray(val)) {\n      val.forEach(function _docReduce(doc) {\n        if (!doc || !doc._doc) {\n          return;\n        }\n        seed = Object.keys(doc._doc).reduce(function(seed, path) {\n          return docReducer(doc._doc, seed, path);\n        }, seed);\n        if (doc instanceof Embedded) {\n          seed.push(doc);\n        }\n      });\n    } else if (isNested && val != null) {\n      for (const path of Object.keys(val)) {\n        docReducer(val, seed, path);\n      }\n    }\n    return seed;\n  }\n\n  const subDocs = [];\n  for (const path of Object.keys(this._doc)) {\n    docReducer(this, subDocs, path);\n  }\n\n  return subDocs;\n};\n\n/*!\n * Runs queued functions\n */\n\nfunction applyQueue(doc) {\n  const q = doc.$__schema && doc.$__schema.callQueue;\n  if (!q.length) {\n    return;\n  }\n\n  for (const pair of q) {\n    if (pair[0] !== 'pre' && pair[0] !== 'post' && pair[0] !== 'on') {\n      doc[pair[0]].apply(doc, pair[1]);\n    }\n  }\n}\n\n/*!\n * ignore\n */\n\nDocument.prototype.$__handleReject = function handleReject(err) {\n  // emit on the Model if listening\n  if (this.$listeners('error').length) {\n    this.$emit('error', err);\n  } else if (this.constructor.listeners && this.constructor.listeners('error').length) {\n    this.constructor.emit('error', err);\n  }\n};\n\n/**\n * Internal helper for toObject() and toJSON() that doesn't manipulate options\n *\n * @return {Object}\n * @api private\n * @method $toObject\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.$toObject = function(options, json) {\n  let defaultOptions = {\n    transform: true,\n    flattenDecimals: true\n  };\n\n  const path = json ? 'toJSON' : 'toObject';\n  const baseOptions = this.constructor &&\n    this.constructor.base &&\n    this.constructor.base.options &&\n    get(this.constructor.base.options, path) || {};\n  const schemaOptions = this.$__schema && this.$__schema.options || {};\n  // merge base default options with Schema's set default options if available.\n  // `clone` is necessary here because `utils.options` directly modifies the second input.\n  defaultOptions = { ...defaultOptions, ...baseOptions, ...schemaOptions[path] };\n\n  // If options do not exist or is not an object, set it to empty object\n  options = utils.isPOJO(options) ? { ...options } : {};\n  options._calledWithOptions = options._calledWithOptions || { ...options };\n\n  let _minimize;\n  if (options._calledWithOptions.minimize != null) {\n    _minimize = options.minimize;\n  } else if (defaultOptions.minimize != null) {\n    _minimize = defaultOptions.minimize;\n  } else {\n    _minimize = schemaOptions.minimize;\n  }\n\n  let flattenMaps;\n  if (options._calledWithOptions.flattenMaps != null) {\n    flattenMaps = options.flattenMaps;\n  } else if (defaultOptions.flattenMaps != null) {\n    flattenMaps = defaultOptions.flattenMaps;\n  } else {\n    flattenMaps = schemaOptions.flattenMaps;\n  }\n\n  let flattenObjectIds;\n  if (options._calledWithOptions.flattenObjectIds != null) {\n    flattenObjectIds = options.flattenObjectIds;\n  } else if (defaultOptions.flattenObjectIds != null) {\n    flattenObjectIds = defaultOptions.flattenObjectIds;\n  } else {\n    flattenObjectIds = schemaOptions.flattenObjectIds;\n  }\n\n  // The original options that will be passed to `clone()`. Important because\n  // `clone()` will recursively call `$toObject()` on embedded docs, so we\n  // need the original options the user passed in, plus `_isNested` and\n  // `_parentOptions` for checking whether we need to depopulate.\n  const cloneOptions = Object.assign({}, options, {\n    _isNested: true,\n    json: json,\n    minimize: _minimize,\n    flattenMaps: flattenMaps,\n    flattenObjectIds: flattenObjectIds,\n    _seen: (options && options._seen) || new Map()\n  });\n\n  if (utils.hasUserDefinedProperty(options, 'getters')) {\n    cloneOptions.getters = options.getters;\n  }\n  if (utils.hasUserDefinedProperty(options, 'virtuals')) {\n    cloneOptions.virtuals = options.virtuals;\n  }\n\n  const depopulate = options.depopulate ||\n    (options._parentOptions && options._parentOptions.depopulate || false);\n  // _isNested will only be true if this is not the top level document, we\n  // should never depopulate the top-level document\n  if (depopulate && options._isNested && this.$__.wasPopulated) {\n    return clone(this.$__.wasPopulated.value || this._id, cloneOptions);\n  }\n\n  // merge default options with input options.\n  options = { ...defaultOptions, ...options };\n  options._isNested = true;\n  options.json = json;\n  options.minimize = _minimize;\n\n  cloneOptions._parentOptions = options;\n  cloneOptions._skipSingleNestedGetters = false;\n\n  const gettersOptions = Object.assign({}, cloneOptions);\n  gettersOptions._skipSingleNestedGetters = true;\n\n  // remember the root transform function\n  // to save it from being overwritten by sub-transform functions\n  const originalTransform = options.transform;\n\n  let ret = clone(this._doc, cloneOptions) || {};\n\n  if (options.getters) {\n    applyGetters(this, ret, gettersOptions);\n\n    if (options.minimize) {\n      ret = minimize(ret) || {};\n    }\n  }\n\n  if (options.virtuals || (options.getters && options.virtuals !== false)) {\n    applyVirtuals(this, ret, gettersOptions, options);\n  }\n\n  if (options.versionKey === false && this.$__schema.options.versionKey) {\n    delete ret[this.$__schema.options.versionKey];\n  }\n\n  let transform = options.transform;\n\n  // In the case where a subdocument has its own transform function, we need to\n  // check and see if the parent has a transform (options.transform) and if the\n  // child schema has a transform (this.schema.options.toObject) In this case,\n  // we need to adjust options.transform to be the child schema's transform and\n  // not the parent schema's\n  if (transform) {\n    applySchemaTypeTransforms(this, ret);\n  }\n\n  if (options.useProjection) {\n    omitDeselectedFields(this, ret);\n  }\n\n  if (transform === true || (schemaOptions.toObject && transform)) {\n    const opts = options.json ? schemaOptions.toJSON : schemaOptions.toObject;\n\n    if (opts) {\n      transform = (typeof options.transform === 'function' ? options.transform : opts.transform);\n    }\n  } else {\n    options.transform = originalTransform;\n  }\n\n  if (typeof transform === 'function') {\n    const xformed = transform(this, ret, options);\n    if (typeof xformed !== 'undefined') {\n      ret = xformed;\n    }\n  }\n\n  return ret;\n};\n\n/**\n * Converts this document into a plain-old JavaScript object ([POJO](https://masteringjs.io/tutorials/fundamentals/pojo)).\n *\n * Buffers are converted to instances of [mongodb.Binary](https://mongodb.github.io/node-mongodb-native/4.9/classes/Binary.html) for proper storage.\n *\n * #### Getters/Virtuals\n *\n * Example of only applying path getters\n *\n *     doc.toObject({ getters: true, virtuals: false })\n *\n * Example of only applying virtual getters\n *\n *     doc.toObject({ virtuals: true })\n *\n * Example of applying both path and virtual getters\n *\n *     doc.toObject({ getters: true })\n *\n * To apply these options to every document of your schema by default, set your [schemas](https://mongoosejs.com/docs/api/schema.html#Schema()) `toObject` option to the same argument.\n *\n *     schema.set('toObject', { virtuals: true })\n *\n * #### Transform:\n *\n * We may need to perform a transformation of the resulting object based on some criteria, say to remove some sensitive information or return a custom object. In this case we set the optional `transform` function.\n *\n * Transform functions receive three arguments\n *\n *     function (doc, ret, options) {}\n *\n * - `doc` The mongoose document which is being converted\n * - `ret` The plain object representation which has been converted\n * - `options` The options in use (either schema options or the options passed inline)\n *\n * #### Example:\n *\n *     // specify the transform schema option\n *     if (!schema.options.toObject) schema.options.toObject = {};\n *     schema.options.toObject.transform = function (doc, ret, options) {\n *       // remove the _id of every document before returning the result\n *       delete ret._id;\n *       return ret;\n *     }\n *\n *     // without the transformation in the schema\n *     doc.toObject(); // { _id: 'anId', name: 'Wreck-it Ralph' }\n *\n *     // with the transformation\n *     doc.toObject(); // { name: 'Wreck-it Ralph' }\n *\n * With transformations we can do a lot more than remove properties. We can even return completely new customized objects:\n *\n *     if (!schema.options.toObject) schema.options.toObject = {};\n *     schema.options.toObject.transform = function (doc, ret, options) {\n *       return { movie: ret.name }\n *     }\n *\n *     // without the transformation in the schema\n *     doc.toObject(); // { _id: 'anId', name: 'Wreck-it Ralph' }\n *\n *     // with the transformation\n *     doc.toObject(); // { movie: 'Wreck-it Ralph' }\n *\n * _Note: if a transform function returns `undefined`, the return value will be ignored._\n *\n * Transformations may also be applied inline, overridding any transform set in the schema options.\n * Any transform function specified in `toObject` options also propagates to any subdocuments.\n *\n *     function deleteId(doc, ret, options) {\n *       delete ret._id;\n *       return ret;\n *     }\n *\n *     const schema = mongoose.Schema({ name: String, docArr: [{ name: String }] });\n *     const TestModel = mongoose.model('Test', schema);\n *\n *     const doc = new TestModel({ name: 'test', docArr: [{ name: 'test' }] });\n *\n *     // pass the transform as an inline option. Deletes `_id` property\n *     // from both the top-level document and the subdocument.\n *     const obj = doc.toObject({ transform: deleteId });\n *     obj._id; // undefined\n *     obj.docArr[0]._id; // undefined\n *\n * If you want to skip transformations, use `transform: false`:\n *\n *     schema.options.toObject.hide = '_id';\n *     schema.options.toObject.transform = function (doc, ret, options) {\n *       if (options.hide) {\n *         options.hide.split(' ').forEach(function (prop) {\n *           delete ret[prop];\n *         });\n *       }\n *       return ret;\n *     }\n *\n *     const doc = new Doc({ _id: 'anId', secret: 47, name: 'Wreck-it Ralph' });\n *     doc.toObject();                                        // { secret: 47, name: 'Wreck-it Ralph' }\n *     doc.toObject({ hide: 'secret _id', transform: false });// { _id: 'anId', secret: 47, name: 'Wreck-it Ralph' }\n *     doc.toObject({ hide: 'secret _id', transform: true }); // { name: 'Wreck-it Ralph' }\n *\n * If you pass a transform in `toObject()` options, Mongoose will apply the transform\n * to [subdocuments](https://mongoosejs.com/docs/subdocs.html) in addition to the top-level document.\n * Similarly, `transform: false` skips transforms for all subdocuments.\n * Note that this behavior is different for transforms defined in the schema:\n * if you define a transform in `schema.options.toObject.transform`, that transform\n * will **not** apply to subdocuments.\n *\n *     const memberSchema = new Schema({ name: String, email: String });\n *     const groupSchema = new Schema({ members: [memberSchema], name: String, email });\n *     const Group = mongoose.model('Group', groupSchema);\n *\n *     const doc = new Group({\n *       name: 'Engineering',\n *       email: 'dev@mongoosejs.io',\n *       members: [{ name: 'Val', email: 'val@mongoosejs.io' }]\n *     });\n *\n *     // Removes `email` from both top-level document **and** array elements\n *     // { name: 'Engineering', members: [{ name: 'Val' }] }\n *     doc.toObject({ transform: (doc, ret) => { delete ret.email; return ret; } });\n *\n * Transforms, like all of these options, are also available for `toJSON`. See [this guide to `JSON.stringify()`](https://thecodebarbarian.com/the-80-20-guide-to-json-stringify-in-javascript.html) to learn why `toJSON()` and `toObject()` are separate functions.\n *\n * See [schema options](https://mongoosejs.com/docs/guide.html#toObject) for some more details.\n *\n * _During save, no custom options are applied to the document before being sent to the database._\n *\n * @param {Object} [options]\n * @param {Boolean} [options.getters=false] if true, apply all getters, including virtuals\n * @param {Boolean|Object} [options.virtuals=false] if true, apply virtuals, including aliases. Use `{ getters: true, virtuals: false }` to just apply getters, not virtuals. An object of the form `{ pathsToSkip: ['someVirtual'] }` may also be used to omit specific virtuals.\n * @param {Boolean} [options.aliases=true] if `options.virtuals = true`, you can set `options.aliases = false` to skip applying aliases. This option is a no-op if `options.virtuals = false`.\n * @param {Boolean} [options.minimize=true] if true, omit any empty objects from the output\n * @param {Function|null} [options.transform=null] if set, mongoose will call this function to allow you to transform the returned object\n * @param {Boolean} [options.depopulate=false] if true, replace any conventionally populated paths with the original id in the output. Has no affect on virtual populated paths.\n * @param {Boolean} [options.versionKey=true] if false, exclude the version key (`__v` by default) from the output\n * @param {Boolean} [options.flattenMaps=false] if true, convert Maps to POJOs. Useful if you want to `JSON.stringify()` the result of `toObject()`.\n * @param {Boolean} [options.flattenObjectIds=false] if true, convert any ObjectIds in the result to 24 character hex strings.\n * @param {Boolean} [options.useProjection=false] - If true, omits fields that are excluded in this document's projection. Unless you specified a projection, this will omit any field that has `select: false` in the schema.\n * @return {Object} js object (not a POJO)\n * @see mongodb.Binary https://mongodb.github.io/node-mongodb-native/4.9/classes/Binary.html\n * @api public\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.toObject = function(options) {\n  return this.$toObject(options);\n};\n\n/*!\n * Applies virtuals properties to `json`.\n */\n\nfunction applyVirtuals(self, json, options, toObjectOptions) {\n  const schema = self.$__schema;\n  const paths = Object.keys(schema.virtuals);\n  let i = paths.length;\n  const numPaths = i;\n  let path;\n  let assignPath;\n  let cur = self._doc;\n  let v;\n  const aliases = typeof (toObjectOptions && toObjectOptions.aliases) === 'boolean'\n    ? toObjectOptions.aliases\n    : true;\n\n  let virtualsToApply = null;\n  if (Array.isArray(options.virtuals)) {\n    virtualsToApply = new Set(options.virtuals);\n  } else if (options.virtuals && options.virtuals.pathsToSkip) {\n    virtualsToApply = new Set(paths);\n    for (let i = 0; i < options.virtuals.pathsToSkip.length; i++) {\n      if (virtualsToApply.has(options.virtuals.pathsToSkip[i])) {\n        virtualsToApply.delete(options.virtuals.pathsToSkip[i]);\n      }\n    }\n  }\n\n  if (!cur) {\n    return json;\n  }\n\n  options = options || {};\n  for (i = 0; i < numPaths; ++i) {\n    path = paths[i];\n\n    if (virtualsToApply != null && !virtualsToApply.has(path)) {\n      continue;\n    }\n\n    // Allow skipping aliases with `toObject({ virtuals: true, aliases: false })`\n    if (!aliases && schema.aliases.hasOwnProperty(path)) {\n      continue;\n    }\n\n    // We may be applying virtuals to a nested object, for example if calling\n    // `doc.nestedProp.toJSON()`. If so, the path we assign to, `assignPath`,\n    // will be a trailing substring of the `path`.\n    assignPath = path;\n    if (options.path != null) {\n      if (!path.startsWith(options.path + '.')) {\n        continue;\n      }\n      assignPath = path.substring(options.path.length + 1);\n    }\n    const parts = assignPath.split('.');\n    v = clone(self.get(path), options);\n    if (v === void 0) {\n      continue;\n    }\n    const plen = parts.length;\n    cur = json;\n    for (let j = 0; j < plen - 1; ++j) {\n      cur[parts[j]] = cur[parts[j]] || {};\n      cur = cur[parts[j]];\n    }\n    cur[parts[plen - 1]] = v;\n  }\n\n  return json;\n}\n\n\n/**\n * Applies virtuals properties to `json`.\n *\n * @param {Document} self\n * @param {Object} json\n * @param {Object} [options]\n * @return {Object} `json`\n * @api private\n */\n\nfunction applyGetters(self, json, options) {\n  const schema = self.$__schema;\n  const paths = Object.keys(schema.paths);\n  let i = paths.length;\n  let path;\n  let cur = self._doc;\n  let v;\n\n  if (!cur) {\n    return json;\n  }\n\n  while (i--) {\n    path = paths[i];\n\n    const parts = path.split('.');\n\n    const plen = parts.length;\n    const last = plen - 1;\n    let branch = json;\n    let part;\n    cur = self._doc;\n\n    if (!self.$__isSelected(path)) {\n      continue;\n    }\n\n    for (let ii = 0; ii < plen; ++ii) {\n      part = parts[ii];\n      v = cur[part];\n      if (ii === last) {\n        const val = self.$get(path);\n        branch[part] = clone(val, options);\n        if (Array.isArray(branch[part]) && schema.paths[path].$embeddedSchemaType) {\n          for (let i = 0; i < branch[part].length; ++i) {\n            branch[part][i] = schema.paths[path].$embeddedSchemaType.applyGetters(\n              branch[part][i],\n              self\n            );\n          }\n        }\n      } else if (v == null) {\n        if (part in cur) {\n          branch[part] = v;\n        }\n        break;\n      } else {\n        branch = branch[part] || (branch[part] = {});\n      }\n      cur = v;\n    }\n  }\n\n  return json;\n}\n\n/**\n * Applies schema type transforms to `json`.\n *\n * @param {Document} self\n * @param {Object} json\n * @return {Object} `json`\n * @api private\n */\n\nfunction applySchemaTypeTransforms(self, json) {\n  const schema = self.$__schema;\n  const paths = Object.keys(schema.paths || {});\n  const cur = self._doc;\n\n  if (!cur) {\n    return json;\n  }\n\n  for (const path of paths) {\n    const schematype = schema.paths[path];\n    if (typeof schematype.options.transform === 'function') {\n      const val = self.$get(path);\n      if (val === undefined) {\n        continue;\n      }\n      const transformedValue = schematype.options.transform.call(self, val);\n      throwErrorIfPromise(path, transformedValue);\n      utils.setValue(path, transformedValue, json);\n    } else if (schematype.$embeddedSchemaType != null &&\n        typeof schematype.$embeddedSchemaType.options.transform === 'function') {\n      const val = self.$get(path);\n      if (val === undefined) {\n        continue;\n      }\n      const vals = [].concat(val);\n      const transform = schematype.$embeddedSchemaType.options.transform;\n      for (let i = 0; i < vals.length; ++i) {\n        const transformedValue = transform.call(self, vals[i]);\n        vals[i] = transformedValue;\n        throwErrorIfPromise(path, transformedValue);\n      }\n\n      json[path] = vals;\n    }\n  }\n\n  return json;\n}\n\nfunction throwErrorIfPromise(path, transformedValue) {\n  if (isPromise(transformedValue)) {\n    throw new Error('`transform` function must be synchronous, but the transform on path `' + path + '` returned a promise.');\n  }\n}\n\n/*!\n * ignore\n */\n\nfunction omitDeselectedFields(self, json) {\n  const schema = self.$__schema;\n  const paths = Object.keys(schema.paths || {});\n  const cur = self._doc;\n\n  if (!cur) {\n    return json;\n  }\n\n  let selected = self.$__.selected;\n  if (selected === void 0) {\n    selected = {};\n    queryhelpers.applyPaths(selected, schema);\n  }\n  if (selected == null || Object.keys(selected).length === 0) {\n    return json;\n  }\n\n  for (const path of paths) {\n    if (selected[path] != null && !selected[path]) {\n      delete json[path];\n    }\n  }\n\n  return json;\n}\n\n/**\n * The return value of this method is used in calls to [`JSON.stringify(doc)`](https://thecodebarbarian.com/the-80-20-guide-to-json-stringify-in-javascript#the-tojson-function).\n *\n * This method accepts the same options as [Document#toObject](https://mongoosejs.com/docs/api/document.html#Document.prototype.toObject()). To apply the options to every document of your schema by default, set your [schemas](https://mongoosejs.com/docs/api/schema.html#Schema()) `toJSON` option to the same argument.\n *\n *     schema.set('toJSON', { virtuals: true });\n *\n * There is one difference between `toJSON()` and `toObject()` options.\n * When you call `toJSON()`, the [`flattenMaps` option](https://mongoosejs.com/docs/api/document.html#Document.prototype.toObject()) defaults to `true`, because `JSON.stringify()` doesn't convert maps to objects by default.\n * When you call `toObject()`, the `flattenMaps` option is `false` by default.\n *\n * See [schema options](https://mongoosejs.com/docs/guide.html#toJSON) for more information on setting `toJSON` option defaults.\n *\n * @param {Object} options\n * @param {Boolean} [options.flattenMaps=true] if true, convert Maps to [POJOs](https://masteringjs.io/tutorials/fundamentals/pojo). Useful if you want to `JSON.stringify()` the result.\n * @param {Boolean} [options.flattenObjectIds=false] if true, convert any ObjectIds in the result to 24 character hex strings.\n * @return {Object}\n * @see Document#toObject https://mongoosejs.com/docs/api/document.html#Document.prototype.toObject()\n * @see JSON.stringify() in JavaScript https://thecodebarbarian.com/the-80-20-guide-to-json-stringify-in-javascript.html\n * @api public\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.toJSON = function(options) {\n  return this.$toObject(options, true);\n};\n\n/*!\n * ignore\n */\n\nDocument.prototype.ownerDocument = function() {\n  return this;\n};\n\n\n/**\n * If this document is a subdocument or populated document, returns the document's\n * parent. Returns the original document if there is no parent.\n *\n * @return {Document}\n * @api public\n * @method parent\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.parent = function() {\n  if (this.$isSubdocument || this.$__.wasPopulated) {\n    return this.$__.parent;\n  }\n  return this;\n};\n\n/**\n * Alias for [`parent()`](https://mongoosejs.com/docs/api/document.html#Document.prototype.parent()). If this document is a subdocument or populated\n * document, returns the document's parent. Returns `undefined` otherwise.\n *\n * @return {Document}\n * @api public\n * @method $parent\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.$parent = Document.prototype.parent;\n\n/**\n * Helper for console.log\n *\n * @return {String}\n * @api public\n * @method inspect\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.inspect = function(options) {\n  const isPOJO = utils.isPOJO(options);\n  let opts;\n  if (isPOJO) {\n    opts = options;\n    opts.minimize = false;\n  }\n\n  const ret = arguments.length > 0 ? this.toObject(opts) : this.toObject();\n\n  if (ret == null) {\n    // If `toObject()` returns null, `this` is still an object, so if `inspect()`\n    // prints out null this can cause some serious confusion. See gh-7942.\n    return 'MongooseDocument { ' + ret + ' }';\n  }\n\n  return ret;\n};\n\nif (inspect.custom) {\n  // Avoid Node deprecation warning DEP0079\n  Document.prototype[inspect.custom] = Document.prototype.inspect;\n}\n\n/**\n * Helper for console.log\n *\n * @return {String}\n * @api public\n * @method toString\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.toString = function() {\n  const ret = this.inspect();\n  if (typeof ret === 'string') {\n    return ret;\n  }\n  return inspect(ret);\n};\n\n/**\n * Returns true if this document is equal to another document.\n *\n * Documents are considered equal when they have matching `_id`s, unless neither\n * document has an `_id`, in which case this function falls back to using\n * `deepEqual()`.\n *\n * @param {Document} [doc] a document to compare. If falsy, will always return \"false\".\n * @return {Boolean}\n * @api public\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.equals = function(doc) {\n  if (!doc) {\n    return false;\n  }\n\n  const tid = this.$__getValue('_id');\n  const docid = doc.$__ != null ? doc.$__getValue('_id') : doc;\n  if (!tid && !docid) {\n    return deepEqual(this, doc);\n  }\n  return tid && tid.equals\n    ? tid.equals(docid)\n    : tid === docid;\n};\n\n/**\n * Populates paths on an existing document.\n *\n * #### Example:\n *\n *     // Given a document, `populate()` lets you pull in referenced docs\n *     await doc.populate([\n *       'stories',\n *       { path: 'fans', sort: { name: -1 } }\n *     ]);\n *     doc.populated('stories'); // Array of ObjectIds\n *     doc.stories[0].title; // 'Casino Royale'\n *     doc.populated('fans'); // Array of ObjectIds\n *\n *     // If the referenced doc has been deleted, `populate()` will\n *     // remove that entry from the array.\n *     await Story.delete({ title: 'Casino Royale' });\n *     await doc.populate('stories'); // Empty array\n *\n *     // You can also pass additional query options to `populate()`,\n *     // like projections:\n *     await doc.populate('fans', '-email');\n *     doc.fans[0].email // undefined because of 2nd param `select`\n *\n * @param {String|Object|Array} path either the path to populate or an object specifying all parameters, or either an array of those\n * @param {Object|String} [select] Field selection for the population query\n * @param {Model} [model] The model you wish to use for population. If not specified, populate will look up the model by the name in the Schema's `ref` field.\n * @param {Object} [match] Conditions for the population query\n * @param {Object} [options] Options for the population query (sort, etc)\n * @param {String} [options.path=null] The path to populate.\n * @param {string|PopulateOptions} [options.populate=null] Recursively populate paths in the populated documents. See [deep populate docs](https://mongoosejs.com/docs/populate.html#deep-populate).\n * @param {boolean} [options.retainNullValues=false] by default, Mongoose removes null and undefined values from populated arrays. Use this option to make `populate()` retain `null` and `undefined` array entries.\n * @param {boolean} [options.getters=false] if true, Mongoose will call any getters defined on the `localField`. By default, Mongoose gets the raw value of `localField`. For example, you would need to set this option to `true` if you wanted to [add a `lowercase` getter to your `localField`](https://mongoosejs.com/docs/schematypes.html#schematype-options).\n * @param {boolean} [options.clone=false] When you do `BlogPost.find().populate('author')`, blog posts with the same author will share 1 copy of an `author` doc. Enable this option to make Mongoose clone populated docs before assigning them.\n * @param {Object|Function} [options.match=null] Add an additional filter to the populate query. Can be a filter object containing [MongoDB query syntax](https://www.mongodb.com/docs/manual/tutorial/query-documents/), or a function that returns a filter object.\n * @param {Function} [options.transform=null] Function that Mongoose will call on every populated document that allows you to transform the populated document.\n * @param {Object} [options.options=null] Additional options like `limit` and `lean`.\n * @param {Function} [callback] Callback\n * @see population https://mongoosejs.com/docs/populate.html\n * @see Query#select https://mongoosejs.com/docs/api/query.html#Query.prototype.select()\n * @see Model.populate https://mongoosejs.com/docs/api/model.html#Model.populate()\n * @memberOf Document\n * @instance\n * @return {Promise|null} Returns a Promise if no `callback` is given.\n * @api public\n */\n\nDocument.prototype.populate = async function populate() {\n  const pop = {};\n  const args = [...arguments];\n  if (typeof args[args.length - 1] === 'function') {\n    throw new MongooseError('Document.prototype.populate() no longer accepts a callback');\n  }\n\n  if (args.length !== 0) {\n    // use hash to remove duplicate paths\n    const res = utils.populate.apply(null, args);\n    for (const populateOptions of res) {\n      pop[populateOptions.path] = populateOptions;\n    }\n  }\n\n  const paths = utils.object.vals(pop);\n  let topLevelModel = this.constructor;\n  if (this.$__isNested) {\n    topLevelModel = this.$__[scopeSymbol].constructor;\n    const nestedPath = this.$__.nestedPath;\n    paths.forEach(function(populateOptions) {\n      populateOptions.path = nestedPath + '.' + populateOptions.path;\n    });\n  }\n\n  // Use `$session()` by default if the document has an associated session\n  // See gh-6754\n  if (this.$session() != null) {\n    const session = this.$session();\n    paths.forEach(path => {\n      if (path.options == null) {\n        path.options = { session: session };\n        return;\n      }\n      if (!('session' in path.options)) {\n        path.options.session = session;\n      }\n    });\n  }\n\n  paths.forEach(p => {\n    p._localModel = topLevelModel;\n  });\n\n  return topLevelModel.populate(this, paths);\n};\n\n/**\n * Gets all populated documents associated with this document.\n *\n * @api public\n * @return {Document[]} array of populated documents. Empty array if there are no populated documents associated with this document.\n * @memberOf Document\n * @method $getPopulatedDocs\n * @instance\n */\n\nDocument.prototype.$getPopulatedDocs = function $getPopulatedDocs() {\n  let keys = [];\n  if (this.$__.populated != null) {\n    keys = keys.concat(Object.keys(this.$__.populated));\n  }\n  let result = [];\n  for (const key of keys) {\n    const value = this.$get(key);\n    if (Array.isArray(value)) {\n      result = result.concat(value);\n    } else if (value instanceof Document) {\n      result.push(value);\n    }\n  }\n  return result;\n};\n\n/**\n * Gets _id(s) used during population of the given `path`.\n *\n * #### Example:\n *\n *     const doc = await Model.findOne().populate('author');\n *\n *     console.log(doc.author.name); // Dr.Seuss\n *     console.log(doc.populated('author')); // '5144cf8050f071d979c118a7'\n *\n * If the path was not populated, returns `undefined`.\n *\n * @param {String} path\n * @param {Any} [val]\n * @param {Object} [options]\n * @return {Array|ObjectId|Number|Buffer|String|undefined}\n * @memberOf Document\n * @instance\n * @api public\n */\n\nDocument.prototype.populated = function(path, val, options) {\n  // val and options are internal\n  if (val == null || val === true) {\n    if (!this.$__.populated) {\n      return undefined;\n    }\n    if (typeof path !== 'string') {\n      return undefined;\n    }\n\n    // Map paths can be populated with either `path.$*` or just `path`\n    const _path = path.endsWith('.$*') ? path.replace(/\\.\\$\\*$/, '') : path;\n\n    const v = this.$__.populated[_path];\n    if (v) {\n      return val === true ? v : v.value;\n    }\n    return undefined;\n  }\n\n  this.$__.populated || (this.$__.populated = {});\n  this.$__.populated[path] = { value: val, options: options };\n\n  // If this was a nested populate, make sure each populated doc knows\n  // about its populated children (gh-7685)\n  const pieces = path.split('.');\n  for (let i = 0; i < pieces.length - 1; ++i) {\n    const subpath = pieces.slice(0, i + 1).join('.');\n    const subdoc = this.$get(subpath);\n    if (subdoc != null && subdoc.$__ != null && this.$populated(subpath)) {\n      const rest = pieces.slice(i + 1).join('.');\n      subdoc.$populated(rest, val, options);\n      // No need to continue because the above recursion should take care of\n      // marking the rest of the docs as populated\n      break;\n    }\n  }\n\n  return val;\n};\n\n/**\n * Alias of [`.populated`](https://mongoosejs.com/docs/api/document.html#Document.prototype.populated()).\n *\n * @method $populated\n * @memberOf Document\n * @api public\n */\n\nDocument.prototype.$populated = Document.prototype.populated;\n\n/**\n * Throws an error if a given path is not populated\n *\n * #### Example:\n *\n *     const doc = await Model.findOne().populate('author');\n *\n *     doc.$assertPopulated('author'); // does not throw\n *     doc.$assertPopulated('other path'); // throws an error\n *\n *     // Manually populate and assert in one call. The following does\n *     // `doc.$set({ likes })` before asserting.\n *     doc.$assertPopulated('likes', { likes });\n *\n *\n * @param {String|String[]} path path or array of paths to check. `$assertPopulated` throws if any of the given paths is not populated.\n * @param {Object} [values] optional values to `$set()`. Convenient if you want to manually populate a path and assert that the path was populated in 1 call.\n * @return {Document} this\n * @memberOf Document\n * @method $assertPopulated\n * @instance\n * @api public\n */\n\nDocument.prototype.$assertPopulated = function $assertPopulated(path, values) {\n  if (Array.isArray(path)) {\n    path.forEach(p => this.$assertPopulated(p, values));\n    return this;\n  }\n\n  if (arguments.length > 1) {\n    this.$set(values);\n  }\n\n  if (!this.$populated(path)) {\n    throw new MongooseError(`Expected path \"${path}\" to be populated`);\n  }\n\n  return this;\n};\n\n/**\n * Takes a populated field and returns it to its unpopulated state.\n *\n * #### Example:\n *\n *     Model.findOne().populate('author').exec(function (err, doc) {\n *       console.log(doc.author.name); // Dr.Seuss\n *       console.log(doc.depopulate('author'));\n *       console.log(doc.author); // '5144cf8050f071d979c118a7'\n *     })\n *\n * If the path was not provided, then all populated fields are returned to their unpopulated state.\n *\n * @param {String|String[]} [path] Specific Path to depopulate. If unset, will depopulate all paths on the Document. Or multiple space-delimited paths.\n * @return {Document} this\n * @see Document.populate https://mongoosejs.com/docs/api/document.html#Document.prototype.populate()\n * @api public\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.depopulate = function(path) {\n  if (typeof path === 'string') {\n    path = path.indexOf(' ') === -1 ? [path] : path.split(' ');\n  }\n\n  let populatedIds;\n  const virtualKeys = this.$$populatedVirtuals ? Object.keys(this.$$populatedVirtuals) : [];\n  const populated = this.$__ && this.$__.populated || {};\n\n  if (arguments.length === 0) {\n    // Depopulate all\n    for (const virtualKey of virtualKeys) {\n      delete this.$$populatedVirtuals[virtualKey];\n      delete this._doc[virtualKey];\n      delete populated[virtualKey];\n    }\n\n    const keys = Object.keys(populated);\n\n    for (const key of keys) {\n      populatedIds = this.$populated(key);\n      if (!populatedIds) {\n        continue;\n      }\n      delete populated[key];\n      utils.setValue(key, populatedIds, this._doc);\n    }\n    return this;\n  }\n\n  for (const singlePath of path) {\n    populatedIds = this.$populated(singlePath);\n    delete populated[singlePath];\n\n    if (virtualKeys.indexOf(singlePath) !== -1) {\n      delete this.$$populatedVirtuals[singlePath];\n      delete this._doc[singlePath];\n    } else if (populatedIds) {\n      utils.setValue(singlePath, populatedIds, this._doc);\n    }\n  }\n  return this;\n};\n\n\n/**\n * Returns the full path to this document.\n *\n * @param {String} [path]\n * @return {String}\n * @api private\n * @method $__fullPath\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.$__fullPath = function(path) {\n  // overridden in SubDocuments\n  return path || '';\n};\n\n/**\n * Returns the changes that happened to the document\n * in the format that will be sent to MongoDB.\n *\n * #### Example:\n *\n *     const userSchema = new Schema({\n *       name: String,\n *       age: Number,\n *       country: String\n *     });\n *     const User = mongoose.model('User', userSchema);\n *     const user = await User.create({\n *       name: 'Hafez',\n *       age: 25,\n *       country: 'Egypt'\n *     });\n *\n *     // returns an empty object, no changes happened yet\n *     user.getChanges(); // { }\n *\n *     user.country = undefined;\n *     user.age = 26;\n *\n *     user.getChanges(); // { $set: { age: 26 }, { $unset: { country: 1 } } }\n *\n *     await user.save();\n *\n *     user.getChanges(); // { }\n *\n * Modifying the object that `getChanges()` returns does not affect the document's\n * change tracking state. Even if you `delete user.getChanges().$set`, Mongoose\n * will still send a `$set` to the server.\n *\n * @return {Object}\n * @api public\n * @method getChanges\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.getChanges = function() {\n  const delta = this.$__delta();\n  const changes = delta ? delta[1] : {};\n  return changes;\n};\n\n/**\n * Returns a copy of this document with a deep clone of `_doc` and `$__`.\n *\n * @return {Document} a copy of this document\n * @api public\n * @method $clone\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.$clone = function() {\n  const Model = this.constructor;\n  const clonedDoc = new Model();\n  clonedDoc.$isNew = this.$isNew;\n  if (this._doc) {\n    clonedDoc._doc = clone(this._doc);\n  }\n  if (this.$__) {\n    const Cache = this.$__.constructor;\n    const clonedCache = new Cache();\n    for (const key of Object.getOwnPropertyNames(this.$__)) {\n      if (key === 'activePaths') {\n        continue;\n      }\n      clonedCache[key] = clone(this.$__[key]);\n    }\n    Object.assign(clonedCache.activePaths, clone({ ...this.$__.activePaths }));\n    clonedDoc.$__ = clonedCache;\n  }\n  return clonedDoc;\n};\n\n/*!\n * Module exports.\n */\n\nDocument.ValidationError = ValidationError;\nmodule.exports = exports = Document;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvZG9jdW1lbnQuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7QUFDQTtBQUNBOztBQUVBLHFCQUFxQiwwREFBOEI7QUFDbkQsc0JBQXNCLG1CQUFPLENBQUMsbUVBQVk7QUFDMUMsc0JBQXNCLG1CQUFPLENBQUMseUVBQWU7QUFDN0Msb0JBQW9CLG1CQUFPLENBQUMsMkVBQWdCO0FBQzVDLDRCQUE0QixtQkFBTyxDQUFDLDJGQUF3QjtBQUM1RCw2QkFBNkIsbUJBQU8sQ0FBQyw2RkFBeUI7QUFDOUQsOEJBQThCLG1CQUFPLENBQUMsK0ZBQTBCO0FBQ2hFLGVBQWUsbUJBQU8sQ0FBQywrREFBVTtBQUNqQyx3QkFBd0IsbUJBQU8sQ0FBQywyRUFBZ0I7QUFDaEQsd0JBQXdCLG1CQUFPLENBQUMsbUZBQW9CO0FBQ3BELHVCQUF1QixtQkFBTyxDQUFDLGlGQUFtQjtBQUNsRCwrQkFBK0IsbUJBQU8sQ0FBQywrSEFBMEM7QUFDakYsc0JBQXNCLG1CQUFPLENBQUMsK0dBQWtDO0FBQ2hFLDhCQUE4QixtQkFBTyxDQUFDLCtIQUEwQztBQUNoRixjQUFjLG1CQUFPLENBQUMsNkVBQWlCO0FBQ3ZDLGdCQUFnQixrSUFBNkM7QUFDN0Qsa0JBQWtCLG9JQUErQztBQUNqRSxnQkFBZ0IsOEdBQW1DO0FBQ25ELFlBQVksbUJBQU8sQ0FBQyx5RUFBZTtBQUNuQyxxQ0FBcUMsbUJBQU8sQ0FBQyw2SUFBaUQ7QUFDOUYsNkJBQTZCLG1CQUFPLENBQUMseUhBQXVDO0FBQzVFLGtDQUFrQyxtQkFBTyxDQUFDLG1JQUE0QztBQUN0Rix3QkFBd0IsbUJBQU8sQ0FBQyxtSEFBb0M7QUFDcEUsa0JBQWtCLG1CQUFPLENBQUMscUZBQXFCO0FBQy9DLDZCQUE2QixtQkFBTyxDQUFDLGlJQUEyQztBQUNoRixvQkFBb0IsbUJBQU8sQ0FBQywrR0FBa0M7QUFDOUQsZ0JBQWdCLGlEQUF1QjtBQUN2QyxnQ0FBZ0MsZ0hBQTRDO0FBQzVF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QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxpQkFBaUI7QUFDNUIsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsaUJBQWlCO0FBQzVCLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qiw0REFBNEQ7QUFDeEY7QUFDQSxXQUFXLGNBQWM7QUFDekIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsU0FBUztBQUNwQixXQUFXLGNBQWM7QUFDekIsWUFBWSxTQUFTO0FBQ3JCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSiw0REFBNEQsNkNBQTZDO0FBQ3pHOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFNBQVM7QUFDdkI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCOztBQUUzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdEQUFnRDtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsaUJBQWlCO0FBQ3ZDO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsa0JBQWtCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7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O0FBQzVCLFlBQVksVUFBVTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsS0FBSyxRQUFRLFNBQVMsSUFBSSxVQUFVO0FBQzlEO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFVBQVU7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCx5QkFBeUI7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbGllbnQvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvZG9jdW1lbnQuanM/YmZiYSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbi8qIVxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG5jb25zdCBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXI7XG5jb25zdCBJbnRlcm5hbENhY2hlID0gcmVxdWlyZSgnLi9pbnRlcm5hbCcpO1xuY29uc3QgTW9uZ29vc2VFcnJvciA9IHJlcXVpcmUoJy4vZXJyb3IvaW5kZXgnKTtcbmNvbnN0IE1peGVkU2NoZW1hID0gcmVxdWlyZSgnLi9zY2hlbWEvbWl4ZWQnKTtcbmNvbnN0IE9iamVjdEV4cGVjdGVkRXJyb3IgPSByZXF1aXJlKCcuL2Vycm9yL29iamVjdEV4cGVjdGVkJyk7XG5jb25zdCBPYmplY3RQYXJhbWV0ZXJFcnJvciA9IHJlcXVpcmUoJy4vZXJyb3Ivb2JqZWN0UGFyYW1ldGVyJyk7XG5jb25zdCBQYXJhbGxlbFZhbGlkYXRlRXJyb3IgPSByZXF1aXJlKCcuL2Vycm9yL3BhcmFsbGVsVmFsaWRhdGUnKTtcbmNvbnN0IFNjaGVtYSA9IHJlcXVpcmUoJy4vc2NoZW1hJyk7XG5jb25zdCBTdHJpY3RNb2RlRXJyb3IgPSByZXF1aXJlKCcuL2Vycm9yL3N0cmljdCcpO1xuY29uc3QgVmFsaWRhdGlvbkVycm9yID0gcmVxdWlyZSgnLi9lcnJvci92YWxpZGF0aW9uJyk7XG5jb25zdCBWYWxpZGF0b3JFcnJvciA9IHJlcXVpcmUoJy4vZXJyb3IvdmFsaWRhdG9yJyk7XG5jb25zdCAkX19oYXNJbmNsdWRlZENoaWxkcmVuID0gcmVxdWlyZSgnLi9oZWxwZXJzL3Byb2plY3Rpb24vaGFzSW5jbHVkZWRDaGlsZHJlbicpO1xuY29uc3QgYXBwbHlEZWZhdWx0cyA9IHJlcXVpcmUoJy4vaGVscGVycy9kb2N1bWVudC9hcHBseURlZmF1bHRzJyk7XG5jb25zdCBjbGVhbk1vZGlmaWVkU3VicGF0aHMgPSByZXF1aXJlKCcuL2hlbHBlcnMvZG9jdW1lbnQvY2xlYW5Nb2RpZmllZFN1YnBhdGhzJyk7XG5jb25zdCBjbG9uZSA9IHJlcXVpcmUoJy4vaGVscGVycy9jbG9uZScpO1xuY29uc3QgY29tcGlsZSA9IHJlcXVpcmUoJy4vaGVscGVycy9kb2N1bWVudC9jb21waWxlJykuY29tcGlsZTtcbmNvbnN0IGRlZmluZUtleSA9IHJlcXVpcmUoJy4vaGVscGVycy9kb2N1bWVudC9jb21waWxlJykuZGVmaW5lS2V5O1xuY29uc3QgZmxhdHRlbiA9IHJlcXVpcmUoJy4vaGVscGVycy9jb21tb24nKS5mbGF0dGVuO1xuY29uc3QgZ2V0ID0gcmVxdWlyZSgnLi9oZWxwZXJzL2dldCcpO1xuY29uc3QgZ2V0RW1iZWRkZWREaXNjcmltaW5hdG9yUGF0aCA9IHJlcXVpcmUoJy4vaGVscGVycy9kb2N1bWVudC9nZXRFbWJlZGRlZERpc2NyaW1pbmF0b3JQYXRoJyk7XG5jb25zdCBnZXRLZXlzSW5TY2hlbWFPcmRlciA9IHJlcXVpcmUoJy4vaGVscGVycy9zY2hlbWEvZ2V0S2V5c0luU2NoZW1hT3JkZXInKTtcbmNvbnN0IGdldFN1YmRvY3VtZW50U3RyaWN0VmFsdWUgPSByZXF1aXJlKCcuL2hlbHBlcnMvc2NoZW1hL2dldFN1YmRvY3VtZW50U3RyaWN0VmFsdWUnKTtcbmNvbnN0IGhhbmRsZVNwcmVhZERvYyA9IHJlcXVpcmUoJy4vaGVscGVycy9kb2N1bWVudC9oYW5kbGVTcHJlYWREb2MnKTtcbmNvbnN0IGltbWVkaWF0ZSA9IHJlcXVpcmUoJy4vaGVscGVycy9pbW1lZGlhdGUnKTtcbmNvbnN0IGlzRGVmaW5pbmdQcm9qZWN0aW9uID0gcmVxdWlyZSgnLi9oZWxwZXJzL3Byb2plY3Rpb24vaXNEZWZpbmluZ1Byb2plY3Rpb24nKTtcbmNvbnN0IGlzRXhjbHVzaXZlID0gcmVxdWlyZSgnLi9oZWxwZXJzL3Byb2plY3Rpb24vaXNFeGNsdXNpdmUnKTtcbmNvbnN0IGluc3BlY3QgPSByZXF1aXJlKCd1dGlsJykuaW5zcGVjdDtcbmNvbnN0IGludGVybmFsVG9PYmplY3RPcHRpb25zID0gcmVxdWlyZSgnLi9vcHRpb25zJykuaW50ZXJuYWxUb09iamVjdE9wdGlvbnM7XG5jb25zdCBtYXJrQXJyYXlTdWJkb2NzUG9wdWxhdGVkID0gcmVxdWlyZSgnLi9oZWxwZXJzL3BvcHVsYXRlL21hcmtBcnJheVN1YmRvY3NQb3B1bGF0ZWQnKTtcbmNvbnN0IG1pbmltaXplID0gcmVxdWlyZSgnLi9oZWxwZXJzL21pbmltaXplJyk7XG5jb25zdCBtcGF0aCA9IHJlcXVpcmUoJ21wYXRoJyk7XG5jb25zdCBxdWVyeWhlbHBlcnMgPSByZXF1aXJlKCcuL3F1ZXJ5SGVscGVycycpO1xuY29uc3QgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG5jb25zdCBpc1Byb21pc2UgPSByZXF1aXJlKCcuL2hlbHBlcnMvaXNQcm9taXNlJyk7XG5cbmNvbnN0IGRlZXBFcXVhbCA9IHV0aWxzLmRlZXBFcXVhbDtcbmNvbnN0IGlzTW9uZ29vc2VPYmplY3QgPSB1dGlscy5pc01vbmdvb3NlT2JqZWN0O1xuXG5jb25zdCBhcnJheUF0b21pY3NCYWNrdXBTeW1ib2wgPSByZXF1aXJlKCcuL2hlbHBlcnMvc3ltYm9scycpLmFycmF5QXRvbWljc0JhY2t1cFN5bWJvbDtcbmNvbnN0IGFycmF5QXRvbWljc1N5bWJvbCA9IHJlcXVpcmUoJy4vaGVscGVycy9zeW1ib2xzJykuYXJyYXlBdG9taWNzU3ltYm9sO1xuY29uc3QgZG9jdW1lbnRBcnJheVBhcmVudCA9IHJlcXVpcmUoJy4vaGVscGVycy9zeW1ib2xzJykuZG9jdW1lbnRBcnJheVBhcmVudDtcbmNvbnN0IGRvY3VtZW50SXNNb2RpZmllZCA9IHJlcXVpcmUoJy4vaGVscGVycy9zeW1ib2xzJykuZG9jdW1lbnRJc01vZGlmaWVkO1xuY29uc3QgZG9jdW1lbnRNb2RpZmllZFBhdGhzID0gcmVxdWlyZSgnLi9oZWxwZXJzL3N5bWJvbHMnKS5kb2N1bWVudE1vZGlmaWVkUGF0aHM7XG5jb25zdCBkb2N1bWVudFNjaGVtYVN5bWJvbCA9IHJlcXVpcmUoJy4vaGVscGVycy9zeW1ib2xzJykuZG9jdW1lbnRTY2hlbWFTeW1ib2w7XG5jb25zdCBnZXRTeW1ib2wgPSByZXF1aXJlKCcuL2hlbHBlcnMvc3ltYm9scycpLmdldFN5bWJvbDtcbmNvbnN0IHBvcHVsYXRlTW9kZWxTeW1ib2wgPSByZXF1aXJlKCcuL2hlbHBlcnMvc3ltYm9scycpLnBvcHVsYXRlTW9kZWxTeW1ib2w7XG5jb25zdCBzY29wZVN5bWJvbCA9IHJlcXVpcmUoJy4vaGVscGVycy9zeW1ib2xzJykuc2NvcGVTeW1ib2w7XG5jb25zdCBzY2hlbWFNaXhlZFN5bWJvbCA9IHJlcXVpcmUoJy4vc2NoZW1hL3N5bWJvbHMnKS5zY2hlbWFNaXhlZFN5bWJvbDtcbmNvbnN0IHBhcmVudFBhdGhzID0gcmVxdWlyZSgnLi9oZWxwZXJzL3BhdGgvcGFyZW50UGF0aHMnKTtcbmNvbnN0IGdldERlZXBlc3RTdWJkb2N1bWVudEZvclBhdGggPSByZXF1aXJlKCcuL2hlbHBlcnMvZG9jdW1lbnQvZ2V0RGVlcGVzdFN1YmRvY3VtZW50Rm9yUGF0aCcpO1xuY29uc3Qgc2Vzc2lvbk5ld0RvY3VtZW50cyA9IHJlcXVpcmUoJy4vaGVscGVycy9zeW1ib2xzJykuc2Vzc2lvbk5ld0RvY3VtZW50cztcblxubGV0IERvY3VtZW50QXJyYXk7XG5sZXQgTW9uZ29vc2VBcnJheTtcbmxldCBFbWJlZGRlZDtcblxuY29uc3Qgc3BlY2lhbFByb3BlcnRpZXMgPSB1dGlscy5zcGVjaWFsUHJvcGVydGllcztcblxuLyoqXG4gKiBUaGUgY29yZSBNb25nb29zZSBkb2N1bWVudCBjb25zdHJ1Y3Rvci4gWW91IHNob3VsZCBub3QgY2FsbCB0aGlzIGRpcmVjdGx5LFxuICogdGhlIE1vbmdvb3NlIFtNb2RlbCBjb25zdHJ1Y3Rvcl0oLi9hcGkvbW9kZWwuaHRtbCNNb2RlbCkgY2FsbHMgdGhpcyBmb3IgeW91LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmogdGhlIHZhbHVlcyB0byBzZXRcbiAqIEBwYXJhbSB7T2JqZWN0fSBbZmllbGRzXSBvcHRpb25hbCBvYmplY3QgY29udGFpbmluZyB0aGUgZmllbGRzIHdoaWNoIHdlcmUgc2VsZWN0ZWQgaW4gdGhlIHF1ZXJ5IHJldHVybmluZyB0aGlzIGRvY3VtZW50IGFuZCBhbnkgcG9wdWxhdGVkIHBhdGhzIGRhdGFcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gdmFyaW91cyBjb25maWd1cmF0aW9uIG9wdGlvbnMgZm9yIHRoZSBkb2N1bWVudFxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5kZWZhdWx0cz10cnVlXSBpZiBgZmFsc2VgLCBza2lwIGFwcGx5aW5nIGRlZmF1bHQgdmFsdWVzIHRvIHRoaXMgZG9jdW1lbnQuXG4gKiBAaW5oZXJpdHMgTm9kZUpTIEV2ZW50RW1pdHRlciBodHRwczovL25vZGVqcy5vcmcvYXBpL2V2ZW50cy5odG1sI2NsYXNzLWV2ZW50ZW1pdHRlclxuICogQGV2ZW50IGBpbml0YDogRW1pdHRlZCBvbiBhIGRvY3VtZW50IGFmdGVyIGl0IGhhcyBiZWVuIHJldHJpZXZlZCBmcm9tIHRoZSBkYiBhbmQgZnVsbHkgaHlkcmF0ZWQgYnkgTW9uZ29vc2UuXG4gKiBAZXZlbnQgYHNhdmVgOiBFbWl0dGVkIHdoZW4gdGhlIGRvY3VtZW50IGlzIHN1Y2Nlc3NmdWxseSBzYXZlZFxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gRG9jdW1lbnQob2JqLCBmaWVsZHMsIHNraXBJZCwgb3B0aW9ucykge1xuICBpZiAodHlwZW9mIHNraXBJZCA9PT0gJ29iamVjdCcgJiYgc2tpcElkICE9IG51bGwpIHtcbiAgICBvcHRpb25zID0gc2tpcElkO1xuICAgIHNraXBJZCA9IG9wdGlvbnMuc2tpcElkO1xuICB9XG4gIG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zKTtcblxuICAvLyBTdXBwb3J0IGBicm93c2VyRG9jdW1lbnQuanNgIHN5bnRheFxuICBpZiAodGhpcy4kX19zY2hlbWEgPT0gbnVsbCkge1xuICAgIGNvbnN0IF9zY2hlbWEgPSB1dGlscy5pc09iamVjdChmaWVsZHMpICYmICFmaWVsZHMuaW5zdGFuY2VPZlNjaGVtYSA/XG4gICAgICBuZXcgU2NoZW1hKGZpZWxkcykgOlxuICAgICAgZmllbGRzO1xuICAgIHRoaXMuJF9fc2V0U2NoZW1hKF9zY2hlbWEpO1xuICAgIGZpZWxkcyA9IHNraXBJZDtcbiAgICBza2lwSWQgPSBvcHRpb25zO1xuICAgIG9wdGlvbnMgPSBhcmd1bWVudHNbNF0gfHwge307XG4gIH1cblxuICB0aGlzLiRfXyA9IG5ldyBJbnRlcm5hbENhY2hlKCk7XG5cbiAgLy8gQXZvaWQgc2V0dGluZyBgaXNOZXdgIHRvIGB0cnVlYCwgYmVjYXVzZSBpdCBpcyBgdHJ1ZWAgYnkgZGVmYXVsdFxuICBpZiAob3B0aW9ucy5pc05ldyAhPSBudWxsICYmIG9wdGlvbnMuaXNOZXcgIT09IHRydWUpIHtcbiAgICB0aGlzLiRpc05ldyA9IG9wdGlvbnMuaXNOZXc7XG4gIH1cblxuICBpZiAob3B0aW9ucy5wcmlvckRvYyAhPSBudWxsKSB7XG4gICAgdGhpcy4kX18ucHJpb3JEb2MgPSBvcHRpb25zLnByaW9yRG9jO1xuICB9XG5cbiAgaWYgKHNraXBJZCkge1xuICAgIHRoaXMuJF9fLnNraXBJZCA9IHNraXBJZDtcbiAgfVxuXG4gIGlmIChvYmogIT0gbnVsbCAmJiB0eXBlb2Ygb2JqICE9PSAnb2JqZWN0Jykge1xuICAgIHRocm93IG5ldyBPYmplY3RQYXJhbWV0ZXJFcnJvcihvYmosICdvYmonLCAnRG9jdW1lbnQnKTtcbiAgfVxuXG4gIGxldCBkZWZhdWx0cyA9IHRydWU7XG4gIGlmIChvcHRpb25zLmRlZmF1bHRzICE9PSB1bmRlZmluZWQpIHtcbiAgICB0aGlzLiRfXy5kZWZhdWx0cyA9IG9wdGlvbnMuZGVmYXVsdHM7XG4gICAgZGVmYXVsdHMgPSBvcHRpb25zLmRlZmF1bHRzO1xuICB9XG5cbiAgY29uc3Qgc2NoZW1hID0gdGhpcy4kX19zY2hlbWE7XG5cbiAgaWYgKHR5cGVvZiBmaWVsZHMgPT09ICdib29sZWFuJyB8fCBmaWVsZHMgPT09ICd0aHJvdycpIHtcbiAgICBpZiAoZmllbGRzICE9PSB0cnVlKSB7XG4gICAgICB0aGlzLiRfXy5zdHJpY3RNb2RlID0gZmllbGRzO1xuICAgIH1cbiAgICBmaWVsZHMgPSB1bmRlZmluZWQ7XG4gIH0gZWxzZSBpZiAoc2NoZW1hLm9wdGlvbnMuc3RyaWN0ICE9PSB0cnVlKSB7XG4gICAgdGhpcy4kX18uc3RyaWN0TW9kZSA9IHNjaGVtYS5vcHRpb25zLnN0cmljdDtcbiAgfVxuXG4gIGNvbnN0IHJlcXVpcmVkUGF0aHMgPSBzY2hlbWEucmVxdWlyZWRQYXRocyh0cnVlKTtcbiAgZm9yIChjb25zdCBwYXRoIG9mIHJlcXVpcmVkUGF0aHMpIHtcbiAgICB0aGlzLiRfXy5hY3RpdmVQYXRocy5yZXF1aXJlKHBhdGgpO1xuICB9XG5cbiAgbGV0IGV4Y2x1ZGUgPSBudWxsO1xuXG4gIC8vIGRldGVybWluZSBpZiB0aGlzIGRvYyBpcyBhIHJlc3VsdCBvZiBhIHF1ZXJ5IHdpdGhcbiAgLy8gZXhjbHVkZWQgZmllbGRzXG4gIGlmICh1dGlscy5pc1BPSk8oZmllbGRzKSAmJiBPYmplY3Qua2V5cyhmaWVsZHMpLmxlbmd0aCA+IDApIHtcbiAgICBleGNsdWRlID0gaXNFeGNsdXNpdmUoZmllbGRzKTtcbiAgICB0aGlzLiRfXy5zZWxlY3RlZCA9IGZpZWxkcztcbiAgICB0aGlzLiRfXy5leGNsdWRlID0gZXhjbHVkZTtcbiAgfVxuXG4gIGNvbnN0IGhhc0luY2x1ZGVkQ2hpbGRyZW4gPSBleGNsdWRlID09PSBmYWxzZSAmJiBmaWVsZHMgP1xuICAgICRfX2hhc0luY2x1ZGVkQ2hpbGRyZW4oZmllbGRzKSA6XG4gICAgbnVsbDtcblxuICBpZiAodGhpcy5fZG9jID09IG51bGwpIHtcbiAgICB0aGlzLiRfX2J1aWxkRG9jKG9iaiwgZmllbGRzLCBza2lwSWQsIGV4Y2x1ZGUsIGhhc0luY2x1ZGVkQ2hpbGRyZW4sIGZhbHNlKTtcblxuICAgIC8vIEJ5IGRlZmF1bHQsIGRlZmF1bHRzIGdldCBhcHBsaWVkICoqYmVmb3JlKiogc2V0dGluZyBpbml0aWFsIHZhbHVlc1xuICAgIC8vIFJlOiBnaC02MTU1XG4gICAgaWYgKGRlZmF1bHRzKSB7XG4gICAgICBhcHBseURlZmF1bHRzKHRoaXMsIGZpZWxkcywgZXhjbHVkZSwgaGFzSW5jbHVkZWRDaGlsZHJlbiwgdHJ1ZSwgbnVsbCk7XG4gICAgfVxuICB9XG4gIGlmIChvYmopIHtcbiAgICAvLyBTa2lwIHNldCBob29rc1xuICAgIGlmICh0aGlzLiRfX29yaWdpbmFsX3NldCkge1xuICAgICAgdGhpcy4kX19vcmlnaW5hbF9zZXQob2JqLCB1bmRlZmluZWQsIHRydWUsIG9wdGlvbnMpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLiRzZXQob2JqLCB1bmRlZmluZWQsIHRydWUsIG9wdGlvbnMpO1xuICAgIH1cblxuICAgIGlmIChvYmogaW5zdGFuY2VvZiBEb2N1bWVudCkge1xuICAgICAgdGhpcy4kaXNOZXcgPSBvYmouJGlzTmV3O1xuICAgIH1cbiAgfVxuXG4gIC8vIEZ1bmN0aW9uIGRlZmF1bHRzIGdldCBhcHBsaWVkICoqYWZ0ZXIqKiBzZXR0aW5nIGluaXRpYWwgdmFsdWVzIHNvIHRoZXlcbiAgLy8gc2VlIHRoZSBmdWxsIGRvYyByYXRoZXIgdGhhbiBhbiBlbXB0eSBvbmUsIHVubGVzcyB0aGV5IG9wdCBvdXQuXG4gIC8vIFJlOiBnaC0zNzgxLCBnaC02MTU1XG4gIGlmIChvcHRpb25zLndpbGxJbml0ICYmIGRlZmF1bHRzKSB7XG4gICAgaWYgKG9wdGlvbnMuc2tpcERlZmF1bHRzKSB7XG4gICAgICB0aGlzLiRfXy5za2lwRGVmYXVsdHMgPSBvcHRpb25zLnNraXBEZWZhdWx0cztcbiAgICB9XG4gIH0gZWxzZSBpZiAoZGVmYXVsdHMpIHtcbiAgICBhcHBseURlZmF1bHRzKHRoaXMsIGZpZWxkcywgZXhjbHVkZSwgaGFzSW5jbHVkZWRDaGlsZHJlbiwgZmFsc2UsIG9wdGlvbnMuc2tpcERlZmF1bHRzKTtcbiAgfVxuXG4gIGlmICghdGhpcy4kX18uc3RyaWN0TW9kZSAmJiBvYmopIHtcbiAgICBjb25zdCBfdGhpcyA9IHRoaXM7XG4gICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHRoaXMuX2RvYyk7XG5cbiAgICBrZXlzLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgICAvLyBBdm9pZCBtZXRob2RzLCB2aXJ0dWFscywgZXhpc3RpbmcgZmllbGRzLCBhbmQgYCRgIGtleXMuIFRoZSBsYXR0ZXIgaXMgdG8gYXZvaWQgb3ZlcndyaXRpbmdcbiAgICAgIC8vIE1vbmdvb3NlIGludGVybmFscy5cbiAgICAgIGlmICghKGtleSBpbiBzY2hlbWEudHJlZSkgJiYgIShrZXkgaW4gc2NoZW1hLm1ldGhvZHMpICYmICEoa2V5IGluIHNjaGVtYS52aXJ0dWFscykgJiYgIWtleS5zdGFydHNXaXRoKCckJykpIHtcbiAgICAgICAgZGVmaW5lS2V5KHsgcHJvcDoga2V5LCBzdWJwcm9wczogbnVsbCwgcHJvdG90eXBlOiBfdGhpcyB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGFwcGx5UXVldWUodGhpcyk7XG59XG5cbkRvY3VtZW50LnByb3RvdHlwZS4kaXNNb25nb29zZURvY3VtZW50UHJvdG90eXBlID0gdHJ1ZTtcblxuLyoqXG4gKiBCb29sZWFuIGZsYWcgc3BlY2lmeWluZyBpZiB0aGUgZG9jdW1lbnQgaXMgbmV3LiBJZiB5b3UgY3JlYXRlIGEgZG9jdW1lbnRcbiAqIHVzaW5nIGBuZXdgLCB0aGlzIGRvY3VtZW50IHdpbGwgYmUgY29uc2lkZXJlZCBcIm5ld1wiLiBgJGlzTmV3YCBpcyBob3dcbiAqIE1vbmdvb3NlIGRldGVybWluZXMgd2hldGhlciBgc2F2ZSgpYCBzaG91bGQgdXNlIGBpbnNlcnRPbmUoKWAgdG8gY3JlYXRlXG4gKiBhIG5ldyBkb2N1bWVudCBvciBgdXBkYXRlT25lKClgIHRvIHVwZGF0ZSBhbiBleGlzdGluZyBkb2N1bWVudC5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IHVzZXIgPSBuZXcgVXNlcih7IG5hbWU6ICdKb2huIFNtaXRoJyB9KTtcbiAqICAgICB1c2VyLiRpc05ldzsgLy8gdHJ1ZVxuICpcbiAqICAgICBhd2FpdCB1c2VyLnNhdmUoKTsgLy8gU2VuZHMgYW4gYGluc2VydE9uZWAgdG8gTW9uZ29EQlxuICpcbiAqIE9uIHRoZSBvdGhlciBoYW5kLCBpZiB5b3UgbG9hZCBhbiBleGlzdGluZyBkb2N1bWVudCBmcm9tIHRoZSBkYXRhYmFzZVxuICogdXNpbmcgYGZpbmRPbmUoKWAgb3IgYW5vdGhlciBbcXVlcnkgb3BlcmF0aW9uXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvcXVlcmllcy5odG1sKSxcbiAqIGAkaXNOZXdgIHdpbGwgYmUgZmFsc2UuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBjb25zdCB1c2VyID0gYXdhaXQgVXNlci5maW5kT25lKHsgbmFtZTogJ0pvaG4gU21pdGgnIH0pO1xuICogICAgIHVzZXIuJGlzTmV3OyAvLyBmYWxzZVxuICpcbiAqIE1vbmdvb3NlIHNldHMgYCRpc05ld2AgdG8gYGZhbHNlYCBpbW1lZGlhdGVseSBhZnRlciBgc2F2ZSgpYCBzdWNjZWVkcy5cbiAqIFRoYXQgbWVhbnMgTW9uZ29vc2Ugc2V0cyBgJGlzTmV3YCB0byBmYWxzZSAqKmJlZm9yZSoqIGBwb3N0KCdzYXZlJylgIGhvb2tzIHJ1bi5cbiAqIEluIGBwb3N0KCdzYXZlJylgIGhvb2tzLCBgJGlzTmV3YCB3aWxsIGJlIGBmYWxzZWAgaWYgYHNhdmUoKWAgc3VjY2VlZGVkLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgdXNlclNjaGVtYS5wb3N0KCdzYXZlJywgZnVuY3Rpb24oKSB7XG4gKiAgICAgICB0aGlzLiRpc05ldzsgLy8gZmFsc2VcbiAqICAgICB9KTtcbiAqICAgICBhd2FpdCBVc2VyLmNyZWF0ZSh7IG5hbWU6ICdKb2huIFNtaXRoJyB9KTtcbiAqXG4gKiBGb3Igc3ViZG9jdW1lbnRzLCBgJGlzTmV3YCBpcyB0cnVlIGlmIGVpdGhlciB0aGUgcGFyZW50IGhhcyBgJGlzTmV3YCBzZXQsXG4gKiBvciBpZiB5b3UgY3JlYXRlIGEgbmV3IHN1YmRvY3VtZW50LlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgLy8gQXNzdW1lIGBHcm91cGAgaGFzIGEgZG9jdW1lbnQgYXJyYXkgYHVzZXJzYFxuICogICAgIGNvbnN0IGdyb3VwID0gYXdhaXQgR3JvdXAuZmluZE9uZSgpO1xuICogICAgIGdyb3VwLnVzZXJzWzBdLiRpc05ldzsgLy8gZmFsc2VcbiAqXG4gKiAgICAgZ3JvdXAudXNlcnMucHVzaCh7IG5hbWU6ICdKb2huIFNtaXRoJyB9KTtcbiAqICAgICBncm91cC51c2Vyc1sxXS4kaXNOZXc7IC8vIHRydWVcbiAqXG4gKiBAYXBpIHB1YmxpY1xuICogQHByb3BlcnR5ICRpc05ld1xuICogQG1lbWJlck9mIERvY3VtZW50XG4gKiBAaW5zdGFuY2VcbiAqL1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoRG9jdW1lbnQucHJvdG90eXBlLCAnaXNOZXcnLCB7XG4gIGdldDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuJGlzTmV3O1xuICB9LFxuICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgdGhpcy4kaXNOZXcgPSB2YWx1ZTtcbiAgfVxufSk7XG5cbi8qKlxuICogSGFzaCBjb250YWluaW5nIGN1cnJlbnQgdmFsaWRhdGlvbiBlcnJvcnMuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqIEBwcm9wZXJ0eSBlcnJvcnNcbiAqIEBtZW1iZXJPZiBEb2N1bWVudFxuICogQGluc3RhbmNlXG4gKi9cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KERvY3VtZW50LnByb3RvdHlwZSwgJ2Vycm9ycycsIHtcbiAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy4kZXJyb3JzO1xuICB9LFxuICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgdGhpcy4kZXJyb3JzID0gdmFsdWU7XG4gIH1cbn0pO1xuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cbkRvY3VtZW50LnByb3RvdHlwZS4kaXNOZXcgPSB0cnVlO1xuXG4vKiFcbiAqIERvY3VtZW50IGV4cG9zZXMgdGhlIE5vZGVKUyBldmVudCBlbWl0dGVyIEFQSSwgc28geW91IGNhbiB1c2VcbiAqIGBvbmAsIGBvbmNlYCwgZXRjLlxuICovXG51dGlscy5lYWNoKFxuICBbJ29uJywgJ29uY2UnLCAnZW1pdCcsICdsaXN0ZW5lcnMnLCAncmVtb3ZlTGlzdGVuZXInLCAnc2V0TWF4TGlzdGVuZXJzJyxcbiAgICAncmVtb3ZlQWxsTGlzdGVuZXJzJywgJ2FkZExpc3RlbmVyJ10sXG4gIGZ1bmN0aW9uKGVtaXR0ZXJGbikge1xuICAgIERvY3VtZW50LnByb3RvdHlwZVtlbWl0dGVyRm5dID0gZnVuY3Rpb24oKSB7XG4gICAgICAvLyBEZWxheSBjcmVhdGluZyBlbWl0dGVyIHVudGlsIG5lY2Vzc2FyeSBiZWNhdXNlIGVtaXR0ZXJzIHRha2UgdXAgYSBsb3Qgb2YgbWVtb3J5LFxuICAgICAgLy8gZXNwZWNpYWxseSBmb3Igc3ViZG9jdW1lbnRzLlxuICAgICAgaWYgKCF0aGlzLiRfXy5lbWl0dGVyKSB7XG4gICAgICAgIGlmIChlbWl0dGVyRm4gPT09ICdlbWl0Jykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLiRfXy5lbWl0dGVyID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICB0aGlzLiRfXy5lbWl0dGVyLnNldE1heExpc3RlbmVycygwKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLiRfXy5lbWl0dGVyW2VtaXR0ZXJGbl0uYXBwbHkodGhpcy4kX18uZW1pdHRlciwgYXJndW1lbnRzKTtcbiAgICB9O1xuICAgIERvY3VtZW50LnByb3RvdHlwZVtgJCR7ZW1pdHRlckZufWBdID0gRG9jdW1lbnQucHJvdG90eXBlW2VtaXR0ZXJGbl07XG4gIH0pO1xuXG5Eb2N1bWVudC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBEb2N1bWVudDtcblxuZm9yIChjb25zdCBpIGluIEV2ZW50RW1pdHRlci5wcm90b3R5cGUpIHtcbiAgRG9jdW1lbnRbaV0gPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlW2ldO1xufVxuXG4vKipcbiAqIFRoZSBkb2N1bWVudCdzIGludGVybmFsIHNjaGVtYS5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqIEBwcm9wZXJ0eSBzY2hlbWFcbiAqIEBtZW1iZXJPZiBEb2N1bWVudFxuICogQGluc3RhbmNlXG4gKi9cblxuRG9jdW1lbnQucHJvdG90eXBlLiRfX3NjaGVtYTtcblxuLyoqXG4gKiBUaGUgZG9jdW1lbnQncyBzY2hlbWEuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqIEBwcm9wZXJ0eSBzY2hlbWFcbiAqIEBtZW1iZXJPZiBEb2N1bWVudFxuICogQGluc3RhbmNlXG4gKi9cblxuRG9jdW1lbnQucHJvdG90eXBlLnNjaGVtYTtcblxuLyoqXG4gKiBFbXB0eSBvYmplY3QgdGhhdCB5b3UgY2FuIHVzZSBmb3Igc3RvcmluZyBwcm9wZXJ0aWVzIG9uIHRoZSBkb2N1bWVudC4gVGhpc1xuICogaXMgaGFuZHkgZm9yIHBhc3NpbmcgZGF0YSB0byBtaWRkbGV3YXJlIHdpdGhvdXQgY29uZmxpY3Rpbmcgd2l0aCBNb25nb29zZVxuICogaW50ZXJuYWxzLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgc2NoZW1hLnByZSgnc2F2ZScsIGZ1bmN0aW9uKCkge1xuICogICAgICAgLy8gTW9uZ29vc2Ugd2lsbCBzZXQgYGlzTmV3YCB0byBgZmFsc2VgIGlmIGBzYXZlKClgIHN1Y2NlZWRzXG4gKiAgICAgICB0aGlzLiRsb2NhbHMud2FzTmV3ID0gdGhpcy5pc05ldztcbiAqICAgICB9KTtcbiAqXG4gKiAgICAgc2NoZW1hLnBvc3QoJ3NhdmUnLCBmdW5jdGlvbigpIHtcbiAqICAgICAgIC8vIFByaW50cyB0cnVlIGlmIGBpc05ld2Agd2FzIHNldCBiZWZvcmUgYHNhdmUoKWBcbiAqICAgICAgIGNvbnNvbGUubG9nKHRoaXMuJGxvY2Fscy53YXNOZXcpO1xuICogICAgIH0pO1xuICpcbiAqIEBhcGkgcHVibGljXG4gKiBAcHJvcGVydHkgJGxvY2Fsc1xuICogQG1lbWJlck9mIERvY3VtZW50XG4gKiBAaW5zdGFuY2VcbiAqL1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoRG9jdW1lbnQucHJvdG90eXBlLCAnJGxvY2FscycsIHtcbiAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgZW51bWVyYWJsZTogZmFsc2UsXG4gIGdldDogZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuJF9fLmxvY2FscyA9PSBudWxsKSB7XG4gICAgICB0aGlzLiRfXy5sb2NhbHMgPSB7fTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuJF9fLmxvY2FscztcbiAgfSxcbiAgc2V0OiBmdW5jdGlvbih2KSB7XG4gICAgdGhpcy4kX18ubG9jYWxzID0gdjtcbiAgfVxufSk7XG5cbi8qKlxuICogTGVnYWN5IGFsaWFzIGZvciBgJGlzTmV3YC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICogQHByb3BlcnR5IGlzTmV3XG4gKiBAbWVtYmVyT2YgRG9jdW1lbnRcbiAqIEBzZWUgJGlzTmV3IGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvZG9jdW1lbnQuaHRtbCNEb2N1bWVudC5wcm90b3R5cGUuJGlzTmV3XG4gKiBAaW5zdGFuY2VcbiAqL1xuXG5Eb2N1bWVudC5wcm90b3R5cGUuaXNOZXc7XG5cbi8qKlxuICogU2V0IHRoaXMgcHJvcGVydHkgdG8gYWRkIGFkZGl0aW9uYWwgcXVlcnkgZmlsdGVycyB3aGVuIE1vbmdvb3NlIHNhdmVzIHRoaXMgZG9jdW1lbnQgYW5kIGBpc05ld2AgaXMgZmFsc2UuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICAvLyBNYWtlIHN1cmUgYHNhdmUoKWAgbmV2ZXIgdXBkYXRlcyBhIHNvZnQgZGVsZXRlZCBkb2N1bWVudC5cbiAqICAgICBzY2hlbWEucHJlKCdzYXZlJywgZnVuY3Rpb24oKSB7XG4gKiAgICAgICB0aGlzLiR3aGVyZSA9IHsgaXNEZWxldGVkOiBmYWxzZSB9O1xuICogICAgIH0pO1xuICpcbiAqIEBhcGkgcHVibGljXG4gKiBAcHJvcGVydHkgJHdoZXJlXG4gKiBAbWVtYmVyT2YgRG9jdW1lbnRcbiAqIEBpbnN0YW5jZVxuICovXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShEb2N1bWVudC5wcm90b3R5cGUsICckd2hlcmUnLCB7XG4gIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gIGVudW1lcmFibGU6IGZhbHNlLFxuICB3cml0YWJsZTogdHJ1ZVxufSk7XG5cbi8qKlxuICogVGhlIHN0cmluZyB2ZXJzaW9uIG9mIHRoaXMgZG9jdW1lbnRzIF9pZC5cbiAqXG4gKiAjIyMjIE5vdGU6XG4gKlxuICogVGhpcyBnZXR0ZXIgZXhpc3RzIG9uIGFsbCBkb2N1bWVudHMgYnkgZGVmYXVsdC4gVGhlIGdldHRlciBjYW4gYmUgZGlzYWJsZWQgYnkgc2V0dGluZyB0aGUgYGlkYCBbb3B0aW9uXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvZ3VpZGUuaHRtbCNpZCkgb2YgaXRzIGBTY2hlbWFgIHRvIGZhbHNlIGF0IGNvbnN0cnVjdGlvbiB0aW1lLlxuICpcbiAqICAgICBuZXcgU2NoZW1hKHsgbmFtZTogU3RyaW5nIH0sIHsgaWQ6IGZhbHNlIH0pO1xuICpcbiAqIEBhcGkgcHVibGljXG4gKiBAc2VlIFNjaGVtYSBvcHRpb25zIGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9ndWlkZS5odG1sI29wdGlvbnNcbiAqIEBwcm9wZXJ0eSBpZFxuICogQG1lbWJlck9mIERvY3VtZW50XG4gKiBAaW5zdGFuY2VcbiAqL1xuXG5Eb2N1bWVudC5wcm90b3R5cGUuaWQ7XG5cbi8qKlxuICogSGFzaCBjb250YWluaW5nIGN1cnJlbnQgdmFsaWRhdGlvbiAkZXJyb3JzLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKiBAcHJvcGVydHkgJGVycm9yc1xuICogQG1lbWJlck9mIERvY3VtZW50XG4gKiBAaW5zdGFuY2VcbiAqL1xuXG5Eb2N1bWVudC5wcm90b3R5cGUuJGVycm9ycztcblxuLyoqXG4gKiBBIHN0cmluZyBjb250YWluaW5nIHRoZSBjdXJyZW50IG9wZXJhdGlvbiB0aGF0IE1vbmdvb3NlIGlzIGV4ZWN1dGluZ1xuICogb24gdGhpcyBkb2N1bWVudC4gTWF5IGJlIGBudWxsYCwgYCdzYXZlJ2AsIGAndmFsaWRhdGUnYCwgb3IgYCdyZW1vdmUnYC5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IGRvYyA9IG5ldyBNb2RlbCh7IG5hbWU6ICd0ZXN0JyB9KTtcbiAqICAgICBkb2MuJG9wOyAvLyBudWxsXG4gKlxuICogICAgIGNvbnN0IHByb21pc2UgPSBkb2Muc2F2ZSgpO1xuICogICAgIGRvYy4kb3A7IC8vICdzYXZlJ1xuICpcbiAqICAgICBhd2FpdCBwcm9taXNlO1xuICogICAgIGRvYy4kb3A7IC8vIG51bGxcbiAqXG4gKiBAYXBpIHB1YmxpY1xuICogQHByb3BlcnR5ICRvcFxuICogQG1lbWJlck9mIERvY3VtZW50XG4gKiBAaW5zdGFuY2VcbiAqL1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoRG9jdW1lbnQucHJvdG90eXBlLCAnJG9wJywge1xuICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLiRfXy5vcCB8fCBudWxsO1xuICB9LFxuICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgdGhpcy4kX18ub3AgPSB2YWx1ZTtcbiAgfVxufSk7XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxuZnVuY3Rpb24gJGFwcGx5RGVmYXVsdHNUb05lc3RlZCh2YWwsIHBhdGgsIGRvYykge1xuICBpZiAodmFsID09IG51bGwpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBjb25zdCBwYXRocyA9IE9iamVjdC5rZXlzKGRvYy4kX19zY2hlbWEucGF0aHMpO1xuICBjb25zdCBwbGVuID0gcGF0aHMubGVuZ3RoO1xuXG4gIGNvbnN0IHBhdGhQaWVjZXMgPSBwYXRoLmluZGV4T2YoJy4nKSA9PT0gLTEgPyBbcGF0aF0gOiBwYXRoLnNwbGl0KCcuJyk7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBwbGVuOyArK2kpIHtcbiAgICBsZXQgY3VyUGF0aCA9ICcnO1xuICAgIGNvbnN0IHAgPSBwYXRoc1tpXTtcblxuICAgIGlmICghcC5zdGFydHNXaXRoKHBhdGggKyAnLicpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBjb25zdCB0eXBlID0gZG9jLiRfX3NjaGVtYS5wYXRoc1twXTtcbiAgICBjb25zdCBwaWVjZXMgPSB0eXBlLnNwbGl0UGF0aCgpLnNsaWNlKHBhdGhQaWVjZXMubGVuZ3RoKTtcbiAgICBjb25zdCBsZW4gPSBwaWVjZXMubGVuZ3RoO1xuXG4gICAgaWYgKHR5cGUuZGVmYXVsdFZhbHVlID09PSB2b2lkIDApIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGxldCBjdXIgPSB2YWw7XG5cbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IGxlbjsgKytqKSB7XG4gICAgICBpZiAoY3VyID09IG51bGwpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHBpZWNlID0gcGllY2VzW2pdO1xuXG4gICAgICBpZiAoaiA9PT0gbGVuIC0gMSkge1xuICAgICAgICBpZiAoY3VyW3BpZWNlXSAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IGRlZiA9IHR5cGUuZ2V0RGVmYXVsdChkb2MsIGZhbHNlKTtcbiAgICAgICAgICBpZiAoZGVmICE9PSB2b2lkIDApIHtcbiAgICAgICAgICAgIGN1cltwaWVjZV0gPSBkZWY7XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICBkb2MuaW52YWxpZGF0ZShwYXRoICsgJy4nICsgY3VyUGF0aCwgZXJyKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBjdXJQYXRoICs9ICghY3VyUGF0aC5sZW5ndGggPyAnJyA6ICcuJykgKyBwaWVjZTtcblxuICAgICAgY3VyW3BpZWNlXSA9IGN1cltwaWVjZV0gfHwge307XG4gICAgICBjdXIgPSBjdXJbcGllY2VdO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEJ1aWxkcyB0aGUgZGVmYXVsdCBkb2Mgc3RydWN0dXJlXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9ialxuICogQHBhcmFtIHtPYmplY3R9IFtmaWVsZHNdXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtza2lwSWRdXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtleGNsdWRlXVxuICogQHBhcmFtIHtPYmplY3R9IFtoYXNJbmNsdWRlZENoaWxkcmVuXVxuICogQGFwaSBwcml2YXRlXG4gKiBAbWV0aG9kICRfX2J1aWxkRG9jXG4gKiBAbWVtYmVyT2YgRG9jdW1lbnRcbiAqIEBpbnN0YW5jZVxuICovXG5cbkRvY3VtZW50LnByb3RvdHlwZS4kX19idWlsZERvYyA9IGZ1bmN0aW9uKG9iaiwgZmllbGRzLCBza2lwSWQsIGV4Y2x1ZGUsIGhhc0luY2x1ZGVkQ2hpbGRyZW4pIHtcbiAgY29uc3QgZG9jID0ge307XG5cbiAgY29uc3QgcGF0aHMgPSBPYmplY3Qua2V5cyh0aGlzLiRfX3NjaGVtYS5wYXRocykuXG4gICAgLy8gRG9uJ3QgYnVpbGQgdXAgYW55IHBhdGhzIHRoYXQgYXJlIHVuZGVybmVhdGggYSBtYXAsIHdlIGRvbid0IGtub3dcbiAgICAvLyB3aGF0IHRoZSBrZXlzIHdpbGwgYmVcbiAgICBmaWx0ZXIocCA9PiAhcC5pbmNsdWRlcygnJConKSk7XG4gIGNvbnN0IHBsZW4gPSBwYXRocy5sZW5ndGg7XG4gIGxldCBpaSA9IDA7XG5cbiAgZm9yICg7IGlpIDwgcGxlbjsgKytpaSkge1xuICAgIGNvbnN0IHAgPSBwYXRoc1tpaV07XG5cbiAgICBpZiAocCA9PT0gJ19pZCcpIHtcbiAgICAgIGlmIChza2lwSWQpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAob2JqICYmICdfaWQnIGluIG9iaikge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBwYXRoID0gdGhpcy4kX19zY2hlbWEucGF0aHNbcF0uc3BsaXRQYXRoKCk7XG4gICAgY29uc3QgbGVuID0gcGF0aC5sZW5ndGg7XG4gICAgY29uc3QgbGFzdCA9IGxlbiAtIDE7XG4gICAgbGV0IGN1clBhdGggPSAnJztcbiAgICBsZXQgZG9jXyA9IGRvYztcbiAgICBsZXQgaW5jbHVkZWQgPSBmYWxzZTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgIGNvbnN0IHBpZWNlID0gcGF0aFtpXTtcblxuICAgICAgaWYgKCFjdXJQYXRoLmxlbmd0aCkge1xuICAgICAgICBjdXJQYXRoID0gcGllY2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjdXJQYXRoICs9ICcuJyArIHBpZWNlO1xuICAgICAgfVxuXG4gICAgICAvLyBzdXBwb3J0IGV4Y2x1ZGluZyBpbnRlcm1lZGlhcnkgbGV2ZWxzXG4gICAgICBpZiAoZXhjbHVkZSA9PT0gdHJ1ZSkge1xuICAgICAgICBpZiAoY3VyUGF0aCBpbiBmaWVsZHMpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChleGNsdWRlID09PSBmYWxzZSAmJiBmaWVsZHMgJiYgIWluY2x1ZGVkKSB7XG4gICAgICAgIGlmIChjdXJQYXRoIGluIGZpZWxkcykge1xuICAgICAgICAgIGluY2x1ZGVkID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIGlmICghaGFzSW5jbHVkZWRDaGlsZHJlbltjdXJQYXRoXSkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChpIDwgbGFzdCkge1xuICAgICAgICBkb2NfID0gZG9jX1twaWVjZV0gfHwgKGRvY19bcGllY2VdID0ge30pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHRoaXMuX2RvYyA9IGRvYztcbn07XG5cbi8qIVxuICogQ29udmVydHMgdG8gUE9KTyB3aGVuIHlvdSB1c2UgdGhlIGRvY3VtZW50IGZvciBxdWVyeWluZ1xuICovXG5cbkRvY3VtZW50LnByb3RvdHlwZS50b0JTT04gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMudG9PYmplY3QoaW50ZXJuYWxUb09iamVjdE9wdGlvbnMpO1xufTtcblxuLyoqXG4gKiBJbml0aWFsaXplcyB0aGUgZG9jdW1lbnQgd2l0aG91dCBzZXR0ZXJzIG9yIG1hcmtpbmcgYW55dGhpbmcgbW9kaWZpZWQuXG4gKlxuICogQ2FsbGVkIGludGVybmFsbHkgYWZ0ZXIgYSBkb2N1bWVudCBpcyByZXR1cm5lZCBmcm9tIG1vbmdvZGIuIE5vcm1hbGx5LFxuICogeW91IGRvICoqbm90KiogbmVlZCB0byBjYWxsIHRoaXMgZnVuY3Rpb24gb24geW91ciBvd24uXG4gKlxuICogVGhpcyBmdW5jdGlvbiB0cmlnZ2VycyBgaW5pdGAgW21pZGRsZXdhcmVdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9taWRkbGV3YXJlLmh0bWwpLlxuICogTm90ZSB0aGF0IGBpbml0YCBob29rcyBhcmUgW3N5bmNocm9ub3VzXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvbWlkZGxld2FyZS5odG1sI3N5bmNocm9ub3VzKS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gZG9jIGRvY3VtZW50IHJldHVybmVkIGJ5IG1vbmdvXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdHNdXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbZm5dXG4gKiBAYXBpIHB1YmxpY1xuICogQG1lbWJlck9mIERvY3VtZW50XG4gKiBAaW5zdGFuY2VcbiAqL1xuXG5Eb2N1bWVudC5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uKGRvYywgb3B0cywgZm4pIHtcbiAgaWYgKHR5cGVvZiBvcHRzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgZm4gPSBvcHRzO1xuICAgIG9wdHMgPSBudWxsO1xuICB9XG5cbiAgdGhpcy4kX19pbml0KGRvYywgb3B0cyk7XG5cbiAgaWYgKGZuKSB7XG4gICAgZm4obnVsbCwgdGhpcyk7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQWxpYXMgZm9yIFtgLmluaXRgXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvYXBpL2RvY3VtZW50Lmh0bWwjRG9jdW1lbnQucHJvdG90eXBlLmluaXQoKSlcbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkRvY3VtZW50LnByb3RvdHlwZS4kaW5pdCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci5wcm90b3R5cGUuaW5pdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufTtcblxuLyoqXG4gKiBJbnRlcm5hbCBcImluaXRcIiBmdW5jdGlvblxuICpcbiAqIEBwYXJhbSB7RG9jdW1lbnR9IGRvY1xuICogQHBhcmFtIHtPYmplY3R9IFtvcHRzXVxuICogQHJldHVybnMge0RvY3VtZW50fSB0aGlzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Eb2N1bWVudC5wcm90b3R5cGUuJF9faW5pdCA9IGZ1bmN0aW9uKGRvYywgb3B0cykge1xuICB0aGlzLiRpc05ldyA9IGZhbHNlO1xuICBvcHRzID0gb3B0cyB8fCB7fTtcblxuICAvLyBoYW5kbGUgZG9jcyB3aXRoIHBvcHVsYXRlZCBwYXRoc1xuICAvLyBJZiBkb2MuX2lkIGlzIG5vdCBudWxsIG9yIHVuZGVmaW5lZFxuICBpZiAoZG9jLl9pZCAhPSBudWxsICYmIG9wdHMucG9wdWxhdGVkICYmIG9wdHMucG9wdWxhdGVkLmxlbmd0aCkge1xuICAgIGNvbnN0IGlkID0gU3RyaW5nKGRvYy5faWQpO1xuICAgIGZvciAoY29uc3QgaXRlbSBvZiBvcHRzLnBvcHVsYXRlZCkge1xuICAgICAgaWYgKGl0ZW0uaXNWaXJ0dWFsKSB7XG4gICAgICAgIHRoaXMuJHBvcHVsYXRlZChpdGVtLnBhdGgsIHV0aWxzLmdldFZhbHVlKGl0ZW0ucGF0aCwgZG9jKSwgaXRlbSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLiRwb3B1bGF0ZWQoaXRlbS5wYXRoLCBpdGVtLl9kb2NzW2lkXSwgaXRlbSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChpdGVtLl9jaGlsZERvY3MgPT0gbnVsbCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGZvciAoY29uc3QgY2hpbGQgb2YgaXRlbS5fY2hpbGREb2NzKSB7XG4gICAgICAgIGlmIChjaGlsZCA9PSBudWxsIHx8IGNoaWxkLiRfXyA9PSBudWxsKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgY2hpbGQuJF9fLnBhcmVudCA9IHRoaXM7XG4gICAgICB9XG4gICAgICBpdGVtLl9jaGlsZERvY3MgPSBbXTtcbiAgICB9XG4gIH1cblxuICBpbml0KHRoaXMsIGRvYywgdGhpcy5fZG9jLCBvcHRzKTtcblxuICBtYXJrQXJyYXlTdWJkb2NzUG9wdWxhdGVkKHRoaXMsIG9wdHMucG9wdWxhdGVkKTtcbiAgdGhpcy4kZW1pdCgnaW5pdCcsIHRoaXMpO1xuICB0aGlzLmNvbnN0cnVjdG9yLmVtaXQoJ2luaXQnLCB0aGlzKTtcblxuICBjb25zdCBoYXNJbmNsdWRlZENoaWxkcmVuID0gdGhpcy4kX18uZXhjbHVkZSA9PT0gZmFsc2UgJiYgdGhpcy4kX18uc2VsZWN0ZWQgP1xuICAgICRfX2hhc0luY2x1ZGVkQ2hpbGRyZW4odGhpcy4kX18uc2VsZWN0ZWQpIDpcbiAgICBudWxsO1xuXG4gIGFwcGx5RGVmYXVsdHModGhpcywgdGhpcy4kX18uc2VsZWN0ZWQsIHRoaXMuJF9fLmV4Y2x1ZGUsIGhhc0luY2x1ZGVkQ2hpbGRyZW4sIGZhbHNlLCB0aGlzLiRfXy5za2lwRGVmYXVsdHMpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogSW5pdCBoZWxwZXIuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHNlbGYgZG9jdW1lbnQgaW5zdGFuY2VcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmogcmF3IG1vbmdvZGIgZG9jXG4gKiBAcGFyYW0ge09iamVjdH0gZG9jIG9iamVjdCB3ZSBhcmUgaW5pdGlhbGl6aW5nXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdHNdIE9wdGlvbmFsIE9wdGlvbnNcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdHMuc2V0dGVyc10gQ2FsbCBgYXBwbHlTZXR0ZXJzYCBpbnN0ZWFkIG9mIGBjYXN0YFxuICogQHBhcmFtIHtTdHJpbmd9IFtwcmVmaXhdIFByZWZpeCB0byBhZGQgdG8gZWFjaCBwYXRoXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBpbml0KHNlbGYsIG9iaiwgZG9jLCBvcHRzLCBwcmVmaXgpIHtcbiAgcHJlZml4ID0gcHJlZml4IHx8ICcnO1xuXG4gIGlmIChvYmouJF9fICE9IG51bGwpIHtcbiAgICBvYmogPSBvYmouX2RvYztcbiAgfVxuICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMob2JqKTtcbiAgY29uc3QgbGVuID0ga2V5cy5sZW5ndGg7XG4gIGxldCBzY2hlbWFUeXBlO1xuICBsZXQgcGF0aDtcbiAgbGV0IGk7XG4gIGxldCBpbmRleCA9IDA7XG4gIGNvbnN0IHN0cmljdCA9IHNlbGYuJF9fLnN0cmljdE1vZGU7XG4gIGNvbnN0IGRvY1NjaGVtYSA9IHNlbGYuJF9fc2NoZW1hO1xuXG4gIHdoaWxlIChpbmRleCA8IGxlbikge1xuICAgIF9pbml0KGluZGV4KyspO1xuICB9XG5cbiAgZnVuY3Rpb24gX2luaXQoaW5kZXgpIHtcbiAgICBpID0ga2V5c1tpbmRleF07XG4gICAgLy8gYXZvaWQgcHJvdG90eXBlIHBvbGx1dGlvblxuICAgIGlmIChpID09PSAnX19wcm90b19fJyB8fCBpID09PSAnY29uc3RydWN0b3InKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHBhdGggPSBwcmVmaXggKyBpO1xuICAgIHNjaGVtYVR5cGUgPSBkb2NTY2hlbWEucGF0aChwYXRoKTtcbiAgICAvLyBTaG91bGQgc3RpbGwgd29yayBpZiBub3QgYSBtb2RlbC1sZXZlbCBkaXNjcmltaW5hdG9yLCBidXQgc2hvdWxkIG5vdCBiZVxuICAgIC8vIG5lY2Vzc2FyeS4gVGhpcyBpcyAqb25seSogdG8gY2F0Y2ggdGhlIGNhc2Ugd2hlcmUgd2UgcXVlcmllZCB1c2luZyB0aGVcbiAgICAvLyBiYXNlIG1vZGVsIGFuZCB0aGUgZGlzY3JpbWluYXRlZCBtb2RlbCBoYXMgYSBwcm9qZWN0aW9uXG4gICAgaWYgKGRvY1NjaGVtYS4kaXNSb290RGlzY3JpbWluYXRvciAmJiAhc2VsZi4kX19pc1NlbGVjdGVkKHBhdGgpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKCFzY2hlbWFUeXBlICYmIHV0aWxzLmlzUE9KTyhvYmpbaV0pKSB7XG4gICAgICAvLyBhc3N1bWUgbmVzdGVkIG9iamVjdFxuICAgICAgaWYgKCFkb2NbaV0pIHtcbiAgICAgICAgZG9jW2ldID0ge307XG4gICAgICAgIGlmICghc3RyaWN0ICYmICEoaSBpbiBkb2NTY2hlbWEudHJlZSkgJiYgIShpIGluIGRvY1NjaGVtYS5tZXRob2RzKSAmJiAhKGkgaW4gZG9jU2NoZW1hLnZpcnR1YWxzKSkge1xuICAgICAgICAgIHNlbGZbaV0gPSBkb2NbaV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGluaXQoc2VsZiwgb2JqW2ldLCBkb2NbaV0sIG9wdHMsIHBhdGggKyAnLicpO1xuICAgIH0gZWxzZSBpZiAoIXNjaGVtYVR5cGUpIHtcbiAgICAgIGRvY1tpXSA9IG9ialtpXTtcbiAgICAgIGlmICghc3RyaWN0ICYmICFwcmVmaXgpIHtcbiAgICAgICAgc2VsZltpXSA9IG9ialtpXTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gUmV0YWluIG9yZGVyIHdoZW4gb3ZlcndyaXRpbmcgZGVmYXVsdHNcbiAgICAgIGlmIChkb2MuaGFzT3duUHJvcGVydHkoaSkgJiYgb2JqW2ldICE9PSB2b2lkIDAgJiYgIW9wdHMuaHlkcmF0ZWRQb3B1bGF0ZWREb2NzKSB7XG4gICAgICAgIGRlbGV0ZSBkb2NbaV07XG4gICAgICB9XG4gICAgICBpZiAob2JqW2ldID09PSBudWxsKSB7XG4gICAgICAgIGRvY1tpXSA9IHNjaGVtYVR5cGUuX2Nhc3ROdWxsaXNoKG51bGwpO1xuICAgICAgfSBlbHNlIGlmIChvYmpbaV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb25zdCB3YXNQb3B1bGF0ZWQgPSBvYmpbaV0uJF9fID09IG51bGwgPyBudWxsIDogb2JqW2ldLiRfXy53YXNQb3B1bGF0ZWQ7XG4gICAgICAgIGlmICgoc2NoZW1hVHlwZSAmJiAhd2FzUG9wdWxhdGVkKSAmJiAhb3B0cy5oeWRyYXRlZFBvcHVsYXRlZERvY3MpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKG9wdHMgJiYgb3B0cy5zZXR0ZXJzKSB7XG4gICAgICAgICAgICAgIC8vIENhbGwgYXBwbHlTZXR0ZXJzIHdpdGggYGluaXQgPSBmYWxzZWAgYmVjYXVzZSBvdGhlcndpc2Ugc2V0dGVycyBhcmUgYSBub29wXG4gICAgICAgICAgICAgIGNvbnN0IG92ZXJyaWRlSW5pdCA9IGZhbHNlO1xuICAgICAgICAgICAgICBkb2NbaV0gPSBzY2hlbWFUeXBlLmFwcGx5U2V0dGVycyhvYmpbaV0sIHNlbGYsIG92ZXJyaWRlSW5pdCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBkb2NbaV0gPSBzY2hlbWFUeXBlLmNhc3Qob2JqW2ldLCBzZWxmLCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBzZWxmLmludmFsaWRhdGUoZS5wYXRoLCBuZXcgVmFsaWRhdG9yRXJyb3Ioe1xuICAgICAgICAgICAgICBwYXRoOiBlLnBhdGgsXG4gICAgICAgICAgICAgIG1lc3NhZ2U6IGUubWVzc2FnZSxcbiAgICAgICAgICAgICAgdHlwZTogJ2Nhc3QnLFxuICAgICAgICAgICAgICB2YWx1ZTogZS52YWx1ZSxcbiAgICAgICAgICAgICAgcmVhc29uOiBlXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRvY1tpXSA9IG9ialtpXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gbWFyayBhcyBoeWRyYXRlZFxuICAgICAgaWYgKCFzZWxmLiRpc01vZGlmaWVkKHBhdGgpKSB7XG4gICAgICAgIHNlbGYuJF9fLmFjdGl2ZVBhdGhzLmluaXQocGF0aCk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogU2VuZHMgYW4gdXBkYXRlT25lIGNvbW1hbmQgd2l0aCB0aGlzIGRvY3VtZW50IGBfaWRgIGFzIHRoZSBxdWVyeSBzZWxlY3Rvci5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIHdlaXJkQ2FyLnVwZGF0ZU9uZSh7JGluYzoge3doZWVsczoxfX0sIHsgdzogMSB9LCBjYWxsYmFjayk7XG4gKlxuICogIyMjIyBWYWxpZCBvcHRpb25zOlxuICpcbiAqICAtIHNhbWUgYXMgaW4gW01vZGVsLnVwZGF0ZU9uZV0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2FwaS9tb2RlbC5odG1sI01vZGVsLnVwZGF0ZU9uZSlcbiAqXG4gKiBAc2VlIE1vZGVsLnVwZGF0ZU9uZSBodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvYXBpL21vZGVsLmh0bWwjTW9kZWwudXBkYXRlT25lXG4gKiBAcGFyYW0ge09iamVjdH0gZG9jXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIG9wdGlvbmFsIHNlZSBbYFF1ZXJ5LnByb3RvdHlwZS5zZXRPcHRpb25zKClgXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvYXBpL3F1ZXJ5Lmh0bWwjUXVlcnkucHJvdG90eXBlLnNldE9wdGlvbnMoKSlcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy5sZWFuXSBpZiB0cnV0aHksIG1vbmdvb3NlIHdpbGwgcmV0dXJuIHRoZSBkb2N1bWVudCBhcyBhIHBsYWluIEphdmFTY3JpcHQgb2JqZWN0IHJhdGhlciB0aGFuIGEgbW9uZ29vc2UgZG9jdW1lbnQuIFNlZSBbYFF1ZXJ5LmxlYW4oKWBdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvcXVlcnkuaHRtbCNRdWVyeS5wcm90b3R5cGUubGVhbigpKSBhbmQgdGhlIFtNb25nb29zZSBsZWFuIHR1dG9yaWFsXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvdHV0b3JpYWxzL2xlYW4uaHRtbCkuXG4gKiBAcGFyYW0ge0Jvb2xlYW58U3RyaW5nfSBbb3B0aW9ucy5zdHJpY3RdIG92ZXJ3cml0ZXMgdGhlIHNjaGVtYSdzIFtzdHJpY3QgbW9kZSBvcHRpb25dKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9ndWlkZS5odG1sI3N0cmljdClcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMudGltZXN0YW1wcz1udWxsXSBJZiBzZXQgdG8gYGZhbHNlYCBhbmQgW3NjaGVtYS1sZXZlbCB0aW1lc3RhbXBzXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvZ3VpZGUuaHRtbCN0aW1lc3RhbXBzKSBhcmUgZW5hYmxlZCwgc2tpcCB0aW1lc3RhbXBzIGZvciB0aGlzIHVwZGF0ZS4gTm90ZSB0aGF0IHRoaXMgYWxsb3dzIHlvdSB0byBvdmVyd3JpdGUgdGltZXN0YW1wcy4gRG9lcyBub3RoaW5nIGlmIHNjaGVtYS1sZXZlbCB0aW1lc3RhbXBzIGFyZSBub3Qgc2V0LlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXVxuICogQHJldHVybiB7UXVlcnl9XG4gKiBAYXBpIHB1YmxpY1xuICogQG1lbWJlck9mIERvY3VtZW50XG4gKiBAaW5zdGFuY2VcbiAqL1xuXG5Eb2N1bWVudC5wcm90b3R5cGUudXBkYXRlT25lID0gZnVuY3Rpb24gdXBkYXRlT25lKGRvYywgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgY29uc3QgcXVlcnkgPSB0aGlzLmNvbnN0cnVjdG9yLnVwZGF0ZU9uZSh7IF9pZDogdGhpcy5faWQgfSwgZG9jLCBvcHRpb25zKTtcbiAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gIHF1ZXJ5LnByZShmdW5jdGlvbiBxdWVyeVByZVVwZGF0ZU9uZShjYikge1xuICAgIHNlbGYuY29uc3RydWN0b3IuX21pZGRsZXdhcmUuZXhlY1ByZSgndXBkYXRlT25lJywgc2VsZiwgW3NlbGZdLCBjYik7XG4gIH0pO1xuICBxdWVyeS5wb3N0KGZ1bmN0aW9uIHF1ZXJ5UG9zdFVwZGF0ZU9uZShjYikge1xuICAgIHNlbGYuY29uc3RydWN0b3IuX21pZGRsZXdhcmUuZXhlY1Bvc3QoJ3VwZGF0ZU9uZScsIHNlbGYsIFtzZWxmXSwge30sIGNiKTtcbiAgfSk7XG5cbiAgaWYgKHRoaXMuJHNlc3Npb24oKSAhPSBudWxsKSB7XG4gICAgaWYgKCEoJ3Nlc3Npb24nIGluIHF1ZXJ5Lm9wdGlvbnMpKSB7XG4gICAgICBxdWVyeS5vcHRpb25zLnNlc3Npb24gPSB0aGlzLiRzZXNzaW9uKCk7XG4gICAgfVxuICB9XG5cbiAgaWYgKGNhbGxiYWNrICE9IG51bGwpIHtcbiAgICByZXR1cm4gcXVlcnkuZXhlYyhjYWxsYmFjayk7XG4gIH1cblxuICByZXR1cm4gcXVlcnk7XG59O1xuXG4vKipcbiAqIFNlbmRzIGEgcmVwbGFjZU9uZSBjb21tYW5kIHdpdGggdGhpcyBkb2N1bWVudCBgX2lkYCBhcyB0aGUgcXVlcnkgc2VsZWN0b3IuXG4gKlxuICogIyMjIyBWYWxpZCBvcHRpb25zOlxuICpcbiAqICAtIHNhbWUgYXMgaW4gW01vZGVsLnJlcGxhY2VPbmVdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvbW9kZWwuaHRtbCNNb2RlbC5yZXBsYWNlT25lKCkpXG4gKlxuICogQHNlZSBNb2RlbC5yZXBsYWNlT25lIGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvbW9kZWwuaHRtbCNNb2RlbC5yZXBsYWNlT25lKClcbiAqIEBwYXJhbSB7T2JqZWN0fSBkb2NcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja11cbiAqIEByZXR1cm4ge1F1ZXJ5fVxuICogQGFwaSBwdWJsaWNcbiAqIEBtZW1iZXJPZiBEb2N1bWVudFxuICogQGluc3RhbmNlXG4gKi9cblxuRG9jdW1lbnQucHJvdG90eXBlLnJlcGxhY2VPbmUgPSBmdW5jdGlvbiByZXBsYWNlT25lKCkge1xuICBjb25zdCBhcmdzID0gWy4uLmFyZ3VtZW50c107XG4gIGFyZ3MudW5zaGlmdCh7IF9pZDogdGhpcy5faWQgfSk7XG4gIHJldHVybiB0aGlzLmNvbnN0cnVjdG9yLnJlcGxhY2VPbmUuYXBwbHkodGhpcy5jb25zdHJ1Y3RvciwgYXJncyk7XG59O1xuXG4vKipcbiAqIEdldHRlci9zZXR0ZXIgYXJvdW5kIHRoZSBzZXNzaW9uIGFzc29jaWF0ZWQgd2l0aCB0aGlzIGRvY3VtZW50LiBVc2VkIHRvXG4gKiBhdXRvbWF0aWNhbGx5IHNldCBgc2Vzc2lvbmAgaWYgeW91IGBzYXZlKClgIGEgZG9jIHRoYXQgeW91IGdvdCBmcm9tIGFcbiAqIHF1ZXJ5IHdpdGggYW4gYXNzb2NpYXRlZCBzZXNzaW9uLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgY29uc3Qgc2Vzc2lvbiA9IE15TW9kZWwuc3RhcnRTZXNzaW9uKCk7XG4gKiAgICAgY29uc3QgZG9jID0gYXdhaXQgTXlNb2RlbC5maW5kT25lKCkuc2Vzc2lvbihzZXNzaW9uKTtcbiAqICAgICBkb2MuJHNlc3Npb24oKSA9PT0gc2Vzc2lvbjsgLy8gdHJ1ZVxuICogICAgIGRvYy4kc2Vzc2lvbihudWxsKTtcbiAqICAgICBkb2MuJHNlc3Npb24oKSA9PT0gbnVsbDsgLy8gdHJ1ZVxuICpcbiAqIElmIHRoaXMgaXMgYSB0b3AtbGV2ZWwgZG9jdW1lbnQsIHNldHRpbmcgdGhlIHNlc3Npb24gcHJvcGFnYXRlcyB0byBhbGwgY2hpbGRcbiAqIGRvY3MuXG4gKlxuICogQHBhcmFtIHtDbGllbnRTZXNzaW9ufSBbc2Vzc2lvbl0gb3ZlcndyaXRlIHRoZSBjdXJyZW50IHNlc3Npb25cbiAqIEByZXR1cm4ge0NsaWVudFNlc3Npb259XG4gKiBAbWV0aG9kICRzZXNzaW9uXG4gKiBAYXBpIHB1YmxpY1xuICogQG1lbWJlck9mIERvY3VtZW50XG4gKi9cblxuRG9jdW1lbnQucHJvdG90eXBlLiRzZXNzaW9uID0gZnVuY3Rpb24gJHNlc3Npb24oc2Vzc2lvbikge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgIGlmICh0aGlzLiRfXy5zZXNzaW9uICE9IG51bGwgJiYgdGhpcy4kX18uc2Vzc2lvbi5oYXNFbmRlZCkge1xuICAgICAgdGhpcy4kX18uc2Vzc2lvbiA9IG51bGw7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuJF9fLnNlc3Npb247XG4gIH1cblxuICBpZiAoc2Vzc2lvbiAhPSBudWxsICYmIHNlc3Npb24uaGFzRW5kZWQpIHtcbiAgICB0aHJvdyBuZXcgTW9uZ29vc2VFcnJvcignQ2Fubm90IHNldCBhIGRvY3VtZW50XFwncyBzZXNzaW9uIHRvIGEgc2Vzc2lvbiB0aGF0IGhhcyBlbmRlZC4gTWFrZSBzdXJlIHlvdSBoYXZlblxcJ3QgJyArXG4gICAgICAnY2FsbGVkIGBlbmRTZXNzaW9uKClgIG9uIHRoZSBzZXNzaW9uIHlvdSBhcmUgcGFzc2luZyB0byBgJHNlc3Npb24oKWAuJyk7XG4gIH1cblxuICBpZiAoc2Vzc2lvbiA9PSBudWxsICYmIHRoaXMuJF9fLnNlc3Npb24gPT0gbnVsbCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHRoaXMuJF9fLnNlc3Npb24gPSBzZXNzaW9uO1xuXG4gIGlmICghdGhpcy4kaXNTdWJkb2N1bWVudCkge1xuICAgIGNvbnN0IHN1YmRvY3MgPSB0aGlzLiRnZXRBbGxTdWJkb2NzKCk7XG4gICAgZm9yIChjb25zdCBjaGlsZCBvZiBzdWJkb2NzKSB7XG4gICAgICBjaGlsZC4kc2Vzc2lvbihzZXNzaW9uKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gc2Vzc2lvbjtcbn07XG5cbi8qKlxuICogR2V0dGVyL3NldHRlciBhcm91bmQgd2hldGhlciB0aGlzIGRvY3VtZW50IHdpbGwgYXBwbHkgdGltZXN0YW1wcyBieVxuICogZGVmYXVsdCB3aGVuIHVzaW5nIGBzYXZlKClgIGFuZCBgYnVsa1NhdmUoKWAuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBjb25zdCBUZXN0TW9kZWwgPSBtb25nb29zZS5tb2RlbCgnVGVzdCcsIG5ldyBTY2hlbWEoeyBuYW1lOiBTdHJpbmcgfSwgeyB0aW1lc3RhbXBzOiB0cnVlIH0pKTtcbiAqICAgICBjb25zdCBkb2MgPSBuZXcgVGVzdE1vZGVsKHsgbmFtZTogJ0pvaG4gU21pdGgnIH0pO1xuICpcbiAqICAgICBkb2MuJHRpbWVzdGFtcHMoKTsgLy8gdHJ1ZVxuICpcbiAqICAgICBkb2MuJHRpbWVzdGFtcHMoZmFsc2UpO1xuICogICAgIGF3YWl0IGRvYy5zYXZlKCk7IC8vIERvZXMgKipub3QqKiBhcHBseSB0aW1lc3RhbXBzXG4gKlxuICogQHBhcmFtIHtCb29sZWFufSBbdmFsdWVdIG92ZXJ3cml0ZSB0aGUgY3VycmVudCBzZXNzaW9uXG4gKiBAcmV0dXJuIHtEb2N1bWVudHxib29sZWFufHVuZGVmaW5lZH0gV2hlbiB1c2VkIGFzIGEgZ2V0dGVyIChubyBhcmd1bWVudCksIGEgYm9vbGVhbiB3aWxsIGJlIHJldHVybmVkIGluZGljYXRpbmcgdGhlIHRpbWVzdGFtcHMgb3B0aW9uIHN0YXRlIG9yIGlmIHVuc2V0IFwidW5kZWZpbmVkXCIgd2lsbCBiZSB1c2VkLCBvdGhlcndpc2Ugd2lsbCByZXR1cm4gXCJ0aGlzXCJcbiAqIEBtZXRob2QgJHRpbWVzdGFtcHNcbiAqIEBhcGkgcHVibGljXG4gKiBAbWVtYmVyT2YgRG9jdW1lbnRcbiAqL1xuXG5Eb2N1bWVudC5wcm90b3R5cGUuJHRpbWVzdGFtcHMgPSBmdW5jdGlvbiAkdGltZXN0YW1wcyh2YWx1ZSkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgIGlmICh0aGlzLiRfXy50aW1lc3RhbXBzICE9IG51bGwpIHtcbiAgICAgIHJldHVybiB0aGlzLiRfXy50aW1lc3RhbXBzO1xuICAgIH1cblxuICAgIGlmICh0aGlzLiRfX3NjaGVtYSkge1xuICAgICAgcmV0dXJuIHRoaXMuJF9fc2NoZW1hLm9wdGlvbnMudGltZXN0YW1wcztcbiAgICB9XG5cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG5cbiAgY29uc3QgY3VycmVudFZhbHVlID0gdGhpcy4kdGltZXN0YW1wcygpO1xuICBpZiAodmFsdWUgIT09IGN1cnJlbnRWYWx1ZSkge1xuICAgIHRoaXMuJF9fLnRpbWVzdGFtcHMgPSB2YWx1ZTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBPdmVyd3JpdGUgYWxsIHZhbHVlcyBpbiB0aGlzIGRvY3VtZW50IHdpdGggdGhlIHZhbHVlcyBvZiBgb2JqYCwgZXhjZXB0XG4gKiBmb3IgaW1tdXRhYmxlIHByb3BlcnRpZXMuIEJlaGF2ZXMgc2ltaWxhcmx5IHRvIGBzZXQoKWAsIGV4Y2VwdCBmb3IgaXRcbiAqIHVuc2V0cyBhbGwgcHJvcGVydGllcyB0aGF0IGFyZW4ndCBpbiBgb2JqYC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqIHRoZSBvYmplY3QgdG8gb3ZlcndyaXRlIHRoaXMgZG9jdW1lbnQgd2l0aFxuICogQG1ldGhvZCBvdmVyd3JpdGVcbiAqIEBtZW1iZXJPZiBEb2N1bWVudFxuICogQGluc3RhbmNlXG4gKiBAYXBpIHB1YmxpY1xuICogQHJldHVybiB7RG9jdW1lbnR9IHRoaXNcbiAqL1xuXG5Eb2N1bWVudC5wcm90b3R5cGUub3ZlcndyaXRlID0gZnVuY3Rpb24gb3ZlcndyaXRlKG9iaikge1xuICBjb25zdCBrZXlzID0gQXJyYXkuZnJvbShuZXcgU2V0KE9iamVjdC5rZXlzKHRoaXMuX2RvYykuY29uY2F0KE9iamVjdC5rZXlzKG9iaikpKSk7XG5cbiAgZm9yIChjb25zdCBrZXkgb2Yga2V5cykge1xuICAgIGlmIChrZXkgPT09ICdfaWQnKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgLy8gRXhwbGljaXRseSBza2lwIHZlcnNpb24ga2V5XG4gICAgaWYgKHRoaXMuJF9fc2NoZW1hLm9wdGlvbnMudmVyc2lvbktleSAmJiBrZXkgPT09IHRoaXMuJF9fc2NoZW1hLm9wdGlvbnMudmVyc2lvbktleSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmICh0aGlzLiRfX3NjaGVtYS5vcHRpb25zLmRpc2NyaW1pbmF0b3JLZXkgJiYga2V5ID09PSB0aGlzLiRfX3NjaGVtYS5vcHRpb25zLmRpc2NyaW1pbmF0b3JLZXkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICB0aGlzLiRzZXQoa2V5LCBvYmpba2V5XSk7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQWxpYXMgZm9yIGBzZXQoKWAsIHVzZWQgaW50ZXJuYWxseSB0byBhdm9pZCBjb25mbGljdHNcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ3xPYmplY3R9IHBhdGggcGF0aCBvciBvYmplY3Qgb2Yga2V5L3ZhbHMgdG8gc2V0XG4gKiBAcGFyYW0ge0FueX0gdmFsIHRoZSB2YWx1ZSB0byBzZXRcbiAqIEBwYXJhbSB7U2NoZW1hfFN0cmluZ3xOdW1iZXJ8QnVmZmVyfCp9IFt0eXBlXSBvcHRpb25hbGx5IHNwZWNpZnkgYSB0eXBlIGZvciBcIm9uLXRoZS1mbHlcIiBhdHRyaWJ1dGVzXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIG9wdGlvbmFsbHkgc3BlY2lmeSBvcHRpb25zIHRoYXQgbW9kaWZ5IHRoZSBiZWhhdmlvciBvZiB0aGUgc2V0XG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLm1lcmdlPWZhbHNlXSBpZiB0cnVlLCBzZXR0aW5nIGEgW25lc3RlZCBwYXRoXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3Mvc3ViZG9jcy5odG1sI3N1YmRvY3VtZW50cy12ZXJzdXMtbmVzdGVkLXBhdGhzKSB3aWxsIG1lcmdlIGV4aXN0aW5nIHZhbHVlcyByYXRoZXIgdGhhbiBvdmVyd3JpdGUgdGhlIHdob2xlIG9iamVjdC4gU28gYGRvYy5zZXQoJ25lc3RlZCcsIHsgYTogMSwgYjogMiB9KWAgYmVjb21lcyBgZG9jLnNldCgnbmVzdGVkLmEnLCAxKTsgZG9jLnNldCgnbmVzdGVkLmInLCAyKTtgXG4gKiBAcmV0dXJuIHtEb2N1bWVudH0gdGhpc1xuICogQG1ldGhvZCAkc2V0XG4gKiBAbWVtYmVyT2YgRG9jdW1lbnRcbiAqIEBpbnN0YW5jZVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Eb2N1bWVudC5wcm90b3R5cGUuJHNldCA9IGZ1bmN0aW9uICRzZXQocGF0aCwgdmFsLCB0eXBlLCBvcHRpb25zKSB7XG4gIGlmICh1dGlscy5pc1BPSk8odHlwZSkpIHtcbiAgICBvcHRpb25zID0gdHlwZTtcbiAgICB0eXBlID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgY29uc3QgbWVyZ2UgPSBvcHRpb25zICYmIG9wdGlvbnMubWVyZ2U7XG4gIGNvbnN0IGFkaG9jID0gdHlwZSAmJiB0eXBlICE9PSB0cnVlO1xuICBjb25zdCBjb25zdHJ1Y3RpbmcgPSB0eXBlID09PSB0cnVlO1xuICBsZXQgYWRob2NzO1xuICBsZXQga2V5cztcbiAgbGV0IGkgPSAwO1xuICBsZXQgcGF0aHR5cGU7XG4gIGxldCBrZXk7XG4gIGxldCBwcmVmaXg7XG5cbiAgY29uc3QgdXNlclNwZWNpZmllZFN0cmljdCA9IG9wdGlvbnMgJiYgJ3N0cmljdCcgaW4gb3B0aW9ucztcbiAgbGV0IHN0cmljdCA9IHVzZXJTcGVjaWZpZWRTdHJpY3RcbiAgICA/IG9wdGlvbnMuc3RyaWN0XG4gICAgOiB0aGlzLiRfXy5zdHJpY3RNb2RlO1xuXG4gIGlmIChhZGhvYykge1xuICAgIGFkaG9jcyA9IHRoaXMuJF9fLmFkaG9jUGF0aHMgfHwgKHRoaXMuJF9fLmFkaG9jUGF0aHMgPSB7fSk7XG4gICAgYWRob2NzW3BhdGhdID0gdGhpcy4kX19zY2hlbWEuaW50ZXJwcmV0QXNUeXBlKHBhdGgsIHR5cGUsIHRoaXMuJF9fc2NoZW1hLm9wdGlvbnMpO1xuICB9XG5cbiAgaWYgKHBhdGggPT0gbnVsbCkge1xuICAgIFtwYXRoLCB2YWxdID0gW3ZhbCwgcGF0aF07XG4gIH0gZWxzZSBpZiAodHlwZW9mIHBhdGggIT09ICdzdHJpbmcnKSB7XG4gICAgLy8gbmV3IERvY3VtZW50KHsga2V5OiB2YWwgfSlcbiAgICBpZiAocGF0aCBpbnN0YW5jZW9mIERvY3VtZW50KSB7XG4gICAgICBpZiAocGF0aC4kX19pc05lc3RlZCkge1xuICAgICAgICBwYXRoID0gcGF0aC50b09iamVjdCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGF0aCA9IHBhdGguX2RvYztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHBhdGggPT0gbnVsbCkge1xuICAgICAgW3BhdGgsIHZhbF0gPSBbdmFsLCBwYXRoXTtcbiAgICB9XG5cbiAgICBwcmVmaXggPSB2YWwgPyB2YWwgKyAnLicgOiAnJztcbiAgICBrZXlzID0gZ2V0S2V5c0luU2NoZW1hT3JkZXIodGhpcy4kX19zY2hlbWEsIHBhdGgpO1xuXG4gICAgY29uc3QgbGVuID0ga2V5cy5sZW5ndGg7XG5cbiAgICAvLyBgX3NraXBNaW5pbWl6ZVRvcExldmVsYCBpcyBiZWNhdXNlIHdlIG1heSBoYXZlIGRlbGV0ZWQgdGhlIHRvcC1sZXZlbFxuICAgIC8vIG5lc3RlZCBrZXkgdG8gZW5zdXJlIGtleSBvcmRlci5cbiAgICBjb25zdCBfc2tpcE1pbmltaXplVG9wTGV2ZWwgPSBvcHRpb25zICYmIG9wdGlvbnMuX3NraXBNaW5pbWl6ZVRvcExldmVsIHx8IGZhbHNlO1xuICAgIGlmIChsZW4gPT09IDAgJiYgX3NraXBNaW5pbWl6ZVRvcExldmVsKSB7XG4gICAgICBkZWxldGUgb3B0aW9ucy5fc2tpcE1pbmltaXplVG9wTGV2ZWw7XG4gICAgICBpZiAodmFsKSB7XG4gICAgICAgIHRoaXMuJHNldCh2YWwsIHt9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zLCB7IF9za2lwTWluaW1pemVUb3BMZXZlbDogZmFsc2UgfSk7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICBrZXkgPSBrZXlzW2ldO1xuICAgICAgY29uc3QgcGF0aE5hbWUgPSBwcmVmaXggPyBwcmVmaXggKyBrZXkgOiBrZXk7XG4gICAgICBwYXRodHlwZSA9IHRoaXMuJF9fc2NoZW1hLnBhdGhUeXBlKHBhdGhOYW1lKTtcbiAgICAgIGNvbnN0IHZhbEZvcktleSA9IHBhdGhba2V5XTtcblxuICAgICAgLy8gT24gaW5pdGlhbCBzZXQsIGRlbGV0ZSBhbnkgbmVzdGVkIGtleXMgaWYgd2UncmUgZ29pbmcgdG8gb3ZlcndyaXRlXG4gICAgICAvLyB0aGVtIHRvIGVuc3VyZSB3ZSBrZWVwIHRoZSB1c2VyJ3Mga2V5IG9yZGVyLlxuICAgICAgaWYgKHR5cGUgPT09IHRydWUgJiZcbiAgICAgICAgICAhcHJlZml4ICYmXG4gICAgICAgICAgdmFsRm9yS2V5ICE9IG51bGwgJiZcbiAgICAgICAgICBwYXRodHlwZSA9PT0gJ25lc3RlZCcgJiZcbiAgICAgICAgICB0aGlzLl9kb2Nba2V5XSAhPSBudWxsKSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzLl9kb2Nba2V5XTtcbiAgICAgIH1cblxuICAgICAgaWYgKHV0aWxzLmlzTm9uQnVpbHRpbk9iamVjdCh2YWxGb3JLZXkpICYmIHBhdGh0eXBlID09PSAnbmVzdGVkJykge1xuICAgICAgICB0aGlzLiRzZXQocGF0aE5hbWUsIHZhbEZvcktleSwgY29uc3RydWN0aW5nLCBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zLCB7IF9za2lwTWFya01vZGlmaWVkOiB0cnVlIH0pKTtcbiAgICAgICAgJGFwcGx5RGVmYXVsdHNUb05lc3RlZCh0aGlzLiRnZXQocGF0aE5hbWUpLCBwYXRoTmFtZSwgdGhpcyk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfSBlbHNlIGlmIChzdHJpY3QpIHtcbiAgICAgICAgLy8gRG9uJ3Qgb3ZlcndyaXRlIGRlZmF1bHRzIHdpdGggdW5kZWZpbmVkIGtleXMgKGdoLTM5ODEpIChnaC05MDM5KVxuICAgICAgICBpZiAoY29uc3RydWN0aW5nICYmIHZhbEZvcktleSA9PT0gdm9pZCAwICYmXG4gICAgICAgICAgICB0aGlzLiRnZXQocGF0aE5hbWUpICE9PSB2b2lkIDApIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwYXRodHlwZSA9PT0gJ2FkaG9jT3JVbmRlZmluZWQnKSB7XG4gICAgICAgICAgcGF0aHR5cGUgPSBnZXRFbWJlZGRlZERpc2NyaW1pbmF0b3JQYXRoKHRoaXMsIHBhdGhOYW1lLCB7IHR5cGVPbmx5OiB0cnVlIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHBhdGh0eXBlID09PSAncmVhbCcgfHwgcGF0aHR5cGUgPT09ICd2aXJ0dWFsJykge1xuICAgICAgICAgIHRoaXMuJHNldChwYXRoTmFtZSwgdmFsRm9yS2V5LCBjb25zdHJ1Y3RpbmcsIG9wdGlvbnMpO1xuICAgICAgICB9IGVsc2UgaWYgKHBhdGh0eXBlID09PSAnbmVzdGVkJyAmJiB2YWxGb3JLZXkgaW5zdGFuY2VvZiBEb2N1bWVudCkge1xuICAgICAgICAgIHRoaXMuJHNldChwYXRoTmFtZSxcbiAgICAgICAgICAgIHZhbEZvcktleS50b09iamVjdCh7IHRyYW5zZm9ybTogZmFsc2UgfSksIGNvbnN0cnVjdGluZywgb3B0aW9ucyk7XG4gICAgICAgIH0gZWxzZSBpZiAoc3RyaWN0ID09PSAndGhyb3cnKSB7XG4gICAgICAgICAgaWYgKHBhdGh0eXBlID09PSAnbmVzdGVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IE9iamVjdEV4cGVjdGVkRXJyb3Ioa2V5LCB2YWxGb3JLZXkpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgU3RyaWN0TW9kZUVycm9yKGtleSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHBhdGh0eXBlID09PSAnbmVzdGVkJyAmJiB2YWxGb3JLZXkgPT0gbnVsbCkge1xuICAgICAgICAgIHRoaXMuJHNldChwYXRoTmFtZSwgdmFsRm9yS2V5LCBjb25zdHJ1Y3RpbmcsIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHZhbEZvcktleSAhPT0gdm9pZCAwKSB7XG4gICAgICAgIHRoaXMuJHNldChwYXRoTmFtZSwgdmFsRm9yS2V5LCBjb25zdHJ1Y3RpbmcsIG9wdGlvbnMpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEVuc3VyZSBhbGwgcHJvcGVydGllcyBhcmUgaW4gY29ycmVjdCBvcmRlclxuICAgIGNvbnN0IG9yZGVyZWREb2MgPSB7fTtcbiAgICBjb25zdCBvcmRlcmVkS2V5cyA9IE9iamVjdC5rZXlzKHRoaXMuJF9fc2NoZW1hLnRyZWUpO1xuICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSBvcmRlcmVkS2V5cy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgICAgKGtleSA9IG9yZGVyZWRLZXlzW2ldKSAmJlxuICAgICAgKHRoaXMuX2RvYy5oYXNPd25Qcm9wZXJ0eShrZXkpKSAmJlxuICAgICAgKG9yZGVyZWREb2Nba2V5XSA9IHVuZGVmaW5lZCk7XG4gICAgfVxuICAgIHRoaXMuX2RvYyA9IE9iamVjdC5hc3NpZ24ob3JkZXJlZERvYywgdGhpcy5fZG9jKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgbGV0IHBhdGhUeXBlID0gdGhpcy4kX19zY2hlbWEucGF0aFR5cGUocGF0aCk7XG4gIGxldCBwYXJ0cyA9IG51bGw7XG4gIGlmIChwYXRoVHlwZSA9PT0gJ2FkaG9jT3JVbmRlZmluZWQnKSB7XG4gICAgcGFydHMgPSBwYXRoLmluZGV4T2YoJy4nKSA9PT0gLTEgPyBbcGF0aF0gOiBwYXRoLnNwbGl0KCcuJyk7XG4gICAgcGF0aFR5cGUgPSBnZXRFbWJlZGRlZERpc2NyaW1pbmF0b3JQYXRoKHRoaXMsIHBhcnRzLCB7IHR5cGVPbmx5OiB0cnVlIH0pO1xuICB9XG4gIGlmIChwYXRoVHlwZSA9PT0gJ2FkaG9jT3JVbmRlZmluZWQnICYmICF1c2VyU3BlY2lmaWVkU3RyaWN0KSB7XG4gICAgLy8gTWF5IGJlIHBhdGggdW5kZXJuZWF0aCBub24tc3RyaWN0IHNjaGVtYVxuICAgIGlmIChwYXJ0cyA9PSBudWxsKSB7XG4gICAgICBwYXJ0cyA9IHBhdGguaW5kZXhPZignLicpID09PSAtMSA/IFtwYXRoXSA6IHBhdGguc3BsaXQoJy4nKTtcbiAgICB9XG4gICAgY29uc3Qgc3ViZG9jU3RyaWN0ID0gZ2V0U3ViZG9jdW1lbnRTdHJpY3RWYWx1ZSh0aGlzLiRfX3NjaGVtYSwgcGFydHMpO1xuICAgIGlmIChzdWJkb2NTdHJpY3QgIT09IHVuZGVmaW5lZCkge1xuICAgICAgc3RyaWN0ID0gc3ViZG9jU3RyaWN0O1xuICAgIH1cbiAgfVxuXG4gIC8vIEFzc3VtZSB0aGlzIGlzIGEgTW9uZ29vc2UgZG9jdW1lbnQgdGhhdCB3YXMgY29waWVkIGludG8gYSBQT0pPIHVzaW5nXG4gIC8vIGBPYmplY3QuYXNzaWduKClgIG9yIGB7Li4uZG9jfWBcbiAgdmFsID0gaGFuZGxlU3ByZWFkRG9jKHZhbCwgdHJ1ZSk7XG5cbiAgLy8gaWYgdGhpcyBkb2MgaXMgYmVpbmcgY29uc3RydWN0ZWQgd2Ugc2hvdWxkIG5vdCB0cmlnZ2VyIGdldHRlcnNcbiAgY29uc3QgcHJpb3JWYWwgPSAoKCkgPT4ge1xuICAgIGlmICh0aGlzLiRfXy5wcmlvckRvYyAhPSBudWxsKSB7XG4gICAgICByZXR1cm4gdGhpcy4kX18ucHJpb3JEb2MuJF9fZ2V0VmFsdWUocGF0aCk7XG4gICAgfVxuICAgIGlmIChjb25zdHJ1Y3RpbmcpIHtcbiAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLiRfX2dldFZhbHVlKHBhdGgpO1xuICB9KSgpO1xuXG4gIGlmIChwYXRoVHlwZSA9PT0gJ25lc3RlZCcgJiYgdmFsKSB7XG4gICAgaWYgKHR5cGVvZiB2YWwgPT09ICdvYmplY3QnICYmIHZhbCAhPSBudWxsKSB7XG4gICAgICBpZiAodmFsLiRfXyAhPSBudWxsKSB7XG4gICAgICAgIHZhbCA9IHZhbC50b09iamVjdChpbnRlcm5hbFRvT2JqZWN0T3B0aW9ucyk7XG4gICAgICB9XG4gICAgICBpZiAodmFsID09IG51bGwpIHtcbiAgICAgICAgdGhpcy5pbnZhbGlkYXRlKHBhdGgsIG5ldyBNb25nb29zZUVycm9yLkNhc3RFcnJvcignT2JqZWN0JywgdmFsLCBwYXRoKSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgICAgY29uc3Qgd2FzTW9kaWZpZWQgPSB0aGlzLiRpc01vZGlmaWVkKHBhdGgpO1xuICAgICAgY29uc3QgaGFzSW5pdGlhbFZhbCA9IHRoaXMuJF9fLnNhdmVkU3RhdGUgIT0gbnVsbCAmJiB0aGlzLiRfXy5zYXZlZFN0YXRlLmhhc093blByb3BlcnR5KHBhdGgpO1xuICAgICAgaWYgKHRoaXMuJF9fLnNhdmVkU3RhdGUgIT0gbnVsbCAmJiAhdGhpcy4kaXNOZXcgJiYgIXRoaXMuJF9fLnNhdmVkU3RhdGUuaGFzT3duUHJvcGVydHkocGF0aCkpIHtcbiAgICAgICAgY29uc3QgaW5pdGlhbFZhbCA9IHRoaXMuJF9fZ2V0VmFsdWUocGF0aCk7XG4gICAgICAgIHRoaXMuJF9fLnNhdmVkU3RhdGVbcGF0aF0gPSBpbml0aWFsVmFsO1xuXG4gICAgICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhpbml0aWFsVmFsIHx8IHt9KTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgb2Yga2V5cykge1xuICAgICAgICAgIHRoaXMuJF9fLnNhdmVkU3RhdGVbcGF0aCArICcuJyArIGtleV0gPSBpbml0aWFsVmFsW2tleV07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKCFtZXJnZSkge1xuICAgICAgICB0aGlzLiRfX3NldFZhbHVlKHBhdGgsIG51bGwpO1xuICAgICAgICBjbGVhbk1vZGlmaWVkU3VicGF0aHModGhpcywgcGF0aCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy4kc2V0KHZhbCwgcGF0aCwgY29uc3RydWN0aW5nKTtcbiAgICAgIH1cblxuICAgICAgY29uc3Qga2V5cyA9IGdldEtleXNJblNjaGVtYU9yZGVyKHRoaXMuJF9fc2NoZW1hLCB2YWwsIHBhdGgpO1xuXG4gICAgICB0aGlzLiRfX3NldFZhbHVlKHBhdGgsIHt9KTtcbiAgICAgIGZvciAoY29uc3Qga2V5IG9mIGtleXMpIHtcbiAgICAgICAgdGhpcy4kc2V0KHBhdGggKyAnLicgKyBrZXksIHZhbFtrZXldLCBjb25zdHJ1Y3RpbmcsIHsgLi4ub3B0aW9ucywgX3NraXBNYXJrTW9kaWZpZWQ6IHRydWUgfSk7XG4gICAgICB9XG4gICAgICBpZiAocHJpb3JWYWwgIT0gbnVsbCAmJlxuICAgICAgICAgICghd2FzTW9kaWZpZWQgfHwgaGFzSW5pdGlhbFZhbCkgJiZcbiAgICAgICAgICB1dGlscy5kZWVwRXF1YWwoaGFzSW5pdGlhbFZhbCA/IHRoaXMuJF9fLnNhdmVkU3RhdGVbcGF0aF0gOiBwcmlvclZhbCwgdmFsKSkge1xuICAgICAgICB0aGlzLnVubWFya01vZGlmaWVkKHBhdGgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5tYXJrTW9kaWZpZWQocGF0aCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgdGhpcy5pbnZhbGlkYXRlKHBhdGgsIG5ldyBNb25nb29zZUVycm9yLkNhc3RFcnJvcignT2JqZWN0JywgdmFsLCBwYXRoKSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBsZXQgc2NoZW1hO1xuICBpZiAocGFydHMgPT0gbnVsbCkge1xuICAgIHBhcnRzID0gcGF0aC5pbmRleE9mKCcuJykgPT09IC0xID8gW3BhdGhdIDogcGF0aC5zcGxpdCgnLicpO1xuICB9XG5cbiAgLy8gTWlnaHQgbmVlZCB0byBjaGFuZ2UgcGF0aCBmb3IgdG9wLWxldmVsIGFsaWFzXG4gIGlmICh0eXBlb2YgdGhpcy4kX19zY2hlbWEuYWxpYXNlc1twYXJ0c1swXV0gPT09ICdzdHJpbmcnKSB7XG4gICAgcGFydHNbMF0gPSB0aGlzLiRfX3NjaGVtYS5hbGlhc2VzW3BhcnRzWzBdXTtcbiAgfVxuXG4gIGlmIChwYXRoVHlwZSA9PT0gJ2FkaG9jT3JVbmRlZmluZWQnICYmIHN0cmljdCkge1xuICAgIC8vIGNoZWNrIGZvciByb290cyB0aGF0IGFyZSBNaXhlZCB0eXBlc1xuICAgIGxldCBtaXhlZDtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBwYXJ0cy5sZW5ndGg7ICsraSkge1xuICAgICAgY29uc3Qgc3VicGF0aCA9IHBhcnRzLnNsaWNlKDAsIGkgKyAxKS5qb2luKCcuJyk7XG5cbiAgICAgIC8vIElmIHBhdGggaXMgdW5kZXJuZWF0aCBhIHZpcnR1YWwsIGJ5cGFzcyBldmVyeXRoaW5nIGFuZCBqdXN0IHNldCBpdC5cbiAgICAgIGlmIChpICsgMSA8IHBhcnRzLmxlbmd0aCAmJiB0aGlzLiRfX3NjaGVtYS5wYXRoVHlwZShzdWJwYXRoKSA9PT0gJ3ZpcnR1YWwnKSB7XG4gICAgICAgIG1wYXRoLnNldChwYXRoLCB2YWwsIHRoaXMpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgc2NoZW1hID0gdGhpcy4kX19zY2hlbWEucGF0aChzdWJwYXRoKTtcbiAgICAgIGlmIChzY2hlbWEgPT0gbnVsbCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHNjaGVtYSBpbnN0YW5jZW9mIE1peGVkU2NoZW1hKSB7XG4gICAgICAgIC8vIGFsbG93IGNoYW5nZXMgdG8gc3ViIHBhdGhzIG9mIG1peGVkIHR5cGVzXG4gICAgICAgIG1peGVkID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9IGVsc2UgaWYgKHNjaGVtYS4kaXNTY2hlbWFNYXAgJiYgc2NoZW1hLiRfX3NjaGVtYVR5cGUgaW5zdGFuY2VvZiBNaXhlZFNjaGVtYSAmJiBpIDwgcGFydHMubGVuZ3RoIC0gMSkge1xuICAgICAgICAvLyBNYXAgb2YgbWl4ZWQgYW5kIG5vdCB0aGUgbGFzdCBlbGVtZW50IGluIHRoZSBwYXRoIHJlc29sdmVzIHRvIG1peGVkXG4gICAgICAgIG1peGVkID0gdHJ1ZTtcbiAgICAgICAgc2NoZW1hID0gc2NoZW1hLiRfX3NjaGVtYVR5cGU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChzY2hlbWEgPT0gbnVsbCkge1xuICAgICAgLy8gQ2hlY2sgZm9yIGVtYmVkZGVkIGRpc2NyaW1pbmF0b3JzXG4gICAgICBzY2hlbWEgPSBnZXRFbWJlZGRlZERpc2NyaW1pbmF0b3JQYXRoKHRoaXMsIHBhdGgpO1xuICAgIH1cblxuICAgIGlmICghbWl4ZWQgJiYgIXNjaGVtYSkge1xuICAgICAgaWYgKHN0cmljdCA9PT0gJ3Rocm93Jykge1xuICAgICAgICB0aHJvdyBuZXcgU3RyaWN0TW9kZUVycm9yKHBhdGgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9IGVsc2UgaWYgKHBhdGhUeXBlID09PSAndmlydHVhbCcpIHtcbiAgICBzY2hlbWEgPSB0aGlzLiRfX3NjaGVtYS52aXJ0dWFscGF0aChwYXRoKTtcbiAgICBzY2hlbWEuYXBwbHlTZXR0ZXJzKHZhbCwgdGhpcyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0gZWxzZSB7XG4gICAgc2NoZW1hID0gdGhpcy4kX19wYXRoKHBhdGgpO1xuICB9XG5cbiAgLy8gZ2gtNDU3OCwgaWYgc2V0dGluZyBhIGRlZXBseSBuZXN0ZWQgcGF0aCB0aGF0IGRvZXNuJ3QgZXhpc3QgeWV0LCBjcmVhdGUgaXRcbiAgbGV0IGN1ciA9IHRoaXMuX2RvYztcbiAgbGV0IGN1clBhdGggPSAnJztcbiAgZm9yIChpID0gMDsgaSA8IHBhcnRzLmxlbmd0aCAtIDE7ICsraSkge1xuICAgIGN1ciA9IGN1cltwYXJ0c1tpXV07XG4gICAgY3VyUGF0aCArPSAoY3VyUGF0aC5sZW5ndGggIT09IDAgPyAnLicgOiAnJykgKyBwYXJ0c1tpXTtcbiAgICBpZiAoIWN1cikge1xuICAgICAgdGhpcy4kc2V0KGN1clBhdGgsIHt9KTtcbiAgICAgIC8vIEhhY2sgcmU6IGdoLTU4MDAuIElmIG5lc3RlZCBmaWVsZCBpcyBub3Qgc2VsZWN0ZWQsIGl0IHByb2JhYmx5IGV4aXN0c1xuICAgICAgLy8gc28gYE1vbmdvU2VydmVyRXJyb3I6IGNhbm5vdCB1c2UgdGhlIHBhcnQgKG5lc3RlZCBvZiBuZXN0ZWQubnVtKSB0b1xuICAgICAgLy8gdHJhdmVyc2UgdGhlIGVsZW1lbnQgKHtuZXN0ZWQ6IG51bGx9KWAgaXMgbm90IGxpa2VseS4gSWYgdXNlciBnZXRzXG4gICAgICAvLyB0aGF0IGVycm9yLCBpdHMgdGhlaXIgZmF1bHQgZm9yIG5vdy4gV2Ugc2hvdWxkIHJlY29uc2lkZXIgZGlzYWxsb3dpbmdcbiAgICAgIC8vIG1vZGlmeWluZyBub3Qgc2VsZWN0ZWQgcGF0aHMgZm9yIDYueFxuICAgICAgaWYgKCF0aGlzLiRfX2lzU2VsZWN0ZWQoY3VyUGF0aCkpIHtcbiAgICAgICAgdGhpcy51bm1hcmtNb2RpZmllZChjdXJQYXRoKTtcbiAgICAgIH1cbiAgICAgIGN1ciA9IHRoaXMuJF9fZ2V0VmFsdWUoY3VyUGF0aCk7XG4gICAgfVxuICB9XG5cbiAgbGV0IHBhdGhUb01hcms7XG5cbiAgLy8gV2hlbiB1c2luZyB0aGUgJHNldCBvcGVyYXRvciB0aGUgcGF0aCB0byB0aGUgZmllbGQgbXVzdCBhbHJlYWR5IGV4aXN0LlxuICAvLyBFbHNlIG1vbmdvZGIgdGhyb3dzOiBcIkxFRlRfU1VCRklFTEQgb25seSBzdXBwb3J0cyBPYmplY3RcIlxuXG4gIGlmIChwYXJ0cy5sZW5ndGggPD0gMSkge1xuICAgIHBhdGhUb01hcmsgPSBwYXRoO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IGxlbiA9IHBhcnRzLmxlbmd0aDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgIGNvbnN0IHN1YnBhdGggPSBwYXJ0cy5zbGljZSgwLCBpICsgMSkuam9pbignLicpO1xuICAgICAgaWYgKHRoaXMuJGdldChzdWJwYXRoLCBudWxsLCB7IGdldHRlcnM6IGZhbHNlIH0pID09PSBudWxsKSB7XG4gICAgICAgIHBhdGhUb01hcmsgPSBzdWJwYXRoO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIXBhdGhUb01hcmspIHtcbiAgICAgIHBhdGhUb01hcmsgPSBwYXRoO1xuICAgIH1cbiAgfVxuXG4gIGlmICghc2NoZW1hKSB7XG4gICAgdGhpcy4kX19zZXQocGF0aFRvTWFyaywgcGF0aCwgb3B0aW9ucywgY29uc3RydWN0aW5nLCBwYXJ0cywgc2NoZW1hLCB2YWwsIHByaW9yVmFsKTtcblxuICAgIGlmIChwYXRoVHlwZSA9PT0gJ25lc3RlZCcgJiYgdmFsID09IG51bGwpIHtcbiAgICAgIGNsZWFuTW9kaWZpZWRTdWJwYXRocyh0aGlzLCBwYXRoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyBJZiBvdmVyd3JpdGluZyBhIHN1YmRvY3VtZW50IHBhdGgsIG1ha2Ugc3VyZSB0byBjbGVhciBvdXRcbiAgLy8gYW55IGVycm9ycyBfYmVmb3JlXyBzZXR0aW5nLCBzbyBuZXcgZXJyb3JzIHRoYXQgaGFwcGVuXG4gIC8vIGdldCBwZXJzaXN0ZWQuIFJlOiAjOTA4MFxuICBpZiAoc2NoZW1hLiRpc1NpbmdsZU5lc3RlZCB8fCBzY2hlbWEuJGlzTW9uZ29vc2VBcnJheSkge1xuICAgIF9tYXJrVmFsaWRTdWJwYXRocyh0aGlzLCBwYXRoKTtcbiAgfVxuXG4gIGlmICh2YWwgIT0gbnVsbCAmJiBtZXJnZSAmJiBzY2hlbWEuJGlzU2luZ2xlTmVzdGVkKSB7XG4gICAgaWYgKHZhbCBpbnN0YW5jZW9mIERvY3VtZW50KSB7XG4gICAgICB2YWwgPSB2YWwudG9PYmplY3QoeyB2aXJ0dWFsczogZmFsc2UsIHRyYW5zZm9ybTogZmFsc2UgfSk7XG4gICAgfVxuICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyh2YWwpO1xuICAgIGZvciAoY29uc3Qga2V5IG9mIGtleXMpIHtcbiAgICAgIHRoaXMuJHNldChwYXRoICsgJy4nICsga2V5LCB2YWxba2V5XSwgY29uc3RydWN0aW5nLCBvcHRpb25zKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGxldCBzaG91bGRTZXQgPSB0cnVlO1xuICB0cnkge1xuICAgIC8vIElmIHRoZSB1c2VyIGlzIHRyeWluZyB0byBzZXQgYSByZWYgcGF0aCB0byBhIGRvY3VtZW50IHdpdGhcbiAgICAvLyB0aGUgY29ycmVjdCBtb2RlbCBuYW1lLCB0cmVhdCBpdCBhcyBwb3B1bGF0ZWRcbiAgICBjb25zdCByZWZNYXRjaGVzID0gKCgpID0+IHtcbiAgICAgIGlmIChzY2hlbWEub3B0aW9ucyA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmICghKHZhbCBpbnN0YW5jZW9mIERvY3VtZW50KSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBjb25zdCBtb2RlbCA9IHZhbC5jb25zdHJ1Y3RvcjtcblxuICAgICAgLy8gQ2hlY2sgcmVmXG4gICAgICBjb25zdCByZWYgPSBzY2hlbWEub3B0aW9ucy5yZWY7XG4gICAgICBpZiAocmVmICE9IG51bGwgJiYgKHJlZiA9PT0gbW9kZWwubW9kZWxOYW1lIHx8IHJlZiA9PT0gbW9kZWwuYmFzZU1vZGVsTmFtZSkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIC8vIENoZWNrIHJlZlBhdGhcbiAgICAgIGNvbnN0IHJlZlBhdGggPSBzY2hlbWEub3B0aW9ucy5yZWZQYXRoO1xuICAgICAgaWYgKHJlZlBhdGggPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBjb25zdCBtb2RlbE5hbWUgPSB2YWwuZ2V0KHJlZlBhdGgpO1xuICAgICAgcmV0dXJuIG1vZGVsTmFtZSA9PT0gbW9kZWwubW9kZWxOYW1lIHx8IG1vZGVsTmFtZSA9PT0gbW9kZWwuYmFzZU1vZGVsTmFtZTtcbiAgICB9KSgpO1xuXG4gICAgbGV0IGRpZFBvcHVsYXRlID0gZmFsc2U7XG4gICAgaWYgKHJlZk1hdGNoZXMgJiYgdmFsIGluc3RhbmNlb2YgRG9jdW1lbnQgJiYgKCF2YWwuJF9fLndhc1BvcHVsYXRlZCB8fCB1dGlscy5kZWVwRXF1YWwodmFsLiRfXy53YXNQb3B1bGF0ZWQudmFsdWUsIHZhbC5faWQpKSkge1xuICAgICAgY29uc3QgdW5wb3B1bGF0ZWRWYWx1ZSA9IChzY2hlbWEgJiYgc2NoZW1hLiRpc1NpbmdsZU5lc3RlZCkgPyBzY2hlbWEuY2FzdCh2YWwsIHRoaXMpIDogdmFsLl9pZDtcbiAgICAgIHRoaXMuJHBvcHVsYXRlZChwYXRoLCB1bnBvcHVsYXRlZFZhbHVlLCB7IFtwb3B1bGF0ZU1vZGVsU3ltYm9sXTogdmFsLmNvbnN0cnVjdG9yIH0pO1xuICAgICAgdmFsLiRfXy53YXNQb3B1bGF0ZWQgPSB7IHZhbHVlOiB1bnBvcHVsYXRlZFZhbHVlIH07XG4gICAgICBkaWRQb3B1bGF0ZSA9IHRydWU7XG4gICAgfVxuXG4gICAgbGV0IHBvcE9wdHM7XG4gICAgY29uc3QgdHlwZUtleSA9IHRoaXMuJF9fc2NoZW1hLm9wdGlvbnMudHlwZUtleTtcbiAgICBpZiAoc2NoZW1hLm9wdGlvbnMgJiZcbiAgICAgICAgQXJyYXkuaXNBcnJheShzY2hlbWEub3B0aW9uc1t0eXBlS2V5XSkgJiZcbiAgICAgICAgc2NoZW1hLm9wdGlvbnNbdHlwZUtleV0ubGVuZ3RoICYmXG4gICAgICAgIHNjaGVtYS5vcHRpb25zW3R5cGVLZXldWzBdLnJlZiAmJlxuICAgICAgICBfaXNNYW51YWxseVBvcHVsYXRlZEFycmF5KHZhbCwgc2NoZW1hLm9wdGlvbnNbdHlwZUtleV1bMF0ucmVmKSkge1xuICAgICAgcG9wT3B0cyA9IHsgW3BvcHVsYXRlTW9kZWxTeW1ib2xdOiB2YWxbMF0uY29uc3RydWN0b3IgfTtcbiAgICAgIHRoaXMuJHBvcHVsYXRlZChwYXRoLCB2YWwubWFwKGZ1bmN0aW9uKHYpIHsgcmV0dXJuIHYuX2lkOyB9KSwgcG9wT3B0cyk7XG5cbiAgICAgIGZvciAoY29uc3QgZG9jIG9mIHZhbCkge1xuICAgICAgICBkb2MuJF9fLndhc1BvcHVsYXRlZCA9IHsgdmFsdWU6IGRvYy5faWQgfTtcbiAgICAgIH1cbiAgICAgIGRpZFBvcHVsYXRlID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAoIXJlZk1hdGNoZXMgfHwgIXNjaGVtYS4kaXNTaW5nbGVOZXN0ZWQgfHwgIXZhbC4kX18pIHtcbiAgICAgIC8vIElmIHRoaXMgcGF0aCBpcyB1bmRlcm5lYXRoIGEgc2luZ2xlIG5lc3RlZCBzY2hlbWEsIHdlJ2xsIGNhbGwgdGhlIHNldHRlclxuICAgICAgLy8gbGF0ZXIgaW4gYCRfX3NldCgpYCBiZWNhdXNlIHdlIGRvbid0IHRha2UgYF9kb2NgIHdoZW4gd2UgaXRlcmF0ZSB0aHJvdWdoXG4gICAgICAvLyBhIHNpbmdsZSBuZXN0ZWQgZG9jLiBUaGF0J3MgdG8gbWFrZSBzdXJlIHdlIGdldCB0aGUgY29ycmVjdCBjb250ZXh0LlxuICAgICAgLy8gT3RoZXJ3aXNlIHdlIHdvdWxkIGRvdWJsZS1jYWxsIHRoZSBzZXR0ZXIsIHNlZSBnaC03MTk2LlxuICAgICAgbGV0IHNldHRlckNvbnRleHQgPSB0aGlzO1xuICAgICAgaWYgKHRoaXMuJF9fc2NoZW1hLnNpbmdsZU5lc3RlZFBhdGhzW3BhdGhdICE9IG51bGwgJiYgcGFydHMubGVuZ3RoID4gMSkge1xuICAgICAgICBzZXR0ZXJDb250ZXh0ID0gZ2V0RGVlcGVzdFN1YmRvY3VtZW50Rm9yUGF0aCh0aGlzLCBwYXJ0cywgdGhpcy5zY2hlbWEpO1xuICAgICAgfVxuICAgICAgaWYgKG9wdGlvbnMgIT0gbnVsbCAmJiBvcHRpb25zLm92ZXJ3cml0ZUltbXV0YWJsZSkge1xuICAgICAgICB2YWwgPSBzY2hlbWEuYXBwbHlTZXR0ZXJzKHZhbCwgc2V0dGVyQ29udGV4dCwgZmFsc2UsIHByaW9yVmFsLCB7IG92ZXJ3cml0ZUltbXV0YWJsZTogdHJ1ZSB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhbCA9IHNjaGVtYS5hcHBseVNldHRlcnModmFsLCBzZXR0ZXJDb250ZXh0LCBmYWxzZSwgcHJpb3JWYWwpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbCkgJiZcbiAgICAgICAgIUFycmF5LmlzQXJyYXkoc2NoZW1hKSAmJlxuICAgICAgICBzY2hlbWEuJGlzTW9uZ29vc2VEb2N1bWVudEFycmF5ICYmXG4gICAgICAgIHZhbC5sZW5ndGggIT09IDAgJiZcbiAgICAgICAgdmFsWzBdICE9IG51bGwgJiZcbiAgICAgICAgdmFsWzBdLiRfXyAhPSBudWxsICYmXG4gICAgICAgIHZhbFswXS4kX18ucG9wdWxhdGVkICE9IG51bGwpIHtcbiAgICAgIGNvbnN0IHBvcHVsYXRlZFBhdGhzID0gT2JqZWN0LmtleXModmFsWzBdLiRfXy5wb3B1bGF0ZWQpO1xuICAgICAgZm9yIChjb25zdCBwb3B1bGF0ZWRQYXRoIG9mIHBvcHVsYXRlZFBhdGhzKSB7XG4gICAgICAgIHRoaXMuJHBvcHVsYXRlZChwYXRoICsgJy4nICsgcG9wdWxhdGVkUGF0aCxcbiAgICAgICAgICB2YWwubWFwKHYgPT4gdi4kcG9wdWxhdGVkKHBvcHVsYXRlZFBhdGgpKSxcbiAgICAgICAgICB2YWxbMF0uJF9fLnBvcHVsYXRlZFtwb3B1bGF0ZWRQYXRoXS5vcHRpb25zKTtcbiAgICAgIH1cbiAgICAgIGRpZFBvcHVsYXRlID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAoIWRpZFBvcHVsYXRlICYmIHRoaXMuJF9fLnBvcHVsYXRlZCkge1xuICAgICAgLy8gSWYgdGhpcyBhcnJheSBwYXJ0aWFsbHkgY29udGFpbnMgcG9wdWxhdGVkIGRvY3VtZW50cywgY29udmVydCB0aGVtXG4gICAgICAvLyBhbGwgdG8gT2JqZWN0SWRzIHJlOiAjODQ0M1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsKSAmJiB0aGlzLiRfXy5wb3B1bGF0ZWRbcGF0aF0pIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWwubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICBpZiAodmFsW2ldIGluc3RhbmNlb2YgRG9jdW1lbnQpIHtcbiAgICAgICAgICAgIHZhbC5zZXQoaSwgdmFsW2ldLl9pZCwgdHJ1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBkZWxldGUgdGhpcy4kX18ucG9wdWxhdGVkW3BhdGhdO1xuICAgIH1cblxuICAgIGlmICh2YWwgIT0gbnVsbCAmJiBzY2hlbWEuJGlzU2luZ2xlTmVzdGVkKSB7XG4gICAgICBfY2hlY2tJbW11dGFibGVTdWJwYXRocyh2YWwsIHNjaGVtYSwgcHJpb3JWYWwpO1xuICAgIH1cblxuICAgIHRoaXMuJG1hcmtWYWxpZChwYXRoKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGlmIChlIGluc3RhbmNlb2YgTW9uZ29vc2VFcnJvci5TdHJpY3RNb2RlRXJyb3IgJiYgZS5pc0ltbXV0YWJsZUVycm9yKSB7XG4gICAgICB0aGlzLmludmFsaWRhdGUocGF0aCwgZSk7XG4gICAgfSBlbHNlIGlmIChlIGluc3RhbmNlb2YgTW9uZ29vc2VFcnJvci5DYXN0RXJyb3IpIHtcbiAgICAgIHRoaXMuaW52YWxpZGF0ZShlLnBhdGgsIGUpO1xuICAgICAgaWYgKGUuJG9yaWdpbmFsRXJyb3JQYXRoKSB7XG4gICAgICAgIHRoaXMuaW52YWxpZGF0ZShwYXRoLFxuICAgICAgICAgIG5ldyBNb25nb29zZUVycm9yLkNhc3RFcnJvcihzY2hlbWEuaW5zdGFuY2UsIHZhbCwgcGF0aCwgZS4kb3JpZ2luYWxFcnJvclBhdGgpKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5pbnZhbGlkYXRlKHBhdGgsXG4gICAgICAgIG5ldyBNb25nb29zZUVycm9yLkNhc3RFcnJvcihzY2hlbWEuaW5zdGFuY2UsIHZhbCwgcGF0aCwgZSkpO1xuICAgIH1cbiAgICBzaG91bGRTZXQgPSBmYWxzZTtcbiAgfVxuXG4gIGlmIChzaG91bGRTZXQpIHtcbiAgICBsZXQgc2F2ZWRTdGF0ZSA9IG51bGw7XG4gICAgbGV0IHNhdmVkU3RhdGVQYXRoID0gbnVsbDtcbiAgICBpZiAoIWNvbnN0cnVjdGluZykge1xuICAgICAgY29uc3QgZG9jID0gdGhpcy4kaXNTdWJkb2N1bWVudCA/IHRoaXMub3duZXJEb2N1bWVudCgpIDogdGhpcztcbiAgICAgIHNhdmVkU3RhdGUgPSBkb2MuJF9fLnNhdmVkU3RhdGU7XG4gICAgICBzYXZlZFN0YXRlUGF0aCA9IHRoaXMuJGlzU3ViZG9jdW1lbnQgPyB0aGlzLiRfXy5mdWxsUGF0aCArICcuJyArIHBhdGggOiBwYXRoO1xuICAgICAgZG9jLiRfX3NhdmVJbml0aWFsU3RhdGUoc2F2ZWRTdGF0ZVBhdGgpO1xuICAgIH1cblxuICAgIHRoaXMuJF9fc2V0KHBhdGhUb01hcmssIHBhdGgsIG9wdGlvbnMsIGNvbnN0cnVjdGluZywgcGFydHMsIHNjaGVtYSwgdmFsLCBwcmlvclZhbCk7XG5cbiAgICBjb25zdCBpc0luVHJhbnNhY3Rpb24gPSAhIXRoaXMuJF9fLnNlc3Npb24/LnRyYW5zYWN0aW9uO1xuICAgIGNvbnN0IGlzTW9kaWZpZWRXaXRoaW5UcmFuc2FjdGlvbiA9IHRoaXMuJF9fLnNlc3Npb24gJiZcbiAgICAgIHRoaXMuJF9fLnNlc3Npb25bc2Vzc2lvbk5ld0RvY3VtZW50c10gJiZcbiAgICAgIHRoaXMuJF9fLnNlc3Npb25bc2Vzc2lvbk5ld0RvY3VtZW50c10uaGFzKHRoaXMpICYmXG4gICAgICB0aGlzLiRfXy5zZXNzaW9uW3Nlc3Npb25OZXdEb2N1bWVudHNdLmdldCh0aGlzKS5tb2RpZmllZFBhdGhzICYmXG4gICAgICAhdGhpcy4kX18uc2Vzc2lvbltzZXNzaW9uTmV3RG9jdW1lbnRzXS5nZXQodGhpcykubW9kaWZpZWRQYXRocy5oYXMoc2F2ZWRTdGF0ZVBhdGgpO1xuICAgIGlmIChzYXZlZFN0YXRlICE9IG51bGwgJiZcbiAgICAgICAgc2F2ZWRTdGF0ZS5oYXNPd25Qcm9wZXJ0eShzYXZlZFN0YXRlUGF0aCkgJiZcbiAgICAgICAgKCFpc0luVHJhbnNhY3Rpb24gfHwgaXNNb2RpZmllZFdpdGhpblRyYW5zYWN0aW9uKSAmJlxuICAgICAgICB1dGlscy5kZWVwRXF1YWwodmFsLCBzYXZlZFN0YXRlW3NhdmVkU3RhdGVQYXRoXSkpIHtcbiAgICAgIHRoaXMudW5tYXJrTW9kaWZpZWQocGF0aCk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHNjaGVtYS4kaXNTaW5nbGVOZXN0ZWQgJiYgKHRoaXMuaXNEaXJlY3RNb2RpZmllZChwYXRoKSB8fCB2YWwgPT0gbnVsbCkpIHtcbiAgICBjbGVhbk1vZGlmaWVkU3VicGF0aHModGhpcywgcGF0aCk7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxuZnVuY3Rpb24gX2lzTWFudWFsbHlQb3B1bGF0ZWRBcnJheSh2YWwsIHJlZikge1xuICBpZiAoIUFycmF5LmlzQXJyYXkodmFsKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAodmFsLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGZvciAoY29uc3QgZWwgb2YgdmFsKSB7XG4gICAgaWYgKCEoZWwgaW5zdGFuY2VvZiBEb2N1bWVudCkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgbW9kZWxOYW1lID0gZWwuY29uc3RydWN0b3IubW9kZWxOYW1lO1xuICAgIGlmIChtb2RlbE5hbWUgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoZWwuY29uc3RydWN0b3IubW9kZWxOYW1lICE9IHJlZiAmJiBlbC5jb25zdHJ1Y3Rvci5iYXNlTW9kZWxOYW1lICE9IHJlZikge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG4vKipcbiAqIFNldHMgdGhlIHZhbHVlIG9mIGEgcGF0aCwgb3IgbWFueSBwYXRocy5cbiAqIEFsaWFzIGZvciBbYC4kc2V0YF0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2FwaS9kb2N1bWVudC5odG1sI0RvY3VtZW50LnByb3RvdHlwZS4kc2V0KCkpLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgLy8gcGF0aCwgdmFsdWVcbiAqICAgICBkb2Muc2V0KHBhdGgsIHZhbHVlKVxuICpcbiAqICAgICAvLyBvYmplY3RcbiAqICAgICBkb2Muc2V0KHtcbiAqICAgICAgICAgcGF0aCAgOiB2YWx1ZVxuICogICAgICAgLCBwYXRoMiA6IHtcbiAqICAgICAgICAgICAgcGF0aCAgOiB2YWx1ZVxuICogICAgICAgICB9XG4gKiAgICAgfSlcbiAqXG4gKiAgICAgLy8gb24tdGhlLWZseSBjYXN0IHRvIG51bWJlclxuICogICAgIGRvYy5zZXQocGF0aCwgdmFsdWUsIE51bWJlcilcbiAqXG4gKiAgICAgLy8gb24tdGhlLWZseSBjYXN0IHRvIHN0cmluZ1xuICogICAgIGRvYy5zZXQocGF0aCwgdmFsdWUsIFN0cmluZylcbiAqXG4gKiAgICAgLy8gY2hhbmdpbmcgc3RyaWN0IG1vZGUgYmVoYXZpb3JcbiAqICAgICBkb2Muc2V0KHBhdGgsIHZhbHVlLCB7IHN0cmljdDogZmFsc2UgfSk7XG4gKlxuICogQHBhcmFtIHtTdHJpbmd8T2JqZWN0fSBwYXRoIHBhdGggb3Igb2JqZWN0IG9mIGtleS92YWxzIHRvIHNldFxuICogQHBhcmFtIHtBbnl9IHZhbCB0aGUgdmFsdWUgdG8gc2V0XG4gKiBAcGFyYW0ge1NjaGVtYXxTdHJpbmd8TnVtYmVyfEJ1ZmZlcnwqfSBbdHlwZV0gb3B0aW9uYWxseSBzcGVjaWZ5IGEgdHlwZSBmb3IgXCJvbi10aGUtZmx5XCIgYXR0cmlidXRlc1xuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBvcHRpb25hbGx5IHNwZWNpZnkgb3B0aW9ucyB0aGF0IG1vZGlmeSB0aGUgYmVoYXZpb3Igb2YgdGhlIHNldFxuICogQHJldHVybiB7RG9jdW1lbnR9IHRoaXNcbiAqIEBhcGkgcHVibGljXG4gKiBAbWV0aG9kIHNldFxuICogQG1lbWJlck9mIERvY3VtZW50XG4gKiBAaW5zdGFuY2VcbiAqL1xuXG5Eb2N1bWVudC5wcm90b3R5cGUuc2V0ID0gRG9jdW1lbnQucHJvdG90eXBlLiRzZXQ7XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIHdlIHNob3VsZCBtYXJrIHRoaXMgY2hhbmdlIGFzIG1vZGlmaWVkLlxuICpcbiAqIEBwYXJhbSB7bmV2ZXJ9IHBhdGhUb01hcmsgVU5VU0VEXG4gKiBAcGFyYW0ge1N0cmluZ3xTeW1ib2x9IHBhdGhcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAcGFyYW0ge0FueX0gY29uc3RydWN0aW5nXG4gKiBAcGFyYW0ge25ldmVyfSBwYXJ0cyBVTlVTRURcbiAqIEBwYXJhbSB7U2NoZW1hfSBzY2hlbWFcbiAqIEBwYXJhbSB7QW55fSB2YWxcbiAqIEBwYXJhbSB7QW55fSBwcmlvclZhbFxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqIEBhcGkgcHJpdmF0ZVxuICogQG1ldGhvZCAkX19zaG91bGRNb2RpZnlcbiAqIEBtZW1iZXJPZiBEb2N1bWVudFxuICogQGluc3RhbmNlXG4gKi9cblxuRG9jdW1lbnQucHJvdG90eXBlLiRfX3Nob3VsZE1vZGlmeSA9IGZ1bmN0aW9uKHBhdGhUb01hcmssIHBhdGgsIG9wdGlvbnMsIGNvbnN0cnVjdGluZywgcGFydHMsIHNjaGVtYSwgdmFsLCBwcmlvclZhbCkge1xuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLl9za2lwTWFya01vZGlmaWVkKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmICh0aGlzLiRpc05ldykge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIC8vIElzIHBhdGggYWxyZWFkeSBtb2RpZmllZD8gSWYgc28sIGFsd2F5cyBtb2RpZnkuIFdlIG1heSB1bm1hcmsgbW9kaWZpZWQgbGF0ZXIuXG4gIGlmIChwYXRoIGluIHRoaXMuJF9fLmFjdGl2ZVBhdGhzLmdldFN0YXRlUGF0aHMoJ21vZGlmeScpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAodmFsID09PSB2b2lkIDAgJiYgIXRoaXMuJF9faXNTZWxlY3RlZChwYXRoKSkge1xuICAgIC8vIHdoZW4gYSBwYXRoIGlzIG5vdCBzZWxlY3RlZCBpbiBhIHF1ZXJ5LCBpdHMgaW5pdGlhbFxuICAgIC8vIHZhbHVlIHdpbGwgYmUgdW5kZWZpbmVkLlxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKHZhbCA9PT0gdm9pZCAwICYmIHBhdGggaW4gdGhpcy4kX18uYWN0aXZlUGF0aHMuZ2V0U3RhdGVQYXRocygnZGVmYXVsdCcpKSB7XG4gICAgLy8gd2UncmUganVzdCB1bnNldHRpbmcgdGhlIGRlZmF1bHQgdmFsdWUgd2hpY2ggd2FzIG5ldmVyIHNhdmVkXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gZ2gtMzk5MjogaWYgc2V0dGluZyBhIHBvcHVsYXRlZCBmaWVsZCB0byBhIGRvYywgZG9uJ3QgbWFyayBtb2RpZmllZFxuICAvLyBpZiB0aGV5IGhhdmUgdGhlIHNhbWUgX2lkXG4gIGlmICh0aGlzLiRwb3B1bGF0ZWQocGF0aCkgJiZcbiAgICAgIHZhbCBpbnN0YW5jZW9mIERvY3VtZW50ICYmXG4gICAgICBkZWVwRXF1YWwodmFsLl9pZCwgcHJpb3JWYWwpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKCFkZWVwRXF1YWwodmFsLCBwcmlvclZhbCAhPT0gdW5kZWZpbmVkID8gcHJpb3JWYWwgOiB1dGlscy5nZXRWYWx1ZShwYXRoLCB0aGlzKSkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmICghY29uc3RydWN0aW5nICYmXG4gICAgICB2YWwgIT09IG51bGwgJiZcbiAgICAgIHZhbCAhPT0gdW5kZWZpbmVkICYmXG4gICAgICBwYXRoIGluIHRoaXMuJF9fLmFjdGl2ZVBhdGhzLmdldFN0YXRlUGF0aHMoJ2RlZmF1bHQnKSAmJlxuICAgICAgZGVlcEVxdWFsKHZhbCwgc2NoZW1hLmdldERlZmF1bHQodGhpcywgY29uc3RydWN0aW5nKSkpIHtcbiAgICAvLyBhIHBhdGggd2l0aCBhIGRlZmF1bHQgd2FzICR1bnNldCBvbiB0aGUgc2VydmVyXG4gICAgLy8gYW5kIHRoZSB1c2VyIGlzIHNldHRpbmcgaXQgdG8gdGhlIHNhbWUgdmFsdWUgYWdhaW5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59O1xuXG4vKipcbiAqIEhhbmRsZXMgdGhlIGFjdHVhbCBzZXR0aW5nIG9mIHRoZSB2YWx1ZSBhbmQgbWFya2luZyB0aGUgcGF0aCBtb2RpZmllZCBpZiBhcHByb3ByaWF0ZS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcGF0aFRvTWFya1xuICogQHBhcmFtIHtTdHJpbmd8U3ltYm9sfSBwYXRoXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQHBhcmFtIHtBbnl9IGNvbnN0cnVjdGluZ1xuICogQHBhcmFtIHtBcnJheX0gcGFydHNcbiAqIEBwYXJhbSB7U2NoZW1hfSBzY2hlbWFcbiAqIEBwYXJhbSB7QW55fSB2YWxcbiAqIEBwYXJhbSB7QW55fSBwcmlvclZhbFxuICogQGFwaSBwcml2YXRlXG4gKiBAbWV0aG9kICRfX3NldFxuICogQG1lbWJlck9mIERvY3VtZW50XG4gKiBAaW5zdGFuY2VcbiAqL1xuXG5Eb2N1bWVudC5wcm90b3R5cGUuJF9fc2V0ID0gZnVuY3Rpb24ocGF0aFRvTWFyaywgcGF0aCwgb3B0aW9ucywgY29uc3RydWN0aW5nLCBwYXJ0cywgc2NoZW1hLCB2YWwsIHByaW9yVmFsKSB7XG4gIEVtYmVkZGVkID0gRW1iZWRkZWQgfHwgcmVxdWlyZSgnLi90eXBlcy9hcnJheVN1YmRvY3VtZW50Jyk7XG5cbiAgY29uc3Qgc2hvdWxkTW9kaWZ5ID0gdGhpcy4kX19zaG91bGRNb2RpZnkocGF0aFRvTWFyaywgcGF0aCwgb3B0aW9ucywgY29uc3RydWN0aW5nLCBwYXJ0cyxcbiAgICBzY2hlbWEsIHZhbCwgcHJpb3JWYWwpO1xuXG4gIGlmIChzaG91bGRNb2RpZnkpIHtcbiAgICBpZiAodGhpcy4kX18ucHJpbWl0aXZlQXRvbWljcyAmJiB0aGlzLiRfXy5wcmltaXRpdmVBdG9taWNzW3BhdGhdKSB7XG4gICAgICBkZWxldGUgdGhpcy4kX18ucHJpbWl0aXZlQXRvbWljc1twYXRoXTtcbiAgICAgIGlmIChPYmplY3Qua2V5cyh0aGlzLiRfXy5wcmltaXRpdmVBdG9taWNzKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgZGVsZXRlIHRoaXMuJF9fLnByaW1pdGl2ZUF0b21pY3M7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMubWFya01vZGlmaWVkKHBhdGhUb01hcmspO1xuXG4gICAgLy8gaGFuZGxlIGRpcmVjdGx5IHNldHRpbmcgYXJyYXlzIChnaC0xMTI2KVxuICAgIE1vbmdvb3NlQXJyYXkgfHwgKE1vbmdvb3NlQXJyYXkgPSByZXF1aXJlKCcuL3R5cGVzL2FycmF5JykpO1xuICAgIGlmICh2YWwgJiYgdXRpbHMuaXNNb25nb29zZUFycmF5KHZhbCkpIHtcbiAgICAgIHZhbC5fcmVnaXN0ZXJBdG9taWMoJyRzZXQnLCB2YWwpO1xuXG4gICAgICAvLyBVcGRhdGUgZW1iZWRkZWQgZG9jdW1lbnQgcGFyZW50IHJlZmVyZW5jZXMgKGdoLTUxODkpXG4gICAgICBpZiAodXRpbHMuaXNNb25nb29zZURvY3VtZW50QXJyYXkodmFsKSkge1xuICAgICAgICB2YWwuZm9yRWFjaChmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgICAgaXRlbSAmJiBpdGVtLl9fcGFyZW50QXJyYXkgJiYgKGl0ZW0uX19wYXJlbnRBcnJheSA9IHZhbCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHZhbCkgJiYgQXJyYXkuaXNBcnJheShwcmlvclZhbCkgJiYgdXRpbHMuaXNNb25nb29zZUFycmF5KHZhbCkgJiYgdXRpbHMuaXNNb25nb29zZUFycmF5KHByaW9yVmFsKSkge1xuICAgIHZhbFthcnJheUF0b21pY3NTeW1ib2xdID0gcHJpb3JWYWxbYXJyYXlBdG9taWNzU3ltYm9sXTtcbiAgICB2YWxbYXJyYXlBdG9taWNzQmFja3VwU3ltYm9sXSA9IHByaW9yVmFsW2FycmF5QXRvbWljc0JhY2t1cFN5bWJvbF07XG4gICAgaWYgKHV0aWxzLmlzTW9uZ29vc2VEb2N1bWVudEFycmF5KHZhbCkpIHtcbiAgICAgIHZhbC5mb3JFYWNoKGRvYyA9PiB7XG4gICAgICAgIGlmIChkb2MgIT0gbnVsbCkge1xuICAgICAgICAgIGRvYy4kaXNOZXcgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgbGV0IG9iaiA9IHRoaXMuX2RvYztcbiAgbGV0IGkgPSAwO1xuICBjb25zdCBsID0gcGFydHMubGVuZ3RoO1xuICBsZXQgY3VyID0gJyc7XG5cbiAgZm9yICg7IGkgPCBsOyBpKyspIHtcbiAgICBjb25zdCBuZXh0ID0gaSArIDE7XG4gICAgY29uc3QgbGFzdCA9IG5leHQgPT09IGw7XG4gICAgY3VyICs9IChjdXIgPyAnLicgKyBwYXJ0c1tpXSA6IHBhcnRzW2ldKTtcbiAgICBpZiAoc3BlY2lhbFByb3BlcnRpZXMuaGFzKHBhcnRzW2ldKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChsYXN0KSB7XG4gICAgICBpZiAob2JqIGluc3RhbmNlb2YgTWFwKSB7XG4gICAgICAgIG9iai5zZXQocGFydHNbaV0sIHZhbCk7XG4gICAgICB9IGVsc2UgaWYgKG9iai4kaXNTaW5nbGVOZXN0ZWQpIHtcbiAgICAgICAgaWYgKCEocGFydHNbaV0gaW4gb2JqKSkge1xuICAgICAgICAgIG9ialtwYXJ0c1tpXV0gPSB2YWw7XG4gICAgICAgICAgb2JqLl9kb2NbcGFydHNbaV1dID0gdmFsO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG9iai5fZG9jW3BhcnRzW2ldXSA9IHZhbDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb2JqW3BhcnRzW2ldXSA9IHZhbDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgaXNNYXAgPSBvYmogaW5zdGFuY2VvZiBNYXA7XG4gICAgICBsZXQgdmFsdWUgPSBpc01hcCA/IG9iai5nZXQocGFydHNbaV0pIDogb2JqW3BhcnRzW2ldXTtcbiAgICAgIGlmICh1dGlscy5pc1BPSk8odmFsdWUpKSB7XG4gICAgICAgIG9iaiA9IHZhbHVlO1xuICAgICAgfSBlbHNlIGlmICh2YWx1ZSAmJiB2YWx1ZSBpbnN0YW5jZW9mIEVtYmVkZGVkKSB7XG4gICAgICAgIG9iaiA9IHZhbHVlO1xuICAgICAgfSBlbHNlIGlmICh2YWx1ZSAmJiAhQXJyYXkuaXNBcnJheSh2YWx1ZSkgJiYgdmFsdWUuJGlzU2luZ2xlTmVzdGVkKSB7XG4gICAgICAgIG9iaiA9IHZhbHVlO1xuICAgICAgfSBlbHNlIGlmICh2YWx1ZSAmJiBBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICBvYmogPSB2YWx1ZTtcbiAgICAgIH0gZWxzZSBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICB2YWx1ZSA9IHt9O1xuICAgICAgICBpZiAoaXNNYXApIHtcbiAgICAgICAgICBvYmouc2V0KHBhcnRzW2ldLCB2YWx1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb2JqW3BhcnRzW2ldXSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIG9iaiA9IHZhbHVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb2JqID0gdmFsdWU7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIEdldHMgYSByYXcgdmFsdWUgZnJvbSBhIHBhdGggKG5vIGdldHRlcnMpXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHBhdGhcbiAqIEByZXR1cm4ge0FueX0gUmV0dXJucyB0aGUgdmFsdWUgZnJvbSB0aGUgZ2l2ZW4gYHBhdGhgLlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuRG9jdW1lbnQucHJvdG90eXBlLiRfX2dldFZhbHVlID0gZnVuY3Rpb24ocGF0aCkge1xuICByZXR1cm4gdXRpbHMuZ2V0VmFsdWUocGF0aCwgdGhpcy5fZG9jKTtcbn07XG5cbi8qKlxuICogSW5jcmVtZW50cyB0aGUgbnVtZXJpYyB2YWx1ZSBhdCBgcGF0aGAgYnkgdGhlIGdpdmVuIGB2YWxgLlxuICogV2hlbiB5b3UgY2FsbCBgc2F2ZSgpYCBvbiB0aGlzIGRvY3VtZW50LCBNb25nb29zZSB3aWxsIHNlbmQgYVxuICogW2AkaW5jYF0oaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvcmVmZXJlbmNlL29wZXJhdG9yL3VwZGF0ZS9pbmMvKVxuICogYXMgb3Bwb3NlZCB0byBhIGAkc2V0YC5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IHNjaGVtYSA9IG5ldyBTY2hlbWEoeyBjb3VudGVyOiBOdW1iZXIgfSk7XG4gKiAgICAgY29uc3QgVGVzdCA9IGRiLm1vZGVsKCdUZXN0Jywgc2NoZW1hKTtcbiAqXG4gKiAgICAgY29uc3QgZG9jID0gYXdhaXQgVGVzdC5jcmVhdGUoeyBjb3VudGVyOiAwIH0pO1xuICogICAgIGRvYy4kaW5jKCdjb3VudGVyJywgMik7XG4gKiAgICAgYXdhaXQgZG9jLnNhdmUoKTsgLy8gU2VuZHMgYSBgeyAkaW5jOiB7IGNvdW50ZXI6IDIgfSB9YCB0byBNb25nb0RCXG4gKiAgICAgZG9jLmNvdW50ZXI7IC8vIDJcbiAqXG4gKiAgICAgZG9jLmNvdW50ZXIgKz0gMjtcbiAqICAgICBhd2FpdCBkb2Muc2F2ZSgpOyAvLyBTZW5kcyBhIGB7ICRzZXQ6IHsgY291bnRlcjogMiB9IH1gIHRvIE1vbmdvREJcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ3xBcnJheX0gcGF0aCBwYXRoIG9yIHBhdGhzIHRvIHVwZGF0ZVxuICogQHBhcmFtIHtOdW1iZXJ9IHZhbCBpbmNyZW1lbnQgYHBhdGhgIGJ5IHRoaXMgdmFsdWVcbiAqIEByZXR1cm4ge0RvY3VtZW50fSB0aGlzXG4gKi9cblxuRG9jdW1lbnQucHJvdG90eXBlLiRpbmMgPSBmdW5jdGlvbiAkaW5jKHBhdGgsIHZhbCkge1xuICBpZiAodmFsID09IG51bGwpIHtcbiAgICB2YWwgPSAxO1xuICB9XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkocGF0aCkpIHtcbiAgICBwYXRoLmZvckVhY2goKHApID0+IHRoaXMuJGluYyhwLCB2YWwpKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGNvbnN0IHNjaGVtYVR5cGUgPSB0aGlzLiRfX3BhdGgocGF0aCk7XG4gIGlmIChzY2hlbWFUeXBlID09IG51bGwpIHtcbiAgICBpZiAodGhpcy4kX18uc3RyaWN0TW9kZSA9PT0gJ3Rocm93Jykge1xuICAgICAgdGhyb3cgbmV3IFN0cmljdE1vZGVFcnJvcihwYXRoKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuJF9fLnN0cmljdE1vZGUgPT09IHRydWUpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSBlbHNlIGlmIChzY2hlbWFUeXBlLmluc3RhbmNlICE9PSAnTnVtYmVyJykge1xuICAgIHRoaXMuaW52YWxpZGF0ZShwYXRoLCBuZXcgTW9uZ29vc2VFcnJvci5DYXN0RXJyb3Ioc2NoZW1hVHlwZS5pbnN0YW5jZSwgdmFsLCBwYXRoKSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBjb25zdCBjdXJyZW50VmFsdWUgPSB0aGlzLiRfX2dldFZhbHVlKHBhdGgpIHx8IDA7XG4gIGxldCBzaG91bGRTZXQgPSBmYWxzZTtcbiAgbGV0IHZhbFRvU2V0ID0gbnVsbDtcbiAgbGV0IHZhbFRvSW5jID0gdmFsO1xuXG4gIHRyeSB7XG4gICAgdmFsID0gc2NoZW1hVHlwZS5jYXN0KHZhbCk7XG4gICAgdmFsVG9TZXQgPSBzY2hlbWFUeXBlLmFwcGx5U2V0dGVycyhjdXJyZW50VmFsdWUgKyB2YWwsIHRoaXMpO1xuICAgIHZhbFRvSW5jID0gdmFsVG9TZXQgLSBjdXJyZW50VmFsdWU7XG4gICAgc2hvdWxkU2V0ID0gdHJ1ZTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgdGhpcy5pbnZhbGlkYXRlKHBhdGgsIG5ldyBNb25nb29zZUVycm9yLkNhc3RFcnJvcignbnVtYmVyJywgdmFsLCBwYXRoLCBlcnIpKTtcbiAgfVxuXG4gIGlmIChzaG91bGRTZXQpIHtcbiAgICB0aGlzLiRfXy5wcmltaXRpdmVBdG9taWNzID0gdGhpcy4kX18ucHJpbWl0aXZlQXRvbWljcyB8fCB7fTtcbiAgICBpZiAodGhpcy4kX18ucHJpbWl0aXZlQXRvbWljc1twYXRoXSA9PSBudWxsKSB7XG4gICAgICB0aGlzLiRfXy5wcmltaXRpdmVBdG9taWNzW3BhdGhdID0geyAkaW5jOiB2YWxUb0luYyB9O1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLiRfXy5wcmltaXRpdmVBdG9taWNzW3BhdGhdLiRpbmMgKz0gdmFsVG9JbmM7XG4gICAgfVxuICAgIHRoaXMubWFya01vZGlmaWVkKHBhdGgpO1xuICAgIHRoaXMuJF9fc2V0VmFsdWUocGF0aCwgdmFsVG9TZXQpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNldHMgYSByYXcgdmFsdWUgZm9yIGEgcGF0aCAobm8gY2FzdGluZywgc2V0dGVycywgdHJhbnNmb3JtYXRpb25zKVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsdWVcbiAqIEByZXR1cm4ge0RvY3VtZW50fSB0aGlzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Eb2N1bWVudC5wcm90b3R5cGUuJF9fc2V0VmFsdWUgPSBmdW5jdGlvbihwYXRoLCB2YWwpIHtcbiAgdXRpbHMuc2V0VmFsdWUocGF0aCwgdmFsLCB0aGlzLl9kb2MpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgdmFsdWUgb2YgYSBwYXRoLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgLy8gcGF0aFxuICogICAgIGRvYy5nZXQoJ2FnZScpIC8vIDQ3XG4gKlxuICogICAgIC8vIGR5bmFtaWMgY2FzdGluZyB0byBhIHN0cmluZ1xuICogICAgIGRvYy5nZXQoJ2FnZScsIFN0cmluZykgLy8gXCI0N1wiXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHBhdGhcbiAqIEBwYXJhbSB7U2NoZW1hfFN0cmluZ3xOdW1iZXJ8QnVmZmVyfCp9IFt0eXBlXSBvcHRpb25hbGx5IHNwZWNpZnkgYSB0eXBlIGZvciBvbi10aGUtZmx5IGF0dHJpYnV0ZXNcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMudmlydHVhbHM9ZmFsc2VdIEFwcGx5IHZpcnR1YWxzIGJlZm9yZSBnZXR0aW5nIHRoaXMgcGF0aFxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5nZXR0ZXJzPXRydWVdIElmIGZhbHNlLCBza2lwIGFwcGx5aW5nIGdldHRlcnMgYW5kIGp1c3QgZ2V0IHRoZSByYXcgdmFsdWVcbiAqIEByZXR1cm4ge0FueX1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuRG9jdW1lbnQucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uKHBhdGgsIHR5cGUsIG9wdGlvbnMpIHtcbiAgbGV0IGFkaG9jO1xuICBpZiAob3B0aW9ucyA9PSBudWxsKSB7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG4gIGlmICh0eXBlKSB7XG4gICAgYWRob2MgPSB0aGlzLiRfX3NjaGVtYS5pbnRlcnByZXRBc1R5cGUocGF0aCwgdHlwZSwgdGhpcy4kX19zY2hlbWEub3B0aW9ucyk7XG4gIH1cbiAgY29uc3Qgbm9Eb3R0ZWRQYXRoID0gb3B0aW9ucy5ub0RvdHRlZFBhdGg7XG5cbiAgLy8gRmFzdCBwYXRoIGlmIHdlIGtub3cgd2UncmUganVzdCBhY2Nlc3NpbmcgdG9wLWxldmVsIHBhdGggb24gdGhlIGRvY3VtZW50OlxuICAvLyBqdXN0IGdldCB0aGUgc2NoZW1hIHBhdGgsIGF2b2lkIGAkX19wYXRoKClgIGJlY2F1c2UgdGhhdCBkb2VzIHN0cmluZyBtYW5pcHVsYXRpb25cbiAgbGV0IHNjaGVtYSA9IG5vRG90dGVkUGF0aCA/IHRoaXMuJF9fc2NoZW1hLnBhdGhzW3BhdGhdIDogdGhpcy4kX19wYXRoKHBhdGgpO1xuICBpZiAoc2NoZW1hID09IG51bGwpIHtcbiAgICBzY2hlbWEgPSB0aGlzLiRfX3NjaGVtYS52aXJ0dWFscGF0aChwYXRoKTtcblxuICAgIGlmIChzY2hlbWEgIT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHNjaGVtYS5hcHBseUdldHRlcnModm9pZCAwLCB0aGlzKTtcbiAgICB9XG4gIH1cblxuICBpZiAobm9Eb3R0ZWRQYXRoKSB7XG4gICAgbGV0IG9iaiA9IHRoaXMuX2RvY1twYXRoXTtcbiAgICBpZiAoYWRob2MpIHtcbiAgICAgIG9iaiA9IGFkaG9jLmNhc3Qob2JqKTtcbiAgICB9XG4gICAgaWYgKHNjaGVtYSAhPSBudWxsICYmIG9wdGlvbnMuZ2V0dGVycyAhPT0gZmFsc2UpIHtcbiAgICAgIHJldHVybiBzY2hlbWEuYXBwbHlHZXR0ZXJzKG9iaiwgdGhpcyk7XG4gICAgfVxuICAgIHJldHVybiBvYmo7XG4gIH1cblxuICBpZiAoc2NoZW1hICE9IG51bGwgJiYgc2NoZW1hLmluc3RhbmNlID09PSAnTWl4ZWQnKSB7XG4gICAgY29uc3QgdmlydHVhbCA9IHRoaXMuJF9fc2NoZW1hLnZpcnR1YWxwYXRoKHBhdGgpO1xuICAgIGlmICh2aXJ0dWFsICE9IG51bGwpIHtcbiAgICAgIHNjaGVtYSA9IHZpcnR1YWw7XG4gICAgfVxuICB9XG5cbiAgY29uc3QgaGFzRG90ID0gcGF0aC5pbmRleE9mKCcuJykgIT09IC0xO1xuICBsZXQgb2JqID0gdGhpcy5fZG9jO1xuXG4gIGNvbnN0IHBpZWNlcyA9IGhhc0RvdCA/IHBhdGguc3BsaXQoJy4nKSA6IFtwYXRoXTtcbiAgLy8gTWlnaHQgbmVlZCB0byBjaGFuZ2UgcGF0aCBmb3IgdG9wLWxldmVsIGFsaWFzXG4gIGlmICh0eXBlb2YgdGhpcy4kX19zY2hlbWEuYWxpYXNlc1twaWVjZXNbMF1dID09PSAnc3RyaW5nJykge1xuICAgIHBpZWNlc1swXSA9IHRoaXMuJF9fc2NoZW1hLmFsaWFzZXNbcGllY2VzWzBdXTtcbiAgfVxuXG4gIGZvciAobGV0IGkgPSAwLCBsID0gcGllY2VzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGlmIChvYmogJiYgb2JqLl9kb2MpIHtcbiAgICAgIG9iaiA9IG9iai5fZG9jO1xuICAgIH1cblxuICAgIGlmIChvYmogPT0gbnVsbCkge1xuICAgICAgb2JqID0gdm9pZCAwO1xuICAgIH0gZWxzZSBpZiAob2JqIGluc3RhbmNlb2YgTWFwKSB7XG4gICAgICBvYmogPSBvYmouZ2V0KHBpZWNlc1tpXSwgeyBnZXR0ZXJzOiBmYWxzZSB9KTtcbiAgICB9IGVsc2UgaWYgKGkgPT09IGwgLSAxKSB7XG4gICAgICBvYmogPSB1dGlscy5nZXRWYWx1ZShwaWVjZXNbaV0sIG9iaik7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9iaiA9IG9ialtwaWVjZXNbaV1dO1xuICAgIH1cbiAgfVxuXG4gIGlmIChhZGhvYykge1xuICAgIG9iaiA9IGFkaG9jLmNhc3Qob2JqKTtcbiAgfVxuXG4gIGlmIChzY2hlbWEgIT0gbnVsbCAmJiBvcHRpb25zLmdldHRlcnMgIT09IGZhbHNlKSB7XG4gICAgb2JqID0gc2NoZW1hLmFwcGx5R2V0dGVycyhvYmosIHRoaXMpO1xuICB9IGVsc2UgaWYgKHRoaXMuJF9fc2NoZW1hLm5lc3RlZFtwYXRoXSAmJiBvcHRpb25zLnZpcnR1YWxzKSB7XG4gICAgLy8gTWlnaHQgbmVlZCB0byBhcHBseSB2aXJ0dWFscyBpZiB0aGlzIGlzIGEgbmVzdGVkIHBhdGhcbiAgICByZXR1cm4gYXBwbHlWaXJ0dWFscyh0aGlzLCBjbG9uZShvYmopIHx8IHt9LCB7IHBhdGg6IHBhdGggfSk7XG4gIH1cblxuICByZXR1cm4gb2JqO1xufTtcblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5Eb2N1bWVudC5wcm90b3R5cGVbZ2V0U3ltYm9sXSA9IERvY3VtZW50LnByb3RvdHlwZS5nZXQ7XG5Eb2N1bWVudC5wcm90b3R5cGUuJGdldCA9IERvY3VtZW50LnByb3RvdHlwZS5nZXQ7XG5cbi8qKlxuICogUmV0dXJucyB0aGUgc2NoZW1hdHlwZSBmb3IgdGhlIGdpdmVuIGBwYXRoYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcGF0aFxuICogQHJldHVybiB7U2NoZW1hUGF0aH1cbiAqIEBhcGkgcHJpdmF0ZVxuICogQG1ldGhvZCAkX19wYXRoXG4gKiBAbWVtYmVyT2YgRG9jdW1lbnRcbiAqIEBpbnN0YW5jZVxuICovXG5cbkRvY3VtZW50LnByb3RvdHlwZS4kX19wYXRoID0gZnVuY3Rpb24ocGF0aCkge1xuICBjb25zdCBhZGhvY3MgPSB0aGlzLiRfXy5hZGhvY1BhdGhzO1xuICBjb25zdCBhZGhvY1R5cGUgPSBhZGhvY3MgJiYgYWRob2NzLmhhc093blByb3BlcnR5KHBhdGgpID8gYWRob2NzW3BhdGhdIDogbnVsbDtcblxuICBpZiAoYWRob2NUeXBlKSB7XG4gICAgcmV0dXJuIGFkaG9jVHlwZTtcbiAgfVxuICByZXR1cm4gdGhpcy4kX19zY2hlbWEucGF0aChwYXRoKTtcbn07XG5cbi8qKlxuICogTWFya3MgdGhlIHBhdGggYXMgaGF2aW5nIHBlbmRpbmcgY2hhbmdlcyB0byB3cml0ZSB0byB0aGUgZGIuXG4gKlxuICogX1ZlcnkgaGVscGZ1bCB3aGVuIHVzaW5nIFtNaXhlZF0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL3NjaGVtYXR5cGVzLmh0bWwjbWl4ZWQpIHR5cGVzLl9cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGRvYy5taXhlZC50eXBlID0gJ2NoYW5nZWQnO1xuICogICAgIGRvYy5tYXJrTW9kaWZpZWQoJ21peGVkLnR5cGUnKTtcbiAqICAgICBkb2Muc2F2ZSgpIC8vIGNoYW5nZXMgdG8gbWl4ZWQudHlwZSBhcmUgbm93IHBlcnNpc3RlZFxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoIHRoZSBwYXRoIHRvIG1hcmsgbW9kaWZpZWRcbiAqIEBwYXJhbSB7RG9jdW1lbnR9IFtzY29wZV0gdGhlIHNjb3BlIHRvIHJ1biB2YWxpZGF0b3JzIHdpdGhcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuRG9jdW1lbnQucHJvdG90eXBlLm1hcmtNb2RpZmllZCA9IGZ1bmN0aW9uKHBhdGgsIHNjb3BlKSB7XG4gIHRoaXMuJF9fc2F2ZUluaXRpYWxTdGF0ZShwYXRoKTtcblxuICB0aGlzLiRfXy5hY3RpdmVQYXRocy5tb2RpZnkocGF0aCk7XG4gIGlmIChzY29wZSAhPSBudWxsICYmICF0aGlzLiRpc1N1YmRvY3VtZW50KSB7XG4gICAgdGhpcy4kX18ucGF0aHNUb1Njb3BlcyA9IHRoaXMuJF9fcGF0aHNUb1Njb3BlcyB8fCB7fTtcbiAgICB0aGlzLiRfXy5wYXRoc1RvU2NvcGVzW3BhdGhdID0gc2NvcGU7XG4gIH1cbn07XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxuRG9jdW1lbnQucHJvdG90eXBlLiRfX3NhdmVJbml0aWFsU3RhdGUgPSBmdW5jdGlvbiAkX19zYXZlSW5pdGlhbFN0YXRlKHBhdGgpIHtcbiAgY29uc3Qgc2F2ZWRTdGF0ZSA9IHRoaXMuJF9fLnNhdmVkU3RhdGU7XG4gIGNvbnN0IHNhdmVkU3RhdGVQYXRoID0gcGF0aDtcbiAgaWYgKHNhdmVkU3RhdGUgIT0gbnVsbCkge1xuICAgIGNvbnN0IGZpcnN0RG90ID0gc2F2ZWRTdGF0ZVBhdGguaW5kZXhPZignLicpO1xuICAgIGNvbnN0IHRvcExldmVsUGF0aCA9IGZpcnN0RG90ID09PSAtMSA/IHNhdmVkU3RhdGVQYXRoIDogc2F2ZWRTdGF0ZVBhdGguc2xpY2UoMCwgZmlyc3REb3QpO1xuICAgIGlmICghc2F2ZWRTdGF0ZS5oYXNPd25Qcm9wZXJ0eSh0b3BMZXZlbFBhdGgpKSB7XG4gICAgICBzYXZlZFN0YXRlW3RvcExldmVsUGF0aF0gPSBjbG9uZSh0aGlzLiRfX2dldFZhbHVlKHRvcExldmVsUGF0aCkpO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBDbGVhcnMgdGhlIG1vZGlmaWVkIHN0YXRlIG9uIHRoZSBzcGVjaWZpZWQgcGF0aC5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGRvYy5mb28gPSAnYmFyJztcbiAqICAgICBkb2MudW5tYXJrTW9kaWZpZWQoJ2ZvbycpO1xuICogICAgIGRvYy5zYXZlKCk7IC8vIGNoYW5nZXMgdG8gZm9vIHdpbGwgbm90IGJlIHBlcnNpc3RlZFxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoIHRoZSBwYXRoIHRvIHVubWFyayBtb2RpZmllZFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Eb2N1bWVudC5wcm90b3R5cGUudW5tYXJrTW9kaWZpZWQgPSBmdW5jdGlvbihwYXRoKSB7XG4gIHRoaXMuJF9fLmFjdGl2ZVBhdGhzLmluaXQocGF0aCk7XG4gIGlmICh0aGlzLiRfXy5wYXRoc1RvU2NvcGVzICE9IG51bGwpIHtcbiAgICBkZWxldGUgdGhpcy4kX18ucGF0aHNUb1Njb3Blc1twYXRoXTtcbiAgfVxufTtcblxuLyoqXG4gKiBEb24ndCBydW4gdmFsaWRhdGlvbiBvbiB0aGlzIHBhdGggb3IgcGVyc2lzdCBjaGFuZ2VzIHRvIHRoaXMgcGF0aC5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGRvYy5mb28gPSBudWxsO1xuICogICAgIGRvYy4kaWdub3JlKCdmb28nKTtcbiAqICAgICBkb2Muc2F2ZSgpOyAvLyBjaGFuZ2VzIHRvIGZvbyB3aWxsIG5vdCBiZSBwZXJzaXN0ZWQgYW5kIHZhbGlkYXRvcnMgd29uJ3QgYmUgcnVuXG4gKlxuICogQG1lbWJlck9mIERvY3VtZW50XG4gKiBAaW5zdGFuY2VcbiAqIEBtZXRob2QgJGlnbm9yZVxuICogQHBhcmFtIHtTdHJpbmd9IHBhdGggdGhlIHBhdGggdG8gaWdub3JlXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkRvY3VtZW50LnByb3RvdHlwZS4kaWdub3JlID0gZnVuY3Rpb24ocGF0aCkge1xuICB0aGlzLiRfXy5hY3RpdmVQYXRocy5pZ25vcmUocGF0aCk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGxpc3Qgb2YgcGF0aHMgdGhhdCBoYXZlIGJlZW4gZGlyZWN0bHkgbW9kaWZpZWQuIEEgZGlyZWN0XG4gKiBtb2RpZmllZCBwYXRoIGlzIGEgcGF0aCB0aGF0IHlvdSBleHBsaWNpdGx5IHNldCwgd2hldGhlciB2aWEgYGRvYy5mb28gPSAnYmFyJ2AsXG4gKiBgT2JqZWN0LmFzc2lnbihkb2MsIHsgZm9vOiAnYmFyJyB9KWAsIG9yIGBkb2Muc2V0KCdmb28nLCAnYmFyJylgLlxuICpcbiAqIEEgcGF0aCBgYWAgbWF5IGJlIGluIGBtb2RpZmllZFBhdGhzKClgIGJ1dCBub3QgaW4gYGRpcmVjdE1vZGlmaWVkUGF0aHMoKWBcbiAqIGJlY2F1c2UgYSBjaGlsZCBvZiBgYWAgd2FzIGRpcmVjdGx5IG1vZGlmaWVkLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgY29uc3Qgc2NoZW1hID0gbmV3IFNjaGVtYSh7IGZvbzogU3RyaW5nLCBuZXN0ZWQ6IHsgYmFyOiBTdHJpbmcgfSB9KTtcbiAqICAgICBjb25zdCBNb2RlbCA9IG1vbmdvb3NlLm1vZGVsKCdUZXN0Jywgc2NoZW1hKTtcbiAqICAgICBhd2FpdCBNb2RlbC5jcmVhdGUoeyBmb286ICdvcmlnaW5hbCcsIG5lc3RlZDogeyBiYXI6ICdvcmlnaW5hbCcgfSB9KTtcbiAqXG4gKiAgICAgY29uc3QgZG9jID0gYXdhaXQgTW9kZWwuZmluZE9uZSgpO1xuICogICAgIGRvYy5uZXN0ZWQuYmFyID0gJ21vZGlmaWVkJztcbiAqICAgICBkb2MuZGlyZWN0TW9kaWZpZWRQYXRocygpOyAvLyBbJ25lc3RlZC5iYXInXVxuICogICAgIGRvYy5tb2RpZmllZFBhdGhzKCk7IC8vIFsnbmVzdGVkJywgJ25lc3RlZC5iYXInXVxuICpcbiAqIEByZXR1cm4ge1N0cmluZ1tdfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Eb2N1bWVudC5wcm90b3R5cGUuZGlyZWN0TW9kaWZpZWRQYXRocyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gT2JqZWN0LmtleXModGhpcy4kX18uYWN0aXZlUGF0aHMuZ2V0U3RhdGVQYXRocygnbW9kaWZ5JykpO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIHBhdGggaXMgbnVsbGlzaCBvciBvbmx5IGNvbnRhaW5zIGVtcHR5IG9iamVjdHMuXG4gKiBVc2VmdWwgZm9yIGRldGVybWluaW5nIHdoZXRoZXIgdGhpcyBzdWJkb2Mgd2lsbCBnZXQgc3RyaXBwZWQgb3V0IGJ5IHRoZVxuICogW21pbmltaXplIG9wdGlvbl0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2d1aWRlLmh0bWwjbWluaW1pemUpLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgY29uc3Qgc2NoZW1hID0gbmV3IFNjaGVtYSh7IG5lc3RlZDogeyBmb286IFN0cmluZyB9IH0pO1xuICogICAgIGNvbnN0IE1vZGVsID0gbW9uZ29vc2UubW9kZWwoJ1Rlc3QnLCBzY2hlbWEpO1xuICogICAgIGNvbnN0IGRvYyA9IG5ldyBNb2RlbCh7fSk7XG4gKiAgICAgZG9jLiRpc0VtcHR5KCduZXN0ZWQnKTsgLy8gdHJ1ZVxuICogICAgIGRvYy5uZXN0ZWQuJGlzRW1wdHkoKTsgLy8gdHJ1ZVxuICpcbiAqICAgICBkb2MubmVzdGVkLmZvbyA9ICdiYXInO1xuICogICAgIGRvYy4kaXNFbXB0eSgnbmVzdGVkJyk7IC8vIGZhbHNlXG4gKiAgICAgZG9jLm5lc3RlZC4kaXNFbXB0eSgpOyAvLyBmYWxzZVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBbcGF0aF1cbiAqIEBtZW1iZXJPZiBEb2N1bWVudFxuICogQGluc3RhbmNlXG4gKiBAYXBpIHB1YmxpY1xuICogQG1ldGhvZCAkaXNFbXB0eVxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuXG5Eb2N1bWVudC5wcm90b3R5cGUuJGlzRW1wdHkgPSBmdW5jdGlvbihwYXRoKSB7XG4gIGNvbnN0IGlzRW1wdHlPcHRpb25zID0ge1xuICAgIG1pbmltaXplOiB0cnVlLFxuICAgIHZpcnR1YWxzOiBmYWxzZSxcbiAgICBnZXR0ZXJzOiBmYWxzZSxcbiAgICB0cmFuc2Zvcm06IGZhbHNlXG4gIH07XG5cbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggIT09IDApIHtcbiAgICBjb25zdCB2ID0gdGhpcy4kZ2V0KHBhdGgpO1xuICAgIGlmICh2ID09IG51bGwpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHYgIT09ICdvYmplY3QnKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICh1dGlscy5pc1BPSk8odikpIHtcbiAgICAgIHJldHVybiBfaXNFbXB0eSh2KTtcbiAgICB9XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKHYudG9PYmplY3QoaXNFbXB0eU9wdGlvbnMpKS5sZW5ndGggPT09IDA7XG4gIH1cblxuICByZXR1cm4gT2JqZWN0LmtleXModGhpcy50b09iamVjdChpc0VtcHR5T3B0aW9ucykpLmxlbmd0aCA9PT0gMDtcbn07XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxuZnVuY3Rpb24gX2lzRW1wdHkodikge1xuICBpZiAodiA9PSBudWxsKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKHR5cGVvZiB2ICE9PSAnb2JqZWN0JyB8fCBBcnJheS5pc0FycmF5KHYpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKHYpKSB7XG4gICAgaWYgKCFfaXNFbXB0eSh2W2tleV0pKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIGxpc3Qgb2YgcGF0aHMgdGhhdCBoYXZlIGJlZW4gbW9kaWZpZWQuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5pbmNsdWRlQ2hpbGRyZW49ZmFsc2VdIGlmIHRydWUsIHJldHVybnMgY2hpbGRyZW4gb2YgbW9kaWZpZWQgcGF0aHMgYXMgd2VsbC4gRm9yIGV4YW1wbGUsIGlmIGZhbHNlLCB0aGUgbGlzdCBvZiBtb2RpZmllZCBwYXRocyBmb3IgYGRvYy5jb2xvcnMgPSB7IHByaW1hcnk6ICdibHVlJyB9O2Agd2lsbCAqKm5vdCoqIGNvbnRhaW4gYGNvbG9ycy5wcmltYXJ5YC4gSWYgdHJ1ZSwgYG1vZGlmaWVkUGF0aHMoKWAgd2lsbCByZXR1cm4gYW4gYXJyYXkgdGhhdCBjb250YWlucyBgY29sb3JzLnByaW1hcnlgLlxuICogQHJldHVybiB7U3RyaW5nW119XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkRvY3VtZW50LnByb3RvdHlwZS5tb2RpZmllZFBhdGhzID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICBjb25zdCBkaXJlY3RNb2RpZmllZFBhdGhzID0gT2JqZWN0LmtleXModGhpcy4kX18uYWN0aXZlUGF0aHMuZ2V0U3RhdGVQYXRocygnbW9kaWZ5JykpO1xuICBjb25zdCByZXN1bHQgPSBuZXcgU2V0KCk7XG5cbiAgbGV0IGkgPSAwO1xuICBsZXQgaiA9IDA7XG4gIGNvbnN0IGxlbiA9IGRpcmVjdE1vZGlmaWVkUGF0aHMubGVuZ3RoO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgIGNvbnN0IHBhdGggPSBkaXJlY3RNb2RpZmllZFBhdGhzW2ldO1xuICAgIGNvbnN0IHBhcnRzID0gcGFyZW50UGF0aHMocGF0aCk7XG4gICAgY29uc3QgcExlbiA9IHBhcnRzLmxlbmd0aDtcblxuICAgIGZvciAoaiA9IDA7IGogPCBwTGVuOyArK2opIHtcbiAgICAgIHJlc3VsdC5hZGQocGFydHNbal0pO1xuICAgIH1cblxuICAgIGlmICghb3B0aW9ucy5pbmNsdWRlQ2hpbGRyZW4pIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGxldCBpaSA9IDA7XG4gICAgbGV0IGN1ciA9IHRoaXMuJGdldChwYXRoKTtcbiAgICBpZiAodHlwZW9mIGN1ciA9PT0gJ29iamVjdCcgJiYgY3VyICE9PSBudWxsKSB7XG4gICAgICBpZiAoY3VyLl9kb2MpIHtcbiAgICAgICAgY3VyID0gY3VyLl9kb2M7XG4gICAgICB9XG4gICAgICBjb25zdCBsZW4gPSBjdXIubGVuZ3RoO1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoY3VyKSkge1xuICAgICAgICBmb3IgKGlpID0gMDsgaWkgPCBsZW47ICsraWkpIHtcbiAgICAgICAgICBjb25zdCBzdWJQYXRoID0gcGF0aCArICcuJyArIGlpO1xuICAgICAgICAgIGlmICghcmVzdWx0LmhhcyhzdWJQYXRoKSkge1xuICAgICAgICAgICAgcmVzdWx0LmFkZChzdWJQYXRoKTtcbiAgICAgICAgICAgIGlmIChjdXJbaWldICE9IG51bGwgJiYgY3VyW2lpXS4kX18pIHtcbiAgICAgICAgICAgICAgY29uc3QgbW9kaWZpZWQgPSBjdXJbaWldLm1vZGlmaWVkUGF0aHMoKTtcbiAgICAgICAgICAgICAgbGV0IGlpaSA9IDA7XG4gICAgICAgICAgICAgIGNvbnN0IGlpaUxlbiA9IG1vZGlmaWVkLmxlbmd0aDtcbiAgICAgICAgICAgICAgZm9yIChpaWkgPSAwOyBpaWkgPCBpaWlMZW47ICsraWlpKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LmFkZChzdWJQYXRoICsgJy4nICsgbW9kaWZpZWRbaWlpXSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhjdXIpO1xuICAgICAgICBsZXQgaWkgPSAwO1xuICAgICAgICBjb25zdCBsZW4gPSBrZXlzLmxlbmd0aDtcbiAgICAgICAgZm9yIChpaSA9IDA7IGlpIDwgbGVuOyArK2lpKSB7XG4gICAgICAgICAgcmVzdWx0LmFkZChwYXRoICsgJy4nICsga2V5c1tpaV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBBcnJheS5mcm9tKHJlc3VsdCk7XG59O1xuXG5Eb2N1bWVudC5wcm90b3R5cGVbZG9jdW1lbnRNb2RpZmllZFBhdGhzXSA9IERvY3VtZW50LnByb3RvdHlwZS5tb2RpZmllZFBhdGhzO1xuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiBhbnkgb2YgdGhlIGdpdmVuIHBhdGhzIGlzIG1vZGlmaWVkLCBlbHNlIGZhbHNlLiBJZiBubyBhcmd1bWVudHMsIHJldHVybnMgYHRydWVgIGlmIGFueSBwYXRoXG4gKiBpbiB0aGlzIGRvY3VtZW50IGlzIG1vZGlmaWVkLlxuICpcbiAqIElmIGBwYXRoYCBpcyBnaXZlbiwgY2hlY2tzIGlmIGEgcGF0aCBvciBhbnkgZnVsbCBwYXRoIGNvbnRhaW5pbmcgYHBhdGhgIGFzIHBhcnQgb2YgaXRzIHBhdGggY2hhaW4gaGFzIGJlZW4gbW9kaWZpZWQuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBkb2Muc2V0KCdkb2N1bWVudHMuMC50aXRsZScsICdjaGFuZ2VkJyk7XG4gKiAgICAgZG9jLmlzTW9kaWZpZWQoKSAgICAgICAgICAgICAgICAgICAgICAvLyB0cnVlXG4gKiAgICAgZG9jLmlzTW9kaWZpZWQoJ2RvY3VtZW50cycpICAgICAgICAgICAvLyB0cnVlXG4gKiAgICAgZG9jLmlzTW9kaWZpZWQoJ2RvY3VtZW50cy4wLnRpdGxlJykgICAvLyB0cnVlXG4gKiAgICAgZG9jLmlzTW9kaWZpZWQoJ2RvY3VtZW50cyBvdGhlclByb3AnKSAvLyB0cnVlXG4gKiAgICAgZG9jLmlzRGlyZWN0TW9kaWZpZWQoJ2RvY3VtZW50cycpICAgICAvLyBmYWxzZVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBbcGF0aF0gb3B0aW9uYWxcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuaWdub3JlQXRvbWljcz1mYWxzZV0gSWYgdHJ1ZSwgZG9lc24ndCByZXR1cm4gdHJ1ZSBpZiBwYXRoIGlzIHVuZGVybmVhdGggYW4gYXJyYXkgdGhhdCB3YXMgbW9kaWZpZWQgd2l0aCBhdG9taWMgb3BlcmF0aW9ucyBsaWtlIGBwdXNoKClgXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Eb2N1bWVudC5wcm90b3R5cGUuaXNNb2RpZmllZCA9IGZ1bmN0aW9uKHBhdGhzLCBvcHRpb25zLCBtb2RpZmllZFBhdGhzKSB7XG4gIGlmIChwYXRocykge1xuICAgIGNvbnN0IGlnbm9yZUF0b21pY3MgPSBvcHRpb25zICYmIG9wdGlvbnMuaWdub3JlQXRvbWljcztcbiAgICBjb25zdCBkaXJlY3RNb2RpZmllZFBhdGhzT2JqID0gdGhpcy4kX18uYWN0aXZlUGF0aHMuc3RhdGVzLm1vZGlmeTtcbiAgICBpZiAoZGlyZWN0TW9kaWZpZWRQYXRoc09iaiA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBwYXRocyA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHBhdGhzID0gcGF0aHMuaW5kZXhPZignICcpID09PSAtMSA/IFtwYXRoc10gOiBwYXRocy5zcGxpdCgnICcpO1xuICAgIH1cblxuICAgIGZvciAoY29uc3QgcGF0aCBvZiBwYXRocykge1xuICAgICAgaWYgKGRpcmVjdE1vZGlmaWVkUGF0aHNPYmpbcGF0aF0gIT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBtb2RpZmllZCA9IG1vZGlmaWVkUGF0aHMgfHwgdGhpc1tkb2N1bWVudE1vZGlmaWVkUGF0aHNdKCk7XG4gICAgY29uc3QgaXNNb2RpZmllZENoaWxkID0gcGF0aHMuc29tZShmdW5jdGlvbihwYXRoKSB7XG4gICAgICByZXR1cm4gISF+bW9kaWZpZWQuaW5kZXhPZihwYXRoKTtcbiAgICB9KTtcblxuICAgIGxldCBkaXJlY3RNb2RpZmllZFBhdGhzID0gT2JqZWN0LmtleXMoZGlyZWN0TW9kaWZpZWRQYXRoc09iaik7XG4gICAgaWYgKGlnbm9yZUF0b21pY3MpIHtcbiAgICAgIGRpcmVjdE1vZGlmaWVkUGF0aHMgPSBkaXJlY3RNb2RpZmllZFBhdGhzLmZpbHRlcihwYXRoID0+IHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLiRfX2dldFZhbHVlKHBhdGgpO1xuICAgICAgICBpZiAodmFsdWUgIT0gbnVsbCAmJiB2YWx1ZVthcnJheUF0b21pY3NTeW1ib2xdICE9IG51bGwgJiYgdmFsdWVbYXJyYXlBdG9taWNzU3ltYm9sXS4kc2V0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGlzTW9kaWZpZWRDaGlsZCB8fCBwYXRocy5zb21lKGZ1bmN0aW9uKHBhdGgpIHtcbiAgICAgIHJldHVybiBkaXJlY3RNb2RpZmllZFBhdGhzLnNvbWUoZnVuY3Rpb24obW9kKSB7XG4gICAgICAgIHJldHVybiBtb2QgPT09IHBhdGggfHwgcGF0aC5zdGFydHNXaXRoKG1vZCArICcuJyk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiB0aGlzLiRfXy5hY3RpdmVQYXRocy5zb21lKCdtb2RpZnknKTtcbn07XG5cbi8qKlxuICogQWxpYXMgb2YgW2AuaXNNb2RpZmllZGBdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvZG9jdW1lbnQuaHRtbCNEb2N1bWVudC5wcm90b3R5cGUuaXNNb2RpZmllZCgpKVxuICpcbiAqIEBtZXRob2QgJGlzTW9kaWZpZWRcbiAqIEBtZW1iZXJPZiBEb2N1bWVudFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Eb2N1bWVudC5wcm90b3R5cGUuJGlzTW9kaWZpZWQgPSBEb2N1bWVudC5wcm90b3R5cGUuaXNNb2RpZmllZDtcblxuRG9jdW1lbnQucHJvdG90eXBlW2RvY3VtZW50SXNNb2RpZmllZF0gPSBEb2N1bWVudC5wcm90b3R5cGUuaXNNb2RpZmllZDtcblxuLyoqXG4gKiBDaGVja3MgaWYgYSBwYXRoIGlzIHNldCB0byBpdHMgZGVmYXVsdC5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIE15TW9kZWwgPSBtb25nb29zZS5tb2RlbCgndGVzdCcsIHsgbmFtZTogeyB0eXBlOiBTdHJpbmcsIGRlZmF1bHQ6ICdWYWwgJ30gfSk7XG4gKiAgICAgY29uc3QgbSA9IG5ldyBNeU1vZGVsKCk7XG4gKiAgICAgbS4kaXNEZWZhdWx0KCduYW1lJyk7IC8vIHRydWVcbiAqXG4gKiBAbWVtYmVyT2YgRG9jdW1lbnRcbiAqIEBpbnN0YW5jZVxuICogQG1ldGhvZCAkaXNEZWZhdWx0XG4gKiBAcGFyYW0ge1N0cmluZ30gW3BhdGhdXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Eb2N1bWVudC5wcm90b3R5cGUuJGlzRGVmYXVsdCA9IGZ1bmN0aW9uKHBhdGgpIHtcbiAgaWYgKHBhdGggPT0gbnVsbCkge1xuICAgIHJldHVybiB0aGlzLiRfXy5hY3RpdmVQYXRocy5zb21lKCdkZWZhdWx0Jyk7XG4gIH1cblxuICBpZiAodHlwZW9mIHBhdGggPT09ICdzdHJpbmcnICYmIHBhdGguaW5kZXhPZignICcpID09PSAtMSkge1xuICAgIHJldHVybiB0aGlzLiRfXy5hY3RpdmVQYXRocy5nZXRTdGF0ZVBhdGhzKCdkZWZhdWx0JykuaGFzT3duUHJvcGVydHkocGF0aCk7XG4gIH1cblxuICBsZXQgcGF0aHMgPSBwYXRoO1xuICBpZiAoIUFycmF5LmlzQXJyYXkocGF0aHMpKSB7XG4gICAgcGF0aHMgPSBwYXRocy5zcGxpdCgnICcpO1xuICB9XG5cbiAgcmV0dXJuIHBhdGhzLnNvbWUocGF0aCA9PiB0aGlzLiRfXy5hY3RpdmVQYXRocy5nZXRTdGF0ZVBhdGhzKCdkZWZhdWx0JykuaGFzT3duUHJvcGVydHkocGF0aCkpO1xufTtcblxuLyoqXG4gKiBHZXR0ZXIvc2V0dGVyLCBkZXRlcm1pbmVzIHdoZXRoZXIgdGhlIGRvY3VtZW50IHdhcyByZW1vdmVkIG9yIG5vdC5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IHByb2R1Y3QgPSBhd2FpdCBwcm9kdWN0LnJlbW92ZSgpO1xuICogICAgIHByb2R1Y3QuJGlzRGVsZXRlZCgpOyAvLyB0cnVlXG4gKiAgICAgcHJvZHVjdC5yZW1vdmUoKTsgLy8gbm8tb3AsIGRvZXNuJ3Qgc2VuZCBhbnl0aGluZyB0byB0aGUgZGJcbiAqXG4gKiAgICAgcHJvZHVjdC4kaXNEZWxldGVkKGZhbHNlKTtcbiAqICAgICBwcm9kdWN0LiRpc0RlbGV0ZWQoKTsgLy8gZmFsc2VcbiAqICAgICBwcm9kdWN0LnJlbW92ZSgpOyAvLyB3aWxsIGV4ZWN1dGUgYSByZW1vdmUgYWdhaW5zdCB0aGUgZGJcbiAqXG4gKlxuICogQHBhcmFtIHtCb29sZWFufSBbdmFsXSBvcHRpb25hbCwgb3ZlcnJpZGVzIHdoZXRoZXIgbW9uZ29vc2UgdGhpbmtzIHRoZSBkb2MgaXMgZGVsZXRlZFxuICogQHJldHVybiB7Qm9vbGVhbnxEb2N1bWVudH0gd2hldGhlciBtb25nb29zZSB0aGlua3MgdGhpcyBkb2MgaXMgZGVsZXRlZC5cbiAqIEBtZXRob2QgJGlzRGVsZXRlZFxuICogQG1lbWJlck9mIERvY3VtZW50XG4gKiBAaW5zdGFuY2VcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuRG9jdW1lbnQucHJvdG90eXBlLiRpc0RlbGV0ZWQgPSBmdW5jdGlvbih2YWwpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gISF0aGlzLiRfXy5pc0RlbGV0ZWQ7XG4gIH1cblxuICB0aGlzLiRfXy5pc0RlbGV0ZWQgPSAhIXZhbDtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiBgcGF0aGAgd2FzIGRpcmVjdGx5IHNldCBhbmQgbW9kaWZpZWQsIGVsc2UgZmFsc2UuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBkb2Muc2V0KCdkb2N1bWVudHMuMC50aXRsZScsICdjaGFuZ2VkJyk7XG4gKiAgICAgZG9jLmlzRGlyZWN0TW9kaWZpZWQoJ2RvY3VtZW50cy4wLnRpdGxlJykgLy8gdHJ1ZVxuICogICAgIGRvYy5pc0RpcmVjdE1vZGlmaWVkKCdkb2N1bWVudHMnKSAvLyBmYWxzZVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfFN0cmluZ1tdfSBbcGF0aF1cbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkRvY3VtZW50LnByb3RvdHlwZS5pc0RpcmVjdE1vZGlmaWVkID0gZnVuY3Rpb24ocGF0aCkge1xuICBpZiAocGF0aCA9PSBudWxsKSB7XG4gICAgcmV0dXJuIHRoaXMuJF9fLmFjdGl2ZVBhdGhzLnNvbWUoJ21vZGlmeScpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBwYXRoID09PSAnc3RyaW5nJyAmJiBwYXRoLmluZGV4T2YoJyAnKSA9PT0gLTEpIHtcbiAgICByZXR1cm4gdGhpcy4kX18uYWN0aXZlUGF0aHMuZ2V0U3RhdGVQYXRocygnbW9kaWZ5JykuaGFzT3duUHJvcGVydHkocGF0aCk7XG4gIH1cblxuICBsZXQgcGF0aHMgPSBwYXRoO1xuICBpZiAoIUFycmF5LmlzQXJyYXkocGF0aHMpKSB7XG4gICAgcGF0aHMgPSBwYXRocy5zcGxpdCgnICcpO1xuICB9XG5cbiAgcmV0dXJuIHBhdGhzLnNvbWUocGF0aCA9PiB0aGlzLiRfXy5hY3RpdmVQYXRocy5nZXRTdGF0ZVBhdGhzKCdtb2RpZnknKS5oYXNPd25Qcm9wZXJ0eShwYXRoKSk7XG59O1xuXG4vKipcbiAqIENoZWNrcyBpZiBgcGF0aGAgaXMgaW4gdGhlIGBpbml0YCBzdGF0ZSwgdGhhdCBpcywgaXQgd2FzIHNldCBieSBgRG9jdW1lbnQjaW5pdCgpYCBhbmQgbm90IG1vZGlmaWVkIHNpbmNlLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBbcGF0aF1cbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkRvY3VtZW50LnByb3RvdHlwZS5pc0luaXQgPSBmdW5jdGlvbihwYXRoKSB7XG4gIGlmIChwYXRoID09IG51bGwpIHtcbiAgICByZXR1cm4gdGhpcy4kX18uYWN0aXZlUGF0aHMuc29tZSgnaW5pdCcpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBwYXRoID09PSAnc3RyaW5nJyAmJiBwYXRoLmluZGV4T2YoJyAnKSA9PT0gLTEpIHtcbiAgICByZXR1cm4gdGhpcy4kX18uYWN0aXZlUGF0aHMuZ2V0U3RhdGVQYXRocygnaW5pdCcpLmhhc093blByb3BlcnR5KHBhdGgpO1xuICB9XG5cbiAgbGV0IHBhdGhzID0gcGF0aDtcbiAgaWYgKCFBcnJheS5pc0FycmF5KHBhdGhzKSkge1xuICAgIHBhdGhzID0gcGF0aHMuc3BsaXQoJyAnKTtcbiAgfVxuXG4gIHJldHVybiBwYXRocy5zb21lKHBhdGggPT4gdGhpcy4kX18uYWN0aXZlUGF0aHMuZ2V0U3RhdGVQYXRocygnaW5pdCcpLmhhc093blByb3BlcnR5KHBhdGgpKTtcbn07XG5cbi8qKlxuICogQ2hlY2tzIGlmIGBwYXRoYCB3YXMgc2VsZWN0ZWQgaW4gdGhlIHNvdXJjZSBxdWVyeSB3aGljaCBpbml0aWFsaXplZCB0aGlzIGRvY3VtZW50LlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgY29uc3QgZG9jID0gYXdhaXQgVGhpbmcuZmluZE9uZSgpLnNlbGVjdCgnbmFtZScpO1xuICogICAgIGRvYy5pc1NlbGVjdGVkKCduYW1lJykgLy8gdHJ1ZVxuICogICAgIGRvYy5pc1NlbGVjdGVkKCdhZ2UnKSAgLy8gZmFsc2VcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ3xTdHJpbmdbXX0gcGF0aFxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuRG9jdW1lbnQucHJvdG90eXBlLmlzU2VsZWN0ZWQgPSBmdW5jdGlvbiBpc1NlbGVjdGVkKHBhdGgpIHtcbiAgaWYgKHRoaXMuJF9fLnNlbGVjdGVkID09IG51bGwpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAoIXBhdGgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKHBhdGggPT09ICdfaWQnKSB7XG4gICAgcmV0dXJuIHRoaXMuJF9fLnNlbGVjdGVkLl9pZCAhPT0gMDtcbiAgfVxuXG4gIGlmIChwYXRoLmluZGV4T2YoJyAnKSAhPT0gLTEpIHtcbiAgICBwYXRoID0gcGF0aC5zcGxpdCgnICcpO1xuICB9XG4gIGlmIChBcnJheS5pc0FycmF5KHBhdGgpKSB7XG4gICAgcmV0dXJuIHBhdGguc29tZShwID0+IHRoaXMuJF9faXNTZWxlY3RlZChwKSk7XG4gIH1cblxuICBjb25zdCBwYXRocyA9IE9iamVjdC5rZXlzKHRoaXMuJF9fLnNlbGVjdGVkKTtcbiAgbGV0IGluY2x1c2l2ZSA9IG51bGw7XG5cbiAgaWYgKHBhdGhzLmxlbmd0aCA9PT0gMSAmJiBwYXRoc1swXSA9PT0gJ19pZCcpIHtcbiAgICAvLyBvbmx5IF9pZCB3YXMgc2VsZWN0ZWQuXG4gICAgcmV0dXJuIHRoaXMuJF9fLnNlbGVjdGVkLl9pZCA9PT0gMDtcbiAgfVxuXG4gIGZvciAoY29uc3QgY3VyIG9mIHBhdGhzKSB7XG4gICAgaWYgKGN1ciA9PT0gJ19pZCcpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAoIWlzRGVmaW5pbmdQcm9qZWN0aW9uKHRoaXMuJF9fLnNlbGVjdGVkW2N1cl0pKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaW5jbHVzaXZlID0gISF0aGlzLiRfXy5zZWxlY3RlZFtjdXJdO1xuICAgIGJyZWFrO1xuICB9XG5cbiAgaWYgKGluY2x1c2l2ZSA9PT0gbnVsbCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKHBhdGggaW4gdGhpcy4kX18uc2VsZWN0ZWQpIHtcbiAgICByZXR1cm4gaW5jbHVzaXZlO1xuICB9XG5cbiAgY29uc3QgcGF0aERvdCA9IHBhdGggKyAnLic7XG5cbiAgZm9yIChjb25zdCBjdXIgb2YgcGF0aHMpIHtcbiAgICBpZiAoY3VyID09PSAnX2lkJykge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKGN1ci5zdGFydHNXaXRoKHBhdGhEb3QpKSB7XG4gICAgICByZXR1cm4gaW5jbHVzaXZlIHx8IGN1ciAhPT0gcGF0aERvdDtcbiAgICB9XG5cbiAgICBpZiAocGF0aERvdC5zdGFydHNXaXRoKGN1ciArICcuJykpIHtcbiAgICAgIHJldHVybiBpbmNsdXNpdmU7XG4gICAgfVxuICB9XG4gIHJldHVybiAhaW5jbHVzaXZlO1xufTtcblxuRG9jdW1lbnQucHJvdG90eXBlLiRfX2lzU2VsZWN0ZWQgPSBEb2N1bWVudC5wcm90b3R5cGUuaXNTZWxlY3RlZDtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHBhdGhgIHdhcyBleHBsaWNpdGx5IHNlbGVjdGVkLiBJZiBubyBwcm9qZWN0aW9uLCBhbHdheXMgcmV0dXJuc1xuICogdHJ1ZS5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIFRoaW5nLmZpbmRPbmUoKS5zZWxlY3QoJ25lc3RlZC5uYW1lJykuZXhlYyhmdW5jdGlvbiAoZXJyLCBkb2MpIHtcbiAqICAgICAgICBkb2MuaXNEaXJlY3RTZWxlY3RlZCgnbmVzdGVkLm5hbWUnKSAvLyB0cnVlXG4gKiAgICAgICAgZG9jLmlzRGlyZWN0U2VsZWN0ZWQoJ25lc3RlZC5vdGhlck5hbWUnKSAvLyBmYWxzZVxuICogICAgICAgIGRvYy5pc0RpcmVjdFNlbGVjdGVkKCduZXN0ZWQnKSAgLy8gZmFsc2VcbiAqICAgICB9KVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Eb2N1bWVudC5wcm90b3R5cGUuaXNEaXJlY3RTZWxlY3RlZCA9IGZ1bmN0aW9uIGlzRGlyZWN0U2VsZWN0ZWQocGF0aCkge1xuICBpZiAodGhpcy4kX18uc2VsZWN0ZWQgPT0gbnVsbCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKHBhdGggPT09ICdfaWQnKSB7XG4gICAgcmV0dXJuIHRoaXMuJF9fLnNlbGVjdGVkLl9pZCAhPT0gMDtcbiAgfVxuXG4gIGlmIChwYXRoLmluZGV4T2YoJyAnKSAhPT0gLTEpIHtcbiAgICBwYXRoID0gcGF0aC5zcGxpdCgnICcpO1xuICB9XG4gIGlmIChBcnJheS5pc0FycmF5KHBhdGgpKSB7XG4gICAgcmV0dXJuIHBhdGguc29tZShwID0+IHRoaXMuaXNEaXJlY3RTZWxlY3RlZChwKSk7XG4gIH1cblxuICBjb25zdCBwYXRocyA9IE9iamVjdC5rZXlzKHRoaXMuJF9fLnNlbGVjdGVkKTtcbiAgbGV0IGluY2x1c2l2ZSA9IG51bGw7XG5cbiAgaWYgKHBhdGhzLmxlbmd0aCA9PT0gMSAmJiBwYXRoc1swXSA9PT0gJ19pZCcpIHtcbiAgICAvLyBvbmx5IF9pZCB3YXMgc2VsZWN0ZWQuXG4gICAgcmV0dXJuIHRoaXMuJF9fLnNlbGVjdGVkLl9pZCA9PT0gMDtcbiAgfVxuXG4gIGZvciAoY29uc3QgY3VyIG9mIHBhdGhzKSB7XG4gICAgaWYgKGN1ciA9PT0gJ19pZCcpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAoIWlzRGVmaW5pbmdQcm9qZWN0aW9uKHRoaXMuJF9fLnNlbGVjdGVkW2N1cl0pKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaW5jbHVzaXZlID0gISF0aGlzLiRfXy5zZWxlY3RlZFtjdXJdO1xuICAgIGJyZWFrO1xuICB9XG5cbiAgaWYgKGluY2x1c2l2ZSA9PT0gbnVsbCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKHRoaXMuJF9fLnNlbGVjdGVkLmhhc093blByb3BlcnR5KHBhdGgpKSB7XG4gICAgcmV0dXJuIGluY2x1c2l2ZTtcbiAgfVxuXG4gIHJldHVybiAhaW5jbHVzaXZlO1xufTtcblxuLyoqXG4gKiBFeGVjdXRlcyByZWdpc3RlcmVkIHZhbGlkYXRpb24gcnVsZXMgZm9yIHRoaXMgZG9jdW1lbnQuXG4gKlxuICogIyMjIyBOb3RlOlxuICpcbiAqIFRoaXMgbWV0aG9kIGlzIGNhbGxlZCBgcHJlYCBzYXZlIGFuZCBpZiBhIHZhbGlkYXRpb24gcnVsZSBpcyB2aW9sYXRlZCwgW3NhdmVdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvbW9kZWwuaHRtbCNNb2RlbC5wcm90b3R5cGUuc2F2ZSgpKSBpcyBhYm9ydGVkIGFuZCB0aGUgZXJyb3IgaXMgdGhyb3duLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgYXdhaXQgZG9jLnZhbGlkYXRlKHsgdmFsaWRhdGVNb2RpZmllZE9ubHk6IGZhbHNlLCBwYXRoc1RvU2tpcDogWyduYW1lJywgJ2VtYWlsJ119KTtcbiAqXG4gKiBAcGFyYW0ge0FycmF5fFN0cmluZ30gW3BhdGhzVG9WYWxpZGF0ZV0gbGlzdCBvZiBwYXRocyB0byB2YWxpZGF0ZS4gSWYgc2V0LCBNb25nb29zZSB3aWxsIHZhbGlkYXRlIG9ubHkgdGhlIG1vZGlmaWVkIHBhdGhzIHRoYXQgYXJlIGluIHRoZSBnaXZlbiBsaXN0LlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBpbnRlcm5hbCBvcHRpb25zXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnZhbGlkYXRlTW9kaWZpZWRPbmx5PWZhbHNlXSBpZiBgdHJ1ZWAgbW9uZ29vc2UgdmFsaWRhdGVzIG9ubHkgbW9kaWZpZWQgcGF0aHMuXG4gKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gW29wdGlvbnMucGF0aHNUb1NraXBdIGxpc3Qgb2YgcGF0aHMgdG8gc2tpcC4gSWYgc2V0LCBNb25nb29zZSB3aWxsIHZhbGlkYXRlIGV2ZXJ5IG1vZGlmaWVkIHBhdGggdGhhdCBpcyBub3QgaW4gdGhpcyBsaXN0LlxuICogQHJldHVybiB7UHJvbWlzZX0gUmV0dXJucyBhIFByb21pc2UuXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkRvY3VtZW50LnByb3RvdHlwZS52YWxpZGF0ZSA9IGFzeW5jIGZ1bmN0aW9uIHZhbGlkYXRlKHBhdGhzVG9WYWxpZGF0ZSwgb3B0aW9ucykge1xuICBpZiAodHlwZW9mIHBhdGhzVG9WYWxpZGF0ZSA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgYXJndW1lbnRzWzJdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IE1vbmdvb3NlRXJyb3IoJ0RvY3VtZW50LnByb3RvdHlwZS52YWxpZGF0ZSgpIG5vIGxvbmdlciBhY2NlcHRzIGEgY2FsbGJhY2snKTtcbiAgfVxuICBsZXQgcGFyYWxsZWxWYWxpZGF0ZTtcbiAgdGhpcy4kb3AgPSAndmFsaWRhdGUnO1xuXG4gIGlmICh0aGlzLiRpc1N1YmRvY3VtZW50ICE9IG51bGwpIHtcbiAgICAvLyBTa2lwIHBhcmFsbGVsIHZhbGlkYXRlIGNoZWNrIGZvciBzdWJkb2N1bWVudHNcbiAgfSBlbHNlIGlmICh0aGlzLiRfXy52YWxpZGF0aW5nKSB7XG4gICAgcGFyYWxsZWxWYWxpZGF0ZSA9IG5ldyBQYXJhbGxlbFZhbGlkYXRlRXJyb3IodGhpcywge1xuICAgICAgcGFyZW50U3RhY2s6IG9wdGlvbnMgJiYgb3B0aW9ucy5wYXJlbnRTdGFjayxcbiAgICAgIGNvbmZsaWN0U3RhY2s6IHRoaXMuJF9fLnZhbGlkYXRpbmcuc3RhY2tcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLiRfXy52YWxpZGF0aW5nID0gbmV3IFBhcmFsbGVsVmFsaWRhdGVFcnJvcih0aGlzLCB7IHBhcmVudFN0YWNrOiBvcHRpb25zICYmIG9wdGlvbnMucGFyZW50U3RhY2sgfSk7XG4gIH1cblxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgIGlmICh0eXBlb2YgYXJndW1lbnRzWzBdID09PSAnb2JqZWN0JyAmJiAhQXJyYXkuaXNBcnJheShhcmd1bWVudHNbMF0pKSB7XG4gICAgICBvcHRpb25zID0gYXJndW1lbnRzWzBdO1xuICAgICAgcGF0aHNUb1ZhbGlkYXRlID0gbnVsbDtcbiAgICB9XG4gIH1cbiAgaWYgKG9wdGlvbnMgJiYgdHlwZW9mIG9wdGlvbnMucGF0aHNUb1NraXAgPT09ICdzdHJpbmcnKSB7XG4gICAgY29uc3QgaXNPbmVQYXRoT25seSA9IG9wdGlvbnMucGF0aHNUb1NraXAuaW5kZXhPZignICcpID09PSAtMTtcbiAgICBvcHRpb25zLnBhdGhzVG9Ta2lwID0gaXNPbmVQYXRoT25seSA/IFtvcHRpb25zLnBhdGhzVG9Ta2lwXSA6IG9wdGlvbnMucGF0aHNUb1NraXAuc3BsaXQoJyAnKTtcbiAgfVxuXG4gIGlmIChwYXJhbGxlbFZhbGlkYXRlICE9IG51bGwpIHtcbiAgICB0aHJvdyBwYXJhbGxlbFZhbGlkYXRlO1xuICB9XG5cbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICB0aGlzLiRfX3ZhbGlkYXRlKHBhdGhzVG9WYWxpZGF0ZSwgb3B0aW9ucywgKGVycm9yKSA9PiB7XG4gICAgICB0aGlzLiRvcCA9IG51bGw7XG4gICAgICB0aGlzLiRfXy52YWxpZGF0aW5nID0gbnVsbDtcbiAgICAgIGlmIChlcnJvciAhPSBudWxsKSB7XG4gICAgICAgIHJldHVybiByZWplY3QoZXJyb3IpO1xuICAgICAgfVxuICAgICAgcmVzb2x2ZSgpO1xuICAgIH0pO1xuICB9KTtcbn07XG5cbi8qKlxuICogQWxpYXMgb2YgW2AudmFsaWRhdGVgXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvYXBpL2RvY3VtZW50Lmh0bWwjRG9jdW1lbnQucHJvdG90eXBlLnZhbGlkYXRlKCkpXG4gKlxuICogQG1ldGhvZCAkdmFsaWRhdGVcbiAqIEBtZW1iZXJPZiBEb2N1bWVudFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Eb2N1bWVudC5wcm90b3R5cGUuJHZhbGlkYXRlID0gRG9jdW1lbnQucHJvdG90eXBlLnZhbGlkYXRlO1xuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cbmZ1bmN0aW9uIF9ldmFsdWF0ZVJlcXVpcmVkRnVuY3Rpb25zKGRvYykge1xuICBjb25zdCByZXF1aXJlZEZpZWxkcyA9IE9iamVjdC5rZXlzKGRvYy4kX18uYWN0aXZlUGF0aHMuZ2V0U3RhdGVQYXRocygncmVxdWlyZScpKTtcbiAgbGV0IGkgPSAwO1xuICBjb25zdCBsZW4gPSByZXF1aXJlZEZpZWxkcy5sZW5ndGg7XG4gIGZvciAoaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgIGNvbnN0IHBhdGggPSByZXF1aXJlZEZpZWxkc1tpXTtcblxuICAgIGNvbnN0IHAgPSBkb2MuJF9fc2NoZW1hLnBhdGgocGF0aCk7XG5cbiAgICBpZiAocCAhPSBudWxsICYmIHR5cGVvZiBwLm9yaWdpbmFsUmVxdWlyZWRWYWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgZG9jLiRfXy5jYWNoZWRSZXF1aXJlZCA9IGRvYy4kX18uY2FjaGVkUmVxdWlyZWQgfHwge307XG4gICAgICB0cnkge1xuICAgICAgICBkb2MuJF9fLmNhY2hlZFJlcXVpcmVkW3BhdGhdID0gcC5vcmlnaW5hbFJlcXVpcmVkVmFsdWUuY2FsbChkb2MsIGRvYyk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgZG9jLmludmFsaWRhdGUocGF0aCwgZXJyKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5mdW5jdGlvbiBfZ2V0UGF0aHNUb1ZhbGlkYXRlKGRvYywgcGF0aHNUb1ZhbGlkYXRlLCBwYXRoc1RvU2tpcCkge1xuICBjb25zdCBkb1ZhbGlkYXRlT3B0aW9ucyA9IHt9O1xuXG4gIF9ldmFsdWF0ZVJlcXVpcmVkRnVuY3Rpb25zKGRvYyk7XG4gIC8vIG9ubHkgdmFsaWRhdGUgcmVxdWlyZWQgZmllbGRzIHdoZW4gbmVjZXNzYXJ5XG4gIGxldCBwYXRocyA9IG5ldyBTZXQoT2JqZWN0LmtleXMoZG9jLiRfXy5hY3RpdmVQYXRocy5nZXRTdGF0ZVBhdGhzKCdyZXF1aXJlJykpLmZpbHRlcihmdW5jdGlvbihwYXRoKSB7XG4gICAgaWYgKCFkb2MuJF9faXNTZWxlY3RlZChwYXRoKSAmJiAhZG9jLiRpc01vZGlmaWVkKHBhdGgpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChkb2MuJF9fLmNhY2hlZFJlcXVpcmVkICE9IG51bGwgJiYgcGF0aCBpbiBkb2MuJF9fLmNhY2hlZFJlcXVpcmVkKSB7XG4gICAgICByZXR1cm4gZG9jLiRfXy5jYWNoZWRSZXF1aXJlZFtwYXRoXTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH0pKTtcblxuICBPYmplY3Qua2V5cyhkb2MuJF9fLmFjdGl2ZVBhdGhzLmdldFN0YXRlUGF0aHMoJ2luaXQnKSkuZm9yRWFjaChhZGRUb1BhdGhzKTtcbiAgT2JqZWN0LmtleXMoZG9jLiRfXy5hY3RpdmVQYXRocy5nZXRTdGF0ZVBhdGhzKCdtb2RpZnknKSkuZm9yRWFjaChhZGRUb1BhdGhzKTtcbiAgT2JqZWN0LmtleXMoZG9jLiRfXy5hY3RpdmVQYXRocy5nZXRTdGF0ZVBhdGhzKCdkZWZhdWx0JykpLmZvckVhY2goYWRkVG9QYXRocyk7XG4gIGZ1bmN0aW9uIGFkZFRvUGF0aHMocCkgeyBwYXRocy5hZGQocCk7IH1cblxuICBjb25zdCBzdWJkb2NzID0gZG9jLiRnZXRBbGxTdWJkb2NzKCk7XG4gIGNvbnN0IG1vZGlmaWVkUGF0aHMgPSBkb2MubW9kaWZpZWRQYXRocygpO1xuICBmb3IgKGNvbnN0IHN1YmRvYyBvZiBzdWJkb2NzKSB7XG4gICAgaWYgKHN1YmRvYy4kYmFzZVBhdGgpIHtcbiAgICAgIGNvbnN0IGZ1bGxQYXRoVG9TdWJkb2MgPSBzdWJkb2MuJGlzU2luZ2xlTmVzdGVkID8gc3ViZG9jLiRfX3BhdGhSZWxhdGl2ZVRvUGFyZW50KCkgOiBzdWJkb2MuJF9fZnVsbFBhdGhXaXRoSW5kZXhlcygpO1xuXG4gICAgICAvLyBSZW1vdmUgY2hpbGQgcGF0aHMgZm9yIG5vdywgYmVjYXVzZSB3ZSdsbCBiZSB2YWxpZGF0aW5nIHRoZSB3aG9sZVxuICAgICAgLy8gc3ViZG9jLlxuICAgICAgLy8gVGhlIGZvbGxvd2luZyBpcyBhIGZhc3RlciB0YWtlIG9uIGxvb3BpbmcgdGhyb3VnaCBldmVyeSBwYXRoIGluIGBwYXRoc2BcbiAgICAgIC8vIGFuZCBjaGVja2luZyBpZiB0aGUgcGF0aCBzdGFydHMgd2l0aCBgZnVsbFBhdGhUb1N1YmRvY2AgcmU6IGdoLTEzMTkxXG4gICAgICBmb3IgKGNvbnN0IG1vZGlmaWVkUGF0aCBvZiBzdWJkb2MubW9kaWZpZWRQYXRocygpKSB7XG4gICAgICAgIHBhdGhzLmRlbGV0ZShmdWxsUGF0aFRvU3ViZG9jICsgJy4nICsgbW9kaWZpZWRQYXRoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGRvYy4kaXNNb2RpZmllZChmdWxsUGF0aFRvU3ViZG9jLCBudWxsLCBtb2RpZmllZFBhdGhzKSAmJlxuICAgICAgICAgICAgIWRvYy5pc0RpcmVjdE1vZGlmaWVkKGZ1bGxQYXRoVG9TdWJkb2MpICYmXG4gICAgICAgICAgICAhZG9jLiRpc0RlZmF1bHQoZnVsbFBhdGhUb1N1YmRvYykpIHtcbiAgICAgICAgcGF0aHMuYWRkKGZ1bGxQYXRoVG9TdWJkb2MpO1xuICAgICAgICBpZiAoZG9jLiRfXy5wYXRoc1RvU2NvcGVzID09IG51bGwpIHtcbiAgICAgICAgICBkb2MuJF9fLnBhdGhzVG9TY29wZXMgPSB7fTtcbiAgICAgICAgfVxuICAgICAgICBkb2MuJF9fLnBhdGhzVG9TY29wZXNbZnVsbFBhdGhUb1N1YmRvY10gPSBzdWJkb2MuJGlzRG9jdW1lbnRBcnJheUVsZW1lbnQgP1xuICAgICAgICAgIHN1YmRvYy5fX3BhcmVudEFycmF5IDpcbiAgICAgICAgICBzdWJkb2MuJHBhcmVudCgpO1xuXG4gICAgICAgIGRvVmFsaWRhdGVPcHRpb25zW2Z1bGxQYXRoVG9TdWJkb2NdID0geyBza2lwU2NoZW1hVmFsaWRhdG9yczogdHJ1ZSB9O1xuICAgICAgICBpZiAoc3ViZG9jLiRpc0RvY3VtZW50QXJyYXlFbGVtZW50ICYmIHN1YmRvYy5fX2luZGV4ICE9IG51bGwpIHtcbiAgICAgICAgICBkb1ZhbGlkYXRlT3B0aW9uc1tmdWxsUGF0aFRvU3ViZG9jXS5pbmRleCA9IHN1YmRvYy5fX2luZGV4O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZm9yIChjb25zdCBwYXRoIG9mIHBhdGhzKSB7XG4gICAgY29uc3QgX3BhdGhUeXBlID0gZG9jLiRfX3NjaGVtYS5wYXRoKHBhdGgpO1xuICAgIGlmICghX3BhdGhUeXBlKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAoX3BhdGhUeXBlLiRpc01vbmdvb3NlRG9jdW1lbnRBcnJheSkge1xuICAgICAgZm9yIChjb25zdCBwIG9mIHBhdGhzKSB7XG4gICAgICAgIGlmIChwID09IG51bGwgfHwgcC5zdGFydHNXaXRoKF9wYXRoVHlwZS5wYXRoICsgJy4nKSkge1xuICAgICAgICAgIHBhdGhzLmRlbGV0ZShwKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIE9wdGltaXphdGlvbjogaWYgcHJpbWl0aXZlIHBhdGggd2l0aCBubyB2YWxpZGF0b3JzLCBvciBhcnJheSBvZiBwcmltaXRpdmVzXG4gICAgLy8gd2l0aCBubyB2YWxpZGF0b3JzLCBza2lwIHZhbGlkYXRpbmcgdGhpcyBwYXRoIGVudGlyZWx5LlxuICAgIGlmICghX3BhdGhUeXBlLmNhc3RlciAmJiBfcGF0aFR5cGUudmFsaWRhdG9ycy5sZW5ndGggPT09IDAgJiYgIV9wYXRoVHlwZS4kcGFyZW50U2NoZW1hRG9jQXJyYXkpIHtcbiAgICAgIHBhdGhzLmRlbGV0ZShwYXRoKTtcbiAgICB9IGVsc2UgaWYgKF9wYXRoVHlwZS4kaXNNb25nb29zZUFycmF5ICYmXG4gICAgICAhX3BhdGhUeXBlLiRpc01vbmdvb3NlRG9jdW1lbnRBcnJheSAmJiAvLyBTa2lwIGRvY3VtZW50IGFycmF5cy4uLlxuICAgICAgIV9wYXRoVHlwZS4kZW1iZWRkZWRTY2hlbWFUeXBlLiRpc01vbmdvb3NlQXJyYXkgJiYgLy8gYW5kIGFycmF5cyBvZiBhcnJheXNcbiAgICAgIF9wYXRoVHlwZS52YWxpZGF0b3JzLmxlbmd0aCA9PT0gMCAmJiAvLyBhbmQgYXJyYXlzIHdpdGggdG9wLWxldmVsIHZhbGlkYXRvcnNcbiAgICAgIF9wYXRoVHlwZS4kZW1iZWRkZWRTY2hlbWFUeXBlLnZhbGlkYXRvcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICBwYXRocy5kZWxldGUocGF0aCk7XG4gICAgfVxuICB9XG5cbiAgZm9yIChjb25zdCBwYXRoIG9mIHBhdGhzKSB7XG4gICAgLy8gU2luZ2xlIG5lc3RlZCBwYXRocyAocGF0aHMgZW1iZWRkZWQgdW5kZXIgc2luZ2xlIG5lc3RlZCBzdWJkb2NzKSB3aWxsXG4gICAgLy8gYmUgdmFsaWRhdGVkIG9uIHRoZWlyIG93biB3aGVuIHdlIGNhbGwgYHZhbGlkYXRlKClgIG9uIHRoZSBzdWJkb2MgaXRzZWxmLlxuICAgIC8vIFJlOiBnaC04NDY4XG4gICAgaWYgKGRvYy4kX19zY2hlbWEuc2luZ2xlTmVzdGVkUGF0aHMuaGFzT3duUHJvcGVydHkocGF0aCkpIHtcbiAgICAgIHBhdGhzLmRlbGV0ZShwYXRoKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgfVxuXG4gIGlmIChBcnJheS5pc0FycmF5KHBhdGhzVG9WYWxpZGF0ZSkpIHtcbiAgICBwYXRocyA9IF9oYW5kbGVQYXRoc1RvVmFsaWRhdGUocGF0aHMsIHBhdGhzVG9WYWxpZGF0ZSk7XG4gIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShwYXRoc1RvU2tpcCkpIHtcbiAgICBwYXRocyA9IF9oYW5kbGVQYXRoc1RvU2tpcChwYXRocywgcGF0aHNUb1NraXApO1xuICB9XG5cbiAgLy8gZnJvbSBoZXJlIG9uIHdlJ3JlIG5vdCByZW1vdmluZyBpdGVtcyBmcm9tIHBhdGhzXG5cbiAgLy8gZ2gtNjYxOiBpZiBhIHdob2xlIGFycmF5IGlzIG1vZGlmaWVkLCBtYWtlIHN1cmUgdG8gcnVuIHZhbGlkYXRpb24gb24gYWxsXG4gIC8vIHRoZSBjaGlsZHJlbiBhcyB3ZWxsXG4gIGZvciAoY29uc3QgcGF0aCBvZiBwYXRocykge1xuICAgIGNvbnN0IF9wYXRoVHlwZSA9IGRvYy4kX19zY2hlbWEucGF0aChwYXRoKTtcbiAgICBpZiAoIV9wYXRoVHlwZSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKCFfcGF0aFR5cGUuJGlzTW9uZ29vc2VBcnJheSB8fFxuICAgICAgICAvLyBUbyBhdm9pZCBwb3RlbnRpYWwgcGVyZm9ybWFuY2UgaXNzdWVzLCBza2lwIGRvYyBhcnJheXMgd2hvc2UgY2hpbGRyZW5cbiAgICAgICAgLy8gYXJlIG5vdCByZXF1aXJlZC4gYGdldFBvc2l0aW9uYWxQYXRoVHlwZSgpYCBtYXkgYmUgc2xvdywgc28gYXZvaWRcbiAgICAgICAgLy8gaXQgdW5sZXNzIHdlIGhhdmUgYSBjYXNlIG9mICM2MzY0XG4gICAgICAgICghQXJyYXkuaXNBcnJheShfcGF0aFR5cGUpICYmXG4gICAgICAgICAgX3BhdGhUeXBlLiRpc01vbmdvb3NlRG9jdW1lbnRBcnJheSAmJlxuICAgICAgICAgICEoX3BhdGhUeXBlICYmIF9wYXRoVHlwZS5zY2hlbWFPcHRpb25zICYmIF9wYXRoVHlwZS5zY2hlbWFPcHRpb25zLnJlcXVpcmVkKSkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIGdoLTExMzgwOiBvcHRpbWl6YXRpb24uIElmIHRoZSBhcnJheSBpc24ndCBhIGRvY3VtZW50IGFycmF5IGFuZCB0aGVyZSdzIG5vIHZhbGlkYXRvcnNcbiAgICAvLyBvbiB0aGUgYXJyYXkgdHlwZSwgdGhlcmUncyBubyBuZWVkIHRvIHJ1biB2YWxpZGF0aW9uIG9uIHRoZSBpbmRpdmlkdWFsIGFycmF5IGVsZW1lbnRzLlxuICAgIGlmIChfcGF0aFR5cGUuJGlzTW9uZ29vc2VBcnJheSAmJlxuICAgICAgICAhX3BhdGhUeXBlLiRpc01vbmdvb3NlRG9jdW1lbnRBcnJheSAmJiAvLyBTa2lwIGRvY3VtZW50IGFycmF5cy4uLlxuICAgICAgICAhX3BhdGhUeXBlLiRlbWJlZGRlZFNjaGVtYVR5cGUuJGlzTW9uZ29vc2VBcnJheSAmJiAvLyBhbmQgYXJyYXlzIG9mIGFycmF5c1xuICAgICAgICBfcGF0aFR5cGUuJGVtYmVkZGVkU2NoZW1hVHlwZS52YWxpZGF0b3JzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgY29uc3QgdmFsID0gZG9jLiRfX2dldFZhbHVlKHBhdGgpO1xuICAgIF9wdXNoTmVzdGVkQXJyYXlQYXRocyh2YWwsIHBhdGhzLCBwYXRoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9wdXNoTmVzdGVkQXJyYXlQYXRocyh2YWwsIHBhdGhzLCBwYXRoKSB7XG4gICAgaWYgKHZhbCAhPSBudWxsKSB7XG4gICAgICBjb25zdCBudW1FbGVtZW50cyA9IHZhbC5sZW5ndGg7XG4gICAgICBmb3IgKGxldCBqID0gMDsgaiA8IG51bUVsZW1lbnRzOyArK2opIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsW2pdKSkge1xuICAgICAgICAgIF9wdXNoTmVzdGVkQXJyYXlQYXRocyh2YWxbal0sIHBhdGhzLCBwYXRoICsgJy4nICsgaik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGF0aHMuYWRkKHBhdGggKyAnLicgKyBqKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGNvbnN0IGZsYXR0ZW5PcHRpb25zID0geyBza2lwQXJyYXlzOiB0cnVlIH07XG4gIGZvciAoY29uc3QgcGF0aFRvQ2hlY2sgb2YgcGF0aHMpIHtcbiAgICBpZiAoZG9jLiRfX3NjaGVtYS5uZXN0ZWRbcGF0aFRvQ2hlY2tdKSB7XG4gICAgICBsZXQgX3YgPSBkb2MuJF9fZ2V0VmFsdWUocGF0aFRvQ2hlY2spO1xuICAgICAgaWYgKGlzTW9uZ29vc2VPYmplY3QoX3YpKSB7XG4gICAgICAgIF92ID0gX3YudG9PYmplY3QoeyB0cmFuc2Zvcm06IGZhbHNlIH0pO1xuICAgICAgfVxuICAgICAgY29uc3QgZmxhdCA9IGZsYXR0ZW4oX3YsIHBhdGhUb0NoZWNrLCBmbGF0dGVuT3B0aW9ucywgZG9jLiRfX3NjaGVtYSk7XG4gICAgICBPYmplY3Qua2V5cyhmbGF0KS5mb3JFYWNoKGFkZFRvUGF0aHMpO1xuICAgIH1cbiAgfVxuXG4gIGZvciAoY29uc3QgcGF0aCBvZiBwYXRocykge1xuICAgIGNvbnN0IF9wYXRoVHlwZSA9IGRvYy4kX19zY2hlbWEucGF0aChwYXRoKTtcblxuICAgIGlmICghX3BhdGhUeXBlKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyBJZiB1bmRlcm5lYXRoIGEgZG9jdW1lbnQgYXJyYXksIG1heSBuZWVkIHRvIHJlLXZhbGlkYXRlIHRoZSBwYXJlbnRcbiAgICAvLyBhcnJheSByZTogZ2gtNjgxOC4gRG8gdGhpcyBfYWZ0ZXJfIGFkZGluZyBzdWJwYXRocywgYmVjYXVzZVxuICAgIC8vIHdlIGRvbid0IHdhbnQgdG8gYWRkIGV2ZXJ5IGFycmF5IHN1YnBhdGguXG4gICAgaWYgKF9wYXRoVHlwZS4kcGFyZW50U2NoZW1hRG9jQXJyYXkgJiYgdHlwZW9mIF9wYXRoVHlwZS4kcGFyZW50U2NoZW1hRG9jQXJyYXkucGF0aCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHBhdGhzLmFkZChfcGF0aFR5cGUuJHBhcmVudFNjaGVtYURvY0FycmF5LnBhdGgpO1xuICAgIH1cblxuICAgIGlmICghX3BhdGhUeXBlLiRpc1NjaGVtYU1hcCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgY29uc3QgdmFsID0gZG9jLiRfX2dldFZhbHVlKHBhdGgpO1xuICAgIGlmICh2YWwgPT0gbnVsbCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGZvciAoY29uc3Qga2V5IG9mIHZhbC5rZXlzKCkpIHtcbiAgICAgIHBhdGhzLmFkZChwYXRoICsgJy4nICsga2V5KTtcbiAgICB9XG4gIH1cblxuICBwYXRocyA9IEFycmF5LmZyb20ocGF0aHMpO1xuICByZXR1cm4gW3BhdGhzLCBkb1ZhbGlkYXRlT3B0aW9uc107XG59XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxuRG9jdW1lbnQucHJvdG90eXBlLiRfX3ZhbGlkYXRlID0gZnVuY3Rpb24ocGF0aHNUb1ZhbGlkYXRlLCBvcHRpb25zLCBjYWxsYmFjaykge1xuICBpZiAodHlwZW9mIHBhdGhzVG9WYWxpZGF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNhbGxiYWNrID0gcGF0aHNUb1ZhbGlkYXRlO1xuICAgIG9wdGlvbnMgPSBudWxsO1xuICAgIHBhdGhzVG9WYWxpZGF0ZSA9IG51bGw7XG4gIH0gZWxzZSBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYWxsYmFjayA9IG9wdGlvbnM7XG4gICAgb3B0aW9ucyA9IG51bGw7XG4gIH1cblxuICBjb25zdCBoYXNWYWxpZGF0ZU1vZGlmaWVkT25seU9wdGlvbiA9IG9wdGlvbnMgJiZcbiAgICAgICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ29iamVjdCcpICYmXG4gICAgICAoJ3ZhbGlkYXRlTW9kaWZpZWRPbmx5JyBpbiBvcHRpb25zKTtcblxuICBjb25zdCBwYXRoc1RvU2tpcCA9IChvcHRpb25zICYmIG9wdGlvbnMucGF0aHNUb1NraXApIHx8IG51bGw7XG5cbiAgbGV0IHNob3VsZFZhbGlkYXRlTW9kaWZpZWRPbmx5O1xuICBpZiAoaGFzVmFsaWRhdGVNb2RpZmllZE9ubHlPcHRpb24pIHtcbiAgICBzaG91bGRWYWxpZGF0ZU1vZGlmaWVkT25seSA9ICEhb3B0aW9ucy52YWxpZGF0ZU1vZGlmaWVkT25seTtcbiAgfSBlbHNlIHtcbiAgICBzaG91bGRWYWxpZGF0ZU1vZGlmaWVkT25seSA9IHRoaXMuJF9fc2NoZW1hLm9wdGlvbnMudmFsaWRhdGVNb2RpZmllZE9ubHk7XG4gIH1cblxuICBjb25zdCBfdGhpcyA9IHRoaXM7XG4gIGNvbnN0IF9jb21wbGV0ZSA9ICgpID0+IHtcbiAgICBsZXQgdmFsaWRhdGlvbkVycm9yID0gdGhpcy4kX18udmFsaWRhdGlvbkVycm9yO1xuICAgIHRoaXMuJF9fLnZhbGlkYXRpb25FcnJvciA9IG51bGw7XG4gICAgdGhpcy4kX18udmFsaWRhdGluZyA9IG51bGw7XG5cbiAgICBpZiAoc2hvdWxkVmFsaWRhdGVNb2RpZmllZE9ubHkgJiYgdmFsaWRhdGlvbkVycm9yICE9IG51bGwpIHtcbiAgICAgIC8vIFJlbW92ZSBhbnkgdmFsaWRhdGlvbiBlcnJvcnMgdGhhdCBhcmVuJ3QgZnJvbSBtb2RpZmllZCBwYXRoc1xuICAgICAgY29uc3QgZXJyb3JzID0gT2JqZWN0LmtleXModmFsaWRhdGlvbkVycm9yLmVycm9ycyk7XG4gICAgICBmb3IgKGNvbnN0IGVyclBhdGggb2YgZXJyb3JzKSB7XG4gICAgICAgIGlmICghdGhpcy4kaXNNb2RpZmllZChlcnJQYXRoKSkge1xuICAgICAgICAgIGRlbGV0ZSB2YWxpZGF0aW9uRXJyb3IuZXJyb3JzW2VyclBhdGhdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoT2JqZWN0LmtleXModmFsaWRhdGlvbkVycm9yLmVycm9ycykubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHZhbGlkYXRpb25FcnJvciA9IHZvaWQgMDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLiRfXy5jYWNoZWRSZXF1aXJlZCA9IHt9O1xuICAgIHRoaXMuJGVtaXQoJ3ZhbGlkYXRlJywgX3RoaXMpO1xuICAgIHRoaXMuY29uc3RydWN0b3IuZW1pdCgndmFsaWRhdGUnLCBfdGhpcyk7XG5cbiAgICBpZiAodmFsaWRhdGlvbkVycm9yKSB7XG4gICAgICBmb3IgKGNvbnN0IGtleSBpbiB2YWxpZGF0aW9uRXJyb3IuZXJyb3JzKSB7XG4gICAgICAgIC8vIE1ha2Ugc3VyZSBjYXN0IGVycm9ycyBwZXJzaXN0XG4gICAgICAgIGlmICghdGhpc1tkb2N1bWVudEFycmF5UGFyZW50XSAmJlxuICAgICAgICAgICAgdmFsaWRhdGlvbkVycm9yLmVycm9yc1trZXldIGluc3RhbmNlb2YgTW9uZ29vc2VFcnJvci5DYXN0RXJyb3IpIHtcbiAgICAgICAgICB0aGlzLmludmFsaWRhdGUoa2V5LCB2YWxpZGF0aW9uRXJyb3IuZXJyb3JzW2tleV0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB2YWxpZGF0aW9uRXJyb3I7XG4gICAgfVxuICB9O1xuXG4gIC8vIG9ubHkgdmFsaWRhdGUgcmVxdWlyZWQgZmllbGRzIHdoZW4gbmVjZXNzYXJ5XG4gIGNvbnN0IHBhdGhEZXRhaWxzID0gX2dldFBhdGhzVG9WYWxpZGF0ZSh0aGlzLCBwYXRoc1RvVmFsaWRhdGUsIHBhdGhzVG9Ta2lwKTtcbiAgY29uc3QgcGF0aHMgPSBzaG91bGRWYWxpZGF0ZU1vZGlmaWVkT25seSA/XG4gICAgcGF0aERldGFpbHNbMF0uZmlsdGVyKChwYXRoKSA9PiB0aGlzLiRpc01vZGlmaWVkKHBhdGgpKSA6XG4gICAgcGF0aERldGFpbHNbMF07XG4gIGNvbnN0IGRvVmFsaWRhdGVPcHRpb25zQnlQYXRoID0gcGF0aERldGFpbHNbMV07XG4gIGlmICh0eXBlb2YgcGF0aHNUb1ZhbGlkYXRlID09PSAnc3RyaW5nJykge1xuICAgIHBhdGhzVG9WYWxpZGF0ZSA9IHBhdGhzVG9WYWxpZGF0ZS5zcGxpdCgnICcpO1xuICB9XG5cbiAgaWYgKHBhdGhzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBpbW1lZGlhdGUoZnVuY3Rpb24oKSB7XG4gICAgICBjb25zdCBlcnJvciA9IF9jb21wbGV0ZSgpO1xuICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgIHJldHVybiBfdGhpcy4kX19zY2hlbWEucy5ob29rcy5leGVjUG9zdCgndmFsaWRhdGU6ZXJyb3InLCBfdGhpcywgW190aGlzXSwgeyBlcnJvcjogZXJyb3IgfSwgZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAgICAgICBjYWxsYmFjayhlcnJvcik7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgY2FsbGJhY2sobnVsbCwgX3RoaXMpO1xuICAgIH0pO1xuICB9XG5cbiAgY29uc3QgdmFsaWRhdGVkID0ge307XG4gIGxldCB0b3RhbCA9IDA7XG5cbiAgZm9yIChjb25zdCBwYXRoIG9mIHBhdGhzKSB7XG4gICAgdmFsaWRhdGVQYXRoKHBhdGgpO1xuICB9XG5cbiAgZnVuY3Rpb24gdmFsaWRhdGVQYXRoKHBhdGgpIHtcbiAgICBpZiAocGF0aCA9PSBudWxsIHx8IHZhbGlkYXRlZFtwYXRoXSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhbGlkYXRlZFtwYXRoXSA9IHRydWU7XG4gICAgdG90YWwrKztcblxuICAgIGltbWVkaWF0ZShmdW5jdGlvbigpIHtcbiAgICAgIGNvbnN0IHNjaGVtYVR5cGUgPSBfdGhpcy4kX19zY2hlbWEucGF0aChwYXRoKTtcblxuICAgICAgaWYgKCFzY2hlbWFUeXBlKSB7XG4gICAgICAgIHJldHVybiAtLXRvdGFsIHx8IGNvbXBsZXRlKCk7XG4gICAgICB9XG5cbiAgICAgIC8vIElmIHVzZXIgbWFya2VkIGFzIGludmFsaWQgb3IgdGhlcmUgd2FzIGEgY2FzdCBlcnJvciwgZG9uJ3QgdmFsaWRhdGVcbiAgICAgIGlmICghX3RoaXMuJGlzVmFsaWQocGF0aCkpIHtcbiAgICAgICAgLS10b3RhbCB8fCBjb21wbGV0ZSgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIElmIHNldHRpbmcgYSBwYXRoIHVuZGVyIGEgbWl4ZWQgcGF0aCwgYXZvaWQgdXNpbmcgdGhlIG1peGVkIHBhdGggdmFsaWRhdG9yIChnaC0xMDE0MSlcbiAgICAgIGlmIChzY2hlbWFUeXBlW3NjaGVtYU1peGVkU3ltYm9sXSAhPSBudWxsICYmIHBhdGggIT09IHNjaGVtYVR5cGUucGF0aCkge1xuICAgICAgICByZXR1cm4gLS10b3RhbCB8fCBjb21wbGV0ZSgpO1xuICAgICAgfVxuXG4gICAgICBsZXQgdmFsID0gX3RoaXMuJF9fZ2V0VmFsdWUocGF0aCk7XG5cbiAgICAgIC8vIElmIHlvdSBgcG9wdWxhdGUoKWAgYW5kIGdldCBiYWNrIGEgbnVsbCB2YWx1ZSwgcmVxdWlyZWQgdmFsaWRhdG9yc1xuICAgICAgLy8gc2hvdWxkbid0IGZhaWwgKGdoLTgwMTgpLiBXZSBzaG91bGQgYWx3YXlzIGZhbGwgYmFjayB0byB0aGUgcG9wdWxhdGVkXG4gICAgICAvLyB2YWx1ZS5cbiAgICAgIGxldCBwb3A7XG4gICAgICBpZiAoKHBvcCA9IF90aGlzLiRwb3B1bGF0ZWQocGF0aCkpKSB7XG4gICAgICAgIHZhbCA9IHBvcDtcbiAgICAgIH0gZWxzZSBpZiAodmFsICE9IG51bGwgJiYgdmFsLiRfXyAhPSBudWxsICYmIHZhbC4kX18ud2FzUG9wdWxhdGVkKSB7XG4gICAgICAgIC8vIEFycmF5IHBhdGhzLCBsaWtlIGBzb21lYXJyYXkuMWAsIGRvIG5vdCBzaG93IHVwIGFzIHBvcHVsYXRlZCB3aXRoIGAkcG9wdWxhdGVkKClgLFxuICAgICAgICAvLyBzbyBpbiB0aGF0IGNhc2UgcHVsbCBvdXQgdGhlIGRvY3VtZW50J3MgaWRcbiAgICAgICAgdmFsID0gdmFsLl9pZDtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHNjb3BlID0gX3RoaXMuJF9fLnBhdGhzVG9TY29wZXMgIT0gbnVsbCAmJiBwYXRoIGluIF90aGlzLiRfXy5wYXRoc1RvU2NvcGVzID9cbiAgICAgICAgX3RoaXMuJF9fLnBhdGhzVG9TY29wZXNbcGF0aF0gOlxuICAgICAgICBfdGhpcztcblxuICAgICAgY29uc3QgZG9WYWxpZGF0ZU9wdGlvbnMgPSB7XG4gICAgICAgIC4uLmRvVmFsaWRhdGVPcHRpb25zQnlQYXRoW3BhdGhdLFxuICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICB2YWxpZGF0ZU1vZGlmaWVkT25seTogc2hvdWxkVmFsaWRhdGVNb2RpZmllZE9ubHlcbiAgICAgIH07XG5cbiAgICAgIHNjaGVtYVR5cGUuZG9WYWxpZGF0ZSh2YWwsIGZ1bmN0aW9uKGVycikge1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgY29uc3QgaXNTdWJkb2MgPSBzY2hlbWFUeXBlLiRpc1NpbmdsZU5lc3RlZCB8fFxuICAgICAgICAgICAgICBzY2hlbWFUeXBlLiRpc0FycmF5U3ViZG9jdW1lbnQgfHxcbiAgICAgICAgICAgICAgc2NoZW1hVHlwZS4kaXNNb25nb29zZURvY3VtZW50QXJyYXk7XG4gICAgICAgICAgaWYgKGlzU3ViZG9jICYmIGVyciBpbnN0YW5jZW9mIFZhbGlkYXRpb25FcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIC0tdG90YWwgfHwgY29tcGxldGUoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgX3RoaXMuaW52YWxpZGF0ZShwYXRoLCBlcnIsIHVuZGVmaW5lZCwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgLS10b3RhbCB8fCBjb21wbGV0ZSgpO1xuICAgICAgfSwgc2NvcGUsIGRvVmFsaWRhdGVPcHRpb25zKTtcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbXBsZXRlKCkge1xuICAgIGNvbnN0IGVycm9yID0gX2NvbXBsZXRlKCk7XG4gICAgaWYgKGVycm9yKSB7XG4gICAgICByZXR1cm4gX3RoaXMuJF9fc2NoZW1hLnMuaG9va3MuZXhlY1Bvc3QoJ3ZhbGlkYXRlOmVycm9yJywgX3RoaXMsIFtfdGhpc10sIHsgZXJyb3I6IGVycm9yIH0sIGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgICAgIGNhbGxiYWNrKGVycm9yKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBjYWxsYmFjayhudWxsLCBfdGhpcyk7XG4gIH1cblxufTtcblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5mdW5jdGlvbiBfaGFuZGxlUGF0aHNUb1ZhbGlkYXRlKHBhdGhzLCBwYXRoc1RvVmFsaWRhdGUpIHtcbiAgY29uc3QgX3BhdGhzVG9WYWxpZGF0ZSA9IG5ldyBTZXQocGF0aHNUb1ZhbGlkYXRlKTtcbiAgY29uc3QgcGFyZW50UGF0aHMgPSBuZXcgTWFwKFtdKTtcbiAgZm9yIChjb25zdCBwYXRoIG9mIHBhdGhzVG9WYWxpZGF0ZSkge1xuICAgIGlmIChwYXRoLmluZGV4T2YoJy4nKSA9PT0gLTEpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBjb25zdCBwaWVjZXMgPSBwYXRoLnNwbGl0KCcuJyk7XG4gICAgbGV0IGN1ciA9IHBpZWNlc1swXTtcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IHBpZWNlcy5sZW5ndGg7ICsraSkge1xuICAgICAgLy8gU2luY2Ugd2Ugc2tpcCBzdWJwYXRocyB1bmRlciBzaW5nbGUgbmVzdGVkIHN1YmRvY3MgdG9cbiAgICAgIC8vIGF2b2lkIGRvdWJsZSB2YWxpZGF0aW9uLCB3ZSBuZWVkIHRvIGFkZCBiYWNrIHRoZVxuICAgICAgLy8gc2luZ2xlIG5lc3RlZCBzdWJwYXRoIGlmIHRoZSB1c2VyIGFza2VkIGZvciBpdCAoZ2gtODYyNilcbiAgICAgIHBhcmVudFBhdGhzLnNldChjdXIsIHBhdGgpO1xuICAgICAgY3VyID0gY3VyICsgJy4nICsgcGllY2VzW2ldO1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0IHJldCA9IG5ldyBTZXQoKTtcbiAgZm9yIChjb25zdCBwYXRoIG9mIHBhdGhzKSB7XG4gICAgaWYgKF9wYXRoc1RvVmFsaWRhdGUuaGFzKHBhdGgpKSB7XG4gICAgICByZXQuYWRkKHBhdGgpO1xuICAgIH0gZWxzZSBpZiAocGFyZW50UGF0aHMuaGFzKHBhdGgpKSB7XG4gICAgICByZXQuYWRkKHBhcmVudFBhdGhzLmdldChwYXRoKSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXQ7XG59XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxuZnVuY3Rpb24gX2hhbmRsZVBhdGhzVG9Ta2lwKHBhdGhzLCBwYXRoc1RvU2tpcCkge1xuICBwYXRoc1RvU2tpcCA9IG5ldyBTZXQocGF0aHNUb1NraXApO1xuICBwYXRocyA9IEFycmF5LmZyb20ocGF0aHMpLmZpbHRlcihwID0+ICFwYXRoc1RvU2tpcC5oYXMocCkpO1xuICByZXR1cm4gbmV3IFNldChwYXRocyk7XG59XG5cbi8qKlxuICogRXhlY3V0ZXMgcmVnaXN0ZXJlZCB2YWxpZGF0aW9uIHJ1bGVzIChza2lwcGluZyBhc3luY2hyb25vdXMgdmFsaWRhdG9ycykgZm9yIHRoaXMgZG9jdW1lbnQuXG4gKlxuICogIyMjIyBOb3RlOlxuICpcbiAqIFRoaXMgbWV0aG9kIGlzIHVzZWZ1bCBpZiB5b3UgbmVlZCBzeW5jaHJvbm91cyB2YWxpZGF0aW9uLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgY29uc3QgZXJyID0gZG9jLnZhbGlkYXRlU3luYygpO1xuICogICAgIGlmIChlcnIpIHtcbiAqICAgICAgIGhhbmRsZUVycm9yKGVycik7XG4gKiAgICAgfSBlbHNlIHtcbiAqICAgICAgIC8vIHZhbGlkYXRpb24gcGFzc2VkXG4gKiAgICAgfVxuICpcbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBbcGF0aHNUb1ZhbGlkYXRlXSBvbmx5IHZhbGlkYXRlIHRoZSBnaXZlbiBwYXRoc1xuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBvcHRpb25zIGZvciB2YWxpZGF0aW9uXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnZhbGlkYXRlTW9kaWZpZWRPbmx5PWZhbHNlXSBJZiBgdHJ1ZWAsIE1vbmdvb3NlIHdpbGwgb25seSB2YWxpZGF0ZSBtb2RpZmllZCBwYXRocywgYXMgb3Bwb3NlZCB0byBtb2RpZmllZCBwYXRocyBhbmQgYHJlcXVpcmVkYCBwYXRocy5cbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBbb3B0aW9ucy5wYXRoc1RvU2tpcF0gbGlzdCBvZiBwYXRocyB0byBza2lwLiBJZiBzZXQsIE1vbmdvb3NlIHdpbGwgdmFsaWRhdGUgZXZlcnkgbW9kaWZpZWQgcGF0aCB0aGF0IGlzIG5vdCBpbiB0aGlzIGxpc3QuXG4gKiBAcmV0dXJuIHtWYWxpZGF0aW9uRXJyb3J8dW5kZWZpbmVkfSBWYWxpZGF0aW9uRXJyb3IgaWYgdGhlcmUgYXJlIGVycm9ycyBkdXJpbmcgdmFsaWRhdGlvbiwgb3IgdW5kZWZpbmVkIGlmIHRoZXJlIGlzIG5vIGVycm9yLlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Eb2N1bWVudC5wcm90b3R5cGUudmFsaWRhdGVTeW5jID0gZnVuY3Rpb24ocGF0aHNUb1ZhbGlkYXRlLCBvcHRpb25zKSB7XG4gIGNvbnN0IF90aGlzID0gdGhpcztcblxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSAmJiB0eXBlb2YgYXJndW1lbnRzWzBdID09PSAnb2JqZWN0JyAmJiAhQXJyYXkuaXNBcnJheShhcmd1bWVudHNbMF0pKSB7XG4gICAgb3B0aW9ucyA9IGFyZ3VtZW50c1swXTtcbiAgICBwYXRoc1RvVmFsaWRhdGUgPSBudWxsO1xuICB9XG5cbiAgY29uc3QgaGFzVmFsaWRhdGVNb2RpZmllZE9ubHlPcHRpb24gPSBvcHRpb25zICYmXG4gICAgICAodHlwZW9mIG9wdGlvbnMgPT09ICdvYmplY3QnKSAmJlxuICAgICAgKCd2YWxpZGF0ZU1vZGlmaWVkT25seScgaW4gb3B0aW9ucyk7XG5cbiAgbGV0IHNob3VsZFZhbGlkYXRlTW9kaWZpZWRPbmx5O1xuICBpZiAoaGFzVmFsaWRhdGVNb2RpZmllZE9ubHlPcHRpb24pIHtcbiAgICBzaG91bGRWYWxpZGF0ZU1vZGlmaWVkT25seSA9ICEhb3B0aW9ucy52YWxpZGF0ZU1vZGlmaWVkT25seTtcbiAgfSBlbHNlIHtcbiAgICBzaG91bGRWYWxpZGF0ZU1vZGlmaWVkT25seSA9IHRoaXMuJF9fc2NoZW1hLm9wdGlvbnMudmFsaWRhdGVNb2RpZmllZE9ubHk7XG4gIH1cblxuICBsZXQgcGF0aHNUb1NraXAgPSBvcHRpb25zICYmIG9wdGlvbnMucGF0aHNUb1NraXA7XG5cbiAgaWYgKHR5cGVvZiBwYXRoc1RvVmFsaWRhdGUgPT09ICdzdHJpbmcnKSB7XG4gICAgY29uc3QgaXNPbmVQYXRoT25seSA9IHBhdGhzVG9WYWxpZGF0ZS5pbmRleE9mKCcgJykgPT09IC0xO1xuICAgIHBhdGhzVG9WYWxpZGF0ZSA9IGlzT25lUGF0aE9ubHkgPyBbcGF0aHNUb1ZhbGlkYXRlXSA6IHBhdGhzVG9WYWxpZGF0ZS5zcGxpdCgnICcpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBwYXRoc1RvU2tpcCA9PT0gJ3N0cmluZycgJiYgcGF0aHNUb1NraXAuaW5kZXhPZignICcpICE9PSAtMSkge1xuICAgIHBhdGhzVG9Ta2lwID0gcGF0aHNUb1NraXAuc3BsaXQoJyAnKTtcbiAgfVxuXG4gIC8vIG9ubHkgdmFsaWRhdGUgcmVxdWlyZWQgZmllbGRzIHdoZW4gbmVjZXNzYXJ5XG4gIGNvbnN0IHBhdGhEZXRhaWxzID0gX2dldFBhdGhzVG9WYWxpZGF0ZSh0aGlzLCBwYXRoc1RvVmFsaWRhdGUsIHBhdGhzVG9Ta2lwKTtcbiAgY29uc3QgcGF0aHMgPSBzaG91bGRWYWxpZGF0ZU1vZGlmaWVkT25seSA/XG4gICAgcGF0aERldGFpbHNbMF0uZmlsdGVyKChwYXRoKSA9PiB0aGlzLiRpc01vZGlmaWVkKHBhdGgpKSA6XG4gICAgcGF0aERldGFpbHNbMF07XG4gIGNvbnN0IHNraXBTY2hlbWFWYWxpZGF0b3JzID0gcGF0aERldGFpbHNbMV07XG5cbiAgY29uc3QgdmFsaWRhdGluZyA9IHt9O1xuXG4gIGZvciAobGV0IGkgPSAwLCBsZW4gPSBwYXRocy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgIGNvbnN0IHBhdGggPSBwYXRoc1tpXTtcblxuICAgIGlmICh2YWxpZGF0aW5nW3BhdGhdKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICB2YWxpZGF0aW5nW3BhdGhdID0gdHJ1ZTtcblxuICAgIGNvbnN0IHAgPSBfdGhpcy4kX19zY2hlbWEucGF0aChwYXRoKTtcbiAgICBpZiAoIXApIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAoIV90aGlzLiRpc1ZhbGlkKHBhdGgpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBjb25zdCB2YWwgPSBfdGhpcy4kX19nZXRWYWx1ZShwYXRoKTtcbiAgICBjb25zdCBlcnIgPSBwLmRvVmFsaWRhdGVTeW5jKHZhbCwgX3RoaXMsIHtcbiAgICAgIHNraXBTY2hlbWFWYWxpZGF0b3JzOiBza2lwU2NoZW1hVmFsaWRhdG9yc1twYXRoXSxcbiAgICAgIHBhdGg6IHBhdGgsXG4gICAgICB2YWxpZGF0ZU1vZGlmaWVkT25seTogc2hvdWxkVmFsaWRhdGVNb2RpZmllZE9ubHlcbiAgICB9KTtcbiAgICBpZiAoZXJyKSB7XG4gICAgICBjb25zdCBpc1N1YmRvYyA9IHAuJGlzU2luZ2xlTmVzdGVkIHx8XG4gICAgICAgIHAuJGlzQXJyYXlTdWJkb2N1bWVudCB8fFxuICAgICAgICBwLiRpc01vbmdvb3NlRG9jdW1lbnRBcnJheTtcbiAgICAgIGlmIChpc1N1YmRvYyAmJiBlcnIgaW5zdGFuY2VvZiBWYWxpZGF0aW9uRXJyb3IpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBfdGhpcy5pbnZhbGlkYXRlKHBhdGgsIGVyciwgdW5kZWZpbmVkLCB0cnVlKTtcbiAgICB9XG4gIH1cblxuICBjb25zdCBlcnIgPSBfdGhpcy4kX18udmFsaWRhdGlvbkVycm9yO1xuICBfdGhpcy4kX18udmFsaWRhdGlvbkVycm9yID0gdW5kZWZpbmVkO1xuICBfdGhpcy4kZW1pdCgndmFsaWRhdGUnLCBfdGhpcyk7XG4gIF90aGlzLmNvbnN0cnVjdG9yLmVtaXQoJ3ZhbGlkYXRlJywgX3RoaXMpO1xuXG4gIGlmIChlcnIpIHtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBlcnIuZXJyb3JzKSB7XG4gICAgICAvLyBNYWtlIHN1cmUgY2FzdCBlcnJvcnMgcGVyc2lzdFxuICAgICAgaWYgKGVyci5lcnJvcnNba2V5XSBpbnN0YW5jZW9mIE1vbmdvb3NlRXJyb3IuQ2FzdEVycm9yKSB7XG4gICAgICAgIF90aGlzLmludmFsaWRhdGUoa2V5LCBlcnIuZXJyb3JzW2tleV0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBlcnI7XG59O1xuXG4vKipcbiAqIE1hcmtzIGEgcGF0aCBhcyBpbnZhbGlkLCBjYXVzaW5nIHZhbGlkYXRpb24gdG8gZmFpbC5cbiAqXG4gKiBUaGUgYGVycm9yTXNnYCBhcmd1bWVudCB3aWxsIGJlY29tZSB0aGUgbWVzc2FnZSBvZiB0aGUgYFZhbGlkYXRpb25FcnJvcmAuXG4gKlxuICogVGhlIGB2YWx1ZWAgYXJndW1lbnQgKGlmIHBhc3NlZCkgd2lsbCBiZSBhdmFpbGFibGUgdGhyb3VnaCB0aGUgYFZhbGlkYXRpb25FcnJvci52YWx1ZWAgcHJvcGVydHkuXG4gKlxuICogICAgIGRvYy5pbnZhbGlkYXRlKCdzaXplJywgJ211c3QgYmUgbGVzcyB0aGFuIDIwJywgMTQpO1xuICpcbiAqICAgICBkb2MudmFsaWRhdGUoZnVuY3Rpb24gKGVycikge1xuICogICAgICAgY29uc29sZS5sb2coZXJyKVxuICogICAgICAgLy8gcHJpbnRzXG4gKiAgICAgICB7IG1lc3NhZ2U6ICdWYWxpZGF0aW9uIGZhaWxlZCcsXG4gKiAgICAgICAgIG5hbWU6ICdWYWxpZGF0aW9uRXJyb3InLFxuICogICAgICAgICBlcnJvcnM6XG4gKiAgICAgICAgICB7IHNpemU6XG4gKiAgICAgICAgICAgICB7IG1lc3NhZ2U6ICdtdXN0IGJlIGxlc3MgdGhhbiAyMCcsXG4gKiAgICAgICAgICAgICAgIG5hbWU6ICdWYWxpZGF0b3JFcnJvcicsXG4gKiAgICAgICAgICAgICAgIHBhdGg6ICdzaXplJyxcbiAqICAgICAgICAgICAgICAgdHlwZTogJ3VzZXIgZGVmaW5lZCcsXG4gKiAgICAgICAgICAgICAgIHZhbHVlOiAxNCB9IH0gfVxuICogICAgIH0pXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHBhdGggdGhlIGZpZWxkIHRvIGludmFsaWRhdGUuIEZvciBhcnJheSBlbGVtZW50cywgdXNlIHRoZSBgYXJyYXkuaS5maWVsZGAgc3ludGF4LCB3aGVyZSBgaWAgaXMgdGhlIDAtYmFzZWQgaW5kZXggaW4gdGhlIGFycmF5LlxuICogQHBhcmFtIHtTdHJpbmd8RXJyb3J9IGVyciB0aGUgZXJyb3Igd2hpY2ggc3RhdGVzIHRoZSByZWFzb24gYHBhdGhgIHdhcyBpbnZhbGlkXG4gKiBAcGFyYW0ge09iamVjdHxTdHJpbmd8TnVtYmVyfGFueX0gdmFsIG9wdGlvbmFsIGludmFsaWQgdmFsdWVcbiAqIEBwYXJhbSB7U3RyaW5nfSBba2luZF0gb3B0aW9uYWwgYGtpbmRgIHByb3BlcnR5IGZvciB0aGUgZXJyb3JcbiAqIEByZXR1cm4ge1ZhbGlkYXRpb25FcnJvcn0gdGhlIGN1cnJlbnQgVmFsaWRhdGlvbkVycm9yLCB3aXRoIGFsbCBjdXJyZW50bHkgaW52YWxpZGF0ZWQgcGF0aHNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuRG9jdW1lbnQucHJvdG90eXBlLmludmFsaWRhdGUgPSBmdW5jdGlvbihwYXRoLCBlcnIsIHZhbCwga2luZCkge1xuICBpZiAoIXRoaXMuJF9fLnZhbGlkYXRpb25FcnJvcikge1xuICAgIHRoaXMuJF9fLnZhbGlkYXRpb25FcnJvciA9IG5ldyBWYWxpZGF0aW9uRXJyb3IodGhpcyk7XG4gIH1cblxuICBpZiAodGhpcy4kX18udmFsaWRhdGlvbkVycm9yLmVycm9yc1twYXRoXSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmICghZXJyIHx8IHR5cGVvZiBlcnIgPT09ICdzdHJpbmcnKSB7XG4gICAgZXJyID0gbmV3IFZhbGlkYXRvckVycm9yKHtcbiAgICAgIHBhdGg6IHBhdGgsXG4gICAgICBtZXNzYWdlOiBlcnIsXG4gICAgICB0eXBlOiBraW5kIHx8ICd1c2VyIGRlZmluZWQnLFxuICAgICAgdmFsdWU6IHZhbFxuICAgIH0pO1xuICB9XG5cbiAgaWYgKHRoaXMuJF9fLnZhbGlkYXRpb25FcnJvciA9PT0gZXJyKSB7XG4gICAgcmV0dXJuIHRoaXMuJF9fLnZhbGlkYXRpb25FcnJvcjtcbiAgfVxuXG4gIHRoaXMuJF9fLnZhbGlkYXRpb25FcnJvci5hZGRFcnJvcihwYXRoLCBlcnIpO1xuICByZXR1cm4gdGhpcy4kX18udmFsaWRhdGlvbkVycm9yO1xufTtcblxuLyoqXG4gKiBNYXJrcyBhIHBhdGggYXMgdmFsaWQsIHJlbW92aW5nIGV4aXN0aW5nIHZhbGlkYXRpb24gZXJyb3JzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoIHRoZSBmaWVsZCB0byBtYXJrIGFzIHZhbGlkXG4gKiBAYXBpIHB1YmxpY1xuICogQG1lbWJlck9mIERvY3VtZW50XG4gKiBAaW5zdGFuY2VcbiAqIEBtZXRob2QgJG1hcmtWYWxpZFxuICovXG5cbkRvY3VtZW50LnByb3RvdHlwZS4kbWFya1ZhbGlkID0gZnVuY3Rpb24ocGF0aCkge1xuICBpZiAoIXRoaXMuJF9fLnZhbGlkYXRpb25FcnJvciB8fCAhdGhpcy4kX18udmFsaWRhdGlvbkVycm9yLmVycm9yc1twYXRoXSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGRlbGV0ZSB0aGlzLiRfXy52YWxpZGF0aW9uRXJyb3IuZXJyb3JzW3BhdGhdO1xuICBpZiAoT2JqZWN0LmtleXModGhpcy4kX18udmFsaWRhdGlvbkVycm9yLmVycm9ycykubGVuZ3RoID09PSAwKSB7XG4gICAgdGhpcy4kX18udmFsaWRhdGlvbkVycm9yID0gbnVsbDtcbiAgfVxufTtcblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5mdW5jdGlvbiBfbWFya1ZhbGlkU3VicGF0aHMoZG9jLCBwYXRoKSB7XG4gIGlmICghZG9jLiRfXy52YWxpZGF0aW9uRXJyb3IpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoZG9jLiRfXy52YWxpZGF0aW9uRXJyb3IuZXJyb3JzKTtcbiAgZm9yIChjb25zdCBrZXkgb2Yga2V5cykge1xuICAgIGlmIChrZXkuc3RhcnRzV2l0aChwYXRoICsgJy4nKSkge1xuICAgICAgZGVsZXRlIGRvYy4kX18udmFsaWRhdGlvbkVycm9yLmVycm9yc1trZXldO1xuICAgIH1cbiAgfVxuICBpZiAoT2JqZWN0LmtleXMoZG9jLiRfXy52YWxpZGF0aW9uRXJyb3IuZXJyb3JzKS5sZW5ndGggPT09IDApIHtcbiAgICBkb2MuJF9fLnZhbGlkYXRpb25FcnJvciA9IG51bGw7XG4gIH1cbn1cblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5mdW5jdGlvbiBfY2hlY2tJbW11dGFibGVTdWJwYXRocyhzdWJkb2MsIHNjaGVtYXR5cGUsIHByaW9yVmFsKSB7XG4gIGNvbnN0IHNjaGVtYSA9IHNjaGVtYXR5cGUuc2NoZW1hO1xuICBpZiAoc2NoZW1hID09IG51bGwpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhzY2hlbWEucGF0aHMpKSB7XG4gICAgY29uc3QgcGF0aCA9IHNjaGVtYS5wYXRoc1trZXldO1xuICAgIGlmIChwYXRoLiRpbW11dGFibGVTZXR0ZXIgPT0gbnVsbCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGNvbnN0IG9sZFZhbCA9IHByaW9yVmFsID09IG51bGwgPyB2b2lkIDAgOiBwcmlvclZhbC4kX19nZXRWYWx1ZShrZXkpO1xuICAgIC8vIENhbGxpbmcgaW1tdXRhYmxlU2V0dGVyIHdpdGggYG9sZFZhbGAgZXZlbiB0aG91Z2ggaXQgZXhwZWN0cyBgbmV3VmFsYFxuICAgIC8vIGlzIGludGVudGlvbmFsLiBUaGF0J3MgYmVjYXVzZSBgJGltbXV0YWJsZVNldHRlcmAgY29tcGFyZXMgaXRzIHBhcmFtXG4gICAgLy8gdG8gdGhlIGN1cnJlbnQgdmFsdWUuXG4gICAgcGF0aC4kaW1tdXRhYmxlU2V0dGVyLmNhbGwoc3ViZG9jLCBvbGRWYWwpO1xuICB9XG59XG5cbi8qKlxuICogU2F2ZXMgdGhpcyBkb2N1bWVudCBieSBpbnNlcnRpbmcgYSBuZXcgZG9jdW1lbnQgaW50byB0aGUgZGF0YWJhc2UgaWYgW2RvY3VtZW50LmlzTmV3XShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvYXBpL2RvY3VtZW50Lmh0bWwjRG9jdW1lbnQucHJvdG90eXBlLmlzTmV3KCkpIGlzIGB0cnVlYCxcbiAqIG9yIHNlbmRzIGFuIFt1cGRhdGVPbmVdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvZG9jdW1lbnQuaHRtbCNEb2N1bWVudC5wcm90b3R5cGUudXBkYXRlT25lKCkpIG9wZXJhdGlvbiAqKm9ubHkqKiB3aXRoIHRoZSBtb2RpZmljYXRpb25zIHRvIHRoZSBkYXRhYmFzZSwgaXQgZG9lcyBub3QgcmVwbGFjZSB0aGUgd2hvbGUgZG9jdW1lbnQgaW4gdGhlIGxhdHRlciBjYXNlLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgcHJvZHVjdC5zb2xkID0gRGF0ZS5ub3coKTtcbiAqICAgICBwcm9kdWN0ID0gYXdhaXQgcHJvZHVjdC5zYXZlKCk7XG4gKlxuICogSWYgc2F2ZSBpcyBzdWNjZXNzZnVsLCB0aGUgcmV0dXJuZWQgcHJvbWlzZSB3aWxsIGZ1bGZpbGwgd2l0aCB0aGUgZG9jdW1lbnRcbiAqIHNhdmVkLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgY29uc3QgbmV3UHJvZHVjdCA9IGF3YWl0IHByb2R1Y3Quc2F2ZSgpO1xuICogICAgIG5ld1Byb2R1Y3QgPT09IHByb2R1Y3Q7IC8vIHRydWVcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIG9wdGlvbnMgb3B0aW9uYWwgb3B0aW9uc1xuICogQHBhcmFtIHtTZXNzaW9ufSBbb3B0aW9ucy5zZXNzaW9uPW51bGxdIHRoZSBbc2Vzc2lvbl0oaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvcmVmZXJlbmNlL3NlcnZlci1zZXNzaW9ucy8pIGFzc29jaWF0ZWQgd2l0aCB0aGlzIHNhdmUgb3BlcmF0aW9uLiBJZiBub3Qgc3BlY2lmaWVkLCBkZWZhdWx0cyB0byB0aGUgW2RvY3VtZW50J3MgYXNzb2NpYXRlZCBzZXNzaW9uXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvYXBpL2RvY3VtZW50Lmh0bWwjRG9jdW1lbnQucHJvdG90eXBlLiRzZXNzaW9uKCkpLlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLnNhZmVdIChERVBSRUNBVEVEKSBvdmVycmlkZXMgW3NjaGVtYSdzIHNhZmUgb3B0aW9uXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvZ3VpZGUuaHRtbCNzYWZlKS4gVXNlIHRoZSBgd2Agb3B0aW9uIGluc3RlYWQuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnZhbGlkYXRlQmVmb3JlU2F2ZV0gc2V0IHRvIGZhbHNlIHRvIHNhdmUgd2l0aG91dCB2YWxpZGF0aW5nLlxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy52YWxpZGF0ZU1vZGlmaWVkT25seT1mYWxzZV0gSWYgYHRydWVgLCBNb25nb29zZSB3aWxsIG9ubHkgdmFsaWRhdGUgbW9kaWZpZWQgcGF0aHMsIGFzIG9wcG9zZWQgdG8gbW9kaWZpZWQgcGF0aHMgYW5kIGByZXF1aXJlZGAgcGF0aHMuXG4gKiBAcGFyYW0ge051bWJlcnxTdHJpbmd9IFtvcHRpb25zLnddIHNldCB0aGUgW3dyaXRlIGNvbmNlcm5dKGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvbWFudWFsL3JlZmVyZW5jZS93cml0ZS1jb25jZXJuLyN3LW9wdGlvbikuIE92ZXJyaWRlcyB0aGUgW3NjaGVtYS1sZXZlbCBgd3JpdGVDb25jZXJuYCBvcHRpb25dKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9ndWlkZS5odG1sI3dyaXRlQ29uY2VybilcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMual0gc2V0IHRvIHRydWUgZm9yIE1vbmdvREIgdG8gd2FpdCB1bnRpbCB0aGlzIGBzYXZlKClgIGhhcyBiZWVuIFtqb3VybmFsZWQgYmVmb3JlIHJlc29sdmluZyB0aGUgcmV0dXJuZWQgcHJvbWlzZV0oaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvcmVmZXJlbmNlL3dyaXRlLWNvbmNlcm4vI2otb3B0aW9uKS4gT3ZlcnJpZGVzIHRoZSBbc2NoZW1hLWxldmVsIGB3cml0ZUNvbmNlcm5gIG9wdGlvbl0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2d1aWRlLmh0bWwjd3JpdGVDb25jZXJuKVxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnd0aW1lb3V0XSBzZXRzIGEgW3RpbWVvdXQgZm9yIHRoZSB3cml0ZSBjb25jZXJuXShodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9yZWZlcmVuY2Uvd3JpdGUtY29uY2Vybi8jd3RpbWVvdXQpLiBPdmVycmlkZXMgdGhlIFtzY2hlbWEtbGV2ZWwgYHdyaXRlQ29uY2VybmAgb3B0aW9uXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvZ3VpZGUuaHRtbCN3cml0ZUNvbmNlcm4pLlxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5jaGVja0tleXM9dHJ1ZV0gdGhlIE1vbmdvREIgZHJpdmVyIHByZXZlbnRzIHlvdSBmcm9tIHNhdmluZyBrZXlzIHRoYXQgc3RhcnQgd2l0aCAnJCcgb3IgY29udGFpbiAnLicgYnkgZGVmYXVsdC4gU2V0IHRoaXMgb3B0aW9uIHRvIGBmYWxzZWAgdG8gc2tpcCB0aGF0IGNoZWNrLiBTZWUgW3Jlc3RyaWN0aW9ucyBvbiBmaWVsZCBuYW1lc10oaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvcmVmZXJlbmNlL2xpbWl0cy8jUmVzdHJpY3Rpb25zLW9uLUZpZWxkLU5hbWVzKVxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy50aW1lc3RhbXBzPXRydWVdIGlmIGBmYWxzZWAgYW5kIFt0aW1lc3RhbXBzXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvZ3VpZGUuaHRtbCN0aW1lc3RhbXBzKSBhcmUgZW5hYmxlZCwgc2tpcCB0aW1lc3RhbXBzIGZvciB0aGlzIGBzYXZlKClgLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2ZuXSBvcHRpb25hbCBjYWxsYmFja1xuICogQG1ldGhvZCBzYXZlXG4gKiBAbWVtYmVyT2YgRG9jdW1lbnRcbiAqIEBpbnN0YW5jZVxuICogQHRocm93cyB7RG9jdW1lbnROb3RGb3VuZEVycm9yfSBpZiB0aGlzIFtzYXZlIHVwZGF0ZXMgYW4gZXhpc3RpbmcgZG9jdW1lbnRdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvZG9jdW1lbnQuaHRtbCNEb2N1bWVudC5wcm90b3R5cGUuaXNOZXcoKSkgYnV0IHRoZSBkb2N1bWVudCBkb2Vzbid0IGV4aXN0IGluIHRoZSBkYXRhYmFzZS4gRm9yIGV4YW1wbGUsIHlvdSB3aWxsIGdldCB0aGlzIGVycm9yIGlmIHRoZSBkb2N1bWVudCBpcyBbZGVsZXRlZCBiZXR3ZWVuIHdoZW4geW91IHJldHJpZXZlZCB0aGUgZG9jdW1lbnQgYW5kIHdoZW4geW91IHNhdmVkIGl0XShkb2N1bWVudHMuaHRtbCN1cGRhdGluZykuXG4gKiBAcmV0dXJuIHtQcm9taXNlfHVuZGVmaW5lZH0gUmV0dXJucyB1bmRlZmluZWQgaWYgdXNlZCB3aXRoIGNhbGxiYWNrIG9yIGEgUHJvbWlzZSBvdGhlcndpc2UuXG4gKiBAYXBpIHB1YmxpY1xuICogQHNlZSBtaWRkbGV3YXJlIGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9taWRkbGV3YXJlLmh0bWxcbiAqL1xuXG4vKipcbiAqIENoZWNrcyBpZiBhIHBhdGggaXMgaW52YWxpZFxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfFN0cmluZ1tdfSBbcGF0aF0gdGhlIGZpZWxkIHRvIGNoZWNrLiBJZiB1bnNldCB3aWxsIGFsd2F5cyByZXR1cm4gXCJmYWxzZVwiXG4gKiBAbWV0aG9kICRpc1ZhbGlkXG4gKiBAbWVtYmVyT2YgRG9jdW1lbnRcbiAqIEBpbnN0YW5jZVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuRG9jdW1lbnQucHJvdG90eXBlLiRpc1ZhbGlkID0gZnVuY3Rpb24ocGF0aCkge1xuICBpZiAodGhpcy4kX18udmFsaWRhdGlvbkVycm9yID09IG51bGwgfHwgT2JqZWN0LmtleXModGhpcy4kX18udmFsaWRhdGlvbkVycm9yLmVycm9ycykubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKHBhdGggPT0gbnVsbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChwYXRoLmluZGV4T2YoJyAnKSAhPT0gLTEpIHtcbiAgICBwYXRoID0gcGF0aC5zcGxpdCgnICcpO1xuICB9XG4gIGlmIChBcnJheS5pc0FycmF5KHBhdGgpKSB7XG4gICAgcmV0dXJuIHBhdGguc29tZShwID0+IHRoaXMuJF9fLnZhbGlkYXRpb25FcnJvci5lcnJvcnNbcF0gPT0gbnVsbCk7XG4gIH1cblxuICByZXR1cm4gdGhpcy4kX18udmFsaWRhdGlvbkVycm9yLmVycm9yc1twYXRoXSA9PSBudWxsO1xufTtcblxuLyoqXG4gKiBSZXNldHMgdGhlIGludGVybmFsIG1vZGlmaWVkIHN0YXRlIG9mIHRoaXMgZG9jdW1lbnQuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKiBAcmV0dXJuIHtEb2N1bWVudH0gdGhpc1xuICogQG1ldGhvZCAkX19yZXNldFxuICogQG1lbWJlck9mIERvY3VtZW50XG4gKiBAaW5zdGFuY2VcbiAqL1xuXG5Eb2N1bWVudC5wcm90b3R5cGUuJF9fcmVzZXQgPSBmdW5jdGlvbiByZXNldCgpIHtcbiAgbGV0IF90aGlzID0gdGhpcztcblxuICAvLyBTa2lwIGZvciBzdWJkb2N1bWVudHNcbiAgY29uc3Qgc3ViZG9jcyA9IHRoaXMuJHBhcmVudCgpID09PSB0aGlzID8gdGhpcy4kZ2V0QWxsU3ViZG9jcygpIDogW107XG4gIGNvbnN0IHJlc2V0QXJyYXlzID0gbmV3IFNldCgpO1xuICBmb3IgKGNvbnN0IHN1YmRvYyBvZiBzdWJkb2NzKSB7XG4gICAgY29uc3QgZnVsbFBhdGhXaXRoSW5kZXhlcyA9IHN1YmRvYy4kX19mdWxsUGF0aFdpdGhJbmRleGVzKCk7XG4gICAgc3ViZG9jLiRfX3Jlc2V0KCk7XG4gICAgaWYgKHRoaXMuaXNNb2RpZmllZChmdWxsUGF0aFdpdGhJbmRleGVzKSB8fCBpc1BhcmVudEluaXQoZnVsbFBhdGhXaXRoSW5kZXhlcykpIHtcbiAgICAgIGlmIChzdWJkb2MuJGlzRG9jdW1lbnRBcnJheUVsZW1lbnQpIHtcbiAgICAgICAgcmVzZXRBcnJheXMuYWRkKHN1YmRvYy5wYXJlbnRBcnJheSgpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IHBhcmVudCA9IHN1YmRvYy4kcGFyZW50KCk7XG4gICAgICAgIGlmIChwYXJlbnQgPT09IHRoaXMpIHtcbiAgICAgICAgICB0aGlzLiRfXy5hY3RpdmVQYXRocy5jbGVhclBhdGgoc3ViZG9jLiRiYXNlUGF0aCk7XG4gICAgICAgIH0gZWxzZSBpZiAocGFyZW50ICE9IG51bGwgJiYgcGFyZW50LiRpc1N1YmRvY3VtZW50KSB7XG4gICAgICAgICAgLy8gSWYgbWFwIHBhdGggdW5kZXJuZWF0aCBzdWJkb2N1bWVudCwgbWF5IGVuZCB1cCB3aXRoIGEgY2FzZSB3aGVyZVxuICAgICAgICAgIC8vIG1hcCBwYXRoIGlzIG1vZGlmaWVkIGJ1dCBwYXJlbnQgc3RpbGwgbmVlZHMgdG8gYmUgcmVzZXQuIFNlZSBnaC0xMDI5NVxuICAgICAgICAgIHBhcmVudC4kX19yZXNldCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZm9yIChjb25zdCBhcnJheSBvZiByZXNldEFycmF5cykge1xuICAgIHRoaXMuJF9fLmFjdGl2ZVBhdGhzLmNsZWFyUGF0aChhcnJheS4kcGF0aCgpKTtcbiAgICBhcnJheVthcnJheUF0b21pY3NCYWNrdXBTeW1ib2xdID0gYXJyYXlbYXJyYXlBdG9taWNzU3ltYm9sXTtcbiAgICBhcnJheVthcnJheUF0b21pY3NTeW1ib2xdID0ge307XG4gIH1cblxuICBmdW5jdGlvbiBpc1BhcmVudEluaXQocGF0aCkge1xuICAgIHBhdGggPSBwYXRoLmluZGV4T2YoJy4nKSA9PT0gLTEgPyBbcGF0aF0gOiBwYXRoLnNwbGl0KCcuJyk7XG4gICAgbGV0IGN1ciA9ICcnO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGF0aC5sZW5ndGg7ICsraSkge1xuICAgICAgY3VyICs9IChjdXIubGVuZ3RoID8gJy4nIDogJycpICsgcGF0aFtpXTtcbiAgICAgIGlmIChfdGhpcy4kX18uYWN0aXZlUGF0aHNbY3VyXSA9PT0gJ2luaXQnKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8vIGNsZWFyIGF0b21pY3NcbiAgdGhpcy4kX19kaXJ0eSgpLmZvckVhY2goZnVuY3Rpb24oZGlydCkge1xuICAgIGNvbnN0IHR5cGUgPSBkaXJ0LnZhbHVlO1xuXG4gICAgaWYgKHR5cGUgJiYgdHlwZVthcnJheUF0b21pY3NTeW1ib2xdKSB7XG4gICAgICB0eXBlW2FycmF5QXRvbWljc0JhY2t1cFN5bWJvbF0gPSB0eXBlW2FycmF5QXRvbWljc1N5bWJvbF07XG4gICAgICB0eXBlW2FycmF5QXRvbWljc1N5bWJvbF0gPSB7fTtcbiAgICB9XG4gIH0pO1xuXG4gIHRoaXMuJF9fLmJhY2t1cCA9IHt9O1xuICB0aGlzLiRfXy5iYWNrdXAuYWN0aXZlUGF0aHMgPSB7XG4gICAgbW9kaWZ5OiBPYmplY3QuYXNzaWduKHt9LCB0aGlzLiRfXy5hY3RpdmVQYXRocy5nZXRTdGF0ZVBhdGhzKCdtb2RpZnknKSksXG4gICAgZGVmYXVsdDogT2JqZWN0LmFzc2lnbih7fSwgdGhpcy4kX18uYWN0aXZlUGF0aHMuZ2V0U3RhdGVQYXRocygnZGVmYXVsdCcpKVxuICB9O1xuICB0aGlzLiRfXy5iYWNrdXAudmFsaWRhdGlvbkVycm9yID0gdGhpcy4kX18udmFsaWRhdGlvbkVycm9yO1xuICB0aGlzLiRfXy5iYWNrdXAuZXJyb3JzID0gdGhpcy4kZXJyb3JzO1xuXG4gIC8vIENsZWFyICdkaXJ0eScgY2FjaGVcbiAgdGhpcy4kX18uYWN0aXZlUGF0aHMuY2xlYXIoJ21vZGlmeScpO1xuICB0aGlzLiRfXy5hY3RpdmVQYXRocy5jbGVhcignZGVmYXVsdCcpO1xuICB0aGlzLiRfXy52YWxpZGF0aW9uRXJyb3IgPSB1bmRlZmluZWQ7XG4gIHRoaXMuJGVycm9ycyA9IHVuZGVmaW5lZDtcbiAgX3RoaXMgPSB0aGlzO1xuICB0aGlzLiRfX3NjaGVtYS5yZXF1aXJlZFBhdGhzKCkuZm9yRWFjaChmdW5jdGlvbihwYXRoKSB7XG4gICAgX3RoaXMuJF9fLmFjdGl2ZVBhdGhzLnJlcXVpcmUocGF0aCk7XG4gIH0pO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5Eb2N1bWVudC5wcm90b3R5cGUuJF9fdW5kb1Jlc2V0ID0gZnVuY3Rpb24gJF9fdW5kb1Jlc2V0KCkge1xuICBpZiAodGhpcy4kX18uYmFja3VwID09IG51bGwgfHwgdGhpcy4kX18uYmFja3VwLmFjdGl2ZVBhdGhzID09IG51bGwpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB0aGlzLiRfXy5hY3RpdmVQYXRocy5zdGF0ZXMubW9kaWZ5ID0gdGhpcy4kX18uYmFja3VwLmFjdGl2ZVBhdGhzLm1vZGlmeTtcbiAgdGhpcy4kX18uYWN0aXZlUGF0aHMuc3RhdGVzLmRlZmF1bHQgPSB0aGlzLiRfXy5iYWNrdXAuYWN0aXZlUGF0aHMuZGVmYXVsdDtcblxuICB0aGlzLiRfXy52YWxpZGF0aW9uRXJyb3IgPSB0aGlzLiRfXy5iYWNrdXAudmFsaWRhdGlvbkVycm9yO1xuICB0aGlzLiRlcnJvcnMgPSB0aGlzLiRfXy5iYWNrdXAuZXJyb3JzO1xuXG4gIGZvciAoY29uc3QgZGlydCBvZiB0aGlzLiRfX2RpcnR5KCkpIHtcbiAgICBjb25zdCB0eXBlID0gZGlydC52YWx1ZTtcblxuICAgIGlmICh0eXBlICYmIHR5cGVbYXJyYXlBdG9taWNzU3ltYm9sXSAmJiB0eXBlW2FycmF5QXRvbWljc0JhY2t1cFN5bWJvbF0pIHtcbiAgICAgIHR5cGVbYXJyYXlBdG9taWNzU3ltYm9sXSA9IHR5cGVbYXJyYXlBdG9taWNzQmFja3VwU3ltYm9sXTtcbiAgICB9XG4gIH1cblxuICBmb3IgKGNvbnN0IHN1YmRvYyBvZiB0aGlzLiRnZXRBbGxTdWJkb2NzKCkpIHtcbiAgICBzdWJkb2MuJF9fdW5kb1Jlc2V0KCk7XG4gIH1cbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGlzIGRvY3VtZW50cyBkaXJ0eSBwYXRocyAvIHZhbHMuXG4gKlxuICogQHJldHVybiB7QXJyYXl9XG4gKiBAYXBpIHByaXZhdGVcbiAqIEBtZXRob2QgJF9fZGlydHlcbiAqIEBtZW1iZXJPZiBEb2N1bWVudFxuICogQGluc3RhbmNlXG4gKi9cblxuRG9jdW1lbnQucHJvdG90eXBlLiRfX2RpcnR5ID0gZnVuY3Rpb24oKSB7XG4gIGNvbnN0IF90aGlzID0gdGhpcztcbiAgbGV0IGFsbCA9IHRoaXMuJF9fLmFjdGl2ZVBhdGhzLm1hcCgnbW9kaWZ5JywgZnVuY3Rpb24ocGF0aCkge1xuICAgIHJldHVybiB7XG4gICAgICBwYXRoOiBwYXRoLFxuICAgICAgdmFsdWU6IF90aGlzLiRfX2dldFZhbHVlKHBhdGgpLFxuICAgICAgc2NoZW1hOiBfdGhpcy4kX19wYXRoKHBhdGgpXG4gICAgfTtcbiAgfSk7XG5cbiAgLy8gZ2gtMjU1ODogaWYgd2UgaGFkIHRvIHNldCBhIGRlZmF1bHQgYW5kIHRoZSB2YWx1ZSBpcyBub3QgdW5kZWZpbmVkLFxuICAvLyB3ZSBoYXZlIHRvIHNhdmUgYXMgd2VsbFxuICBhbGwgPSBhbGwuY29uY2F0KHRoaXMuJF9fLmFjdGl2ZVBhdGhzLm1hcCgnZGVmYXVsdCcsIGZ1bmN0aW9uKHBhdGgpIHtcbiAgICBpZiAocGF0aCA9PT0gJ19pZCcgfHwgX3RoaXMuJF9fZ2V0VmFsdWUocGF0aCkgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgcGF0aDogcGF0aCxcbiAgICAgIHZhbHVlOiBfdGhpcy4kX19nZXRWYWx1ZShwYXRoKSxcbiAgICAgIHNjaGVtYTogX3RoaXMuJF9fcGF0aChwYXRoKVxuICAgIH07XG4gIH0pKTtcblxuICBjb25zdCBhbGxQYXRocyA9IG5ldyBNYXAoYWxsLmZpbHRlcigoZWwpID0+IGVsICE9IG51bGwpLm1hcCgoZWwpID0+IFtlbC5wYXRoLCBlbC52YWx1ZV0pKTtcbiAgLy8gSWdub3JlIFwiZm9vLmFcIiBpZiBcImZvb1wiIGlzIGRpcnR5IGFscmVhZHkuXG4gIGNvbnN0IG1pbmltYWwgPSBbXTtcblxuICBhbGwuZm9yRWFjaChmdW5jdGlvbihpdGVtKSB7XG4gICAgaWYgKCFpdGVtKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgbGV0IHRvcCA9IG51bGw7XG5cbiAgICBjb25zdCBhcnJheSA9IHBhcmVudFBhdGhzKGl0ZW0ucGF0aCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgIGlmIChhbGxQYXRocy5oYXMoYXJyYXlbaV0pKSB7XG4gICAgICAgIHRvcCA9IGFsbFBhdGhzLmdldChhcnJheVtpXSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodG9wID09IG51bGwpIHtcbiAgICAgIG1pbmltYWwucHVzaChpdGVtKTtcbiAgICB9IGVsc2UgaWYgKHRvcCAhPSBudWxsICYmXG4gICAgICAgIHRvcFthcnJheUF0b21pY3NTeW1ib2xdICE9IG51bGwgJiZcbiAgICAgICAgdG9wLmhhc0F0b21pY3MoKSkge1xuICAgICAgLy8gc3BlY2lhbCBjYXNlIGZvciB0b3AgbGV2ZWwgTW9uZ29vc2VBcnJheXNcbiAgICAgIC8vIHRoZSBgdG9wYCBhcnJheSBpdHNlbGYgYW5kIGEgc3ViIHBhdGggb2YgYHRvcGAgYXJlIGJlaW5nIHNldC5cbiAgICAgIC8vIHRoZSBvbmx5IHdheSB0byBob25vciBhbGwgb2YgYm90aCBtb2RpZmljYXRpb25zIGlzIHRocm91Z2ggYSAkc2V0XG4gICAgICAvLyBvZiBlbnRpcmUgYXJyYXkuXG4gICAgICB0b3BbYXJyYXlBdG9taWNzU3ltYm9sXSA9IHt9O1xuICAgICAgdG9wW2FycmF5QXRvbWljc1N5bWJvbF0uJHNldCA9IHRvcDtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gbWluaW1hbDtcbn07XG5cbi8qKlxuICogQXNzaWducy9jb21waWxlcyBgc2NoZW1hYCBpbnRvIHRoaXMgZG9jdW1lbnRzIHByb3RvdHlwZS5cbiAqXG4gKiBAcGFyYW0ge1NjaGVtYX0gc2NoZW1hXG4gKiBAYXBpIHByaXZhdGVcbiAqIEBtZXRob2QgJF9fc2V0U2NoZW1hXG4gKiBAbWVtYmVyT2YgRG9jdW1lbnRcbiAqIEBpbnN0YW5jZVxuICovXG5cbkRvY3VtZW50LnByb3RvdHlwZS4kX19zZXRTY2hlbWEgPSBmdW5jdGlvbihzY2hlbWEpIHtcbiAgY29tcGlsZShzY2hlbWEudHJlZSwgdGhpcywgdW5kZWZpbmVkLCBzY2hlbWEub3B0aW9ucyk7XG5cbiAgLy8gQXBwbHkgZGVmYXVsdCBnZXR0ZXJzIGlmIHZpcnR1YWwgZG9lc24ndCBoYXZlIGFueSAoZ2gtNjI2MilcbiAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMoc2NoZW1hLnZpcnR1YWxzKSkge1xuICAgIHNjaGVtYS52aXJ0dWFsc1trZXldLl9hcHBseURlZmF1bHRHZXR0ZXJzKCk7XG4gIH1cbiAgaWYgKHNjaGVtYS5wYXRoKCdzY2hlbWEnKSA9PSBudWxsKSB7XG4gICAgdGhpcy5zY2hlbWEgPSBzY2hlbWE7XG4gIH1cbiAgdGhpcy4kX19zY2hlbWEgPSBzY2hlbWE7XG4gIHRoaXNbZG9jdW1lbnRTY2hlbWFTeW1ib2xdID0gc2NoZW1hO1xufTtcblxuXG4vKipcbiAqIEdldCBhY3RpdmUgcGF0aCB0aGF0IHdlcmUgY2hhbmdlZCBhbmQgYXJlIGFycmF5c1xuICpcbiAqIEByZXR1cm4ge0FycmF5fVxuICogQGFwaSBwcml2YXRlXG4gKiBAbWV0aG9kICRfX2dldEFycmF5UGF0aHNUb1ZhbGlkYXRlXG4gKiBAbWVtYmVyT2YgRG9jdW1lbnRcbiAqIEBpbnN0YW5jZVxuICovXG5cbkRvY3VtZW50LnByb3RvdHlwZS4kX19nZXRBcnJheVBhdGhzVG9WYWxpZGF0ZSA9IGZ1bmN0aW9uKCkge1xuICBEb2N1bWVudEFycmF5IHx8IChEb2N1bWVudEFycmF5ID0gcmVxdWlyZSgnLi90eXBlcy9kb2N1bWVudEFycmF5JykpO1xuXG4gIC8vIHZhbGlkYXRlIGFsbCBkb2N1bWVudCBhcnJheXMuXG4gIHJldHVybiB0aGlzLiRfXy5hY3RpdmVQYXRoc1xuICAgIC5tYXAoJ2luaXQnLCAnbW9kaWZ5JywgZnVuY3Rpb24oaSkge1xuICAgICAgcmV0dXJuIHRoaXMuJF9fZ2V0VmFsdWUoaSk7XG4gICAgfS5iaW5kKHRoaXMpKVxuICAgIC5maWx0ZXIoZnVuY3Rpb24odmFsKSB7XG4gICAgICByZXR1cm4gdmFsICYmIEFycmF5LmlzQXJyYXkodmFsKSAmJiB1dGlscy5pc01vbmdvb3NlRG9jdW1lbnRBcnJheSh2YWwpICYmIHZhbC5sZW5ndGg7XG4gICAgfSkucmVkdWNlKGZ1bmN0aW9uKHNlZWQsIGFycmF5KSB7XG4gICAgICByZXR1cm4gc2VlZC5jb25jYXQoYXJyYXkpO1xuICAgIH0sIFtdKVxuICAgIC5maWx0ZXIoZnVuY3Rpb24oZG9jKSB7XG4gICAgICByZXR1cm4gZG9jO1xuICAgIH0pO1xufTtcblxuXG4vKipcbiAqIEdldCBhbGwgc3ViZG9jcyAoYnkgYmZzKVxuICpcbiAqIEByZXR1cm4ge0FycmF5fVxuICogQGFwaSBwdWJsaWNcbiAqIEBtZXRob2QgJGdldEFsbFN1YmRvY3NcbiAqIEBtZW1iZXJPZiBEb2N1bWVudFxuICogQGluc3RhbmNlXG4gKi9cblxuRG9jdW1lbnQucHJvdG90eXBlLiRnZXRBbGxTdWJkb2NzID0gZnVuY3Rpb24oKSB7XG4gIERvY3VtZW50QXJyYXkgfHwgKERvY3VtZW50QXJyYXkgPSByZXF1aXJlKCcuL3R5cGVzL2RvY3VtZW50QXJyYXknKSk7XG4gIEVtYmVkZGVkID0gRW1iZWRkZWQgfHwgcmVxdWlyZSgnLi90eXBlcy9hcnJheVN1YmRvY3VtZW50Jyk7XG5cbiAgZnVuY3Rpb24gZG9jUmVkdWNlcihkb2MsIHNlZWQsIHBhdGgpIHtcbiAgICBsZXQgdmFsID0gZG9jO1xuICAgIGxldCBpc05lc3RlZCA9IGZhbHNlO1xuICAgIGlmIChwYXRoKSB7XG4gICAgICBpZiAoZG9jIGluc3RhbmNlb2YgRG9jdW1lbnQgJiYgZG9jW2RvY3VtZW50U2NoZW1hU3ltYm9sXS5wYXRoc1twYXRoXSkge1xuICAgICAgICB2YWwgPSBkb2MuX2RvY1twYXRoXTtcbiAgICAgIH0gZWxzZSBpZiAoZG9jIGluc3RhbmNlb2YgRG9jdW1lbnQgJiYgZG9jW2RvY3VtZW50U2NoZW1hU3ltYm9sXS5uZXN0ZWRbcGF0aF0pIHtcbiAgICAgICAgdmFsID0gZG9jLl9kb2NbcGF0aF07XG4gICAgICAgIGlzTmVzdGVkID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhbCA9IGRvY1twYXRoXTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHZhbCBpbnN0YW5jZW9mIEVtYmVkZGVkKSB7XG4gICAgICBzZWVkLnB1c2godmFsKTtcbiAgICB9IGVsc2UgaWYgKHZhbCBpbnN0YW5jZW9mIE1hcCkge1xuICAgICAgc2VlZCA9IEFycmF5LmZyb20odmFsLmtleXMoKSkucmVkdWNlKGZ1bmN0aW9uKHNlZWQsIHBhdGgpIHtcbiAgICAgICAgcmV0dXJuIGRvY1JlZHVjZXIodmFsLmdldChwYXRoKSwgc2VlZCwgbnVsbCk7XG4gICAgICB9LCBzZWVkKTtcbiAgICB9IGVsc2UgaWYgKHZhbCAmJiAhQXJyYXkuaXNBcnJheSh2YWwpICYmIHZhbC4kaXNTaW5nbGVOZXN0ZWQpIHtcbiAgICAgIHNlZWQgPSBPYmplY3Qua2V5cyh2YWwuX2RvYykucmVkdWNlKGZ1bmN0aW9uKHNlZWQsIHBhdGgpIHtcbiAgICAgICAgcmV0dXJuIGRvY1JlZHVjZXIodmFsLCBzZWVkLCBwYXRoKTtcbiAgICAgIH0sIHNlZWQpO1xuICAgICAgc2VlZC5wdXNoKHZhbCk7XG4gICAgfSBlbHNlIGlmICh2YWwgJiYgdXRpbHMuaXNNb25nb29zZURvY3VtZW50QXJyYXkodmFsKSkge1xuICAgICAgdmFsLmZvckVhY2goZnVuY3Rpb24gX2RvY1JlZHVjZShkb2MpIHtcbiAgICAgICAgaWYgKCFkb2MgfHwgIWRvYy5fZG9jKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHNlZWQgPSBPYmplY3Qua2V5cyhkb2MuX2RvYykucmVkdWNlKGZ1bmN0aW9uKHNlZWQsIHBhdGgpIHtcbiAgICAgICAgICByZXR1cm4gZG9jUmVkdWNlcihkb2MuX2RvYywgc2VlZCwgcGF0aCk7XG4gICAgICAgIH0sIHNlZWQpO1xuICAgICAgICBpZiAoZG9jIGluc3RhbmNlb2YgRW1iZWRkZWQpIHtcbiAgICAgICAgICBzZWVkLnB1c2goZG9jKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChpc05lc3RlZCAmJiB2YWwgIT0gbnVsbCkge1xuICAgICAgZm9yIChjb25zdCBwYXRoIG9mIE9iamVjdC5rZXlzKHZhbCkpIHtcbiAgICAgICAgZG9jUmVkdWNlcih2YWwsIHNlZWQsIHBhdGgpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc2VlZDtcbiAgfVxuXG4gIGNvbnN0IHN1YkRvY3MgPSBbXTtcbiAgZm9yIChjb25zdCBwYXRoIG9mIE9iamVjdC5rZXlzKHRoaXMuX2RvYykpIHtcbiAgICBkb2NSZWR1Y2VyKHRoaXMsIHN1YkRvY3MsIHBhdGgpO1xuICB9XG5cbiAgcmV0dXJuIHN1YkRvY3M7XG59O1xuXG4vKiFcbiAqIFJ1bnMgcXVldWVkIGZ1bmN0aW9uc1xuICovXG5cbmZ1bmN0aW9uIGFwcGx5UXVldWUoZG9jKSB7XG4gIGNvbnN0IHEgPSBkb2MuJF9fc2NoZW1hICYmIGRvYy4kX19zY2hlbWEuY2FsbFF1ZXVlO1xuICBpZiAoIXEubGVuZ3RoKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgZm9yIChjb25zdCBwYWlyIG9mIHEpIHtcbiAgICBpZiAocGFpclswXSAhPT0gJ3ByZScgJiYgcGFpclswXSAhPT0gJ3Bvc3QnICYmIHBhaXJbMF0gIT09ICdvbicpIHtcbiAgICAgIGRvY1twYWlyWzBdXS5hcHBseShkb2MsIHBhaXJbMV0pO1xuICAgIH1cbiAgfVxufVxuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cbkRvY3VtZW50LnByb3RvdHlwZS4kX19oYW5kbGVSZWplY3QgPSBmdW5jdGlvbiBoYW5kbGVSZWplY3QoZXJyKSB7XG4gIC8vIGVtaXQgb24gdGhlIE1vZGVsIGlmIGxpc3RlbmluZ1xuICBpZiAodGhpcy4kbGlzdGVuZXJzKCdlcnJvcicpLmxlbmd0aCkge1xuICAgIHRoaXMuJGVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgfSBlbHNlIGlmICh0aGlzLmNvbnN0cnVjdG9yLmxpc3RlbmVycyAmJiB0aGlzLmNvbnN0cnVjdG9yLmxpc3RlbmVycygnZXJyb3InKS5sZW5ndGgpIHtcbiAgICB0aGlzLmNvbnN0cnVjdG9yLmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgfVxufTtcblxuLyoqXG4gKiBJbnRlcm5hbCBoZWxwZXIgZm9yIHRvT2JqZWN0KCkgYW5kIHRvSlNPTigpIHRoYXQgZG9lc24ndCBtYW5pcHVsYXRlIG9wdGlvbnNcbiAqXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKiBAYXBpIHByaXZhdGVcbiAqIEBtZXRob2QgJHRvT2JqZWN0XG4gKiBAbWVtYmVyT2YgRG9jdW1lbnRcbiAqIEBpbnN0YW5jZVxuICovXG5cbkRvY3VtZW50LnByb3RvdHlwZS4kdG9PYmplY3QgPSBmdW5jdGlvbihvcHRpb25zLCBqc29uKSB7XG4gIGxldCBkZWZhdWx0T3B0aW9ucyA9IHtcbiAgICB0cmFuc2Zvcm06IHRydWUsXG4gICAgZmxhdHRlbkRlY2ltYWxzOiB0cnVlXG4gIH07XG5cbiAgY29uc3QgcGF0aCA9IGpzb24gPyAndG9KU09OJyA6ICd0b09iamVjdCc7XG4gIGNvbnN0IGJhc2VPcHRpb25zID0gdGhpcy5jb25zdHJ1Y3RvciAmJlxuICAgIHRoaXMuY29uc3RydWN0b3IuYmFzZSAmJlxuICAgIHRoaXMuY29uc3RydWN0b3IuYmFzZS5vcHRpb25zICYmXG4gICAgZ2V0KHRoaXMuY29uc3RydWN0b3IuYmFzZS5vcHRpb25zLCBwYXRoKSB8fCB7fTtcbiAgY29uc3Qgc2NoZW1hT3B0aW9ucyA9IHRoaXMuJF9fc2NoZW1hICYmIHRoaXMuJF9fc2NoZW1hLm9wdGlvbnMgfHwge307XG4gIC8vIG1lcmdlIGJhc2UgZGVmYXVsdCBvcHRpb25zIHdpdGggU2NoZW1hJ3Mgc2V0IGRlZmF1bHQgb3B0aW9ucyBpZiBhdmFpbGFibGUuXG4gIC8vIGBjbG9uZWAgaXMgbmVjZXNzYXJ5IGhlcmUgYmVjYXVzZSBgdXRpbHMub3B0aW9uc2AgZGlyZWN0bHkgbW9kaWZpZXMgdGhlIHNlY29uZCBpbnB1dC5cbiAgZGVmYXVsdE9wdGlvbnMgPSB7IC4uLmRlZmF1bHRPcHRpb25zLCAuLi5iYXNlT3B0aW9ucywgLi4uc2NoZW1hT3B0aW9uc1twYXRoXSB9O1xuXG4gIC8vIElmIG9wdGlvbnMgZG8gbm90IGV4aXN0IG9yIGlzIG5vdCBhbiBvYmplY3QsIHNldCBpdCB0byBlbXB0eSBvYmplY3RcbiAgb3B0aW9ucyA9IHV0aWxzLmlzUE9KTyhvcHRpb25zKSA/IHsgLi4ub3B0aW9ucyB9IDoge307XG4gIG9wdGlvbnMuX2NhbGxlZFdpdGhPcHRpb25zID0gb3B0aW9ucy5fY2FsbGVkV2l0aE9wdGlvbnMgfHwgeyAuLi5vcHRpb25zIH07XG5cbiAgbGV0IF9taW5pbWl6ZTtcbiAgaWYgKG9wdGlvbnMuX2NhbGxlZFdpdGhPcHRpb25zLm1pbmltaXplICE9IG51bGwpIHtcbiAgICBfbWluaW1pemUgPSBvcHRpb25zLm1pbmltaXplO1xuICB9IGVsc2UgaWYgKGRlZmF1bHRPcHRpb25zLm1pbmltaXplICE9IG51bGwpIHtcbiAgICBfbWluaW1pemUgPSBkZWZhdWx0T3B0aW9ucy5taW5pbWl6ZTtcbiAgfSBlbHNlIHtcbiAgICBfbWluaW1pemUgPSBzY2hlbWFPcHRpb25zLm1pbmltaXplO1xuICB9XG5cbiAgbGV0IGZsYXR0ZW5NYXBzO1xuICBpZiAob3B0aW9ucy5fY2FsbGVkV2l0aE9wdGlvbnMuZmxhdHRlbk1hcHMgIT0gbnVsbCkge1xuICAgIGZsYXR0ZW5NYXBzID0gb3B0aW9ucy5mbGF0dGVuTWFwcztcbiAgfSBlbHNlIGlmIChkZWZhdWx0T3B0aW9ucy5mbGF0dGVuTWFwcyAhPSBudWxsKSB7XG4gICAgZmxhdHRlbk1hcHMgPSBkZWZhdWx0T3B0aW9ucy5mbGF0dGVuTWFwcztcbiAgfSBlbHNlIHtcbiAgICBmbGF0dGVuTWFwcyA9IHNjaGVtYU9wdGlvbnMuZmxhdHRlbk1hcHM7XG4gIH1cblxuICBsZXQgZmxhdHRlbk9iamVjdElkcztcbiAgaWYgKG9wdGlvbnMuX2NhbGxlZFdpdGhPcHRpb25zLmZsYXR0ZW5PYmplY3RJZHMgIT0gbnVsbCkge1xuICAgIGZsYXR0ZW5PYmplY3RJZHMgPSBvcHRpb25zLmZsYXR0ZW5PYmplY3RJZHM7XG4gIH0gZWxzZSBpZiAoZGVmYXVsdE9wdGlvbnMuZmxhdHRlbk9iamVjdElkcyAhPSBudWxsKSB7XG4gICAgZmxhdHRlbk9iamVjdElkcyA9IGRlZmF1bHRPcHRpb25zLmZsYXR0ZW5PYmplY3RJZHM7XG4gIH0gZWxzZSB7XG4gICAgZmxhdHRlbk9iamVjdElkcyA9IHNjaGVtYU9wdGlvbnMuZmxhdHRlbk9iamVjdElkcztcbiAgfVxuXG4gIC8vIFRoZSBvcmlnaW5hbCBvcHRpb25zIHRoYXQgd2lsbCBiZSBwYXNzZWQgdG8gYGNsb25lKClgLiBJbXBvcnRhbnQgYmVjYXVzZVxuICAvLyBgY2xvbmUoKWAgd2lsbCByZWN1cnNpdmVseSBjYWxsIGAkdG9PYmplY3QoKWAgb24gZW1iZWRkZWQgZG9jcywgc28gd2VcbiAgLy8gbmVlZCB0aGUgb3JpZ2luYWwgb3B0aW9ucyB0aGUgdXNlciBwYXNzZWQgaW4sIHBsdXMgYF9pc05lc3RlZGAgYW5kXG4gIC8vIGBfcGFyZW50T3B0aW9uc2AgZm9yIGNoZWNraW5nIHdoZXRoZXIgd2UgbmVlZCB0byBkZXBvcHVsYXRlLlxuICBjb25zdCBjbG9uZU9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zLCB7XG4gICAgX2lzTmVzdGVkOiB0cnVlLFxuICAgIGpzb246IGpzb24sXG4gICAgbWluaW1pemU6IF9taW5pbWl6ZSxcbiAgICBmbGF0dGVuTWFwczogZmxhdHRlbk1hcHMsXG4gICAgZmxhdHRlbk9iamVjdElkczogZmxhdHRlbk9iamVjdElkcyxcbiAgICBfc2VlbjogKG9wdGlvbnMgJiYgb3B0aW9ucy5fc2VlbikgfHwgbmV3IE1hcCgpXG4gIH0pO1xuXG4gIGlmICh1dGlscy5oYXNVc2VyRGVmaW5lZFByb3BlcnR5KG9wdGlvbnMsICdnZXR0ZXJzJykpIHtcbiAgICBjbG9uZU9wdGlvbnMuZ2V0dGVycyA9IG9wdGlvbnMuZ2V0dGVycztcbiAgfVxuICBpZiAodXRpbHMuaGFzVXNlckRlZmluZWRQcm9wZXJ0eShvcHRpb25zLCAndmlydHVhbHMnKSkge1xuICAgIGNsb25lT3B0aW9ucy52aXJ0dWFscyA9IG9wdGlvbnMudmlydHVhbHM7XG4gIH1cblxuICBjb25zdCBkZXBvcHVsYXRlID0gb3B0aW9ucy5kZXBvcHVsYXRlIHx8XG4gICAgKG9wdGlvbnMuX3BhcmVudE9wdGlvbnMgJiYgb3B0aW9ucy5fcGFyZW50T3B0aW9ucy5kZXBvcHVsYXRlIHx8IGZhbHNlKTtcbiAgLy8gX2lzTmVzdGVkIHdpbGwgb25seSBiZSB0cnVlIGlmIHRoaXMgaXMgbm90IHRoZSB0b3AgbGV2ZWwgZG9jdW1lbnQsIHdlXG4gIC8vIHNob3VsZCBuZXZlciBkZXBvcHVsYXRlIHRoZSB0b3AtbGV2ZWwgZG9jdW1lbnRcbiAgaWYgKGRlcG9wdWxhdGUgJiYgb3B0aW9ucy5faXNOZXN0ZWQgJiYgdGhpcy4kX18ud2FzUG9wdWxhdGVkKSB7XG4gICAgcmV0dXJuIGNsb25lKHRoaXMuJF9fLndhc1BvcHVsYXRlZC52YWx1ZSB8fCB0aGlzLl9pZCwgY2xvbmVPcHRpb25zKTtcbiAgfVxuXG4gIC8vIG1lcmdlIGRlZmF1bHQgb3B0aW9ucyB3aXRoIGlucHV0IG9wdGlvbnMuXG4gIG9wdGlvbnMgPSB7IC4uLmRlZmF1bHRPcHRpb25zLCAuLi5vcHRpb25zIH07XG4gIG9wdGlvbnMuX2lzTmVzdGVkID0gdHJ1ZTtcbiAgb3B0aW9ucy5qc29uID0ganNvbjtcbiAgb3B0aW9ucy5taW5pbWl6ZSA9IF9taW5pbWl6ZTtcblxuICBjbG9uZU9wdGlvbnMuX3BhcmVudE9wdGlvbnMgPSBvcHRpb25zO1xuICBjbG9uZU9wdGlvbnMuX3NraXBTaW5nbGVOZXN0ZWRHZXR0ZXJzID0gZmFsc2U7XG5cbiAgY29uc3QgZ2V0dGVyc09wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBjbG9uZU9wdGlvbnMpO1xuICBnZXR0ZXJzT3B0aW9ucy5fc2tpcFNpbmdsZU5lc3RlZEdldHRlcnMgPSB0cnVlO1xuXG4gIC8vIHJlbWVtYmVyIHRoZSByb290IHRyYW5zZm9ybSBmdW5jdGlvblxuICAvLyB0byBzYXZlIGl0IGZyb20gYmVpbmcgb3ZlcndyaXR0ZW4gYnkgc3ViLXRyYW5zZm9ybSBmdW5jdGlvbnNcbiAgY29uc3Qgb3JpZ2luYWxUcmFuc2Zvcm0gPSBvcHRpb25zLnRyYW5zZm9ybTtcblxuICBsZXQgcmV0ID0gY2xvbmUodGhpcy5fZG9jLCBjbG9uZU9wdGlvbnMpIHx8IHt9O1xuXG4gIGlmIChvcHRpb25zLmdldHRlcnMpIHtcbiAgICBhcHBseUdldHRlcnModGhpcywgcmV0LCBnZXR0ZXJzT3B0aW9ucyk7XG5cbiAgICBpZiAob3B0aW9ucy5taW5pbWl6ZSkge1xuICAgICAgcmV0ID0gbWluaW1pemUocmV0KSB8fCB7fTtcbiAgICB9XG4gIH1cblxuICBpZiAob3B0aW9ucy52aXJ0dWFscyB8fCAob3B0aW9ucy5nZXR0ZXJzICYmIG9wdGlvbnMudmlydHVhbHMgIT09IGZhbHNlKSkge1xuICAgIGFwcGx5VmlydHVhbHModGhpcywgcmV0LCBnZXR0ZXJzT3B0aW9ucywgb3B0aW9ucyk7XG4gIH1cblxuICBpZiAob3B0aW9ucy52ZXJzaW9uS2V5ID09PSBmYWxzZSAmJiB0aGlzLiRfX3NjaGVtYS5vcHRpb25zLnZlcnNpb25LZXkpIHtcbiAgICBkZWxldGUgcmV0W3RoaXMuJF9fc2NoZW1hLm9wdGlvbnMudmVyc2lvbktleV07XG4gIH1cblxuICBsZXQgdHJhbnNmb3JtID0gb3B0aW9ucy50cmFuc2Zvcm07XG5cbiAgLy8gSW4gdGhlIGNhc2Ugd2hlcmUgYSBzdWJkb2N1bWVudCBoYXMgaXRzIG93biB0cmFuc2Zvcm0gZnVuY3Rpb24sIHdlIG5lZWQgdG9cbiAgLy8gY2hlY2sgYW5kIHNlZSBpZiB0aGUgcGFyZW50IGhhcyBhIHRyYW5zZm9ybSAob3B0aW9ucy50cmFuc2Zvcm0pIGFuZCBpZiB0aGVcbiAgLy8gY2hpbGQgc2NoZW1hIGhhcyBhIHRyYW5zZm9ybSAodGhpcy5zY2hlbWEub3B0aW9ucy50b09iamVjdCkgSW4gdGhpcyBjYXNlLFxuICAvLyB3ZSBuZWVkIHRvIGFkanVzdCBvcHRpb25zLnRyYW5zZm9ybSB0byBiZSB0aGUgY2hpbGQgc2NoZW1hJ3MgdHJhbnNmb3JtIGFuZFxuICAvLyBub3QgdGhlIHBhcmVudCBzY2hlbWEnc1xuICBpZiAodHJhbnNmb3JtKSB7XG4gICAgYXBwbHlTY2hlbWFUeXBlVHJhbnNmb3Jtcyh0aGlzLCByZXQpO1xuICB9XG5cbiAgaWYgKG9wdGlvbnMudXNlUHJvamVjdGlvbikge1xuICAgIG9taXREZXNlbGVjdGVkRmllbGRzKHRoaXMsIHJldCk7XG4gIH1cblxuICBpZiAodHJhbnNmb3JtID09PSB0cnVlIHx8IChzY2hlbWFPcHRpb25zLnRvT2JqZWN0ICYmIHRyYW5zZm9ybSkpIHtcbiAgICBjb25zdCBvcHRzID0gb3B0aW9ucy5qc29uID8gc2NoZW1hT3B0aW9ucy50b0pTT04gOiBzY2hlbWFPcHRpb25zLnRvT2JqZWN0O1xuXG4gICAgaWYgKG9wdHMpIHtcbiAgICAgIHRyYW5zZm9ybSA9ICh0eXBlb2Ygb3B0aW9ucy50cmFuc2Zvcm0gPT09ICdmdW5jdGlvbicgPyBvcHRpb25zLnRyYW5zZm9ybSA6IG9wdHMudHJhbnNmb3JtKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgb3B0aW9ucy50cmFuc2Zvcm0gPSBvcmlnaW5hbFRyYW5zZm9ybTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgdHJhbnNmb3JtID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY29uc3QgeGZvcm1lZCA9IHRyYW5zZm9ybSh0aGlzLCByZXQsIG9wdGlvbnMpO1xuICAgIGlmICh0eXBlb2YgeGZvcm1lZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHJldCA9IHhmb3JtZWQ7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJldDtcbn07XG5cbi8qKlxuICogQ29udmVydHMgdGhpcyBkb2N1bWVudCBpbnRvIGEgcGxhaW4tb2xkIEphdmFTY3JpcHQgb2JqZWN0IChbUE9KT10oaHR0cHM6Ly9tYXN0ZXJpbmdqcy5pby90dXRvcmlhbHMvZnVuZGFtZW50YWxzL3Bvam8pKS5cbiAqXG4gKiBCdWZmZXJzIGFyZSBjb252ZXJ0ZWQgdG8gaW5zdGFuY2VzIG9mIFttb25nb2RiLkJpbmFyeV0oaHR0cHM6Ly9tb25nb2RiLmdpdGh1Yi5pby9ub2RlLW1vbmdvZGItbmF0aXZlLzQuOS9jbGFzc2VzL0JpbmFyeS5odG1sKSBmb3IgcHJvcGVyIHN0b3JhZ2UuXG4gKlxuICogIyMjIyBHZXR0ZXJzL1ZpcnR1YWxzXG4gKlxuICogRXhhbXBsZSBvZiBvbmx5IGFwcGx5aW5nIHBhdGggZ2V0dGVyc1xuICpcbiAqICAgICBkb2MudG9PYmplY3QoeyBnZXR0ZXJzOiB0cnVlLCB2aXJ0dWFsczogZmFsc2UgfSlcbiAqXG4gKiBFeGFtcGxlIG9mIG9ubHkgYXBwbHlpbmcgdmlydHVhbCBnZXR0ZXJzXG4gKlxuICogICAgIGRvYy50b09iamVjdCh7IHZpcnR1YWxzOiB0cnVlIH0pXG4gKlxuICogRXhhbXBsZSBvZiBhcHBseWluZyBib3RoIHBhdGggYW5kIHZpcnR1YWwgZ2V0dGVyc1xuICpcbiAqICAgICBkb2MudG9PYmplY3QoeyBnZXR0ZXJzOiB0cnVlIH0pXG4gKlxuICogVG8gYXBwbHkgdGhlc2Ugb3B0aW9ucyB0byBldmVyeSBkb2N1bWVudCBvZiB5b3VyIHNjaGVtYSBieSBkZWZhdWx0LCBzZXQgeW91ciBbc2NoZW1hc10oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2FwaS9zY2hlbWEuaHRtbCNTY2hlbWEoKSkgYHRvT2JqZWN0YCBvcHRpb24gdG8gdGhlIHNhbWUgYXJndW1lbnQuXG4gKlxuICogICAgIHNjaGVtYS5zZXQoJ3RvT2JqZWN0JywgeyB2aXJ0dWFsczogdHJ1ZSB9KVxuICpcbiAqICMjIyMgVHJhbnNmb3JtOlxuICpcbiAqIFdlIG1heSBuZWVkIHRvIHBlcmZvcm0gYSB0cmFuc2Zvcm1hdGlvbiBvZiB0aGUgcmVzdWx0aW5nIG9iamVjdCBiYXNlZCBvbiBzb21lIGNyaXRlcmlhLCBzYXkgdG8gcmVtb3ZlIHNvbWUgc2Vuc2l0aXZlIGluZm9ybWF0aW9uIG9yIHJldHVybiBhIGN1c3RvbSBvYmplY3QuIEluIHRoaXMgY2FzZSB3ZSBzZXQgdGhlIG9wdGlvbmFsIGB0cmFuc2Zvcm1gIGZ1bmN0aW9uLlxuICpcbiAqIFRyYW5zZm9ybSBmdW5jdGlvbnMgcmVjZWl2ZSB0aHJlZSBhcmd1bWVudHNcbiAqXG4gKiAgICAgZnVuY3Rpb24gKGRvYywgcmV0LCBvcHRpb25zKSB7fVxuICpcbiAqIC0gYGRvY2AgVGhlIG1vbmdvb3NlIGRvY3VtZW50IHdoaWNoIGlzIGJlaW5nIGNvbnZlcnRlZFxuICogLSBgcmV0YCBUaGUgcGxhaW4gb2JqZWN0IHJlcHJlc2VudGF0aW9uIHdoaWNoIGhhcyBiZWVuIGNvbnZlcnRlZFxuICogLSBgb3B0aW9uc2AgVGhlIG9wdGlvbnMgaW4gdXNlIChlaXRoZXIgc2NoZW1hIG9wdGlvbnMgb3IgdGhlIG9wdGlvbnMgcGFzc2VkIGlubGluZSlcbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIC8vIHNwZWNpZnkgdGhlIHRyYW5zZm9ybSBzY2hlbWEgb3B0aW9uXG4gKiAgICAgaWYgKCFzY2hlbWEub3B0aW9ucy50b09iamVjdCkgc2NoZW1hLm9wdGlvbnMudG9PYmplY3QgPSB7fTtcbiAqICAgICBzY2hlbWEub3B0aW9ucy50b09iamVjdC50cmFuc2Zvcm0gPSBmdW5jdGlvbiAoZG9jLCByZXQsIG9wdGlvbnMpIHtcbiAqICAgICAgIC8vIHJlbW92ZSB0aGUgX2lkIG9mIGV2ZXJ5IGRvY3VtZW50IGJlZm9yZSByZXR1cm5pbmcgdGhlIHJlc3VsdFxuICogICAgICAgZGVsZXRlIHJldC5faWQ7XG4gKiAgICAgICByZXR1cm4gcmV0O1xuICogICAgIH1cbiAqXG4gKiAgICAgLy8gd2l0aG91dCB0aGUgdHJhbnNmb3JtYXRpb24gaW4gdGhlIHNjaGVtYVxuICogICAgIGRvYy50b09iamVjdCgpOyAvLyB7IF9pZDogJ2FuSWQnLCBuYW1lOiAnV3JlY2staXQgUmFscGgnIH1cbiAqXG4gKiAgICAgLy8gd2l0aCB0aGUgdHJhbnNmb3JtYXRpb25cbiAqICAgICBkb2MudG9PYmplY3QoKTsgLy8geyBuYW1lOiAnV3JlY2staXQgUmFscGgnIH1cbiAqXG4gKiBXaXRoIHRyYW5zZm9ybWF0aW9ucyB3ZSBjYW4gZG8gYSBsb3QgbW9yZSB0aGFuIHJlbW92ZSBwcm9wZXJ0aWVzLiBXZSBjYW4gZXZlbiByZXR1cm4gY29tcGxldGVseSBuZXcgY3VzdG9taXplZCBvYmplY3RzOlxuICpcbiAqICAgICBpZiAoIXNjaGVtYS5vcHRpb25zLnRvT2JqZWN0KSBzY2hlbWEub3B0aW9ucy50b09iamVjdCA9IHt9O1xuICogICAgIHNjaGVtYS5vcHRpb25zLnRvT2JqZWN0LnRyYW5zZm9ybSA9IGZ1bmN0aW9uIChkb2MsIHJldCwgb3B0aW9ucykge1xuICogICAgICAgcmV0dXJuIHsgbW92aWU6IHJldC5uYW1lIH1cbiAqICAgICB9XG4gKlxuICogICAgIC8vIHdpdGhvdXQgdGhlIHRyYW5zZm9ybWF0aW9uIGluIHRoZSBzY2hlbWFcbiAqICAgICBkb2MudG9PYmplY3QoKTsgLy8geyBfaWQ6ICdhbklkJywgbmFtZTogJ1dyZWNrLWl0IFJhbHBoJyB9XG4gKlxuICogICAgIC8vIHdpdGggdGhlIHRyYW5zZm9ybWF0aW9uXG4gKiAgICAgZG9jLnRvT2JqZWN0KCk7IC8vIHsgbW92aWU6ICdXcmVjay1pdCBSYWxwaCcgfVxuICpcbiAqIF9Ob3RlOiBpZiBhIHRyYW5zZm9ybSBmdW5jdGlvbiByZXR1cm5zIGB1bmRlZmluZWRgLCB0aGUgcmV0dXJuIHZhbHVlIHdpbGwgYmUgaWdub3JlZC5fXG4gKlxuICogVHJhbnNmb3JtYXRpb25zIG1heSBhbHNvIGJlIGFwcGxpZWQgaW5saW5lLCBvdmVycmlkZGluZyBhbnkgdHJhbnNmb3JtIHNldCBpbiB0aGUgc2NoZW1hIG9wdGlvbnMuXG4gKiBBbnkgdHJhbnNmb3JtIGZ1bmN0aW9uIHNwZWNpZmllZCBpbiBgdG9PYmplY3RgIG9wdGlvbnMgYWxzbyBwcm9wYWdhdGVzIHRvIGFueSBzdWJkb2N1bWVudHMuXG4gKlxuICogICAgIGZ1bmN0aW9uIGRlbGV0ZUlkKGRvYywgcmV0LCBvcHRpb25zKSB7XG4gKiAgICAgICBkZWxldGUgcmV0Ll9pZDtcbiAqICAgICAgIHJldHVybiByZXQ7XG4gKiAgICAgfVxuICpcbiAqICAgICBjb25zdCBzY2hlbWEgPSBtb25nb29zZS5TY2hlbWEoeyBuYW1lOiBTdHJpbmcsIGRvY0FycjogW3sgbmFtZTogU3RyaW5nIH1dIH0pO1xuICogICAgIGNvbnN0IFRlc3RNb2RlbCA9IG1vbmdvb3NlLm1vZGVsKCdUZXN0Jywgc2NoZW1hKTtcbiAqXG4gKiAgICAgY29uc3QgZG9jID0gbmV3IFRlc3RNb2RlbCh7IG5hbWU6ICd0ZXN0JywgZG9jQXJyOiBbeyBuYW1lOiAndGVzdCcgfV0gfSk7XG4gKlxuICogICAgIC8vIHBhc3MgdGhlIHRyYW5zZm9ybSBhcyBhbiBpbmxpbmUgb3B0aW9uLiBEZWxldGVzIGBfaWRgIHByb3BlcnR5XG4gKiAgICAgLy8gZnJvbSBib3RoIHRoZSB0b3AtbGV2ZWwgZG9jdW1lbnQgYW5kIHRoZSBzdWJkb2N1bWVudC5cbiAqICAgICBjb25zdCBvYmogPSBkb2MudG9PYmplY3QoeyB0cmFuc2Zvcm06IGRlbGV0ZUlkIH0pO1xuICogICAgIG9iai5faWQ7IC8vIHVuZGVmaW5lZFxuICogICAgIG9iai5kb2NBcnJbMF0uX2lkOyAvLyB1bmRlZmluZWRcbiAqXG4gKiBJZiB5b3Ugd2FudCB0byBza2lwIHRyYW5zZm9ybWF0aW9ucywgdXNlIGB0cmFuc2Zvcm06IGZhbHNlYDpcbiAqXG4gKiAgICAgc2NoZW1hLm9wdGlvbnMudG9PYmplY3QuaGlkZSA9ICdfaWQnO1xuICogICAgIHNjaGVtYS5vcHRpb25zLnRvT2JqZWN0LnRyYW5zZm9ybSA9IGZ1bmN0aW9uIChkb2MsIHJldCwgb3B0aW9ucykge1xuICogICAgICAgaWYgKG9wdGlvbnMuaGlkZSkge1xuICogICAgICAgICBvcHRpb25zLmhpZGUuc3BsaXQoJyAnKS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7XG4gKiAgICAgICAgICAgZGVsZXRlIHJldFtwcm9wXTtcbiAqICAgICAgICAgfSk7XG4gKiAgICAgICB9XG4gKiAgICAgICByZXR1cm4gcmV0O1xuICogICAgIH1cbiAqXG4gKiAgICAgY29uc3QgZG9jID0gbmV3IERvYyh7IF9pZDogJ2FuSWQnLCBzZWNyZXQ6IDQ3LCBuYW1lOiAnV3JlY2staXQgUmFscGgnIH0pO1xuICogICAgIGRvYy50b09iamVjdCgpOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB7IHNlY3JldDogNDcsIG5hbWU6ICdXcmVjay1pdCBSYWxwaCcgfVxuICogICAgIGRvYy50b09iamVjdCh7IGhpZGU6ICdzZWNyZXQgX2lkJywgdHJhbnNmb3JtOiBmYWxzZSB9KTsvLyB7IF9pZDogJ2FuSWQnLCBzZWNyZXQ6IDQ3LCBuYW1lOiAnV3JlY2staXQgUmFscGgnIH1cbiAqICAgICBkb2MudG9PYmplY3QoeyBoaWRlOiAnc2VjcmV0IF9pZCcsIHRyYW5zZm9ybTogdHJ1ZSB9KTsgLy8geyBuYW1lOiAnV3JlY2staXQgUmFscGgnIH1cbiAqXG4gKiBJZiB5b3UgcGFzcyBhIHRyYW5zZm9ybSBpbiBgdG9PYmplY3QoKWAgb3B0aW9ucywgTW9uZ29vc2Ugd2lsbCBhcHBseSB0aGUgdHJhbnNmb3JtXG4gKiB0byBbc3ViZG9jdW1lbnRzXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3Mvc3ViZG9jcy5odG1sKSBpbiBhZGRpdGlvbiB0byB0aGUgdG9wLWxldmVsIGRvY3VtZW50LlxuICogU2ltaWxhcmx5LCBgdHJhbnNmb3JtOiBmYWxzZWAgc2tpcHMgdHJhbnNmb3JtcyBmb3IgYWxsIHN1YmRvY3VtZW50cy5cbiAqIE5vdGUgdGhhdCB0aGlzIGJlaGF2aW9yIGlzIGRpZmZlcmVudCBmb3IgdHJhbnNmb3JtcyBkZWZpbmVkIGluIHRoZSBzY2hlbWE6XG4gKiBpZiB5b3UgZGVmaW5lIGEgdHJhbnNmb3JtIGluIGBzY2hlbWEub3B0aW9ucy50b09iamVjdC50cmFuc2Zvcm1gLCB0aGF0IHRyYW5zZm9ybVxuICogd2lsbCAqKm5vdCoqIGFwcGx5IHRvIHN1YmRvY3VtZW50cy5cbiAqXG4gKiAgICAgY29uc3QgbWVtYmVyU2NoZW1hID0gbmV3IFNjaGVtYSh7IG5hbWU6IFN0cmluZywgZW1haWw6IFN0cmluZyB9KTtcbiAqICAgICBjb25zdCBncm91cFNjaGVtYSA9IG5ldyBTY2hlbWEoeyBtZW1iZXJzOiBbbWVtYmVyU2NoZW1hXSwgbmFtZTogU3RyaW5nLCBlbWFpbCB9KTtcbiAqICAgICBjb25zdCBHcm91cCA9IG1vbmdvb3NlLm1vZGVsKCdHcm91cCcsIGdyb3VwU2NoZW1hKTtcbiAqXG4gKiAgICAgY29uc3QgZG9jID0gbmV3IEdyb3VwKHtcbiAqICAgICAgIG5hbWU6ICdFbmdpbmVlcmluZycsXG4gKiAgICAgICBlbWFpbDogJ2RldkBtb25nb29zZWpzLmlvJyxcbiAqICAgICAgIG1lbWJlcnM6IFt7IG5hbWU6ICdWYWwnLCBlbWFpbDogJ3ZhbEBtb25nb29zZWpzLmlvJyB9XVxuICogICAgIH0pO1xuICpcbiAqICAgICAvLyBSZW1vdmVzIGBlbWFpbGAgZnJvbSBib3RoIHRvcC1sZXZlbCBkb2N1bWVudCAqKmFuZCoqIGFycmF5IGVsZW1lbnRzXG4gKiAgICAgLy8geyBuYW1lOiAnRW5naW5lZXJpbmcnLCBtZW1iZXJzOiBbeyBuYW1lOiAnVmFsJyB9XSB9XG4gKiAgICAgZG9jLnRvT2JqZWN0KHsgdHJhbnNmb3JtOiAoZG9jLCByZXQpID0+IHsgZGVsZXRlIHJldC5lbWFpbDsgcmV0dXJuIHJldDsgfSB9KTtcbiAqXG4gKiBUcmFuc2Zvcm1zLCBsaWtlIGFsbCBvZiB0aGVzZSBvcHRpb25zLCBhcmUgYWxzbyBhdmFpbGFibGUgZm9yIGB0b0pTT05gLiBTZWUgW3RoaXMgZ3VpZGUgdG8gYEpTT04uc3RyaW5naWZ5KClgXShodHRwczovL3RoZWNvZGViYXJiYXJpYW4uY29tL3RoZS04MC0yMC1ndWlkZS10by1qc29uLXN0cmluZ2lmeS1pbi1qYXZhc2NyaXB0Lmh0bWwpIHRvIGxlYXJuIHdoeSBgdG9KU09OKClgIGFuZCBgdG9PYmplY3QoKWAgYXJlIHNlcGFyYXRlIGZ1bmN0aW9ucy5cbiAqXG4gKiBTZWUgW3NjaGVtYSBvcHRpb25zXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvZ3VpZGUuaHRtbCN0b09iamVjdCkgZm9yIHNvbWUgbW9yZSBkZXRhaWxzLlxuICpcbiAqIF9EdXJpbmcgc2F2ZSwgbm8gY3VzdG9tIG9wdGlvbnMgYXJlIGFwcGxpZWQgdG8gdGhlIGRvY3VtZW50IGJlZm9yZSBiZWluZyBzZW50IHRvIHRoZSBkYXRhYmFzZS5fXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5nZXR0ZXJzPWZhbHNlXSBpZiB0cnVlLCBhcHBseSBhbGwgZ2V0dGVycywgaW5jbHVkaW5nIHZpcnR1YWxzXG4gKiBAcGFyYW0ge0Jvb2xlYW58T2JqZWN0fSBbb3B0aW9ucy52aXJ0dWFscz1mYWxzZV0gaWYgdHJ1ZSwgYXBwbHkgdmlydHVhbHMsIGluY2x1ZGluZyBhbGlhc2VzLiBVc2UgYHsgZ2V0dGVyczogdHJ1ZSwgdmlydHVhbHM6IGZhbHNlIH1gIHRvIGp1c3QgYXBwbHkgZ2V0dGVycywgbm90IHZpcnR1YWxzLiBBbiBvYmplY3Qgb2YgdGhlIGZvcm0gYHsgcGF0aHNUb1NraXA6IFsnc29tZVZpcnR1YWwnXSB9YCBtYXkgYWxzbyBiZSB1c2VkIHRvIG9taXQgc3BlY2lmaWMgdmlydHVhbHMuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmFsaWFzZXM9dHJ1ZV0gaWYgYG9wdGlvbnMudmlydHVhbHMgPSB0cnVlYCwgeW91IGNhbiBzZXQgYG9wdGlvbnMuYWxpYXNlcyA9IGZhbHNlYCB0byBza2lwIGFwcGx5aW5nIGFsaWFzZXMuIFRoaXMgb3B0aW9uIGlzIGEgbm8tb3AgaWYgYG9wdGlvbnMudmlydHVhbHMgPSBmYWxzZWAuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLm1pbmltaXplPXRydWVdIGlmIHRydWUsIG9taXQgYW55IGVtcHR5IG9iamVjdHMgZnJvbSB0aGUgb3V0cHV0XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufG51bGx9IFtvcHRpb25zLnRyYW5zZm9ybT1udWxsXSBpZiBzZXQsIG1vbmdvb3NlIHdpbGwgY2FsbCB0aGlzIGZ1bmN0aW9uIHRvIGFsbG93IHlvdSB0byB0cmFuc2Zvcm0gdGhlIHJldHVybmVkIG9iamVjdFxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5kZXBvcHVsYXRlPWZhbHNlXSBpZiB0cnVlLCByZXBsYWNlIGFueSBjb252ZW50aW9uYWxseSBwb3B1bGF0ZWQgcGF0aHMgd2l0aCB0aGUgb3JpZ2luYWwgaWQgaW4gdGhlIG91dHB1dC4gSGFzIG5vIGFmZmVjdCBvbiB2aXJ0dWFsIHBvcHVsYXRlZCBwYXRocy5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMudmVyc2lvbktleT10cnVlXSBpZiBmYWxzZSwgZXhjbHVkZSB0aGUgdmVyc2lvbiBrZXkgKGBfX3ZgIGJ5IGRlZmF1bHQpIGZyb20gdGhlIG91dHB1dFxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5mbGF0dGVuTWFwcz1mYWxzZV0gaWYgdHJ1ZSwgY29udmVydCBNYXBzIHRvIFBPSk9zLiBVc2VmdWwgaWYgeW91IHdhbnQgdG8gYEpTT04uc3RyaW5naWZ5KClgIHRoZSByZXN1bHQgb2YgYHRvT2JqZWN0KClgLlxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5mbGF0dGVuT2JqZWN0SWRzPWZhbHNlXSBpZiB0cnVlLCBjb252ZXJ0IGFueSBPYmplY3RJZHMgaW4gdGhlIHJlc3VsdCB0byAyNCBjaGFyYWN0ZXIgaGV4IHN0cmluZ3MuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnVzZVByb2plY3Rpb249ZmFsc2VdIC0gSWYgdHJ1ZSwgb21pdHMgZmllbGRzIHRoYXQgYXJlIGV4Y2x1ZGVkIGluIHRoaXMgZG9jdW1lbnQncyBwcm9qZWN0aW9uLiBVbmxlc3MgeW91IHNwZWNpZmllZCBhIHByb2plY3Rpb24sIHRoaXMgd2lsbCBvbWl0IGFueSBmaWVsZCB0aGF0IGhhcyBgc2VsZWN0OiBmYWxzZWAgaW4gdGhlIHNjaGVtYS5cbiAqIEByZXR1cm4ge09iamVjdH0ganMgb2JqZWN0IChub3QgYSBQT0pPKVxuICogQHNlZSBtb25nb2RiLkJpbmFyeSBodHRwczovL21vbmdvZGIuZ2l0aHViLmlvL25vZGUtbW9uZ29kYi1uYXRpdmUvNC45L2NsYXNzZXMvQmluYXJ5Lmh0bWxcbiAqIEBhcGkgcHVibGljXG4gKiBAbWVtYmVyT2YgRG9jdW1lbnRcbiAqIEBpbnN0YW5jZVxuICovXG5cbkRvY3VtZW50LnByb3RvdHlwZS50b09iamVjdCA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgcmV0dXJuIHRoaXMuJHRvT2JqZWN0KG9wdGlvbnMpO1xufTtcblxuLyohXG4gKiBBcHBsaWVzIHZpcnR1YWxzIHByb3BlcnRpZXMgdG8gYGpzb25gLlxuICovXG5cbmZ1bmN0aW9uIGFwcGx5VmlydHVhbHMoc2VsZiwganNvbiwgb3B0aW9ucywgdG9PYmplY3RPcHRpb25zKSB7XG4gIGNvbnN0IHNjaGVtYSA9IHNlbGYuJF9fc2NoZW1hO1xuICBjb25zdCBwYXRocyA9IE9iamVjdC5rZXlzKHNjaGVtYS52aXJ0dWFscyk7XG4gIGxldCBpID0gcGF0aHMubGVuZ3RoO1xuICBjb25zdCBudW1QYXRocyA9IGk7XG4gIGxldCBwYXRoO1xuICBsZXQgYXNzaWduUGF0aDtcbiAgbGV0IGN1ciA9IHNlbGYuX2RvYztcbiAgbGV0IHY7XG4gIGNvbnN0IGFsaWFzZXMgPSB0eXBlb2YgKHRvT2JqZWN0T3B0aW9ucyAmJiB0b09iamVjdE9wdGlvbnMuYWxpYXNlcykgPT09ICdib29sZWFuJ1xuICAgID8gdG9PYmplY3RPcHRpb25zLmFsaWFzZXNcbiAgICA6IHRydWU7XG5cbiAgbGV0IHZpcnR1YWxzVG9BcHBseSA9IG51bGw7XG4gIGlmIChBcnJheS5pc0FycmF5KG9wdGlvbnMudmlydHVhbHMpKSB7XG4gICAgdmlydHVhbHNUb0FwcGx5ID0gbmV3IFNldChvcHRpb25zLnZpcnR1YWxzKTtcbiAgfSBlbHNlIGlmIChvcHRpb25zLnZpcnR1YWxzICYmIG9wdGlvbnMudmlydHVhbHMucGF0aHNUb1NraXApIHtcbiAgICB2aXJ0dWFsc1RvQXBwbHkgPSBuZXcgU2V0KHBhdGhzKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG9wdGlvbnMudmlydHVhbHMucGF0aHNUb1NraXAubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICh2aXJ0dWFsc1RvQXBwbHkuaGFzKG9wdGlvbnMudmlydHVhbHMucGF0aHNUb1NraXBbaV0pKSB7XG4gICAgICAgIHZpcnR1YWxzVG9BcHBseS5kZWxldGUob3B0aW9ucy52aXJ0dWFscy5wYXRoc1RvU2tpcFtpXSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKCFjdXIpIHtcbiAgICByZXR1cm4ganNvbjtcbiAgfVxuXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBmb3IgKGkgPSAwOyBpIDwgbnVtUGF0aHM7ICsraSkge1xuICAgIHBhdGggPSBwYXRoc1tpXTtcblxuICAgIGlmICh2aXJ0dWFsc1RvQXBwbHkgIT0gbnVsbCAmJiAhdmlydHVhbHNUb0FwcGx5LmhhcyhwYXRoKSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gQWxsb3cgc2tpcHBpbmcgYWxpYXNlcyB3aXRoIGB0b09iamVjdCh7IHZpcnR1YWxzOiB0cnVlLCBhbGlhc2VzOiBmYWxzZSB9KWBcbiAgICBpZiAoIWFsaWFzZXMgJiYgc2NoZW1hLmFsaWFzZXMuaGFzT3duUHJvcGVydHkocGF0aCkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIFdlIG1heSBiZSBhcHBseWluZyB2aXJ0dWFscyB0byBhIG5lc3RlZCBvYmplY3QsIGZvciBleGFtcGxlIGlmIGNhbGxpbmdcbiAgICAvLyBgZG9jLm5lc3RlZFByb3AudG9KU09OKClgLiBJZiBzbywgdGhlIHBhdGggd2UgYXNzaWduIHRvLCBgYXNzaWduUGF0aGAsXG4gICAgLy8gd2lsbCBiZSBhIHRyYWlsaW5nIHN1YnN0cmluZyBvZiB0aGUgYHBhdGhgLlxuICAgIGFzc2lnblBhdGggPSBwYXRoO1xuICAgIGlmIChvcHRpb25zLnBhdGggIT0gbnVsbCkge1xuICAgICAgaWYgKCFwYXRoLnN0YXJ0c1dpdGgob3B0aW9ucy5wYXRoICsgJy4nKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGFzc2lnblBhdGggPSBwYXRoLnN1YnN0cmluZyhvcHRpb25zLnBhdGgubGVuZ3RoICsgMSk7XG4gICAgfVxuICAgIGNvbnN0IHBhcnRzID0gYXNzaWduUGF0aC5zcGxpdCgnLicpO1xuICAgIHYgPSBjbG9uZShzZWxmLmdldChwYXRoKSwgb3B0aW9ucyk7XG4gICAgaWYgKHYgPT09IHZvaWQgMCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGNvbnN0IHBsZW4gPSBwYXJ0cy5sZW5ndGg7XG4gICAgY3VyID0ganNvbjtcbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IHBsZW4gLSAxOyArK2opIHtcbiAgICAgIGN1cltwYXJ0c1tqXV0gPSBjdXJbcGFydHNbal1dIHx8IHt9O1xuICAgICAgY3VyID0gY3VyW3BhcnRzW2pdXTtcbiAgICB9XG4gICAgY3VyW3BhcnRzW3BsZW4gLSAxXV0gPSB2O1xuICB9XG5cbiAgcmV0dXJuIGpzb247XG59XG5cblxuLyoqXG4gKiBBcHBsaWVzIHZpcnR1YWxzIHByb3BlcnRpZXMgdG8gYGpzb25gLlxuICpcbiAqIEBwYXJhbSB7RG9jdW1lbnR9IHNlbGZcbiAqIEBwYXJhbSB7T2JqZWN0fSBqc29uXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiBAcmV0dXJuIHtPYmplY3R9IGBqc29uYFxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gYXBwbHlHZXR0ZXJzKHNlbGYsIGpzb24sIG9wdGlvbnMpIHtcbiAgY29uc3Qgc2NoZW1hID0gc2VsZi4kX19zY2hlbWE7XG4gIGNvbnN0IHBhdGhzID0gT2JqZWN0LmtleXMoc2NoZW1hLnBhdGhzKTtcbiAgbGV0IGkgPSBwYXRocy5sZW5ndGg7XG4gIGxldCBwYXRoO1xuICBsZXQgY3VyID0gc2VsZi5fZG9jO1xuICBsZXQgdjtcblxuICBpZiAoIWN1cikge1xuICAgIHJldHVybiBqc29uO1xuICB9XG5cbiAgd2hpbGUgKGktLSkge1xuICAgIHBhdGggPSBwYXRoc1tpXTtcblxuICAgIGNvbnN0IHBhcnRzID0gcGF0aC5zcGxpdCgnLicpO1xuXG4gICAgY29uc3QgcGxlbiA9IHBhcnRzLmxlbmd0aDtcbiAgICBjb25zdCBsYXN0ID0gcGxlbiAtIDE7XG4gICAgbGV0IGJyYW5jaCA9IGpzb247XG4gICAgbGV0IHBhcnQ7XG4gICAgY3VyID0gc2VsZi5fZG9jO1xuXG4gICAgaWYgKCFzZWxmLiRfX2lzU2VsZWN0ZWQocGF0aCkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGZvciAobGV0IGlpID0gMDsgaWkgPCBwbGVuOyArK2lpKSB7XG4gICAgICBwYXJ0ID0gcGFydHNbaWldO1xuICAgICAgdiA9IGN1cltwYXJ0XTtcbiAgICAgIGlmIChpaSA9PT0gbGFzdCkge1xuICAgICAgICBjb25zdCB2YWwgPSBzZWxmLiRnZXQocGF0aCk7XG4gICAgICAgIGJyYW5jaFtwYXJ0XSA9IGNsb25lKHZhbCwgb3B0aW9ucyk7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGJyYW5jaFtwYXJ0XSkgJiYgc2NoZW1hLnBhdGhzW3BhdGhdLiRlbWJlZGRlZFNjaGVtYVR5cGUpIHtcbiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJyYW5jaFtwYXJ0XS5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgYnJhbmNoW3BhcnRdW2ldID0gc2NoZW1hLnBhdGhzW3BhdGhdLiRlbWJlZGRlZFNjaGVtYVR5cGUuYXBwbHlHZXR0ZXJzKFxuICAgICAgICAgICAgICBicmFuY2hbcGFydF1baV0sXG4gICAgICAgICAgICAgIHNlbGZcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHYgPT0gbnVsbCkge1xuICAgICAgICBpZiAocGFydCBpbiBjdXIpIHtcbiAgICAgICAgICBicmFuY2hbcGFydF0gPSB2O1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYnJhbmNoID0gYnJhbmNoW3BhcnRdIHx8IChicmFuY2hbcGFydF0gPSB7fSk7XG4gICAgICB9XG4gICAgICBjdXIgPSB2O1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBqc29uO1xufVxuXG4vKipcbiAqIEFwcGxpZXMgc2NoZW1hIHR5cGUgdHJhbnNmb3JtcyB0byBganNvbmAuXG4gKlxuICogQHBhcmFtIHtEb2N1bWVudH0gc2VsZlxuICogQHBhcmFtIHtPYmplY3R9IGpzb25cbiAqIEByZXR1cm4ge09iamVjdH0gYGpzb25gXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBhcHBseVNjaGVtYVR5cGVUcmFuc2Zvcm1zKHNlbGYsIGpzb24pIHtcbiAgY29uc3Qgc2NoZW1hID0gc2VsZi4kX19zY2hlbWE7XG4gIGNvbnN0IHBhdGhzID0gT2JqZWN0LmtleXMoc2NoZW1hLnBhdGhzIHx8IHt9KTtcbiAgY29uc3QgY3VyID0gc2VsZi5fZG9jO1xuXG4gIGlmICghY3VyKSB7XG4gICAgcmV0dXJuIGpzb247XG4gIH1cblxuICBmb3IgKGNvbnN0IHBhdGggb2YgcGF0aHMpIHtcbiAgICBjb25zdCBzY2hlbWF0eXBlID0gc2NoZW1hLnBhdGhzW3BhdGhdO1xuICAgIGlmICh0eXBlb2Ygc2NoZW1hdHlwZS5vcHRpb25zLnRyYW5zZm9ybSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY29uc3QgdmFsID0gc2VsZi4kZ2V0KHBhdGgpO1xuICAgICAgaWYgKHZhbCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgY29uc3QgdHJhbnNmb3JtZWRWYWx1ZSA9IHNjaGVtYXR5cGUub3B0aW9ucy50cmFuc2Zvcm0uY2FsbChzZWxmLCB2YWwpO1xuICAgICAgdGhyb3dFcnJvcklmUHJvbWlzZShwYXRoLCB0cmFuc2Zvcm1lZFZhbHVlKTtcbiAgICAgIHV0aWxzLnNldFZhbHVlKHBhdGgsIHRyYW5zZm9ybWVkVmFsdWUsIGpzb24pO1xuICAgIH0gZWxzZSBpZiAoc2NoZW1hdHlwZS4kZW1iZWRkZWRTY2hlbWFUeXBlICE9IG51bGwgJiZcbiAgICAgICAgdHlwZW9mIHNjaGVtYXR5cGUuJGVtYmVkZGVkU2NoZW1hVHlwZS5vcHRpb25zLnRyYW5zZm9ybSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY29uc3QgdmFsID0gc2VsZi4kZ2V0KHBhdGgpO1xuICAgICAgaWYgKHZhbCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgY29uc3QgdmFscyA9IFtdLmNvbmNhdCh2YWwpO1xuICAgICAgY29uc3QgdHJhbnNmb3JtID0gc2NoZW1hdHlwZS4kZW1iZWRkZWRTY2hlbWFUeXBlLm9wdGlvbnMudHJhbnNmb3JtO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWxzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGNvbnN0IHRyYW5zZm9ybWVkVmFsdWUgPSB0cmFuc2Zvcm0uY2FsbChzZWxmLCB2YWxzW2ldKTtcbiAgICAgICAgdmFsc1tpXSA9IHRyYW5zZm9ybWVkVmFsdWU7XG4gICAgICAgIHRocm93RXJyb3JJZlByb21pc2UocGF0aCwgdHJhbnNmb3JtZWRWYWx1ZSk7XG4gICAgICB9XG5cbiAgICAgIGpzb25bcGF0aF0gPSB2YWxzO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBqc29uO1xufVxuXG5mdW5jdGlvbiB0aHJvd0Vycm9ySWZQcm9taXNlKHBhdGgsIHRyYW5zZm9ybWVkVmFsdWUpIHtcbiAgaWYgKGlzUHJvbWlzZSh0cmFuc2Zvcm1lZFZhbHVlKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignYHRyYW5zZm9ybWAgZnVuY3Rpb24gbXVzdCBiZSBzeW5jaHJvbm91cywgYnV0IHRoZSB0cmFuc2Zvcm0gb24gcGF0aCBgJyArIHBhdGggKyAnYCByZXR1cm5lZCBhIHByb21pc2UuJyk7XG4gIH1cbn1cblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5mdW5jdGlvbiBvbWl0RGVzZWxlY3RlZEZpZWxkcyhzZWxmLCBqc29uKSB7XG4gIGNvbnN0IHNjaGVtYSA9IHNlbGYuJF9fc2NoZW1hO1xuICBjb25zdCBwYXRocyA9IE9iamVjdC5rZXlzKHNjaGVtYS5wYXRocyB8fCB7fSk7XG4gIGNvbnN0IGN1ciA9IHNlbGYuX2RvYztcblxuICBpZiAoIWN1cikge1xuICAgIHJldHVybiBqc29uO1xuICB9XG5cbiAgbGV0IHNlbGVjdGVkID0gc2VsZi4kX18uc2VsZWN0ZWQ7XG4gIGlmIChzZWxlY3RlZCA9PT0gdm9pZCAwKSB7XG4gICAgc2VsZWN0ZWQgPSB7fTtcbiAgICBxdWVyeWhlbHBlcnMuYXBwbHlQYXRocyhzZWxlY3RlZCwgc2NoZW1hKTtcbiAgfVxuICBpZiAoc2VsZWN0ZWQgPT0gbnVsbCB8fCBPYmplY3Qua2V5cyhzZWxlY3RlZCkubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIGpzb247XG4gIH1cblxuICBmb3IgKGNvbnN0IHBhdGggb2YgcGF0aHMpIHtcbiAgICBpZiAoc2VsZWN0ZWRbcGF0aF0gIT0gbnVsbCAmJiAhc2VsZWN0ZWRbcGF0aF0pIHtcbiAgICAgIGRlbGV0ZSBqc29uW3BhdGhdO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBqc29uO1xufVxuXG4vKipcbiAqIFRoZSByZXR1cm4gdmFsdWUgb2YgdGhpcyBtZXRob2QgaXMgdXNlZCBpbiBjYWxscyB0byBbYEpTT04uc3RyaW5naWZ5KGRvYylgXShodHRwczovL3RoZWNvZGViYXJiYXJpYW4uY29tL3RoZS04MC0yMC1ndWlkZS10by1qc29uLXN0cmluZ2lmeS1pbi1qYXZhc2NyaXB0I3RoZS10b2pzb24tZnVuY3Rpb24pLlxuICpcbiAqIFRoaXMgbWV0aG9kIGFjY2VwdHMgdGhlIHNhbWUgb3B0aW9ucyBhcyBbRG9jdW1lbnQjdG9PYmplY3RdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvZG9jdW1lbnQuaHRtbCNEb2N1bWVudC5wcm90b3R5cGUudG9PYmplY3QoKSkuIFRvIGFwcGx5IHRoZSBvcHRpb25zIHRvIGV2ZXJ5IGRvY3VtZW50IG9mIHlvdXIgc2NoZW1hIGJ5IGRlZmF1bHQsIHNldCB5b3VyIFtzY2hlbWFzXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvYXBpL3NjaGVtYS5odG1sI1NjaGVtYSgpKSBgdG9KU09OYCBvcHRpb24gdG8gdGhlIHNhbWUgYXJndW1lbnQuXG4gKlxuICogICAgIHNjaGVtYS5zZXQoJ3RvSlNPTicsIHsgdmlydHVhbHM6IHRydWUgfSk7XG4gKlxuICogVGhlcmUgaXMgb25lIGRpZmZlcmVuY2UgYmV0d2VlbiBgdG9KU09OKClgIGFuZCBgdG9PYmplY3QoKWAgb3B0aW9ucy5cbiAqIFdoZW4geW91IGNhbGwgYHRvSlNPTigpYCwgdGhlIFtgZmxhdHRlbk1hcHNgIG9wdGlvbl0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2FwaS9kb2N1bWVudC5odG1sI0RvY3VtZW50LnByb3RvdHlwZS50b09iamVjdCgpKSBkZWZhdWx0cyB0byBgdHJ1ZWAsIGJlY2F1c2UgYEpTT04uc3RyaW5naWZ5KClgIGRvZXNuJ3QgY29udmVydCBtYXBzIHRvIG9iamVjdHMgYnkgZGVmYXVsdC5cbiAqIFdoZW4geW91IGNhbGwgYHRvT2JqZWN0KClgLCB0aGUgYGZsYXR0ZW5NYXBzYCBvcHRpb24gaXMgYGZhbHNlYCBieSBkZWZhdWx0LlxuICpcbiAqIFNlZSBbc2NoZW1hIG9wdGlvbnNdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9ndWlkZS5odG1sI3RvSlNPTikgZm9yIG1vcmUgaW5mb3JtYXRpb24gb24gc2V0dGluZyBgdG9KU09OYCBvcHRpb24gZGVmYXVsdHMuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuZmxhdHRlbk1hcHM9dHJ1ZV0gaWYgdHJ1ZSwgY29udmVydCBNYXBzIHRvIFtQT0pPc10oaHR0cHM6Ly9tYXN0ZXJpbmdqcy5pby90dXRvcmlhbHMvZnVuZGFtZW50YWxzL3Bvam8pLiBVc2VmdWwgaWYgeW91IHdhbnQgdG8gYEpTT04uc3RyaW5naWZ5KClgIHRoZSByZXN1bHQuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmZsYXR0ZW5PYmplY3RJZHM9ZmFsc2VdIGlmIHRydWUsIGNvbnZlcnQgYW55IE9iamVjdElkcyBpbiB0aGUgcmVzdWx0IHRvIDI0IGNoYXJhY3RlciBoZXggc3RyaW5ncy5cbiAqIEByZXR1cm4ge09iamVjdH1cbiAqIEBzZWUgRG9jdW1lbnQjdG9PYmplY3QgaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2FwaS9kb2N1bWVudC5odG1sI0RvY3VtZW50LnByb3RvdHlwZS50b09iamVjdCgpXG4gKiBAc2VlIEpTT04uc3RyaW5naWZ5KCkgaW4gSmF2YVNjcmlwdCBodHRwczovL3RoZWNvZGViYXJiYXJpYW4uY29tL3RoZS04MC0yMC1ndWlkZS10by1qc29uLXN0cmluZ2lmeS1pbi1qYXZhc2NyaXB0Lmh0bWxcbiAqIEBhcGkgcHVibGljXG4gKiBAbWVtYmVyT2YgRG9jdW1lbnRcbiAqIEBpbnN0YW5jZVxuICovXG5cbkRvY3VtZW50LnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gIHJldHVybiB0aGlzLiR0b09iamVjdChvcHRpb25zLCB0cnVlKTtcbn07XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxuRG9jdW1lbnQucHJvdG90eXBlLm93bmVyRG9jdW1lbnQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5cbi8qKlxuICogSWYgdGhpcyBkb2N1bWVudCBpcyBhIHN1YmRvY3VtZW50IG9yIHBvcHVsYXRlZCBkb2N1bWVudCwgcmV0dXJucyB0aGUgZG9jdW1lbnQnc1xuICogcGFyZW50LiBSZXR1cm5zIHRoZSBvcmlnaW5hbCBkb2N1bWVudCBpZiB0aGVyZSBpcyBubyBwYXJlbnQuXG4gKlxuICogQHJldHVybiB7RG9jdW1lbnR9XG4gKiBAYXBpIHB1YmxpY1xuICogQG1ldGhvZCBwYXJlbnRcbiAqIEBtZW1iZXJPZiBEb2N1bWVudFxuICogQGluc3RhbmNlXG4gKi9cblxuRG9jdW1lbnQucHJvdG90eXBlLnBhcmVudCA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy4kaXNTdWJkb2N1bWVudCB8fCB0aGlzLiRfXy53YXNQb3B1bGF0ZWQpIHtcbiAgICByZXR1cm4gdGhpcy4kX18ucGFyZW50O1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBBbGlhcyBmb3IgW2BwYXJlbnQoKWBdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvZG9jdW1lbnQuaHRtbCNEb2N1bWVudC5wcm90b3R5cGUucGFyZW50KCkpLiBJZiB0aGlzIGRvY3VtZW50IGlzIGEgc3ViZG9jdW1lbnQgb3IgcG9wdWxhdGVkXG4gKiBkb2N1bWVudCwgcmV0dXJucyB0aGUgZG9jdW1lbnQncyBwYXJlbnQuIFJldHVybnMgYHVuZGVmaW5lZGAgb3RoZXJ3aXNlLlxuICpcbiAqIEByZXR1cm4ge0RvY3VtZW50fVxuICogQGFwaSBwdWJsaWNcbiAqIEBtZXRob2QgJHBhcmVudFxuICogQG1lbWJlck9mIERvY3VtZW50XG4gKiBAaW5zdGFuY2VcbiAqL1xuXG5Eb2N1bWVudC5wcm90b3R5cGUuJHBhcmVudCA9IERvY3VtZW50LnByb3RvdHlwZS5wYXJlbnQ7XG5cbi8qKlxuICogSGVscGVyIGZvciBjb25zb2xlLmxvZ1xuICpcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHVibGljXG4gKiBAbWV0aG9kIGluc3BlY3RcbiAqIEBtZW1iZXJPZiBEb2N1bWVudFxuICogQGluc3RhbmNlXG4gKi9cblxuRG9jdW1lbnQucHJvdG90eXBlLmluc3BlY3QgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gIGNvbnN0IGlzUE9KTyA9IHV0aWxzLmlzUE9KTyhvcHRpb25zKTtcbiAgbGV0IG9wdHM7XG4gIGlmIChpc1BPSk8pIHtcbiAgICBvcHRzID0gb3B0aW9ucztcbiAgICBvcHRzLm1pbmltaXplID0gZmFsc2U7XG4gIH1cblxuICBjb25zdCByZXQgPSBhcmd1bWVudHMubGVuZ3RoID4gMCA/IHRoaXMudG9PYmplY3Qob3B0cykgOiB0aGlzLnRvT2JqZWN0KCk7XG5cbiAgaWYgKHJldCA9PSBudWxsKSB7XG4gICAgLy8gSWYgYHRvT2JqZWN0KClgIHJldHVybnMgbnVsbCwgYHRoaXNgIGlzIHN0aWxsIGFuIG9iamVjdCwgc28gaWYgYGluc3BlY3QoKWBcbiAgICAvLyBwcmludHMgb3V0IG51bGwgdGhpcyBjYW4gY2F1c2Ugc29tZSBzZXJpb3VzIGNvbmZ1c2lvbi4gU2VlIGdoLTc5NDIuXG4gICAgcmV0dXJuICdNb25nb29zZURvY3VtZW50IHsgJyArIHJldCArICcgfSc7XG4gIH1cblxuICByZXR1cm4gcmV0O1xufTtcblxuaWYgKGluc3BlY3QuY3VzdG9tKSB7XG4gIC8vIEF2b2lkIE5vZGUgZGVwcmVjYXRpb24gd2FybmluZyBERVAwMDc5XG4gIERvY3VtZW50LnByb3RvdHlwZVtpbnNwZWN0LmN1c3RvbV0gPSBEb2N1bWVudC5wcm90b3R5cGUuaW5zcGVjdDtcbn1cblxuLyoqXG4gKiBIZWxwZXIgZm9yIGNvbnNvbGUubG9nXG4gKlxuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwdWJsaWNcbiAqIEBtZXRob2QgdG9TdHJpbmdcbiAqIEBtZW1iZXJPZiBEb2N1bWVudFxuICogQGluc3RhbmNlXG4gKi9cblxuRG9jdW1lbnQucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gIGNvbnN0IHJldCA9IHRoaXMuaW5zcGVjdCgpO1xuICBpZiAodHlwZW9mIHJldCA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gcmV0O1xuICB9XG4gIHJldHVybiBpbnNwZWN0KHJldCk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGlzIGRvY3VtZW50IGlzIGVxdWFsIHRvIGFub3RoZXIgZG9jdW1lbnQuXG4gKlxuICogRG9jdW1lbnRzIGFyZSBjb25zaWRlcmVkIGVxdWFsIHdoZW4gdGhleSBoYXZlIG1hdGNoaW5nIGBfaWRgcywgdW5sZXNzIG5laXRoZXJcbiAqIGRvY3VtZW50IGhhcyBhbiBgX2lkYCwgaW4gd2hpY2ggY2FzZSB0aGlzIGZ1bmN0aW9uIGZhbGxzIGJhY2sgdG8gdXNpbmdcbiAqIGBkZWVwRXF1YWwoKWAuXG4gKlxuICogQHBhcmFtIHtEb2N1bWVudH0gW2RvY10gYSBkb2N1bWVudCB0byBjb21wYXJlLiBJZiBmYWxzeSwgd2lsbCBhbHdheXMgcmV0dXJuIFwiZmFsc2VcIi5cbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKiBAYXBpIHB1YmxpY1xuICogQG1lbWJlck9mIERvY3VtZW50XG4gKiBAaW5zdGFuY2VcbiAqL1xuXG5Eb2N1bWVudC5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24oZG9jKSB7XG4gIGlmICghZG9jKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgY29uc3QgdGlkID0gdGhpcy4kX19nZXRWYWx1ZSgnX2lkJyk7XG4gIGNvbnN0IGRvY2lkID0gZG9jLiRfXyAhPSBudWxsID8gZG9jLiRfX2dldFZhbHVlKCdfaWQnKSA6IGRvYztcbiAgaWYgKCF0aWQgJiYgIWRvY2lkKSB7XG4gICAgcmV0dXJuIGRlZXBFcXVhbCh0aGlzLCBkb2MpO1xuICB9XG4gIHJldHVybiB0aWQgJiYgdGlkLmVxdWFsc1xuICAgID8gdGlkLmVxdWFscyhkb2NpZClcbiAgICA6IHRpZCA9PT0gZG9jaWQ7XG59O1xuXG4vKipcbiAqIFBvcHVsYXRlcyBwYXRocyBvbiBhbiBleGlzdGluZyBkb2N1bWVudC5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIC8vIEdpdmVuIGEgZG9jdW1lbnQsIGBwb3B1bGF0ZSgpYCBsZXRzIHlvdSBwdWxsIGluIHJlZmVyZW5jZWQgZG9jc1xuICogICAgIGF3YWl0IGRvYy5wb3B1bGF0ZShbXG4gKiAgICAgICAnc3RvcmllcycsXG4gKiAgICAgICB7IHBhdGg6ICdmYW5zJywgc29ydDogeyBuYW1lOiAtMSB9IH1cbiAqICAgICBdKTtcbiAqICAgICBkb2MucG9wdWxhdGVkKCdzdG9yaWVzJyk7IC8vIEFycmF5IG9mIE9iamVjdElkc1xuICogICAgIGRvYy5zdG9yaWVzWzBdLnRpdGxlOyAvLyAnQ2FzaW5vIFJveWFsZSdcbiAqICAgICBkb2MucG9wdWxhdGVkKCdmYW5zJyk7IC8vIEFycmF5IG9mIE9iamVjdElkc1xuICpcbiAqICAgICAvLyBJZiB0aGUgcmVmZXJlbmNlZCBkb2MgaGFzIGJlZW4gZGVsZXRlZCwgYHBvcHVsYXRlKClgIHdpbGxcbiAqICAgICAvLyByZW1vdmUgdGhhdCBlbnRyeSBmcm9tIHRoZSBhcnJheS5cbiAqICAgICBhd2FpdCBTdG9yeS5kZWxldGUoeyB0aXRsZTogJ0Nhc2lubyBSb3lhbGUnIH0pO1xuICogICAgIGF3YWl0IGRvYy5wb3B1bGF0ZSgnc3RvcmllcycpOyAvLyBFbXB0eSBhcnJheVxuICpcbiAqICAgICAvLyBZb3UgY2FuIGFsc28gcGFzcyBhZGRpdGlvbmFsIHF1ZXJ5IG9wdGlvbnMgdG8gYHBvcHVsYXRlKClgLFxuICogICAgIC8vIGxpa2UgcHJvamVjdGlvbnM6XG4gKiAgICAgYXdhaXQgZG9jLnBvcHVsYXRlKCdmYW5zJywgJy1lbWFpbCcpO1xuICogICAgIGRvYy5mYW5zWzBdLmVtYWlsIC8vIHVuZGVmaW5lZCBiZWNhdXNlIG9mIDJuZCBwYXJhbSBgc2VsZWN0YFxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfE9iamVjdHxBcnJheX0gcGF0aCBlaXRoZXIgdGhlIHBhdGggdG8gcG9wdWxhdGUgb3IgYW4gb2JqZWN0IHNwZWNpZnlpbmcgYWxsIHBhcmFtZXRlcnMsIG9yIGVpdGhlciBhbiBhcnJheSBvZiB0aG9zZVxuICogQHBhcmFtIHtPYmplY3R8U3RyaW5nfSBbc2VsZWN0XSBGaWVsZCBzZWxlY3Rpb24gZm9yIHRoZSBwb3B1bGF0aW9uIHF1ZXJ5XG4gKiBAcGFyYW0ge01vZGVsfSBbbW9kZWxdIFRoZSBtb2RlbCB5b3Ugd2lzaCB0byB1c2UgZm9yIHBvcHVsYXRpb24uIElmIG5vdCBzcGVjaWZpZWQsIHBvcHVsYXRlIHdpbGwgbG9vayB1cCB0aGUgbW9kZWwgYnkgdGhlIG5hbWUgaW4gdGhlIFNjaGVtYSdzIGByZWZgIGZpZWxkLlxuICogQHBhcmFtIHtPYmplY3R9IFttYXRjaF0gQ29uZGl0aW9ucyBmb3IgdGhlIHBvcHVsYXRpb24gcXVlcnlcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyBmb3IgdGhlIHBvcHVsYXRpb24gcXVlcnkgKHNvcnQsIGV0YylcbiAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5wYXRoPW51bGxdIFRoZSBwYXRoIHRvIHBvcHVsYXRlLlxuICogQHBhcmFtIHtzdHJpbmd8UG9wdWxhdGVPcHRpb25zfSBbb3B0aW9ucy5wb3B1bGF0ZT1udWxsXSBSZWN1cnNpdmVseSBwb3B1bGF0ZSBwYXRocyBpbiB0aGUgcG9wdWxhdGVkIGRvY3VtZW50cy4gU2VlIFtkZWVwIHBvcHVsYXRlIGRvY3NdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9wb3B1bGF0ZS5odG1sI2RlZXAtcG9wdWxhdGUpLlxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5yZXRhaW5OdWxsVmFsdWVzPWZhbHNlXSBieSBkZWZhdWx0LCBNb25nb29zZSByZW1vdmVzIG51bGwgYW5kIHVuZGVmaW5lZCB2YWx1ZXMgZnJvbSBwb3B1bGF0ZWQgYXJyYXlzLiBVc2UgdGhpcyBvcHRpb24gdG8gbWFrZSBgcG9wdWxhdGUoKWAgcmV0YWluIGBudWxsYCBhbmQgYHVuZGVmaW5lZGAgYXJyYXkgZW50cmllcy5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuZ2V0dGVycz1mYWxzZV0gaWYgdHJ1ZSwgTW9uZ29vc2Ugd2lsbCBjYWxsIGFueSBnZXR0ZXJzIGRlZmluZWQgb24gdGhlIGBsb2NhbEZpZWxkYC4gQnkgZGVmYXVsdCwgTW9uZ29vc2UgZ2V0cyB0aGUgcmF3IHZhbHVlIG9mIGBsb2NhbEZpZWxkYC4gRm9yIGV4YW1wbGUsIHlvdSB3b3VsZCBuZWVkIHRvIHNldCB0aGlzIG9wdGlvbiB0byBgdHJ1ZWAgaWYgeW91IHdhbnRlZCB0byBbYWRkIGEgYGxvd2VyY2FzZWAgZ2V0dGVyIHRvIHlvdXIgYGxvY2FsRmllbGRgXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3Mvc2NoZW1hdHlwZXMuaHRtbCNzY2hlbWF0eXBlLW9wdGlvbnMpLlxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5jbG9uZT1mYWxzZV0gV2hlbiB5b3UgZG8gYEJsb2dQb3N0LmZpbmQoKS5wb3B1bGF0ZSgnYXV0aG9yJylgLCBibG9nIHBvc3RzIHdpdGggdGhlIHNhbWUgYXV0aG9yIHdpbGwgc2hhcmUgMSBjb3B5IG9mIGFuIGBhdXRob3JgIGRvYy4gRW5hYmxlIHRoaXMgb3B0aW9uIHRvIG1ha2UgTW9uZ29vc2UgY2xvbmUgcG9wdWxhdGVkIGRvY3MgYmVmb3JlIGFzc2lnbmluZyB0aGVtLlxuICogQHBhcmFtIHtPYmplY3R8RnVuY3Rpb259IFtvcHRpb25zLm1hdGNoPW51bGxdIEFkZCBhbiBhZGRpdGlvbmFsIGZpbHRlciB0byB0aGUgcG9wdWxhdGUgcXVlcnkuIENhbiBiZSBhIGZpbHRlciBvYmplY3QgY29udGFpbmluZyBbTW9uZ29EQiBxdWVyeSBzeW50YXhdKGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvbWFudWFsL3R1dG9yaWFsL3F1ZXJ5LWRvY3VtZW50cy8pLCBvciBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhIGZpbHRlciBvYmplY3QuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy50cmFuc2Zvcm09bnVsbF0gRnVuY3Rpb24gdGhhdCBNb25nb29zZSB3aWxsIGNhbGwgb24gZXZlcnkgcG9wdWxhdGVkIGRvY3VtZW50IHRoYXQgYWxsb3dzIHlvdSB0byB0cmFuc2Zvcm0gdGhlIHBvcHVsYXRlZCBkb2N1bWVudC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy5vcHRpb25zPW51bGxdIEFkZGl0aW9uYWwgb3B0aW9ucyBsaWtlIGBsaW1pdGAgYW5kIGBsZWFuYC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gQ2FsbGJhY2tcbiAqIEBzZWUgcG9wdWxhdGlvbiBodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvcG9wdWxhdGUuaHRtbFxuICogQHNlZSBRdWVyeSNzZWxlY3QgaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2FwaS9xdWVyeS5odG1sI1F1ZXJ5LnByb3RvdHlwZS5zZWxlY3QoKVxuICogQHNlZSBNb2RlbC5wb3B1bGF0ZSBodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvYXBpL21vZGVsLmh0bWwjTW9kZWwucG9wdWxhdGUoKVxuICogQG1lbWJlck9mIERvY3VtZW50XG4gKiBAaW5zdGFuY2VcbiAqIEByZXR1cm4ge1Byb21pc2V8bnVsbH0gUmV0dXJucyBhIFByb21pc2UgaWYgbm8gYGNhbGxiYWNrYCBpcyBnaXZlbi5cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuRG9jdW1lbnQucHJvdG90eXBlLnBvcHVsYXRlID0gYXN5bmMgZnVuY3Rpb24gcG9wdWxhdGUoKSB7XG4gIGNvbnN0IHBvcCA9IHt9O1xuICBjb25zdCBhcmdzID0gWy4uLmFyZ3VtZW50c107XG4gIGlmICh0eXBlb2YgYXJnc1thcmdzLmxlbmd0aCAtIDFdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IE1vbmdvb3NlRXJyb3IoJ0RvY3VtZW50LnByb3RvdHlwZS5wb3B1bGF0ZSgpIG5vIGxvbmdlciBhY2NlcHRzIGEgY2FsbGJhY2snKTtcbiAgfVxuXG4gIGlmIChhcmdzLmxlbmd0aCAhPT0gMCkge1xuICAgIC8vIHVzZSBoYXNoIHRvIHJlbW92ZSBkdXBsaWNhdGUgcGF0aHNcbiAgICBjb25zdCByZXMgPSB1dGlscy5wb3B1bGF0ZS5hcHBseShudWxsLCBhcmdzKTtcbiAgICBmb3IgKGNvbnN0IHBvcHVsYXRlT3B0aW9ucyBvZiByZXMpIHtcbiAgICAgIHBvcFtwb3B1bGF0ZU9wdGlvbnMucGF0aF0gPSBwb3B1bGF0ZU9wdGlvbnM7XG4gICAgfVxuICB9XG5cbiAgY29uc3QgcGF0aHMgPSB1dGlscy5vYmplY3QudmFscyhwb3ApO1xuICBsZXQgdG9wTGV2ZWxNb2RlbCA9IHRoaXMuY29uc3RydWN0b3I7XG4gIGlmICh0aGlzLiRfX2lzTmVzdGVkKSB7XG4gICAgdG9wTGV2ZWxNb2RlbCA9IHRoaXMuJF9fW3Njb3BlU3ltYm9sXS5jb25zdHJ1Y3RvcjtcbiAgICBjb25zdCBuZXN0ZWRQYXRoID0gdGhpcy4kX18ubmVzdGVkUGF0aDtcbiAgICBwYXRocy5mb3JFYWNoKGZ1bmN0aW9uKHBvcHVsYXRlT3B0aW9ucykge1xuICAgICAgcG9wdWxhdGVPcHRpb25zLnBhdGggPSBuZXN0ZWRQYXRoICsgJy4nICsgcG9wdWxhdGVPcHRpb25zLnBhdGg7XG4gICAgfSk7XG4gIH1cblxuICAvLyBVc2UgYCRzZXNzaW9uKClgIGJ5IGRlZmF1bHQgaWYgdGhlIGRvY3VtZW50IGhhcyBhbiBhc3NvY2lhdGVkIHNlc3Npb25cbiAgLy8gU2VlIGdoLTY3NTRcbiAgaWYgKHRoaXMuJHNlc3Npb24oKSAhPSBudWxsKSB7XG4gICAgY29uc3Qgc2Vzc2lvbiA9IHRoaXMuJHNlc3Npb24oKTtcbiAgICBwYXRocy5mb3JFYWNoKHBhdGggPT4ge1xuICAgICAgaWYgKHBhdGgub3B0aW9ucyA9PSBudWxsKSB7XG4gICAgICAgIHBhdGgub3B0aW9ucyA9IHsgc2Vzc2lvbjogc2Vzc2lvbiB9O1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoISgnc2Vzc2lvbicgaW4gcGF0aC5vcHRpb25zKSkge1xuICAgICAgICBwYXRoLm9wdGlvbnMuc2Vzc2lvbiA9IHNlc3Npb247XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBwYXRocy5mb3JFYWNoKHAgPT4ge1xuICAgIHAuX2xvY2FsTW9kZWwgPSB0b3BMZXZlbE1vZGVsO1xuICB9KTtcblxuICByZXR1cm4gdG9wTGV2ZWxNb2RlbC5wb3B1bGF0ZSh0aGlzLCBwYXRocyk7XG59O1xuXG4vKipcbiAqIEdldHMgYWxsIHBvcHVsYXRlZCBkb2N1bWVudHMgYXNzb2NpYXRlZCB3aXRoIHRoaXMgZG9jdW1lbnQuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqIEByZXR1cm4ge0RvY3VtZW50W119IGFycmF5IG9mIHBvcHVsYXRlZCBkb2N1bWVudHMuIEVtcHR5IGFycmF5IGlmIHRoZXJlIGFyZSBubyBwb3B1bGF0ZWQgZG9jdW1lbnRzIGFzc29jaWF0ZWQgd2l0aCB0aGlzIGRvY3VtZW50LlxuICogQG1lbWJlck9mIERvY3VtZW50XG4gKiBAbWV0aG9kICRnZXRQb3B1bGF0ZWREb2NzXG4gKiBAaW5zdGFuY2VcbiAqL1xuXG5Eb2N1bWVudC5wcm90b3R5cGUuJGdldFBvcHVsYXRlZERvY3MgPSBmdW5jdGlvbiAkZ2V0UG9wdWxhdGVkRG9jcygpIHtcbiAgbGV0IGtleXMgPSBbXTtcbiAgaWYgKHRoaXMuJF9fLnBvcHVsYXRlZCAhPSBudWxsKSB7XG4gICAga2V5cyA9IGtleXMuY29uY2F0KE9iamVjdC5rZXlzKHRoaXMuJF9fLnBvcHVsYXRlZCkpO1xuICB9XG4gIGxldCByZXN1bHQgPSBbXTtcbiAgZm9yIChjb25zdCBrZXkgb2Yga2V5cykge1xuICAgIGNvbnN0IHZhbHVlID0gdGhpcy4kZ2V0KGtleSk7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICByZXN1bHQgPSByZXN1bHQuY29uY2F0KHZhbHVlKTtcbiAgICB9IGVsc2UgaWYgKHZhbHVlIGluc3RhbmNlb2YgRG9jdW1lbnQpIHtcbiAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKlxuICogR2V0cyBfaWQocykgdXNlZCBkdXJpbmcgcG9wdWxhdGlvbiBvZiB0aGUgZ2l2ZW4gYHBhdGhgLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgY29uc3QgZG9jID0gYXdhaXQgTW9kZWwuZmluZE9uZSgpLnBvcHVsYXRlKCdhdXRob3InKTtcbiAqXG4gKiAgICAgY29uc29sZS5sb2coZG9jLmF1dGhvci5uYW1lKTsgLy8gRHIuU2V1c3NcbiAqICAgICBjb25zb2xlLmxvZyhkb2MucG9wdWxhdGVkKCdhdXRob3InKSk7IC8vICc1MTQ0Y2Y4MDUwZjA3MWQ5NzljMTE4YTcnXG4gKlxuICogSWYgdGhlIHBhdGggd2FzIG5vdCBwb3B1bGF0ZWQsIHJldHVybnMgYHVuZGVmaW5lZGAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHBhdGhcbiAqIEBwYXJhbSB7QW55fSBbdmFsXVxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQHJldHVybiB7QXJyYXl8T2JqZWN0SWR8TnVtYmVyfEJ1ZmZlcnxTdHJpbmd8dW5kZWZpbmVkfVxuICogQG1lbWJlck9mIERvY3VtZW50XG4gKiBAaW5zdGFuY2VcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuRG9jdW1lbnQucHJvdG90eXBlLnBvcHVsYXRlZCA9IGZ1bmN0aW9uKHBhdGgsIHZhbCwgb3B0aW9ucykge1xuICAvLyB2YWwgYW5kIG9wdGlvbnMgYXJlIGludGVybmFsXG4gIGlmICh2YWwgPT0gbnVsbCB8fCB2YWwgPT09IHRydWUpIHtcbiAgICBpZiAoIXRoaXMuJF9fLnBvcHVsYXRlZCkge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBwYXRoICE9PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICAvLyBNYXAgcGF0aHMgY2FuIGJlIHBvcHVsYXRlZCB3aXRoIGVpdGhlciBgcGF0aC4kKmAgb3IganVzdCBgcGF0aGBcbiAgICBjb25zdCBfcGF0aCA9IHBhdGguZW5kc1dpdGgoJy4kKicpID8gcGF0aC5yZXBsYWNlKC9cXC5cXCRcXCokLywgJycpIDogcGF0aDtcblxuICAgIGNvbnN0IHYgPSB0aGlzLiRfXy5wb3B1bGF0ZWRbX3BhdGhdO1xuICAgIGlmICh2KSB7XG4gICAgICByZXR1cm4gdmFsID09PSB0cnVlID8gdiA6IHYudmFsdWU7XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cblxuICB0aGlzLiRfXy5wb3B1bGF0ZWQgfHwgKHRoaXMuJF9fLnBvcHVsYXRlZCA9IHt9KTtcbiAgdGhpcy4kX18ucG9wdWxhdGVkW3BhdGhdID0geyB2YWx1ZTogdmFsLCBvcHRpb25zOiBvcHRpb25zIH07XG5cbiAgLy8gSWYgdGhpcyB3YXMgYSBuZXN0ZWQgcG9wdWxhdGUsIG1ha2Ugc3VyZSBlYWNoIHBvcHVsYXRlZCBkb2Mga25vd3NcbiAgLy8gYWJvdXQgaXRzIHBvcHVsYXRlZCBjaGlsZHJlbiAoZ2gtNzY4NSlcbiAgY29uc3QgcGllY2VzID0gcGF0aC5zcGxpdCgnLicpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHBpZWNlcy5sZW5ndGggLSAxOyArK2kpIHtcbiAgICBjb25zdCBzdWJwYXRoID0gcGllY2VzLnNsaWNlKDAsIGkgKyAxKS5qb2luKCcuJyk7XG4gICAgY29uc3Qgc3ViZG9jID0gdGhpcy4kZ2V0KHN1YnBhdGgpO1xuICAgIGlmIChzdWJkb2MgIT0gbnVsbCAmJiBzdWJkb2MuJF9fICE9IG51bGwgJiYgdGhpcy4kcG9wdWxhdGVkKHN1YnBhdGgpKSB7XG4gICAgICBjb25zdCByZXN0ID0gcGllY2VzLnNsaWNlKGkgKyAxKS5qb2luKCcuJyk7XG4gICAgICBzdWJkb2MuJHBvcHVsYXRlZChyZXN0LCB2YWwsIG9wdGlvbnMpO1xuICAgICAgLy8gTm8gbmVlZCB0byBjb250aW51ZSBiZWNhdXNlIHRoZSBhYm92ZSByZWN1cnNpb24gc2hvdWxkIHRha2UgY2FyZSBvZlxuICAgICAgLy8gbWFya2luZyB0aGUgcmVzdCBvZiB0aGUgZG9jcyBhcyBwb3B1bGF0ZWRcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB2YWw7XG59O1xuXG4vKipcbiAqIEFsaWFzIG9mIFtgLnBvcHVsYXRlZGBdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvZG9jdW1lbnQuaHRtbCNEb2N1bWVudC5wcm90b3R5cGUucG9wdWxhdGVkKCkpLlxuICpcbiAqIEBtZXRob2QgJHBvcHVsYXRlZFxuICogQG1lbWJlck9mIERvY3VtZW50XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkRvY3VtZW50LnByb3RvdHlwZS4kcG9wdWxhdGVkID0gRG9jdW1lbnQucHJvdG90eXBlLnBvcHVsYXRlZDtcblxuLyoqXG4gKiBUaHJvd3MgYW4gZXJyb3IgaWYgYSBnaXZlbiBwYXRoIGlzIG5vdCBwb3B1bGF0ZWRcbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IGRvYyA9IGF3YWl0IE1vZGVsLmZpbmRPbmUoKS5wb3B1bGF0ZSgnYXV0aG9yJyk7XG4gKlxuICogICAgIGRvYy4kYXNzZXJ0UG9wdWxhdGVkKCdhdXRob3InKTsgLy8gZG9lcyBub3QgdGhyb3dcbiAqICAgICBkb2MuJGFzc2VydFBvcHVsYXRlZCgnb3RoZXIgcGF0aCcpOyAvLyB0aHJvd3MgYW4gZXJyb3JcbiAqXG4gKiAgICAgLy8gTWFudWFsbHkgcG9wdWxhdGUgYW5kIGFzc2VydCBpbiBvbmUgY2FsbC4gVGhlIGZvbGxvd2luZyBkb2VzXG4gKiAgICAgLy8gYGRvYy4kc2V0KHsgbGlrZXMgfSlgIGJlZm9yZSBhc3NlcnRpbmcuXG4gKiAgICAgZG9jLiRhc3NlcnRQb3B1bGF0ZWQoJ2xpa2VzJywgeyBsaWtlcyB9KTtcbiAqXG4gKlxuICogQHBhcmFtIHtTdHJpbmd8U3RyaW5nW119IHBhdGggcGF0aCBvciBhcnJheSBvZiBwYXRocyB0byBjaGVjay4gYCRhc3NlcnRQb3B1bGF0ZWRgIHRocm93cyBpZiBhbnkgb2YgdGhlIGdpdmVuIHBhdGhzIGlzIG5vdCBwb3B1bGF0ZWQuXG4gKiBAcGFyYW0ge09iamVjdH0gW3ZhbHVlc10gb3B0aW9uYWwgdmFsdWVzIHRvIGAkc2V0KClgLiBDb252ZW5pZW50IGlmIHlvdSB3YW50IHRvIG1hbnVhbGx5IHBvcHVsYXRlIGEgcGF0aCBhbmQgYXNzZXJ0IHRoYXQgdGhlIHBhdGggd2FzIHBvcHVsYXRlZCBpbiAxIGNhbGwuXG4gKiBAcmV0dXJuIHtEb2N1bWVudH0gdGhpc1xuICogQG1lbWJlck9mIERvY3VtZW50XG4gKiBAbWV0aG9kICRhc3NlcnRQb3B1bGF0ZWRcbiAqIEBpbnN0YW5jZVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Eb2N1bWVudC5wcm90b3R5cGUuJGFzc2VydFBvcHVsYXRlZCA9IGZ1bmN0aW9uICRhc3NlcnRQb3B1bGF0ZWQocGF0aCwgdmFsdWVzKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KHBhdGgpKSB7XG4gICAgcGF0aC5mb3JFYWNoKHAgPT4gdGhpcy4kYXNzZXJ0UG9wdWxhdGVkKHAsIHZhbHVlcykpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgdGhpcy4kc2V0KHZhbHVlcyk7XG4gIH1cblxuICBpZiAoIXRoaXMuJHBvcHVsYXRlZChwYXRoKSkge1xuICAgIHRocm93IG5ldyBNb25nb29zZUVycm9yKGBFeHBlY3RlZCBwYXRoIFwiJHtwYXRofVwiIHRvIGJlIHBvcHVsYXRlZGApO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFRha2VzIGEgcG9wdWxhdGVkIGZpZWxkIGFuZCByZXR1cm5zIGl0IHRvIGl0cyB1bnBvcHVsYXRlZCBzdGF0ZS5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIE1vZGVsLmZpbmRPbmUoKS5wb3B1bGF0ZSgnYXV0aG9yJykuZXhlYyhmdW5jdGlvbiAoZXJyLCBkb2MpIHtcbiAqICAgICAgIGNvbnNvbGUubG9nKGRvYy5hdXRob3IubmFtZSk7IC8vIERyLlNldXNzXG4gKiAgICAgICBjb25zb2xlLmxvZyhkb2MuZGVwb3B1bGF0ZSgnYXV0aG9yJykpO1xuICogICAgICAgY29uc29sZS5sb2coZG9jLmF1dGhvcik7IC8vICc1MTQ0Y2Y4MDUwZjA3MWQ5NzljMTE4YTcnXG4gKiAgICAgfSlcbiAqXG4gKiBJZiB0aGUgcGF0aCB3YXMgbm90IHByb3ZpZGVkLCB0aGVuIGFsbCBwb3B1bGF0ZWQgZmllbGRzIGFyZSByZXR1cm5lZCB0byB0aGVpciB1bnBvcHVsYXRlZCBzdGF0ZS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ3xTdHJpbmdbXX0gW3BhdGhdIFNwZWNpZmljIFBhdGggdG8gZGVwb3B1bGF0ZS4gSWYgdW5zZXQsIHdpbGwgZGVwb3B1bGF0ZSBhbGwgcGF0aHMgb24gdGhlIERvY3VtZW50LiBPciBtdWx0aXBsZSBzcGFjZS1kZWxpbWl0ZWQgcGF0aHMuXG4gKiBAcmV0dXJuIHtEb2N1bWVudH0gdGhpc1xuICogQHNlZSBEb2N1bWVudC5wb3B1bGF0ZSBodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvYXBpL2RvY3VtZW50Lmh0bWwjRG9jdW1lbnQucHJvdG90eXBlLnBvcHVsYXRlKClcbiAqIEBhcGkgcHVibGljXG4gKiBAbWVtYmVyT2YgRG9jdW1lbnRcbiAqIEBpbnN0YW5jZVxuICovXG5cbkRvY3VtZW50LnByb3RvdHlwZS5kZXBvcHVsYXRlID0gZnVuY3Rpb24ocGF0aCkge1xuICBpZiAodHlwZW9mIHBhdGggPT09ICdzdHJpbmcnKSB7XG4gICAgcGF0aCA9IHBhdGguaW5kZXhPZignICcpID09PSAtMSA/IFtwYXRoXSA6IHBhdGguc3BsaXQoJyAnKTtcbiAgfVxuXG4gIGxldCBwb3B1bGF0ZWRJZHM7XG4gIGNvbnN0IHZpcnR1YWxLZXlzID0gdGhpcy4kJHBvcHVsYXRlZFZpcnR1YWxzID8gT2JqZWN0LmtleXModGhpcy4kJHBvcHVsYXRlZFZpcnR1YWxzKSA6IFtdO1xuICBjb25zdCBwb3B1bGF0ZWQgPSB0aGlzLiRfXyAmJiB0aGlzLiRfXy5wb3B1bGF0ZWQgfHwge307XG5cbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAvLyBEZXBvcHVsYXRlIGFsbFxuICAgIGZvciAoY29uc3QgdmlydHVhbEtleSBvZiB2aXJ0dWFsS2V5cykge1xuICAgICAgZGVsZXRlIHRoaXMuJCRwb3B1bGF0ZWRWaXJ0dWFsc1t2aXJ0dWFsS2V5XTtcbiAgICAgIGRlbGV0ZSB0aGlzLl9kb2NbdmlydHVhbEtleV07XG4gICAgICBkZWxldGUgcG9wdWxhdGVkW3ZpcnR1YWxLZXldO1xuICAgIH1cblxuICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhwb3B1bGF0ZWQpO1xuXG4gICAgZm9yIChjb25zdCBrZXkgb2Yga2V5cykge1xuICAgICAgcG9wdWxhdGVkSWRzID0gdGhpcy4kcG9wdWxhdGVkKGtleSk7XG4gICAgICBpZiAoIXBvcHVsYXRlZElkcykge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGRlbGV0ZSBwb3B1bGF0ZWRba2V5XTtcbiAgICAgIHV0aWxzLnNldFZhbHVlKGtleSwgcG9wdWxhdGVkSWRzLCB0aGlzLl9kb2MpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGZvciAoY29uc3Qgc2luZ2xlUGF0aCBvZiBwYXRoKSB7XG4gICAgcG9wdWxhdGVkSWRzID0gdGhpcy4kcG9wdWxhdGVkKHNpbmdsZVBhdGgpO1xuICAgIGRlbGV0ZSBwb3B1bGF0ZWRbc2luZ2xlUGF0aF07XG5cbiAgICBpZiAodmlydHVhbEtleXMuaW5kZXhPZihzaW5nbGVQYXRoKSAhPT0gLTEpIHtcbiAgICAgIGRlbGV0ZSB0aGlzLiQkcG9wdWxhdGVkVmlydHVhbHNbc2luZ2xlUGF0aF07XG4gICAgICBkZWxldGUgdGhpcy5fZG9jW3NpbmdsZVBhdGhdO1xuICAgIH0gZWxzZSBpZiAocG9wdWxhdGVkSWRzKSB7XG4gICAgICB1dGlscy5zZXRWYWx1ZShzaW5nbGVQYXRoLCBwb3B1bGF0ZWRJZHMsIHRoaXMuX2RvYyk7XG4gICAgfVxuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuXG4vKipcbiAqIFJldHVybnMgdGhlIGZ1bGwgcGF0aCB0byB0aGlzIGRvY3VtZW50LlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBbcGF0aF1cbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHJpdmF0ZVxuICogQG1ldGhvZCAkX19mdWxsUGF0aFxuICogQG1lbWJlck9mIERvY3VtZW50XG4gKiBAaW5zdGFuY2VcbiAqL1xuXG5Eb2N1bWVudC5wcm90b3R5cGUuJF9fZnVsbFBhdGggPSBmdW5jdGlvbihwYXRoKSB7XG4gIC8vIG92ZXJyaWRkZW4gaW4gU3ViRG9jdW1lbnRzXG4gIHJldHVybiBwYXRoIHx8ICcnO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBjaGFuZ2VzIHRoYXQgaGFwcGVuZWQgdG8gdGhlIGRvY3VtZW50XG4gKiBpbiB0aGUgZm9ybWF0IHRoYXQgd2lsbCBiZSBzZW50IHRvIE1vbmdvREIuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBjb25zdCB1c2VyU2NoZW1hID0gbmV3IFNjaGVtYSh7XG4gKiAgICAgICBuYW1lOiBTdHJpbmcsXG4gKiAgICAgICBhZ2U6IE51bWJlcixcbiAqICAgICAgIGNvdW50cnk6IFN0cmluZ1xuICogICAgIH0pO1xuICogICAgIGNvbnN0IFVzZXIgPSBtb25nb29zZS5tb2RlbCgnVXNlcicsIHVzZXJTY2hlbWEpO1xuICogICAgIGNvbnN0IHVzZXIgPSBhd2FpdCBVc2VyLmNyZWF0ZSh7XG4gKiAgICAgICBuYW1lOiAnSGFmZXonLFxuICogICAgICAgYWdlOiAyNSxcbiAqICAgICAgIGNvdW50cnk6ICdFZ3lwdCdcbiAqICAgICB9KTtcbiAqXG4gKiAgICAgLy8gcmV0dXJucyBhbiBlbXB0eSBvYmplY3QsIG5vIGNoYW5nZXMgaGFwcGVuZWQgeWV0XG4gKiAgICAgdXNlci5nZXRDaGFuZ2VzKCk7IC8vIHsgfVxuICpcbiAqICAgICB1c2VyLmNvdW50cnkgPSB1bmRlZmluZWQ7XG4gKiAgICAgdXNlci5hZ2UgPSAyNjtcbiAqXG4gKiAgICAgdXNlci5nZXRDaGFuZ2VzKCk7IC8vIHsgJHNldDogeyBhZ2U6IDI2IH0sIHsgJHVuc2V0OiB7IGNvdW50cnk6IDEgfSB9IH1cbiAqXG4gKiAgICAgYXdhaXQgdXNlci5zYXZlKCk7XG4gKlxuICogICAgIHVzZXIuZ2V0Q2hhbmdlcygpOyAvLyB7IH1cbiAqXG4gKiBNb2RpZnlpbmcgdGhlIG9iamVjdCB0aGF0IGBnZXRDaGFuZ2VzKClgIHJldHVybnMgZG9lcyBub3QgYWZmZWN0IHRoZSBkb2N1bWVudCdzXG4gKiBjaGFuZ2UgdHJhY2tpbmcgc3RhdGUuIEV2ZW4gaWYgeW91IGBkZWxldGUgdXNlci5nZXRDaGFuZ2VzKCkuJHNldGAsIE1vbmdvb3NlXG4gKiB3aWxsIHN0aWxsIHNlbmQgYSBgJHNldGAgdG8gdGhlIHNlcnZlci5cbiAqXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKiBAYXBpIHB1YmxpY1xuICogQG1ldGhvZCBnZXRDaGFuZ2VzXG4gKiBAbWVtYmVyT2YgRG9jdW1lbnRcbiAqIEBpbnN0YW5jZVxuICovXG5cbkRvY3VtZW50LnByb3RvdHlwZS5nZXRDaGFuZ2VzID0gZnVuY3Rpb24oKSB7XG4gIGNvbnN0IGRlbHRhID0gdGhpcy4kX19kZWx0YSgpO1xuICBjb25zdCBjaGFuZ2VzID0gZGVsdGEgPyBkZWx0YVsxXSA6IHt9O1xuICByZXR1cm4gY2hhbmdlcztcbn07XG5cbi8qKlxuICogUmV0dXJucyBhIGNvcHkgb2YgdGhpcyBkb2N1bWVudCB3aXRoIGEgZGVlcCBjbG9uZSBvZiBgX2RvY2AgYW5kIGAkX19gLlxuICpcbiAqIEByZXR1cm4ge0RvY3VtZW50fSBhIGNvcHkgb2YgdGhpcyBkb2N1bWVudFxuICogQGFwaSBwdWJsaWNcbiAqIEBtZXRob2QgJGNsb25lXG4gKiBAbWVtYmVyT2YgRG9jdW1lbnRcbiAqIEBpbnN0YW5jZVxuICovXG5cbkRvY3VtZW50LnByb3RvdHlwZS4kY2xvbmUgPSBmdW5jdGlvbigpIHtcbiAgY29uc3QgTW9kZWwgPSB0aGlzLmNvbnN0cnVjdG9yO1xuICBjb25zdCBjbG9uZWREb2MgPSBuZXcgTW9kZWwoKTtcbiAgY2xvbmVkRG9jLiRpc05ldyA9IHRoaXMuJGlzTmV3O1xuICBpZiAodGhpcy5fZG9jKSB7XG4gICAgY2xvbmVkRG9jLl9kb2MgPSBjbG9uZSh0aGlzLl9kb2MpO1xuICB9XG4gIGlmICh0aGlzLiRfXykge1xuICAgIGNvbnN0IENhY2hlID0gdGhpcy4kX18uY29uc3RydWN0b3I7XG4gICAgY29uc3QgY2xvbmVkQ2FjaGUgPSBuZXcgQ2FjaGUoKTtcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0aGlzLiRfXykpIHtcbiAgICAgIGlmIChrZXkgPT09ICdhY3RpdmVQYXRocycpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjbG9uZWRDYWNoZVtrZXldID0gY2xvbmUodGhpcy4kX19ba2V5XSk7XG4gICAgfVxuICAgIE9iamVjdC5hc3NpZ24oY2xvbmVkQ2FjaGUuYWN0aXZlUGF0aHMsIGNsb25lKHsgLi4udGhpcy4kX18uYWN0aXZlUGF0aHMgfSkpO1xuICAgIGNsb25lZERvYy4kX18gPSBjbG9uZWRDYWNoZTtcbiAgfVxuICByZXR1cm4gY2xvbmVkRG9jO1xufTtcblxuLyohXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqL1xuXG5Eb2N1bWVudC5WYWxpZGF0aW9uRXJyb3IgPSBWYWxpZGF0aW9uRXJyb3I7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBEb2N1bWVudDtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../server/node_modules/mongoose/lib/document.js\n");

/***/ }),

/***/ "../server/node_modules/mongoose/lib/documentProvider.js":
/*!***************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/documentProvider.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\n/* eslint-env browser */\n\n/*!\n * Module dependencies.\n */\nconst Document = __webpack_require__(/*! ./document.js */ \"../server/node_modules/mongoose/lib/document.js\");\nconst BrowserDocument = __webpack_require__(/*! ./browserDocument.js */ \"../server/node_modules/mongoose/lib/browserDocument.js\");\n\nlet isBrowser = false;\n\n/**\n * Returns the Document constructor for the current context\n *\n * @api private\n */\nmodule.exports = function documentProvider() {\n  if (isBrowser) {\n    return BrowserDocument;\n  }\n  return Document;\n};\n\n/*!\n * ignore\n */\nmodule.exports.setBrowser = function(flag) {\n  isBrowser = flag;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvZG9jdW1lbnRQcm92aWRlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsbUJBQU8sQ0FBQyxzRUFBZTtBQUN4Qyx3QkFBd0IsbUJBQU8sQ0FBQyxvRkFBc0I7O0FBRXREOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbGllbnQvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvZG9jdW1lbnRQcm92aWRlci5qcz81NGQwIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuLyogZXNsaW50LWVudiBicm93c2VyICovXG5cbi8qIVxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuY29uc3QgRG9jdW1lbnQgPSByZXF1aXJlKCcuL2RvY3VtZW50LmpzJyk7XG5jb25zdCBCcm93c2VyRG9jdW1lbnQgPSByZXF1aXJlKCcuL2Jyb3dzZXJEb2N1bWVudC5qcycpO1xuXG5sZXQgaXNCcm93c2VyID0gZmFsc2U7XG5cbi8qKlxuICogUmV0dXJucyB0aGUgRG9jdW1lbnQgY29uc3RydWN0b3IgZm9yIHRoZSBjdXJyZW50IGNvbnRleHRcbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBkb2N1bWVudFByb3ZpZGVyKCkge1xuICBpZiAoaXNCcm93c2VyKSB7XG4gICAgcmV0dXJuIEJyb3dzZXJEb2N1bWVudDtcbiAgfVxuICByZXR1cm4gRG9jdW1lbnQ7XG59O1xuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5tb2R1bGUuZXhwb3J0cy5zZXRCcm93c2VyID0gZnVuY3Rpb24oZmxhZykge1xuICBpc0Jyb3dzZXIgPSBmbGFnO1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../server/node_modules/mongoose/lib/documentProvider.js\n");

/***/ }),

/***/ "../server/node_modules/mongoose/lib/driver.js":
/*!*****************************************************!*\
  !*** ../server/node_modules/mongoose/lib/driver.js ***!
  \*****************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/*!\n * ignore\n */\n\nlet driver = null;\n\nmodule.exports.get = function() {\n  return driver;\n};\n\nmodule.exports.set = function(v) {\n  driver = v;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvZHJpdmVyLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxrQkFBa0I7QUFDbEI7QUFDQTs7QUFFQSxrQkFBa0I7QUFDbEI7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2NsaWVudC8uLi9zZXJ2ZXIvbm9kZV9tb2R1bGVzL21vbmdvb3NlL2xpYi9kcml2ZXIuanM/ODc4YiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxubGV0IGRyaXZlciA9IG51bGw7XG5cbm1vZHVsZS5leHBvcnRzLmdldCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gZHJpdmVyO1xufTtcblxubW9kdWxlLmV4cG9ydHMuc2V0ID0gZnVuY3Rpb24odikge1xuICBkcml2ZXIgPSB2O1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../server/node_modules/mongoose/lib/driver.js\n");

/***/ }),

/***/ "../server/node_modules/mongoose/lib/drivers/node-mongodb-native/collection.js":
/*!*************************************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/drivers/node-mongodb-native/collection.js ***!
  \*************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\n/*!\n * Module dependencies.\n */\n\nconst MongooseCollection = __webpack_require__(/*! ../../collection */ \"../server/node_modules/mongoose/lib/collection.js\");\nconst MongooseError = __webpack_require__(/*! ../../error/mongooseError */ \"../server/node_modules/mongoose/lib/error/mongooseError.js\");\nconst Collection = (__webpack_require__(/*! mongodb */ \"../server/node_modules/mongodb/lib/index.js\").Collection);\nconst ObjectId = __webpack_require__(/*! ../../types/objectid */ \"../server/node_modules/mongoose/lib/types/objectid.js\");\nconst getConstructorName = __webpack_require__(/*! ../../helpers/getConstructorName */ \"../server/node_modules/mongoose/lib/helpers/getConstructorName.js\");\nconst internalToObjectOptions = (__webpack_require__(/*! ../../options */ \"../server/node_modules/mongoose/lib/options.js\").internalToObjectOptions);\nconst stream = __webpack_require__(/*! stream */ \"stream\");\nconst util = __webpack_require__(/*! util */ \"util\");\n\n/**\n * A [node-mongodb-native](https://github.com/mongodb/node-mongodb-native) collection implementation.\n *\n * All methods methods from the [node-mongodb-native](https://github.com/mongodb/node-mongodb-native) driver are copied and wrapped in queue management.\n *\n * @inherits Collection https://mongodb.github.io/node-mongodb-native/4.9/classes/Collection.html\n * @api private\n */\n\nfunction NativeCollection(name, conn, options) {\n  this.collection = null;\n  this.Promise = options.Promise || Promise;\n  this.modelName = options.modelName;\n  delete options.modelName;\n  this._closed = false;\n  MongooseCollection.apply(this, arguments);\n}\n\n/*!\n * Inherit from abstract Collection.\n */\n\nObject.setPrototypeOf(NativeCollection.prototype, MongooseCollection.prototype);\n\n/**\n * Called when the connection opens.\n *\n * @api private\n */\n\nNativeCollection.prototype.onOpen = function() {\n  this.collection = this.conn.db.collection(this.name);\n  MongooseCollection.prototype.onOpen.call(this);\n  return this.collection;\n};\n\n/**\n * Called when the connection closes\n *\n * @api private\n */\n\nNativeCollection.prototype.onClose = function(force) {\n  MongooseCollection.prototype.onClose.call(this, force);\n};\n\n/**\n * Helper to get the collection, in case `this.collection` isn't set yet.\n * May happen if `bufferCommands` is false and created the model when\n * Mongoose was disconnected.\n *\n * @api private\n */\n\nNativeCollection.prototype._getCollection = function _getCollection() {\n  if (this.collection) {\n    return this.collection;\n  }\n  if (this.conn.db != null) {\n    this.collection = this.conn.db.collection(this.name);\n    return this.collection;\n  }\n  return null;\n};\n\n/*!\n * ignore\n */\n\nconst syncCollectionMethods = { watch: true, find: true, aggregate: true };\n\n/**\n * Copy the collection methods and make them subject to queues\n * @param {Number|String} I\n * @api private\n */\n\nfunction iter(i) {\n  NativeCollection.prototype[i] = function() {\n    const collection = this._getCollection();\n    const args = Array.from(arguments);\n    const _this = this;\n    const globalDebug = _this &&\n      _this.conn &&\n      _this.conn.base &&\n      _this.conn.base.options &&\n      _this.conn.base.options.debug;\n    const connectionDebug = _this &&\n      _this.conn &&\n      _this.conn.options &&\n      _this.conn.options.debug;\n    const debug = connectionDebug == null ? globalDebug : connectionDebug;\n    const lastArg = arguments[arguments.length - 1];\n    const opId = new ObjectId();\n\n    // If user force closed, queueing will hang forever. See #5664\n    if (this.conn.$wasForceClosed) {\n      const error = new MongooseError('Connection was force closed');\n      if (args.length > 0 &&\n        typeof args[args.length - 1] === 'function') {\n        args[args.length - 1](error);\n        return;\n      } else {\n        throw error;\n      }\n    }\n\n    let _args = args;\n    let callback = null;\n    if (this._shouldBufferCommands() && this.buffer) {\n      this.conn.emit('buffer', {\n        _id: opId,\n        modelName: _this.modelName,\n        collectionName: _this.name,\n        method: i,\n        args: args\n      });\n\n      let callback;\n      let _args = args;\n      let promise = null;\n      let timeout = null;\n      if (syncCollectionMethods[i] && typeof lastArg === 'function') {\n        this.addQueue(() => {\n          lastArg.call(this, null, this[i].apply(this, _args.slice(0, _args.length - 1)));\n        }, []);\n      } else if (syncCollectionMethods[i]) {\n        promise = new Promise((resolve, reject) => {\n          callback = function collectionOperationCallback(err, res) {\n            if (timeout != null) {\n              clearTimeout(timeout);\n            }\n            if (err != null) {\n              return reject(err);\n            }\n            resolve(res);\n          };\n          _args = args.concat([callback]);\n          this.addQueue(i, _args);\n        });\n      } else if (typeof lastArg === 'function') {\n        callback = function collectionOperationCallback() {\n          if (timeout != null) {\n            clearTimeout(timeout);\n          }\n          return lastArg.apply(this, arguments);\n        };\n        _args = args.slice(0, args.length - 1).concat([callback]);\n      } else {\n        promise = new Promise((resolve, reject) => {\n          callback = function collectionOperationCallback(err, res) {\n            if (timeout != null) {\n              clearTimeout(timeout);\n            }\n            if (err != null) {\n              return reject(err);\n            }\n            resolve(res);\n          };\n          _args = args.concat([callback]);\n          this.addQueue(i, _args);\n        });\n      }\n\n      const bufferTimeoutMS = this._getBufferTimeoutMS();\n      timeout = setTimeout(() => {\n        const removed = this.removeQueue(i, _args);\n        if (removed) {\n          const message = 'Operation `' + this.name + '.' + i + '()` buffering timed out after ' +\n            bufferTimeoutMS + 'ms';\n          const err = new MongooseError(message);\n          this.conn.emit('buffer-end', { _id: opId, modelName: _this.modelName, collectionName: _this.name, method: i, error: err });\n          callback(err);\n        }\n      }, bufferTimeoutMS);\n\n      if (!syncCollectionMethods[i] && typeof lastArg === 'function') {\n        this.addQueue(i, _args);\n        return;\n      }\n\n      return promise;\n    } else if (!syncCollectionMethods[i] && typeof lastArg === 'function') {\n      callback = function collectionOperationCallback(err, res) {\n        if (err != null) {\n          _this.conn.emit('operation-end', { _id: opId, modelName: _this.modelName, collectionName: _this.name, method: i, error: err });\n        } else {\n          _this.conn.emit('operation-end', { _id: opId, modelName: _this.modelName, collectionName: _this.name, method: i, result: res });\n        }\n        return lastArg.apply(this, arguments);\n      };\n      _args = args.slice(0, args.length - 1).concat([callback]);\n    }\n\n    if (debug) {\n      if (typeof debug === 'function') {\n        let argsToAdd = null;\n        if (typeof args[args.length - 1] == 'function') {\n          argsToAdd = args.slice(0, args.length - 1);\n        } else {\n          argsToAdd = args;\n        }\n        debug.apply(_this,\n          [_this.name, i].concat(argsToAdd));\n      } else if (debug instanceof stream.Writable) {\n        this.$printToStream(_this.name, i, args, debug);\n      } else {\n        const color = debug.color == null ? true : debug.color;\n        const shell = debug.shell == null ? false : debug.shell;\n        this.$print(_this.name, i, args, color, shell);\n      }\n    }\n\n    this.conn.emit('operation-start', { _id: opId, modelName: _this.modelName, collectionName: this.name, method: i, params: _args });\n\n    try {\n      if (collection == null) {\n        const message = 'Cannot call `' + this.name + '.' + i + '()` before initial connection ' +\n          'is complete if `bufferCommands = false`. Make sure you `await mongoose.connect()` if ' +\n          'you have `bufferCommands = false`.';\n        throw new MongooseError(message);\n      }\n\n      if (syncCollectionMethods[i] && typeof lastArg === 'function') {\n        const ret = collection[i].apply(collection, _args.slice(0, _args.length - 1));\n        return lastArg.call(this, null, ret);\n      }\n\n      const ret = collection[i].apply(collection, _args);\n      if (ret != null && typeof ret.then === 'function') {\n        return ret.then(\n          res => {\n            typeof lastArg === 'function' && lastArg(null, res);\n            return res;\n          },\n          err => {\n            if (typeof lastArg === 'function') {\n              lastArg(err);\n              return;\n            }\n            throw err;\n          }\n        );\n      }\n      return ret;\n    } catch (error) {\n      // Collection operation may throw because of max bson size, catch it here\n      // See gh-3906\n      if (typeof lastArg === 'function') {\n        return lastArg(error);\n      } else {\n        this.conn.emit('operation-end', { _id: opId, modelName: _this.modelName, collectionName: this.name, method: i, error: error });\n\n        throw error;\n      }\n    }\n  };\n}\n\nfor (const key of Object.getOwnPropertyNames(Collection.prototype)) {\n  // Janky hack to work around gh-3005 until we can get rid of the mongoose\n  // collection abstraction\n  const descriptor = Object.getOwnPropertyDescriptor(Collection.prototype, key);\n  // Skip properties with getters because they may throw errors (gh-8528)\n  if (descriptor.get !== undefined) {\n    continue;\n  }\n  if (typeof Collection.prototype[key] !== 'function') {\n    continue;\n  }\n\n  iter(key);\n}\n\n/**\n * Debug print helper\n *\n * @api public\n * @method $print\n */\n\nNativeCollection.prototype.$print = function(name, i, args, color, shell) {\n  const moduleName = color ? '\\x1B[0;36mMongoose:\\x1B[0m ' : 'Mongoose: ';\n  const functionCall = [name, i].join('.');\n  const _args = [];\n  for (let j = args.length - 1; j >= 0; --j) {\n    if (this.$format(args[j]) || _args.length) {\n      _args.unshift(this.$format(args[j], color, shell));\n    }\n  }\n  const params = '(' + _args.join(', ') + ')';\n\n  console.info(moduleName + functionCall + params);\n};\n\n/**\n * Debug print helper\n *\n * @api public\n * @method $print\n */\n\nNativeCollection.prototype.$printToStream = function(name, i, args, stream) {\n  const functionCall = [name, i].join('.');\n  const _args = [];\n  for (let j = args.length - 1; j >= 0; --j) {\n    if (this.$format(args[j]) || _args.length) {\n      _args.unshift(this.$format(args[j]));\n    }\n  }\n  const params = '(' + _args.join(', ') + ')';\n\n  stream.write(functionCall + params, 'utf8');\n};\n\n/**\n * Formatter for debug print args\n *\n * @api public\n * @method $format\n */\n\nNativeCollection.prototype.$format = function(arg, color, shell) {\n  const type = typeof arg;\n  if (type === 'function' || type === 'undefined') return '';\n  return format(arg, false, color, shell);\n};\n\n/**\n * Debug print helper\n * @param {Any} representation\n * @api private\n */\n\nfunction inspectable(representation) {\n  const ret = {\n    inspect: function() { return representation; }\n  };\n  if (util.inspect.custom) {\n    ret[util.inspect.custom] = ret.inspect;\n  }\n  return ret;\n}\nfunction map(o) {\n  return format(o, true);\n}\nfunction formatObjectId(x, key) {\n  x[key] = inspectable('ObjectId(\"' + x[key].toHexString() + '\")');\n}\nfunction formatDate(x, key, shell) {\n  if (shell) {\n    x[key] = inspectable('ISODate(\"' + x[key].toUTCString() + '\")');\n  } else {\n    x[key] = inspectable('new Date(\"' + x[key].toUTCString() + '\")');\n  }\n}\nfunction format(obj, sub, color, shell) {\n  if (obj && typeof obj.toBSON === 'function') {\n    obj = obj.toBSON();\n  }\n  if (obj == null) {\n    return obj;\n  }\n\n  const clone = __webpack_require__(/*! ../../helpers/clone */ \"../server/node_modules/mongoose/lib/helpers/clone.js\");\n  let x = clone(obj, internalToObjectOptions);\n  const constructorName = getConstructorName(x);\n\n  if (constructorName === 'Binary') {\n    x = 'BinData(' + x.sub_type + ', \"' + x.toString('base64') + '\")';\n  } else if (constructorName === 'ObjectId') {\n    x = inspectable('ObjectId(\"' + x.toHexString() + '\")');\n  } else if (constructorName === 'Date') {\n    x = inspectable('new Date(\"' + x.toUTCString() + '\")');\n  } else if (constructorName === 'Object') {\n    const keys = Object.keys(x);\n    const numKeys = keys.length;\n    let key;\n    for (let i = 0; i < numKeys; ++i) {\n      key = keys[i];\n      if (x[key]) {\n        let error;\n        if (typeof x[key].toBSON === 'function') {\n          try {\n            // `session.toBSON()` throws an error. This means we throw errors\n            // in debug mode when using transactions, see gh-6712. As a\n            // workaround, catch `toBSON()` errors, try to serialize without\n            // `toBSON()`, and rethrow if serialization still fails.\n            x[key] = x[key].toBSON();\n          } catch (_error) {\n            error = _error;\n          }\n        }\n        const _constructorName = getConstructorName(x[key]);\n        if (_constructorName === 'Binary') {\n          x[key] = 'BinData(' + x[key].sub_type + ', \"' +\n            x[key].buffer.toString('base64') + '\")';\n        } else if (_constructorName === 'Object') {\n          x[key] = format(x[key], true);\n        } else if (_constructorName === 'ObjectId') {\n          formatObjectId(x, key);\n        } else if (_constructorName === 'Date') {\n          formatDate(x, key, shell);\n        } else if (_constructorName === 'ClientSession') {\n          x[key] = inspectable('ClientSession(\"' +\n            (\n              x[key] &&\n              x[key].id &&\n              x[key].id.id &&\n              x[key].id.id.buffer || ''\n            ).toString('hex') + '\")');\n        } else if (Array.isArray(x[key])) {\n          x[key] = x[key].map(map);\n        } else if (error != null) {\n          // If there was an error with `toBSON()` and the object wasn't\n          // already converted to a string representation, rethrow it.\n          // Open to better ideas on how to handle this.\n          throw error;\n        }\n      }\n    }\n  }\n  if (sub) {\n    return x;\n  }\n\n  return util.\n    inspect(x, false, 10, color).\n    replace(/\\n/g, '').\n    replace(/\\s{2,}/g, ' ');\n}\n\n/**\n * Retrieves information about this collections indexes.\n *\n * @param {Function} callback\n * @method getIndexes\n * @api public\n */\n\nNativeCollection.prototype.getIndexes = NativeCollection.prototype.indexInformation;\n\n/*!\n * Module exports.\n */\n\nmodule.exports = NativeCollection;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvZHJpdmVycy9ub2RlLW1vbmdvZGItbmF0aXZlL2NvbGxlY3Rpb24uanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7QUFDQTtBQUNBOztBQUVBLDJCQUEyQixtQkFBTyxDQUFDLDJFQUFrQjtBQUNyRCxzQkFBc0IsbUJBQU8sQ0FBQyw2RkFBMkI7QUFDekQsbUJBQW1CLDhGQUE2QjtBQUNoRCxpQkFBaUIsbUJBQU8sQ0FBQyxtRkFBc0I7QUFDL0MsMkJBQTJCLG1CQUFPLENBQUMsMkdBQWtDO0FBQ3JFLGdDQUFnQyxvSEFBZ0Q7QUFDaEYsZUFBZSxtQkFBTyxDQUFDLHNCQUFRO0FBQy9CLGFBQWEsbUJBQU8sQ0FBQyxrQkFBTTs7QUFFM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGdDQUFnQzs7QUFFaEM7QUFDQTtBQUNBLFdBQVcsZUFBZTtBQUMxQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUFDQTtBQUNBLFdBQVcsVUFBVTtBQUNyQjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2xpZW50Ly4uL3NlcnZlci9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2RyaXZlcnMvbm9kZS1tb25nb2RiLW5hdGl2ZS9jb2xsZWN0aW9uLmpzPzJmOGYiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG4vKiFcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxuY29uc3QgTW9uZ29vc2VDb2xsZWN0aW9uID0gcmVxdWlyZSgnLi4vLi4vY29sbGVjdGlvbicpO1xuY29uc3QgTW9uZ29vc2VFcnJvciA9IHJlcXVpcmUoJy4uLy4uL2Vycm9yL21vbmdvb3NlRXJyb3InKTtcbmNvbnN0IENvbGxlY3Rpb24gPSByZXF1aXJlKCdtb25nb2RiJykuQ29sbGVjdGlvbjtcbmNvbnN0IE9iamVjdElkID0gcmVxdWlyZSgnLi4vLi4vdHlwZXMvb2JqZWN0aWQnKTtcbmNvbnN0IGdldENvbnN0cnVjdG9yTmFtZSA9IHJlcXVpcmUoJy4uLy4uL2hlbHBlcnMvZ2V0Q29uc3RydWN0b3JOYW1lJyk7XG5jb25zdCBpbnRlcm5hbFRvT2JqZWN0T3B0aW9ucyA9IHJlcXVpcmUoJy4uLy4uL29wdGlvbnMnKS5pbnRlcm5hbFRvT2JqZWN0T3B0aW9ucztcbmNvbnN0IHN0cmVhbSA9IHJlcXVpcmUoJ3N0cmVhbScpO1xuY29uc3QgdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcblxuLyoqXG4gKiBBIFtub2RlLW1vbmdvZGItbmF0aXZlXShodHRwczovL2dpdGh1Yi5jb20vbW9uZ29kYi9ub2RlLW1vbmdvZGItbmF0aXZlKSBjb2xsZWN0aW9uIGltcGxlbWVudGF0aW9uLlxuICpcbiAqIEFsbCBtZXRob2RzIG1ldGhvZHMgZnJvbSB0aGUgW25vZGUtbW9uZ29kYi1uYXRpdmVdKGh0dHBzOi8vZ2l0aHViLmNvbS9tb25nb2RiL25vZGUtbW9uZ29kYi1uYXRpdmUpIGRyaXZlciBhcmUgY29waWVkIGFuZCB3cmFwcGVkIGluIHF1ZXVlIG1hbmFnZW1lbnQuXG4gKlxuICogQGluaGVyaXRzIENvbGxlY3Rpb24gaHR0cHM6Ly9tb25nb2RiLmdpdGh1Yi5pby9ub2RlLW1vbmdvZGItbmF0aXZlLzQuOS9jbGFzc2VzL0NvbGxlY3Rpb24uaHRtbFxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gTmF0aXZlQ29sbGVjdGlvbihuYW1lLCBjb25uLCBvcHRpb25zKSB7XG4gIHRoaXMuY29sbGVjdGlvbiA9IG51bGw7XG4gIHRoaXMuUHJvbWlzZSA9IG9wdGlvbnMuUHJvbWlzZSB8fCBQcm9taXNlO1xuICB0aGlzLm1vZGVsTmFtZSA9IG9wdGlvbnMubW9kZWxOYW1lO1xuICBkZWxldGUgb3B0aW9ucy5tb2RlbE5hbWU7XG4gIHRoaXMuX2Nsb3NlZCA9IGZhbHNlO1xuICBNb25nb29zZUNvbGxlY3Rpb24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuLyohXG4gKiBJbmhlcml0IGZyb20gYWJzdHJhY3QgQ29sbGVjdGlvbi5cbiAqL1xuXG5PYmplY3Quc2V0UHJvdG90eXBlT2YoTmF0aXZlQ29sbGVjdGlvbi5wcm90b3R5cGUsIE1vbmdvb3NlQ29sbGVjdGlvbi5wcm90b3R5cGUpO1xuXG4vKipcbiAqIENhbGxlZCB3aGVuIHRoZSBjb25uZWN0aW9uIG9wZW5zLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbk5hdGl2ZUNvbGxlY3Rpb24ucHJvdG90eXBlLm9uT3BlbiA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLmNvbGxlY3Rpb24gPSB0aGlzLmNvbm4uZGIuY29sbGVjdGlvbih0aGlzLm5hbWUpO1xuICBNb25nb29zZUNvbGxlY3Rpb24ucHJvdG90eXBlLm9uT3Blbi5jYWxsKHRoaXMpO1xuICByZXR1cm4gdGhpcy5jb2xsZWN0aW9uO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgd2hlbiB0aGUgY29ubmVjdGlvbiBjbG9zZXNcbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5OYXRpdmVDb2xsZWN0aW9uLnByb3RvdHlwZS5vbkNsb3NlID0gZnVuY3Rpb24oZm9yY2UpIHtcbiAgTW9uZ29vc2VDb2xsZWN0aW9uLnByb3RvdHlwZS5vbkNsb3NlLmNhbGwodGhpcywgZm9yY2UpO1xufTtcblxuLyoqXG4gKiBIZWxwZXIgdG8gZ2V0IHRoZSBjb2xsZWN0aW9uLCBpbiBjYXNlIGB0aGlzLmNvbGxlY3Rpb25gIGlzbid0IHNldCB5ZXQuXG4gKiBNYXkgaGFwcGVuIGlmIGBidWZmZXJDb21tYW5kc2AgaXMgZmFsc2UgYW5kIGNyZWF0ZWQgdGhlIG1vZGVsIHdoZW5cbiAqIE1vbmdvb3NlIHdhcyBkaXNjb25uZWN0ZWQuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuTmF0aXZlQ29sbGVjdGlvbi5wcm90b3R5cGUuX2dldENvbGxlY3Rpb24gPSBmdW5jdGlvbiBfZ2V0Q29sbGVjdGlvbigpIHtcbiAgaWYgKHRoaXMuY29sbGVjdGlvbikge1xuICAgIHJldHVybiB0aGlzLmNvbGxlY3Rpb247XG4gIH1cbiAgaWYgKHRoaXMuY29ubi5kYiAhPSBudWxsKSB7XG4gICAgdGhpcy5jb2xsZWN0aW9uID0gdGhpcy5jb25uLmRiLmNvbGxlY3Rpb24odGhpcy5uYW1lKTtcbiAgICByZXR1cm4gdGhpcy5jb2xsZWN0aW9uO1xuICB9XG4gIHJldHVybiBudWxsO1xufTtcblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5jb25zdCBzeW5jQ29sbGVjdGlvbk1ldGhvZHMgPSB7IHdhdGNoOiB0cnVlLCBmaW5kOiB0cnVlLCBhZ2dyZWdhdGU6IHRydWUgfTtcblxuLyoqXG4gKiBDb3B5IHRoZSBjb2xsZWN0aW9uIG1ldGhvZHMgYW5kIG1ha2UgdGhlbSBzdWJqZWN0IHRvIHF1ZXVlc1xuICogQHBhcmFtIHtOdW1iZXJ8U3RyaW5nfSBJXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBpdGVyKGkpIHtcbiAgTmF0aXZlQ29sbGVjdGlvbi5wcm90b3R5cGVbaV0gPSBmdW5jdGlvbigpIHtcbiAgICBjb25zdCBjb2xsZWN0aW9uID0gdGhpcy5fZ2V0Q29sbGVjdGlvbigpO1xuICAgIGNvbnN0IGFyZ3MgPSBBcnJheS5mcm9tKGFyZ3VtZW50cyk7XG4gICAgY29uc3QgX3RoaXMgPSB0aGlzO1xuICAgIGNvbnN0IGdsb2JhbERlYnVnID0gX3RoaXMgJiZcbiAgICAgIF90aGlzLmNvbm4gJiZcbiAgICAgIF90aGlzLmNvbm4uYmFzZSAmJlxuICAgICAgX3RoaXMuY29ubi5iYXNlLm9wdGlvbnMgJiZcbiAgICAgIF90aGlzLmNvbm4uYmFzZS5vcHRpb25zLmRlYnVnO1xuICAgIGNvbnN0IGNvbm5lY3Rpb25EZWJ1ZyA9IF90aGlzICYmXG4gICAgICBfdGhpcy5jb25uICYmXG4gICAgICBfdGhpcy5jb25uLm9wdGlvbnMgJiZcbiAgICAgIF90aGlzLmNvbm4ub3B0aW9ucy5kZWJ1ZztcbiAgICBjb25zdCBkZWJ1ZyA9IGNvbm5lY3Rpb25EZWJ1ZyA9PSBudWxsID8gZ2xvYmFsRGVidWcgOiBjb25uZWN0aW9uRGVidWc7XG4gICAgY29uc3QgbGFzdEFyZyA9IGFyZ3VtZW50c1thcmd1bWVudHMubGVuZ3RoIC0gMV07XG4gICAgY29uc3Qgb3BJZCA9IG5ldyBPYmplY3RJZCgpO1xuXG4gICAgLy8gSWYgdXNlciBmb3JjZSBjbG9zZWQsIHF1ZXVlaW5nIHdpbGwgaGFuZyBmb3JldmVyLiBTZWUgIzU2NjRcbiAgICBpZiAodGhpcy5jb25uLiR3YXNGb3JjZUNsb3NlZCkge1xuICAgICAgY29uc3QgZXJyb3IgPSBuZXcgTW9uZ29vc2VFcnJvcignQ29ubmVjdGlvbiB3YXMgZm9yY2UgY2xvc2VkJyk7XG4gICAgICBpZiAoYXJncy5sZW5ndGggPiAwICYmXG4gICAgICAgIHR5cGVvZiBhcmdzW2FyZ3MubGVuZ3RoIC0gMV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgYXJnc1thcmdzLmxlbmd0aCAtIDFdKGVycm9yKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICB9XG4gICAgfVxuXG4gICAgbGV0IF9hcmdzID0gYXJncztcbiAgICBsZXQgY2FsbGJhY2sgPSBudWxsO1xuICAgIGlmICh0aGlzLl9zaG91bGRCdWZmZXJDb21tYW5kcygpICYmIHRoaXMuYnVmZmVyKSB7XG4gICAgICB0aGlzLmNvbm4uZW1pdCgnYnVmZmVyJywge1xuICAgICAgICBfaWQ6IG9wSWQsXG4gICAgICAgIG1vZGVsTmFtZTogX3RoaXMubW9kZWxOYW1lLFxuICAgICAgICBjb2xsZWN0aW9uTmFtZTogX3RoaXMubmFtZSxcbiAgICAgICAgbWV0aG9kOiBpLFxuICAgICAgICBhcmdzOiBhcmdzXG4gICAgICB9KTtcblxuICAgICAgbGV0IGNhbGxiYWNrO1xuICAgICAgbGV0IF9hcmdzID0gYXJncztcbiAgICAgIGxldCBwcm9taXNlID0gbnVsbDtcbiAgICAgIGxldCB0aW1lb3V0ID0gbnVsbDtcbiAgICAgIGlmIChzeW5jQ29sbGVjdGlvbk1ldGhvZHNbaV0gJiYgdHlwZW9mIGxhc3RBcmcgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhpcy5hZGRRdWV1ZSgoKSA9PiB7XG4gICAgICAgICAgbGFzdEFyZy5jYWxsKHRoaXMsIG51bGwsIHRoaXNbaV0uYXBwbHkodGhpcywgX2FyZ3Muc2xpY2UoMCwgX2FyZ3MubGVuZ3RoIC0gMSkpKTtcbiAgICAgICAgfSwgW10pO1xuICAgICAgfSBlbHNlIGlmIChzeW5jQ29sbGVjdGlvbk1ldGhvZHNbaV0pIHtcbiAgICAgICAgcHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICBjYWxsYmFjayA9IGZ1bmN0aW9uIGNvbGxlY3Rpb25PcGVyYXRpb25DYWxsYmFjayhlcnIsIHJlcykge1xuICAgICAgICAgICAgaWYgKHRpbWVvdXQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZXJyICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdChlcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzb2x2ZShyZXMpO1xuICAgICAgICAgIH07XG4gICAgICAgICAgX2FyZ3MgPSBhcmdzLmNvbmNhdChbY2FsbGJhY2tdKTtcbiAgICAgICAgICB0aGlzLmFkZFF1ZXVlKGksIF9hcmdzKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBsYXN0QXJnID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGNhbGxiYWNrID0gZnVuY3Rpb24gY29sbGVjdGlvbk9wZXJhdGlvbkNhbGxiYWNrKCkge1xuICAgICAgICAgIGlmICh0aW1lb3V0ICE9IG51bGwpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGxhc3RBcmcuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfTtcbiAgICAgICAgX2FyZ3MgPSBhcmdzLnNsaWNlKDAsIGFyZ3MubGVuZ3RoIC0gMSkuY29uY2F0KFtjYWxsYmFja10pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICBjYWxsYmFjayA9IGZ1bmN0aW9uIGNvbGxlY3Rpb25PcGVyYXRpb25DYWxsYmFjayhlcnIsIHJlcykge1xuICAgICAgICAgICAgaWYgKHRpbWVvdXQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZXJyICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdChlcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzb2x2ZShyZXMpO1xuICAgICAgICAgIH07XG4gICAgICAgICAgX2FyZ3MgPSBhcmdzLmNvbmNhdChbY2FsbGJhY2tdKTtcbiAgICAgICAgICB0aGlzLmFkZFF1ZXVlKGksIF9hcmdzKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGJ1ZmZlclRpbWVvdXRNUyA9IHRoaXMuX2dldEJ1ZmZlclRpbWVvdXRNUygpO1xuICAgICAgdGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBjb25zdCByZW1vdmVkID0gdGhpcy5yZW1vdmVRdWV1ZShpLCBfYXJncyk7XG4gICAgICAgIGlmIChyZW1vdmVkKSB7XG4gICAgICAgICAgY29uc3QgbWVzc2FnZSA9ICdPcGVyYXRpb24gYCcgKyB0aGlzLm5hbWUgKyAnLicgKyBpICsgJygpYCBidWZmZXJpbmcgdGltZWQgb3V0IGFmdGVyICcgK1xuICAgICAgICAgICAgYnVmZmVyVGltZW91dE1TICsgJ21zJztcbiAgICAgICAgICBjb25zdCBlcnIgPSBuZXcgTW9uZ29vc2VFcnJvcihtZXNzYWdlKTtcbiAgICAgICAgICB0aGlzLmNvbm4uZW1pdCgnYnVmZmVyLWVuZCcsIHsgX2lkOiBvcElkLCBtb2RlbE5hbWU6IF90aGlzLm1vZGVsTmFtZSwgY29sbGVjdGlvbk5hbWU6IF90aGlzLm5hbWUsIG1ldGhvZDogaSwgZXJyb3I6IGVyciB9KTtcbiAgICAgICAgICBjYWxsYmFjayhlcnIpO1xuICAgICAgICB9XG4gICAgICB9LCBidWZmZXJUaW1lb3V0TVMpO1xuXG4gICAgICBpZiAoIXN5bmNDb2xsZWN0aW9uTWV0aG9kc1tpXSAmJiB0eXBlb2YgbGFzdEFyZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aGlzLmFkZFF1ZXVlKGksIF9hcmdzKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICB9IGVsc2UgaWYgKCFzeW5jQ29sbGVjdGlvbk1ldGhvZHNbaV0gJiYgdHlwZW9mIGxhc3RBcmcgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNhbGxiYWNrID0gZnVuY3Rpb24gY29sbGVjdGlvbk9wZXJhdGlvbkNhbGxiYWNrKGVyciwgcmVzKSB7XG4gICAgICAgIGlmIChlcnIgIT0gbnVsbCkge1xuICAgICAgICAgIF90aGlzLmNvbm4uZW1pdCgnb3BlcmF0aW9uLWVuZCcsIHsgX2lkOiBvcElkLCBtb2RlbE5hbWU6IF90aGlzLm1vZGVsTmFtZSwgY29sbGVjdGlvbk5hbWU6IF90aGlzLm5hbWUsIG1ldGhvZDogaSwgZXJyb3I6IGVyciB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBfdGhpcy5jb25uLmVtaXQoJ29wZXJhdGlvbi1lbmQnLCB7IF9pZDogb3BJZCwgbW9kZWxOYW1lOiBfdGhpcy5tb2RlbE5hbWUsIGNvbGxlY3Rpb25OYW1lOiBfdGhpcy5uYW1lLCBtZXRob2Q6IGksIHJlc3VsdDogcmVzIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsYXN0QXJnLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9O1xuICAgICAgX2FyZ3MgPSBhcmdzLnNsaWNlKDAsIGFyZ3MubGVuZ3RoIC0gMSkuY29uY2F0KFtjYWxsYmFja10pO1xuICAgIH1cblxuICAgIGlmIChkZWJ1Zykge1xuICAgICAgaWYgKHR5cGVvZiBkZWJ1ZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBsZXQgYXJnc1RvQWRkID0gbnVsbDtcbiAgICAgICAgaWYgKHR5cGVvZiBhcmdzW2FyZ3MubGVuZ3RoIC0gMV0gPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIGFyZ3NUb0FkZCA9IGFyZ3Muc2xpY2UoMCwgYXJncy5sZW5ndGggLSAxKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhcmdzVG9BZGQgPSBhcmdzO1xuICAgICAgICB9XG4gICAgICAgIGRlYnVnLmFwcGx5KF90aGlzLFxuICAgICAgICAgIFtfdGhpcy5uYW1lLCBpXS5jb25jYXQoYXJnc1RvQWRkKSk7XG4gICAgICB9IGVsc2UgaWYgKGRlYnVnIGluc3RhbmNlb2Ygc3RyZWFtLldyaXRhYmxlKSB7XG4gICAgICAgIHRoaXMuJHByaW50VG9TdHJlYW0oX3RoaXMubmFtZSwgaSwgYXJncywgZGVidWcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgY29sb3IgPSBkZWJ1Zy5jb2xvciA9PSBudWxsID8gdHJ1ZSA6IGRlYnVnLmNvbG9yO1xuICAgICAgICBjb25zdCBzaGVsbCA9IGRlYnVnLnNoZWxsID09IG51bGwgPyBmYWxzZSA6IGRlYnVnLnNoZWxsO1xuICAgICAgICB0aGlzLiRwcmludChfdGhpcy5uYW1lLCBpLCBhcmdzLCBjb2xvciwgc2hlbGwpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuY29ubi5lbWl0KCdvcGVyYXRpb24tc3RhcnQnLCB7IF9pZDogb3BJZCwgbW9kZWxOYW1lOiBfdGhpcy5tb2RlbE5hbWUsIGNvbGxlY3Rpb25OYW1lOiB0aGlzLm5hbWUsIG1ldGhvZDogaSwgcGFyYW1zOiBfYXJncyB9KTtcblxuICAgIHRyeSB7XG4gICAgICBpZiAoY29sbGVjdGlvbiA9PSBudWxsKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSAnQ2Fubm90IGNhbGwgYCcgKyB0aGlzLm5hbWUgKyAnLicgKyBpICsgJygpYCBiZWZvcmUgaW5pdGlhbCBjb25uZWN0aW9uICcgK1xuICAgICAgICAgICdpcyBjb21wbGV0ZSBpZiBgYnVmZmVyQ29tbWFuZHMgPSBmYWxzZWAuIE1ha2Ugc3VyZSB5b3UgYGF3YWl0IG1vbmdvb3NlLmNvbm5lY3QoKWAgaWYgJyArXG4gICAgICAgICAgJ3lvdSBoYXZlIGBidWZmZXJDb21tYW5kcyA9IGZhbHNlYC4nO1xuICAgICAgICB0aHJvdyBuZXcgTW9uZ29vc2VFcnJvcihtZXNzYWdlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHN5bmNDb2xsZWN0aW9uTWV0aG9kc1tpXSAmJiB0eXBlb2YgbGFzdEFyZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBjb25zdCByZXQgPSBjb2xsZWN0aW9uW2ldLmFwcGx5KGNvbGxlY3Rpb24sIF9hcmdzLnNsaWNlKDAsIF9hcmdzLmxlbmd0aCAtIDEpKTtcbiAgICAgICAgcmV0dXJuIGxhc3RBcmcuY2FsbCh0aGlzLCBudWxsLCByZXQpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCByZXQgPSBjb2xsZWN0aW9uW2ldLmFwcGx5KGNvbGxlY3Rpb24sIF9hcmdzKTtcbiAgICAgIGlmIChyZXQgIT0gbnVsbCAmJiB0eXBlb2YgcmV0LnRoZW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIHJldC50aGVuKFxuICAgICAgICAgIHJlcyA9PiB7XG4gICAgICAgICAgICB0eXBlb2YgbGFzdEFyZyA9PT0gJ2Z1bmN0aW9uJyAmJiBsYXN0QXJnKG51bGwsIHJlcyk7XG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZXJyID0+IHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbGFzdEFyZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICBsYXN0QXJnKGVycik7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICB9XG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmV0O1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAvLyBDb2xsZWN0aW9uIG9wZXJhdGlvbiBtYXkgdGhyb3cgYmVjYXVzZSBvZiBtYXggYnNvbiBzaXplLCBjYXRjaCBpdCBoZXJlXG4gICAgICAvLyBTZWUgZ2gtMzkwNlxuICAgICAgaWYgKHR5cGVvZiBsYXN0QXJnID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBsYXN0QXJnKGVycm9yKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuY29ubi5lbWl0KCdvcGVyYXRpb24tZW5kJywgeyBfaWQ6IG9wSWQsIG1vZGVsTmFtZTogX3RoaXMubW9kZWxOYW1lLCBjb2xsZWN0aW9uTmFtZTogdGhpcy5uYW1lLCBtZXRob2Q6IGksIGVycm9yOiBlcnJvciB9KTtcblxuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH1cbiAgICB9XG4gIH07XG59XG5cbmZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKENvbGxlY3Rpb24ucHJvdG90eXBlKSkge1xuICAvLyBKYW5reSBoYWNrIHRvIHdvcmsgYXJvdW5kIGdoLTMwMDUgdW50aWwgd2UgY2FuIGdldCByaWQgb2YgdGhlIG1vbmdvb3NlXG4gIC8vIGNvbGxlY3Rpb24gYWJzdHJhY3Rpb25cbiAgY29uc3QgZGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoQ29sbGVjdGlvbi5wcm90b3R5cGUsIGtleSk7XG4gIC8vIFNraXAgcHJvcGVydGllcyB3aXRoIGdldHRlcnMgYmVjYXVzZSB0aGV5IG1heSB0aHJvdyBlcnJvcnMgKGdoLTg1MjgpXG4gIGlmIChkZXNjcmlwdG9yLmdldCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgY29udGludWU7XG4gIH1cbiAgaWYgKHR5cGVvZiBDb2xsZWN0aW9uLnByb3RvdHlwZVtrZXldICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgY29udGludWU7XG4gIH1cblxuICBpdGVyKGtleSk7XG59XG5cbi8qKlxuICogRGVidWcgcHJpbnQgaGVscGVyXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqIEBtZXRob2QgJHByaW50XG4gKi9cblxuTmF0aXZlQ29sbGVjdGlvbi5wcm90b3R5cGUuJHByaW50ID0gZnVuY3Rpb24obmFtZSwgaSwgYXJncywgY29sb3IsIHNoZWxsKSB7XG4gIGNvbnN0IG1vZHVsZU5hbWUgPSBjb2xvciA/ICdcXHgxQlswOzM2bU1vbmdvb3NlOlxceDFCWzBtICcgOiAnTW9uZ29vc2U6ICc7XG4gIGNvbnN0IGZ1bmN0aW9uQ2FsbCA9IFtuYW1lLCBpXS5qb2luKCcuJyk7XG4gIGNvbnN0IF9hcmdzID0gW107XG4gIGZvciAobGV0IGogPSBhcmdzLmxlbmd0aCAtIDE7IGogPj0gMDsgLS1qKSB7XG4gICAgaWYgKHRoaXMuJGZvcm1hdChhcmdzW2pdKSB8fCBfYXJncy5sZW5ndGgpIHtcbiAgICAgIF9hcmdzLnVuc2hpZnQodGhpcy4kZm9ybWF0KGFyZ3Nbal0sIGNvbG9yLCBzaGVsbCkpO1xuICAgIH1cbiAgfVxuICBjb25zdCBwYXJhbXMgPSAnKCcgKyBfYXJncy5qb2luKCcsICcpICsgJyknO1xuXG4gIGNvbnNvbGUuaW5mbyhtb2R1bGVOYW1lICsgZnVuY3Rpb25DYWxsICsgcGFyYW1zKTtcbn07XG5cbi8qKlxuICogRGVidWcgcHJpbnQgaGVscGVyXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqIEBtZXRob2QgJHByaW50XG4gKi9cblxuTmF0aXZlQ29sbGVjdGlvbi5wcm90b3R5cGUuJHByaW50VG9TdHJlYW0gPSBmdW5jdGlvbihuYW1lLCBpLCBhcmdzLCBzdHJlYW0pIHtcbiAgY29uc3QgZnVuY3Rpb25DYWxsID0gW25hbWUsIGldLmpvaW4oJy4nKTtcbiAgY29uc3QgX2FyZ3MgPSBbXTtcbiAgZm9yIChsZXQgaiA9IGFyZ3MubGVuZ3RoIC0gMTsgaiA+PSAwOyAtLWopIHtcbiAgICBpZiAodGhpcy4kZm9ybWF0KGFyZ3Nbal0pIHx8IF9hcmdzLmxlbmd0aCkge1xuICAgICAgX2FyZ3MudW5zaGlmdCh0aGlzLiRmb3JtYXQoYXJnc1tqXSkpO1xuICAgIH1cbiAgfVxuICBjb25zdCBwYXJhbXMgPSAnKCcgKyBfYXJncy5qb2luKCcsICcpICsgJyknO1xuXG4gIHN0cmVhbS53cml0ZShmdW5jdGlvbkNhbGwgKyBwYXJhbXMsICd1dGY4Jyk7XG59O1xuXG4vKipcbiAqIEZvcm1hdHRlciBmb3IgZGVidWcgcHJpbnQgYXJnc1xuICpcbiAqIEBhcGkgcHVibGljXG4gKiBAbWV0aG9kICRmb3JtYXRcbiAqL1xuXG5OYXRpdmVDb2xsZWN0aW9uLnByb3RvdHlwZS4kZm9ybWF0ID0gZnVuY3Rpb24oYXJnLCBjb2xvciwgc2hlbGwpIHtcbiAgY29uc3QgdHlwZSA9IHR5cGVvZiBhcmc7XG4gIGlmICh0eXBlID09PSAnZnVuY3Rpb24nIHx8IHR5cGUgPT09ICd1bmRlZmluZWQnKSByZXR1cm4gJyc7XG4gIHJldHVybiBmb3JtYXQoYXJnLCBmYWxzZSwgY29sb3IsIHNoZWxsKTtcbn07XG5cbi8qKlxuICogRGVidWcgcHJpbnQgaGVscGVyXG4gKiBAcGFyYW0ge0FueX0gcmVwcmVzZW50YXRpb25cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGluc3BlY3RhYmxlKHJlcHJlc2VudGF0aW9uKSB7XG4gIGNvbnN0IHJldCA9IHtcbiAgICBpbnNwZWN0OiBmdW5jdGlvbigpIHsgcmV0dXJuIHJlcHJlc2VudGF0aW9uOyB9XG4gIH07XG4gIGlmICh1dGlsLmluc3BlY3QuY3VzdG9tKSB7XG4gICAgcmV0W3V0aWwuaW5zcGVjdC5jdXN0b21dID0gcmV0Lmluc3BlY3Q7XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cbmZ1bmN0aW9uIG1hcChvKSB7XG4gIHJldHVybiBmb3JtYXQobywgdHJ1ZSk7XG59XG5mdW5jdGlvbiBmb3JtYXRPYmplY3RJZCh4LCBrZXkpIHtcbiAgeFtrZXldID0gaW5zcGVjdGFibGUoJ09iamVjdElkKFwiJyArIHhba2V5XS50b0hleFN0cmluZygpICsgJ1wiKScpO1xufVxuZnVuY3Rpb24gZm9ybWF0RGF0ZSh4LCBrZXksIHNoZWxsKSB7XG4gIGlmIChzaGVsbCkge1xuICAgIHhba2V5XSA9IGluc3BlY3RhYmxlKCdJU09EYXRlKFwiJyArIHhba2V5XS50b1VUQ1N0cmluZygpICsgJ1wiKScpO1xuICB9IGVsc2Uge1xuICAgIHhba2V5XSA9IGluc3BlY3RhYmxlKCduZXcgRGF0ZShcIicgKyB4W2tleV0udG9VVENTdHJpbmcoKSArICdcIiknKTtcbiAgfVxufVxuZnVuY3Rpb24gZm9ybWF0KG9iaiwgc3ViLCBjb2xvciwgc2hlbGwpIHtcbiAgaWYgKG9iaiAmJiB0eXBlb2Ygb2JqLnRvQlNPTiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIG9iaiA9IG9iai50b0JTT04oKTtcbiAgfVxuICBpZiAob2JqID09IG51bGwpIHtcbiAgICByZXR1cm4gb2JqO1xuICB9XG5cbiAgY29uc3QgY2xvbmUgPSByZXF1aXJlKCcuLi8uLi9oZWxwZXJzL2Nsb25lJyk7XG4gIGxldCB4ID0gY2xvbmUob2JqLCBpbnRlcm5hbFRvT2JqZWN0T3B0aW9ucyk7XG4gIGNvbnN0IGNvbnN0cnVjdG9yTmFtZSA9IGdldENvbnN0cnVjdG9yTmFtZSh4KTtcblxuICBpZiAoY29uc3RydWN0b3JOYW1lID09PSAnQmluYXJ5Jykge1xuICAgIHggPSAnQmluRGF0YSgnICsgeC5zdWJfdHlwZSArICcsIFwiJyArIHgudG9TdHJpbmcoJ2Jhc2U2NCcpICsgJ1wiKSc7XG4gIH0gZWxzZSBpZiAoY29uc3RydWN0b3JOYW1lID09PSAnT2JqZWN0SWQnKSB7XG4gICAgeCA9IGluc3BlY3RhYmxlKCdPYmplY3RJZChcIicgKyB4LnRvSGV4U3RyaW5nKCkgKyAnXCIpJyk7XG4gIH0gZWxzZSBpZiAoY29uc3RydWN0b3JOYW1lID09PSAnRGF0ZScpIHtcbiAgICB4ID0gaW5zcGVjdGFibGUoJ25ldyBEYXRlKFwiJyArIHgudG9VVENTdHJpbmcoKSArICdcIiknKTtcbiAgfSBlbHNlIGlmIChjb25zdHJ1Y3Rvck5hbWUgPT09ICdPYmplY3QnKSB7XG4gICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHgpO1xuICAgIGNvbnN0IG51bUtleXMgPSBrZXlzLmxlbmd0aDtcbiAgICBsZXQga2V5O1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtS2V5czsgKytpKSB7XG4gICAgICBrZXkgPSBrZXlzW2ldO1xuICAgICAgaWYgKHhba2V5XSkge1xuICAgICAgICBsZXQgZXJyb3I7XG4gICAgICAgIGlmICh0eXBlb2YgeFtrZXldLnRvQlNPTiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBgc2Vzc2lvbi50b0JTT04oKWAgdGhyb3dzIGFuIGVycm9yLiBUaGlzIG1lYW5zIHdlIHRocm93IGVycm9yc1xuICAgICAgICAgICAgLy8gaW4gZGVidWcgbW9kZSB3aGVuIHVzaW5nIHRyYW5zYWN0aW9ucywgc2VlIGdoLTY3MTIuIEFzIGFcbiAgICAgICAgICAgIC8vIHdvcmthcm91bmQsIGNhdGNoIGB0b0JTT04oKWAgZXJyb3JzLCB0cnkgdG8gc2VyaWFsaXplIHdpdGhvdXRcbiAgICAgICAgICAgIC8vIGB0b0JTT04oKWAsIGFuZCByZXRocm93IGlmIHNlcmlhbGl6YXRpb24gc3RpbGwgZmFpbHMuXG4gICAgICAgICAgICB4W2tleV0gPSB4W2tleV0udG9CU09OKCk7XG4gICAgICAgICAgfSBjYXRjaCAoX2Vycm9yKSB7XG4gICAgICAgICAgICBlcnJvciA9IF9lcnJvcjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgX2NvbnN0cnVjdG9yTmFtZSA9IGdldENvbnN0cnVjdG9yTmFtZSh4W2tleV0pO1xuICAgICAgICBpZiAoX2NvbnN0cnVjdG9yTmFtZSA9PT0gJ0JpbmFyeScpIHtcbiAgICAgICAgICB4W2tleV0gPSAnQmluRGF0YSgnICsgeFtrZXldLnN1Yl90eXBlICsgJywgXCInICtcbiAgICAgICAgICAgIHhba2V5XS5idWZmZXIudG9TdHJpbmcoJ2Jhc2U2NCcpICsgJ1wiKSc7XG4gICAgICAgIH0gZWxzZSBpZiAoX2NvbnN0cnVjdG9yTmFtZSA9PT0gJ09iamVjdCcpIHtcbiAgICAgICAgICB4W2tleV0gPSBmb3JtYXQoeFtrZXldLCB0cnVlKTtcbiAgICAgICAgfSBlbHNlIGlmIChfY29uc3RydWN0b3JOYW1lID09PSAnT2JqZWN0SWQnKSB7XG4gICAgICAgICAgZm9ybWF0T2JqZWN0SWQoeCwga2V5KTtcbiAgICAgICAgfSBlbHNlIGlmIChfY29uc3RydWN0b3JOYW1lID09PSAnRGF0ZScpIHtcbiAgICAgICAgICBmb3JtYXREYXRlKHgsIGtleSwgc2hlbGwpO1xuICAgICAgICB9IGVsc2UgaWYgKF9jb25zdHJ1Y3Rvck5hbWUgPT09ICdDbGllbnRTZXNzaW9uJykge1xuICAgICAgICAgIHhba2V5XSA9IGluc3BlY3RhYmxlKCdDbGllbnRTZXNzaW9uKFwiJyArXG4gICAgICAgICAgICAoXG4gICAgICAgICAgICAgIHhba2V5XSAmJlxuICAgICAgICAgICAgICB4W2tleV0uaWQgJiZcbiAgICAgICAgICAgICAgeFtrZXldLmlkLmlkICYmXG4gICAgICAgICAgICAgIHhba2V5XS5pZC5pZC5idWZmZXIgfHwgJydcbiAgICAgICAgICAgICkudG9TdHJpbmcoJ2hleCcpICsgJ1wiKScpO1xuICAgICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoeFtrZXldKSkge1xuICAgICAgICAgIHhba2V5XSA9IHhba2V5XS5tYXAobWFwKTtcbiAgICAgICAgfSBlbHNlIGlmIChlcnJvciAhPSBudWxsKSB7XG4gICAgICAgICAgLy8gSWYgdGhlcmUgd2FzIGFuIGVycm9yIHdpdGggYHRvQlNPTigpYCBhbmQgdGhlIG9iamVjdCB3YXNuJ3RcbiAgICAgICAgICAvLyBhbHJlYWR5IGNvbnZlcnRlZCB0byBhIHN0cmluZyByZXByZXNlbnRhdGlvbiwgcmV0aHJvdyBpdC5cbiAgICAgICAgICAvLyBPcGVuIHRvIGJldHRlciBpZGVhcyBvbiBob3cgdG8gaGFuZGxlIHRoaXMuXG4gICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKHN1Yikge1xuICAgIHJldHVybiB4O1xuICB9XG5cbiAgcmV0dXJuIHV0aWwuXG4gICAgaW5zcGVjdCh4LCBmYWxzZSwgMTAsIGNvbG9yKS5cbiAgICByZXBsYWNlKC9cXG4vZywgJycpLlxuICAgIHJlcGxhY2UoL1xcc3syLH0vZywgJyAnKTtcbn1cblxuLyoqXG4gKiBSZXRyaWV2ZXMgaW5mb3JtYXRpb24gYWJvdXQgdGhpcyBjb2xsZWN0aW9ucyBpbmRleGVzLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gKiBAbWV0aG9kIGdldEluZGV4ZXNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuTmF0aXZlQ29sbGVjdGlvbi5wcm90b3R5cGUuZ2V0SW5kZXhlcyA9IE5hdGl2ZUNvbGxlY3Rpb24ucHJvdG90eXBlLmluZGV4SW5mb3JtYXRpb247XG5cbi8qIVxuICogTW9kdWxlIGV4cG9ydHMuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBOYXRpdmVDb2xsZWN0aW9uO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../server/node_modules/mongoose/lib/drivers/node-mongodb-native/collection.js\n");

/***/ }),

/***/ "../server/node_modules/mongoose/lib/drivers/node-mongodb-native/connection.js":
/*!*************************************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/drivers/node-mongodb-native/connection.js ***!
  \*************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*!\n * Module dependencies.\n */\n\n\n\nconst MongooseConnection = __webpack_require__(/*! ../../connection */ \"../server/node_modules/mongoose/lib/connection.js\");\nconst MongooseError = __webpack_require__(/*! ../../error/index */ \"../server/node_modules/mongoose/lib/error/index.js\");\nconst STATES = __webpack_require__(/*! ../../connectionState */ \"../server/node_modules/mongoose/lib/connectionState.js\");\nconst mongodb = __webpack_require__(/*! mongodb */ \"../server/node_modules/mongodb/lib/index.js\");\nconst pkg = __webpack_require__(/*! ../../../package.json */ \"../server/node_modules/mongoose/package.json\");\nconst processConnectionOptions = __webpack_require__(/*! ../../helpers/processConnectionOptions */ \"../server/node_modules/mongoose/lib/helpers/processConnectionOptions.js\");\nconst setTimeout = (__webpack_require__(/*! ../../helpers/timers */ \"../server/node_modules/mongoose/lib/helpers/timers.js\").setTimeout);\nconst utils = __webpack_require__(/*! ../../utils */ \"../server/node_modules/mongoose/lib/utils.js\");\n\n/**\n * A [node-mongodb-native](https://github.com/mongodb/node-mongodb-native) connection implementation.\n *\n * @inherits Connection\n * @api private\n */\n\nfunction NativeConnection() {\n  MongooseConnection.apply(this, arguments);\n  this._listening = false;\n}\n\n/**\n * Expose the possible connection states.\n * @api public\n */\n\nNativeConnection.STATES = STATES;\n\n/*!\n * Inherits from Connection.\n */\n\nObject.setPrototypeOf(NativeConnection.prototype, MongooseConnection.prototype);\n\n/**\n * Switches to a different database using the same connection pool.\n *\n * Returns a new connection object, with the new db. If you set the `useCache`\n * option, `useDb()` will cache connections by `name`.\n *\n * **Note:** Calling `close()` on a `useDb()` connection will close the base connection as well.\n *\n * @param {String} name The database name\n * @param {Object} [options]\n * @param {Boolean} [options.useCache=false] If true, cache results so calling `useDb()` multiple times with the same name only creates 1 connection object.\n * @param {Boolean} [options.noListener=false] If true, the new connection object won't listen to any events on the base connection. This is better for memory usage in cases where you're calling `useDb()` for every request.\n * @return {Connection} New Connection Object\n * @api public\n */\n\nNativeConnection.prototype.useDb = function(name, options) {\n  // Return immediately if cached\n  options = options || {};\n  if (options.useCache && this.relatedDbs[name]) {\n    return this.relatedDbs[name];\n  }\n\n  // we have to manually copy all of the attributes...\n  const newConn = new this.constructor();\n  newConn.name = name;\n  newConn.base = this.base;\n  newConn.collections = {};\n  newConn.models = {};\n  newConn.replica = this.replica;\n  newConn.config = Object.assign({}, this.config, newConn.config);\n  newConn.name = this.name;\n  newConn.options = this.options;\n  newConn._readyState = this._readyState;\n  newConn._closeCalled = this._closeCalled;\n  newConn._hasOpened = this._hasOpened;\n  newConn._listening = false;\n  newConn._parent = this;\n\n  newConn.host = this.host;\n  newConn.port = this.port;\n  newConn.user = this.user;\n  newConn.pass = this.pass;\n\n  // First, when we create another db object, we are not guaranteed to have a\n  // db object to work with. So, in the case where we have a db object and it\n  // is connected, we can just proceed with setting everything up. However, if\n  // we do not have a db or the state is not connected, then we need to wait on\n  // the 'open' event of the connection before doing the rest of the setup\n  // the 'connected' event is the first time we'll have access to the db object\n\n  const _this = this;\n\n  newConn.client = _this.client;\n\n  if (this.db && this._readyState === STATES.connected) {\n    wireup();\n  } else {\n    this.once('connected', wireup);\n  }\n\n  function wireup() {\n    newConn.client = _this.client;\n    const _opts = {};\n    if (options.hasOwnProperty('noListener')) {\n      _opts.noListener = options.noListener;\n    }\n    newConn.db = _this.client.db(name, _opts);\n    newConn.onOpen();\n  }\n\n  newConn.name = name;\n\n  // push onto the otherDbs stack, this is used when state changes\n  if (options.noListener !== true) {\n    this.otherDbs.push(newConn);\n  }\n  newConn.otherDbs.push(this);\n\n  // push onto the relatedDbs cache, this is used when state changes\n  if (options && options.useCache) {\n    this.relatedDbs[newConn.name] = newConn;\n    newConn.relatedDbs = this.relatedDbs;\n  }\n\n  return newConn;\n};\n\n/**\n * Removes the database connection with the given name created with `useDb()`.\n *\n * Throws an error if the database connection was not found.\n *\n * #### Example:\n *\n *     // Connect to `initialdb` first\n *     const conn = await mongoose.createConnection('mongodb://127.0.0.1:27017/initialdb').asPromise();\n *\n *     // Creates an un-cached connection to `mydb`\n *     const db = conn.useDb('mydb');\n *\n *     // Closes `db`, and removes `db` from `conn.relatedDbs` and `conn.otherDbs`\n *     await conn.removeDb('mydb');\n *\n * @method removeDb\n * @memberOf Connection\n * @param {String} name The database name\n * @return {Connection} this\n */\n\nNativeConnection.prototype.removeDb = function removeDb(name) {\n  const dbs = this.otherDbs.filter(db => db.name === name);\n  if (!dbs.length) {\n    throw new MongooseError(`No connections to database \"${name}\" found`);\n  }\n\n  for (const db of dbs) {\n    db._closeCalled = true;\n    db._destroyCalled = true;\n    db._readyState = STATES.disconnected;\n    db.$wasForceClosed = true;\n  }\n  delete this.relatedDbs[name];\n  this.otherDbs = this.otherDbs.filter(db => db.name !== name);\n};\n\n/**\n * Closes the connection\n *\n * @param {Boolean} [force]\n * @return {Connection} this\n * @api private\n */\n\nNativeConnection.prototype.doClose = async function doClose(force) {\n  if (this.client == null) {\n    return this;\n  }\n\n  let skipCloseClient = false;\n  if (force != null && typeof force === 'object') {\n    skipCloseClient = force.skipCloseClient;\n    force = force.force;\n  }\n\n  if (skipCloseClient) {\n    return this;\n  }\n\n  await this.client.close(force);\n  // Defer because the driver will wait at least 1ms before finishing closing\n  // the pool, see https://github.com/mongodb-js/mongodb-core/blob/a8f8e4ce41936babc3b9112bf42d609779f03b39/lib/connection/pool.js#L1026-L1030.\n  // If there's queued operations, you may still get some background work\n  // after the callback is called.\n  await new Promise(resolve => setTimeout(resolve, 1));\n\n  return this;\n};\n\n/*!\n * ignore\n */\n\nNativeConnection.prototype.createClient = async function createClient(uri, options) {\n  if (typeof uri !== 'string') {\n    throw new MongooseError('The `uri` parameter to `openUri()` must be a ' +\n      `string, got \"${typeof uri}\". Make sure the first parameter to ` +\n      '`mongoose.connect()` or `mongoose.createConnection()` is a string.');\n  }\n\n  if (this._destroyCalled) {\n    throw new MongooseError(\n      'Connection has been closed and destroyed, and cannot be used for re-opening the connection. ' +\n      'Please create a new connection with `mongoose.createConnection()` or `mongoose.connect()`.'\n    );\n  }\n\n  if (this.readyState === STATES.connecting || this.readyState === STATES.connected) {\n    if (this._connectionString !== uri) {\n      throw new MongooseError('Can\\'t call `openUri()` on an active connection with ' +\n        'different connection strings. Make sure you aren\\'t calling `mongoose.connect()` ' +\n        'multiple times. See: https://mongoosejs.com/docs/connections.html#multiple_connections');\n    }\n  }\n\n  options = processConnectionOptions(uri, options);\n\n  if (options) {\n\n    const autoIndex = options.config && options.config.autoIndex != null ?\n      options.config.autoIndex :\n      options.autoIndex;\n    if (autoIndex != null) {\n      this.config.autoIndex = autoIndex !== false;\n      delete options.config;\n      delete options.autoIndex;\n    }\n\n    if ('autoCreate' in options) {\n      this.config.autoCreate = !!options.autoCreate;\n      delete options.autoCreate;\n    }\n\n    if ('sanitizeFilter' in options) {\n      this.config.sanitizeFilter = options.sanitizeFilter;\n      delete options.sanitizeFilter;\n    }\n\n    if ('autoSearchIndex' in options) {\n      this.config.autoSearchIndex = options.autoSearchIndex;\n      delete options.autoSearchIndex;\n    }\n\n    // Backwards compat\n    if (options.user || options.pass) {\n      options.auth = options.auth || {};\n      options.auth.username = options.user;\n      options.auth.password = options.pass;\n\n      this.user = options.user;\n      this.pass = options.pass;\n    }\n    delete options.user;\n    delete options.pass;\n\n    if (options.bufferCommands != null) {\n      this.config.bufferCommands = options.bufferCommands;\n      delete options.bufferCommands;\n    }\n  } else {\n    options = {};\n  }\n\n  this._connectionOptions = options;\n  const dbName = options.dbName;\n  if (dbName != null) {\n    this.$dbName = dbName;\n  }\n  delete options.dbName;\n\n  if (!utils.hasUserDefinedProperty(options, 'driverInfo')) {\n    options.driverInfo = {\n      name: 'Mongoose',\n      version: pkg.version\n    };\n  }\n\n  this.readyState = STATES.connecting;\n  this._connectionString = uri;\n\n  let client;\n  try {\n    client = new mongodb.MongoClient(uri, options);\n  } catch (error) {\n    this.readyState = STATES.disconnected;\n    throw error;\n  }\n  this.client = client;\n\n  client.setMaxListeners(0);\n  await client.connect();\n\n  _setClient(this, client, options, dbName);\n\n  for (const db of this.otherDbs) {\n    _setClient(db, client, {}, db.name);\n  }\n  return this;\n};\n\n/*!\n * ignore\n */\n\nNativeConnection.prototype.setClient = function setClient(client) {\n  if (!(client instanceof mongodb.MongoClient)) {\n    throw new MongooseError('Must call `setClient()` with an instance of MongoClient');\n  }\n  if (this.readyState !== STATES.disconnected) {\n    throw new MongooseError('Cannot call `setClient()` on a connection that is already connected.');\n  }\n  if (client.topology == null) {\n    throw new MongooseError('Cannot call `setClient()` with a MongoClient that you have not called `connect()` on yet.');\n  }\n\n  this._connectionString = client.s.url;\n  _setClient(this, client, {}, client.s.options.dbName);\n\n  for (const model of Object.values(this.models)) {\n    // Errors handled internally, so safe to ignore error\n    model.init().catch(function $modelInitNoop() {});\n  }\n\n  return this;\n};\n\n/*!\n * ignore\n */\n\nfunction _setClient(conn, client, options, dbName) {\n  const db = dbName != null ? client.db(dbName) : client.db();\n  conn.db = db;\n  conn.client = client;\n  conn.host = client &&\n    client.s &&\n    client.s.options &&\n    client.s.options.hosts &&\n    client.s.options.hosts[0] &&\n    client.s.options.hosts[0].host || void 0;\n  conn.port = client &&\n    client.s &&\n    client.s.options &&\n    client.s.options.hosts &&\n    client.s.options.hosts[0] &&\n    client.s.options.hosts[0].port || void 0;\n  conn.name = dbName != null ? dbName : db.databaseName;\n  conn._closeCalled = client._closeCalled;\n\n  const _handleReconnect = () => {\n    // If we aren't disconnected, we assume this reconnect is due to a\n    // socket timeout. If there's no activity on a socket for\n    // `socketTimeoutMS`, the driver will attempt to reconnect and emit\n    // this event.\n    if (conn.readyState !== STATES.connected) {\n      conn.readyState = STATES.connected;\n      conn.emit('reconnect');\n      conn.emit('reconnected');\n      conn.onOpen();\n    }\n  };\n\n  const type = client &&\n  client.topology &&\n  client.topology.description &&\n  client.topology.description.type || '';\n\n  if (type === 'Single') {\n    client.on('serverDescriptionChanged', ev => {\n      const newDescription = ev.newDescription;\n      if (newDescription.type === 'Unknown') {\n        conn.readyState = STATES.disconnected;\n      } else {\n        _handleReconnect();\n      }\n    });\n  } else if (type.startsWith('ReplicaSet')) {\n    client.on('topologyDescriptionChanged', ev => {\n      // Emit disconnected if we've lost connectivity to the primary\n      const description = ev.newDescription;\n      if (conn.readyState === STATES.connected && description.type !== 'ReplicaSetWithPrimary') {\n        // Implicitly emits 'disconnected'\n        conn.readyState = STATES.disconnected;\n      } else if (conn.readyState === STATES.disconnected && description.type === 'ReplicaSetWithPrimary') {\n        _handleReconnect();\n      }\n    });\n  }\n\n  conn.onOpen();\n\n  for (const i in conn.collections) {\n    if (utils.object.hasOwnProperty(conn.collections, i)) {\n      conn.collections[i].onOpen();\n    }\n  }\n}\n\n\n/*!\n * Module exports.\n */\n\nmodule.exports = NativeConnection;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvZHJpdmVycy9ub2RlLW1vbmdvZGItbmF0aXZlL2Nvbm5lY3Rpb24uanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBOztBQUVhOztBQUViLDJCQUEyQixtQkFBTyxDQUFDLDJFQUFrQjtBQUNyRCxzQkFBc0IsbUJBQU8sQ0FBQyw2RUFBbUI7QUFDakQsZUFBZSxtQkFBTyxDQUFDLHFGQUF1QjtBQUM5QyxnQkFBZ0IsbUJBQU8sQ0FBQyw0REFBUztBQUNqQyxZQUFZLG1CQUFPLENBQUMsMkVBQXVCO0FBQzNDLGlDQUFpQyxtQkFBTyxDQUFDLHVIQUF3QztBQUNqRixtQkFBbUIscUhBQTBDO0FBQzdELGNBQWMsbUJBQU8sQ0FBQyxpRUFBYTs7QUFFbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFNBQVM7QUFDcEIsV0FBVyxTQUFTO0FBQ3BCLFlBQVksWUFBWTtBQUN4QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsWUFBWSxZQUFZO0FBQ3hCOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCxLQUFLO0FBQ2hFOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEIsWUFBWSxZQUFZO0FBQ3hCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixXQUFXO0FBQ2pDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw2QkFBNkI7O0FBRTdCO0FBQ0E7QUFDQSxtREFBbUQ7QUFDbkQ7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2xpZW50Ly4uL3NlcnZlci9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2RyaXZlcnMvbm9kZS1tb25nb2RiLW5hdGl2ZS9jb25uZWN0aW9uLmpzP2I1NmMiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuY29uc3QgTW9uZ29vc2VDb25uZWN0aW9uID0gcmVxdWlyZSgnLi4vLi4vY29ubmVjdGlvbicpO1xuY29uc3QgTW9uZ29vc2VFcnJvciA9IHJlcXVpcmUoJy4uLy4uL2Vycm9yL2luZGV4Jyk7XG5jb25zdCBTVEFURVMgPSByZXF1aXJlKCcuLi8uLi9jb25uZWN0aW9uU3RhdGUnKTtcbmNvbnN0IG1vbmdvZGIgPSByZXF1aXJlKCdtb25nb2RiJyk7XG5jb25zdCBwa2cgPSByZXF1aXJlKCcuLi8uLi8uLi9wYWNrYWdlLmpzb24nKTtcbmNvbnN0IHByb2Nlc3NDb25uZWN0aW9uT3B0aW9ucyA9IHJlcXVpcmUoJy4uLy4uL2hlbHBlcnMvcHJvY2Vzc0Nvbm5lY3Rpb25PcHRpb25zJyk7XG5jb25zdCBzZXRUaW1lb3V0ID0gcmVxdWlyZSgnLi4vLi4vaGVscGVycy90aW1lcnMnKS5zZXRUaW1lb3V0O1xuY29uc3QgdXRpbHMgPSByZXF1aXJlKCcuLi8uLi91dGlscycpO1xuXG4vKipcbiAqIEEgW25vZGUtbW9uZ29kYi1uYXRpdmVdKGh0dHBzOi8vZ2l0aHViLmNvbS9tb25nb2RiL25vZGUtbW9uZ29kYi1uYXRpdmUpIGNvbm5lY3Rpb24gaW1wbGVtZW50YXRpb24uXG4gKlxuICogQGluaGVyaXRzIENvbm5lY3Rpb25cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIE5hdGl2ZUNvbm5lY3Rpb24oKSB7XG4gIE1vbmdvb3NlQ29ubmVjdGlvbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB0aGlzLl9saXN0ZW5pbmcgPSBmYWxzZTtcbn1cblxuLyoqXG4gKiBFeHBvc2UgdGhlIHBvc3NpYmxlIGNvbm5lY3Rpb24gc3RhdGVzLlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5OYXRpdmVDb25uZWN0aW9uLlNUQVRFUyA9IFNUQVRFUztcblxuLyohXG4gKiBJbmhlcml0cyBmcm9tIENvbm5lY3Rpb24uXG4gKi9cblxuT2JqZWN0LnNldFByb3RvdHlwZU9mKE5hdGl2ZUNvbm5lY3Rpb24ucHJvdG90eXBlLCBNb25nb29zZUNvbm5lY3Rpb24ucHJvdG90eXBlKTtcblxuLyoqXG4gKiBTd2l0Y2hlcyB0byBhIGRpZmZlcmVudCBkYXRhYmFzZSB1c2luZyB0aGUgc2FtZSBjb25uZWN0aW9uIHBvb2wuXG4gKlxuICogUmV0dXJucyBhIG5ldyBjb25uZWN0aW9uIG9iamVjdCwgd2l0aCB0aGUgbmV3IGRiLiBJZiB5b3Ugc2V0IHRoZSBgdXNlQ2FjaGVgXG4gKiBvcHRpb24sIGB1c2VEYigpYCB3aWxsIGNhY2hlIGNvbm5lY3Rpb25zIGJ5IGBuYW1lYC5cbiAqXG4gKiAqKk5vdGU6KiogQ2FsbGluZyBgY2xvc2UoKWAgb24gYSBgdXNlRGIoKWAgY29ubmVjdGlvbiB3aWxsIGNsb3NlIHRoZSBiYXNlIGNvbm5lY3Rpb24gYXMgd2VsbC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBUaGUgZGF0YWJhc2UgbmFtZVxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy51c2VDYWNoZT1mYWxzZV0gSWYgdHJ1ZSwgY2FjaGUgcmVzdWx0cyBzbyBjYWxsaW5nIGB1c2VEYigpYCBtdWx0aXBsZSB0aW1lcyB3aXRoIHRoZSBzYW1lIG5hbWUgb25seSBjcmVhdGVzIDEgY29ubmVjdGlvbiBvYmplY3QuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLm5vTGlzdGVuZXI9ZmFsc2VdIElmIHRydWUsIHRoZSBuZXcgY29ubmVjdGlvbiBvYmplY3Qgd29uJ3QgbGlzdGVuIHRvIGFueSBldmVudHMgb24gdGhlIGJhc2UgY29ubmVjdGlvbi4gVGhpcyBpcyBiZXR0ZXIgZm9yIG1lbW9yeSB1c2FnZSBpbiBjYXNlcyB3aGVyZSB5b3UncmUgY2FsbGluZyBgdXNlRGIoKWAgZm9yIGV2ZXJ5IHJlcXVlc3QuXG4gKiBAcmV0dXJuIHtDb25uZWN0aW9ufSBOZXcgQ29ubmVjdGlvbiBPYmplY3RcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuTmF0aXZlQ29ubmVjdGlvbi5wcm90b3R5cGUudXNlRGIgPSBmdW5jdGlvbihuYW1lLCBvcHRpb25zKSB7XG4gIC8vIFJldHVybiBpbW1lZGlhdGVseSBpZiBjYWNoZWRcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIGlmIChvcHRpb25zLnVzZUNhY2hlICYmIHRoaXMucmVsYXRlZERic1tuYW1lXSkge1xuICAgIHJldHVybiB0aGlzLnJlbGF0ZWREYnNbbmFtZV07XG4gIH1cblxuICAvLyB3ZSBoYXZlIHRvIG1hbnVhbGx5IGNvcHkgYWxsIG9mIHRoZSBhdHRyaWJ1dGVzLi4uXG4gIGNvbnN0IG5ld0Nvbm4gPSBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpO1xuICBuZXdDb25uLm5hbWUgPSBuYW1lO1xuICBuZXdDb25uLmJhc2UgPSB0aGlzLmJhc2U7XG4gIG5ld0Nvbm4uY29sbGVjdGlvbnMgPSB7fTtcbiAgbmV3Q29ubi5tb2RlbHMgPSB7fTtcbiAgbmV3Q29ubi5yZXBsaWNhID0gdGhpcy5yZXBsaWNhO1xuICBuZXdDb25uLmNvbmZpZyA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMuY29uZmlnLCBuZXdDb25uLmNvbmZpZyk7XG4gIG5ld0Nvbm4ubmFtZSA9IHRoaXMubmFtZTtcbiAgbmV3Q29ubi5vcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICBuZXdDb25uLl9yZWFkeVN0YXRlID0gdGhpcy5fcmVhZHlTdGF0ZTtcbiAgbmV3Q29ubi5fY2xvc2VDYWxsZWQgPSB0aGlzLl9jbG9zZUNhbGxlZDtcbiAgbmV3Q29ubi5faGFzT3BlbmVkID0gdGhpcy5faGFzT3BlbmVkO1xuICBuZXdDb25uLl9saXN0ZW5pbmcgPSBmYWxzZTtcbiAgbmV3Q29ubi5fcGFyZW50ID0gdGhpcztcblxuICBuZXdDb25uLmhvc3QgPSB0aGlzLmhvc3Q7XG4gIG5ld0Nvbm4ucG9ydCA9IHRoaXMucG9ydDtcbiAgbmV3Q29ubi51c2VyID0gdGhpcy51c2VyO1xuICBuZXdDb25uLnBhc3MgPSB0aGlzLnBhc3M7XG5cbiAgLy8gRmlyc3QsIHdoZW4gd2UgY3JlYXRlIGFub3RoZXIgZGIgb2JqZWN0LCB3ZSBhcmUgbm90IGd1YXJhbnRlZWQgdG8gaGF2ZSBhXG4gIC8vIGRiIG9iamVjdCB0byB3b3JrIHdpdGguIFNvLCBpbiB0aGUgY2FzZSB3aGVyZSB3ZSBoYXZlIGEgZGIgb2JqZWN0IGFuZCBpdFxuICAvLyBpcyBjb25uZWN0ZWQsIHdlIGNhbiBqdXN0IHByb2NlZWQgd2l0aCBzZXR0aW5nIGV2ZXJ5dGhpbmcgdXAuIEhvd2V2ZXIsIGlmXG4gIC8vIHdlIGRvIG5vdCBoYXZlIGEgZGIgb3IgdGhlIHN0YXRlIGlzIG5vdCBjb25uZWN0ZWQsIHRoZW4gd2UgbmVlZCB0byB3YWl0IG9uXG4gIC8vIHRoZSAnb3BlbicgZXZlbnQgb2YgdGhlIGNvbm5lY3Rpb24gYmVmb3JlIGRvaW5nIHRoZSByZXN0IG9mIHRoZSBzZXR1cFxuICAvLyB0aGUgJ2Nvbm5lY3RlZCcgZXZlbnQgaXMgdGhlIGZpcnN0IHRpbWUgd2UnbGwgaGF2ZSBhY2Nlc3MgdG8gdGhlIGRiIG9iamVjdFxuXG4gIGNvbnN0IF90aGlzID0gdGhpcztcblxuICBuZXdDb25uLmNsaWVudCA9IF90aGlzLmNsaWVudDtcblxuICBpZiAodGhpcy5kYiAmJiB0aGlzLl9yZWFkeVN0YXRlID09PSBTVEFURVMuY29ubmVjdGVkKSB7XG4gICAgd2lyZXVwKCk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5vbmNlKCdjb25uZWN0ZWQnLCB3aXJldXApO1xuICB9XG5cbiAgZnVuY3Rpb24gd2lyZXVwKCkge1xuICAgIG5ld0Nvbm4uY2xpZW50ID0gX3RoaXMuY2xpZW50O1xuICAgIGNvbnN0IF9vcHRzID0ge307XG4gICAgaWYgKG9wdGlvbnMuaGFzT3duUHJvcGVydHkoJ25vTGlzdGVuZXInKSkge1xuICAgICAgX29wdHMubm9MaXN0ZW5lciA9IG9wdGlvbnMubm9MaXN0ZW5lcjtcbiAgICB9XG4gICAgbmV3Q29ubi5kYiA9IF90aGlzLmNsaWVudC5kYihuYW1lLCBfb3B0cyk7XG4gICAgbmV3Q29ubi5vbk9wZW4oKTtcbiAgfVxuXG4gIG5ld0Nvbm4ubmFtZSA9IG5hbWU7XG5cbiAgLy8gcHVzaCBvbnRvIHRoZSBvdGhlckRicyBzdGFjaywgdGhpcyBpcyB1c2VkIHdoZW4gc3RhdGUgY2hhbmdlc1xuICBpZiAob3B0aW9ucy5ub0xpc3RlbmVyICE9PSB0cnVlKSB7XG4gICAgdGhpcy5vdGhlckRicy5wdXNoKG5ld0Nvbm4pO1xuICB9XG4gIG5ld0Nvbm4ub3RoZXJEYnMucHVzaCh0aGlzKTtcblxuICAvLyBwdXNoIG9udG8gdGhlIHJlbGF0ZWREYnMgY2FjaGUsIHRoaXMgaXMgdXNlZCB3aGVuIHN0YXRlIGNoYW5nZXNcbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy51c2VDYWNoZSkge1xuICAgIHRoaXMucmVsYXRlZERic1tuZXdDb25uLm5hbWVdID0gbmV3Q29ubjtcbiAgICBuZXdDb25uLnJlbGF0ZWREYnMgPSB0aGlzLnJlbGF0ZWREYnM7XG4gIH1cblxuICByZXR1cm4gbmV3Q29ubjtcbn07XG5cbi8qKlxuICogUmVtb3ZlcyB0aGUgZGF0YWJhc2UgY29ubmVjdGlvbiB3aXRoIHRoZSBnaXZlbiBuYW1lIGNyZWF0ZWQgd2l0aCBgdXNlRGIoKWAuXG4gKlxuICogVGhyb3dzIGFuIGVycm9yIGlmIHRoZSBkYXRhYmFzZSBjb25uZWN0aW9uIHdhcyBub3QgZm91bmQuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICAvLyBDb25uZWN0IHRvIGBpbml0aWFsZGJgIGZpcnN0XG4gKiAgICAgY29uc3QgY29ubiA9IGF3YWl0IG1vbmdvb3NlLmNyZWF0ZUNvbm5lY3Rpb24oJ21vbmdvZGI6Ly8xMjcuMC4wLjE6MjcwMTcvaW5pdGlhbGRiJykuYXNQcm9taXNlKCk7XG4gKlxuICogICAgIC8vIENyZWF0ZXMgYW4gdW4tY2FjaGVkIGNvbm5lY3Rpb24gdG8gYG15ZGJgXG4gKiAgICAgY29uc3QgZGIgPSBjb25uLnVzZURiKCdteWRiJyk7XG4gKlxuICogICAgIC8vIENsb3NlcyBgZGJgLCBhbmQgcmVtb3ZlcyBgZGJgIGZyb20gYGNvbm4ucmVsYXRlZERic2AgYW5kIGBjb25uLm90aGVyRGJzYFxuICogICAgIGF3YWl0IGNvbm4ucmVtb3ZlRGIoJ215ZGInKTtcbiAqXG4gKiBAbWV0aG9kIHJlbW92ZURiXG4gKiBAbWVtYmVyT2YgQ29ubmVjdGlvblxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgVGhlIGRhdGFiYXNlIG5hbWVcbiAqIEByZXR1cm4ge0Nvbm5lY3Rpb259IHRoaXNcbiAqL1xuXG5OYXRpdmVDb25uZWN0aW9uLnByb3RvdHlwZS5yZW1vdmVEYiA9IGZ1bmN0aW9uIHJlbW92ZURiKG5hbWUpIHtcbiAgY29uc3QgZGJzID0gdGhpcy5vdGhlckRicy5maWx0ZXIoZGIgPT4gZGIubmFtZSA9PT0gbmFtZSk7XG4gIGlmICghZGJzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBNb25nb29zZUVycm9yKGBObyBjb25uZWN0aW9ucyB0byBkYXRhYmFzZSBcIiR7bmFtZX1cIiBmb3VuZGApO1xuICB9XG5cbiAgZm9yIChjb25zdCBkYiBvZiBkYnMpIHtcbiAgICBkYi5fY2xvc2VDYWxsZWQgPSB0cnVlO1xuICAgIGRiLl9kZXN0cm95Q2FsbGVkID0gdHJ1ZTtcbiAgICBkYi5fcmVhZHlTdGF0ZSA9IFNUQVRFUy5kaXNjb25uZWN0ZWQ7XG4gICAgZGIuJHdhc0ZvcmNlQ2xvc2VkID0gdHJ1ZTtcbiAgfVxuICBkZWxldGUgdGhpcy5yZWxhdGVkRGJzW25hbWVdO1xuICB0aGlzLm90aGVyRGJzID0gdGhpcy5vdGhlckRicy5maWx0ZXIoZGIgPT4gZGIubmFtZSAhPT0gbmFtZSk7XG59O1xuXG4vKipcbiAqIENsb3NlcyB0aGUgY29ubmVjdGlvblxuICpcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW2ZvcmNlXVxuICogQHJldHVybiB7Q29ubmVjdGlvbn0gdGhpc1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuTmF0aXZlQ29ubmVjdGlvbi5wcm90b3R5cGUuZG9DbG9zZSA9IGFzeW5jIGZ1bmN0aW9uIGRvQ2xvc2UoZm9yY2UpIHtcbiAgaWYgKHRoaXMuY2xpZW50ID09IG51bGwpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGxldCBza2lwQ2xvc2VDbGllbnQgPSBmYWxzZTtcbiAgaWYgKGZvcmNlICE9IG51bGwgJiYgdHlwZW9mIGZvcmNlID09PSAnb2JqZWN0Jykge1xuICAgIHNraXBDbG9zZUNsaWVudCA9IGZvcmNlLnNraXBDbG9zZUNsaWVudDtcbiAgICBmb3JjZSA9IGZvcmNlLmZvcmNlO1xuICB9XG5cbiAgaWYgKHNraXBDbG9zZUNsaWVudCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgYXdhaXQgdGhpcy5jbGllbnQuY2xvc2UoZm9yY2UpO1xuICAvLyBEZWZlciBiZWNhdXNlIHRoZSBkcml2ZXIgd2lsbCB3YWl0IGF0IGxlYXN0IDFtcyBiZWZvcmUgZmluaXNoaW5nIGNsb3NpbmdcbiAgLy8gdGhlIHBvb2wsIHNlZSBodHRwczovL2dpdGh1Yi5jb20vbW9uZ29kYi1qcy9tb25nb2RiLWNvcmUvYmxvYi9hOGY4ZTRjZTQxOTM2YmFiYzNiOTExMmJmNDJkNjA5Nzc5ZjAzYjM5L2xpYi9jb25uZWN0aW9uL3Bvb2wuanMjTDEwMjYtTDEwMzAuXG4gIC8vIElmIHRoZXJlJ3MgcXVldWVkIG9wZXJhdGlvbnMsIHlvdSBtYXkgc3RpbGwgZ2V0IHNvbWUgYmFja2dyb3VuZCB3b3JrXG4gIC8vIGFmdGVyIHRoZSBjYWxsYmFjayBpcyBjYWxsZWQuXG4gIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCAxKSk7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cbk5hdGl2ZUNvbm5lY3Rpb24ucHJvdG90eXBlLmNyZWF0ZUNsaWVudCA9IGFzeW5jIGZ1bmN0aW9uIGNyZWF0ZUNsaWVudCh1cmksIG9wdGlvbnMpIHtcbiAgaWYgKHR5cGVvZiB1cmkgIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IE1vbmdvb3NlRXJyb3IoJ1RoZSBgdXJpYCBwYXJhbWV0ZXIgdG8gYG9wZW5VcmkoKWAgbXVzdCBiZSBhICcgK1xuICAgICAgYHN0cmluZywgZ290IFwiJHt0eXBlb2YgdXJpfVwiLiBNYWtlIHN1cmUgdGhlIGZpcnN0IHBhcmFtZXRlciB0byBgICtcbiAgICAgICdgbW9uZ29vc2UuY29ubmVjdCgpYCBvciBgbW9uZ29vc2UuY3JlYXRlQ29ubmVjdGlvbigpYCBpcyBhIHN0cmluZy4nKTtcbiAgfVxuXG4gIGlmICh0aGlzLl9kZXN0cm95Q2FsbGVkKSB7XG4gICAgdGhyb3cgbmV3IE1vbmdvb3NlRXJyb3IoXG4gICAgICAnQ29ubmVjdGlvbiBoYXMgYmVlbiBjbG9zZWQgYW5kIGRlc3Ryb3llZCwgYW5kIGNhbm5vdCBiZSB1c2VkIGZvciByZS1vcGVuaW5nIHRoZSBjb25uZWN0aW9uLiAnICtcbiAgICAgICdQbGVhc2UgY3JlYXRlIGEgbmV3IGNvbm5lY3Rpb24gd2l0aCBgbW9uZ29vc2UuY3JlYXRlQ29ubmVjdGlvbigpYCBvciBgbW9uZ29vc2UuY29ubmVjdCgpYC4nXG4gICAgKTtcbiAgfVxuXG4gIGlmICh0aGlzLnJlYWR5U3RhdGUgPT09IFNUQVRFUy5jb25uZWN0aW5nIHx8IHRoaXMucmVhZHlTdGF0ZSA9PT0gU1RBVEVTLmNvbm5lY3RlZCkge1xuICAgIGlmICh0aGlzLl9jb25uZWN0aW9uU3RyaW5nICE9PSB1cmkpIHtcbiAgICAgIHRocm93IG5ldyBNb25nb29zZUVycm9yKCdDYW5cXCd0IGNhbGwgYG9wZW5VcmkoKWAgb24gYW4gYWN0aXZlIGNvbm5lY3Rpb24gd2l0aCAnICtcbiAgICAgICAgJ2RpZmZlcmVudCBjb25uZWN0aW9uIHN0cmluZ3MuIE1ha2Ugc3VyZSB5b3UgYXJlblxcJ3QgY2FsbGluZyBgbW9uZ29vc2UuY29ubmVjdCgpYCAnICtcbiAgICAgICAgJ211bHRpcGxlIHRpbWVzLiBTZWU6IGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9jb25uZWN0aW9ucy5odG1sI211bHRpcGxlX2Nvbm5lY3Rpb25zJyk7XG4gICAgfVxuICB9XG5cbiAgb3B0aW9ucyA9IHByb2Nlc3NDb25uZWN0aW9uT3B0aW9ucyh1cmksIG9wdGlvbnMpO1xuXG4gIGlmIChvcHRpb25zKSB7XG5cbiAgICBjb25zdCBhdXRvSW5kZXggPSBvcHRpb25zLmNvbmZpZyAmJiBvcHRpb25zLmNvbmZpZy5hdXRvSW5kZXggIT0gbnVsbCA/XG4gICAgICBvcHRpb25zLmNvbmZpZy5hdXRvSW5kZXggOlxuICAgICAgb3B0aW9ucy5hdXRvSW5kZXg7XG4gICAgaWYgKGF1dG9JbmRleCAhPSBudWxsKSB7XG4gICAgICB0aGlzLmNvbmZpZy5hdXRvSW5kZXggPSBhdXRvSW5kZXggIT09IGZhbHNlO1xuICAgICAgZGVsZXRlIG9wdGlvbnMuY29uZmlnO1xuICAgICAgZGVsZXRlIG9wdGlvbnMuYXV0b0luZGV4O1xuICAgIH1cblxuICAgIGlmICgnYXV0b0NyZWF0ZScgaW4gb3B0aW9ucykge1xuICAgICAgdGhpcy5jb25maWcuYXV0b0NyZWF0ZSA9ICEhb3B0aW9ucy5hdXRvQ3JlYXRlO1xuICAgICAgZGVsZXRlIG9wdGlvbnMuYXV0b0NyZWF0ZTtcbiAgICB9XG5cbiAgICBpZiAoJ3Nhbml0aXplRmlsdGVyJyBpbiBvcHRpb25zKSB7XG4gICAgICB0aGlzLmNvbmZpZy5zYW5pdGl6ZUZpbHRlciA9IG9wdGlvbnMuc2FuaXRpemVGaWx0ZXI7XG4gICAgICBkZWxldGUgb3B0aW9ucy5zYW5pdGl6ZUZpbHRlcjtcbiAgICB9XG5cbiAgICBpZiAoJ2F1dG9TZWFyY2hJbmRleCcgaW4gb3B0aW9ucykge1xuICAgICAgdGhpcy5jb25maWcuYXV0b1NlYXJjaEluZGV4ID0gb3B0aW9ucy5hdXRvU2VhcmNoSW5kZXg7XG4gICAgICBkZWxldGUgb3B0aW9ucy5hdXRvU2VhcmNoSW5kZXg7XG4gICAgfVxuXG4gICAgLy8gQmFja3dhcmRzIGNvbXBhdFxuICAgIGlmIChvcHRpb25zLnVzZXIgfHwgb3B0aW9ucy5wYXNzKSB7XG4gICAgICBvcHRpb25zLmF1dGggPSBvcHRpb25zLmF1dGggfHwge307XG4gICAgICBvcHRpb25zLmF1dGgudXNlcm5hbWUgPSBvcHRpb25zLnVzZXI7XG4gICAgICBvcHRpb25zLmF1dGgucGFzc3dvcmQgPSBvcHRpb25zLnBhc3M7XG5cbiAgICAgIHRoaXMudXNlciA9IG9wdGlvbnMudXNlcjtcbiAgICAgIHRoaXMucGFzcyA9IG9wdGlvbnMucGFzcztcbiAgICB9XG4gICAgZGVsZXRlIG9wdGlvbnMudXNlcjtcbiAgICBkZWxldGUgb3B0aW9ucy5wYXNzO1xuXG4gICAgaWYgKG9wdGlvbnMuYnVmZmVyQ29tbWFuZHMgIT0gbnVsbCkge1xuICAgICAgdGhpcy5jb25maWcuYnVmZmVyQ29tbWFuZHMgPSBvcHRpb25zLmJ1ZmZlckNvbW1hbmRzO1xuICAgICAgZGVsZXRlIG9wdGlvbnMuYnVmZmVyQ29tbWFuZHM7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuXG4gIHRoaXMuX2Nvbm5lY3Rpb25PcHRpb25zID0gb3B0aW9ucztcbiAgY29uc3QgZGJOYW1lID0gb3B0aW9ucy5kYk5hbWU7XG4gIGlmIChkYk5hbWUgIT0gbnVsbCkge1xuICAgIHRoaXMuJGRiTmFtZSA9IGRiTmFtZTtcbiAgfVxuICBkZWxldGUgb3B0aW9ucy5kYk5hbWU7XG5cbiAgaWYgKCF1dGlscy5oYXNVc2VyRGVmaW5lZFByb3BlcnR5KG9wdGlvbnMsICdkcml2ZXJJbmZvJykpIHtcbiAgICBvcHRpb25zLmRyaXZlckluZm8gPSB7XG4gICAgICBuYW1lOiAnTW9uZ29vc2UnLFxuICAgICAgdmVyc2lvbjogcGtnLnZlcnNpb25cbiAgICB9O1xuICB9XG5cbiAgdGhpcy5yZWFkeVN0YXRlID0gU1RBVEVTLmNvbm5lY3Rpbmc7XG4gIHRoaXMuX2Nvbm5lY3Rpb25TdHJpbmcgPSB1cmk7XG5cbiAgbGV0IGNsaWVudDtcbiAgdHJ5IHtcbiAgICBjbGllbnQgPSBuZXcgbW9uZ29kYi5Nb25nb0NsaWVudCh1cmksIG9wdGlvbnMpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHRoaXMucmVhZHlTdGF0ZSA9IFNUQVRFUy5kaXNjb25uZWN0ZWQ7XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbiAgdGhpcy5jbGllbnQgPSBjbGllbnQ7XG5cbiAgY2xpZW50LnNldE1heExpc3RlbmVycygwKTtcbiAgYXdhaXQgY2xpZW50LmNvbm5lY3QoKTtcblxuICBfc2V0Q2xpZW50KHRoaXMsIGNsaWVudCwgb3B0aW9ucywgZGJOYW1lKTtcblxuICBmb3IgKGNvbnN0IGRiIG9mIHRoaXMub3RoZXJEYnMpIHtcbiAgICBfc2V0Q2xpZW50KGRiLCBjbGllbnQsIHt9LCBkYi5uYW1lKTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxuTmF0aXZlQ29ubmVjdGlvbi5wcm90b3R5cGUuc2V0Q2xpZW50ID0gZnVuY3Rpb24gc2V0Q2xpZW50KGNsaWVudCkge1xuICBpZiAoIShjbGllbnQgaW5zdGFuY2VvZiBtb25nb2RiLk1vbmdvQ2xpZW50KSkge1xuICAgIHRocm93IG5ldyBNb25nb29zZUVycm9yKCdNdXN0IGNhbGwgYHNldENsaWVudCgpYCB3aXRoIGFuIGluc3RhbmNlIG9mIE1vbmdvQ2xpZW50Jyk7XG4gIH1cbiAgaWYgKHRoaXMucmVhZHlTdGF0ZSAhPT0gU1RBVEVTLmRpc2Nvbm5lY3RlZCkge1xuICAgIHRocm93IG5ldyBNb25nb29zZUVycm9yKCdDYW5ub3QgY2FsbCBgc2V0Q2xpZW50KClgIG9uIGEgY29ubmVjdGlvbiB0aGF0IGlzIGFscmVhZHkgY29ubmVjdGVkLicpO1xuICB9XG4gIGlmIChjbGllbnQudG9wb2xvZ3kgPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBNb25nb29zZUVycm9yKCdDYW5ub3QgY2FsbCBgc2V0Q2xpZW50KClgIHdpdGggYSBNb25nb0NsaWVudCB0aGF0IHlvdSBoYXZlIG5vdCBjYWxsZWQgYGNvbm5lY3QoKWAgb24geWV0LicpO1xuICB9XG5cbiAgdGhpcy5fY29ubmVjdGlvblN0cmluZyA9IGNsaWVudC5zLnVybDtcbiAgX3NldENsaWVudCh0aGlzLCBjbGllbnQsIHt9LCBjbGllbnQucy5vcHRpb25zLmRiTmFtZSk7XG5cbiAgZm9yIChjb25zdCBtb2RlbCBvZiBPYmplY3QudmFsdWVzKHRoaXMubW9kZWxzKSkge1xuICAgIC8vIEVycm9ycyBoYW5kbGVkIGludGVybmFsbHksIHNvIHNhZmUgdG8gaWdub3JlIGVycm9yXG4gICAgbW9kZWwuaW5pdCgpLmNhdGNoKGZ1bmN0aW9uICRtb2RlbEluaXROb29wKCkge30pO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cbmZ1bmN0aW9uIF9zZXRDbGllbnQoY29ubiwgY2xpZW50LCBvcHRpb25zLCBkYk5hbWUpIHtcbiAgY29uc3QgZGIgPSBkYk5hbWUgIT0gbnVsbCA/IGNsaWVudC5kYihkYk5hbWUpIDogY2xpZW50LmRiKCk7XG4gIGNvbm4uZGIgPSBkYjtcbiAgY29ubi5jbGllbnQgPSBjbGllbnQ7XG4gIGNvbm4uaG9zdCA9IGNsaWVudCAmJlxuICAgIGNsaWVudC5zICYmXG4gICAgY2xpZW50LnMub3B0aW9ucyAmJlxuICAgIGNsaWVudC5zLm9wdGlvbnMuaG9zdHMgJiZcbiAgICBjbGllbnQucy5vcHRpb25zLmhvc3RzWzBdICYmXG4gICAgY2xpZW50LnMub3B0aW9ucy5ob3N0c1swXS5ob3N0IHx8IHZvaWQgMDtcbiAgY29ubi5wb3J0ID0gY2xpZW50ICYmXG4gICAgY2xpZW50LnMgJiZcbiAgICBjbGllbnQucy5vcHRpb25zICYmXG4gICAgY2xpZW50LnMub3B0aW9ucy5ob3N0cyAmJlxuICAgIGNsaWVudC5zLm9wdGlvbnMuaG9zdHNbMF0gJiZcbiAgICBjbGllbnQucy5vcHRpb25zLmhvc3RzWzBdLnBvcnQgfHwgdm9pZCAwO1xuICBjb25uLm5hbWUgPSBkYk5hbWUgIT0gbnVsbCA/IGRiTmFtZSA6IGRiLmRhdGFiYXNlTmFtZTtcbiAgY29ubi5fY2xvc2VDYWxsZWQgPSBjbGllbnQuX2Nsb3NlQ2FsbGVkO1xuXG4gIGNvbnN0IF9oYW5kbGVSZWNvbm5lY3QgPSAoKSA9PiB7XG4gICAgLy8gSWYgd2UgYXJlbid0IGRpc2Nvbm5lY3RlZCwgd2UgYXNzdW1lIHRoaXMgcmVjb25uZWN0IGlzIGR1ZSB0byBhXG4gICAgLy8gc29ja2V0IHRpbWVvdXQuIElmIHRoZXJlJ3Mgbm8gYWN0aXZpdHkgb24gYSBzb2NrZXQgZm9yXG4gICAgLy8gYHNvY2tldFRpbWVvdXRNU2AsIHRoZSBkcml2ZXIgd2lsbCBhdHRlbXB0IHRvIHJlY29ubmVjdCBhbmQgZW1pdFxuICAgIC8vIHRoaXMgZXZlbnQuXG4gICAgaWYgKGNvbm4ucmVhZHlTdGF0ZSAhPT0gU1RBVEVTLmNvbm5lY3RlZCkge1xuICAgICAgY29ubi5yZWFkeVN0YXRlID0gU1RBVEVTLmNvbm5lY3RlZDtcbiAgICAgIGNvbm4uZW1pdCgncmVjb25uZWN0Jyk7XG4gICAgICBjb25uLmVtaXQoJ3JlY29ubmVjdGVkJyk7XG4gICAgICBjb25uLm9uT3BlbigpO1xuICAgIH1cbiAgfTtcblxuICBjb25zdCB0eXBlID0gY2xpZW50ICYmXG4gIGNsaWVudC50b3BvbG9neSAmJlxuICBjbGllbnQudG9wb2xvZ3kuZGVzY3JpcHRpb24gJiZcbiAgY2xpZW50LnRvcG9sb2d5LmRlc2NyaXB0aW9uLnR5cGUgfHwgJyc7XG5cbiAgaWYgKHR5cGUgPT09ICdTaW5nbGUnKSB7XG4gICAgY2xpZW50Lm9uKCdzZXJ2ZXJEZXNjcmlwdGlvbkNoYW5nZWQnLCBldiA9PiB7XG4gICAgICBjb25zdCBuZXdEZXNjcmlwdGlvbiA9IGV2Lm5ld0Rlc2NyaXB0aW9uO1xuICAgICAgaWYgKG5ld0Rlc2NyaXB0aW9uLnR5cGUgPT09ICdVbmtub3duJykge1xuICAgICAgICBjb25uLnJlYWR5U3RhdGUgPSBTVEFURVMuZGlzY29ubmVjdGVkO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgX2hhbmRsZVJlY29ubmVjdCgpO1xuICAgICAgfVxuICAgIH0pO1xuICB9IGVsc2UgaWYgKHR5cGUuc3RhcnRzV2l0aCgnUmVwbGljYVNldCcpKSB7XG4gICAgY2xpZW50Lm9uKCd0b3BvbG9neURlc2NyaXB0aW9uQ2hhbmdlZCcsIGV2ID0+IHtcbiAgICAgIC8vIEVtaXQgZGlzY29ubmVjdGVkIGlmIHdlJ3ZlIGxvc3QgY29ubmVjdGl2aXR5IHRvIHRoZSBwcmltYXJ5XG4gICAgICBjb25zdCBkZXNjcmlwdGlvbiA9IGV2Lm5ld0Rlc2NyaXB0aW9uO1xuICAgICAgaWYgKGNvbm4ucmVhZHlTdGF0ZSA9PT0gU1RBVEVTLmNvbm5lY3RlZCAmJiBkZXNjcmlwdGlvbi50eXBlICE9PSAnUmVwbGljYVNldFdpdGhQcmltYXJ5Jykge1xuICAgICAgICAvLyBJbXBsaWNpdGx5IGVtaXRzICdkaXNjb25uZWN0ZWQnXG4gICAgICAgIGNvbm4ucmVhZHlTdGF0ZSA9IFNUQVRFUy5kaXNjb25uZWN0ZWQ7XG4gICAgICB9IGVsc2UgaWYgKGNvbm4ucmVhZHlTdGF0ZSA9PT0gU1RBVEVTLmRpc2Nvbm5lY3RlZCAmJiBkZXNjcmlwdGlvbi50eXBlID09PSAnUmVwbGljYVNldFdpdGhQcmltYXJ5Jykge1xuICAgICAgICBfaGFuZGxlUmVjb25uZWN0KCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBjb25uLm9uT3BlbigpO1xuXG4gIGZvciAoY29uc3QgaSBpbiBjb25uLmNvbGxlY3Rpb25zKSB7XG4gICAgaWYgKHV0aWxzLm9iamVjdC5oYXNPd25Qcm9wZXJ0eShjb25uLmNvbGxlY3Rpb25zLCBpKSkge1xuICAgICAgY29ubi5jb2xsZWN0aW9uc1tpXS5vbk9wZW4oKTtcbiAgICB9XG4gIH1cbn1cblxuXG4vKiFcbiAqIE1vZHVsZSBleHBvcnRzLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gTmF0aXZlQ29ubmVjdGlvbjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../server/node_modules/mongoose/lib/drivers/node-mongodb-native/connection.js\n");

/***/ }),

/***/ "../server/node_modules/mongoose/lib/drivers/node-mongodb-native/index.js":
/*!********************************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/drivers/node-mongodb-native/index.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("/*!\n * Module exports.\n */\n\n\n\nexports.Collection = __webpack_require__(/*! ./collection */ \"../server/node_modules/mongoose/lib/drivers/node-mongodb-native/collection.js\");\nexports.Connection = __webpack_require__(/*! ./connection */ \"../server/node_modules/mongoose/lib/drivers/node-mongodb-native/connection.js\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvZHJpdmVycy9ub2RlLW1vbmdvZGItbmF0aXZlL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTs7QUFFYTs7QUFFYiw2SUFBNEM7QUFDNUMsNklBQTRDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2xpZW50Ly4uL3NlcnZlci9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2RyaXZlcnMvbm9kZS1tb25nb2RiLW5hdGl2ZS9pbmRleC5qcz9mMTBhIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogTW9kdWxlIGV4cG9ydHMuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLkNvbGxlY3Rpb24gPSByZXF1aXJlKCcuL2NvbGxlY3Rpb24nKTtcbmV4cG9ydHMuQ29ubmVjdGlvbiA9IHJlcXVpcmUoJy4vY29ubmVjdGlvbicpO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../server/node_modules/mongoose/lib/drivers/node-mongodb-native/index.js\n");

/***/ }),

/***/ "../server/node_modules/mongoose/lib/error/bulkWriteError.js":
/*!*******************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/error/bulkWriteError.js ***!
  \*******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*!\n * Module dependencies.\n */\n\n\n\nconst MongooseError = __webpack_require__(/*! ./ */ \"../server/node_modules/mongoose/lib/error/index.js\");\n\n\n/**\n * If `bulkWrite()` or `insertMany()` has validation errors, but\n * all valid operations succeed, and 'throwOnValidationError' is true,\n * Mongoose will throw this error.\n *\n * @api private\n */\n\nclass MongooseBulkWriteError extends MongooseError {\n  constructor(validationErrors, results, rawResult, operation) {\n    let preview = validationErrors.map(e => e.message).join(', ');\n    if (preview.length > 200) {\n      preview = preview.slice(0, 200) + '...';\n    }\n    super(`${operation} failed with ${validationErrors.length} Mongoose validation errors: ${preview}`);\n\n    this.validationErrors = validationErrors;\n    this.results = results;\n    this.rawResult = rawResult;\n    this.operation = operation;\n  }\n}\n\nObject.defineProperty(MongooseBulkWriteError.prototype, 'name', {\n  value: 'MongooseBulkWriteError'\n});\n\n/*!\n * exports\n */\n\nmodule.exports = MongooseBulkWriteError;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvZXJyb3IvYnVsa1dyaXRlRXJyb3IuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBOztBQUVhOztBQUViLHNCQUFzQixtQkFBTyxDQUFDLDhEQUFJOzs7QUFHbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxXQUFXLGNBQWMseUJBQXlCLDhCQUE4QixRQUFROztBQUVyRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2xpZW50Ly4uL3NlcnZlci9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2Vycm9yL2J1bGtXcml0ZUVycm9yLmpzP2ZhMzkiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuY29uc3QgTW9uZ29vc2VFcnJvciA9IHJlcXVpcmUoJy4vJyk7XG5cblxuLyoqXG4gKiBJZiBgYnVsa1dyaXRlKClgIG9yIGBpbnNlcnRNYW55KClgIGhhcyB2YWxpZGF0aW9uIGVycm9ycywgYnV0XG4gKiBhbGwgdmFsaWQgb3BlcmF0aW9ucyBzdWNjZWVkLCBhbmQgJ3Rocm93T25WYWxpZGF0aW9uRXJyb3InIGlzIHRydWUsXG4gKiBNb25nb29zZSB3aWxsIHRocm93IHRoaXMgZXJyb3IuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuY2xhc3MgTW9uZ29vc2VCdWxrV3JpdGVFcnJvciBleHRlbmRzIE1vbmdvb3NlRXJyb3Ige1xuICBjb25zdHJ1Y3Rvcih2YWxpZGF0aW9uRXJyb3JzLCByZXN1bHRzLCByYXdSZXN1bHQsIG9wZXJhdGlvbikge1xuICAgIGxldCBwcmV2aWV3ID0gdmFsaWRhdGlvbkVycm9ycy5tYXAoZSA9PiBlLm1lc3NhZ2UpLmpvaW4oJywgJyk7XG4gICAgaWYgKHByZXZpZXcubGVuZ3RoID4gMjAwKSB7XG4gICAgICBwcmV2aWV3ID0gcHJldmlldy5zbGljZSgwLCAyMDApICsgJy4uLic7XG4gICAgfVxuICAgIHN1cGVyKGAke29wZXJhdGlvbn0gZmFpbGVkIHdpdGggJHt2YWxpZGF0aW9uRXJyb3JzLmxlbmd0aH0gTW9uZ29vc2UgdmFsaWRhdGlvbiBlcnJvcnM6ICR7cHJldmlld31gKTtcblxuICAgIHRoaXMudmFsaWRhdGlvbkVycm9ycyA9IHZhbGlkYXRpb25FcnJvcnM7XG4gICAgdGhpcy5yZXN1bHRzID0gcmVzdWx0cztcbiAgICB0aGlzLnJhd1Jlc3VsdCA9IHJhd1Jlc3VsdDtcbiAgICB0aGlzLm9wZXJhdGlvbiA9IG9wZXJhdGlvbjtcbiAgfVxufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoTW9uZ29vc2VCdWxrV3JpdGVFcnJvci5wcm90b3R5cGUsICduYW1lJywge1xuICB2YWx1ZTogJ01vbmdvb3NlQnVsa1dyaXRlRXJyb3InXG59KTtcblxuLyohXG4gKiBleHBvcnRzXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBNb25nb29zZUJ1bGtXcml0ZUVycm9yO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../server/node_modules/mongoose/lib/error/bulkWriteError.js\n");

/***/ }),

/***/ "../server/node_modules/mongoose/lib/error/cast.js":
/*!*********************************************************!*\
  !*** ../server/node_modules/mongoose/lib/error/cast.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\n/*!\n * Module dependencies.\n */\n\nconst MongooseError = __webpack_require__(/*! ./mongooseError */ \"../server/node_modules/mongoose/lib/error/mongooseError.js\");\nconst util = __webpack_require__(/*! util */ \"util\");\n\n/**\n * Casting Error constructor.\n *\n * @param {String} type\n * @param {String} value\n * @inherits MongooseError\n * @api private\n */\n\nclass CastError extends MongooseError {\n  constructor(type, value, path, reason, schemaType) {\n    // If no args, assume we'll `init()` later.\n    if (arguments.length > 0) {\n      const valueType = getValueType(value);\n      const messageFormat = getMessageFormat(schemaType);\n      const msg = formatMessage(null, type, value, path, messageFormat, valueType, reason);\n      super(msg);\n      this.init(type, value, path, reason, schemaType);\n    } else {\n      super(formatMessage());\n    }\n  }\n\n  toJSON() {\n    return {\n      stringValue: this.stringValue,\n      valueType: this.valueType,\n      kind: this.kind,\n      value: this.value,\n      path: this.path,\n      reason: this.reason,\n      name: this.name,\n      message: this.message\n    };\n  }\n  /*!\n   * ignore\n   */\n  init(type, value, path, reason, schemaType) {\n    this.stringValue = getStringValue(value);\n    this.messageFormat = getMessageFormat(schemaType);\n    this.kind = type;\n    this.value = value;\n    this.path = path;\n    this.reason = reason;\n    this.valueType = getValueType(value);\n  }\n\n  /**\n   * ignore\n   * @param {Readonly<CastError>} other\n   * @api private\n   */\n  copy(other) {\n    this.messageFormat = other.messageFormat;\n    this.stringValue = other.stringValue;\n    this.kind = other.kind;\n    this.value = other.value;\n    this.path = other.path;\n    this.reason = other.reason;\n    this.message = other.message;\n    this.valueType = other.valueType;\n  }\n\n  /*!\n   * ignore\n   */\n  setModel(model) {\n    this.model = model;\n    this.message = formatMessage(model, this.kind, this.value, this.path,\n      this.messageFormat, this.valueType);\n  }\n}\n\nObject.defineProperty(CastError.prototype, 'name', {\n  value: 'CastError'\n});\n\nfunction getStringValue(value) {\n  let stringValue = util.inspect(value);\n  stringValue = stringValue.replace(/^'|'$/g, '\"');\n  if (!stringValue.startsWith('\"')) {\n    stringValue = '\"' + stringValue + '\"';\n  }\n  return stringValue;\n}\n\nfunction getValueType(value) {\n  if (value == null) {\n    return '' + value;\n  }\n\n  const t = typeof value;\n  if (t !== 'object') {\n    return t;\n  }\n  if (typeof value.constructor !== 'function') {\n    return t;\n  }\n  return value.constructor.name;\n}\n\nfunction getMessageFormat(schemaType) {\n  const messageFormat = schemaType && schemaType._castErrorMessage || null;\n  if (typeof messageFormat === 'string' || typeof messageFormat === 'function') {\n    return messageFormat;\n  }\n}\n\n/*!\n * ignore\n */\n\nfunction formatMessage(model, kind, value, path, messageFormat, valueType, reason) {\n  if (typeof messageFormat === 'string') {\n    const stringValue = getStringValue(value);\n    let ret = messageFormat.\n      replace('{KIND}', kind).\n      replace('{VALUE}', stringValue).\n      replace('{PATH}', path);\n    if (model != null) {\n      ret = ret.replace('{MODEL}', model.modelName);\n    }\n\n    return ret;\n  } else if (typeof messageFormat === 'function') {\n    return messageFormat(value, path, model, kind);\n  } else {\n    const stringValue = getStringValue(value);\n    const valueTypeMsg = valueType ? ' (type ' + valueType + ')' : '';\n    let ret = 'Cast to ' + kind + ' failed for value ' +\n      stringValue + valueTypeMsg + ' at path \"' + path + '\"';\n    if (model != null) {\n      ret += ' for model \"' + model.modelName + '\"';\n    }\n    if (reason != null &&\n        typeof reason.constructor === 'function' &&\n        reason.constructor.name !== 'AssertionError' &&\n        reason.constructor.name !== 'Error') {\n      ret += ' because of \"' + reason.constructor.name + '\"';\n    }\n    return ret;\n  }\n}\n\n/*!\n * exports\n */\n\nmodule.exports = CastError;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvZXJyb3IvY2FzdC5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBO0FBQ0E7O0FBRUEsc0JBQXNCLG1CQUFPLENBQUMsbUZBQWlCO0FBQy9DLGFBQWEsbUJBQU8sQ0FBQyxrQkFBTTs7QUFFM0I7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEscUJBQXFCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixLQUFLO0FBQ3JCLGdCQUFnQixNQUFNO0FBQ3RCLGdCQUFnQixLQUFLO0FBQ3JCO0FBQ0EsMEJBQTBCLE1BQU07QUFDaEM7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2xpZW50Ly4uL3NlcnZlci9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2Vycm9yL2Nhc3QuanM/OTIyZSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbi8qIVxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG5jb25zdCBNb25nb29zZUVycm9yID0gcmVxdWlyZSgnLi9tb25nb29zZUVycm9yJyk7XG5jb25zdCB1dGlsID0gcmVxdWlyZSgndXRpbCcpO1xuXG4vKipcbiAqIENhc3RpbmcgRXJyb3IgY29uc3RydWN0b3IuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZVxuICogQGluaGVyaXRzIE1vbmdvb3NlRXJyb3JcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmNsYXNzIENhc3RFcnJvciBleHRlbmRzIE1vbmdvb3NlRXJyb3Ige1xuICBjb25zdHJ1Y3Rvcih0eXBlLCB2YWx1ZSwgcGF0aCwgcmVhc29uLCBzY2hlbWFUeXBlKSB7XG4gICAgLy8gSWYgbm8gYXJncywgYXNzdW1lIHdlJ2xsIGBpbml0KClgIGxhdGVyLlxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMCkge1xuICAgICAgY29uc3QgdmFsdWVUeXBlID0gZ2V0VmFsdWVUeXBlKHZhbHVlKTtcbiAgICAgIGNvbnN0IG1lc3NhZ2VGb3JtYXQgPSBnZXRNZXNzYWdlRm9ybWF0KHNjaGVtYVR5cGUpO1xuICAgICAgY29uc3QgbXNnID0gZm9ybWF0TWVzc2FnZShudWxsLCB0eXBlLCB2YWx1ZSwgcGF0aCwgbWVzc2FnZUZvcm1hdCwgdmFsdWVUeXBlLCByZWFzb24pO1xuICAgICAgc3VwZXIobXNnKTtcbiAgICAgIHRoaXMuaW5pdCh0eXBlLCB2YWx1ZSwgcGF0aCwgcmVhc29uLCBzY2hlbWFUeXBlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3VwZXIoZm9ybWF0TWVzc2FnZSgpKTtcbiAgICB9XG4gIH1cblxuICB0b0pTT04oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHN0cmluZ1ZhbHVlOiB0aGlzLnN0cmluZ1ZhbHVlLFxuICAgICAgdmFsdWVUeXBlOiB0aGlzLnZhbHVlVHlwZSxcbiAgICAgIGtpbmQ6IHRoaXMua2luZCxcbiAgICAgIHZhbHVlOiB0aGlzLnZhbHVlLFxuICAgICAgcGF0aDogdGhpcy5wYXRoLFxuICAgICAgcmVhc29uOiB0aGlzLnJlYXNvbixcbiAgICAgIG5hbWU6IHRoaXMubmFtZSxcbiAgICAgIG1lc3NhZ2U6IHRoaXMubWVzc2FnZVxuICAgIH07XG4gIH1cbiAgLyohXG4gICAqIGlnbm9yZVxuICAgKi9cbiAgaW5pdCh0eXBlLCB2YWx1ZSwgcGF0aCwgcmVhc29uLCBzY2hlbWFUeXBlKSB7XG4gICAgdGhpcy5zdHJpbmdWYWx1ZSA9IGdldFN0cmluZ1ZhbHVlKHZhbHVlKTtcbiAgICB0aGlzLm1lc3NhZ2VGb3JtYXQgPSBnZXRNZXNzYWdlRm9ybWF0KHNjaGVtYVR5cGUpO1xuICAgIHRoaXMua2luZCA9IHR5cGU7XG4gICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgIHRoaXMucGF0aCA9IHBhdGg7XG4gICAgdGhpcy5yZWFzb24gPSByZWFzb247XG4gICAgdGhpcy52YWx1ZVR5cGUgPSBnZXRWYWx1ZVR5cGUodmFsdWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIGlnbm9yZVxuICAgKiBAcGFyYW0ge1JlYWRvbmx5PENhc3RFcnJvcj59IG90aGVyXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgY29weShvdGhlcikge1xuICAgIHRoaXMubWVzc2FnZUZvcm1hdCA9IG90aGVyLm1lc3NhZ2VGb3JtYXQ7XG4gICAgdGhpcy5zdHJpbmdWYWx1ZSA9IG90aGVyLnN0cmluZ1ZhbHVlO1xuICAgIHRoaXMua2luZCA9IG90aGVyLmtpbmQ7XG4gICAgdGhpcy52YWx1ZSA9IG90aGVyLnZhbHVlO1xuICAgIHRoaXMucGF0aCA9IG90aGVyLnBhdGg7XG4gICAgdGhpcy5yZWFzb24gPSBvdGhlci5yZWFzb247XG4gICAgdGhpcy5tZXNzYWdlID0gb3RoZXIubWVzc2FnZTtcbiAgICB0aGlzLnZhbHVlVHlwZSA9IG90aGVyLnZhbHVlVHlwZTtcbiAgfVxuXG4gIC8qIVxuICAgKiBpZ25vcmVcbiAgICovXG4gIHNldE1vZGVsKG1vZGVsKSB7XG4gICAgdGhpcy5tb2RlbCA9IG1vZGVsO1xuICAgIHRoaXMubWVzc2FnZSA9IGZvcm1hdE1lc3NhZ2UobW9kZWwsIHRoaXMua2luZCwgdGhpcy52YWx1ZSwgdGhpcy5wYXRoLFxuICAgICAgdGhpcy5tZXNzYWdlRm9ybWF0LCB0aGlzLnZhbHVlVHlwZSk7XG4gIH1cbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KENhc3RFcnJvci5wcm90b3R5cGUsICduYW1lJywge1xuICB2YWx1ZTogJ0Nhc3RFcnJvcidcbn0pO1xuXG5mdW5jdGlvbiBnZXRTdHJpbmdWYWx1ZSh2YWx1ZSkge1xuICBsZXQgc3RyaW5nVmFsdWUgPSB1dGlsLmluc3BlY3QodmFsdWUpO1xuICBzdHJpbmdWYWx1ZSA9IHN0cmluZ1ZhbHVlLnJlcGxhY2UoL14nfCckL2csICdcIicpO1xuICBpZiAoIXN0cmluZ1ZhbHVlLnN0YXJ0c1dpdGgoJ1wiJykpIHtcbiAgICBzdHJpbmdWYWx1ZSA9ICdcIicgKyBzdHJpbmdWYWx1ZSArICdcIic7XG4gIH1cbiAgcmV0dXJuIHN0cmluZ1ZhbHVlO1xufVxuXG5mdW5jdGlvbiBnZXRWYWx1ZVR5cGUodmFsdWUpIHtcbiAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICByZXR1cm4gJycgKyB2YWx1ZTtcbiAgfVxuXG4gIGNvbnN0IHQgPSB0eXBlb2YgdmFsdWU7XG4gIGlmICh0ICE9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiB0O1xuICB9XG4gIGlmICh0eXBlb2YgdmFsdWUuY29uc3RydWN0b3IgIT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gdDtcbiAgfVxuICByZXR1cm4gdmFsdWUuY29uc3RydWN0b3IubmFtZTtcbn1cblxuZnVuY3Rpb24gZ2V0TWVzc2FnZUZvcm1hdChzY2hlbWFUeXBlKSB7XG4gIGNvbnN0IG1lc3NhZ2VGb3JtYXQgPSBzY2hlbWFUeXBlICYmIHNjaGVtYVR5cGUuX2Nhc3RFcnJvck1lc3NhZ2UgfHwgbnVsbDtcbiAgaWYgKHR5cGVvZiBtZXNzYWdlRm9ybWF0ID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgbWVzc2FnZUZvcm1hdCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBtZXNzYWdlRm9ybWF0O1xuICB9XG59XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxuZnVuY3Rpb24gZm9ybWF0TWVzc2FnZShtb2RlbCwga2luZCwgdmFsdWUsIHBhdGgsIG1lc3NhZ2VGb3JtYXQsIHZhbHVlVHlwZSwgcmVhc29uKSB7XG4gIGlmICh0eXBlb2YgbWVzc2FnZUZvcm1hdCA9PT0gJ3N0cmluZycpIHtcbiAgICBjb25zdCBzdHJpbmdWYWx1ZSA9IGdldFN0cmluZ1ZhbHVlKHZhbHVlKTtcbiAgICBsZXQgcmV0ID0gbWVzc2FnZUZvcm1hdC5cbiAgICAgIHJlcGxhY2UoJ3tLSU5EfScsIGtpbmQpLlxuICAgICAgcmVwbGFjZSgne1ZBTFVFfScsIHN0cmluZ1ZhbHVlKS5cbiAgICAgIHJlcGxhY2UoJ3tQQVRIfScsIHBhdGgpO1xuICAgIGlmIChtb2RlbCAhPSBudWxsKSB7XG4gICAgICByZXQgPSByZXQucmVwbGFjZSgne01PREVMfScsIG1vZGVsLm1vZGVsTmFtZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJldDtcbiAgfSBlbHNlIGlmICh0eXBlb2YgbWVzc2FnZUZvcm1hdCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBtZXNzYWdlRm9ybWF0KHZhbHVlLCBwYXRoLCBtb2RlbCwga2luZCk7XG4gIH0gZWxzZSB7XG4gICAgY29uc3Qgc3RyaW5nVmFsdWUgPSBnZXRTdHJpbmdWYWx1ZSh2YWx1ZSk7XG4gICAgY29uc3QgdmFsdWVUeXBlTXNnID0gdmFsdWVUeXBlID8gJyAodHlwZSAnICsgdmFsdWVUeXBlICsgJyknIDogJyc7XG4gICAgbGV0IHJldCA9ICdDYXN0IHRvICcgKyBraW5kICsgJyBmYWlsZWQgZm9yIHZhbHVlICcgK1xuICAgICAgc3RyaW5nVmFsdWUgKyB2YWx1ZVR5cGVNc2cgKyAnIGF0IHBhdGggXCInICsgcGF0aCArICdcIic7XG4gICAgaWYgKG1vZGVsICE9IG51bGwpIHtcbiAgICAgIHJldCArPSAnIGZvciBtb2RlbCBcIicgKyBtb2RlbC5tb2RlbE5hbWUgKyAnXCInO1xuICAgIH1cbiAgICBpZiAocmVhc29uICE9IG51bGwgJiZcbiAgICAgICAgdHlwZW9mIHJlYXNvbi5jb25zdHJ1Y3RvciA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgICAgICByZWFzb24uY29uc3RydWN0b3IubmFtZSAhPT0gJ0Fzc2VydGlvbkVycm9yJyAmJlxuICAgICAgICByZWFzb24uY29uc3RydWN0b3IubmFtZSAhPT0gJ0Vycm9yJykge1xuICAgICAgcmV0ICs9ICcgYmVjYXVzZSBvZiBcIicgKyByZWFzb24uY29uc3RydWN0b3IubmFtZSArICdcIic7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG4gIH1cbn1cblxuLyohXG4gKiBleHBvcnRzXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBDYXN0RXJyb3I7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../server/node_modules/mongoose/lib/error/cast.js\n");

/***/ }),

/***/ "../server/node_modules/mongoose/lib/error/createCollectionsError.js":
/*!***************************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/error/createCollectionsError.js ***!
  \***************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst MongooseError = __webpack_require__(/*! ./mongooseError */ \"../server/node_modules/mongoose/lib/error/mongooseError.js\");\n\n/**\n * createCollections Error constructor\n *\n * @param {String} message\n * @param {String} errorsMap\n * @inherits MongooseError\n * @api private\n */\n\nclass CreateCollectionsError extends MongooseError {\n  constructor(message, errorsMap) {\n    super(message);\n    this.errors = errorsMap;\n  }\n}\n\nObject.defineProperty(CreateCollectionsError.prototype, 'name', {\n  value: 'CreateCollectionsError'\n});\n\nmodule.exports = CreateCollectionsError;\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvZXJyb3IvY3JlYXRlQ29sbGVjdGlvbnNFcnJvci5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixzQkFBc0IsbUJBQU8sQ0FBQyxtRkFBaUI7O0FBRS9DO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRCIsInNvdXJjZXMiOlsid2VicGFjazovL2NsaWVudC8uLi9zZXJ2ZXIvbm9kZV9tb2R1bGVzL21vbmdvb3NlL2xpYi9lcnJvci9jcmVhdGVDb2xsZWN0aW9uc0Vycm9yLmpzPzZjNzYiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBNb25nb29zZUVycm9yID0gcmVxdWlyZSgnLi9tb25nb29zZUVycm9yJyk7XG5cbi8qKlxuICogY3JlYXRlQ29sbGVjdGlvbnMgRXJyb3IgY29uc3RydWN0b3JcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICogQHBhcmFtIHtTdHJpbmd9IGVycm9yc01hcFxuICogQGluaGVyaXRzIE1vbmdvb3NlRXJyb3JcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmNsYXNzIENyZWF0ZUNvbGxlY3Rpb25zRXJyb3IgZXh0ZW5kcyBNb25nb29zZUVycm9yIHtcbiAgY29uc3RydWN0b3IobWVzc2FnZSwgZXJyb3JzTWFwKSB7XG4gICAgc3VwZXIobWVzc2FnZSk7XG4gICAgdGhpcy5lcnJvcnMgPSBlcnJvcnNNYXA7XG4gIH1cbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KENyZWF0ZUNvbGxlY3Rpb25zRXJyb3IucHJvdG90eXBlLCAnbmFtZScsIHtcbiAgdmFsdWU6ICdDcmVhdGVDb2xsZWN0aW9uc0Vycm9yJ1xufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gQ3JlYXRlQ29sbGVjdGlvbnNFcnJvcjtcblxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../server/node_modules/mongoose/lib/error/createCollectionsError.js\n");

/***/ }),

/***/ "../server/node_modules/mongoose/lib/error/divergentArray.js":
/*!*******************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/error/divergentArray.js ***!
  \*******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n/*!\n * Module dependencies.\n */\n\n\n\nconst MongooseError = __webpack_require__(/*! ./ */ \"../server/node_modules/mongoose/lib/error/index.js\");\n\nclass DivergentArrayError extends MongooseError {\n  /**\n   * DivergentArrayError constructor.\n   * @param {Array<String>} paths\n   * @api private\n   */\n  constructor(paths) {\n    const msg = 'For your own good, using `document.save()` to update an array '\n            + 'which was selected using an $elemMatch projection OR '\n            + 'populated using skip, limit, query conditions, or exclusion of '\n            + 'the _id field when the operation results in a $pop or $set of '\n            + 'the entire array is not supported. The following '\n            + 'path(s) would have been modified unsafely:\\n'\n            + '  ' + paths.join('\\n  ') + '\\n'\n            + 'Use Model.updateOne() to update these arrays instead.';\n    // TODO write up a docs page (FAQ) and link to it\n    super(msg);\n  }\n}\n\nObject.defineProperty(DivergentArrayError.prototype, 'name', {\n  value: 'DivergentArrayError'\n});\n\n/*!\n * exports\n */\n\nmodule.exports = DivergentArrayError;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvZXJyb3IvZGl2ZXJnZW50QXJyYXkuanMiLCJtYXBwaW5ncyI6IjtBQUNBO0FBQ0E7QUFDQTs7QUFFYTs7QUFFYixzQkFBc0IsbUJBQU8sQ0FBQyw4REFBSTs7QUFFbEM7QUFDQTtBQUNBO0FBQ0EsYUFBYSxlQUFlO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbGllbnQvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvZXJyb3IvZGl2ZXJnZW50QXJyYXkuanM/ZTZjOCJdLCJzb3VyY2VzQ29udGVudCI6WyJcbi8qIVxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbmNvbnN0IE1vbmdvb3NlRXJyb3IgPSByZXF1aXJlKCcuLycpO1xuXG5jbGFzcyBEaXZlcmdlbnRBcnJheUVycm9yIGV4dGVuZHMgTW9uZ29vc2VFcnJvciB7XG4gIC8qKlxuICAgKiBEaXZlcmdlbnRBcnJheUVycm9yIGNvbnN0cnVjdG9yLlxuICAgKiBAcGFyYW0ge0FycmF5PFN0cmluZz59IHBhdGhzXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgY29uc3RydWN0b3IocGF0aHMpIHtcbiAgICBjb25zdCBtc2cgPSAnRm9yIHlvdXIgb3duIGdvb2QsIHVzaW5nIGBkb2N1bWVudC5zYXZlKClgIHRvIHVwZGF0ZSBhbiBhcnJheSAnXG4gICAgICAgICAgICArICd3aGljaCB3YXMgc2VsZWN0ZWQgdXNpbmcgYW4gJGVsZW1NYXRjaCBwcm9qZWN0aW9uIE9SICdcbiAgICAgICAgICAgICsgJ3BvcHVsYXRlZCB1c2luZyBza2lwLCBsaW1pdCwgcXVlcnkgY29uZGl0aW9ucywgb3IgZXhjbHVzaW9uIG9mICdcbiAgICAgICAgICAgICsgJ3RoZSBfaWQgZmllbGQgd2hlbiB0aGUgb3BlcmF0aW9uIHJlc3VsdHMgaW4gYSAkcG9wIG9yICRzZXQgb2YgJ1xuICAgICAgICAgICAgKyAndGhlIGVudGlyZSBhcnJheSBpcyBub3Qgc3VwcG9ydGVkLiBUaGUgZm9sbG93aW5nICdcbiAgICAgICAgICAgICsgJ3BhdGgocykgd291bGQgaGF2ZSBiZWVuIG1vZGlmaWVkIHVuc2FmZWx5OlxcbidcbiAgICAgICAgICAgICsgJyAgJyArIHBhdGhzLmpvaW4oJ1xcbiAgJykgKyAnXFxuJ1xuICAgICAgICAgICAgKyAnVXNlIE1vZGVsLnVwZGF0ZU9uZSgpIHRvIHVwZGF0ZSB0aGVzZSBhcnJheXMgaW5zdGVhZC4nO1xuICAgIC8vIFRPRE8gd3JpdGUgdXAgYSBkb2NzIHBhZ2UgKEZBUSkgYW5kIGxpbmsgdG8gaXRcbiAgICBzdXBlcihtc2cpO1xuICB9XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShEaXZlcmdlbnRBcnJheUVycm9yLnByb3RvdHlwZSwgJ25hbWUnLCB7XG4gIHZhbHVlOiAnRGl2ZXJnZW50QXJyYXlFcnJvcidcbn0pO1xuXG4vKiFcbiAqIGV4cG9ydHNcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IERpdmVyZ2VudEFycmF5RXJyb3I7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../server/node_modules/mongoose/lib/error/divergentArray.js\n");

/***/ }),

/***/ "../server/node_modules/mongoose/lib/error/eachAsyncMultiError.js":
/*!************************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/error/eachAsyncMultiError.js ***!
  \************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*!\n * Module dependencies.\n */\n\n\n\nconst MongooseError = __webpack_require__(/*! ./ */ \"../server/node_modules/mongoose/lib/error/index.js\");\n\n\n/**\n * If `eachAsync()` is called with `continueOnError: true`, there can be\n * multiple errors. This error class contains an `errors` property, which\n * contains an array of all errors that occurred in `eachAsync()`.\n *\n * @api private\n */\n\nclass EachAsyncMultiError extends MongooseError {\n  /**\n   * @param {String} connectionString\n   */\n  constructor(errors) {\n    let preview = errors.map(e => e.message).join(', ');\n    if (preview.length > 50) {\n      preview = preview.slice(0, 50) + '...';\n    }\n    super(`eachAsync() finished with ${errors.length} errors: ${preview}`);\n\n    this.errors = errors;\n  }\n}\n\nObject.defineProperty(EachAsyncMultiError.prototype, 'name', {\n  value: 'EachAsyncMultiError'\n});\n\n/*!\n * exports\n */\n\nmodule.exports = EachAsyncMultiError;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvZXJyb3IvZWFjaEFzeW5jTXVsdGlFcnJvci5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7O0FBRWE7O0FBRWIsc0JBQXNCLG1CQUFPLENBQUMsOERBQUk7OztBQUdsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxlQUFlLFVBQVUsUUFBUTs7QUFFeEU7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL2NsaWVudC8uLi9zZXJ2ZXIvbm9kZV9tb2R1bGVzL21vbmdvb3NlL2xpYi9lcnJvci9lYWNoQXN5bmNNdWx0aUVycm9yLmpzPzNjMDIiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuY29uc3QgTW9uZ29vc2VFcnJvciA9IHJlcXVpcmUoJy4vJyk7XG5cblxuLyoqXG4gKiBJZiBgZWFjaEFzeW5jKClgIGlzIGNhbGxlZCB3aXRoIGBjb250aW51ZU9uRXJyb3I6IHRydWVgLCB0aGVyZSBjYW4gYmVcbiAqIG11bHRpcGxlIGVycm9ycy4gVGhpcyBlcnJvciBjbGFzcyBjb250YWlucyBhbiBgZXJyb3JzYCBwcm9wZXJ0eSwgd2hpY2hcbiAqIGNvbnRhaW5zIGFuIGFycmF5IG9mIGFsbCBlcnJvcnMgdGhhdCBvY2N1cnJlZCBpbiBgZWFjaEFzeW5jKClgLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmNsYXNzIEVhY2hBc3luY011bHRpRXJyb3IgZXh0ZW5kcyBNb25nb29zZUVycm9yIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBjb25uZWN0aW9uU3RyaW5nXG4gICAqL1xuICBjb25zdHJ1Y3RvcihlcnJvcnMpIHtcbiAgICBsZXQgcHJldmlldyA9IGVycm9ycy5tYXAoZSA9PiBlLm1lc3NhZ2UpLmpvaW4oJywgJyk7XG4gICAgaWYgKHByZXZpZXcubGVuZ3RoID4gNTApIHtcbiAgICAgIHByZXZpZXcgPSBwcmV2aWV3LnNsaWNlKDAsIDUwKSArICcuLi4nO1xuICAgIH1cbiAgICBzdXBlcihgZWFjaEFzeW5jKCkgZmluaXNoZWQgd2l0aCAke2Vycm9ycy5sZW5ndGh9IGVycm9yczogJHtwcmV2aWV3fWApO1xuXG4gICAgdGhpcy5lcnJvcnMgPSBlcnJvcnM7XG4gIH1cbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KEVhY2hBc3luY011bHRpRXJyb3IucHJvdG90eXBlLCAnbmFtZScsIHtcbiAgdmFsdWU6ICdFYWNoQXN5bmNNdWx0aUVycm9yJ1xufSk7XG5cbi8qIVxuICogZXhwb3J0c1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0gRWFjaEFzeW5jTXVsdGlFcnJvcjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../server/node_modules/mongoose/lib/error/eachAsyncMultiError.js\n");

/***/ }),

/***/ "../server/node_modules/mongoose/lib/error/index.js":
/*!**********************************************************!*\
  !*** ../server/node_modules/mongoose/lib/error/index.js ***!
  \**********************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("\n\n/**\n * MongooseError constructor. MongooseError is the base class for all\n * Mongoose-specific errors.\n *\n * #### Example:\n *\n *     const Model = mongoose.model('Test', new mongoose.Schema({ answer: Number }));\n *     const doc = new Model({ answer: 'not a number' });\n *     const err = doc.validateSync();\n *\n *     err instanceof mongoose.Error.ValidationError; // true\n *\n * @constructor Error\n * @param {String} msg Error message\n * @inherits Error https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error\n */\n\nconst MongooseError = __webpack_require__(/*! ./mongooseError */ \"../server/node_modules/mongoose/lib/error/mongooseError.js\");\n\n/**\n * The name of the error. The name uniquely identifies this Mongoose error. The\n * possible values are:\n *\n * - `MongooseError`: general Mongoose error\n * - `CastError`: Mongoose could not convert a value to the type defined in the schema path. May be in a `ValidationError` class' `errors` property.\n * - `DivergentArrayError`: You attempted to `save()` an array that was modified after you loaded it with a `$elemMatch` or similar projection\n * - `MissingSchemaError`: You tried to access a model with [`mongoose.model()`](https://mongoosejs.com/docs/api/mongoose.html#Mongoose.model()) that was not defined\n * - `DocumentNotFoundError`: The document you tried to [`save()`](https://mongoosejs.com/docs/api/document.html#Document.prototype.save()) was not found\n * - `ValidatorError`: error from an individual schema path's validator\n * - `ValidationError`: error returned from [`validate()`](https://mongoosejs.com/docs/api/document.html#Document.prototype.validate()) or [`validateSync()`](https://mongoosejs.com/docs/api/document.html#Document.prototype.validateSync()). Contains zero or more `ValidatorError` instances in `.errors` property.\n * - `MissingSchemaError`: You called `mongoose.Document()` without a schema\n * - `ObjectExpectedError`: Thrown when you set a nested path to a non-object value with [strict mode set](https://mongoosejs.com/docs/guide.html#strict).\n * - `ObjectParameterError`: Thrown when you pass a non-object value to a function which expects an object as a paramter\n * - `OverwriteModelError`: Thrown when you call [`mongoose.model()`](https://mongoosejs.com/docs/api/mongoose.html#Mongoose.model()) to re-define a model that was already defined.\n * - `ParallelSaveError`: Thrown when you call [`save()`](https://mongoosejs.com/docs/api/model.html#Model.prototype.save()) on a document when the same document instance is already saving.\n * - `StrictModeError`: Thrown when you set a path that isn't the schema and [strict mode](https://mongoosejs.com/docs/guide.html#strict) is set to `throw`.\n * - `VersionError`: Thrown when the [document is out of sync](https://mongoosejs.com/docs/guide.html#versionKey)\n *\n * @api public\n * @property {String} name\n * @memberOf Error\n * @instance\n */\n\n/*!\n * Module exports.\n */\n\nmodule.exports = exports = MongooseError;\n\n/**\n * The default built-in validator error messages.\n *\n * @see Error.messages https://mongoosejs.com/docs/api/error.html#Error.messages\n * @api public\n * @memberOf Error\n * @static\n */\n\nMongooseError.messages = __webpack_require__(/*! ./messages */ \"../server/node_modules/mongoose/lib/error/messages.js\");\n\n// backward compat\nMongooseError.Messages = MongooseError.messages;\n\n/**\n * An instance of this error class will be returned when `save()` fails\n * because the underlying\n * document was not found. The constructor takes one parameter, the\n * conditions that mongoose passed to `updateOne()` when trying to update\n * the document.\n *\n * @api public\n * @memberOf Error\n * @static\n */\n\nMongooseError.DocumentNotFoundError = __webpack_require__(/*! ./notFound */ \"../server/node_modules/mongoose/lib/error/notFound.js\");\n\n/**\n * An instance of this error class will be returned when mongoose failed to\n * cast a value.\n *\n * @api public\n * @memberOf Error\n * @static\n */\n\nMongooseError.CastError = __webpack_require__(/*! ./cast */ \"../server/node_modules/mongoose/lib/error/cast.js\");\n\n/**\n * An instance of this error class will be returned when [validation](https://mongoosejs.com/docs/validation.html) failed.\n * The `errors` property contains an object whose keys are the paths that failed and whose values are\n * instances of CastError or ValidationError.\n *\n * @api public\n * @memberOf Error\n * @static\n */\n\nMongooseError.ValidationError = __webpack_require__(/*! ./validation */ \"../server/node_modules/mongoose/lib/error/validation.js\");\n\n/**\n * A `ValidationError` has a hash of `errors` that contain individual\n * `ValidatorError` instances.\n *\n * #### Example:\n *\n *     const schema = Schema({ name: { type: String, required: true } });\n *     const Model = mongoose.model('Test', schema);\n *     const doc = new Model({});\n *\n *     // Top-level error is a ValidationError, **not** a ValidatorError\n *     const err = doc.validateSync();\n *     err instanceof mongoose.Error.ValidationError; // true\n *\n *     // A ValidationError `err` has 0 or more ValidatorErrors keyed by the\n *     // path in the `err.errors` property.\n *     err.errors['name'] instanceof mongoose.Error.ValidatorError;\n *\n *     err.errors['name'].kind; // 'required'\n *     err.errors['name'].path; // 'name'\n *     err.errors['name'].value; // undefined\n *\n * Instances of `ValidatorError` have the following properties:\n *\n * - `kind`: The validator's `type`, like `'required'` or `'regexp'`\n * - `path`: The path that failed validation\n * - `value`: The value that failed validation\n *\n * @api public\n * @memberOf Error\n * @static\n */\n\nMongooseError.ValidatorError = __webpack_require__(/*! ./validator */ \"../server/node_modules/mongoose/lib/error/validator.js\");\n\n/**\n * An instance of this error class will be returned when you call `save()` after\n * the document in the database was changed in a potentially unsafe way. See\n * the [`versionKey` option](https://mongoosejs.com/docs/guide.html#versionKey) for more information.\n *\n * @api public\n * @memberOf Error\n * @static\n */\n\nMongooseError.VersionError = __webpack_require__(/*! ./version */ \"../server/node_modules/mongoose/lib/error/version.js\");\n\n/**\n * An instance of this error class will be returned when you call `save()` multiple\n * times on the same document in parallel. See the [FAQ](https://mongoosejs.com/docs/faq.html) for more\n * information.\n *\n * @api public\n * @memberOf Error\n * @static\n */\n\nMongooseError.ParallelSaveError = __webpack_require__(/*! ./parallelSave */ \"../server/node_modules/mongoose/lib/error/parallelSave.js\");\n\n/**\n * Thrown when a model with the given name was already registered on the connection.\n * See [the FAQ about `OverwriteModelError`](https://mongoosejs.com/docs/faq.html#overwrite-model-error).\n *\n * @api public\n * @memberOf Error\n * @static\n */\n\nMongooseError.OverwriteModelError = __webpack_require__(/*! ./overwriteModel */ \"../server/node_modules/mongoose/lib/error/overwriteModel.js\");\n\n/**\n * Thrown when you try to access a model that has not been registered yet\n *\n * @api public\n * @memberOf Error\n * @static\n */\n\nMongooseError.MissingSchemaError = __webpack_require__(/*! ./missingSchema */ \"../server/node_modules/mongoose/lib/error/missingSchema.js\");\n\n/**\n * Thrown when the MongoDB Node driver can't connect to a valid server\n * to send an operation to.\n *\n * @api public\n * @memberOf Error\n * @static\n */\n\nMongooseError.MongooseServerSelectionError = __webpack_require__(/*! ./serverSelection */ \"../server/node_modules/mongoose/lib/error/serverSelection.js\");\n\n/**\n * An instance of this error will be returned if you used an array projection\n * and then modified the array in an unsafe way.\n *\n * @api public\n * @memberOf Error\n * @static\n */\n\nMongooseError.DivergentArrayError = __webpack_require__(/*! ./divergentArray */ \"../server/node_modules/mongoose/lib/error/divergentArray.js\");\n\n/**\n * Thrown when your try to pass values to model constructor that\n * were not specified in schema or change immutable properties when\n * `strict` mode is `\"throw\"`\n *\n * @api public\n * @memberOf Error\n * @static\n */\n\nMongooseError.StrictModeError = __webpack_require__(/*! ./strict */ \"../server/node_modules/mongoose/lib/error/strict.js\");\n\n/**\n * An instance of this error class will be returned when mongoose failed to\n * populate with a path that is not existing.\n *\n * @api public\n * @memberOf Error\n * @static\n */\n\nMongooseError.StrictPopulateError = __webpack_require__(/*! ./strictPopulate */ \"../server/node_modules/mongoose/lib/error/strictPopulate.js\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvZXJyb3IvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFLGdCQUFnQjtBQUNsRiwrQkFBK0Isd0JBQXdCO0FBQ3ZEO0FBQ0E7QUFDQSxzREFBc0Q7QUFDdEQ7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBOztBQUVBLHNCQUFzQixtQkFBTyxDQUFDLG1GQUFpQjs7QUFFL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEseUJBQXlCLG1CQUFPLENBQUMseUVBQVk7O0FBRTdDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxzQ0FBc0MsbUJBQU8sQ0FBQyx5RUFBWTs7QUFFMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwwQkFBMEIsbUJBQU8sQ0FBQyxpRUFBUTs7QUFFMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdDQUFnQyxtQkFBTyxDQUFDLDZFQUFjOztBQUV0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsUUFBUSxnQ0FBZ0M7QUFDdkU7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0Esc0RBQXNEO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEMsZ0NBQWdDO0FBQ2hDLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLCtCQUErQixtQkFBTyxDQUFDLDJFQUFhOztBQUVwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNkJBQTZCLG1CQUFPLENBQUMsdUVBQVc7O0FBRWhEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQ0FBa0MsbUJBQU8sQ0FBQyxpRkFBZ0I7O0FBRTFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0NBQW9DLG1CQUFPLENBQUMscUZBQWtCOztBQUU5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQ0FBbUMsbUJBQU8sQ0FBQyxtRkFBaUI7O0FBRTVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNkNBQTZDLG1CQUFPLENBQUMsdUZBQW1COztBQUV4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9DQUFvQyxtQkFBTyxDQUFDLHFGQUFrQjs7QUFFOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdDQUFnQyxtQkFBTyxDQUFDLHFFQUFVOztBQUVsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9DQUFvQyxtQkFBTyxDQUFDLHFGQUFrQiIsInNvdXJjZXMiOlsid2VicGFjazovL2NsaWVudC8uLi9zZXJ2ZXIvbm9kZV9tb2R1bGVzL21vbmdvb3NlL2xpYi9lcnJvci9pbmRleC5qcz84OGNhIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBNb25nb29zZUVycm9yIGNvbnN0cnVjdG9yLiBNb25nb29zZUVycm9yIGlzIHRoZSBiYXNlIGNsYXNzIGZvciBhbGxcbiAqIE1vbmdvb3NlLXNwZWNpZmljIGVycm9ycy5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IE1vZGVsID0gbW9uZ29vc2UubW9kZWwoJ1Rlc3QnLCBuZXcgbW9uZ29vc2UuU2NoZW1hKHsgYW5zd2VyOiBOdW1iZXIgfSkpO1xuICogICAgIGNvbnN0IGRvYyA9IG5ldyBNb2RlbCh7IGFuc3dlcjogJ25vdCBhIG51bWJlcicgfSk7XG4gKiAgICAgY29uc3QgZXJyID0gZG9jLnZhbGlkYXRlU3luYygpO1xuICpcbiAqICAgICBlcnIgaW5zdGFuY2VvZiBtb25nb29zZS5FcnJvci5WYWxpZGF0aW9uRXJyb3I7IC8vIHRydWVcbiAqXG4gKiBAY29uc3RydWN0b3IgRXJyb3JcbiAqIEBwYXJhbSB7U3RyaW5nfSBtc2cgRXJyb3IgbWVzc2FnZVxuICogQGluaGVyaXRzIEVycm9yIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0Vycm9yXG4gKi9cblxuY29uc3QgTW9uZ29vc2VFcnJvciA9IHJlcXVpcmUoJy4vbW9uZ29vc2VFcnJvcicpO1xuXG4vKipcbiAqIFRoZSBuYW1lIG9mIHRoZSBlcnJvci4gVGhlIG5hbWUgdW5pcXVlbHkgaWRlbnRpZmllcyB0aGlzIE1vbmdvb3NlIGVycm9yLiBUaGVcbiAqIHBvc3NpYmxlIHZhbHVlcyBhcmU6XG4gKlxuICogLSBgTW9uZ29vc2VFcnJvcmA6IGdlbmVyYWwgTW9uZ29vc2UgZXJyb3JcbiAqIC0gYENhc3RFcnJvcmA6IE1vbmdvb3NlIGNvdWxkIG5vdCBjb252ZXJ0IGEgdmFsdWUgdG8gdGhlIHR5cGUgZGVmaW5lZCBpbiB0aGUgc2NoZW1hIHBhdGguIE1heSBiZSBpbiBhIGBWYWxpZGF0aW9uRXJyb3JgIGNsYXNzJyBgZXJyb3JzYCBwcm9wZXJ0eS5cbiAqIC0gYERpdmVyZ2VudEFycmF5RXJyb3JgOiBZb3UgYXR0ZW1wdGVkIHRvIGBzYXZlKClgIGFuIGFycmF5IHRoYXQgd2FzIG1vZGlmaWVkIGFmdGVyIHlvdSBsb2FkZWQgaXQgd2l0aCBhIGAkZWxlbU1hdGNoYCBvciBzaW1pbGFyIHByb2plY3Rpb25cbiAqIC0gYE1pc3NpbmdTY2hlbWFFcnJvcmA6IFlvdSB0cmllZCB0byBhY2Nlc3MgYSBtb2RlbCB3aXRoIFtgbW9uZ29vc2UubW9kZWwoKWBdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvbW9uZ29vc2UuaHRtbCNNb25nb29zZS5tb2RlbCgpKSB0aGF0IHdhcyBub3QgZGVmaW5lZFxuICogLSBgRG9jdW1lbnROb3RGb3VuZEVycm9yYDogVGhlIGRvY3VtZW50IHlvdSB0cmllZCB0byBbYHNhdmUoKWBdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvZG9jdW1lbnQuaHRtbCNEb2N1bWVudC5wcm90b3R5cGUuc2F2ZSgpKSB3YXMgbm90IGZvdW5kXG4gKiAtIGBWYWxpZGF0b3JFcnJvcmA6IGVycm9yIGZyb20gYW4gaW5kaXZpZHVhbCBzY2hlbWEgcGF0aCdzIHZhbGlkYXRvclxuICogLSBgVmFsaWRhdGlvbkVycm9yYDogZXJyb3IgcmV0dXJuZWQgZnJvbSBbYHZhbGlkYXRlKClgXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvYXBpL2RvY3VtZW50Lmh0bWwjRG9jdW1lbnQucHJvdG90eXBlLnZhbGlkYXRlKCkpIG9yIFtgdmFsaWRhdGVTeW5jKClgXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvYXBpL2RvY3VtZW50Lmh0bWwjRG9jdW1lbnQucHJvdG90eXBlLnZhbGlkYXRlU3luYygpKS4gQ29udGFpbnMgemVybyBvciBtb3JlIGBWYWxpZGF0b3JFcnJvcmAgaW5zdGFuY2VzIGluIGAuZXJyb3JzYCBwcm9wZXJ0eS5cbiAqIC0gYE1pc3NpbmdTY2hlbWFFcnJvcmA6IFlvdSBjYWxsZWQgYG1vbmdvb3NlLkRvY3VtZW50KClgIHdpdGhvdXQgYSBzY2hlbWFcbiAqIC0gYE9iamVjdEV4cGVjdGVkRXJyb3JgOiBUaHJvd24gd2hlbiB5b3Ugc2V0IGEgbmVzdGVkIHBhdGggdG8gYSBub24tb2JqZWN0IHZhbHVlIHdpdGggW3N0cmljdCBtb2RlIHNldF0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2d1aWRlLmh0bWwjc3RyaWN0KS5cbiAqIC0gYE9iamVjdFBhcmFtZXRlckVycm9yYDogVGhyb3duIHdoZW4geW91IHBhc3MgYSBub24tb2JqZWN0IHZhbHVlIHRvIGEgZnVuY3Rpb24gd2hpY2ggZXhwZWN0cyBhbiBvYmplY3QgYXMgYSBwYXJhbXRlclxuICogLSBgT3ZlcndyaXRlTW9kZWxFcnJvcmA6IFRocm93biB3aGVuIHlvdSBjYWxsIFtgbW9uZ29vc2UubW9kZWwoKWBdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvbW9uZ29vc2UuaHRtbCNNb25nb29zZS5tb2RlbCgpKSB0byByZS1kZWZpbmUgYSBtb2RlbCB0aGF0IHdhcyBhbHJlYWR5IGRlZmluZWQuXG4gKiAtIGBQYXJhbGxlbFNhdmVFcnJvcmA6IFRocm93biB3aGVuIHlvdSBjYWxsIFtgc2F2ZSgpYF0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2FwaS9tb2RlbC5odG1sI01vZGVsLnByb3RvdHlwZS5zYXZlKCkpIG9uIGEgZG9jdW1lbnQgd2hlbiB0aGUgc2FtZSBkb2N1bWVudCBpbnN0YW5jZSBpcyBhbHJlYWR5IHNhdmluZy5cbiAqIC0gYFN0cmljdE1vZGVFcnJvcmA6IFRocm93biB3aGVuIHlvdSBzZXQgYSBwYXRoIHRoYXQgaXNuJ3QgdGhlIHNjaGVtYSBhbmQgW3N0cmljdCBtb2RlXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvZ3VpZGUuaHRtbCNzdHJpY3QpIGlzIHNldCB0byBgdGhyb3dgLlxuICogLSBgVmVyc2lvbkVycm9yYDogVGhyb3duIHdoZW4gdGhlIFtkb2N1bWVudCBpcyBvdXQgb2Ygc3luY10oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2d1aWRlLmh0bWwjdmVyc2lvbktleSlcbiAqXG4gKiBAYXBpIHB1YmxpY1xuICogQHByb3BlcnR5IHtTdHJpbmd9IG5hbWVcbiAqIEBtZW1iZXJPZiBFcnJvclxuICogQGluc3RhbmNlXG4gKi9cblxuLyohXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBNb25nb29zZUVycm9yO1xuXG4vKipcbiAqIFRoZSBkZWZhdWx0IGJ1aWx0LWluIHZhbGlkYXRvciBlcnJvciBtZXNzYWdlcy5cbiAqXG4gKiBAc2VlIEVycm9yLm1lc3NhZ2VzIGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvZXJyb3IuaHRtbCNFcnJvci5tZXNzYWdlc1xuICogQGFwaSBwdWJsaWNcbiAqIEBtZW1iZXJPZiBFcnJvclxuICogQHN0YXRpY1xuICovXG5cbk1vbmdvb3NlRXJyb3IubWVzc2FnZXMgPSByZXF1aXJlKCcuL21lc3NhZ2VzJyk7XG5cbi8vIGJhY2t3YXJkIGNvbXBhdFxuTW9uZ29vc2VFcnJvci5NZXNzYWdlcyA9IE1vbmdvb3NlRXJyb3IubWVzc2FnZXM7XG5cbi8qKlxuICogQW4gaW5zdGFuY2Ugb2YgdGhpcyBlcnJvciBjbGFzcyB3aWxsIGJlIHJldHVybmVkIHdoZW4gYHNhdmUoKWAgZmFpbHNcbiAqIGJlY2F1c2UgdGhlIHVuZGVybHlpbmdcbiAqIGRvY3VtZW50IHdhcyBub3QgZm91bmQuIFRoZSBjb25zdHJ1Y3RvciB0YWtlcyBvbmUgcGFyYW1ldGVyLCB0aGVcbiAqIGNvbmRpdGlvbnMgdGhhdCBtb25nb29zZSBwYXNzZWQgdG8gYHVwZGF0ZU9uZSgpYCB3aGVuIHRyeWluZyB0byB1cGRhdGVcbiAqIHRoZSBkb2N1bWVudC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICogQG1lbWJlck9mIEVycm9yXG4gKiBAc3RhdGljXG4gKi9cblxuTW9uZ29vc2VFcnJvci5Eb2N1bWVudE5vdEZvdW5kRXJyb3IgPSByZXF1aXJlKCcuL25vdEZvdW5kJyk7XG5cbi8qKlxuICogQW4gaW5zdGFuY2Ugb2YgdGhpcyBlcnJvciBjbGFzcyB3aWxsIGJlIHJldHVybmVkIHdoZW4gbW9uZ29vc2UgZmFpbGVkIHRvXG4gKiBjYXN0IGEgdmFsdWUuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqIEBtZW1iZXJPZiBFcnJvclxuICogQHN0YXRpY1xuICovXG5cbk1vbmdvb3NlRXJyb3IuQ2FzdEVycm9yID0gcmVxdWlyZSgnLi9jYXN0Jyk7XG5cbi8qKlxuICogQW4gaW5zdGFuY2Ugb2YgdGhpcyBlcnJvciBjbGFzcyB3aWxsIGJlIHJldHVybmVkIHdoZW4gW3ZhbGlkYXRpb25dKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy92YWxpZGF0aW9uLmh0bWwpIGZhaWxlZC5cbiAqIFRoZSBgZXJyb3JzYCBwcm9wZXJ0eSBjb250YWlucyBhbiBvYmplY3Qgd2hvc2Uga2V5cyBhcmUgdGhlIHBhdGhzIHRoYXQgZmFpbGVkIGFuZCB3aG9zZSB2YWx1ZXMgYXJlXG4gKiBpbnN0YW5jZXMgb2YgQ2FzdEVycm9yIG9yIFZhbGlkYXRpb25FcnJvci5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICogQG1lbWJlck9mIEVycm9yXG4gKiBAc3RhdGljXG4gKi9cblxuTW9uZ29vc2VFcnJvci5WYWxpZGF0aW9uRXJyb3IgPSByZXF1aXJlKCcuL3ZhbGlkYXRpb24nKTtcblxuLyoqXG4gKiBBIGBWYWxpZGF0aW9uRXJyb3JgIGhhcyBhIGhhc2ggb2YgYGVycm9yc2AgdGhhdCBjb250YWluIGluZGl2aWR1YWxcbiAqIGBWYWxpZGF0b3JFcnJvcmAgaW5zdGFuY2VzLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgY29uc3Qgc2NoZW1hID0gU2NoZW1hKHsgbmFtZTogeyB0eXBlOiBTdHJpbmcsIHJlcXVpcmVkOiB0cnVlIH0gfSk7XG4gKiAgICAgY29uc3QgTW9kZWwgPSBtb25nb29zZS5tb2RlbCgnVGVzdCcsIHNjaGVtYSk7XG4gKiAgICAgY29uc3QgZG9jID0gbmV3IE1vZGVsKHt9KTtcbiAqXG4gKiAgICAgLy8gVG9wLWxldmVsIGVycm9yIGlzIGEgVmFsaWRhdGlvbkVycm9yLCAqKm5vdCoqIGEgVmFsaWRhdG9yRXJyb3JcbiAqICAgICBjb25zdCBlcnIgPSBkb2MudmFsaWRhdGVTeW5jKCk7XG4gKiAgICAgZXJyIGluc3RhbmNlb2YgbW9uZ29vc2UuRXJyb3IuVmFsaWRhdGlvbkVycm9yOyAvLyB0cnVlXG4gKlxuICogICAgIC8vIEEgVmFsaWRhdGlvbkVycm9yIGBlcnJgIGhhcyAwIG9yIG1vcmUgVmFsaWRhdG9yRXJyb3JzIGtleWVkIGJ5IHRoZVxuICogICAgIC8vIHBhdGggaW4gdGhlIGBlcnIuZXJyb3JzYCBwcm9wZXJ0eS5cbiAqICAgICBlcnIuZXJyb3JzWyduYW1lJ10gaW5zdGFuY2VvZiBtb25nb29zZS5FcnJvci5WYWxpZGF0b3JFcnJvcjtcbiAqXG4gKiAgICAgZXJyLmVycm9yc1snbmFtZSddLmtpbmQ7IC8vICdyZXF1aXJlZCdcbiAqICAgICBlcnIuZXJyb3JzWyduYW1lJ10ucGF0aDsgLy8gJ25hbWUnXG4gKiAgICAgZXJyLmVycm9yc1snbmFtZSddLnZhbHVlOyAvLyB1bmRlZmluZWRcbiAqXG4gKiBJbnN0YW5jZXMgb2YgYFZhbGlkYXRvckVycm9yYCBoYXZlIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAqXG4gKiAtIGBraW5kYDogVGhlIHZhbGlkYXRvcidzIGB0eXBlYCwgbGlrZSBgJ3JlcXVpcmVkJ2Agb3IgYCdyZWdleHAnYFxuICogLSBgcGF0aGA6IFRoZSBwYXRoIHRoYXQgZmFpbGVkIHZhbGlkYXRpb25cbiAqIC0gYHZhbHVlYDogVGhlIHZhbHVlIHRoYXQgZmFpbGVkIHZhbGlkYXRpb25cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICogQG1lbWJlck9mIEVycm9yXG4gKiBAc3RhdGljXG4gKi9cblxuTW9uZ29vc2VFcnJvci5WYWxpZGF0b3JFcnJvciA9IHJlcXVpcmUoJy4vdmFsaWRhdG9yJyk7XG5cbi8qKlxuICogQW4gaW5zdGFuY2Ugb2YgdGhpcyBlcnJvciBjbGFzcyB3aWxsIGJlIHJldHVybmVkIHdoZW4geW91IGNhbGwgYHNhdmUoKWAgYWZ0ZXJcbiAqIHRoZSBkb2N1bWVudCBpbiB0aGUgZGF0YWJhc2Ugd2FzIGNoYW5nZWQgaW4gYSBwb3RlbnRpYWxseSB1bnNhZmUgd2F5LiBTZWVcbiAqIHRoZSBbYHZlcnNpb25LZXlgIG9wdGlvbl0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2d1aWRlLmh0bWwjdmVyc2lvbktleSkgZm9yIG1vcmUgaW5mb3JtYXRpb24uXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqIEBtZW1iZXJPZiBFcnJvclxuICogQHN0YXRpY1xuICovXG5cbk1vbmdvb3NlRXJyb3IuVmVyc2lvbkVycm9yID0gcmVxdWlyZSgnLi92ZXJzaW9uJyk7XG5cbi8qKlxuICogQW4gaW5zdGFuY2Ugb2YgdGhpcyBlcnJvciBjbGFzcyB3aWxsIGJlIHJldHVybmVkIHdoZW4geW91IGNhbGwgYHNhdmUoKWAgbXVsdGlwbGVcbiAqIHRpbWVzIG9uIHRoZSBzYW1lIGRvY3VtZW50IGluIHBhcmFsbGVsLiBTZWUgdGhlIFtGQVFdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9mYXEuaHRtbCkgZm9yIG1vcmVcbiAqIGluZm9ybWF0aW9uLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKiBAbWVtYmVyT2YgRXJyb3JcbiAqIEBzdGF0aWNcbiAqL1xuXG5Nb25nb29zZUVycm9yLlBhcmFsbGVsU2F2ZUVycm9yID0gcmVxdWlyZSgnLi9wYXJhbGxlbFNhdmUnKTtcblxuLyoqXG4gKiBUaHJvd24gd2hlbiBhIG1vZGVsIHdpdGggdGhlIGdpdmVuIG5hbWUgd2FzIGFscmVhZHkgcmVnaXN0ZXJlZCBvbiB0aGUgY29ubmVjdGlvbi5cbiAqIFNlZSBbdGhlIEZBUSBhYm91dCBgT3ZlcndyaXRlTW9kZWxFcnJvcmBdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9mYXEuaHRtbCNvdmVyd3JpdGUtbW9kZWwtZXJyb3IpLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKiBAbWVtYmVyT2YgRXJyb3JcbiAqIEBzdGF0aWNcbiAqL1xuXG5Nb25nb29zZUVycm9yLk92ZXJ3cml0ZU1vZGVsRXJyb3IgPSByZXF1aXJlKCcuL292ZXJ3cml0ZU1vZGVsJyk7XG5cbi8qKlxuICogVGhyb3duIHdoZW4geW91IHRyeSB0byBhY2Nlc3MgYSBtb2RlbCB0aGF0IGhhcyBub3QgYmVlbiByZWdpc3RlcmVkIHlldFxuICpcbiAqIEBhcGkgcHVibGljXG4gKiBAbWVtYmVyT2YgRXJyb3JcbiAqIEBzdGF0aWNcbiAqL1xuXG5Nb25nb29zZUVycm9yLk1pc3NpbmdTY2hlbWFFcnJvciA9IHJlcXVpcmUoJy4vbWlzc2luZ1NjaGVtYScpO1xuXG4vKipcbiAqIFRocm93biB3aGVuIHRoZSBNb25nb0RCIE5vZGUgZHJpdmVyIGNhbid0IGNvbm5lY3QgdG8gYSB2YWxpZCBzZXJ2ZXJcbiAqIHRvIHNlbmQgYW4gb3BlcmF0aW9uIHRvLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKiBAbWVtYmVyT2YgRXJyb3JcbiAqIEBzdGF0aWNcbiAqL1xuXG5Nb25nb29zZUVycm9yLk1vbmdvb3NlU2VydmVyU2VsZWN0aW9uRXJyb3IgPSByZXF1aXJlKCcuL3NlcnZlclNlbGVjdGlvbicpO1xuXG4vKipcbiAqIEFuIGluc3RhbmNlIG9mIHRoaXMgZXJyb3Igd2lsbCBiZSByZXR1cm5lZCBpZiB5b3UgdXNlZCBhbiBhcnJheSBwcm9qZWN0aW9uXG4gKiBhbmQgdGhlbiBtb2RpZmllZCB0aGUgYXJyYXkgaW4gYW4gdW5zYWZlIHdheS5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICogQG1lbWJlck9mIEVycm9yXG4gKiBAc3RhdGljXG4gKi9cblxuTW9uZ29vc2VFcnJvci5EaXZlcmdlbnRBcnJheUVycm9yID0gcmVxdWlyZSgnLi9kaXZlcmdlbnRBcnJheScpO1xuXG4vKipcbiAqIFRocm93biB3aGVuIHlvdXIgdHJ5IHRvIHBhc3MgdmFsdWVzIHRvIG1vZGVsIGNvbnN0cnVjdG9yIHRoYXRcbiAqIHdlcmUgbm90IHNwZWNpZmllZCBpbiBzY2hlbWEgb3IgY2hhbmdlIGltbXV0YWJsZSBwcm9wZXJ0aWVzIHdoZW5cbiAqIGBzdHJpY3RgIG1vZGUgaXMgYFwidGhyb3dcImBcbiAqXG4gKiBAYXBpIHB1YmxpY1xuICogQG1lbWJlck9mIEVycm9yXG4gKiBAc3RhdGljXG4gKi9cblxuTW9uZ29vc2VFcnJvci5TdHJpY3RNb2RlRXJyb3IgPSByZXF1aXJlKCcuL3N0cmljdCcpO1xuXG4vKipcbiAqIEFuIGluc3RhbmNlIG9mIHRoaXMgZXJyb3IgY2xhc3Mgd2lsbCBiZSByZXR1cm5lZCB3aGVuIG1vbmdvb3NlIGZhaWxlZCB0b1xuICogcG9wdWxhdGUgd2l0aCBhIHBhdGggdGhhdCBpcyBub3QgZXhpc3RpbmcuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqIEBtZW1iZXJPZiBFcnJvclxuICogQHN0YXRpY1xuICovXG5cbk1vbmdvb3NlRXJyb3IuU3RyaWN0UG9wdWxhdGVFcnJvciA9IHJlcXVpcmUoJy4vc3RyaWN0UG9wdWxhdGUnKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../server/node_modules/mongoose/lib/error/index.js\n");

/***/ }),

/***/ "../server/node_modules/mongoose/lib/error/invalidSchemaOption.js":
/*!************************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/error/invalidSchemaOption.js ***!
  \************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n/*!\n * Module dependencies.\n */\n\n\n\nconst MongooseError = __webpack_require__(/*! ./ */ \"../server/node_modules/mongoose/lib/error/index.js\");\n\nclass InvalidSchemaOptionError extends MongooseError {\n  /**\n   * InvalidSchemaOption Error constructor.\n   * @param {String} name\n   * @api private\n   */\n  constructor(name, option) {\n    const msg = `Cannot create use schema for property \"${name}\" because the schema has the ${option} option enabled.`;\n    super(msg);\n  }\n}\n\nObject.defineProperty(InvalidSchemaOptionError.prototype, 'name', {\n  value: 'InvalidSchemaOptionError'\n});\n\n/*!\n * exports\n */\n\nmodule.exports = InvalidSchemaOptionError;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvZXJyb3IvaW52YWxpZFNjaGVtYU9wdGlvbi5qcyIsIm1hcHBpbmdzIjoiO0FBQ0E7QUFDQTtBQUNBOztBQUVhOztBQUViLHNCQUFzQixtQkFBTyxDQUFDLDhEQUFJOztBQUVsQztBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0EsMERBQTBELEtBQUssK0JBQStCLFFBQVE7QUFDdEc7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL2NsaWVudC8uLi9zZXJ2ZXIvbm9kZV9tb2R1bGVzL21vbmdvb3NlL2xpYi9lcnJvci9pbnZhbGlkU2NoZW1hT3B0aW9uLmpzP2YzNWYiXSwic291cmNlc0NvbnRlbnQiOlsiXG4vKiFcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBNb25nb29zZUVycm9yID0gcmVxdWlyZSgnLi8nKTtcblxuY2xhc3MgSW52YWxpZFNjaGVtYU9wdGlvbkVycm9yIGV4dGVuZHMgTW9uZ29vc2VFcnJvciB7XG4gIC8qKlxuICAgKiBJbnZhbGlkU2NoZW1hT3B0aW9uIEVycm9yIGNvbnN0cnVjdG9yLlxuICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIGNvbnN0cnVjdG9yKG5hbWUsIG9wdGlvbikge1xuICAgIGNvbnN0IG1zZyA9IGBDYW5ub3QgY3JlYXRlIHVzZSBzY2hlbWEgZm9yIHByb3BlcnR5IFwiJHtuYW1lfVwiIGJlY2F1c2UgdGhlIHNjaGVtYSBoYXMgdGhlICR7b3B0aW9ufSBvcHRpb24gZW5hYmxlZC5gO1xuICAgIHN1cGVyKG1zZyk7XG4gIH1cbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KEludmFsaWRTY2hlbWFPcHRpb25FcnJvci5wcm90b3R5cGUsICduYW1lJywge1xuICB2YWx1ZTogJ0ludmFsaWRTY2hlbWFPcHRpb25FcnJvcidcbn0pO1xuXG4vKiFcbiAqIGV4cG9ydHNcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IEludmFsaWRTY2hlbWFPcHRpb25FcnJvcjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../server/node_modules/mongoose/lib/error/invalidSchemaOption.js\n");

/***/ }),

/***/ "../server/node_modules/mongoose/lib/error/messages.js":
/*!*************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/error/messages.js ***!
  \*************************************************************/
/***/ ((module, exports) => {

"use strict";
eval("\n/**\n * The default built-in validator error messages. These may be customized.\n *\n *     // customize within each schema or globally like so\n *     const mongoose = require('mongoose');\n *     mongoose.Error.messages.String.enum  = \"Your custom message for {PATH}.\";\n *\n * Error messages support basic templating. Mongoose will replace the following strings with the corresponding value.\n *\n * - `{PATH}` is replaced with the invalid document path\n * - `{VALUE}` is replaced with the invalid value\n * - `{TYPE}` is replaced with the validator type such as \"regexp\", \"min\", or \"user defined\"\n * - `{MIN}` is replaced with the declared min value for the Number.min validator\n * - `{MAX}` is replaced with the declared max value for the Number.max validator\n *\n * Click the \"show code\" link below to see all defaults.\n *\n * @static\n * @memberOf MongooseError\n * @api public\n */\n\n\n\nconst msg = module.exports = exports = {};\n\nmsg.DocumentNotFoundError = null;\n\nmsg.general = {};\nmsg.general.default = 'Validator failed for path `{PATH}` with value `{VALUE}`';\nmsg.general.required = 'Path `{PATH}` is required.';\n\nmsg.Number = {};\nmsg.Number.min = 'Path `{PATH}` ({VALUE}) is less than minimum allowed value ({MIN}).';\nmsg.Number.max = 'Path `{PATH}` ({VALUE}) is more than maximum allowed value ({MAX}).';\nmsg.Number.enum = '`{VALUE}` is not a valid enum value for path `{PATH}`.';\n\nmsg.Date = {};\nmsg.Date.min = 'Path `{PATH}` ({VALUE}) is before minimum allowed value ({MIN}).';\nmsg.Date.max = 'Path `{PATH}` ({VALUE}) is after maximum allowed value ({MAX}).';\n\nmsg.String = {};\nmsg.String.enum = '`{VALUE}` is not a valid enum value for path `{PATH}`.';\nmsg.String.match = 'Path `{PATH}` is invalid ({VALUE}).';\nmsg.String.minlength = 'Path `{PATH}` (`{VALUE}`) is shorter than the minimum allowed length ({MINLENGTH}).';\nmsg.String.maxlength = 'Path `{PATH}` (`{VALUE}`) is longer than the maximum allowed length ({MAXLENGTH}).';\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvZXJyb3IvbWVzc2FnZXMuanMiLCJtYXBwaW5ncyI6IjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3RUFBd0UsS0FBSztBQUM3RTtBQUNBO0FBQ0E7QUFDQSxPQUFPLEtBQUs7QUFDWixPQUFPLE1BQU07QUFDYixPQUFPLEtBQUs7QUFDWixPQUFPLElBQUk7QUFDWCxPQUFPLElBQUk7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFYTs7QUFFYjs7QUFFQTs7QUFFQTtBQUNBLG1EQUFtRCxLQUFLLGVBQWUsTUFBTTtBQUM3RSwrQkFBK0IsS0FBSzs7QUFFcEM7QUFDQSx5QkFBeUIsS0FBSyxJQUFJLE1BQU0sdUNBQXVDLElBQUk7QUFDbkYseUJBQXlCLEtBQUssSUFBSSxNQUFNLHVDQUF1QyxJQUFJO0FBQ25GLHFCQUFxQixNQUFNLHVDQUF1QyxLQUFLOztBQUV2RTtBQUNBLHVCQUF1QixLQUFLLElBQUksTUFBTSxvQ0FBb0MsSUFBSTtBQUM5RSx1QkFBdUIsS0FBSyxJQUFJLE1BQU0sbUNBQW1DLElBQUk7O0FBRTdFO0FBQ0EscUJBQXFCLE1BQU0sdUNBQXVDLEtBQUs7QUFDdkUsMkJBQTJCLEtBQUssZUFBZSxNQUFNO0FBQ3JELCtCQUErQixLQUFLLEtBQUssTUFBTSxnREFBZ0QsVUFBVTtBQUN6RywrQkFBK0IsS0FBSyxLQUFLLE1BQU0sK0NBQStDLFVBQVUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbGllbnQvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvZXJyb3IvbWVzc2FnZXMuanM/N2YwYyJdLCJzb3VyY2VzQ29udGVudCI6WyJcbi8qKlxuICogVGhlIGRlZmF1bHQgYnVpbHQtaW4gdmFsaWRhdG9yIGVycm9yIG1lc3NhZ2VzLiBUaGVzZSBtYXkgYmUgY3VzdG9taXplZC5cbiAqXG4gKiAgICAgLy8gY3VzdG9taXplIHdpdGhpbiBlYWNoIHNjaGVtYSBvciBnbG9iYWxseSBsaWtlIHNvXG4gKiAgICAgY29uc3QgbW9uZ29vc2UgPSByZXF1aXJlKCdtb25nb29zZScpO1xuICogICAgIG1vbmdvb3NlLkVycm9yLm1lc3NhZ2VzLlN0cmluZy5lbnVtICA9IFwiWW91ciBjdXN0b20gbWVzc2FnZSBmb3Ige1BBVEh9LlwiO1xuICpcbiAqIEVycm9yIG1lc3NhZ2VzIHN1cHBvcnQgYmFzaWMgdGVtcGxhdGluZy4gTW9uZ29vc2Ugd2lsbCByZXBsYWNlIHRoZSBmb2xsb3dpbmcgc3RyaW5ncyB3aXRoIHRoZSBjb3JyZXNwb25kaW5nIHZhbHVlLlxuICpcbiAqIC0gYHtQQVRIfWAgaXMgcmVwbGFjZWQgd2l0aCB0aGUgaW52YWxpZCBkb2N1bWVudCBwYXRoXG4gKiAtIGB7VkFMVUV9YCBpcyByZXBsYWNlZCB3aXRoIHRoZSBpbnZhbGlkIHZhbHVlXG4gKiAtIGB7VFlQRX1gIGlzIHJlcGxhY2VkIHdpdGggdGhlIHZhbGlkYXRvciB0eXBlIHN1Y2ggYXMgXCJyZWdleHBcIiwgXCJtaW5cIiwgb3IgXCJ1c2VyIGRlZmluZWRcIlxuICogLSBge01JTn1gIGlzIHJlcGxhY2VkIHdpdGggdGhlIGRlY2xhcmVkIG1pbiB2YWx1ZSBmb3IgdGhlIE51bWJlci5taW4gdmFsaWRhdG9yXG4gKiAtIGB7TUFYfWAgaXMgcmVwbGFjZWQgd2l0aCB0aGUgZGVjbGFyZWQgbWF4IHZhbHVlIGZvciB0aGUgTnVtYmVyLm1heCB2YWxpZGF0b3JcbiAqXG4gKiBDbGljayB0aGUgXCJzaG93IGNvZGVcIiBsaW5rIGJlbG93IHRvIHNlZSBhbGwgZGVmYXVsdHMuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIE1vbmdvb3NlRXJyb3JcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBtc2cgPSBtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSB7fTtcblxubXNnLkRvY3VtZW50Tm90Rm91bmRFcnJvciA9IG51bGw7XG5cbm1zZy5nZW5lcmFsID0ge307XG5tc2cuZ2VuZXJhbC5kZWZhdWx0ID0gJ1ZhbGlkYXRvciBmYWlsZWQgZm9yIHBhdGggYHtQQVRIfWAgd2l0aCB2YWx1ZSBge1ZBTFVFfWAnO1xubXNnLmdlbmVyYWwucmVxdWlyZWQgPSAnUGF0aCBge1BBVEh9YCBpcyByZXF1aXJlZC4nO1xuXG5tc2cuTnVtYmVyID0ge307XG5tc2cuTnVtYmVyLm1pbiA9ICdQYXRoIGB7UEFUSH1gICh7VkFMVUV9KSBpcyBsZXNzIHRoYW4gbWluaW11bSBhbGxvd2VkIHZhbHVlICh7TUlOfSkuJztcbm1zZy5OdW1iZXIubWF4ID0gJ1BhdGggYHtQQVRIfWAgKHtWQUxVRX0pIGlzIG1vcmUgdGhhbiBtYXhpbXVtIGFsbG93ZWQgdmFsdWUgKHtNQVh9KS4nO1xubXNnLk51bWJlci5lbnVtID0gJ2B7VkFMVUV9YCBpcyBub3QgYSB2YWxpZCBlbnVtIHZhbHVlIGZvciBwYXRoIGB7UEFUSH1gLic7XG5cbm1zZy5EYXRlID0ge307XG5tc2cuRGF0ZS5taW4gPSAnUGF0aCBge1BBVEh9YCAoe1ZBTFVFfSkgaXMgYmVmb3JlIG1pbmltdW0gYWxsb3dlZCB2YWx1ZSAoe01JTn0pLic7XG5tc2cuRGF0ZS5tYXggPSAnUGF0aCBge1BBVEh9YCAoe1ZBTFVFfSkgaXMgYWZ0ZXIgbWF4aW11bSBhbGxvd2VkIHZhbHVlICh7TUFYfSkuJztcblxubXNnLlN0cmluZyA9IHt9O1xubXNnLlN0cmluZy5lbnVtID0gJ2B7VkFMVUV9YCBpcyBub3QgYSB2YWxpZCBlbnVtIHZhbHVlIGZvciBwYXRoIGB7UEFUSH1gLic7XG5tc2cuU3RyaW5nLm1hdGNoID0gJ1BhdGggYHtQQVRIfWAgaXMgaW52YWxpZCAoe1ZBTFVFfSkuJztcbm1zZy5TdHJpbmcubWlubGVuZ3RoID0gJ1BhdGggYHtQQVRIfWAgKGB7VkFMVUV9YCkgaXMgc2hvcnRlciB0aGFuIHRoZSBtaW5pbXVtIGFsbG93ZWQgbGVuZ3RoICh7TUlOTEVOR1RIfSkuJztcbm1zZy5TdHJpbmcubWF4bGVuZ3RoID0gJ1BhdGggYHtQQVRIfWAgKGB7VkFMVUV9YCkgaXMgbG9uZ2VyIHRoYW4gdGhlIG1heGltdW0gYWxsb3dlZCBsZW5ndGggKHtNQVhMRU5HVEh9KS4nO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../server/node_modules/mongoose/lib/error/messages.js\n");

/***/ }),

/***/ "../server/node_modules/mongoose/lib/error/missingSchema.js":
/*!******************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/error/missingSchema.js ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n/*!\n * Module dependencies.\n */\n\n\n\nconst MongooseError = __webpack_require__(/*! ./ */ \"../server/node_modules/mongoose/lib/error/index.js\");\n\nclass MissingSchemaError extends MongooseError {\n  /**\n   * MissingSchema Error constructor.\n   * @param {String} name\n   * @api private\n   */\n  constructor(name) {\n    const msg = 'Schema hasn\\'t been registered for model \"' + name + '\".\\n'\n            + 'Use mongoose.model(name, schema)';\n    super(msg);\n  }\n}\n\nObject.defineProperty(MissingSchemaError.prototype, 'name', {\n  value: 'MissingSchemaError'\n});\n\n/*!\n * exports\n */\n\nmodule.exports = MissingSchemaError;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvZXJyb3IvbWlzc2luZ1NjaGVtYS5qcyIsIm1hcHBpbmdzIjoiO0FBQ0E7QUFDQTtBQUNBOztBQUVhOztBQUViLHNCQUFzQixtQkFBTyxDQUFDLDhEQUFJOztBQUVsQztBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbGllbnQvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvZXJyb3IvbWlzc2luZ1NjaGVtYS5qcz83ZjFjIl0sInNvdXJjZXNDb250ZW50IjpbIlxuLyohXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuY29uc3QgTW9uZ29vc2VFcnJvciA9IHJlcXVpcmUoJy4vJyk7XG5cbmNsYXNzIE1pc3NpbmdTY2hlbWFFcnJvciBleHRlbmRzIE1vbmdvb3NlRXJyb3Ige1xuICAvKipcbiAgICogTWlzc2luZ1NjaGVtYSBFcnJvciBjb25zdHJ1Y3Rvci5cbiAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBjb25zdHJ1Y3RvcihuYW1lKSB7XG4gICAgY29uc3QgbXNnID0gJ1NjaGVtYSBoYXNuXFwndCBiZWVuIHJlZ2lzdGVyZWQgZm9yIG1vZGVsIFwiJyArIG5hbWUgKyAnXCIuXFxuJ1xuICAgICAgICAgICAgKyAnVXNlIG1vbmdvb3NlLm1vZGVsKG5hbWUsIHNjaGVtYSknO1xuICAgIHN1cGVyKG1zZyk7XG4gIH1cbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KE1pc3NpbmdTY2hlbWFFcnJvci5wcm90b3R5cGUsICduYW1lJywge1xuICB2YWx1ZTogJ01pc3NpbmdTY2hlbWFFcnJvcidcbn0pO1xuXG4vKiFcbiAqIGV4cG9ydHNcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IE1pc3NpbmdTY2hlbWFFcnJvcjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../server/node_modules/mongoose/lib/error/missingSchema.js\n");

/***/ }),

/***/ "../server/node_modules/mongoose/lib/error/mongooseError.js":
/*!******************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/error/mongooseError.js ***!
  \******************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/*!\n * ignore\n */\n\nclass MongooseError extends Error { }\n\nObject.defineProperty(MongooseError.prototype, 'name', {\n  value: 'MongooseError'\n});\n\nmodule.exports = MongooseError;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvZXJyb3IvbW9uZ29vc2VFcnJvci5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbGllbnQvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvZXJyb3IvbW9uZ29vc2VFcnJvci5qcz8yNjMzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5jbGFzcyBNb25nb29zZUVycm9yIGV4dGVuZHMgRXJyb3IgeyB9XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShNb25nb29zZUVycm9yLnByb3RvdHlwZSwgJ25hbWUnLCB7XG4gIHZhbHVlOiAnTW9uZ29vc2VFcnJvcidcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IE1vbmdvb3NlRXJyb3I7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../server/node_modules/mongoose/lib/error/mongooseError.js\n");

/***/ }),

/***/ "../server/node_modules/mongoose/lib/error/notFound.js":
/*!*************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/error/notFound.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\n/*!\n * Module dependencies.\n */\n\nconst MongooseError = __webpack_require__(/*! ./ */ \"../server/node_modules/mongoose/lib/error/index.js\");\nconst util = __webpack_require__(/*! util */ \"util\");\n\nclass DocumentNotFoundError extends MongooseError {\n  /**\n   * OverwriteModel Error constructor.\n   * @api private\n   */\n  constructor(filter, model, numAffected, result) {\n    let msg;\n    const messages = MongooseError.messages;\n    if (messages.DocumentNotFoundError != null) {\n      msg = typeof messages.DocumentNotFoundError === 'function' ?\n        messages.DocumentNotFoundError(filter, model) :\n        messages.DocumentNotFoundError;\n    } else {\n      msg = 'No document found for query \"' + util.inspect(filter) +\n        '\" on model \"' + model + '\"';\n    }\n\n    super(msg);\n\n    this.result = result;\n    this.numAffected = numAffected;\n    this.filter = filter;\n    // Backwards compat\n    this.query = filter;\n  }\n}\n\nObject.defineProperty(DocumentNotFoundError.prototype, 'name', {\n  value: 'DocumentNotFoundError'\n});\n\n/*!\n * exports\n */\n\nmodule.exports = DocumentNotFoundError;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvZXJyb3Ivbm90Rm91bmQuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7QUFDQTtBQUNBOztBQUVBLHNCQUFzQixtQkFBTyxDQUFDLDhEQUFJO0FBQ2xDLGFBQWEsbUJBQU8sQ0FBQyxrQkFBTTs7QUFFM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbGllbnQvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvZXJyb3Ivbm90Rm91bmQuanM/NDNmYiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbi8qIVxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG5jb25zdCBNb25nb29zZUVycm9yID0gcmVxdWlyZSgnLi8nKTtcbmNvbnN0IHV0aWwgPSByZXF1aXJlKCd1dGlsJyk7XG5cbmNsYXNzIERvY3VtZW50Tm90Rm91bmRFcnJvciBleHRlbmRzIE1vbmdvb3NlRXJyb3Ige1xuICAvKipcbiAgICogT3ZlcndyaXRlTW9kZWwgRXJyb3IgY29uc3RydWN0b3IuXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgY29uc3RydWN0b3IoZmlsdGVyLCBtb2RlbCwgbnVtQWZmZWN0ZWQsIHJlc3VsdCkge1xuICAgIGxldCBtc2c7XG4gICAgY29uc3QgbWVzc2FnZXMgPSBNb25nb29zZUVycm9yLm1lc3NhZ2VzO1xuICAgIGlmIChtZXNzYWdlcy5Eb2N1bWVudE5vdEZvdW5kRXJyb3IgIT0gbnVsbCkge1xuICAgICAgbXNnID0gdHlwZW9mIG1lc3NhZ2VzLkRvY3VtZW50Tm90Rm91bmRFcnJvciA9PT0gJ2Z1bmN0aW9uJyA/XG4gICAgICAgIG1lc3NhZ2VzLkRvY3VtZW50Tm90Rm91bmRFcnJvcihmaWx0ZXIsIG1vZGVsKSA6XG4gICAgICAgIG1lc3NhZ2VzLkRvY3VtZW50Tm90Rm91bmRFcnJvcjtcbiAgICB9IGVsc2Uge1xuICAgICAgbXNnID0gJ05vIGRvY3VtZW50IGZvdW5kIGZvciBxdWVyeSBcIicgKyB1dGlsLmluc3BlY3QoZmlsdGVyKSArXG4gICAgICAgICdcIiBvbiBtb2RlbCBcIicgKyBtb2RlbCArICdcIic7XG4gICAgfVxuXG4gICAgc3VwZXIobXNnKTtcblxuICAgIHRoaXMucmVzdWx0ID0gcmVzdWx0O1xuICAgIHRoaXMubnVtQWZmZWN0ZWQgPSBudW1BZmZlY3RlZDtcbiAgICB0aGlzLmZpbHRlciA9IGZpbHRlcjtcbiAgICAvLyBCYWNrd2FyZHMgY29tcGF0XG4gICAgdGhpcy5xdWVyeSA9IGZpbHRlcjtcbiAgfVxufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoRG9jdW1lbnROb3RGb3VuZEVycm9yLnByb3RvdHlwZSwgJ25hbWUnLCB7XG4gIHZhbHVlOiAnRG9jdW1lbnROb3RGb3VuZEVycm9yJ1xufSk7XG5cbi8qIVxuICogZXhwb3J0c1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0gRG9jdW1lbnROb3RGb3VuZEVycm9yO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../server/node_modules/mongoose/lib/error/notFound.js\n");

/***/ }),

/***/ "../server/node_modules/mongoose/lib/error/objectExpected.js":
/*!*******************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/error/objectExpected.js ***!
  \*******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*!\n * Module dependencies.\n */\n\n\n\nconst MongooseError = __webpack_require__(/*! ./ */ \"../server/node_modules/mongoose/lib/error/index.js\");\n\n\nclass ObjectExpectedError extends MongooseError {\n  /**\n   * Strict mode error constructor\n   *\n   * @param {string} type\n   * @param {string} value\n   * @api private\n   */\n  constructor(path, val) {\n    const typeDescription = Array.isArray(val) ? 'array' : 'primitive value';\n    super('Tried to set nested object field `' + path +\n      `\\` to ${typeDescription} \\`` + val + '`');\n    this.path = path;\n  }\n}\n\nObject.defineProperty(ObjectExpectedError.prototype, 'name', {\n  value: 'ObjectExpectedError'\n});\n\nmodule.exports = ObjectExpectedError;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvZXJyb3Ivb2JqZWN0RXhwZWN0ZWQuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBOztBQUVhOztBQUViLHNCQUFzQixtQkFBTyxDQUFDLDhEQUFJOzs7QUFHbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGlCQUFpQjtBQUNoQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbGllbnQvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvZXJyb3Ivb2JqZWN0RXhwZWN0ZWQuanM/ZWE2MCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBNb25nb29zZUVycm9yID0gcmVxdWlyZSgnLi8nKTtcblxuXG5jbGFzcyBPYmplY3RFeHBlY3RlZEVycm9yIGV4dGVuZHMgTW9uZ29vc2VFcnJvciB7XG4gIC8qKlxuICAgKiBTdHJpY3QgbW9kZSBlcnJvciBjb25zdHJ1Y3RvclxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBjb25zdHJ1Y3RvcihwYXRoLCB2YWwpIHtcbiAgICBjb25zdCB0eXBlRGVzY3JpcHRpb24gPSBBcnJheS5pc0FycmF5KHZhbCkgPyAnYXJyYXknIDogJ3ByaW1pdGl2ZSB2YWx1ZSc7XG4gICAgc3VwZXIoJ1RyaWVkIHRvIHNldCBuZXN0ZWQgb2JqZWN0IGZpZWxkIGAnICsgcGF0aCArXG4gICAgICBgXFxgIHRvICR7dHlwZURlc2NyaXB0aW9ufSBcXGBgICsgdmFsICsgJ2AnKTtcbiAgICB0aGlzLnBhdGggPSBwYXRoO1xuICB9XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShPYmplY3RFeHBlY3RlZEVycm9yLnByb3RvdHlwZSwgJ25hbWUnLCB7XG4gIHZhbHVlOiAnT2JqZWN0RXhwZWN0ZWRFcnJvcidcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdEV4cGVjdGVkRXJyb3I7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../server/node_modules/mongoose/lib/error/objectExpected.js\n");

/***/ }),

/***/ "../server/node_modules/mongoose/lib/error/objectParameter.js":
/*!********************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/error/objectParameter.js ***!
  \********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*!\n * Module dependencies.\n */\n\n\n\nconst MongooseError = __webpack_require__(/*! ./ */ \"../server/node_modules/mongoose/lib/error/index.js\");\n\nclass ObjectParameterError extends MongooseError {\n  /**\n   * Constructor for errors that happen when a parameter that's expected to be\n   * an object isn't an object\n   *\n   * @param {Any} value\n   * @param {String} paramName\n   * @param {String} fnName\n   * @api private\n   */\n  constructor(value, paramName, fnName) {\n    super('Parameter \"' + paramName + '\" to ' + fnName +\n      '() must be an object, got \"' + value.toString() + '\" (type ' + typeof value + ')');\n  }\n}\n\n\nObject.defineProperty(ObjectParameterError.prototype, 'name', {\n  value: 'ObjectParameterError'\n});\n\nmodule.exports = ObjectParameterError;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvZXJyb3Ivb2JqZWN0UGFyYW1ldGVyLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTs7QUFFYTs7QUFFYixzQkFBc0IsbUJBQU8sQ0FBQyw4REFBSTs7QUFFbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsS0FBSztBQUNsQixhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRCIsInNvdXJjZXMiOlsid2VicGFjazovL2NsaWVudC8uLi9zZXJ2ZXIvbm9kZV9tb2R1bGVzL21vbmdvb3NlL2xpYi9lcnJvci9vYmplY3RQYXJhbWV0ZXIuanM/NGI0NyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBNb25nb29zZUVycm9yID0gcmVxdWlyZSgnLi8nKTtcblxuY2xhc3MgT2JqZWN0UGFyYW1ldGVyRXJyb3IgZXh0ZW5kcyBNb25nb29zZUVycm9yIHtcbiAgLyoqXG4gICAqIENvbnN0cnVjdG9yIGZvciBlcnJvcnMgdGhhdCBoYXBwZW4gd2hlbiBhIHBhcmFtZXRlciB0aGF0J3MgZXhwZWN0ZWQgdG8gYmVcbiAgICogYW4gb2JqZWN0IGlzbid0IGFuIG9iamVjdFxuICAgKlxuICAgKiBAcGFyYW0ge0FueX0gdmFsdWVcbiAgICogQHBhcmFtIHtTdHJpbmd9IHBhcmFtTmFtZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gZm5OYW1lXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgY29uc3RydWN0b3IodmFsdWUsIHBhcmFtTmFtZSwgZm5OYW1lKSB7XG4gICAgc3VwZXIoJ1BhcmFtZXRlciBcIicgKyBwYXJhbU5hbWUgKyAnXCIgdG8gJyArIGZuTmFtZSArXG4gICAgICAnKCkgbXVzdCBiZSBhbiBvYmplY3QsIGdvdCBcIicgKyB2YWx1ZS50b1N0cmluZygpICsgJ1wiICh0eXBlICcgKyB0eXBlb2YgdmFsdWUgKyAnKScpO1xuICB9XG59XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KE9iamVjdFBhcmFtZXRlckVycm9yLnByb3RvdHlwZSwgJ25hbWUnLCB7XG4gIHZhbHVlOiAnT2JqZWN0UGFyYW1ldGVyRXJyb3InXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBPYmplY3RQYXJhbWV0ZXJFcnJvcjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../server/node_modules/mongoose/lib/error/objectParameter.js\n");

/***/ }),

/***/ "../server/node_modules/mongoose/lib/error/overwriteModel.js":
/*!*******************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/error/overwriteModel.js ***!
  \*******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n/*!\n * Module dependencies.\n */\n\n\n\nconst MongooseError = __webpack_require__(/*! ./ */ \"../server/node_modules/mongoose/lib/error/index.js\");\n\n\nclass OverwriteModelError extends MongooseError {\n  /**\n   * OverwriteModel Error constructor.\n   * @param {String} name\n   * @api private\n   */\n  constructor(name) {\n    super('Cannot overwrite `' + name + '` model once compiled.');\n  }\n}\n\nObject.defineProperty(OverwriteModelError.prototype, 'name', {\n  value: 'OverwriteModelError'\n});\n\n/*!\n * exports\n */\n\nmodule.exports = OverwriteModelError;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvZXJyb3Ivb3ZlcndyaXRlTW9kZWwuanMiLCJtYXBwaW5ncyI6IjtBQUNBO0FBQ0E7QUFDQTs7QUFFYTs7QUFFYixzQkFBc0IsbUJBQU8sQ0FBQyw4REFBSTs7O0FBR2xDO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2xpZW50Ly4uL3NlcnZlci9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2Vycm9yL292ZXJ3cml0ZU1vZGVsLmpzPzQ4OGYiXSwic291cmNlc0NvbnRlbnQiOlsiXG4vKiFcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBNb25nb29zZUVycm9yID0gcmVxdWlyZSgnLi8nKTtcblxuXG5jbGFzcyBPdmVyd3JpdGVNb2RlbEVycm9yIGV4dGVuZHMgTW9uZ29vc2VFcnJvciB7XG4gIC8qKlxuICAgKiBPdmVyd3JpdGVNb2RlbCBFcnJvciBjb25zdHJ1Y3Rvci5cbiAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBjb25zdHJ1Y3RvcihuYW1lKSB7XG4gICAgc3VwZXIoJ0Nhbm5vdCBvdmVyd3JpdGUgYCcgKyBuYW1lICsgJ2AgbW9kZWwgb25jZSBjb21waWxlZC4nKTtcbiAgfVxufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoT3ZlcndyaXRlTW9kZWxFcnJvci5wcm90b3R5cGUsICduYW1lJywge1xuICB2YWx1ZTogJ092ZXJ3cml0ZU1vZGVsRXJyb3InXG59KTtcblxuLyohXG4gKiBleHBvcnRzXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBPdmVyd3JpdGVNb2RlbEVycm9yO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../server/node_modules/mongoose/lib/error/overwriteModel.js\n");

/***/ }),

/***/ "../server/node_modules/mongoose/lib/error/parallelSave.js":
/*!*****************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/error/parallelSave.js ***!
  \*****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\n/*!\n * Module dependencies.\n */\n\nconst MongooseError = __webpack_require__(/*! ./ */ \"../server/node_modules/mongoose/lib/error/index.js\");\n\nclass ParallelSaveError extends MongooseError {\n  /**\n   * ParallelSave Error constructor.\n   *\n   * @param {Document} doc\n   * @api private\n   */\n  constructor(doc) {\n    const msg = 'Can\\'t save() the same doc multiple times in parallel. Document: ';\n    super(msg + doc._id);\n  }\n}\n\nObject.defineProperty(ParallelSaveError.prototype, 'name', {\n  value: 'ParallelSaveError'\n});\n\n/*!\n * exports\n */\n\nmodule.exports = ParallelSaveError;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvZXJyb3IvcGFyYWxsZWxTYXZlLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0E7QUFDQTs7QUFFQSxzQkFBc0IsbUJBQU8sQ0FBQyw4REFBSTs7QUFFbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFVBQVU7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2xpZW50Ly4uL3NlcnZlci9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2Vycm9yL3BhcmFsbGVsU2F2ZS5qcz84ZjJlIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuLyohXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbmNvbnN0IE1vbmdvb3NlRXJyb3IgPSByZXF1aXJlKCcuLycpO1xuXG5jbGFzcyBQYXJhbGxlbFNhdmVFcnJvciBleHRlbmRzIE1vbmdvb3NlRXJyb3Ige1xuICAvKipcbiAgICogUGFyYWxsZWxTYXZlIEVycm9yIGNvbnN0cnVjdG9yLlxuICAgKlxuICAgKiBAcGFyYW0ge0RvY3VtZW50fSBkb2NcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBjb25zdHJ1Y3Rvcihkb2MpIHtcbiAgICBjb25zdCBtc2cgPSAnQ2FuXFwndCBzYXZlKCkgdGhlIHNhbWUgZG9jIG11bHRpcGxlIHRpbWVzIGluIHBhcmFsbGVsLiBEb2N1bWVudDogJztcbiAgICBzdXBlcihtc2cgKyBkb2MuX2lkKTtcbiAgfVxufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoUGFyYWxsZWxTYXZlRXJyb3IucHJvdG90eXBlLCAnbmFtZScsIHtcbiAgdmFsdWU6ICdQYXJhbGxlbFNhdmVFcnJvcidcbn0pO1xuXG4vKiFcbiAqIGV4cG9ydHNcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IFBhcmFsbGVsU2F2ZUVycm9yO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../server/node_modules/mongoose/lib/error/parallelSave.js\n");

/***/ }),

/***/ "../server/node_modules/mongoose/lib/error/parallelValidate.js":
/*!*********************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/error/parallelValidate.js ***!
  \*********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\n/*!\n * Module dependencies.\n */\n\nconst MongooseError = __webpack_require__(/*! ./mongooseError */ \"../server/node_modules/mongoose/lib/error/mongooseError.js\");\n\n\nclass ParallelValidateError extends MongooseError {\n  /**\n   * ParallelValidate Error constructor.\n   *\n   * @param {Document} doc\n   * @api private\n   */\n  constructor(doc) {\n    const msg = 'Can\\'t validate() the same doc multiple times in parallel. Document: ';\n    super(msg + doc._id);\n  }\n}\n\nObject.defineProperty(ParallelValidateError.prototype, 'name', {\n  value: 'ParallelValidateError'\n});\n\n/*!\n * exports\n */\n\nmodule.exports = ParallelValidateError;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvZXJyb3IvcGFyYWxsZWxWYWxpZGF0ZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBO0FBQ0E7O0FBRUEsc0JBQXNCLG1CQUFPLENBQUMsbUZBQWlCOzs7QUFHL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFVBQVU7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2xpZW50Ly4uL3NlcnZlci9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2Vycm9yL3BhcmFsbGVsVmFsaWRhdGUuanM/NmI0MyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbi8qIVxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG5jb25zdCBNb25nb29zZUVycm9yID0gcmVxdWlyZSgnLi9tb25nb29zZUVycm9yJyk7XG5cblxuY2xhc3MgUGFyYWxsZWxWYWxpZGF0ZUVycm9yIGV4dGVuZHMgTW9uZ29vc2VFcnJvciB7XG4gIC8qKlxuICAgKiBQYXJhbGxlbFZhbGlkYXRlIEVycm9yIGNvbnN0cnVjdG9yLlxuICAgKlxuICAgKiBAcGFyYW0ge0RvY3VtZW50fSBkb2NcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBjb25zdHJ1Y3Rvcihkb2MpIHtcbiAgICBjb25zdCBtc2cgPSAnQ2FuXFwndCB2YWxpZGF0ZSgpIHRoZSBzYW1lIGRvYyBtdWx0aXBsZSB0aW1lcyBpbiBwYXJhbGxlbC4gRG9jdW1lbnQ6ICc7XG4gICAgc3VwZXIobXNnICsgZG9jLl9pZCk7XG4gIH1cbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFBhcmFsbGVsVmFsaWRhdGVFcnJvci5wcm90b3R5cGUsICduYW1lJywge1xuICB2YWx1ZTogJ1BhcmFsbGVsVmFsaWRhdGVFcnJvcidcbn0pO1xuXG4vKiFcbiAqIGV4cG9ydHNcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IFBhcmFsbGVsVmFsaWRhdGVFcnJvcjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../server/node_modules/mongoose/lib/error/parallelValidate.js\n");

/***/ }),

/***/ "../server/node_modules/mongoose/lib/error/serverSelection.js":
/*!********************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/error/serverSelection.js ***!
  \********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*!\n * Module dependencies.\n */\n\n\n\nconst MongooseError = __webpack_require__(/*! ./mongooseError */ \"../server/node_modules/mongoose/lib/error/mongooseError.js\");\nconst allServersUnknown = __webpack_require__(/*! ../helpers/topology/allServersUnknown */ \"../server/node_modules/mongoose/lib/helpers/topology/allServersUnknown.js\");\nconst isAtlas = __webpack_require__(/*! ../helpers/topology/isAtlas */ \"../server/node_modules/mongoose/lib/helpers/topology/isAtlas.js\");\nconst isSSLError = __webpack_require__(/*! ../helpers/topology/isSSLError */ \"../server/node_modules/mongoose/lib/helpers/topology/isSSLError.js\");\n\n/*!\n * ignore\n */\n\nconst atlasMessage = 'Could not connect to any servers in your MongoDB Atlas cluster. ' +\n  'One common reason is that you\\'re trying to access the database from ' +\n  'an IP that isn\\'t whitelisted. Make sure your current IP address is on your Atlas ' +\n  'cluster\\'s IP whitelist: https://www.mongodb.com/docs/atlas/security-whitelist/';\n\nconst sslMessage = 'Mongoose is connecting with SSL enabled, but the server is ' +\n  'not accepting SSL connections. Please ensure that the MongoDB server you are ' +\n  'connecting to is configured to accept SSL connections. Learn more: ' +\n  'https://mongoosejs.com/docs/tutorials/ssl.html';\n\nclass MongooseServerSelectionError extends MongooseError {\n  /**\n   * MongooseServerSelectionError constructor\n   *\n   * @api private\n   */\n  assimilateError(err) {\n    const reason = err.reason;\n    // Special message for a case that is likely due to IP whitelisting issues.\n    const isAtlasWhitelistError = isAtlas(reason) &&\n      allServersUnknown(reason) &&\n      err.message.indexOf('bad auth') === -1 &&\n      err.message.indexOf('Authentication failed') === -1;\n\n    if (isAtlasWhitelistError) {\n      this.message = atlasMessage;\n    } else if (isSSLError(reason)) {\n      this.message = sslMessage;\n    } else {\n      this.message = err.message;\n    }\n    for (const key in err) {\n      if (key !== 'name') {\n        this[key] = err[key];\n      }\n    }\n\n    return this;\n  }\n}\n\nObject.defineProperty(MongooseServerSelectionError.prototype, 'name', {\n  value: 'MongooseServerSelectionError'\n});\n\nmodule.exports = MongooseServerSelectionError;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvZXJyb3Ivc2VydmVyU2VsZWN0aW9uLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTs7QUFFYTs7QUFFYixzQkFBc0IsbUJBQU8sQ0FBQyxtRkFBaUI7QUFDL0MsMEJBQTBCLG1CQUFPLENBQUMsd0hBQXVDO0FBQ3pFLGdCQUFnQixtQkFBTyxDQUFDLG9HQUE2QjtBQUNyRCxtQkFBbUIsbUJBQU8sQ0FBQywwR0FBZ0M7O0FBRTNEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRCIsInNvdXJjZXMiOlsid2VicGFjazovL2NsaWVudC8uLi9zZXJ2ZXIvbm9kZV9tb2R1bGVzL21vbmdvb3NlL2xpYi9lcnJvci9zZXJ2ZXJTZWxlY3Rpb24uanM/NGI1OSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBNb25nb29zZUVycm9yID0gcmVxdWlyZSgnLi9tb25nb29zZUVycm9yJyk7XG5jb25zdCBhbGxTZXJ2ZXJzVW5rbm93biA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvdG9wb2xvZ3kvYWxsU2VydmVyc1Vua25vd24nKTtcbmNvbnN0IGlzQXRsYXMgPSByZXF1aXJlKCcuLi9oZWxwZXJzL3RvcG9sb2d5L2lzQXRsYXMnKTtcbmNvbnN0IGlzU1NMRXJyb3IgPSByZXF1aXJlKCcuLi9oZWxwZXJzL3RvcG9sb2d5L2lzU1NMRXJyb3InKTtcblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5jb25zdCBhdGxhc01lc3NhZ2UgPSAnQ291bGQgbm90IGNvbm5lY3QgdG8gYW55IHNlcnZlcnMgaW4geW91ciBNb25nb0RCIEF0bGFzIGNsdXN0ZXIuICcgK1xuICAnT25lIGNvbW1vbiByZWFzb24gaXMgdGhhdCB5b3VcXCdyZSB0cnlpbmcgdG8gYWNjZXNzIHRoZSBkYXRhYmFzZSBmcm9tICcgK1xuICAnYW4gSVAgdGhhdCBpc25cXCd0IHdoaXRlbGlzdGVkLiBNYWtlIHN1cmUgeW91ciBjdXJyZW50IElQIGFkZHJlc3MgaXMgb24geW91ciBBdGxhcyAnICtcbiAgJ2NsdXN0ZXJcXCdzIElQIHdoaXRlbGlzdDogaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9hdGxhcy9zZWN1cml0eS13aGl0ZWxpc3QvJztcblxuY29uc3Qgc3NsTWVzc2FnZSA9ICdNb25nb29zZSBpcyBjb25uZWN0aW5nIHdpdGggU1NMIGVuYWJsZWQsIGJ1dCB0aGUgc2VydmVyIGlzICcgK1xuICAnbm90IGFjY2VwdGluZyBTU0wgY29ubmVjdGlvbnMuIFBsZWFzZSBlbnN1cmUgdGhhdCB0aGUgTW9uZ29EQiBzZXJ2ZXIgeW91IGFyZSAnICtcbiAgJ2Nvbm5lY3RpbmcgdG8gaXMgY29uZmlndXJlZCB0byBhY2NlcHQgU1NMIGNvbm5lY3Rpb25zLiBMZWFybiBtb3JlOiAnICtcbiAgJ2h0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy90dXRvcmlhbHMvc3NsLmh0bWwnO1xuXG5jbGFzcyBNb25nb29zZVNlcnZlclNlbGVjdGlvbkVycm9yIGV4dGVuZHMgTW9uZ29vc2VFcnJvciB7XG4gIC8qKlxuICAgKiBNb25nb29zZVNlcnZlclNlbGVjdGlvbkVycm9yIGNvbnN0cnVjdG9yXG4gICAqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgYXNzaW1pbGF0ZUVycm9yKGVycikge1xuICAgIGNvbnN0IHJlYXNvbiA9IGVyci5yZWFzb247XG4gICAgLy8gU3BlY2lhbCBtZXNzYWdlIGZvciBhIGNhc2UgdGhhdCBpcyBsaWtlbHkgZHVlIHRvIElQIHdoaXRlbGlzdGluZyBpc3N1ZXMuXG4gICAgY29uc3QgaXNBdGxhc1doaXRlbGlzdEVycm9yID0gaXNBdGxhcyhyZWFzb24pICYmXG4gICAgICBhbGxTZXJ2ZXJzVW5rbm93bihyZWFzb24pICYmXG4gICAgICBlcnIubWVzc2FnZS5pbmRleE9mKCdiYWQgYXV0aCcpID09PSAtMSAmJlxuICAgICAgZXJyLm1lc3NhZ2UuaW5kZXhPZignQXV0aGVudGljYXRpb24gZmFpbGVkJykgPT09IC0xO1xuXG4gICAgaWYgKGlzQXRsYXNXaGl0ZWxpc3RFcnJvcikge1xuICAgICAgdGhpcy5tZXNzYWdlID0gYXRsYXNNZXNzYWdlO1xuICAgIH0gZWxzZSBpZiAoaXNTU0xFcnJvcihyZWFzb24pKSB7XG4gICAgICB0aGlzLm1lc3NhZ2UgPSBzc2xNZXNzYWdlO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLm1lc3NhZ2UgPSBlcnIubWVzc2FnZTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBrZXkgaW4gZXJyKSB7XG4gICAgICBpZiAoa2V5ICE9PSAnbmFtZScpIHtcbiAgICAgICAgdGhpc1trZXldID0gZXJyW2tleV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KE1vbmdvb3NlU2VydmVyU2VsZWN0aW9uRXJyb3IucHJvdG90eXBlLCAnbmFtZScsIHtcbiAgdmFsdWU6ICdNb25nb29zZVNlcnZlclNlbGVjdGlvbkVycm9yJ1xufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gTW9uZ29vc2VTZXJ2ZXJTZWxlY3Rpb25FcnJvcjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../server/node_modules/mongoose/lib/error/serverSelection.js\n");

/***/ }),

/***/ "../server/node_modules/mongoose/lib/error/setOptionError.js":
/*!*******************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/error/setOptionError.js ***!
  \*******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*!\n * Module requirements\n */\n\n\n\nconst MongooseError = __webpack_require__(/*! ./mongooseError */ \"../server/node_modules/mongoose/lib/error/mongooseError.js\");\nconst util = __webpack_require__(/*! util */ \"util\");\nconst combinePathErrors = __webpack_require__(/*! ../helpers/error/combinePathErrors */ \"../server/node_modules/mongoose/lib/helpers/error/combinePathErrors.js\");\n\nclass SetOptionError extends MongooseError {\n  /**\n   * Mongoose.set Error\n   *\n   * @api private\n   * @inherits MongooseError\n   */\n  constructor() {\n    super('');\n\n    this.errors = {};\n  }\n\n  /**\n   * Console.log helper\n   */\n  toString() {\n    return combinePathErrors(this);\n  }\n\n  /**\n   * inspect helper\n   * @api private\n   */\n  inspect() {\n    return Object.assign(new Error(this.message), this);\n  }\n\n  /**\n  * add message\n  * @param {String} key\n  * @param {String|Error} error\n  * @api private\n  */\n  addError(key, error) {\n    if (error instanceof SetOptionError) {\n      const { errors } = error;\n      for (const optionKey of Object.keys(errors)) {\n        this.addError(optionKey, errors[optionKey]);\n      }\n\n      return;\n    }\n\n    this.errors[key] = error;\n    this.message = combinePathErrors(this);\n  }\n}\n\n\nif (util.inspect.custom) {\n  // Avoid Node deprecation warning DEP0079\n  SetOptionError.prototype[util.inspect.custom] = SetOptionError.prototype.inspect;\n}\n\n/**\n * Helper for JSON.stringify\n * Ensure `name` and `message` show up in toJSON output re: gh-9847\n * @api private\n */\nObject.defineProperty(SetOptionError.prototype, 'toJSON', {\n  enumerable: false,\n  writable: false,\n  configurable: true,\n  value: function() {\n    return Object.assign({}, this, { name: this.name, message: this.message });\n  }\n});\n\n\nObject.defineProperty(SetOptionError.prototype, 'name', {\n  value: 'SetOptionError'\n});\n\nclass SetOptionInnerError extends MongooseError {\n  /**\n   * Error for the \"errors\" array in \"SetOptionError\" with consistent message\n   * @param {String} key\n   */\n  constructor(key) {\n    super(`\"${key}\" is not a valid option to set`);\n  }\n}\n\nSetOptionError.SetOptionInnerError = SetOptionInnerError;\n\n/*!\n * Module exports\n */\n\nmodule.exports = SetOptionError;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvZXJyb3Ivc2V0T3B0aW9uRXJyb3IuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBOztBQUVhOztBQUViLHNCQUFzQixtQkFBTyxDQUFDLG1GQUFpQjtBQUMvQyxhQUFhLG1CQUFPLENBQUMsa0JBQU07QUFDM0IsMEJBQTBCLG1CQUFPLENBQUMsa0hBQW9DOztBQUV0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQixZQUFZLGNBQWM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFNBQVM7QUFDdkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLFVBQVUsd0NBQXdDO0FBQzdFO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQSxjQUFjLElBQUk7QUFDbEI7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbGllbnQvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvZXJyb3Ivc2V0T3B0aW9uRXJyb3IuanM/YjQ0MyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIE1vZHVsZSByZXF1aXJlbWVudHNcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbmNvbnN0IE1vbmdvb3NlRXJyb3IgPSByZXF1aXJlKCcuL21vbmdvb3NlRXJyb3InKTtcbmNvbnN0IHV0aWwgPSByZXF1aXJlKCd1dGlsJyk7XG5jb25zdCBjb21iaW5lUGF0aEVycm9ycyA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvZXJyb3IvY29tYmluZVBhdGhFcnJvcnMnKTtcblxuY2xhc3MgU2V0T3B0aW9uRXJyb3IgZXh0ZW5kcyBNb25nb29zZUVycm9yIHtcbiAgLyoqXG4gICAqIE1vbmdvb3NlLnNldCBFcnJvclxuICAgKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICogQGluaGVyaXRzIE1vbmdvb3NlRXJyb3JcbiAgICovXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCcnKTtcblxuICAgIHRoaXMuZXJyb3JzID0ge307XG4gIH1cblxuICAvKipcbiAgICogQ29uc29sZS5sb2cgaGVscGVyXG4gICAqL1xuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gY29tYmluZVBhdGhFcnJvcnModGhpcyk7XG4gIH1cblxuICAvKipcbiAgICogaW5zcGVjdCBoZWxwZXJcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBpbnNwZWN0KCkge1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKG5ldyBFcnJvcih0aGlzLm1lc3NhZ2UpLCB0aGlzKTtcbiAgfVxuXG4gIC8qKlxuICAqIGFkZCBtZXNzYWdlXG4gICogQHBhcmFtIHtTdHJpbmd9IGtleVxuICAqIEBwYXJhbSB7U3RyaW5nfEVycm9yfSBlcnJvclxuICAqIEBhcGkgcHJpdmF0ZVxuICAqL1xuICBhZGRFcnJvcihrZXksIGVycm9yKSB7XG4gICAgaWYgKGVycm9yIGluc3RhbmNlb2YgU2V0T3B0aW9uRXJyb3IpIHtcbiAgICAgIGNvbnN0IHsgZXJyb3JzIH0gPSBlcnJvcjtcbiAgICAgIGZvciAoY29uc3Qgb3B0aW9uS2V5IG9mIE9iamVjdC5rZXlzKGVycm9ycykpIHtcbiAgICAgICAgdGhpcy5hZGRFcnJvcihvcHRpb25LZXksIGVycm9yc1tvcHRpb25LZXldKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuZXJyb3JzW2tleV0gPSBlcnJvcjtcbiAgICB0aGlzLm1lc3NhZ2UgPSBjb21iaW5lUGF0aEVycm9ycyh0aGlzKTtcbiAgfVxufVxuXG5cbmlmICh1dGlsLmluc3BlY3QuY3VzdG9tKSB7XG4gIC8vIEF2b2lkIE5vZGUgZGVwcmVjYXRpb24gd2FybmluZyBERVAwMDc5XG4gIFNldE9wdGlvbkVycm9yLnByb3RvdHlwZVt1dGlsLmluc3BlY3QuY3VzdG9tXSA9IFNldE9wdGlvbkVycm9yLnByb3RvdHlwZS5pbnNwZWN0O1xufVxuXG4vKipcbiAqIEhlbHBlciBmb3IgSlNPTi5zdHJpbmdpZnlcbiAqIEVuc3VyZSBgbmFtZWAgYW5kIGBtZXNzYWdlYCBzaG93IHVwIGluIHRvSlNPTiBvdXRwdXQgcmU6IGdoLTk4NDdcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoU2V0T3B0aW9uRXJyb3IucHJvdG90eXBlLCAndG9KU09OJywge1xuICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgd3JpdGFibGU6IGZhbHNlLFxuICBjb25maWd1cmFibGU6IHRydWUsXG4gIHZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgdGhpcywgeyBuYW1lOiB0aGlzLm5hbWUsIG1lc3NhZ2U6IHRoaXMubWVzc2FnZSB9KTtcbiAgfVxufSk7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFNldE9wdGlvbkVycm9yLnByb3RvdHlwZSwgJ25hbWUnLCB7XG4gIHZhbHVlOiAnU2V0T3B0aW9uRXJyb3InXG59KTtcblxuY2xhc3MgU2V0T3B0aW9uSW5uZXJFcnJvciBleHRlbmRzIE1vbmdvb3NlRXJyb3Ige1xuICAvKipcbiAgICogRXJyb3IgZm9yIHRoZSBcImVycm9yc1wiIGFycmF5IGluIFwiU2V0T3B0aW9uRXJyb3JcIiB3aXRoIGNvbnNpc3RlbnQgbWVzc2FnZVxuICAgKiBAcGFyYW0ge1N0cmluZ30ga2V5XG4gICAqL1xuICBjb25zdHJ1Y3RvcihrZXkpIHtcbiAgICBzdXBlcihgXCIke2tleX1cIiBpcyBub3QgYSB2YWxpZCBvcHRpb24gdG8gc2V0YCk7XG4gIH1cbn1cblxuU2V0T3B0aW9uRXJyb3IuU2V0T3B0aW9uSW5uZXJFcnJvciA9IFNldE9wdGlvbklubmVyRXJyb3I7XG5cbi8qIVxuICogTW9kdWxlIGV4cG9ydHNcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNldE9wdGlvbkVycm9yO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../server/node_modules/mongoose/lib/error/setOptionError.js\n");

/***/ }),

/***/ "../server/node_modules/mongoose/lib/error/strict.js":
/*!***********************************************************!*\
  !*** ../server/node_modules/mongoose/lib/error/strict.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*!\n * Module dependencies.\n */\n\n\n\nconst MongooseError = __webpack_require__(/*! ./ */ \"../server/node_modules/mongoose/lib/error/index.js\");\n\n\nclass StrictModeError extends MongooseError {\n  /**\n   * Strict mode error constructor\n   *\n   * @param {String} path\n   * @param {String} [msg]\n   * @param {Boolean} [immutable]\n   * @inherits MongooseError\n   * @api private\n   */\n  constructor(path, msg, immutable) {\n    msg = msg || 'Field `' + path + '` is not in schema and strict ' +\n      'mode is set to throw.';\n    super(msg);\n    this.isImmutableError = !!immutable;\n    this.path = path;\n  }\n}\n\nObject.defineProperty(StrictModeError.prototype, 'name', {\n  value: 'StrictModeError'\n});\n\nmodule.exports = StrictModeError;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvZXJyb3Ivc3RyaWN0LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTs7QUFFYTs7QUFFYixzQkFBc0IsbUJBQU8sQ0FBQyw4REFBSTs7O0FBR2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQixhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRCIsInNvdXJjZXMiOlsid2VicGFjazovL2NsaWVudC8uLi9zZXJ2ZXIvbm9kZV9tb2R1bGVzL21vbmdvb3NlL2xpYi9lcnJvci9zdHJpY3QuanM/OWY4NSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBNb25nb29zZUVycm9yID0gcmVxdWlyZSgnLi8nKTtcblxuXG5jbGFzcyBTdHJpY3RNb2RlRXJyb3IgZXh0ZW5kcyBNb25nb29zZUVycm9yIHtcbiAgLyoqXG4gICAqIFN0cmljdCBtb2RlIGVycm9yIGNvbnN0cnVjdG9yXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbbXNnXVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtpbW11dGFibGVdXG4gICAqIEBpbmhlcml0cyBNb25nb29zZUVycm9yXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgY29uc3RydWN0b3IocGF0aCwgbXNnLCBpbW11dGFibGUpIHtcbiAgICBtc2cgPSBtc2cgfHwgJ0ZpZWxkIGAnICsgcGF0aCArICdgIGlzIG5vdCBpbiBzY2hlbWEgYW5kIHN0cmljdCAnICtcbiAgICAgICdtb2RlIGlzIHNldCB0byB0aHJvdy4nO1xuICAgIHN1cGVyKG1zZyk7XG4gICAgdGhpcy5pc0ltbXV0YWJsZUVycm9yID0gISFpbW11dGFibGU7XG4gICAgdGhpcy5wYXRoID0gcGF0aDtcbiAgfVxufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoU3RyaWN0TW9kZUVycm9yLnByb3RvdHlwZSwgJ25hbWUnLCB7XG4gIHZhbHVlOiAnU3RyaWN0TW9kZUVycm9yJ1xufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gU3RyaWN0TW9kZUVycm9yO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../server/node_modules/mongoose/lib/error/strict.js\n");

/***/ }),

/***/ "../server/node_modules/mongoose/lib/error/strictPopulate.js":
/*!*******************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/error/strictPopulate.js ***!
  \*******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*!\n * Module dependencies.\n */\n\n\n\nconst MongooseError = __webpack_require__(/*! ./ */ \"../server/node_modules/mongoose/lib/error/index.js\");\n\nclass StrictPopulateError extends MongooseError {\n  /**\n   * Strict mode error constructor\n   *\n   * @param {String} path\n   * @param {String} [msg]\n   * @inherits MongooseError\n   * @api private\n   */\n  constructor(path, msg) {\n    msg = msg || 'Cannot populate path `' + path + '` because it is not in your schema. ' + 'Set the `strictPopulate` option to false to override.';\n    super(msg);\n    this.path = path;\n  }\n}\n\nObject.defineProperty(StrictPopulateError.prototype, 'name', {\n  value: 'StrictPopulateError'\n});\n\nmodule.exports = StrictPopulateError;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvZXJyb3Ivc3RyaWN0UG9wdWxhdGUuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBOztBQUVhOztBQUViLHNCQUFzQixtQkFBTyxDQUFDLDhEQUFJOztBQUVsQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOztBQUVEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2xpZW50Ly4uL3NlcnZlci9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2Vycm9yL3N0cmljdFBvcHVsYXRlLmpzPzMxYmMiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuY29uc3QgTW9uZ29vc2VFcnJvciA9IHJlcXVpcmUoJy4vJyk7XG5cbmNsYXNzIFN0cmljdFBvcHVsYXRlRXJyb3IgZXh0ZW5kcyBNb25nb29zZUVycm9yIHtcbiAgLyoqXG4gICAqIFN0cmljdCBtb2RlIGVycm9yIGNvbnN0cnVjdG9yXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbbXNnXVxuICAgKiBAaW5oZXJpdHMgTW9uZ29vc2VFcnJvclxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIGNvbnN0cnVjdG9yKHBhdGgsIG1zZykge1xuICAgIG1zZyA9IG1zZyB8fCAnQ2Fubm90IHBvcHVsYXRlIHBhdGggYCcgKyBwYXRoICsgJ2AgYmVjYXVzZSBpdCBpcyBub3QgaW4geW91ciBzY2hlbWEuICcgKyAnU2V0IHRoZSBgc3RyaWN0UG9wdWxhdGVgIG9wdGlvbiB0byBmYWxzZSB0byBvdmVycmlkZS4nO1xuICAgIHN1cGVyKG1zZyk7XG4gICAgdGhpcy5wYXRoID0gcGF0aDtcbiAgfVxufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoU3RyaWN0UG9wdWxhdGVFcnJvci5wcm90b3R5cGUsICduYW1lJywge1xuICB2YWx1ZTogJ1N0cmljdFBvcHVsYXRlRXJyb3InXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBTdHJpY3RQb3B1bGF0ZUVycm9yO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../server/node_modules/mongoose/lib/error/strictPopulate.js\n");

/***/ }),

/***/ "../server/node_modules/mongoose/lib/error/syncIndexes.js":
/*!****************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/error/syncIndexes.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\n/*!\n * Module dependencies.\n */\n\nconst MongooseError = __webpack_require__(/*! ./mongooseError */ \"../server/node_modules/mongoose/lib/error/mongooseError.js\");\n\n/**\n * SyncIndexes Error constructor.\n *\n * @param {String} message\n * @param {String} errorsMap\n * @inherits MongooseError\n * @api private\n */\n\nclass SyncIndexesError extends MongooseError {\n  constructor(message, errorsMap) {\n    super(message);\n    this.errors = errorsMap;\n  }\n}\n\nObject.defineProperty(SyncIndexesError.prototype, 'name', {\n  value: 'SyncIndexesError'\n});\n\n\nmodule.exports = SyncIndexesError;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvZXJyb3Ivc3luY0luZGV4ZXMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7QUFDQTtBQUNBOztBQUVBLHNCQUFzQixtQkFBTyxDQUFDLG1GQUFpQjs7QUFFL0M7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOzs7QUFHRCIsInNvdXJjZXMiOlsid2VicGFjazovL2NsaWVudC8uLi9zZXJ2ZXIvbm9kZV9tb2R1bGVzL21vbmdvb3NlL2xpYi9lcnJvci9zeW5jSW5kZXhlcy5qcz9mZDRmIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuLyohXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbmNvbnN0IE1vbmdvb3NlRXJyb3IgPSByZXF1aXJlKCcuL21vbmdvb3NlRXJyb3InKTtcblxuLyoqXG4gKiBTeW5jSW5kZXhlcyBFcnJvciBjb25zdHJ1Y3Rvci5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICogQHBhcmFtIHtTdHJpbmd9IGVycm9yc01hcFxuICogQGluaGVyaXRzIE1vbmdvb3NlRXJyb3JcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmNsYXNzIFN5bmNJbmRleGVzRXJyb3IgZXh0ZW5kcyBNb25nb29zZUVycm9yIHtcbiAgY29uc3RydWN0b3IobWVzc2FnZSwgZXJyb3JzTWFwKSB7XG4gICAgc3VwZXIobWVzc2FnZSk7XG4gICAgdGhpcy5lcnJvcnMgPSBlcnJvcnNNYXA7XG4gIH1cbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFN5bmNJbmRleGVzRXJyb3IucHJvdG90eXBlLCAnbmFtZScsIHtcbiAgdmFsdWU6ICdTeW5jSW5kZXhlc0Vycm9yJ1xufSk7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBTeW5jSW5kZXhlc0Vycm9yO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../server/node_modules/mongoose/lib/error/syncIndexes.js\n");

/***/ }),

/***/ "../server/node_modules/mongoose/lib/error/validation.js":
/*!***************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/error/validation.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*!\n * Module requirements\n */\n\n\n\nconst MongooseError = __webpack_require__(/*! ./mongooseError */ \"../server/node_modules/mongoose/lib/error/mongooseError.js\");\nconst getConstructorName = __webpack_require__(/*! ../helpers/getConstructorName */ \"../server/node_modules/mongoose/lib/helpers/getConstructorName.js\");\nconst util = __webpack_require__(/*! util */ \"util\");\nconst combinePathErrors = __webpack_require__(/*! ../helpers/error/combinePathErrors */ \"../server/node_modules/mongoose/lib/helpers/error/combinePathErrors.js\");\n\nclass ValidationError extends MongooseError {\n  /**\n   * Document Validation Error\n   *\n   * @api private\n   * @param {Document} [instance]\n   * @inherits MongooseError\n   */\n  constructor(instance) {\n    let _message;\n    if (getConstructorName(instance) === 'model') {\n      _message = instance.constructor.modelName + ' validation failed';\n    } else {\n      _message = 'Validation failed';\n    }\n\n    super(_message);\n\n    this.errors = {};\n    this._message = _message;\n\n    if (instance) {\n      instance.$errors = this.errors;\n    }\n  }\n\n  /**\n   * Console.log helper\n   */\n  toString() {\n    return this.name + ': ' + combinePathErrors(this);\n  }\n\n  /**\n   * inspect helper\n   * @api private\n   */\n  inspect() {\n    return Object.assign(new Error(this.message), this);\n  }\n\n  /**\n  * add message\n  * @param {String} path\n  * @param {String|Error} error\n  * @api private\n  */\n  addError(path, error) {\n    if (error instanceof ValidationError) {\n      const { errors } = error;\n      for (const errorPath of Object.keys(errors)) {\n        this.addError(`${path}.${errorPath}`, errors[errorPath]);\n      }\n\n      return;\n    }\n\n    this.errors[path] = error;\n    this.message = this._message + ': ' + combinePathErrors(this);\n  }\n}\n\n\nif (util.inspect.custom) {\n  // Avoid Node deprecation warning DEP0079\n  ValidationError.prototype[util.inspect.custom] = ValidationError.prototype.inspect;\n}\n\n/**\n * Helper for JSON.stringify\n * Ensure `name` and `message` show up in toJSON output re: gh-9847\n * @api private\n */\nObject.defineProperty(ValidationError.prototype, 'toJSON', {\n  enumerable: false,\n  writable: false,\n  configurable: true,\n  value: function() {\n    return Object.assign({}, this, { name: this.name, message: this.message });\n  }\n});\n\n\nObject.defineProperty(ValidationError.prototype, 'name', {\n  value: 'ValidationError'\n});\n\n/*!\n * Module exports\n */\n\nmodule.exports = ValidationError;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvZXJyb3IvdmFsaWRhdGlvbi5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7O0FBRWE7O0FBRWIsc0JBQXNCLG1CQUFPLENBQUMsbUZBQWlCO0FBQy9DLDJCQUEyQixtQkFBTyxDQUFDLHdHQUErQjtBQUNsRSxhQUFhLG1CQUFPLENBQUMsa0JBQU07QUFDM0IsMEJBQTBCLG1CQUFPLENBQUMsa0hBQW9DOztBQUV0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxVQUFVO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEIsWUFBWSxjQUFjO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0EseUJBQXlCLEtBQUssR0FBRyxVQUFVO0FBQzNDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLFVBQVUsd0NBQXdDO0FBQzdFO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2xpZW50Ly4uL3NlcnZlci9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2Vycm9yL3ZhbGlkYXRpb24uanM/MTZhNSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIE1vZHVsZSByZXF1aXJlbWVudHNcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbmNvbnN0IE1vbmdvb3NlRXJyb3IgPSByZXF1aXJlKCcuL21vbmdvb3NlRXJyb3InKTtcbmNvbnN0IGdldENvbnN0cnVjdG9yTmFtZSA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvZ2V0Q29uc3RydWN0b3JOYW1lJyk7XG5jb25zdCB1dGlsID0gcmVxdWlyZSgndXRpbCcpO1xuY29uc3QgY29tYmluZVBhdGhFcnJvcnMgPSByZXF1aXJlKCcuLi9oZWxwZXJzL2Vycm9yL2NvbWJpbmVQYXRoRXJyb3JzJyk7XG5cbmNsYXNzIFZhbGlkYXRpb25FcnJvciBleHRlbmRzIE1vbmdvb3NlRXJyb3Ige1xuICAvKipcbiAgICogRG9jdW1lbnQgVmFsaWRhdGlvbiBFcnJvclxuICAgKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICogQHBhcmFtIHtEb2N1bWVudH0gW2luc3RhbmNlXVxuICAgKiBAaW5oZXJpdHMgTW9uZ29vc2VFcnJvclxuICAgKi9cbiAgY29uc3RydWN0b3IoaW5zdGFuY2UpIHtcbiAgICBsZXQgX21lc3NhZ2U7XG4gICAgaWYgKGdldENvbnN0cnVjdG9yTmFtZShpbnN0YW5jZSkgPT09ICdtb2RlbCcpIHtcbiAgICAgIF9tZXNzYWdlID0gaW5zdGFuY2UuY29uc3RydWN0b3IubW9kZWxOYW1lICsgJyB2YWxpZGF0aW9uIGZhaWxlZCc7XG4gICAgfSBlbHNlIHtcbiAgICAgIF9tZXNzYWdlID0gJ1ZhbGlkYXRpb24gZmFpbGVkJztcbiAgICB9XG5cbiAgICBzdXBlcihfbWVzc2FnZSk7XG5cbiAgICB0aGlzLmVycm9ycyA9IHt9O1xuICAgIHRoaXMuX21lc3NhZ2UgPSBfbWVzc2FnZTtcblxuICAgIGlmIChpbnN0YW5jZSkge1xuICAgICAgaW5zdGFuY2UuJGVycm9ycyA9IHRoaXMuZXJyb3JzO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDb25zb2xlLmxvZyBoZWxwZXJcbiAgICovXG4gIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLm5hbWUgKyAnOiAnICsgY29tYmluZVBhdGhFcnJvcnModGhpcyk7XG4gIH1cblxuICAvKipcbiAgICogaW5zcGVjdCBoZWxwZXJcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBpbnNwZWN0KCkge1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKG5ldyBFcnJvcih0aGlzLm1lc3NhZ2UpLCB0aGlzKTtcbiAgfVxuXG4gIC8qKlxuICAqIGFkZCBtZXNzYWdlXG4gICogQHBhcmFtIHtTdHJpbmd9IHBhdGhcbiAgKiBAcGFyYW0ge1N0cmluZ3xFcnJvcn0gZXJyb3JcbiAgKiBAYXBpIHByaXZhdGVcbiAgKi9cbiAgYWRkRXJyb3IocGF0aCwgZXJyb3IpIHtcbiAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBWYWxpZGF0aW9uRXJyb3IpIHtcbiAgICAgIGNvbnN0IHsgZXJyb3JzIH0gPSBlcnJvcjtcbiAgICAgIGZvciAoY29uc3QgZXJyb3JQYXRoIG9mIE9iamVjdC5rZXlzKGVycm9ycykpIHtcbiAgICAgICAgdGhpcy5hZGRFcnJvcihgJHtwYXRofS4ke2Vycm9yUGF0aH1gLCBlcnJvcnNbZXJyb3JQYXRoXSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLmVycm9yc1twYXRoXSA9IGVycm9yO1xuICAgIHRoaXMubWVzc2FnZSA9IHRoaXMuX21lc3NhZ2UgKyAnOiAnICsgY29tYmluZVBhdGhFcnJvcnModGhpcyk7XG4gIH1cbn1cblxuXG5pZiAodXRpbC5pbnNwZWN0LmN1c3RvbSkge1xuICAvLyBBdm9pZCBOb2RlIGRlcHJlY2F0aW9uIHdhcm5pbmcgREVQMDA3OVxuICBWYWxpZGF0aW9uRXJyb3IucHJvdG90eXBlW3V0aWwuaW5zcGVjdC5jdXN0b21dID0gVmFsaWRhdGlvbkVycm9yLnByb3RvdHlwZS5pbnNwZWN0O1xufVxuXG4vKipcbiAqIEhlbHBlciBmb3IgSlNPTi5zdHJpbmdpZnlcbiAqIEVuc3VyZSBgbmFtZWAgYW5kIGBtZXNzYWdlYCBzaG93IHVwIGluIHRvSlNPTiBvdXRwdXQgcmU6IGdoLTk4NDdcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoVmFsaWRhdGlvbkVycm9yLnByb3RvdHlwZSwgJ3RvSlNPTicsIHtcbiAgZW51bWVyYWJsZTogZmFsc2UsXG4gIHdyaXRhYmxlOiBmYWxzZSxcbiAgY29uZmlndXJhYmxlOiB0cnVlLFxuICB2YWx1ZTogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIHRoaXMsIHsgbmFtZTogdGhpcy5uYW1lLCBtZXNzYWdlOiB0aGlzLm1lc3NhZ2UgfSk7XG4gIH1cbn0pO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShWYWxpZGF0aW9uRXJyb3IucHJvdG90eXBlLCAnbmFtZScsIHtcbiAgdmFsdWU6ICdWYWxpZGF0aW9uRXJyb3InXG59KTtcblxuLyohXG4gKiBNb2R1bGUgZXhwb3J0c1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0gVmFsaWRhdGlvbkVycm9yO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../server/node_modules/mongoose/lib/error/validation.js\n");

/***/ }),

/***/ "../server/node_modules/mongoose/lib/error/validator.js":
/*!**************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/error/validator.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*!\n * Module dependencies.\n */\n\n\n\nconst MongooseError = __webpack_require__(/*! ./ */ \"../server/node_modules/mongoose/lib/error/index.js\");\n\n\nclass ValidatorError extends MongooseError {\n  /**\n   * Schema validator error\n   *\n   * @param {Object} properties\n   * @param {Document} doc\n   * @api private\n   */\n  constructor(properties, doc) {\n    let msg = properties.message;\n    if (!msg) {\n      msg = MongooseError.messages.general.default;\n    }\n\n    const message = formatMessage(msg, properties, doc);\n    super(message);\n\n    properties = Object.assign({}, properties, { message: message });\n    this.properties = properties;\n    this.kind = properties.type;\n    this.path = properties.path;\n    this.value = properties.value;\n    this.reason = properties.reason;\n  }\n\n  /**\n   * toString helper\n   * TODO remove? This defaults to `${this.name}: ${this.message}`\n   * @api private\n   */\n  toString() {\n    return this.message;\n  }\n\n  /**\n   * Ensure `name` and `message` show up in toJSON output re: gh-9296\n   * @api private\n   */\n\n  toJSON() {\n    return Object.assign({ name: this.name, message: this.message }, this);\n  }\n}\n\n\nObject.defineProperty(ValidatorError.prototype, 'name', {\n  value: 'ValidatorError'\n});\n\n/**\n * The object used to define this validator. Not enumerable to hide\n * it from `require('util').inspect()` output re: gh-3925\n * @api private\n */\n\nObject.defineProperty(ValidatorError.prototype, 'properties', {\n  enumerable: false,\n  writable: true,\n  value: null\n});\n\n// Exposed for testing\nValidatorError.prototype.formatMessage = formatMessage;\n\n/**\n * Formats error messages\n * @api private\n */\n\nfunction formatMessage(msg, properties, doc) {\n  if (typeof msg === 'function') {\n    return msg(properties, doc);\n  }\n\n  const propertyNames = Object.keys(properties);\n  for (const propertyName of propertyNames) {\n    if (propertyName === 'message') {\n      continue;\n    }\n    msg = msg.replace('{' + propertyName.toUpperCase() + '}', properties[propertyName]);\n  }\n\n  return msg;\n}\n\n/*!\n * exports\n */\n\nmodule.exports = ValidatorError;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvZXJyb3IvdmFsaWRhdG9yLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTs7QUFFYTs7QUFFYixzQkFBc0IsbUJBQU8sQ0FBQyw4REFBSTs7O0FBR2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsVUFBVTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGlDQUFpQyxnQkFBZ0Isa0JBQWtCO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esc0NBQXNDLFVBQVUsSUFBSSxhQUFhO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyQkFBMkIsd0NBQXdDO0FBQ25FO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixtQ0FBbUM7QUFDM0Q7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbGllbnQvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvZXJyb3IvdmFsaWRhdG9yLmpzP2M0ZmQiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuY29uc3QgTW9uZ29vc2VFcnJvciA9IHJlcXVpcmUoJy4vJyk7XG5cblxuY2xhc3MgVmFsaWRhdG9yRXJyb3IgZXh0ZW5kcyBNb25nb29zZUVycm9yIHtcbiAgLyoqXG4gICAqIFNjaGVtYSB2YWxpZGF0b3IgZXJyb3JcbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IHByb3BlcnRpZXNcbiAgICogQHBhcmFtIHtEb2N1bWVudH0gZG9jXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgY29uc3RydWN0b3IocHJvcGVydGllcywgZG9jKSB7XG4gICAgbGV0IG1zZyA9IHByb3BlcnRpZXMubWVzc2FnZTtcbiAgICBpZiAoIW1zZykge1xuICAgICAgbXNnID0gTW9uZ29vc2VFcnJvci5tZXNzYWdlcy5nZW5lcmFsLmRlZmF1bHQ7XG4gICAgfVxuXG4gICAgY29uc3QgbWVzc2FnZSA9IGZvcm1hdE1lc3NhZ2UobXNnLCBwcm9wZXJ0aWVzLCBkb2MpO1xuICAgIHN1cGVyKG1lc3NhZ2UpO1xuXG4gICAgcHJvcGVydGllcyA9IE9iamVjdC5hc3NpZ24oe30sIHByb3BlcnRpZXMsIHsgbWVzc2FnZTogbWVzc2FnZSB9KTtcbiAgICB0aGlzLnByb3BlcnRpZXMgPSBwcm9wZXJ0aWVzO1xuICAgIHRoaXMua2luZCA9IHByb3BlcnRpZXMudHlwZTtcbiAgICB0aGlzLnBhdGggPSBwcm9wZXJ0aWVzLnBhdGg7XG4gICAgdGhpcy52YWx1ZSA9IHByb3BlcnRpZXMudmFsdWU7XG4gICAgdGhpcy5yZWFzb24gPSBwcm9wZXJ0aWVzLnJlYXNvbjtcbiAgfVxuXG4gIC8qKlxuICAgKiB0b1N0cmluZyBoZWxwZXJcbiAgICogVE9ETyByZW1vdmU/IFRoaXMgZGVmYXVsdHMgdG8gYCR7dGhpcy5uYW1lfTogJHt0aGlzLm1lc3NhZ2V9YFxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLm1lc3NhZ2U7XG4gIH1cblxuICAvKipcbiAgICogRW5zdXJlIGBuYW1lYCBhbmQgYG1lc3NhZ2VgIHNob3cgdXAgaW4gdG9KU09OIG91dHB1dCByZTogZ2gtOTI5NlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG5cbiAgdG9KU09OKCkge1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKHsgbmFtZTogdGhpcy5uYW1lLCBtZXNzYWdlOiB0aGlzLm1lc3NhZ2UgfSwgdGhpcyk7XG4gIH1cbn1cblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoVmFsaWRhdG9yRXJyb3IucHJvdG90eXBlLCAnbmFtZScsIHtcbiAgdmFsdWU6ICdWYWxpZGF0b3JFcnJvcidcbn0pO1xuXG4vKipcbiAqIFRoZSBvYmplY3QgdXNlZCB0byBkZWZpbmUgdGhpcyB2YWxpZGF0b3IuIE5vdCBlbnVtZXJhYmxlIHRvIGhpZGVcbiAqIGl0IGZyb20gYHJlcXVpcmUoJ3V0aWwnKS5pbnNwZWN0KClgIG91dHB1dCByZTogZ2gtMzkyNVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFZhbGlkYXRvckVycm9yLnByb3RvdHlwZSwgJ3Byb3BlcnRpZXMnLCB7XG4gIGVudW1lcmFibGU6IGZhbHNlLFxuICB3cml0YWJsZTogdHJ1ZSxcbiAgdmFsdWU6IG51bGxcbn0pO1xuXG4vLyBFeHBvc2VkIGZvciB0ZXN0aW5nXG5WYWxpZGF0b3JFcnJvci5wcm90b3R5cGUuZm9ybWF0TWVzc2FnZSA9IGZvcm1hdE1lc3NhZ2U7XG5cbi8qKlxuICogRm9ybWF0cyBlcnJvciBtZXNzYWdlc1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gZm9ybWF0TWVzc2FnZShtc2csIHByb3BlcnRpZXMsIGRvYykge1xuICBpZiAodHlwZW9mIG1zZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBtc2cocHJvcGVydGllcywgZG9jKTtcbiAgfVxuXG4gIGNvbnN0IHByb3BlcnR5TmFtZXMgPSBPYmplY3Qua2V5cyhwcm9wZXJ0aWVzKTtcbiAgZm9yIChjb25zdCBwcm9wZXJ0eU5hbWUgb2YgcHJvcGVydHlOYW1lcykge1xuICAgIGlmIChwcm9wZXJ0eU5hbWUgPT09ICdtZXNzYWdlJykge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIG1zZyA9IG1zZy5yZXBsYWNlKCd7JyArIHByb3BlcnR5TmFtZS50b1VwcGVyQ2FzZSgpICsgJ30nLCBwcm9wZXJ0aWVzW3Byb3BlcnR5TmFtZV0pO1xuICB9XG5cbiAgcmV0dXJuIG1zZztcbn1cblxuLyohXG4gKiBleHBvcnRzXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBWYWxpZGF0b3JFcnJvcjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../server/node_modules/mongoose/lib/error/validator.js\n");

/***/ }),

/***/ "../server/node_modules/mongoose/lib/error/version.js":
/*!************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/error/version.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\n/*!\n * Module dependencies.\n */\n\nconst MongooseError = __webpack_require__(/*! ./ */ \"../server/node_modules/mongoose/lib/error/index.js\");\n\nclass VersionError extends MongooseError {\n  /**\n   * Version Error constructor.\n   *\n   * @param {Document} doc\n   * @param {Number} currentVersion\n   * @param {Array<String>} modifiedPaths\n   * @api private\n   */\n  constructor(doc, currentVersion, modifiedPaths) {\n    const modifiedPathsStr = modifiedPaths.join(', ');\n    super('No matching document found for id \"' + doc._id +\n      '\" version ' + currentVersion + ' modifiedPaths \"' + modifiedPathsStr + '\"');\n    this.version = currentVersion;\n    this.modifiedPaths = modifiedPaths;\n  }\n}\n\n\nObject.defineProperty(VersionError.prototype, 'name', {\n  value: 'VersionError'\n});\n\n/*!\n * exports\n */\n\nmodule.exports = VersionError;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvZXJyb3IvdmVyc2lvbi5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBO0FBQ0E7O0FBRUEsc0JBQXNCLG1CQUFPLENBQUMsOERBQUk7O0FBRWxDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxVQUFVO0FBQ3ZCLGFBQWEsUUFBUTtBQUNyQixhQUFhLGVBQWU7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL2NsaWVudC8uLi9zZXJ2ZXIvbm9kZV9tb2R1bGVzL21vbmdvb3NlL2xpYi9lcnJvci92ZXJzaW9uLmpzPzZhOWIiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG4vKiFcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxuY29uc3QgTW9uZ29vc2VFcnJvciA9IHJlcXVpcmUoJy4vJyk7XG5cbmNsYXNzIFZlcnNpb25FcnJvciBleHRlbmRzIE1vbmdvb3NlRXJyb3Ige1xuICAvKipcbiAgICogVmVyc2lvbiBFcnJvciBjb25zdHJ1Y3Rvci5cbiAgICpcbiAgICogQHBhcmFtIHtEb2N1bWVudH0gZG9jXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBjdXJyZW50VmVyc2lvblxuICAgKiBAcGFyYW0ge0FycmF5PFN0cmluZz59IG1vZGlmaWVkUGF0aHNcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBjb25zdHJ1Y3Rvcihkb2MsIGN1cnJlbnRWZXJzaW9uLCBtb2RpZmllZFBhdGhzKSB7XG4gICAgY29uc3QgbW9kaWZpZWRQYXRoc1N0ciA9IG1vZGlmaWVkUGF0aHMuam9pbignLCAnKTtcbiAgICBzdXBlcignTm8gbWF0Y2hpbmcgZG9jdW1lbnQgZm91bmQgZm9yIGlkIFwiJyArIGRvYy5faWQgK1xuICAgICAgJ1wiIHZlcnNpb24gJyArIGN1cnJlbnRWZXJzaW9uICsgJyBtb2RpZmllZFBhdGhzIFwiJyArIG1vZGlmaWVkUGF0aHNTdHIgKyAnXCInKTtcbiAgICB0aGlzLnZlcnNpb24gPSBjdXJyZW50VmVyc2lvbjtcbiAgICB0aGlzLm1vZGlmaWVkUGF0aHMgPSBtb2RpZmllZFBhdGhzO1xuICB9XG59XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFZlcnNpb25FcnJvci5wcm90b3R5cGUsICduYW1lJywge1xuICB2YWx1ZTogJ1ZlcnNpb25FcnJvcidcbn0pO1xuXG4vKiFcbiAqIGV4cG9ydHNcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IFZlcnNpb25FcnJvcjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../server/node_modules/mongoose/lib/error/version.js\n");

/***/ }),

/***/ "../server/node_modules/mongoose/lib/helpers/aggregate/prepareDiscriminatorPipeline.js":
/*!*********************************************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/helpers/aggregate/prepareDiscriminatorPipeline.js ***!
  \*********************************************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nmodule.exports = function prepareDiscriminatorPipeline(pipeline, schema, prefix) {\n  const discriminatorMapping = schema && schema.discriminatorMapping;\n  prefix = prefix || '';\n\n  if (discriminatorMapping && !discriminatorMapping.isRoot) {\n    const originalPipeline = pipeline;\n    const filterKey = (prefix.length > 0 ? prefix + '.' : prefix) + discriminatorMapping.key;\n    const discriminatorValue = discriminatorMapping.value;\n\n    // If the first pipeline stage is a match and it doesn't specify a `__t`\n    // key, add the discriminator key to it. This allows for potential\n    // aggregation query optimizations not to be disturbed by this feature.\n    if (originalPipeline[0] != null &&\n        originalPipeline[0].$match &&\n        (originalPipeline[0].$match[filterKey] === undefined || originalPipeline[0].$match[filterKey] === discriminatorValue)) {\n      originalPipeline[0].$match[filterKey] = discriminatorValue;\n      // `originalPipeline` is a ref, so there's no need for\n      // aggregate._pipeline = originalPipeline\n    } else if (originalPipeline[0] != null && originalPipeline[0].$geoNear) {\n      originalPipeline[0].$geoNear.query =\n          originalPipeline[0].$geoNear.query || {};\n      originalPipeline[0].$geoNear.query[filterKey] = discriminatorValue;\n    } else if (originalPipeline[0] != null && originalPipeline[0].$search) {\n      if (originalPipeline[1] && originalPipeline[1].$match != null) {\n        originalPipeline[1].$match[filterKey] = originalPipeline[1].$match[filterKey] || discriminatorValue;\n      } else {\n        const match = {};\n        match[filterKey] = discriminatorValue;\n        originalPipeline.splice(1, 0, { $match: match });\n      }\n    } else {\n      const match = {};\n      match[filterKey] = discriminatorValue;\n      originalPipeline.unshift({ $match: match });\n    }\n  }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9hZ2dyZWdhdGUvcHJlcGFyZURpc2NyaW1pbmF0b3JQaXBlbGluZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSx3Q0FBd0MsZUFBZTtBQUN2RDtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsaUNBQWlDLGVBQWU7QUFDaEQ7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2xpZW50Ly4uL3NlcnZlci9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvYWdncmVnYXRlL3ByZXBhcmVEaXNjcmltaW5hdG9yUGlwZWxpbmUuanM/ODljOSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gcHJlcGFyZURpc2NyaW1pbmF0b3JQaXBlbGluZShwaXBlbGluZSwgc2NoZW1hLCBwcmVmaXgpIHtcbiAgY29uc3QgZGlzY3JpbWluYXRvck1hcHBpbmcgPSBzY2hlbWEgJiYgc2NoZW1hLmRpc2NyaW1pbmF0b3JNYXBwaW5nO1xuICBwcmVmaXggPSBwcmVmaXggfHwgJyc7XG5cbiAgaWYgKGRpc2NyaW1pbmF0b3JNYXBwaW5nICYmICFkaXNjcmltaW5hdG9yTWFwcGluZy5pc1Jvb3QpIHtcbiAgICBjb25zdCBvcmlnaW5hbFBpcGVsaW5lID0gcGlwZWxpbmU7XG4gICAgY29uc3QgZmlsdGVyS2V5ID0gKHByZWZpeC5sZW5ndGggPiAwID8gcHJlZml4ICsgJy4nIDogcHJlZml4KSArIGRpc2NyaW1pbmF0b3JNYXBwaW5nLmtleTtcbiAgICBjb25zdCBkaXNjcmltaW5hdG9yVmFsdWUgPSBkaXNjcmltaW5hdG9yTWFwcGluZy52YWx1ZTtcblxuICAgIC8vIElmIHRoZSBmaXJzdCBwaXBlbGluZSBzdGFnZSBpcyBhIG1hdGNoIGFuZCBpdCBkb2Vzbid0IHNwZWNpZnkgYSBgX190YFxuICAgIC8vIGtleSwgYWRkIHRoZSBkaXNjcmltaW5hdG9yIGtleSB0byBpdC4gVGhpcyBhbGxvd3MgZm9yIHBvdGVudGlhbFxuICAgIC8vIGFnZ3JlZ2F0aW9uIHF1ZXJ5IG9wdGltaXphdGlvbnMgbm90IHRvIGJlIGRpc3R1cmJlZCBieSB0aGlzIGZlYXR1cmUuXG4gICAgaWYgKG9yaWdpbmFsUGlwZWxpbmVbMF0gIT0gbnVsbCAmJlxuICAgICAgICBvcmlnaW5hbFBpcGVsaW5lWzBdLiRtYXRjaCAmJlxuICAgICAgICAob3JpZ2luYWxQaXBlbGluZVswXS4kbWF0Y2hbZmlsdGVyS2V5XSA9PT0gdW5kZWZpbmVkIHx8IG9yaWdpbmFsUGlwZWxpbmVbMF0uJG1hdGNoW2ZpbHRlcktleV0gPT09IGRpc2NyaW1pbmF0b3JWYWx1ZSkpIHtcbiAgICAgIG9yaWdpbmFsUGlwZWxpbmVbMF0uJG1hdGNoW2ZpbHRlcktleV0gPSBkaXNjcmltaW5hdG9yVmFsdWU7XG4gICAgICAvLyBgb3JpZ2luYWxQaXBlbGluZWAgaXMgYSByZWYsIHNvIHRoZXJlJ3Mgbm8gbmVlZCBmb3JcbiAgICAgIC8vIGFnZ3JlZ2F0ZS5fcGlwZWxpbmUgPSBvcmlnaW5hbFBpcGVsaW5lXG4gICAgfSBlbHNlIGlmIChvcmlnaW5hbFBpcGVsaW5lWzBdICE9IG51bGwgJiYgb3JpZ2luYWxQaXBlbGluZVswXS4kZ2VvTmVhcikge1xuICAgICAgb3JpZ2luYWxQaXBlbGluZVswXS4kZ2VvTmVhci5xdWVyeSA9XG4gICAgICAgICAgb3JpZ2luYWxQaXBlbGluZVswXS4kZ2VvTmVhci5xdWVyeSB8fCB7fTtcbiAgICAgIG9yaWdpbmFsUGlwZWxpbmVbMF0uJGdlb05lYXIucXVlcnlbZmlsdGVyS2V5XSA9IGRpc2NyaW1pbmF0b3JWYWx1ZTtcbiAgICB9IGVsc2UgaWYgKG9yaWdpbmFsUGlwZWxpbmVbMF0gIT0gbnVsbCAmJiBvcmlnaW5hbFBpcGVsaW5lWzBdLiRzZWFyY2gpIHtcbiAgICAgIGlmIChvcmlnaW5hbFBpcGVsaW5lWzFdICYmIG9yaWdpbmFsUGlwZWxpbmVbMV0uJG1hdGNoICE9IG51bGwpIHtcbiAgICAgICAgb3JpZ2luYWxQaXBlbGluZVsxXS4kbWF0Y2hbZmlsdGVyS2V5XSA9IG9yaWdpbmFsUGlwZWxpbmVbMV0uJG1hdGNoW2ZpbHRlcktleV0gfHwgZGlzY3JpbWluYXRvclZhbHVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgbWF0Y2ggPSB7fTtcbiAgICAgICAgbWF0Y2hbZmlsdGVyS2V5XSA9IGRpc2NyaW1pbmF0b3JWYWx1ZTtcbiAgICAgICAgb3JpZ2luYWxQaXBlbGluZS5zcGxpY2UoMSwgMCwgeyAkbWF0Y2g6IG1hdGNoIH0pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBtYXRjaCA9IHt9O1xuICAgICAgbWF0Y2hbZmlsdGVyS2V5XSA9IGRpc2NyaW1pbmF0b3JWYWx1ZTtcbiAgICAgIG9yaWdpbmFsUGlwZWxpbmUudW5zaGlmdCh7ICRtYXRjaDogbWF0Y2ggfSk7XG4gICAgfVxuICB9XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../server/node_modules/mongoose/lib/helpers/aggregate/prepareDiscriminatorPipeline.js\n");

/***/ }),

/***/ "../server/node_modules/mongoose/lib/helpers/aggregate/stringifyFunctionOperators.js":
/*!*******************************************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/helpers/aggregate/stringifyFunctionOperators.js ***!
  \*******************************************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nmodule.exports = function stringifyFunctionOperators(pipeline) {\n  if (!Array.isArray(pipeline)) {\n    return;\n  }\n\n  for (const stage of pipeline) {\n    if (stage == null) {\n      continue;\n    }\n\n    const canHaveAccumulator = stage.$group || stage.$bucket || stage.$bucketAuto;\n    if (canHaveAccumulator != null) {\n      for (const key of Object.keys(canHaveAccumulator)) {\n        handleAccumulator(canHaveAccumulator[key]);\n      }\n    }\n\n    const stageType = Object.keys(stage)[0];\n    if (stageType && typeof stage[stageType] === 'object') {\n      const stageOptions = stage[stageType];\n      for (const key of Object.keys(stageOptions)) {\n        if (stageOptions[key] != null &&\n            stageOptions[key].$function != null &&\n            typeof stageOptions[key].$function.body === 'function') {\n          stageOptions[key].$function.body = stageOptions[key].$function.body.toString();\n        }\n      }\n    }\n\n    if (stage.$facet != null) {\n      for (const key of Object.keys(stage.$facet)) {\n        stringifyFunctionOperators(stage.$facet[key]);\n      }\n    }\n  }\n};\n\nfunction handleAccumulator(operator) {\n  if (operator == null || operator.$accumulator == null) {\n    return;\n  }\n\n  for (const key of ['init', 'accumulate', 'merge', 'finalize']) {\n    if (typeof operator.$accumulator[key] === 'function') {\n      operator.$accumulator[key] = String(operator.$accumulator[key]);\n    }\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9hZ2dyZWdhdGUvc3RyaW5naWZ5RnVuY3Rpb25PcGVyYXRvcnMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2xpZW50Ly4uL3NlcnZlci9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvYWdncmVnYXRlL3N0cmluZ2lmeUZ1bmN0aW9uT3BlcmF0b3JzLmpzPzI0NDIiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHN0cmluZ2lmeUZ1bmN0aW9uT3BlcmF0b3JzKHBpcGVsaW5lKSB7XG4gIGlmICghQXJyYXkuaXNBcnJheShwaXBlbGluZSkpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBmb3IgKGNvbnN0IHN0YWdlIG9mIHBpcGVsaW5lKSB7XG4gICAgaWYgKHN0YWdlID09IG51bGwpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGNvbnN0IGNhbkhhdmVBY2N1bXVsYXRvciA9IHN0YWdlLiRncm91cCB8fCBzdGFnZS4kYnVja2V0IHx8IHN0YWdlLiRidWNrZXRBdXRvO1xuICAgIGlmIChjYW5IYXZlQWNjdW11bGF0b3IgIT0gbnVsbCkge1xuICAgICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMoY2FuSGF2ZUFjY3VtdWxhdG9yKSkge1xuICAgICAgICBoYW5kbGVBY2N1bXVsYXRvcihjYW5IYXZlQWNjdW11bGF0b3Jba2V5XSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3Qgc3RhZ2VUeXBlID0gT2JqZWN0LmtleXMoc3RhZ2UpWzBdO1xuICAgIGlmIChzdGFnZVR5cGUgJiYgdHlwZW9mIHN0YWdlW3N0YWdlVHlwZV0gPT09ICdvYmplY3QnKSB7XG4gICAgICBjb25zdCBzdGFnZU9wdGlvbnMgPSBzdGFnZVtzdGFnZVR5cGVdO1xuICAgICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMoc3RhZ2VPcHRpb25zKSkge1xuICAgICAgICBpZiAoc3RhZ2VPcHRpb25zW2tleV0gIT0gbnVsbCAmJlxuICAgICAgICAgICAgc3RhZ2VPcHRpb25zW2tleV0uJGZ1bmN0aW9uICE9IG51bGwgJiZcbiAgICAgICAgICAgIHR5cGVvZiBzdGFnZU9wdGlvbnNba2V5XS4kZnVuY3Rpb24uYm9keSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHN0YWdlT3B0aW9uc1trZXldLiRmdW5jdGlvbi5ib2R5ID0gc3RhZ2VPcHRpb25zW2tleV0uJGZ1bmN0aW9uLmJvZHkudG9TdHJpbmcoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChzdGFnZS4kZmFjZXQgIT0gbnVsbCkge1xuICAgICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMoc3RhZ2UuJGZhY2V0KSkge1xuICAgICAgICBzdHJpbmdpZnlGdW5jdGlvbk9wZXJhdG9ycyhzdGFnZS4kZmFjZXRba2V5XSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG5mdW5jdGlvbiBoYW5kbGVBY2N1bXVsYXRvcihvcGVyYXRvcikge1xuICBpZiAob3BlcmF0b3IgPT0gbnVsbCB8fCBvcGVyYXRvci4kYWNjdW11bGF0b3IgPT0gbnVsbCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGZvciAoY29uc3Qga2V5IG9mIFsnaW5pdCcsICdhY2N1bXVsYXRlJywgJ21lcmdlJywgJ2ZpbmFsaXplJ10pIHtcbiAgICBpZiAodHlwZW9mIG9wZXJhdG9yLiRhY2N1bXVsYXRvcltrZXldID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBvcGVyYXRvci4kYWNjdW11bGF0b3Jba2V5XSA9IFN0cmluZyhvcGVyYXRvci4kYWNjdW11bGF0b3Jba2V5XSk7XG4gICAgfVxuICB9XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../server/node_modules/mongoose/lib/helpers/aggregate/stringifyFunctionOperators.js\n");

/***/ }),

/***/ "../server/node_modules/mongoose/lib/helpers/arrayDepth.js":
/*!*****************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/helpers/arrayDepth.js ***!
  \*****************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nmodule.exports = arrayDepth;\n\nfunction arrayDepth(arr) {\n  if (!Array.isArray(arr)) {\n    return { min: 0, max: 0, containsNonArrayItem: true };\n  }\n  if (arr.length === 0) {\n    return { min: 1, max: 1, containsNonArrayItem: false };\n  }\n  if (arr.length === 1 && !Array.isArray(arr[0])) {\n    return { min: 1, max: 1, containsNonArrayItem: false };\n  }\n\n  const res = arrayDepth(arr[0]);\n\n  for (let i = 1; i < arr.length; ++i) {\n    const _res = arrayDepth(arr[i]);\n    if (_res.min < res.min) {\n      res.min = _res.min;\n    }\n    if (_res.max > res.max) {\n      res.max = _res.max;\n    }\n    res.containsNonArrayItem = res.containsNonArrayItem || _res.containsNonArrayItem;\n  }\n\n  res.min = res.min + 1;\n  res.max = res.max + 1;\n\n  return res;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9hcnJheURlcHRoLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViOztBQUVBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBOztBQUVBLGtCQUFrQixnQkFBZ0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2NsaWVudC8uLi9zZXJ2ZXIvbm9kZV9tb2R1bGVzL21vbmdvb3NlL2xpYi9oZWxwZXJzL2FycmF5RGVwdGguanM/OGUxYSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gYXJyYXlEZXB0aDtcblxuZnVuY3Rpb24gYXJyYXlEZXB0aChhcnIpIHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KGFycikpIHtcbiAgICByZXR1cm4geyBtaW46IDAsIG1heDogMCwgY29udGFpbnNOb25BcnJheUl0ZW06IHRydWUgfTtcbiAgfVxuICBpZiAoYXJyLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiB7IG1pbjogMSwgbWF4OiAxLCBjb250YWluc05vbkFycmF5SXRlbTogZmFsc2UgfTtcbiAgfVxuICBpZiAoYXJyLmxlbmd0aCA9PT0gMSAmJiAhQXJyYXkuaXNBcnJheShhcnJbMF0pKSB7XG4gICAgcmV0dXJuIHsgbWluOiAxLCBtYXg6IDEsIGNvbnRhaW5zTm9uQXJyYXlJdGVtOiBmYWxzZSB9O1xuICB9XG5cbiAgY29uc3QgcmVzID0gYXJyYXlEZXB0aChhcnJbMF0pO1xuXG4gIGZvciAobGV0IGkgPSAxOyBpIDwgYXJyLmxlbmd0aDsgKytpKSB7XG4gICAgY29uc3QgX3JlcyA9IGFycmF5RGVwdGgoYXJyW2ldKTtcbiAgICBpZiAoX3Jlcy5taW4gPCByZXMubWluKSB7XG4gICAgICByZXMubWluID0gX3Jlcy5taW47XG4gICAgfVxuICAgIGlmIChfcmVzLm1heCA+IHJlcy5tYXgpIHtcbiAgICAgIHJlcy5tYXggPSBfcmVzLm1heDtcbiAgICB9XG4gICAgcmVzLmNvbnRhaW5zTm9uQXJyYXlJdGVtID0gcmVzLmNvbnRhaW5zTm9uQXJyYXlJdGVtIHx8IF9yZXMuY29udGFpbnNOb25BcnJheUl0ZW07XG4gIH1cblxuICByZXMubWluID0gcmVzLm1pbiArIDE7XG4gIHJlcy5tYXggPSByZXMubWF4ICsgMTtcblxuICByZXR1cm4gcmVzO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../server/node_modules/mongoose/lib/helpers/arrayDepth.js\n");

/***/ }),

/***/ "../server/node_modules/mongoose/lib/helpers/clone.js":
/*!************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/helpers/clone.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst Decimal = __webpack_require__(/*! ../types/decimal128 */ \"../server/node_modules/mongoose/lib/types/decimal128.js\");\nconst ObjectId = __webpack_require__(/*! ../types/objectid */ \"../server/node_modules/mongoose/lib/types/objectid.js\");\nconst specialProperties = __webpack_require__(/*! ./specialProperties */ \"../server/node_modules/mongoose/lib/helpers/specialProperties.js\");\nconst isMongooseObject = __webpack_require__(/*! ./isMongooseObject */ \"../server/node_modules/mongoose/lib/helpers/isMongooseObject.js\");\nconst getFunctionName = __webpack_require__(/*! ./getFunctionName */ \"../server/node_modules/mongoose/lib/helpers/getFunctionName.js\");\nconst isBsonType = __webpack_require__(/*! ./isBsonType */ \"../server/node_modules/mongoose/lib/helpers/isBsonType.js\");\nconst isMongooseArray = (__webpack_require__(/*! ../types/array/isMongooseArray */ \"../server/node_modules/mongoose/lib/types/array/isMongooseArray.js\").isMongooseArray);\nconst isObject = __webpack_require__(/*! ./isObject */ \"../server/node_modules/mongoose/lib/helpers/isObject.js\");\nconst isPOJO = __webpack_require__(/*! ./isPOJO */ \"../server/node_modules/mongoose/lib/helpers/isPOJO.js\");\nconst symbols = __webpack_require__(/*! ./symbols */ \"../server/node_modules/mongoose/lib/helpers/symbols.js\");\nconst trustedSymbol = (__webpack_require__(/*! ./query/trusted */ \"../server/node_modules/mongoose/lib/helpers/query/trusted.js\").trustedSymbol);\n\n/**\n * Object clone with Mongoose natives support.\n *\n * If options.minimize is true, creates a minimal data object. Empty objects and undefined values will not be cloned. This makes the data payload sent to MongoDB as small as possible.\n *\n * Functions are never cloned.\n *\n * @param {Object} obj the object to clone\n * @param {Object} options\n * @param {Boolean} isArrayChild true if cloning immediately underneath an array. Special case for minimize.\n * @return {Object} the cloned object\n * @api private\n */\n\nfunction clone(obj, options, isArrayChild) {\n  if (obj == null) {\n    return obj;\n  }\n\n  if (Array.isArray(obj)) {\n    return cloneArray(isMongooseArray(obj) ? obj.__array : obj, options);\n  }\n\n  if (isMongooseObject(obj)) {\n    // Single nested subdocs should apply getters later in `applyGetters()`\n    // when calling `toObject()`. See gh-7442, gh-8295\n    if (options && options._skipSingleNestedGetters && obj.$isSingleNested) {\n      options = Object.assign({}, options, { getters: false });\n    }\n    const isSingleNested = obj.$isSingleNested;\n\n    if (isPOJO(obj) && obj.$__ != null && obj._doc != null) {\n      return obj._doc;\n    }\n\n    let ret;\n    if (options && options.json && typeof obj.toJSON === 'function') {\n      ret = obj.toJSON(options);\n    } else {\n      ret = obj.toObject(options);\n    }\n\n    if (options && options.minimize && !obj.constructor.$__required && isSingleNested && Object.keys(ret).length === 0) {\n      return undefined;\n    }\n\n    return ret;\n  }\n\n  const objConstructor = obj.constructor;\n\n  if (objConstructor) {\n    switch (getFunctionName(objConstructor)) {\n      case 'Object':\n        return cloneObject(obj, options, isArrayChild);\n      case 'Date':\n        return new objConstructor(+obj);\n      case 'RegExp':\n        return cloneRegExp(obj);\n      default:\n        // ignore\n        break;\n    }\n  }\n\n  if (isBsonType(obj, 'ObjectId')) {\n    if (options && options.flattenObjectIds) {\n      return obj.toJSON();\n    }\n    return new ObjectId(obj.id);\n  }\n\n  if (isBsonType(obj, 'Decimal128')) {\n    if (options && options.flattenDecimals) {\n      return obj.toJSON();\n    }\n    return Decimal.fromString(obj.toString());\n  }\n\n  // object created with Object.create(null)\n  if (!objConstructor && isObject(obj)) {\n    return cloneObject(obj, options, isArrayChild);\n  }\n\n  if (typeof obj === 'object' && obj[symbols.schemaTypeSymbol]) {\n    return obj.clone();\n  }\n\n  // If we're cloning this object to go into a MongoDB command,\n  // and there's a `toBSON()` function, assume this object will be\n  // stored as a primitive in MongoDB and doesn't need to be cloned.\n  if (options && options.bson && typeof obj.toBSON === 'function') {\n    return obj;\n  }\n\n  if (typeof obj.valueOf === 'function') {\n    return obj.valueOf();\n  }\n\n  return cloneObject(obj, options, isArrayChild);\n}\nmodule.exports = clone;\n\n/*!\n * ignore\n */\n\nfunction cloneObject(obj, options, isArrayChild) {\n  const minimize = options && options.minimize;\n  const omitUndefined = options && options.omitUndefined;\n  const seen = options && options._seen;\n  const ret = {};\n  let hasKeys;\n\n  if (seen && seen.has(obj)) {\n    return seen.get(obj);\n  } else if (seen) {\n    seen.set(obj, ret);\n  }\n  if (trustedSymbol in obj) {\n    ret[trustedSymbol] = obj[trustedSymbol];\n  }\n\n  let i = 0;\n  let key = '';\n  const keys = Object.keys(obj);\n  const len = keys.length;\n\n  for (i = 0; i < len; ++i) {\n    if (specialProperties.has(key = keys[i])) {\n      continue;\n    }\n\n    // Don't pass `isArrayChild` down\n    const val = clone(obj[key], options, false);\n\n    if ((minimize === false || omitUndefined) && typeof val === 'undefined') {\n      delete ret[key];\n    } else if (minimize !== true || (typeof val !== 'undefined')) {\n      hasKeys || (hasKeys = true);\n      ret[key] = val;\n    }\n  }\n\n  return minimize && !isArrayChild ? hasKeys && ret : ret;\n}\n\nfunction cloneArray(arr, options) {\n  let i = 0;\n  const len = arr.length;\n  const ret = new Array(len);\n  for (i = 0; i < len; ++i) {\n    ret[i] = clone(arr[i], options, true);\n  }\n\n  return ret;\n}\n\nfunction cloneRegExp(regexp) {\n  const ret = new RegExp(regexp.source, regexp.flags);\n\n  if (ret.lastIndex !== regexp.lastIndex) {\n    ret.lastIndex = regexp.lastIndex;\n  }\n  return ret;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9jbG9uZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixnQkFBZ0IsbUJBQU8sQ0FBQyxvRkFBcUI7QUFDN0MsaUJBQWlCLG1CQUFPLENBQUMsZ0ZBQW1CO0FBQzVDLDBCQUEwQixtQkFBTyxDQUFDLDZGQUFxQjtBQUN2RCx5QkFBeUIsbUJBQU8sQ0FBQywyRkFBb0I7QUFDckQsd0JBQXdCLG1CQUFPLENBQUMseUZBQW1CO0FBQ25ELG1CQUFtQixtQkFBTyxDQUFDLCtFQUFjO0FBQ3pDLHdCQUF3QixpSkFBeUQ7QUFDakYsaUJBQWlCLG1CQUFPLENBQUMsMkVBQVk7QUFDckMsZUFBZSxtQkFBTyxDQUFDLHVFQUFVO0FBQ2pDLGdCQUFnQixtQkFBTyxDQUFDLHlFQUFXO0FBQ25DLHNCQUFzQiwwSEFBd0M7O0FBRTlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFNBQVM7QUFDcEIsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLGFBQWEsZ0JBQWdCO0FBQzdEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGNBQWMsU0FBUztBQUN2QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFNBQVM7QUFDdkI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2NsaWVudC8uLi9zZXJ2ZXIvbm9kZV9tb2R1bGVzL21vbmdvb3NlL2xpYi9oZWxwZXJzL2Nsb25lLmpzP2Q1YWEiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBEZWNpbWFsID0gcmVxdWlyZSgnLi4vdHlwZXMvZGVjaW1hbDEyOCcpO1xuY29uc3QgT2JqZWN0SWQgPSByZXF1aXJlKCcuLi90eXBlcy9vYmplY3RpZCcpO1xuY29uc3Qgc3BlY2lhbFByb3BlcnRpZXMgPSByZXF1aXJlKCcuL3NwZWNpYWxQcm9wZXJ0aWVzJyk7XG5jb25zdCBpc01vbmdvb3NlT2JqZWN0ID0gcmVxdWlyZSgnLi9pc01vbmdvb3NlT2JqZWN0Jyk7XG5jb25zdCBnZXRGdW5jdGlvbk5hbWUgPSByZXF1aXJlKCcuL2dldEZ1bmN0aW9uTmFtZScpO1xuY29uc3QgaXNCc29uVHlwZSA9IHJlcXVpcmUoJy4vaXNCc29uVHlwZScpO1xuY29uc3QgaXNNb25nb29zZUFycmF5ID0gcmVxdWlyZSgnLi4vdHlwZXMvYXJyYXkvaXNNb25nb29zZUFycmF5JykuaXNNb25nb29zZUFycmF5O1xuY29uc3QgaXNPYmplY3QgPSByZXF1aXJlKCcuL2lzT2JqZWN0Jyk7XG5jb25zdCBpc1BPSk8gPSByZXF1aXJlKCcuL2lzUE9KTycpO1xuY29uc3Qgc3ltYm9scyA9IHJlcXVpcmUoJy4vc3ltYm9scycpO1xuY29uc3QgdHJ1c3RlZFN5bWJvbCA9IHJlcXVpcmUoJy4vcXVlcnkvdHJ1c3RlZCcpLnRydXN0ZWRTeW1ib2w7XG5cbi8qKlxuICogT2JqZWN0IGNsb25lIHdpdGggTW9uZ29vc2UgbmF0aXZlcyBzdXBwb3J0LlxuICpcbiAqIElmIG9wdGlvbnMubWluaW1pemUgaXMgdHJ1ZSwgY3JlYXRlcyBhIG1pbmltYWwgZGF0YSBvYmplY3QuIEVtcHR5IG9iamVjdHMgYW5kIHVuZGVmaW5lZCB2YWx1ZXMgd2lsbCBub3QgYmUgY2xvbmVkLiBUaGlzIG1ha2VzIHRoZSBkYXRhIHBheWxvYWQgc2VudCB0byBNb25nb0RCIGFzIHNtYWxsIGFzIHBvc3NpYmxlLlxuICpcbiAqIEZ1bmN0aW9ucyBhcmUgbmV2ZXIgY2xvbmVkLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmogdGhlIG9iamVjdCB0byBjbG9uZVxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gaXNBcnJheUNoaWxkIHRydWUgaWYgY2xvbmluZyBpbW1lZGlhdGVseSB1bmRlcm5lYXRoIGFuIGFycmF5LiBTcGVjaWFsIGNhc2UgZm9yIG1pbmltaXplLlxuICogQHJldHVybiB7T2JqZWN0fSB0aGUgY2xvbmVkIG9iamVjdFxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gY2xvbmUob2JqLCBvcHRpb25zLCBpc0FycmF5Q2hpbGQpIHtcbiAgaWYgKG9iaiA9PSBudWxsKSB7XG4gICAgcmV0dXJuIG9iajtcbiAgfVxuXG4gIGlmIChBcnJheS5pc0FycmF5KG9iaikpIHtcbiAgICByZXR1cm4gY2xvbmVBcnJheShpc01vbmdvb3NlQXJyYXkob2JqKSA/IG9iai5fX2FycmF5IDogb2JqLCBvcHRpb25zKTtcbiAgfVxuXG4gIGlmIChpc01vbmdvb3NlT2JqZWN0KG9iaikpIHtcbiAgICAvLyBTaW5nbGUgbmVzdGVkIHN1YmRvY3Mgc2hvdWxkIGFwcGx5IGdldHRlcnMgbGF0ZXIgaW4gYGFwcGx5R2V0dGVycygpYFxuICAgIC8vIHdoZW4gY2FsbGluZyBgdG9PYmplY3QoKWAuIFNlZSBnaC03NDQyLCBnaC04Mjk1XG4gICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5fc2tpcFNpbmdsZU5lc3RlZEdldHRlcnMgJiYgb2JqLiRpc1NpbmdsZU5lc3RlZCkge1xuICAgICAgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMsIHsgZ2V0dGVyczogZmFsc2UgfSk7XG4gICAgfVxuICAgIGNvbnN0IGlzU2luZ2xlTmVzdGVkID0gb2JqLiRpc1NpbmdsZU5lc3RlZDtcblxuICAgIGlmIChpc1BPSk8ob2JqKSAmJiBvYmouJF9fICE9IG51bGwgJiYgb2JqLl9kb2MgIT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG9iai5fZG9jO1xuICAgIH1cblxuICAgIGxldCByZXQ7XG4gICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5qc29uICYmIHR5cGVvZiBvYmoudG9KU09OID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXQgPSBvYmoudG9KU09OKG9wdGlvbnMpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXQgPSBvYmoudG9PYmplY3Qob3B0aW9ucyk7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5taW5pbWl6ZSAmJiAhb2JqLmNvbnN0cnVjdG9yLiRfX3JlcXVpcmVkICYmIGlzU2luZ2xlTmVzdGVkICYmIE9iamVjdC5rZXlzKHJldCkubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIHJldHVybiByZXQ7XG4gIH1cblxuICBjb25zdCBvYmpDb25zdHJ1Y3RvciA9IG9iai5jb25zdHJ1Y3RvcjtcblxuICBpZiAob2JqQ29uc3RydWN0b3IpIHtcbiAgICBzd2l0Y2ggKGdldEZ1bmN0aW9uTmFtZShvYmpDb25zdHJ1Y3RvcikpIHtcbiAgICAgIGNhc2UgJ09iamVjdCc6XG4gICAgICAgIHJldHVybiBjbG9uZU9iamVjdChvYmosIG9wdGlvbnMsIGlzQXJyYXlDaGlsZCk7XG4gICAgICBjYXNlICdEYXRlJzpcbiAgICAgICAgcmV0dXJuIG5ldyBvYmpDb25zdHJ1Y3Rvcigrb2JqKTtcbiAgICAgIGNhc2UgJ1JlZ0V4cCc6XG4gICAgICAgIHJldHVybiBjbG9uZVJlZ0V4cChvYmopO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgLy8gaWdub3JlXG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIGlmIChpc0Jzb25UeXBlKG9iaiwgJ09iamVjdElkJykpIHtcbiAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmZsYXR0ZW5PYmplY3RJZHMpIHtcbiAgICAgIHJldHVybiBvYmoudG9KU09OKCk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgT2JqZWN0SWQob2JqLmlkKTtcbiAgfVxuXG4gIGlmIChpc0Jzb25UeXBlKG9iaiwgJ0RlY2ltYWwxMjgnKSkge1xuICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMuZmxhdHRlbkRlY2ltYWxzKSB7XG4gICAgICByZXR1cm4gb2JqLnRvSlNPTigpO1xuICAgIH1cbiAgICByZXR1cm4gRGVjaW1hbC5mcm9tU3RyaW5nKG9iai50b1N0cmluZygpKTtcbiAgfVxuXG4gIC8vIG9iamVjdCBjcmVhdGVkIHdpdGggT2JqZWN0LmNyZWF0ZShudWxsKVxuICBpZiAoIW9iakNvbnN0cnVjdG9yICYmIGlzT2JqZWN0KG9iaikpIHtcbiAgICByZXR1cm4gY2xvbmVPYmplY3Qob2JqLCBvcHRpb25zLCBpc0FycmF5Q2hpbGQpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBvYmogPT09ICdvYmplY3QnICYmIG9ialtzeW1ib2xzLnNjaGVtYVR5cGVTeW1ib2xdKSB7XG4gICAgcmV0dXJuIG9iai5jbG9uZSgpO1xuICB9XG5cbiAgLy8gSWYgd2UncmUgY2xvbmluZyB0aGlzIG9iamVjdCB0byBnbyBpbnRvIGEgTW9uZ29EQiBjb21tYW5kLFxuICAvLyBhbmQgdGhlcmUncyBhIGB0b0JTT04oKWAgZnVuY3Rpb24sIGFzc3VtZSB0aGlzIG9iamVjdCB3aWxsIGJlXG4gIC8vIHN0b3JlZCBhcyBhIHByaW1pdGl2ZSBpbiBNb25nb0RCIGFuZCBkb2Vzbid0IG5lZWQgdG8gYmUgY2xvbmVkLlxuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmJzb24gJiYgdHlwZW9mIG9iai50b0JTT04gPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gb2JqO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBvYmoudmFsdWVPZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBvYmoudmFsdWVPZigpO1xuICB9XG5cbiAgcmV0dXJuIGNsb25lT2JqZWN0KG9iaiwgb3B0aW9ucywgaXNBcnJheUNoaWxkKTtcbn1cbm1vZHVsZS5leHBvcnRzID0gY2xvbmU7XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxuZnVuY3Rpb24gY2xvbmVPYmplY3Qob2JqLCBvcHRpb25zLCBpc0FycmF5Q2hpbGQpIHtcbiAgY29uc3QgbWluaW1pemUgPSBvcHRpb25zICYmIG9wdGlvbnMubWluaW1pemU7XG4gIGNvbnN0IG9taXRVbmRlZmluZWQgPSBvcHRpb25zICYmIG9wdGlvbnMub21pdFVuZGVmaW5lZDtcbiAgY29uc3Qgc2VlbiA9IG9wdGlvbnMgJiYgb3B0aW9ucy5fc2VlbjtcbiAgY29uc3QgcmV0ID0ge307XG4gIGxldCBoYXNLZXlzO1xuXG4gIGlmIChzZWVuICYmIHNlZW4uaGFzKG9iaikpIHtcbiAgICByZXR1cm4gc2Vlbi5nZXQob2JqKTtcbiAgfSBlbHNlIGlmIChzZWVuKSB7XG4gICAgc2Vlbi5zZXQob2JqLCByZXQpO1xuICB9XG4gIGlmICh0cnVzdGVkU3ltYm9sIGluIG9iaikge1xuICAgIHJldFt0cnVzdGVkU3ltYm9sXSA9IG9ialt0cnVzdGVkU3ltYm9sXTtcbiAgfVxuXG4gIGxldCBpID0gMDtcbiAgbGV0IGtleSA9ICcnO1xuICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMob2JqKTtcbiAgY29uc3QgbGVuID0ga2V5cy5sZW5ndGg7XG5cbiAgZm9yIChpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgaWYgKHNwZWNpYWxQcm9wZXJ0aWVzLmhhcyhrZXkgPSBrZXlzW2ldKSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gRG9uJ3QgcGFzcyBgaXNBcnJheUNoaWxkYCBkb3duXG4gICAgY29uc3QgdmFsID0gY2xvbmUob2JqW2tleV0sIG9wdGlvbnMsIGZhbHNlKTtcblxuICAgIGlmICgobWluaW1pemUgPT09IGZhbHNlIHx8IG9taXRVbmRlZmluZWQpICYmIHR5cGVvZiB2YWwgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBkZWxldGUgcmV0W2tleV07XG4gICAgfSBlbHNlIGlmIChtaW5pbWl6ZSAhPT0gdHJ1ZSB8fCAodHlwZW9mIHZhbCAhPT0gJ3VuZGVmaW5lZCcpKSB7XG4gICAgICBoYXNLZXlzIHx8IChoYXNLZXlzID0gdHJ1ZSk7XG4gICAgICByZXRba2V5XSA9IHZhbDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbWluaW1pemUgJiYgIWlzQXJyYXlDaGlsZCA/IGhhc0tleXMgJiYgcmV0IDogcmV0O1xufVxuXG5mdW5jdGlvbiBjbG9uZUFycmF5KGFyciwgb3B0aW9ucykge1xuICBsZXQgaSA9IDA7XG4gIGNvbnN0IGxlbiA9IGFyci5sZW5ndGg7XG4gIGNvbnN0IHJldCA9IG5ldyBBcnJheShsZW4pO1xuICBmb3IgKGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICByZXRbaV0gPSBjbG9uZShhcnJbaV0sIG9wdGlvbnMsIHRydWUpO1xuICB9XG5cbiAgcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gY2xvbmVSZWdFeHAocmVnZXhwKSB7XG4gIGNvbnN0IHJldCA9IG5ldyBSZWdFeHAocmVnZXhwLnNvdXJjZSwgcmVnZXhwLmZsYWdzKTtcblxuICBpZiAocmV0Lmxhc3RJbmRleCAhPT0gcmVnZXhwLmxhc3RJbmRleCkge1xuICAgIHJldC5sYXN0SW5kZXggPSByZWdleHAubGFzdEluZGV4O1xuICB9XG4gIHJldHVybiByZXQ7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../server/node_modules/mongoose/lib/helpers/clone.js\n");

/***/ }),

/***/ "../server/node_modules/mongoose/lib/helpers/common.js":
/*!*************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/helpers/common.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\n/*!\n * Module dependencies.\n */\n\nconst Binary = (__webpack_require__(/*! bson */ \"../server/node_modules/bson/lib/bson.cjs\").Binary);\nconst isBsonType = __webpack_require__(/*! ./isBsonType */ \"../server/node_modules/mongoose/lib/helpers/isBsonType.js\");\nconst isMongooseObject = __webpack_require__(/*! ./isMongooseObject */ \"../server/node_modules/mongoose/lib/helpers/isMongooseObject.js\");\nconst MongooseError = __webpack_require__(/*! ../error */ \"../server/node_modules/mongoose/lib/error/index.js\");\nconst util = __webpack_require__(/*! util */ \"util\");\n\nexports.flatten = flatten;\nexports.modifiedPaths = modifiedPaths;\n\n/*!\n * ignore\n */\n\nfunction flatten(update, path, options, schema) {\n  let keys;\n  if (update && isMongooseObject(update) && !Buffer.isBuffer(update)) {\n    keys = Object.keys(update.toObject({ transform: false, virtuals: false }) || {});\n  } else {\n    keys = Object.keys(update || {});\n  }\n\n  const numKeys = keys.length;\n  const result = {};\n  path = path ? path + '.' : '';\n\n  for (let i = 0; i < numKeys; ++i) {\n    const key = keys[i];\n    const val = update[key];\n    result[path + key] = val;\n\n    // Avoid going into mixed paths if schema is specified\n    const keySchema = schema && schema.path && schema.path(path + key);\n    const isNested = schema && schema.nested && schema.nested[path + key];\n    if (keySchema && keySchema.instance === 'Mixed') continue;\n\n    if (shouldFlatten(val)) {\n      if (options && options.skipArrays && Array.isArray(val)) {\n        continue;\n      }\n      const flat = flatten(val, path + key, options, schema);\n      for (const k in flat) {\n        result[k] = flat[k];\n      }\n      if (Array.isArray(val)) {\n        result[path + key] = val;\n      }\n    }\n\n    if (isNested) {\n      const paths = Object.keys(schema.paths);\n      for (const p of paths) {\n        if (p.startsWith(path + key + '.') && !result.hasOwnProperty(p)) {\n          result[p] = void 0;\n        }\n      }\n    }\n  }\n\n  return result;\n}\n\n/*!\n * ignore\n */\n\nfunction modifiedPaths(update, path, result, recursion = null) {\n  if (update == null || typeof update !== 'object') {\n    return;\n  }\n\n  if (recursion == null) {\n    recursion = {\n      raw: { update, path },\n      trace: new WeakSet()\n    };\n  }\n\n  if (recursion.trace.has(update)) {\n    throw new MongooseError(`a circular reference in the update value, updateValue:\n${util.inspect(recursion.raw.update, { showHidden: false, depth: 1 })}\nupdatePath: '${recursion.raw.path}'`);\n  }\n  recursion.trace.add(update);\n\n  const keys = Object.keys(update || {});\n  const numKeys = keys.length;\n  result = result || {};\n  path = path ? path + '.' : '';\n\n  for (let i = 0; i < numKeys; ++i) {\n    const key = keys[i];\n    let val = update[key];\n\n    const _path = path + key;\n    result[_path] = true;\n    if (!Buffer.isBuffer(val) && isMongooseObject(val)) {\n      val = val.toObject({ transform: false, virtuals: false });\n    }\n    if (shouldFlatten(val)) {\n      modifiedPaths(val, path + key, result, recursion);\n    }\n  }\n  recursion.trace.delete(update);\n\n  return result;\n}\n\n/*!\n * ignore\n */\n\nfunction shouldFlatten(val) {\n  return val &&\n      typeof val === 'object' &&\n      !(val instanceof Date) &&\n      !isBsonType(val, 'ObjectId') &&\n      (!Array.isArray(val) || val.length !== 0) &&\n      !(val instanceof Buffer) &&\n      !isBsonType(val, 'Decimal128') &&\n      !(val instanceof Binary);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9jb21tb24uanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7QUFDQTtBQUNBOztBQUVBLGVBQWUsb0ZBQXNCO0FBQ3JDLG1CQUFtQixtQkFBTyxDQUFDLCtFQUFjO0FBQ3pDLHlCQUF5QixtQkFBTyxDQUFDLDJGQUFvQjtBQUNyRCxzQkFBc0IsbUJBQU8sQ0FBQyxvRUFBVTtBQUN4QyxhQUFhLG1CQUFPLENBQUMsa0JBQU07O0FBRTNCLGVBQWU7QUFDZixxQkFBcUI7O0FBRXJCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsbUNBQW1DLE9BQU87QUFDbkYsSUFBSTtBQUNKLG1DQUFtQztBQUNuQzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLGFBQWE7QUFDL0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsY0FBYztBQUMzQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUUscUNBQXFDLDZCQUE2QjtBQUNwRSxlQUFlLG1CQUFtQjtBQUNsQztBQUNBOztBQUVBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLGFBQWE7QUFDL0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsbUNBQW1DO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2NsaWVudC8uLi9zZXJ2ZXIvbm9kZV9tb2R1bGVzL21vbmdvb3NlL2xpYi9oZWxwZXJzL2NvbW1vbi5qcz8zMmFiIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuLyohXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbmNvbnN0IEJpbmFyeSA9IHJlcXVpcmUoJ2Jzb24nKS5CaW5hcnk7XG5jb25zdCBpc0Jzb25UeXBlID0gcmVxdWlyZSgnLi9pc0Jzb25UeXBlJyk7XG5jb25zdCBpc01vbmdvb3NlT2JqZWN0ID0gcmVxdWlyZSgnLi9pc01vbmdvb3NlT2JqZWN0Jyk7XG5jb25zdCBNb25nb29zZUVycm9yID0gcmVxdWlyZSgnLi4vZXJyb3InKTtcbmNvbnN0IHV0aWwgPSByZXF1aXJlKCd1dGlsJyk7XG5cbmV4cG9ydHMuZmxhdHRlbiA9IGZsYXR0ZW47XG5leHBvcnRzLm1vZGlmaWVkUGF0aHMgPSBtb2RpZmllZFBhdGhzO1xuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cbmZ1bmN0aW9uIGZsYXR0ZW4odXBkYXRlLCBwYXRoLCBvcHRpb25zLCBzY2hlbWEpIHtcbiAgbGV0IGtleXM7XG4gIGlmICh1cGRhdGUgJiYgaXNNb25nb29zZU9iamVjdCh1cGRhdGUpICYmICFCdWZmZXIuaXNCdWZmZXIodXBkYXRlKSkge1xuICAgIGtleXMgPSBPYmplY3Qua2V5cyh1cGRhdGUudG9PYmplY3QoeyB0cmFuc2Zvcm06IGZhbHNlLCB2aXJ0dWFsczogZmFsc2UgfSkgfHwge30pO1xuICB9IGVsc2Uge1xuICAgIGtleXMgPSBPYmplY3Qua2V5cyh1cGRhdGUgfHwge30pO1xuICB9XG5cbiAgY29uc3QgbnVtS2V5cyA9IGtleXMubGVuZ3RoO1xuICBjb25zdCByZXN1bHQgPSB7fTtcbiAgcGF0aCA9IHBhdGggPyBwYXRoICsgJy4nIDogJyc7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1LZXlzOyArK2kpIHtcbiAgICBjb25zdCBrZXkgPSBrZXlzW2ldO1xuICAgIGNvbnN0IHZhbCA9IHVwZGF0ZVtrZXldO1xuICAgIHJlc3VsdFtwYXRoICsga2V5XSA9IHZhbDtcblxuICAgIC8vIEF2b2lkIGdvaW5nIGludG8gbWl4ZWQgcGF0aHMgaWYgc2NoZW1hIGlzIHNwZWNpZmllZFxuICAgIGNvbnN0IGtleVNjaGVtYSA9IHNjaGVtYSAmJiBzY2hlbWEucGF0aCAmJiBzY2hlbWEucGF0aChwYXRoICsga2V5KTtcbiAgICBjb25zdCBpc05lc3RlZCA9IHNjaGVtYSAmJiBzY2hlbWEubmVzdGVkICYmIHNjaGVtYS5uZXN0ZWRbcGF0aCArIGtleV07XG4gICAgaWYgKGtleVNjaGVtYSAmJiBrZXlTY2hlbWEuaW5zdGFuY2UgPT09ICdNaXhlZCcpIGNvbnRpbnVlO1xuXG4gICAgaWYgKHNob3VsZEZsYXR0ZW4odmFsKSkge1xuICAgICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5za2lwQXJyYXlzICYmIEFycmF5LmlzQXJyYXkodmFsKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGZsYXQgPSBmbGF0dGVuKHZhbCwgcGF0aCArIGtleSwgb3B0aW9ucywgc2NoZW1hKTtcbiAgICAgIGZvciAoY29uc3QgayBpbiBmbGF0KSB7XG4gICAgICAgIHJlc3VsdFtrXSA9IGZsYXRba107XG4gICAgICB9XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWwpKSB7XG4gICAgICAgIHJlc3VsdFtwYXRoICsga2V5XSA9IHZhbDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoaXNOZXN0ZWQpIHtcbiAgICAgIGNvbnN0IHBhdGhzID0gT2JqZWN0LmtleXMoc2NoZW1hLnBhdGhzKTtcbiAgICAgIGZvciAoY29uc3QgcCBvZiBwYXRocykge1xuICAgICAgICBpZiAocC5zdGFydHNXaXRoKHBhdGggKyBrZXkgKyAnLicpICYmICFyZXN1bHQuaGFzT3duUHJvcGVydHkocCkpIHtcbiAgICAgICAgICByZXN1bHRbcF0gPSB2b2lkIDA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cbmZ1bmN0aW9uIG1vZGlmaWVkUGF0aHModXBkYXRlLCBwYXRoLCByZXN1bHQsIHJlY3Vyc2lvbiA9IG51bGwpIHtcbiAgaWYgKHVwZGF0ZSA9PSBudWxsIHx8IHR5cGVvZiB1cGRhdGUgIT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKHJlY3Vyc2lvbiA9PSBudWxsKSB7XG4gICAgcmVjdXJzaW9uID0ge1xuICAgICAgcmF3OiB7IHVwZGF0ZSwgcGF0aCB9LFxuICAgICAgdHJhY2U6IG5ldyBXZWFrU2V0KClcbiAgICB9O1xuICB9XG5cbiAgaWYgKHJlY3Vyc2lvbi50cmFjZS5oYXModXBkYXRlKSkge1xuICAgIHRocm93IG5ldyBNb25nb29zZUVycm9yKGBhIGNpcmN1bGFyIHJlZmVyZW5jZSBpbiB0aGUgdXBkYXRlIHZhbHVlLCB1cGRhdGVWYWx1ZTpcbiR7dXRpbC5pbnNwZWN0KHJlY3Vyc2lvbi5yYXcudXBkYXRlLCB7IHNob3dIaWRkZW46IGZhbHNlLCBkZXB0aDogMSB9KX1cbnVwZGF0ZVBhdGg6ICcke3JlY3Vyc2lvbi5yYXcucGF0aH0nYCk7XG4gIH1cbiAgcmVjdXJzaW9uLnRyYWNlLmFkZCh1cGRhdGUpO1xuXG4gIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyh1cGRhdGUgfHwge30pO1xuICBjb25zdCBudW1LZXlzID0ga2V5cy5sZW5ndGg7XG4gIHJlc3VsdCA9IHJlc3VsdCB8fCB7fTtcbiAgcGF0aCA9IHBhdGggPyBwYXRoICsgJy4nIDogJyc7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1LZXlzOyArK2kpIHtcbiAgICBjb25zdCBrZXkgPSBrZXlzW2ldO1xuICAgIGxldCB2YWwgPSB1cGRhdGVba2V5XTtcblxuICAgIGNvbnN0IF9wYXRoID0gcGF0aCArIGtleTtcbiAgICByZXN1bHRbX3BhdGhdID0gdHJ1ZTtcbiAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcih2YWwpICYmIGlzTW9uZ29vc2VPYmplY3QodmFsKSkge1xuICAgICAgdmFsID0gdmFsLnRvT2JqZWN0KHsgdHJhbnNmb3JtOiBmYWxzZSwgdmlydHVhbHM6IGZhbHNlIH0pO1xuICAgIH1cbiAgICBpZiAoc2hvdWxkRmxhdHRlbih2YWwpKSB7XG4gICAgICBtb2RpZmllZFBhdGhzKHZhbCwgcGF0aCArIGtleSwgcmVzdWx0LCByZWN1cnNpb24pO1xuICAgIH1cbiAgfVxuICByZWN1cnNpb24udHJhY2UuZGVsZXRlKHVwZGF0ZSk7XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5mdW5jdGlvbiBzaG91bGRGbGF0dGVuKHZhbCkge1xuICByZXR1cm4gdmFsICYmXG4gICAgICB0eXBlb2YgdmFsID09PSAnb2JqZWN0JyAmJlxuICAgICAgISh2YWwgaW5zdGFuY2VvZiBEYXRlKSAmJlxuICAgICAgIWlzQnNvblR5cGUodmFsLCAnT2JqZWN0SWQnKSAmJlxuICAgICAgKCFBcnJheS5pc0FycmF5KHZhbCkgfHwgdmFsLmxlbmd0aCAhPT0gMCkgJiZcbiAgICAgICEodmFsIGluc3RhbmNlb2YgQnVmZmVyKSAmJlxuICAgICAgIWlzQnNvblR5cGUodmFsLCAnRGVjaW1hbDEyOCcpICYmXG4gICAgICAhKHZhbCBpbnN0YW5jZW9mIEJpbmFyeSk7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../server/node_modules/mongoose/lib/helpers/common.js\n");

/***/ }),

/***/ "../server/node_modules/mongoose/lib/helpers/cursor/eachAsync.js":
/*!***********************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/helpers/cursor/eachAsync.js ***!
  \***********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\n/*!\n * Module dependencies.\n */\n\nconst EachAsyncMultiError = __webpack_require__(/*! ../../error/eachAsyncMultiError */ \"../server/node_modules/mongoose/lib/error/eachAsyncMultiError.js\");\nconst immediate = __webpack_require__(/*! ../immediate */ \"../server/node_modules/mongoose/lib/helpers/immediate.js\");\n\n/**\n * Execute `fn` for every document in the cursor. If `fn` returns a promise,\n * will wait for the promise to resolve before iterating on to the next one.\n * Returns a promise that resolves when done.\n *\n * @param {Function} next the thunk to call to get the next document\n * @param {Function} fn\n * @param {Object} options\n * @param {Number} [options.batchSize=null] if set, Mongoose will call `fn` with an array of at most `batchSize` documents, instead of a single document\n * @param {Number} [options.parallel=1] maximum number of `fn` calls that Mongoose will run in parallel\n * @param {AbortSignal} [options.signal] allow cancelling this eachAsync(). Once the abort signal is fired, `eachAsync()` will immediately fulfill the returned promise (or call the callback) and not fetch any more documents.\n * @return {Promise}\n * @api public\n * @method eachAsync\n */\n\nmodule.exports = async function eachAsync(next, fn, options) {\n  const parallel = options.parallel || 1;\n  const batchSize = options.batchSize;\n  const signal = options.signal;\n  const continueOnError = options.continueOnError;\n  const aggregatedErrors = [];\n  const enqueue = asyncQueue();\n\n  let aborted = false;\n\n  return new Promise((resolve, reject) => {\n    if (signal != null) {\n      if (signal.aborted) {\n        return resolve(null);\n      }\n\n      signal.addEventListener('abort', () => {\n        aborted = true;\n        return resolve(null);\n      }, { once: true });\n    }\n\n    if (batchSize != null) {\n      if (typeof batchSize !== 'number') {\n        throw new TypeError('batchSize must be a number');\n      } else if (!Number.isInteger(batchSize)) {\n        throw new TypeError('batchSize must be an integer');\n      } else if (batchSize < 1) {\n        throw new TypeError('batchSize must be at least 1');\n      }\n    }\n\n    iterate((err, res) => {\n      if (err != null) {\n        return reject(err);\n      }\n      resolve(res);\n    });\n  });\n\n  function iterate(finalCallback) {\n    let handleResultsInProgress = 0;\n    let currentDocumentIndex = 0;\n\n    let error = null;\n    for (let i = 0; i < parallel; ++i) {\n      enqueue(createFetch());\n    }\n\n    function createFetch() {\n      let documentsBatch = [];\n      let drained = false;\n\n      return fetch;\n\n      function fetch(done) {\n        if (drained || aborted) {\n          return done();\n        } else if (error) {\n          return done();\n        }\n\n        next(function(err, doc) {\n          if (error != null) {\n            return done();\n          }\n          if (err != null) {\n            if (err.name === 'MongoCursorExhaustedError') {\n              // We may end up calling `next()` multiple times on an exhausted\n              // cursor, which leads to an error. In case cursor is exhausted,\n              // just treat it as if the cursor returned no document, which is\n              // how a cursor indicates it is exhausted.\n              doc = null;\n            } else if (continueOnError) {\n              aggregatedErrors.push(err);\n            } else {\n              error = err;\n              finalCallback(err);\n              return done();\n            }\n          }\n          if (doc == null) {\n            drained = true;\n            if (handleResultsInProgress <= 0) {\n              const finalErr = continueOnError ?\n                createEachAsyncMultiError(aggregatedErrors) :\n                error;\n\n              finalCallback(finalErr);\n            } else if (batchSize && documentsBatch.length) {\n              handleNextResult(documentsBatch, currentDocumentIndex++, handleNextResultCallBack);\n            }\n            return done();\n          }\n\n          ++handleResultsInProgress;\n\n          // Kick off the subsequent `next()` before handling the result, but\n          // make sure we know that we still have a result to handle re: #8422\n          immediate(() => done());\n\n          if (batchSize) {\n            documentsBatch.push(doc);\n          }\n\n          // If the current documents size is less than the provided batch size don't process the documents yet\n          if (batchSize && documentsBatch.length !== batchSize) {\n            immediate(() => enqueue(fetch));\n            return;\n          }\n\n          const docsToProcess = batchSize ? documentsBatch : doc;\n\n          function handleNextResultCallBack(err) {\n            if (batchSize) {\n              handleResultsInProgress -= documentsBatch.length;\n              documentsBatch = [];\n            } else {\n              --handleResultsInProgress;\n            }\n            if (err != null) {\n              if (continueOnError) {\n                aggregatedErrors.push(err);\n              } else {\n                error = err;\n                return finalCallback(err);\n              }\n            }\n            if ((drained || aborted) && handleResultsInProgress <= 0) {\n              const finalErr = continueOnError ?\n                createEachAsyncMultiError(aggregatedErrors) :\n                error;\n              return finalCallback(finalErr);\n            }\n\n            immediate(() => enqueue(fetch));\n          }\n\n          handleNextResult(docsToProcess, currentDocumentIndex++, handleNextResultCallBack);\n        });\n      }\n    }\n  }\n\n  function handleNextResult(doc, i, callback) {\n    let maybePromise;\n    try {\n      maybePromise = fn(doc, i);\n    } catch (err) {\n      return callback(err);\n    }\n    if (maybePromise && typeof maybePromise.then === 'function') {\n      maybePromise.then(\n        function() { callback(null); },\n        function(error) {\n          callback(error || new Error('`eachAsync()` promise rejected without error'));\n        });\n    } else {\n      callback(null);\n    }\n  }\n};\n\n// `next()` can only execute one at a time, so make sure we always execute\n// `next()` in series, while still allowing multiple `fn()` instances to run\n// in parallel.\nfunction asyncQueue() {\n  const _queue = [];\n  let inProgress = null;\n  let id = 0;\n\n  return function enqueue(fn) {\n    if (\n      inProgress === null &&\n      _queue.length === 0\n    ) {\n      inProgress = id++;\n      return fn(_step);\n    }\n    _queue.push(fn);\n  };\n\n  function _step() {\n    if (_queue.length !== 0) {\n      inProgress = id++;\n      const fn = _queue.shift();\n      fn(_step);\n    } else {\n      inProgress = null;\n    }\n  }\n}\n\nfunction createEachAsyncMultiError(aggregatedErrors) {\n  if (aggregatedErrors.length === 0) {\n    return null;\n  }\n\n  return new EachAsyncMultiError(aggregatedErrors);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9jdXJzb3IvZWFjaEFzeW5jLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0E7QUFDQTs7QUFFQSw0QkFBNEIsbUJBQU8sQ0FBQyx5R0FBaUM7QUFDckUsa0JBQWtCLG1CQUFPLENBQUMsOEVBQWM7O0FBRXhDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFVBQVU7QUFDckIsV0FBVyxVQUFVO0FBQ3JCLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsYUFBYTtBQUN4QixZQUFZO0FBQ1o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTyxJQUFJLFlBQVk7QUFDdkI7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0JBQW9CLGNBQWM7QUFDbEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLGlCQUFpQjtBQUN0QztBQUNBO0FBQ0EsU0FBUztBQUNULE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbGllbnQvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9jdXJzb3IvZWFjaEFzeW5jLmpzP2YzZTciXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG4vKiFcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxuY29uc3QgRWFjaEFzeW5jTXVsdGlFcnJvciA9IHJlcXVpcmUoJy4uLy4uL2Vycm9yL2VhY2hBc3luY011bHRpRXJyb3InKTtcbmNvbnN0IGltbWVkaWF0ZSA9IHJlcXVpcmUoJy4uL2ltbWVkaWF0ZScpO1xuXG4vKipcbiAqIEV4ZWN1dGUgYGZuYCBmb3IgZXZlcnkgZG9jdW1lbnQgaW4gdGhlIGN1cnNvci4gSWYgYGZuYCByZXR1cm5zIGEgcHJvbWlzZSxcbiAqIHdpbGwgd2FpdCBmb3IgdGhlIHByb21pc2UgdG8gcmVzb2x2ZSBiZWZvcmUgaXRlcmF0aW5nIG9uIHRvIHRoZSBuZXh0IG9uZS5cbiAqIFJldHVybnMgYSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2hlbiBkb25lLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IG5leHQgdGhlIHRodW5rIHRvIGNhbGwgdG8gZ2V0IHRoZSBuZXh0IGRvY3VtZW50XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5iYXRjaFNpemU9bnVsbF0gaWYgc2V0LCBNb25nb29zZSB3aWxsIGNhbGwgYGZuYCB3aXRoIGFuIGFycmF5IG9mIGF0IG1vc3QgYGJhdGNoU2l6ZWAgZG9jdW1lbnRzLCBpbnN0ZWFkIG9mIGEgc2luZ2xlIGRvY3VtZW50XG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMucGFyYWxsZWw9MV0gbWF4aW11bSBudW1iZXIgb2YgYGZuYCBjYWxscyB0aGF0IE1vbmdvb3NlIHdpbGwgcnVuIGluIHBhcmFsbGVsXG4gKiBAcGFyYW0ge0Fib3J0U2lnbmFsfSBbb3B0aW9ucy5zaWduYWxdIGFsbG93IGNhbmNlbGxpbmcgdGhpcyBlYWNoQXN5bmMoKS4gT25jZSB0aGUgYWJvcnQgc2lnbmFsIGlzIGZpcmVkLCBgZWFjaEFzeW5jKClgIHdpbGwgaW1tZWRpYXRlbHkgZnVsZmlsbCB0aGUgcmV0dXJuZWQgcHJvbWlzZSAob3IgY2FsbCB0aGUgY2FsbGJhY2spIGFuZCBub3QgZmV0Y2ggYW55IG1vcmUgZG9jdW1lbnRzLlxuICogQHJldHVybiB7UHJvbWlzZX1cbiAqIEBhcGkgcHVibGljXG4gKiBAbWV0aG9kIGVhY2hBc3luY1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0gYXN5bmMgZnVuY3Rpb24gZWFjaEFzeW5jKG5leHQsIGZuLCBvcHRpb25zKSB7XG4gIGNvbnN0IHBhcmFsbGVsID0gb3B0aW9ucy5wYXJhbGxlbCB8fCAxO1xuICBjb25zdCBiYXRjaFNpemUgPSBvcHRpb25zLmJhdGNoU2l6ZTtcbiAgY29uc3Qgc2lnbmFsID0gb3B0aW9ucy5zaWduYWw7XG4gIGNvbnN0IGNvbnRpbnVlT25FcnJvciA9IG9wdGlvbnMuY29udGludWVPbkVycm9yO1xuICBjb25zdCBhZ2dyZWdhdGVkRXJyb3JzID0gW107XG4gIGNvbnN0IGVucXVldWUgPSBhc3luY1F1ZXVlKCk7XG5cbiAgbGV0IGFib3J0ZWQgPSBmYWxzZTtcblxuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIGlmIChzaWduYWwgIT0gbnVsbCkge1xuICAgICAgaWYgKHNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICAgIHJldHVybiByZXNvbHZlKG51bGwpO1xuICAgICAgfVxuXG4gICAgICBzaWduYWwuYWRkRXZlbnRMaXN0ZW5lcignYWJvcnQnLCAoKSA9PiB7XG4gICAgICAgIGFib3J0ZWQgPSB0cnVlO1xuICAgICAgICByZXR1cm4gcmVzb2x2ZShudWxsKTtcbiAgICAgIH0sIHsgb25jZTogdHJ1ZSB9KTtcbiAgICB9XG5cbiAgICBpZiAoYmF0Y2hTaXplICE9IG51bGwpIHtcbiAgICAgIGlmICh0eXBlb2YgYmF0Y2hTaXplICE9PSAnbnVtYmVyJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdiYXRjaFNpemUgbXVzdCBiZSBhIG51bWJlcicpO1xuICAgICAgfSBlbHNlIGlmICghTnVtYmVyLmlzSW50ZWdlcihiYXRjaFNpemUpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2JhdGNoU2l6ZSBtdXN0IGJlIGFuIGludGVnZXInKTtcbiAgICAgIH0gZWxzZSBpZiAoYmF0Y2hTaXplIDwgMSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdiYXRjaFNpemUgbXVzdCBiZSBhdCBsZWFzdCAxJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaXRlcmF0ZSgoZXJyLCByZXMpID0+IHtcbiAgICAgIGlmIChlcnIgIT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gcmVqZWN0KGVycik7XG4gICAgICB9XG4gICAgICByZXNvbHZlKHJlcyk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGZ1bmN0aW9uIGl0ZXJhdGUoZmluYWxDYWxsYmFjaykge1xuICAgIGxldCBoYW5kbGVSZXN1bHRzSW5Qcm9ncmVzcyA9IDA7XG4gICAgbGV0IGN1cnJlbnREb2N1bWVudEluZGV4ID0gMDtcblxuICAgIGxldCBlcnJvciA9IG51bGw7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXJhbGxlbDsgKytpKSB7XG4gICAgICBlbnF1ZXVlKGNyZWF0ZUZldGNoKCkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZUZldGNoKCkge1xuICAgICAgbGV0IGRvY3VtZW50c0JhdGNoID0gW107XG4gICAgICBsZXQgZHJhaW5lZCA9IGZhbHNlO1xuXG4gICAgICByZXR1cm4gZmV0Y2g7XG5cbiAgICAgIGZ1bmN0aW9uIGZldGNoKGRvbmUpIHtcbiAgICAgICAgaWYgKGRyYWluZWQgfHwgYWJvcnRlZCkge1xuICAgICAgICAgIHJldHVybiBkb25lKCk7XG4gICAgICAgIH0gZWxzZSBpZiAoZXJyb3IpIHtcbiAgICAgICAgICByZXR1cm4gZG9uZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgbmV4dChmdW5jdGlvbihlcnIsIGRvYykge1xuICAgICAgICAgIGlmIChlcnJvciAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gZG9uZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZXJyICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChlcnIubmFtZSA9PT0gJ01vbmdvQ3Vyc29yRXhoYXVzdGVkRXJyb3InKSB7XG4gICAgICAgICAgICAgIC8vIFdlIG1heSBlbmQgdXAgY2FsbGluZyBgbmV4dCgpYCBtdWx0aXBsZSB0aW1lcyBvbiBhbiBleGhhdXN0ZWRcbiAgICAgICAgICAgICAgLy8gY3Vyc29yLCB3aGljaCBsZWFkcyB0byBhbiBlcnJvci4gSW4gY2FzZSBjdXJzb3IgaXMgZXhoYXVzdGVkLFxuICAgICAgICAgICAgICAvLyBqdXN0IHRyZWF0IGl0IGFzIGlmIHRoZSBjdXJzb3IgcmV0dXJuZWQgbm8gZG9jdW1lbnQsIHdoaWNoIGlzXG4gICAgICAgICAgICAgIC8vIGhvdyBhIGN1cnNvciBpbmRpY2F0ZXMgaXQgaXMgZXhoYXVzdGVkLlxuICAgICAgICAgICAgICBkb2MgPSBudWxsO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChjb250aW51ZU9uRXJyb3IpIHtcbiAgICAgICAgICAgICAgYWdncmVnYXRlZEVycm9ycy5wdXNoKGVycik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBlcnJvciA9IGVycjtcbiAgICAgICAgICAgICAgZmluYWxDYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgICByZXR1cm4gZG9uZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZG9jID09IG51bGwpIHtcbiAgICAgICAgICAgIGRyYWluZWQgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKGhhbmRsZVJlc3VsdHNJblByb2dyZXNzIDw9IDApIHtcbiAgICAgICAgICAgICAgY29uc3QgZmluYWxFcnIgPSBjb250aW51ZU9uRXJyb3IgP1xuICAgICAgICAgICAgICAgIGNyZWF0ZUVhY2hBc3luY011bHRpRXJyb3IoYWdncmVnYXRlZEVycm9ycykgOlxuICAgICAgICAgICAgICAgIGVycm9yO1xuXG4gICAgICAgICAgICAgIGZpbmFsQ2FsbGJhY2soZmluYWxFcnIpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChiYXRjaFNpemUgJiYgZG9jdW1lbnRzQmF0Y2gubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIGhhbmRsZU5leHRSZXN1bHQoZG9jdW1lbnRzQmF0Y2gsIGN1cnJlbnREb2N1bWVudEluZGV4KyssIGhhbmRsZU5leHRSZXN1bHRDYWxsQmFjayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZG9uZSgpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgICsraGFuZGxlUmVzdWx0c0luUHJvZ3Jlc3M7XG5cbiAgICAgICAgICAvLyBLaWNrIG9mZiB0aGUgc3Vic2VxdWVudCBgbmV4dCgpYCBiZWZvcmUgaGFuZGxpbmcgdGhlIHJlc3VsdCwgYnV0XG4gICAgICAgICAgLy8gbWFrZSBzdXJlIHdlIGtub3cgdGhhdCB3ZSBzdGlsbCBoYXZlIGEgcmVzdWx0IHRvIGhhbmRsZSByZTogIzg0MjJcbiAgICAgICAgICBpbW1lZGlhdGUoKCkgPT4gZG9uZSgpKTtcblxuICAgICAgICAgIGlmIChiYXRjaFNpemUpIHtcbiAgICAgICAgICAgIGRvY3VtZW50c0JhdGNoLnB1c2goZG9jKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBJZiB0aGUgY3VycmVudCBkb2N1bWVudHMgc2l6ZSBpcyBsZXNzIHRoYW4gdGhlIHByb3ZpZGVkIGJhdGNoIHNpemUgZG9uJ3QgcHJvY2VzcyB0aGUgZG9jdW1lbnRzIHlldFxuICAgICAgICAgIGlmIChiYXRjaFNpemUgJiYgZG9jdW1lbnRzQmF0Y2gubGVuZ3RoICE9PSBiYXRjaFNpemUpIHtcbiAgICAgICAgICAgIGltbWVkaWF0ZSgoKSA9PiBlbnF1ZXVlKGZldGNoKSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uc3QgZG9jc1RvUHJvY2VzcyA9IGJhdGNoU2l6ZSA/IGRvY3VtZW50c0JhdGNoIDogZG9jO1xuXG4gICAgICAgICAgZnVuY3Rpb24gaGFuZGxlTmV4dFJlc3VsdENhbGxCYWNrKGVycikge1xuICAgICAgICAgICAgaWYgKGJhdGNoU2l6ZSkge1xuICAgICAgICAgICAgICBoYW5kbGVSZXN1bHRzSW5Qcm9ncmVzcyAtPSBkb2N1bWVudHNCYXRjaC5sZW5ndGg7XG4gICAgICAgICAgICAgIGRvY3VtZW50c0JhdGNoID0gW107XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAtLWhhbmRsZVJlc3VsdHNJblByb2dyZXNzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGVyciAhPSBudWxsKSB7XG4gICAgICAgICAgICAgIGlmIChjb250aW51ZU9uRXJyb3IpIHtcbiAgICAgICAgICAgICAgICBhZ2dyZWdhdGVkRXJyb3JzLnB1c2goZXJyKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBlcnJvciA9IGVycjtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmluYWxDYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoKGRyYWluZWQgfHwgYWJvcnRlZCkgJiYgaGFuZGxlUmVzdWx0c0luUHJvZ3Jlc3MgPD0gMCkge1xuICAgICAgICAgICAgICBjb25zdCBmaW5hbEVyciA9IGNvbnRpbnVlT25FcnJvciA/XG4gICAgICAgICAgICAgICAgY3JlYXRlRWFjaEFzeW5jTXVsdGlFcnJvcihhZ2dyZWdhdGVkRXJyb3JzKSA6XG4gICAgICAgICAgICAgICAgZXJyb3I7XG4gICAgICAgICAgICAgIHJldHVybiBmaW5hbENhbGxiYWNrKGZpbmFsRXJyKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaW1tZWRpYXRlKCgpID0+IGVucXVldWUoZmV0Y2gpKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBoYW5kbGVOZXh0UmVzdWx0KGRvY3NUb1Byb2Nlc3MsIGN1cnJlbnREb2N1bWVudEluZGV4KyssIGhhbmRsZU5leHRSZXN1bHRDYWxsQmFjayk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGhhbmRsZU5leHRSZXN1bHQoZG9jLCBpLCBjYWxsYmFjaykge1xuICAgIGxldCBtYXliZVByb21pc2U7XG4gICAgdHJ5IHtcbiAgICAgIG1heWJlUHJvbWlzZSA9IGZuKGRvYywgaSk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICB9XG4gICAgaWYgKG1heWJlUHJvbWlzZSAmJiB0eXBlb2YgbWF5YmVQcm9taXNlLnRoZW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIG1heWJlUHJvbWlzZS50aGVuKFxuICAgICAgICBmdW5jdGlvbigpIHsgY2FsbGJhY2sobnVsbCk7IH0sXG4gICAgICAgIGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgICAgICAgY2FsbGJhY2soZXJyb3IgfHwgbmV3IEVycm9yKCdgZWFjaEFzeW5jKClgIHByb21pc2UgcmVqZWN0ZWQgd2l0aG91dCBlcnJvcicpKTtcbiAgICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNhbGxiYWNrKG51bGwpO1xuICAgIH1cbiAgfVxufTtcblxuLy8gYG5leHQoKWAgY2FuIG9ubHkgZXhlY3V0ZSBvbmUgYXQgYSB0aW1lLCBzbyBtYWtlIHN1cmUgd2UgYWx3YXlzIGV4ZWN1dGVcbi8vIGBuZXh0KClgIGluIHNlcmllcywgd2hpbGUgc3RpbGwgYWxsb3dpbmcgbXVsdGlwbGUgYGZuKClgIGluc3RhbmNlcyB0byBydW5cbi8vIGluIHBhcmFsbGVsLlxuZnVuY3Rpb24gYXN5bmNRdWV1ZSgpIHtcbiAgY29uc3QgX3F1ZXVlID0gW107XG4gIGxldCBpblByb2dyZXNzID0gbnVsbDtcbiAgbGV0IGlkID0gMDtcblxuICByZXR1cm4gZnVuY3Rpb24gZW5xdWV1ZShmbikge1xuICAgIGlmIChcbiAgICAgIGluUHJvZ3Jlc3MgPT09IG51bGwgJiZcbiAgICAgIF9xdWV1ZS5sZW5ndGggPT09IDBcbiAgICApIHtcbiAgICAgIGluUHJvZ3Jlc3MgPSBpZCsrO1xuICAgICAgcmV0dXJuIGZuKF9zdGVwKTtcbiAgICB9XG4gICAgX3F1ZXVlLnB1c2goZm4pO1xuICB9O1xuXG4gIGZ1bmN0aW9uIF9zdGVwKCkge1xuICAgIGlmIChfcXVldWUubGVuZ3RoICE9PSAwKSB7XG4gICAgICBpblByb2dyZXNzID0gaWQrKztcbiAgICAgIGNvbnN0IGZuID0gX3F1ZXVlLnNoaWZ0KCk7XG4gICAgICBmbihfc3RlcCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGluUHJvZ3Jlc3MgPSBudWxsO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVFYWNoQXN5bmNNdWx0aUVycm9yKGFnZ3JlZ2F0ZWRFcnJvcnMpIHtcbiAgaWYgKGFnZ3JlZ2F0ZWRFcnJvcnMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICByZXR1cm4gbmV3IEVhY2hBc3luY011bHRpRXJyb3IoYWdncmVnYXRlZEVycm9ycyk7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../server/node_modules/mongoose/lib/helpers/cursor/eachAsync.js\n");

/***/ }),

/***/ "../server/node_modules/mongoose/lib/helpers/discriminator/applyEmbeddedDiscriminators.js":
/*!************************************************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/helpers/discriminator/applyEmbeddedDiscriminators.js ***!
  \************************************************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nmodule.exports = applyEmbeddedDiscriminators;\n\nfunction applyEmbeddedDiscriminators(schema, seen = new WeakSet()) {\n  if (seen.has(schema)) {\n    return;\n  }\n  seen.add(schema);\n  for (const path of Object.keys(schema.paths)) {\n    const schemaType = schema.paths[path];\n    if (!schemaType.schema) {\n      continue;\n    }\n    applyEmbeddedDiscriminators(schemaType.schema, seen);\n    if (!schemaType.schema._applyDiscriminators) {\n      continue;\n    }\n    if (schemaType._appliedDiscriminators) {\n      continue;\n    }\n    for (const disc of schemaType.schema._applyDiscriminators.keys()) {\n      schemaType.discriminator(\n        disc,\n        schemaType.schema._applyDiscriminators.get(disc)\n      );\n    }\n    schemaType._appliedDiscriminators = true;\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9kaXNjcmltaW5hdG9yL2FwcGx5RW1iZWRkZWREaXNjcmltaW5hdG9ycy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2xpZW50Ly4uL3NlcnZlci9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvZGlzY3JpbWluYXRvci9hcHBseUVtYmVkZGVkRGlzY3JpbWluYXRvcnMuanM/NzU5ZiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gYXBwbHlFbWJlZGRlZERpc2NyaW1pbmF0b3JzO1xuXG5mdW5jdGlvbiBhcHBseUVtYmVkZGVkRGlzY3JpbWluYXRvcnMoc2NoZW1hLCBzZWVuID0gbmV3IFdlYWtTZXQoKSkge1xuICBpZiAoc2Vlbi5oYXMoc2NoZW1hKSkge1xuICAgIHJldHVybjtcbiAgfVxuICBzZWVuLmFkZChzY2hlbWEpO1xuICBmb3IgKGNvbnN0IHBhdGggb2YgT2JqZWN0LmtleXMoc2NoZW1hLnBhdGhzKSkge1xuICAgIGNvbnN0IHNjaGVtYVR5cGUgPSBzY2hlbWEucGF0aHNbcGF0aF07XG4gICAgaWYgKCFzY2hlbWFUeXBlLnNjaGVtYSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGFwcGx5RW1iZWRkZWREaXNjcmltaW5hdG9ycyhzY2hlbWFUeXBlLnNjaGVtYSwgc2Vlbik7XG4gICAgaWYgKCFzY2hlbWFUeXBlLnNjaGVtYS5fYXBwbHlEaXNjcmltaW5hdG9ycykge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChzY2hlbWFUeXBlLl9hcHBsaWVkRGlzY3JpbWluYXRvcnMpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGRpc2Mgb2Ygc2NoZW1hVHlwZS5zY2hlbWEuX2FwcGx5RGlzY3JpbWluYXRvcnMua2V5cygpKSB7XG4gICAgICBzY2hlbWFUeXBlLmRpc2NyaW1pbmF0b3IoXG4gICAgICAgIGRpc2MsXG4gICAgICAgIHNjaGVtYVR5cGUuc2NoZW1hLl9hcHBseURpc2NyaW1pbmF0b3JzLmdldChkaXNjKVxuICAgICAgKTtcbiAgICB9XG4gICAgc2NoZW1hVHlwZS5fYXBwbGllZERpc2NyaW1pbmF0b3JzID0gdHJ1ZTtcbiAgfVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../server/node_modules/mongoose/lib/helpers/discriminator/applyEmbeddedDiscriminators.js\n");

/***/ }),

/***/ "../server/node_modules/mongoose/lib/helpers/discriminator/areDiscriminatorValuesEqual.js":
/*!************************************************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/helpers/discriminator/areDiscriminatorValuesEqual.js ***!
  \************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst isBsonType = __webpack_require__(/*! ../isBsonType */ \"../server/node_modules/mongoose/lib/helpers/isBsonType.js\");\n\nmodule.exports = function areDiscriminatorValuesEqual(a, b) {\n  if (typeof a === 'string' && typeof b === 'string') {\n    return a === b;\n  }\n  if (typeof a === 'number' && typeof b === 'number') {\n    return a === b;\n  }\n  if (isBsonType(a, 'ObjectId') && isBsonType(b, 'ObjectId')) {\n    return a.toString() === b.toString();\n  }\n  return false;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9kaXNjcmltaW5hdG9yL2FyZURpc2NyaW1pbmF0b3JWYWx1ZXNFcXVhbC5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixtQkFBbUIsbUJBQU8sQ0FBQyxnRkFBZTs7QUFFMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2xpZW50Ly4uL3NlcnZlci9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvZGlzY3JpbWluYXRvci9hcmVEaXNjcmltaW5hdG9yVmFsdWVzRXF1YWwuanM/MTkyYSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IGlzQnNvblR5cGUgPSByZXF1aXJlKCcuLi9pc0Jzb25UeXBlJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gYXJlRGlzY3JpbWluYXRvclZhbHVlc0VxdWFsKGEsIGIpIHtcbiAgaWYgKHR5cGVvZiBhID09PSAnc3RyaW5nJyAmJiB0eXBlb2YgYiA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gYSA9PT0gYjtcbiAgfVxuICBpZiAodHlwZW9mIGEgPT09ICdudW1iZXInICYmIHR5cGVvZiBiID09PSAnbnVtYmVyJykge1xuICAgIHJldHVybiBhID09PSBiO1xuICB9XG4gIGlmIChpc0Jzb25UeXBlKGEsICdPYmplY3RJZCcpICYmIGlzQnNvblR5cGUoYiwgJ09iamVjdElkJykpIHtcbiAgICByZXR1cm4gYS50b1N0cmluZygpID09PSBiLnRvU3RyaW5nKCk7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../server/node_modules/mongoose/lib/helpers/discriminator/areDiscriminatorValuesEqual.js\n");

/***/ }),

/***/ "../server/node_modules/mongoose/lib/helpers/discriminator/checkEmbeddedDiscriminatorKeyProjection.js":
/*!************************************************************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/helpers/discriminator/checkEmbeddedDiscriminatorKeyProjection.js ***!
  \************************************************************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nmodule.exports = function checkEmbeddedDiscriminatorKeyProjection(userProjection, path, schema, selected, addedPaths) {\n  const userProjectedInPath = Object.keys(userProjection).\n    reduce((cur, key) => cur || key.startsWith(path + '.'), false);\n  const _discriminatorKey = path + '.' + schema.options.discriminatorKey;\n  if (!userProjectedInPath &&\n      addedPaths.length === 1 &&\n      addedPaths[0] === _discriminatorKey) {\n    selected.splice(selected.indexOf(_discriminatorKey), 1);\n  }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9kaXNjcmltaW5hdG9yL2NoZWNrRW1iZWRkZWREaXNjcmltaW5hdG9yS2V5UHJvamVjdGlvbi5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2NsaWVudC8uLi9zZXJ2ZXIvbm9kZV9tb2R1bGVzL21vbmdvb3NlL2xpYi9oZWxwZXJzL2Rpc2NyaW1pbmF0b3IvY2hlY2tFbWJlZGRlZERpc2NyaW1pbmF0b3JLZXlQcm9qZWN0aW9uLmpzP2Q0MWIiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGNoZWNrRW1iZWRkZWREaXNjcmltaW5hdG9yS2V5UHJvamVjdGlvbih1c2VyUHJvamVjdGlvbiwgcGF0aCwgc2NoZW1hLCBzZWxlY3RlZCwgYWRkZWRQYXRocykge1xuICBjb25zdCB1c2VyUHJvamVjdGVkSW5QYXRoID0gT2JqZWN0LmtleXModXNlclByb2plY3Rpb24pLlxuICAgIHJlZHVjZSgoY3VyLCBrZXkpID0+IGN1ciB8fCBrZXkuc3RhcnRzV2l0aChwYXRoICsgJy4nKSwgZmFsc2UpO1xuICBjb25zdCBfZGlzY3JpbWluYXRvcktleSA9IHBhdGggKyAnLicgKyBzY2hlbWEub3B0aW9ucy5kaXNjcmltaW5hdG9yS2V5O1xuICBpZiAoIXVzZXJQcm9qZWN0ZWRJblBhdGggJiZcbiAgICAgIGFkZGVkUGF0aHMubGVuZ3RoID09PSAxICYmXG4gICAgICBhZGRlZFBhdGhzWzBdID09PSBfZGlzY3JpbWluYXRvcktleSkge1xuICAgIHNlbGVjdGVkLnNwbGljZShzZWxlY3RlZC5pbmRleE9mKF9kaXNjcmltaW5hdG9yS2V5KSwgMSk7XG4gIH1cbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../server/node_modules/mongoose/lib/helpers/discriminator/checkEmbeddedDiscriminatorKeyProjection.js\n");

/***/ }),

/***/ "../server/node_modules/mongoose/lib/helpers/discriminator/getConstructor.js":
/*!***********************************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/helpers/discriminator/getConstructor.js ***!
  \***********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst getDiscriminatorByValue = __webpack_require__(/*! ./getDiscriminatorByValue */ \"../server/node_modules/mongoose/lib/helpers/discriminator/getDiscriminatorByValue.js\");\n\n/**\n * Find the correct constructor, taking into account discriminators\n * @api private\n */\n\nmodule.exports = function getConstructor(Constructor, value, defaultDiscriminatorValue) {\n  const discriminatorKey = Constructor.schema.options.discriminatorKey;\n  let discriminatorValue = (value != null && value[discriminatorKey]);\n  if (discriminatorValue == null) {\n    discriminatorValue = defaultDiscriminatorValue;\n  }\n  if (Constructor.discriminators &&\n      discriminatorValue != null) {\n    if (Constructor.discriminators[discriminatorValue]) {\n      Constructor = Constructor.discriminators[discriminatorValue];\n    } else {\n      const constructorByValue = getDiscriminatorByValue(Constructor.discriminators, discriminatorValue);\n      if (constructorByValue) {\n        Constructor = constructorByValue;\n      }\n    }\n  }\n\n  return Constructor;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9kaXNjcmltaW5hdG9yL2dldENvbnN0cnVjdG9yLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLGdDQUFnQyxtQkFBTyxDQUFDLHVIQUEyQjs7QUFFbkU7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbGllbnQvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9kaXNjcmltaW5hdG9yL2dldENvbnN0cnVjdG9yLmpzPzU1NWQiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBnZXREaXNjcmltaW5hdG9yQnlWYWx1ZSA9IHJlcXVpcmUoJy4vZ2V0RGlzY3JpbWluYXRvckJ5VmFsdWUnKTtcblxuLyoqXG4gKiBGaW5kIHRoZSBjb3JyZWN0IGNvbnN0cnVjdG9yLCB0YWtpbmcgaW50byBhY2NvdW50IGRpc2NyaW1pbmF0b3JzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGdldENvbnN0cnVjdG9yKENvbnN0cnVjdG9yLCB2YWx1ZSwgZGVmYXVsdERpc2NyaW1pbmF0b3JWYWx1ZSkge1xuICBjb25zdCBkaXNjcmltaW5hdG9yS2V5ID0gQ29uc3RydWN0b3Iuc2NoZW1hLm9wdGlvbnMuZGlzY3JpbWluYXRvcktleTtcbiAgbGV0IGRpc2NyaW1pbmF0b3JWYWx1ZSA9ICh2YWx1ZSAhPSBudWxsICYmIHZhbHVlW2Rpc2NyaW1pbmF0b3JLZXldKTtcbiAgaWYgKGRpc2NyaW1pbmF0b3JWYWx1ZSA9PSBudWxsKSB7XG4gICAgZGlzY3JpbWluYXRvclZhbHVlID0gZGVmYXVsdERpc2NyaW1pbmF0b3JWYWx1ZTtcbiAgfVxuICBpZiAoQ29uc3RydWN0b3IuZGlzY3JpbWluYXRvcnMgJiZcbiAgICAgIGRpc2NyaW1pbmF0b3JWYWx1ZSAhPSBudWxsKSB7XG4gICAgaWYgKENvbnN0cnVjdG9yLmRpc2NyaW1pbmF0b3JzW2Rpc2NyaW1pbmF0b3JWYWx1ZV0pIHtcbiAgICAgIENvbnN0cnVjdG9yID0gQ29uc3RydWN0b3IuZGlzY3JpbWluYXRvcnNbZGlzY3JpbWluYXRvclZhbHVlXTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgY29uc3RydWN0b3JCeVZhbHVlID0gZ2V0RGlzY3JpbWluYXRvckJ5VmFsdWUoQ29uc3RydWN0b3IuZGlzY3JpbWluYXRvcnMsIGRpc2NyaW1pbmF0b3JWYWx1ZSk7XG4gICAgICBpZiAoY29uc3RydWN0b3JCeVZhbHVlKSB7XG4gICAgICAgIENvbnN0cnVjdG9yID0gY29uc3RydWN0b3JCeVZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBDb25zdHJ1Y3Rvcjtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../server/node_modules/mongoose/lib/helpers/discriminator/getConstructor.js\n");

/***/ }),

/***/ "../server/node_modules/mongoose/lib/helpers/discriminator/getDiscriminatorByValue.js":
/*!********************************************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/helpers/discriminator/getDiscriminatorByValue.js ***!
  \********************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst areDiscriminatorValuesEqual = __webpack_require__(/*! ./areDiscriminatorValuesEqual */ \"../server/node_modules/mongoose/lib/helpers/discriminator/areDiscriminatorValuesEqual.js\");\n\n/**\n * returns discriminator by discriminatorMapping.value\n *\n * @param {Object} discriminators\n * @param {string} value\n * @api private\n */\n\nmodule.exports = function getDiscriminatorByValue(discriminators, value) {\n  if (discriminators == null) {\n    return null;\n  }\n  for (const name of Object.keys(discriminators)) {\n    const it = discriminators[name];\n    if (\n      it.schema &&\n      it.schema.discriminatorMapping &&\n      areDiscriminatorValuesEqual(it.schema.discriminatorMapping.value, value)\n    ) {\n      return it;\n    }\n  }\n  return null;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9kaXNjcmltaW5hdG9yL2dldERpc2NyaW1pbmF0b3JCeVZhbHVlLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLG9DQUFvQyxtQkFBTyxDQUFDLCtIQUErQjs7QUFFM0U7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2xpZW50Ly4uL3NlcnZlci9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvZGlzY3JpbWluYXRvci9nZXREaXNjcmltaW5hdG9yQnlWYWx1ZS5qcz84NDNjIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3QgYXJlRGlzY3JpbWluYXRvclZhbHVlc0VxdWFsID0gcmVxdWlyZSgnLi9hcmVEaXNjcmltaW5hdG9yVmFsdWVzRXF1YWwnKTtcblxuLyoqXG4gKiByZXR1cm5zIGRpc2NyaW1pbmF0b3IgYnkgZGlzY3JpbWluYXRvck1hcHBpbmcudmFsdWVcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gZGlzY3JpbWluYXRvcnNcbiAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBnZXREaXNjcmltaW5hdG9yQnlWYWx1ZShkaXNjcmltaW5hdG9ycywgdmFsdWUpIHtcbiAgaWYgKGRpc2NyaW1pbmF0b3JzID09IG51bGwpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBmb3IgKGNvbnN0IG5hbWUgb2YgT2JqZWN0LmtleXMoZGlzY3JpbWluYXRvcnMpKSB7XG4gICAgY29uc3QgaXQgPSBkaXNjcmltaW5hdG9yc1tuYW1lXTtcbiAgICBpZiAoXG4gICAgICBpdC5zY2hlbWEgJiZcbiAgICAgIGl0LnNjaGVtYS5kaXNjcmltaW5hdG9yTWFwcGluZyAmJlxuICAgICAgYXJlRGlzY3JpbWluYXRvclZhbHVlc0VxdWFsKGl0LnNjaGVtYS5kaXNjcmltaW5hdG9yTWFwcGluZy52YWx1ZSwgdmFsdWUpXG4gICAgKSB7XG4gICAgICByZXR1cm4gaXQ7XG4gICAgfVxuICB9XG4gIHJldHVybiBudWxsO1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../server/node_modules/mongoose/lib/helpers/discriminator/getDiscriminatorByValue.js\n");

/***/ }),

/***/ "../server/node_modules/mongoose/lib/helpers/discriminator/getSchemaDiscriminatorByValue.js":
/*!**************************************************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/helpers/discriminator/getSchemaDiscriminatorByValue.js ***!
  \**************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst areDiscriminatorValuesEqual = __webpack_require__(/*! ./areDiscriminatorValuesEqual */ \"../server/node_modules/mongoose/lib/helpers/discriminator/areDiscriminatorValuesEqual.js\");\n\n/**\n * returns discriminator by discriminatorMapping.value\n *\n * @param {Schema} schema\n * @param {string} value\n * @api private\n */\n\nmodule.exports = function getSchemaDiscriminatorByValue(schema, value) {\n  if (schema == null || schema.discriminators == null) {\n    return null;\n  }\n  for (const key of Object.keys(schema.discriminators)) {\n    const discriminatorSchema = schema.discriminators[key];\n    if (discriminatorSchema.discriminatorMapping == null) {\n      continue;\n    }\n    if (areDiscriminatorValuesEqual(discriminatorSchema.discriminatorMapping.value, value)) {\n      return discriminatorSchema;\n    }\n  }\n  return null;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9kaXNjcmltaW5hdG9yL2dldFNjaGVtYURpc2NyaW1pbmF0b3JCeVZhbHVlLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLG9DQUFvQyxtQkFBTyxDQUFDLCtIQUErQjs7QUFFM0U7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2NsaWVudC8uLi9zZXJ2ZXIvbm9kZV9tb2R1bGVzL21vbmdvb3NlL2xpYi9oZWxwZXJzL2Rpc2NyaW1pbmF0b3IvZ2V0U2NoZW1hRGlzY3JpbWluYXRvckJ5VmFsdWUuanM/MGE0YSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IGFyZURpc2NyaW1pbmF0b3JWYWx1ZXNFcXVhbCA9IHJlcXVpcmUoJy4vYXJlRGlzY3JpbWluYXRvclZhbHVlc0VxdWFsJyk7XG5cbi8qKlxuICogcmV0dXJucyBkaXNjcmltaW5hdG9yIGJ5IGRpc2NyaW1pbmF0b3JNYXBwaW5nLnZhbHVlXG4gKlxuICogQHBhcmFtIHtTY2hlbWF9IHNjaGVtYVxuICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGdldFNjaGVtYURpc2NyaW1pbmF0b3JCeVZhbHVlKHNjaGVtYSwgdmFsdWUpIHtcbiAgaWYgKHNjaGVtYSA9PSBudWxsIHx8IHNjaGVtYS5kaXNjcmltaW5hdG9ycyA9PSBudWxsKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMoc2NoZW1hLmRpc2NyaW1pbmF0b3JzKSkge1xuICAgIGNvbnN0IGRpc2NyaW1pbmF0b3JTY2hlbWEgPSBzY2hlbWEuZGlzY3JpbWluYXRvcnNba2V5XTtcbiAgICBpZiAoZGlzY3JpbWluYXRvclNjaGVtYS5kaXNjcmltaW5hdG9yTWFwcGluZyA9PSBudWxsKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKGFyZURpc2NyaW1pbmF0b3JWYWx1ZXNFcXVhbChkaXNjcmltaW5hdG9yU2NoZW1hLmRpc2NyaW1pbmF0b3JNYXBwaW5nLnZhbHVlLCB2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBkaXNjcmltaW5hdG9yU2NoZW1hO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbnVsbDtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../server/node_modules/mongoose/lib/helpers/discriminator/getSchemaDiscriminatorByValue.js\n");

/***/ }),

/***/ "../server/node_modules/mongoose/lib/helpers/discriminator/mergeDiscriminatorSchema.js":
/*!*********************************************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/helpers/discriminator/mergeDiscriminatorSchema.js ***!
  \*********************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst schemaMerge = __webpack_require__(/*! ../schema/merge */ \"../server/node_modules/mongoose/lib/helpers/schema/merge.js\");\nconst specialProperties = __webpack_require__(/*! ../../helpers/specialProperties */ \"../server/node_modules/mongoose/lib/helpers/specialProperties.js\");\nconst isBsonType = __webpack_require__(/*! ../../helpers/isBsonType */ \"../server/node_modules/mongoose/lib/helpers/isBsonType.js\");\nconst ObjectId = __webpack_require__(/*! ../../types/objectid */ \"../server/node_modules/mongoose/lib/types/objectid.js\");\nconst isObject = __webpack_require__(/*! ../../helpers/isObject */ \"../server/node_modules/mongoose/lib/helpers/isObject.js\");\n/**\n * Merges `from` into `to` without overwriting existing properties.\n *\n * @param {Object} to\n * @param {Object} from\n * @param {String} [path]\n * @api private\n */\n\nmodule.exports = function mergeDiscriminatorSchema(to, from, path, seen) {\n  const keys = Object.keys(from);\n  let i = 0;\n  const len = keys.length;\n  let key;\n\n  path = path || '';\n  seen = seen || new WeakSet();\n\n  if (seen.has(from)) {\n    return;\n  }\n  seen.add(from);\n\n  while (i < len) {\n    key = keys[i++];\n    if (!path) {\n      if (key === 'discriminators' ||\n        key === 'base' ||\n        key === '_applyDiscriminators' ||\n        key === '_userProvidedOptions' ||\n        key === 'options' ||\n        key === 'tree') {\n        continue;\n      }\n    }\n    if (path === 'tree' && from != null && from.instanceOfSchema) {\n      continue;\n    }\n    if (specialProperties.has(key)) {\n      continue;\n    }\n    if (to[key] == null) {\n      to[key] = from[key];\n    } else if (isObject(from[key])) {\n      if (!isObject(to[key])) {\n        to[key] = {};\n      }\n      if (from[key] != null) {\n        // Skip merging schemas if we're creating a discriminator schema and\n        // base schema has a given path as a single nested but discriminator schema\n        // has the path as a document array, or vice versa (gh-9534)\n        if ((from[key].$isSingleNested && to[key].$isMongooseDocumentArray) ||\n              (from[key].$isMongooseDocumentArray && to[key].$isSingleNested) ||\n              (from[key].$isMongooseDocumentArrayElement && to[key].$isMongooseDocumentArrayElement)) {\n          continue;\n        } else if (from[key].instanceOfSchema) {\n          if (to[key].instanceOfSchema) {\n            schemaMerge(to[key], from[key].clone(), true);\n          } else {\n            to[key] = from[key].clone();\n          }\n          continue;\n        } else if (isBsonType(from[key], 'ObjectId')) {\n          to[key] = new ObjectId(from[key]);\n          continue;\n        }\n      }\n      mergeDiscriminatorSchema(to[key], from[key], path ? path + '.' + key : key, seen);\n    }\n  }\n\n  if (from != null && from.instanceOfSchema) {\n    to.tree = Object.assign({}, from.tree, to.tree);\n  }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9kaXNjcmltaW5hdG9yL21lcmdlRGlzY3JpbWluYXRvclNjaGVtYS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLG9CQUFvQixtQkFBTyxDQUFDLG9GQUFpQjtBQUM3QywwQkFBMEIsbUJBQU8sQ0FBQyx5R0FBaUM7QUFDbkUsbUJBQW1CLG1CQUFPLENBQUMsMkZBQTBCO0FBQ3JELGlCQUFpQixtQkFBTyxDQUFDLG1GQUFzQjtBQUMvQyxpQkFBaUIsbUJBQU8sQ0FBQyx1RkFBd0I7QUFDakQ7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbGllbnQvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9kaXNjcmltaW5hdG9yL21lcmdlRGlzY3JpbWluYXRvclNjaGVtYS5qcz80OGM4Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcbmNvbnN0IHNjaGVtYU1lcmdlID0gcmVxdWlyZSgnLi4vc2NoZW1hL21lcmdlJyk7XG5jb25zdCBzcGVjaWFsUHJvcGVydGllcyA9IHJlcXVpcmUoJy4uLy4uL2hlbHBlcnMvc3BlY2lhbFByb3BlcnRpZXMnKTtcbmNvbnN0IGlzQnNvblR5cGUgPSByZXF1aXJlKCcuLi8uLi9oZWxwZXJzL2lzQnNvblR5cGUnKTtcbmNvbnN0IE9iamVjdElkID0gcmVxdWlyZSgnLi4vLi4vdHlwZXMvb2JqZWN0aWQnKTtcbmNvbnN0IGlzT2JqZWN0ID0gcmVxdWlyZSgnLi4vLi4vaGVscGVycy9pc09iamVjdCcpO1xuLyoqXG4gKiBNZXJnZXMgYGZyb21gIGludG8gYHRvYCB3aXRob3V0IG92ZXJ3cml0aW5nIGV4aXN0aW5nIHByb3BlcnRpZXMuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHRvXG4gKiBAcGFyYW0ge09iamVjdH0gZnJvbVxuICogQHBhcmFtIHtTdHJpbmd9IFtwYXRoXVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBtZXJnZURpc2NyaW1pbmF0b3JTY2hlbWEodG8sIGZyb20sIHBhdGgsIHNlZW4pIHtcbiAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKGZyb20pO1xuICBsZXQgaSA9IDA7XG4gIGNvbnN0IGxlbiA9IGtleXMubGVuZ3RoO1xuICBsZXQga2V5O1xuXG4gIHBhdGggPSBwYXRoIHx8ICcnO1xuICBzZWVuID0gc2VlbiB8fCBuZXcgV2Vha1NldCgpO1xuXG4gIGlmIChzZWVuLmhhcyhmcm9tKSkge1xuICAgIHJldHVybjtcbiAgfVxuICBzZWVuLmFkZChmcm9tKTtcblxuICB3aGlsZSAoaSA8IGxlbikge1xuICAgIGtleSA9IGtleXNbaSsrXTtcbiAgICBpZiAoIXBhdGgpIHtcbiAgICAgIGlmIChrZXkgPT09ICdkaXNjcmltaW5hdG9ycycgfHxcbiAgICAgICAga2V5ID09PSAnYmFzZScgfHxcbiAgICAgICAga2V5ID09PSAnX2FwcGx5RGlzY3JpbWluYXRvcnMnIHx8XG4gICAgICAgIGtleSA9PT0gJ191c2VyUHJvdmlkZWRPcHRpb25zJyB8fFxuICAgICAgICBrZXkgPT09ICdvcHRpb25zJyB8fFxuICAgICAgICBrZXkgPT09ICd0cmVlJykge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHBhdGggPT09ICd0cmVlJyAmJiBmcm9tICE9IG51bGwgJiYgZnJvbS5pbnN0YW5jZU9mU2NoZW1hKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKHNwZWNpYWxQcm9wZXJ0aWVzLmhhcyhrZXkpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKHRvW2tleV0gPT0gbnVsbCkge1xuICAgICAgdG9ba2V5XSA9IGZyb21ba2V5XTtcbiAgICB9IGVsc2UgaWYgKGlzT2JqZWN0KGZyb21ba2V5XSkpIHtcbiAgICAgIGlmICghaXNPYmplY3QodG9ba2V5XSkpIHtcbiAgICAgICAgdG9ba2V5XSA9IHt9O1xuICAgICAgfVxuICAgICAgaWYgKGZyb21ba2V5XSAhPSBudWxsKSB7XG4gICAgICAgIC8vIFNraXAgbWVyZ2luZyBzY2hlbWFzIGlmIHdlJ3JlIGNyZWF0aW5nIGEgZGlzY3JpbWluYXRvciBzY2hlbWEgYW5kXG4gICAgICAgIC8vIGJhc2Ugc2NoZW1hIGhhcyBhIGdpdmVuIHBhdGggYXMgYSBzaW5nbGUgbmVzdGVkIGJ1dCBkaXNjcmltaW5hdG9yIHNjaGVtYVxuICAgICAgICAvLyBoYXMgdGhlIHBhdGggYXMgYSBkb2N1bWVudCBhcnJheSwgb3IgdmljZSB2ZXJzYSAoZ2gtOTUzNClcbiAgICAgICAgaWYgKChmcm9tW2tleV0uJGlzU2luZ2xlTmVzdGVkICYmIHRvW2tleV0uJGlzTW9uZ29vc2VEb2N1bWVudEFycmF5KSB8fFxuICAgICAgICAgICAgICAoZnJvbVtrZXldLiRpc01vbmdvb3NlRG9jdW1lbnRBcnJheSAmJiB0b1trZXldLiRpc1NpbmdsZU5lc3RlZCkgfHxcbiAgICAgICAgICAgICAgKGZyb21ba2V5XS4kaXNNb25nb29zZURvY3VtZW50QXJyYXlFbGVtZW50ICYmIHRvW2tleV0uJGlzTW9uZ29vc2VEb2N1bWVudEFycmF5RWxlbWVudCkpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfSBlbHNlIGlmIChmcm9tW2tleV0uaW5zdGFuY2VPZlNjaGVtYSkge1xuICAgICAgICAgIGlmICh0b1trZXldLmluc3RhbmNlT2ZTY2hlbWEpIHtcbiAgICAgICAgICAgIHNjaGVtYU1lcmdlKHRvW2tleV0sIGZyb21ba2V5XS5jbG9uZSgpLCB0cnVlKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdG9ba2V5XSA9IGZyb21ba2V5XS5jbG9uZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfSBlbHNlIGlmIChpc0Jzb25UeXBlKGZyb21ba2V5XSwgJ09iamVjdElkJykpIHtcbiAgICAgICAgICB0b1trZXldID0gbmV3IE9iamVjdElkKGZyb21ba2V5XSk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIG1lcmdlRGlzY3JpbWluYXRvclNjaGVtYSh0b1trZXldLCBmcm9tW2tleV0sIHBhdGggPyBwYXRoICsgJy4nICsga2V5IDoga2V5LCBzZWVuKTtcbiAgICB9XG4gIH1cblxuICBpZiAoZnJvbSAhPSBudWxsICYmIGZyb20uaW5zdGFuY2VPZlNjaGVtYSkge1xuICAgIHRvLnRyZWUgPSBPYmplY3QuYXNzaWduKHt9LCBmcm9tLnRyZWUsIHRvLnRyZWUpO1xuICB9XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../server/node_modules/mongoose/lib/helpers/discriminator/mergeDiscriminatorSchema.js\n");

/***/ }),

/***/ "../server/node_modules/mongoose/lib/helpers/document/applyDefaults.js":
/*!*****************************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/helpers/document/applyDefaults.js ***!
  \*****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst isNestedProjection = __webpack_require__(/*! ../projection/isNestedProjection */ \"../server/node_modules/mongoose/lib/helpers/projection/isNestedProjection.js\");\n\nmodule.exports = function applyDefaults(doc, fields, exclude, hasIncludedChildren, isBeforeSetters, pathsToSkip) {\n  const paths = Object.keys(doc.$__schema.paths);\n  const plen = paths.length;\n\n  for (let i = 0; i < plen; ++i) {\n    let def;\n    let curPath = '';\n    const p = paths[i];\n\n    if (p === '_id' && doc.$__.skipId) {\n      continue;\n    }\n\n    const type = doc.$__schema.paths[p];\n    const path = type.splitPath();\n    const len = path.length;\n    let included = false;\n    let doc_ = doc._doc;\n    for (let j = 0; j < len; ++j) {\n      if (doc_ == null) {\n        break;\n      }\n\n      const piece = path[j];\n      curPath += (!curPath.length ? '' : '.') + piece;\n\n      if (exclude === true) {\n        if (curPath in fields) {\n          break;\n        }\n      } else if (exclude === false && fields && !included) {\n        const hasSubpaths = type.$isSingleNested || type.$isMongooseDocumentArray;\n        if ((curPath in fields && !isNestedProjection(fields[curPath])) || (j === len - 1 && hasSubpaths && hasIncludedChildren != null && hasIncludedChildren[curPath])) {\n          included = true;\n        } else if (hasIncludedChildren != null && !hasIncludedChildren[curPath]) {\n          break;\n        }\n      }\n\n      if (j === len - 1) {\n        if (doc_[piece] !== void 0) {\n          break;\n        }\n\n        if (isBeforeSetters != null) {\n          if (typeof type.defaultValue === 'function') {\n            if (!type.defaultValue.$runBeforeSetters && isBeforeSetters) {\n              break;\n            }\n            if (type.defaultValue.$runBeforeSetters && !isBeforeSetters) {\n              break;\n            }\n          } else if (!isBeforeSetters) {\n            // Non-function defaults should always run **before** setters\n            continue;\n          }\n        }\n\n        if (pathsToSkip && pathsToSkip[curPath]) {\n          break;\n        }\n\n        if (fields && exclude !== null) {\n          if (exclude === true) {\n            // apply defaults to all non-excluded fields\n            if (p in fields) {\n              continue;\n            }\n\n            try {\n              def = type.getDefault(doc, false);\n            } catch (err) {\n              doc.invalidate(p, err);\n              break;\n            }\n\n            if (typeof def !== 'undefined') {\n              doc_[piece] = def;\n              applyChangeTracking(doc, p);\n            }\n          } else if (included) {\n            // selected field\n            try {\n              def = type.getDefault(doc, false);\n            } catch (err) {\n              doc.invalidate(p, err);\n              break;\n            }\n\n            if (typeof def !== 'undefined') {\n              doc_[piece] = def;\n              applyChangeTracking(doc, p);\n            }\n          }\n        } else {\n          try {\n            def = type.getDefault(doc, false);\n          } catch (err) {\n            doc.invalidate(p, err);\n            break;\n          }\n\n          if (typeof def !== 'undefined') {\n            doc_[piece] = def;\n            applyChangeTracking(doc, p);\n          }\n        }\n      } else {\n        doc_ = doc_[piece];\n      }\n    }\n  }\n};\n\n/*!\n * ignore\n */\n\nfunction applyChangeTracking(doc, fullPath) {\n  doc.$__.activePaths.default(fullPath);\n  if (doc.$isSubdocument && doc.$isSingleNested && doc.$parent() != null) {\n    doc.$parent().$__.activePaths.default(doc.$__pathRelativeToParent(fullPath));\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9kb2N1bWVudC9hcHBseURlZmF1bHRzLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLDJCQUEyQixtQkFBTyxDQUFDLHNIQUFrQzs7QUFFckU7QUFDQTtBQUNBOztBQUVBLGtCQUFrQixVQUFVO0FBQzVCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2NsaWVudC8uLi9zZXJ2ZXIvbm9kZV9tb2R1bGVzL21vbmdvb3NlL2xpYi9oZWxwZXJzL2RvY3VtZW50L2FwcGx5RGVmYXVsdHMuanM/Yjk4OCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IGlzTmVzdGVkUHJvamVjdGlvbiA9IHJlcXVpcmUoJy4uL3Byb2plY3Rpb24vaXNOZXN0ZWRQcm9qZWN0aW9uJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gYXBwbHlEZWZhdWx0cyhkb2MsIGZpZWxkcywgZXhjbHVkZSwgaGFzSW5jbHVkZWRDaGlsZHJlbiwgaXNCZWZvcmVTZXR0ZXJzLCBwYXRoc1RvU2tpcCkge1xuICBjb25zdCBwYXRocyA9IE9iamVjdC5rZXlzKGRvYy4kX19zY2hlbWEucGF0aHMpO1xuICBjb25zdCBwbGVuID0gcGF0aHMubGVuZ3RoO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcGxlbjsgKytpKSB7XG4gICAgbGV0IGRlZjtcbiAgICBsZXQgY3VyUGF0aCA9ICcnO1xuICAgIGNvbnN0IHAgPSBwYXRoc1tpXTtcblxuICAgIGlmIChwID09PSAnX2lkJyAmJiBkb2MuJF9fLnNraXBJZCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgY29uc3QgdHlwZSA9IGRvYy4kX19zY2hlbWEucGF0aHNbcF07XG4gICAgY29uc3QgcGF0aCA9IHR5cGUuc3BsaXRQYXRoKCk7XG4gICAgY29uc3QgbGVuID0gcGF0aC5sZW5ndGg7XG4gICAgbGV0IGluY2x1ZGVkID0gZmFsc2U7XG4gICAgbGV0IGRvY18gPSBkb2MuX2RvYztcbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IGxlbjsgKytqKSB7XG4gICAgICBpZiAoZG9jXyA9PSBudWxsKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBwaWVjZSA9IHBhdGhbal07XG4gICAgICBjdXJQYXRoICs9ICghY3VyUGF0aC5sZW5ndGggPyAnJyA6ICcuJykgKyBwaWVjZTtcblxuICAgICAgaWYgKGV4Y2x1ZGUgPT09IHRydWUpIHtcbiAgICAgICAgaWYgKGN1clBhdGggaW4gZmllbGRzKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoZXhjbHVkZSA9PT0gZmFsc2UgJiYgZmllbGRzICYmICFpbmNsdWRlZCkge1xuICAgICAgICBjb25zdCBoYXNTdWJwYXRocyA9IHR5cGUuJGlzU2luZ2xlTmVzdGVkIHx8IHR5cGUuJGlzTW9uZ29vc2VEb2N1bWVudEFycmF5O1xuICAgICAgICBpZiAoKGN1clBhdGggaW4gZmllbGRzICYmICFpc05lc3RlZFByb2plY3Rpb24oZmllbGRzW2N1clBhdGhdKSkgfHwgKGogPT09IGxlbiAtIDEgJiYgaGFzU3VicGF0aHMgJiYgaGFzSW5jbHVkZWRDaGlsZHJlbiAhPSBudWxsICYmIGhhc0luY2x1ZGVkQ2hpbGRyZW5bY3VyUGF0aF0pKSB7XG4gICAgICAgICAgaW5jbHVkZWQgPSB0cnVlO1xuICAgICAgICB9IGVsc2UgaWYgKGhhc0luY2x1ZGVkQ2hpbGRyZW4gIT0gbnVsbCAmJiAhaGFzSW5jbHVkZWRDaGlsZHJlbltjdXJQYXRoXSkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChqID09PSBsZW4gLSAxKSB7XG4gICAgICAgIGlmIChkb2NfW3BpZWNlXSAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNCZWZvcmVTZXR0ZXJzICE9IG51bGwpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIHR5cGUuZGVmYXVsdFZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBpZiAoIXR5cGUuZGVmYXVsdFZhbHVlLiRydW5CZWZvcmVTZXR0ZXJzICYmIGlzQmVmb3JlU2V0dGVycykge1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlLmRlZmF1bHRWYWx1ZS4kcnVuQmVmb3JlU2V0dGVycyAmJiAhaXNCZWZvcmVTZXR0ZXJzKSB7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAoIWlzQmVmb3JlU2V0dGVycykge1xuICAgICAgICAgICAgLy8gTm9uLWZ1bmN0aW9uIGRlZmF1bHRzIHNob3VsZCBhbHdheXMgcnVuICoqYmVmb3JlKiogc2V0dGVyc1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHBhdGhzVG9Ta2lwICYmIHBhdGhzVG9Ta2lwW2N1clBhdGhdKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZmllbGRzICYmIGV4Y2x1ZGUgIT09IG51bGwpIHtcbiAgICAgICAgICBpZiAoZXhjbHVkZSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgLy8gYXBwbHkgZGVmYXVsdHMgdG8gYWxsIG5vbi1leGNsdWRlZCBmaWVsZHNcbiAgICAgICAgICAgIGlmIChwIGluIGZpZWxkcykge1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgZGVmID0gdHlwZS5nZXREZWZhdWx0KGRvYywgZmFsc2UpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgIGRvYy5pbnZhbGlkYXRlKHAsIGVycik7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodHlwZW9mIGRlZiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgZG9jX1twaWVjZV0gPSBkZWY7XG4gICAgICAgICAgICAgIGFwcGx5Q2hhbmdlVHJhY2tpbmcoZG9jLCBwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKGluY2x1ZGVkKSB7XG4gICAgICAgICAgICAvLyBzZWxlY3RlZCBmaWVsZFxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgZGVmID0gdHlwZS5nZXREZWZhdWx0KGRvYywgZmFsc2UpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgIGRvYy5pbnZhbGlkYXRlKHAsIGVycik7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodHlwZW9mIGRlZiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgZG9jX1twaWVjZV0gPSBkZWY7XG4gICAgICAgICAgICAgIGFwcGx5Q2hhbmdlVHJhY2tpbmcoZG9jLCBwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGRlZiA9IHR5cGUuZ2V0RGVmYXVsdChkb2MsIGZhbHNlKTtcbiAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIGRvYy5pbnZhbGlkYXRlKHAsIGVycik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAodHlwZW9mIGRlZiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIGRvY19bcGllY2VdID0gZGVmO1xuICAgICAgICAgICAgYXBwbHlDaGFuZ2VUcmFja2luZyhkb2MsIHApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZG9jXyA9IGRvY19bcGllY2VdO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5mdW5jdGlvbiBhcHBseUNoYW5nZVRyYWNraW5nKGRvYywgZnVsbFBhdGgpIHtcbiAgZG9jLiRfXy5hY3RpdmVQYXRocy5kZWZhdWx0KGZ1bGxQYXRoKTtcbiAgaWYgKGRvYy4kaXNTdWJkb2N1bWVudCAmJiBkb2MuJGlzU2luZ2xlTmVzdGVkICYmIGRvYy4kcGFyZW50KCkgIT0gbnVsbCkge1xuICAgIGRvYy4kcGFyZW50KCkuJF9fLmFjdGl2ZVBhdGhzLmRlZmF1bHQoZG9jLiRfX3BhdGhSZWxhdGl2ZVRvUGFyZW50KGZ1bGxQYXRoKSk7XG4gIH1cbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../server/node_modules/mongoose/lib/helpers/document/applyDefaults.js\n");

/***/ }),

/***/ "../server/node_modules/mongoose/lib/helpers/document/cleanModifiedSubpaths.js":
/*!*************************************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/helpers/document/cleanModifiedSubpaths.js ***!
  \*************************************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/*!\n * ignore\n */\n\nmodule.exports = function cleanModifiedSubpaths(doc, path, options) {\n  options = options || {};\n  const skipDocArrays = options.skipDocArrays;\n\n  let deleted = 0;\n  if (!doc) {\n    return deleted;\n  }\n\n  for (const modifiedPath of Object.keys(doc.$__.activePaths.getStatePaths('modify'))) {\n    if (skipDocArrays) {\n      const schemaType = doc.$__schema.path(modifiedPath);\n      if (schemaType && schemaType.$isMongooseDocumentArray) {\n        continue;\n      }\n    }\n    if (modifiedPath.startsWith(path + '.')) {\n      doc.$__.activePaths.clearPath(modifiedPath);\n      ++deleted;\n\n      if (doc.$isSubdocument) {\n        const owner = doc.ownerDocument();\n        const fullPath = doc.$__fullPath(modifiedPath);\n        owner.$__.activePaths.clearPath(fullPath);\n      }\n    }\n  }\n  return deleted;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9kb2N1bWVudC9jbGVhbk1vZGlmaWVkU3VicGF0aHMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbGllbnQvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9kb2N1bWVudC9jbGVhbk1vZGlmaWVkU3VicGF0aHMuanM/YzU5NyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBjbGVhbk1vZGlmaWVkU3VicGF0aHMoZG9jLCBwYXRoLCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBjb25zdCBza2lwRG9jQXJyYXlzID0gb3B0aW9ucy5za2lwRG9jQXJyYXlzO1xuXG4gIGxldCBkZWxldGVkID0gMDtcbiAgaWYgKCFkb2MpIHtcbiAgICByZXR1cm4gZGVsZXRlZDtcbiAgfVxuXG4gIGZvciAoY29uc3QgbW9kaWZpZWRQYXRoIG9mIE9iamVjdC5rZXlzKGRvYy4kX18uYWN0aXZlUGF0aHMuZ2V0U3RhdGVQYXRocygnbW9kaWZ5JykpKSB7XG4gICAgaWYgKHNraXBEb2NBcnJheXMpIHtcbiAgICAgIGNvbnN0IHNjaGVtYVR5cGUgPSBkb2MuJF9fc2NoZW1hLnBhdGgobW9kaWZpZWRQYXRoKTtcbiAgICAgIGlmIChzY2hlbWFUeXBlICYmIHNjaGVtYVR5cGUuJGlzTW9uZ29vc2VEb2N1bWVudEFycmF5KSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAobW9kaWZpZWRQYXRoLnN0YXJ0c1dpdGgocGF0aCArICcuJykpIHtcbiAgICAgIGRvYy4kX18uYWN0aXZlUGF0aHMuY2xlYXJQYXRoKG1vZGlmaWVkUGF0aCk7XG4gICAgICArK2RlbGV0ZWQ7XG5cbiAgICAgIGlmIChkb2MuJGlzU3ViZG9jdW1lbnQpIHtcbiAgICAgICAgY29uc3Qgb3duZXIgPSBkb2Mub3duZXJEb2N1bWVudCgpO1xuICAgICAgICBjb25zdCBmdWxsUGF0aCA9IGRvYy4kX19mdWxsUGF0aChtb2RpZmllZFBhdGgpO1xuICAgICAgICBvd25lci4kX18uYWN0aXZlUGF0aHMuY2xlYXJQYXRoKGZ1bGxQYXRoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGRlbGV0ZWQ7XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../server/node_modules/mongoose/lib/helpers/document/cleanModifiedSubpaths.js\n");

/***/ }),

/***/ "../server/node_modules/mongoose/lib/helpers/document/compile.js":
/*!***********************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/helpers/document/compile.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nconst clone = __webpack_require__(/*! ../../helpers/clone */ \"../server/node_modules/mongoose/lib/helpers/clone.js\");\nconst documentSchemaSymbol = (__webpack_require__(/*! ../../helpers/symbols */ \"../server/node_modules/mongoose/lib/helpers/symbols.js\").documentSchemaSymbol);\nconst internalToObjectOptions = (__webpack_require__(/*! ../../options */ \"../server/node_modules/mongoose/lib/options.js\").internalToObjectOptions);\nconst utils = __webpack_require__(/*! ../../utils */ \"../server/node_modules/mongoose/lib/utils.js\");\n\nlet Document;\nconst getSymbol = (__webpack_require__(/*! ../../helpers/symbols */ \"../server/node_modules/mongoose/lib/helpers/symbols.js\").getSymbol);\nconst scopeSymbol = (__webpack_require__(/*! ../../helpers/symbols */ \"../server/node_modules/mongoose/lib/helpers/symbols.js\").scopeSymbol);\n\nconst isPOJO = utils.isPOJO;\n\n/*!\n * exports\n */\n\nexports.compile = compile;\nexports.defineKey = defineKey;\n\nconst _isEmptyOptions = Object.freeze({\n  minimize: true,\n  virtuals: false,\n  getters: false,\n  transform: false\n});\n\nconst noDottedPathGetOptions = Object.freeze({\n  noDottedPath: true\n});\n\n/**\n * Compiles schemas.\n * @param {Object} tree\n * @param {Any} proto\n * @param {String} prefix\n * @param {Object} options\n * @api private\n */\n\nfunction compile(tree, proto, prefix, options) {\n  Document = Document || __webpack_require__(/*! ../../document */ \"../server/node_modules/mongoose/lib/document.js\");\n  const typeKey = options.typeKey;\n\n  for (const key of Object.keys(tree)) {\n    const limb = tree[key];\n\n    const hasSubprops = isPOJO(limb) &&\n      Object.keys(limb).length > 0 &&\n      (!limb[typeKey] || (typeKey === 'type' && isPOJO(limb.type) && limb.type.type));\n    const subprops = hasSubprops ? limb : null;\n\n    defineKey({ prop: key, subprops: subprops, prototype: proto, prefix: prefix, options: options });\n  }\n}\n\n/**\n * Defines the accessor named prop on the incoming prototype.\n * @param {Object} options\n * @param {String} options.prop\n * @param {Boolean} options.subprops\n * @param {Any} options.prototype\n * @param {String} [options.prefix]\n * @param {Object} options.options\n * @api private\n */\n\nfunction defineKey({ prop, subprops, prototype, prefix, options }) {\n  Document = Document || __webpack_require__(/*! ../../document */ \"../server/node_modules/mongoose/lib/document.js\");\n  const path = (prefix ? prefix + '.' : '') + prop;\n  prefix = prefix || '';\n  const useGetOptions = prefix ? Object.freeze({}) : noDottedPathGetOptions;\n\n  if (subprops) {\n    Object.defineProperty(prototype, prop, {\n      enumerable: true,\n      configurable: true,\n      get: function() {\n        const _this = this;\n        if (!this.$__.getters) {\n          this.$__.getters = {};\n        }\n\n        if (!this.$__.getters[path]) {\n          const nested = Object.create(Document.prototype, getOwnPropertyDescriptors(this));\n\n          // save scope for nested getters/setters\n          if (!prefix) {\n            nested.$__[scopeSymbol] = this;\n          }\n          nested.$__.nestedPath = path;\n\n          Object.defineProperty(nested, 'schema', {\n            enumerable: false,\n            configurable: true,\n            writable: false,\n            value: prototype.schema\n          });\n\n          Object.defineProperty(nested, '$__schema', {\n            enumerable: false,\n            configurable: true,\n            writable: false,\n            value: prototype.schema\n          });\n\n          Object.defineProperty(nested, documentSchemaSymbol, {\n            enumerable: false,\n            configurable: true,\n            writable: false,\n            value: prototype.schema\n          });\n\n          Object.defineProperty(nested, 'toObject', {\n            enumerable: false,\n            configurable: true,\n            writable: false,\n            value: function() {\n              return clone(_this.get(path, null, {\n                virtuals: this &&\n                  this.schema &&\n                  this.schema.options &&\n                  this.schema.options.toObject &&\n                  this.schema.options.toObject.virtuals || null\n              }));\n            }\n          });\n\n          Object.defineProperty(nested, '$__get', {\n            enumerable: false,\n            configurable: true,\n            writable: false,\n            value: function() {\n              return _this.get(path, null, {\n                virtuals: this && this.schema && this.schema.options && this.schema.options.toObject && this.schema.options.toObject.virtuals || null\n              });\n            }\n          });\n\n          Object.defineProperty(nested, 'toJSON', {\n            enumerable: false,\n            configurable: true,\n            writable: false,\n            value: function() {\n              return _this.get(path, null, {\n                virtuals: this && this.schema && this.schema.options && this.schema.options.toJSON && this.schema.options.toJSON.virtuals || null\n              });\n            }\n          });\n\n          Object.defineProperty(nested, '$__isNested', {\n            enumerable: false,\n            configurable: true,\n            writable: false,\n            value: true\n          });\n\n          Object.defineProperty(nested, '$isEmpty', {\n            enumerable: false,\n            configurable: true,\n            writable: false,\n            value: function() {\n              return Object.keys(this.get(path, null, _isEmptyOptions) || {}).length === 0;\n            }\n          });\n\n          Object.defineProperty(nested, '$__parent', {\n            enumerable: false,\n            configurable: true,\n            writable: false,\n            value: this\n          });\n\n          compile(subprops, nested, path, options);\n          this.$__.getters[path] = nested;\n        }\n\n        return this.$__.getters[path];\n      },\n      set: function(v) {\n        if (v != null && v.$__isNested) {\n          // Convert top-level to POJO, but leave subdocs hydrated so `$set`\n          // can handle them. See gh-9293.\n          v = v.$__get();\n        } else if (v instanceof Document && !v.$__isNested) {\n          v = v.$toObject(internalToObjectOptions);\n        }\n        const doc = this.$__[scopeSymbol] || this;\n        doc.$set(path, v);\n      }\n    });\n  } else {\n    Object.defineProperty(prototype, prop, {\n      enumerable: true,\n      configurable: true,\n      get: function() {\n        return this[getSymbol].call(\n          this.$__[scopeSymbol] || this,\n          path,\n          null,\n          useGetOptions\n        );\n      },\n      set: function(v) {\n        this.$set.call(this.$__[scopeSymbol] || this, path, v);\n      }\n    });\n  }\n}\n\n// gets descriptors for all properties of `object`\n// makes all properties non-enumerable to match previous behavior to #2211\nfunction getOwnPropertyDescriptors(object) {\n  const result = {};\n\n  Object.getOwnPropertyNames(object).forEach(function(key) {\n    const skip = [\n      'isNew',\n      '$__',\n      '$errors',\n      'errors',\n      '_doc',\n      '$locals',\n      '$op',\n      '__parentArray',\n      '__index',\n      '$isDocumentArrayElement'\n    ].indexOf(key) === -1;\n    if (skip) {\n      return;\n    }\n\n    result[key] = Object.getOwnPropertyDescriptor(object, key);\n    result[key].enumerable = false;\n  });\n\n  return result;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9kb2N1bWVudC9jb21waWxlLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLGNBQWMsbUJBQU8sQ0FBQyxpRkFBcUI7QUFDM0MsNkJBQTZCLGlJQUFxRDtBQUNsRixnQ0FBZ0Msb0hBQWdEO0FBQ2hGLGNBQWMsbUJBQU8sQ0FBQyxpRUFBYTs7QUFFbkM7QUFDQSxrQkFBa0Isc0hBQTBDO0FBQzVELG9CQUFvQix3SEFBNEM7O0FBRWhFOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxlQUFlO0FBQ2YsaUJBQWlCOztBQUVqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsS0FBSztBQUNoQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7O0FBRUE7QUFDQSx5QkFBeUIsbUJBQU8sQ0FBQyx1RUFBZ0I7QUFDakQ7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxnQkFBZ0IsbUZBQW1GO0FBQ25HO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsS0FBSztBQUNoQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7O0FBRUEscUJBQXFCLDRDQUE0QztBQUNqRSx5QkFBeUIsbUJBQU8sQ0FBQyx1RUFBZ0I7QUFDakQ7QUFDQTtBQUNBLGlEQUFpRDs7QUFFakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVzs7QUFFWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVzs7QUFFWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVzs7QUFFWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0EsV0FBVzs7QUFFWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBLFdBQVc7O0FBRVg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0RUFBNEU7QUFDNUU7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbGllbnQvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9kb2N1bWVudC9jb21waWxlLmpzPzQxMDIiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBjbG9uZSA9IHJlcXVpcmUoJy4uLy4uL2hlbHBlcnMvY2xvbmUnKTtcbmNvbnN0IGRvY3VtZW50U2NoZW1hU3ltYm9sID0gcmVxdWlyZSgnLi4vLi4vaGVscGVycy9zeW1ib2xzJykuZG9jdW1lbnRTY2hlbWFTeW1ib2w7XG5jb25zdCBpbnRlcm5hbFRvT2JqZWN0T3B0aW9ucyA9IHJlcXVpcmUoJy4uLy4uL29wdGlvbnMnKS5pbnRlcm5hbFRvT2JqZWN0T3B0aW9ucztcbmNvbnN0IHV0aWxzID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMnKTtcblxubGV0IERvY3VtZW50O1xuY29uc3QgZ2V0U3ltYm9sID0gcmVxdWlyZSgnLi4vLi4vaGVscGVycy9zeW1ib2xzJykuZ2V0U3ltYm9sO1xuY29uc3Qgc2NvcGVTeW1ib2wgPSByZXF1aXJlKCcuLi8uLi9oZWxwZXJzL3N5bWJvbHMnKS5zY29wZVN5bWJvbDtcblxuY29uc3QgaXNQT0pPID0gdXRpbHMuaXNQT0pPO1xuXG4vKiFcbiAqIGV4cG9ydHNcbiAqL1xuXG5leHBvcnRzLmNvbXBpbGUgPSBjb21waWxlO1xuZXhwb3J0cy5kZWZpbmVLZXkgPSBkZWZpbmVLZXk7XG5cbmNvbnN0IF9pc0VtcHR5T3B0aW9ucyA9IE9iamVjdC5mcmVlemUoe1xuICBtaW5pbWl6ZTogdHJ1ZSxcbiAgdmlydHVhbHM6IGZhbHNlLFxuICBnZXR0ZXJzOiBmYWxzZSxcbiAgdHJhbnNmb3JtOiBmYWxzZVxufSk7XG5cbmNvbnN0IG5vRG90dGVkUGF0aEdldE9wdGlvbnMgPSBPYmplY3QuZnJlZXplKHtcbiAgbm9Eb3R0ZWRQYXRoOiB0cnVlXG59KTtcblxuLyoqXG4gKiBDb21waWxlcyBzY2hlbWFzLlxuICogQHBhcmFtIHtPYmplY3R9IHRyZWVcbiAqIEBwYXJhbSB7QW55fSBwcm90b1xuICogQHBhcmFtIHtTdHJpbmd9IHByZWZpeFxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGNvbXBpbGUodHJlZSwgcHJvdG8sIHByZWZpeCwgb3B0aW9ucykge1xuICBEb2N1bWVudCA9IERvY3VtZW50IHx8IHJlcXVpcmUoJy4uLy4uL2RvY3VtZW50Jyk7XG4gIGNvbnN0IHR5cGVLZXkgPSBvcHRpb25zLnR5cGVLZXk7XG5cbiAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXModHJlZSkpIHtcbiAgICBjb25zdCBsaW1iID0gdHJlZVtrZXldO1xuXG4gICAgY29uc3QgaGFzU3VicHJvcHMgPSBpc1BPSk8obGltYikgJiZcbiAgICAgIE9iamVjdC5rZXlzKGxpbWIpLmxlbmd0aCA+IDAgJiZcbiAgICAgICghbGltYlt0eXBlS2V5XSB8fCAodHlwZUtleSA9PT0gJ3R5cGUnICYmIGlzUE9KTyhsaW1iLnR5cGUpICYmIGxpbWIudHlwZS50eXBlKSk7XG4gICAgY29uc3Qgc3VicHJvcHMgPSBoYXNTdWJwcm9wcyA/IGxpbWIgOiBudWxsO1xuXG4gICAgZGVmaW5lS2V5KHsgcHJvcDoga2V5LCBzdWJwcm9wczogc3VicHJvcHMsIHByb3RvdHlwZTogcHJvdG8sIHByZWZpeDogcHJlZml4LCBvcHRpb25zOiBvcHRpb25zIH0pO1xuICB9XG59XG5cbi8qKlxuICogRGVmaW5lcyB0aGUgYWNjZXNzb3IgbmFtZWQgcHJvcCBvbiB0aGUgaW5jb21pbmcgcHJvdG90eXBlLlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEBwYXJhbSB7U3RyaW5nfSBvcHRpb25zLnByb3BcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gb3B0aW9ucy5zdWJwcm9wc1xuICogQHBhcmFtIHtBbnl9IG9wdGlvbnMucHJvdG90eXBlXG4gKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMucHJlZml4XVxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMub3B0aW9uc1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gZGVmaW5lS2V5KHsgcHJvcCwgc3VicHJvcHMsIHByb3RvdHlwZSwgcHJlZml4LCBvcHRpb25zIH0pIHtcbiAgRG9jdW1lbnQgPSBEb2N1bWVudCB8fCByZXF1aXJlKCcuLi8uLi9kb2N1bWVudCcpO1xuICBjb25zdCBwYXRoID0gKHByZWZpeCA/IHByZWZpeCArICcuJyA6ICcnKSArIHByb3A7XG4gIHByZWZpeCA9IHByZWZpeCB8fCAnJztcbiAgY29uc3QgdXNlR2V0T3B0aW9ucyA9IHByZWZpeCA/IE9iamVjdC5mcmVlemUoe30pIDogbm9Eb3R0ZWRQYXRoR2V0T3B0aW9ucztcblxuICBpZiAoc3VicHJvcHMpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvdG90eXBlLCBwcm9wLCB7XG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgY29uc3QgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoIXRoaXMuJF9fLmdldHRlcnMpIHtcbiAgICAgICAgICB0aGlzLiRfXy5nZXR0ZXJzID0ge307XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRoaXMuJF9fLmdldHRlcnNbcGF0aF0pIHtcbiAgICAgICAgICBjb25zdCBuZXN0ZWQgPSBPYmplY3QuY3JlYXRlKERvY3VtZW50LnByb3RvdHlwZSwgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyh0aGlzKSk7XG5cbiAgICAgICAgICAvLyBzYXZlIHNjb3BlIGZvciBuZXN0ZWQgZ2V0dGVycy9zZXR0ZXJzXG4gICAgICAgICAgaWYgKCFwcmVmaXgpIHtcbiAgICAgICAgICAgIG5lc3RlZC4kX19bc2NvcGVTeW1ib2xdID0gdGhpcztcbiAgICAgICAgICB9XG4gICAgICAgICAgbmVzdGVkLiRfXy5uZXN0ZWRQYXRoID0gcGF0aDtcblxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuZXN0ZWQsICdzY2hlbWEnLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgIHZhbHVlOiBwcm90b3R5cGUuc2NoZW1hXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobmVzdGVkLCAnJF9fc2NoZW1hJywge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICAgICAgICB2YWx1ZTogcHJvdG90eXBlLnNjaGVtYVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG5lc3RlZCwgZG9jdW1lbnRTY2hlbWFTeW1ib2wsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgICAgICAgdmFsdWU6IHByb3RvdHlwZS5zY2hlbWFcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuZXN0ZWQsICd0b09iamVjdCcsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICByZXR1cm4gY2xvbmUoX3RoaXMuZ2V0KHBhdGgsIG51bGwsIHtcbiAgICAgICAgICAgICAgICB2aXJ0dWFsczogdGhpcyAmJlxuICAgICAgICAgICAgICAgICAgdGhpcy5zY2hlbWEgJiZcbiAgICAgICAgICAgICAgICAgIHRoaXMuc2NoZW1hLm9wdGlvbnMgJiZcbiAgICAgICAgICAgICAgICAgIHRoaXMuc2NoZW1hLm9wdGlvbnMudG9PYmplY3QgJiZcbiAgICAgICAgICAgICAgICAgIHRoaXMuc2NoZW1hLm9wdGlvbnMudG9PYmplY3QudmlydHVhbHMgfHwgbnVsbFxuICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobmVzdGVkLCAnJF9fZ2V0Jywge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIHJldHVybiBfdGhpcy5nZXQocGF0aCwgbnVsbCwge1xuICAgICAgICAgICAgICAgIHZpcnR1YWxzOiB0aGlzICYmIHRoaXMuc2NoZW1hICYmIHRoaXMuc2NoZW1hLm9wdGlvbnMgJiYgdGhpcy5zY2hlbWEub3B0aW9ucy50b09iamVjdCAmJiB0aGlzLnNjaGVtYS5vcHRpb25zLnRvT2JqZWN0LnZpcnR1YWxzIHx8IG51bGxcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobmVzdGVkLCAndG9KU09OJywge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIHJldHVybiBfdGhpcy5nZXQocGF0aCwgbnVsbCwge1xuICAgICAgICAgICAgICAgIHZpcnR1YWxzOiB0aGlzICYmIHRoaXMuc2NoZW1hICYmIHRoaXMuc2NoZW1hLm9wdGlvbnMgJiYgdGhpcy5zY2hlbWEub3B0aW9ucy50b0pTT04gJiYgdGhpcy5zY2hlbWEub3B0aW9ucy50b0pTT04udmlydHVhbHMgfHwgbnVsbFxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuZXN0ZWQsICckX19pc05lc3RlZCcsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgICAgICAgdmFsdWU6IHRydWVcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuZXN0ZWQsICckaXNFbXB0eScsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICByZXR1cm4gT2JqZWN0LmtleXModGhpcy5nZXQocGF0aCwgbnVsbCwgX2lzRW1wdHlPcHRpb25zKSB8fCB7fSkubGVuZ3RoID09PSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG5lc3RlZCwgJyRfX3BhcmVudCcsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgICAgICAgdmFsdWU6IHRoaXNcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIGNvbXBpbGUoc3VicHJvcHMsIG5lc3RlZCwgcGF0aCwgb3B0aW9ucyk7XG4gICAgICAgICAgdGhpcy4kX18uZ2V0dGVyc1twYXRoXSA9IG5lc3RlZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLiRfXy5nZXR0ZXJzW3BhdGhdO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24odikge1xuICAgICAgICBpZiAodiAhPSBudWxsICYmIHYuJF9faXNOZXN0ZWQpIHtcbiAgICAgICAgICAvLyBDb252ZXJ0IHRvcC1sZXZlbCB0byBQT0pPLCBidXQgbGVhdmUgc3ViZG9jcyBoeWRyYXRlZCBzbyBgJHNldGBcbiAgICAgICAgICAvLyBjYW4gaGFuZGxlIHRoZW0uIFNlZSBnaC05MjkzLlxuICAgICAgICAgIHYgPSB2LiRfX2dldCgpO1xuICAgICAgICB9IGVsc2UgaWYgKHYgaW5zdGFuY2VvZiBEb2N1bWVudCAmJiAhdi4kX19pc05lc3RlZCkge1xuICAgICAgICAgIHYgPSB2LiR0b09iamVjdChpbnRlcm5hbFRvT2JqZWN0T3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZG9jID0gdGhpcy4kX19bc2NvcGVTeW1ib2xdIHx8IHRoaXM7XG4gICAgICAgIGRvYy4kc2V0KHBhdGgsIHYpO1xuICAgICAgfVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm90b3R5cGUsIHByb3AsIHtcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpc1tnZXRTeW1ib2xdLmNhbGwoXG4gICAgICAgICAgdGhpcy4kX19bc2NvcGVTeW1ib2xdIHx8IHRoaXMsXG4gICAgICAgICAgcGF0aCxcbiAgICAgICAgICBudWxsLFxuICAgICAgICAgIHVzZUdldE9wdGlvbnNcbiAgICAgICAgKTtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgdGhpcy4kc2V0LmNhbGwodGhpcy4kX19bc2NvcGVTeW1ib2xdIHx8IHRoaXMsIHBhdGgsIHYpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG5cbi8vIGdldHMgZGVzY3JpcHRvcnMgZm9yIGFsbCBwcm9wZXJ0aWVzIG9mIGBvYmplY3RgXG4vLyBtYWtlcyBhbGwgcHJvcGVydGllcyBub24tZW51bWVyYWJsZSB0byBtYXRjaCBwcmV2aW91cyBiZWhhdmlvciB0byAjMjIxMVxuZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhvYmplY3QpIHtcbiAgY29uc3QgcmVzdWx0ID0ge307XG5cbiAgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMob2JqZWN0KS5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgIGNvbnN0IHNraXAgPSBbXG4gICAgICAnaXNOZXcnLFxuICAgICAgJyRfXycsXG4gICAgICAnJGVycm9ycycsXG4gICAgICAnZXJyb3JzJyxcbiAgICAgICdfZG9jJyxcbiAgICAgICckbG9jYWxzJyxcbiAgICAgICckb3AnLFxuICAgICAgJ19fcGFyZW50QXJyYXknLFxuICAgICAgJ19faW5kZXgnLFxuICAgICAgJyRpc0RvY3VtZW50QXJyYXlFbGVtZW50J1xuICAgIF0uaW5kZXhPZihrZXkpID09PSAtMTtcbiAgICBpZiAoc2tpcCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHJlc3VsdFtrZXldID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIGtleSk7XG4gICAgcmVzdWx0W2tleV0uZW51bWVyYWJsZSA9IGZhbHNlO1xuICB9KTtcblxuICByZXR1cm4gcmVzdWx0O1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../server/node_modules/mongoose/lib/helpers/document/compile.js\n");

/***/ }),

/***/ "../server/node_modules/mongoose/lib/helpers/document/getDeepestSubdocumentForPath.js":
/*!********************************************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/helpers/document/getDeepestSubdocumentForPath.js ***!
  \********************************************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/**\n * Find the deepest subdocument along a given path to ensure setter functions run\n * with the correct subdocument as `this`. If no subdocuments, returns the top-level\n * document.\n *\n * @param {Document} doc\n * @param {String[]} parts\n * @param {Schema} schema\n * @returns Document\n */\n\nmodule.exports = function getDeepestSubdocumentForPath(doc, parts, schema) {\n  let curPath = parts[0];\n  let curSchema = schema;\n  let subdoc = doc;\n  for (let i = 0; i < parts.length - 1; ++i) {\n    const curSchemaType = curSchema.path(curPath);\n    if (curSchemaType && curSchemaType.schema) {\n      let newSubdoc = subdoc.get(curPath);\n      curSchema = curSchemaType.schema;\n      curPath = parts[i + 1];\n      if (Array.isArray(newSubdoc) && !isNaN(curPath)) {\n        newSubdoc = newSubdoc[curPath];\n        curPath = '';\n      }\n      if (newSubdoc == null) {\n        break;\n      }\n      subdoc = newSubdoc;\n    } else {\n      curPath += curPath.length ? '.' + parts[i + 1] : parts[i + 1];\n    }\n  }\n\n  return subdoc;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9kb2N1bWVudC9nZXREZWVwZXN0U3ViZG9jdW1lbnRGb3JQYXRoLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFVBQVU7QUFDckIsV0FBVyxVQUFVO0FBQ3JCLFdBQVcsUUFBUTtBQUNuQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHNCQUFzQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2NsaWVudC8uLi9zZXJ2ZXIvbm9kZV9tb2R1bGVzL21vbmdvb3NlL2xpYi9oZWxwZXJzL2RvY3VtZW50L2dldERlZXBlc3RTdWJkb2N1bWVudEZvclBhdGguanM/NGJkMSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogRmluZCB0aGUgZGVlcGVzdCBzdWJkb2N1bWVudCBhbG9uZyBhIGdpdmVuIHBhdGggdG8gZW5zdXJlIHNldHRlciBmdW5jdGlvbnMgcnVuXG4gKiB3aXRoIHRoZSBjb3JyZWN0IHN1YmRvY3VtZW50IGFzIGB0aGlzYC4gSWYgbm8gc3ViZG9jdW1lbnRzLCByZXR1cm5zIHRoZSB0b3AtbGV2ZWxcbiAqIGRvY3VtZW50LlxuICpcbiAqIEBwYXJhbSB7RG9jdW1lbnR9IGRvY1xuICogQHBhcmFtIHtTdHJpbmdbXX0gcGFydHNcbiAqIEBwYXJhbSB7U2NoZW1hfSBzY2hlbWFcbiAqIEByZXR1cm5zIERvY3VtZW50XG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBnZXREZWVwZXN0U3ViZG9jdW1lbnRGb3JQYXRoKGRvYywgcGFydHMsIHNjaGVtYSkge1xuICBsZXQgY3VyUGF0aCA9IHBhcnRzWzBdO1xuICBsZXQgY3VyU2NoZW1hID0gc2NoZW1hO1xuICBsZXQgc3ViZG9jID0gZG9jO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHBhcnRzLmxlbmd0aCAtIDE7ICsraSkge1xuICAgIGNvbnN0IGN1clNjaGVtYVR5cGUgPSBjdXJTY2hlbWEucGF0aChjdXJQYXRoKTtcbiAgICBpZiAoY3VyU2NoZW1hVHlwZSAmJiBjdXJTY2hlbWFUeXBlLnNjaGVtYSkge1xuICAgICAgbGV0IG5ld1N1YmRvYyA9IHN1YmRvYy5nZXQoY3VyUGF0aCk7XG4gICAgICBjdXJTY2hlbWEgPSBjdXJTY2hlbWFUeXBlLnNjaGVtYTtcbiAgICAgIGN1clBhdGggPSBwYXJ0c1tpICsgMV07XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShuZXdTdWJkb2MpICYmICFpc05hTihjdXJQYXRoKSkge1xuICAgICAgICBuZXdTdWJkb2MgPSBuZXdTdWJkb2NbY3VyUGF0aF07XG4gICAgICAgIGN1clBhdGggPSAnJztcbiAgICAgIH1cbiAgICAgIGlmIChuZXdTdWJkb2MgPT0gbnVsbCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHN1YmRvYyA9IG5ld1N1YmRvYztcbiAgICB9IGVsc2Uge1xuICAgICAgY3VyUGF0aCArPSBjdXJQYXRoLmxlbmd0aCA/ICcuJyArIHBhcnRzW2kgKyAxXSA6IHBhcnRzW2kgKyAxXTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gc3ViZG9jO1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../server/node_modules/mongoose/lib/helpers/document/getDeepestSubdocumentForPath.js\n");

/***/ }),

/***/ "../server/node_modules/mongoose/lib/helpers/document/getEmbeddedDiscriminatorPath.js":
/*!********************************************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/helpers/document/getEmbeddedDiscriminatorPath.js ***!
  \********************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst get = __webpack_require__(/*! ../get */ \"../server/node_modules/mongoose/lib/helpers/get.js\");\nconst getSchemaDiscriminatorByValue = __webpack_require__(/*! ../discriminator/getSchemaDiscriminatorByValue */ \"../server/node_modules/mongoose/lib/helpers/discriminator/getSchemaDiscriminatorByValue.js\");\n\n/**\n * Like `schema.path()`, except with a document, because impossible to\n * determine path type without knowing the embedded discriminator key.\n *\n * @param {Document} doc\n * @param {String|String[]} path\n * @param {Object} [options]\n * @api private\n */\n\nmodule.exports = function getEmbeddedDiscriminatorPath(doc, path, options) {\n  options = options || {};\n  const typeOnly = options.typeOnly;\n  const parts = Array.isArray(path) ?\n    path :\n    (path.indexOf('.') === -1 ? [path] : path.split('.'));\n  let schemaType = null;\n  let type = 'adhocOrUndefined';\n\n  const schema = getSchemaDiscriminatorByValue(doc.schema, doc.get(doc.schema.options.discriminatorKey)) || doc.schema;\n\n  for (let i = 0; i < parts.length; ++i) {\n    const subpath = parts.slice(0, i + 1).join('.');\n    schemaType = schema.path(subpath);\n    if (schemaType == null) {\n      type = 'adhocOrUndefined';\n      continue;\n    }\n    if (schemaType.instance === 'Mixed') {\n      return typeOnly ? 'real' : schemaType;\n    }\n    type = schema.pathType(subpath);\n    if ((schemaType.$isSingleNested || schemaType.$isMongooseDocumentArrayElement) &&\n    schemaType.schema.discriminators != null) {\n      const discriminators = schemaType.schema.discriminators;\n      const discriminatorKey = doc.get(subpath + '.' +\n        get(schemaType, 'schema.options.discriminatorKey'));\n      if (discriminatorKey == null || discriminators[discriminatorKey] == null) {\n        continue;\n      }\n      const rest = parts.slice(i + 1).join('.');\n      return getEmbeddedDiscriminatorPath(doc.get(subpath), rest, options);\n    }\n  }\n\n  // Are we getting the whole schema or just the type, 'real', 'nested', etc.\n  return typeOnly ? type : schemaType;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9kb2N1bWVudC9nZXRFbWJlZGRlZERpc2NyaW1pbmF0b3JQYXRoLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLFlBQVksbUJBQU8sQ0FBQyxrRUFBUTtBQUM1QixzQ0FBc0MsbUJBQU8sQ0FBQyxrSkFBZ0Q7O0FBRTlGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCLFdBQVcsaUJBQWlCO0FBQzVCLFdBQVcsUUFBUTtBQUNuQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsa0JBQWtCLGtCQUFrQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbGllbnQvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9kb2N1bWVudC9nZXRFbWJlZGRlZERpc2NyaW1pbmF0b3JQYXRoLmpzPzIwMGUiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBnZXQgPSByZXF1aXJlKCcuLi9nZXQnKTtcbmNvbnN0IGdldFNjaGVtYURpc2NyaW1pbmF0b3JCeVZhbHVlID0gcmVxdWlyZSgnLi4vZGlzY3JpbWluYXRvci9nZXRTY2hlbWFEaXNjcmltaW5hdG9yQnlWYWx1ZScpO1xuXG4vKipcbiAqIExpa2UgYHNjaGVtYS5wYXRoKClgLCBleGNlcHQgd2l0aCBhIGRvY3VtZW50LCBiZWNhdXNlIGltcG9zc2libGUgdG9cbiAqIGRldGVybWluZSBwYXRoIHR5cGUgd2l0aG91dCBrbm93aW5nIHRoZSBlbWJlZGRlZCBkaXNjcmltaW5hdG9yIGtleS5cbiAqXG4gKiBAcGFyYW0ge0RvY3VtZW50fSBkb2NcbiAqIEBwYXJhbSB7U3RyaW5nfFN0cmluZ1tdfSBwYXRoXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGdldEVtYmVkZGVkRGlzY3JpbWluYXRvclBhdGgoZG9jLCBwYXRoLCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBjb25zdCB0eXBlT25seSA9IG9wdGlvbnMudHlwZU9ubHk7XG4gIGNvbnN0IHBhcnRzID0gQXJyYXkuaXNBcnJheShwYXRoKSA/XG4gICAgcGF0aCA6XG4gICAgKHBhdGguaW5kZXhPZignLicpID09PSAtMSA/IFtwYXRoXSA6IHBhdGguc3BsaXQoJy4nKSk7XG4gIGxldCBzY2hlbWFUeXBlID0gbnVsbDtcbiAgbGV0IHR5cGUgPSAnYWRob2NPclVuZGVmaW5lZCc7XG5cbiAgY29uc3Qgc2NoZW1hID0gZ2V0U2NoZW1hRGlzY3JpbWluYXRvckJ5VmFsdWUoZG9jLnNjaGVtYSwgZG9jLmdldChkb2Muc2NoZW1hLm9wdGlvbnMuZGlzY3JpbWluYXRvcktleSkpIHx8IGRvYy5zY2hlbWE7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXJ0cy5sZW5ndGg7ICsraSkge1xuICAgIGNvbnN0IHN1YnBhdGggPSBwYXJ0cy5zbGljZSgwLCBpICsgMSkuam9pbignLicpO1xuICAgIHNjaGVtYVR5cGUgPSBzY2hlbWEucGF0aChzdWJwYXRoKTtcbiAgICBpZiAoc2NoZW1hVHlwZSA9PSBudWxsKSB7XG4gICAgICB0eXBlID0gJ2FkaG9jT3JVbmRlZmluZWQnO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChzY2hlbWFUeXBlLmluc3RhbmNlID09PSAnTWl4ZWQnKSB7XG4gICAgICByZXR1cm4gdHlwZU9ubHkgPyAncmVhbCcgOiBzY2hlbWFUeXBlO1xuICAgIH1cbiAgICB0eXBlID0gc2NoZW1hLnBhdGhUeXBlKHN1YnBhdGgpO1xuICAgIGlmICgoc2NoZW1hVHlwZS4kaXNTaW5nbGVOZXN0ZWQgfHwgc2NoZW1hVHlwZS4kaXNNb25nb29zZURvY3VtZW50QXJyYXlFbGVtZW50KSAmJlxuICAgIHNjaGVtYVR5cGUuc2NoZW1hLmRpc2NyaW1pbmF0b3JzICE9IG51bGwpIHtcbiAgICAgIGNvbnN0IGRpc2NyaW1pbmF0b3JzID0gc2NoZW1hVHlwZS5zY2hlbWEuZGlzY3JpbWluYXRvcnM7XG4gICAgICBjb25zdCBkaXNjcmltaW5hdG9yS2V5ID0gZG9jLmdldChzdWJwYXRoICsgJy4nICtcbiAgICAgICAgZ2V0KHNjaGVtYVR5cGUsICdzY2hlbWEub3B0aW9ucy5kaXNjcmltaW5hdG9yS2V5JykpO1xuICAgICAgaWYgKGRpc2NyaW1pbmF0b3JLZXkgPT0gbnVsbCB8fCBkaXNjcmltaW5hdG9yc1tkaXNjcmltaW5hdG9yS2V5XSA9PSBudWxsKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgY29uc3QgcmVzdCA9IHBhcnRzLnNsaWNlKGkgKyAxKS5qb2luKCcuJyk7XG4gICAgICByZXR1cm4gZ2V0RW1iZWRkZWREaXNjcmltaW5hdG9yUGF0aChkb2MuZ2V0KHN1YnBhdGgpLCByZXN0LCBvcHRpb25zKTtcbiAgICB9XG4gIH1cblxuICAvLyBBcmUgd2UgZ2V0dGluZyB0aGUgd2hvbGUgc2NoZW1hIG9yIGp1c3QgdGhlIHR5cGUsICdyZWFsJywgJ25lc3RlZCcsIGV0Yy5cbiAgcmV0dXJuIHR5cGVPbmx5ID8gdHlwZSA6IHNjaGVtYVR5cGU7XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../server/node_modules/mongoose/lib/helpers/document/getEmbeddedDiscriminatorPath.js\n");

/***/ }),

/***/ "../server/node_modules/mongoose/lib/helpers/document/handleSpreadDoc.js":
/*!*******************************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/helpers/document/handleSpreadDoc.js ***!
  \*******************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst utils = __webpack_require__(/*! ../../utils */ \"../server/node_modules/mongoose/lib/utils.js\");\n\nconst keysToSkip = new Set(['__index', '__parentArray', '_doc']);\n\n/**\n * Using spread operator on a Mongoose document gives you a\n * POJO that has a tendency to cause infinite recursion. So\n * we use this function on `set()` to prevent that.\n */\n\nmodule.exports = function handleSpreadDoc(v, includeExtraKeys) {\n  if (utils.isPOJO(v) && v.$__ != null && v._doc != null) {\n    if (includeExtraKeys) {\n      const extraKeys = {};\n      for (const key of Object.keys(v)) {\n        if (typeof key === 'symbol') {\n          continue;\n        }\n        if (key[0] === '$') {\n          continue;\n        }\n        if (keysToSkip.has(key)) {\n          continue;\n        }\n        extraKeys[key] = v[key];\n      }\n      return { ...v._doc, ...extraKeys };\n    }\n    return v._doc;\n  }\n\n  return v;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9kb2N1bWVudC9oYW5kbGVTcHJlYWREb2MuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsY0FBYyxtQkFBTyxDQUFDLGlFQUFhOztBQUVuQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTs7QUFFQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2xpZW50Ly4uL3NlcnZlci9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvZG9jdW1lbnQvaGFuZGxlU3ByZWFkRG9jLmpzP2YzNWEiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCB1dGlscyA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzJyk7XG5cbmNvbnN0IGtleXNUb1NraXAgPSBuZXcgU2V0KFsnX19pbmRleCcsICdfX3BhcmVudEFycmF5JywgJ19kb2MnXSk7XG5cbi8qKlxuICogVXNpbmcgc3ByZWFkIG9wZXJhdG9yIG9uIGEgTW9uZ29vc2UgZG9jdW1lbnQgZ2l2ZXMgeW91IGFcbiAqIFBPSk8gdGhhdCBoYXMgYSB0ZW5kZW5jeSB0byBjYXVzZSBpbmZpbml0ZSByZWN1cnNpb24uIFNvXG4gKiB3ZSB1c2UgdGhpcyBmdW5jdGlvbiBvbiBgc2V0KClgIHRvIHByZXZlbnQgdGhhdC5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGhhbmRsZVNwcmVhZERvYyh2LCBpbmNsdWRlRXh0cmFLZXlzKSB7XG4gIGlmICh1dGlscy5pc1BPSk8odikgJiYgdi4kX18gIT0gbnVsbCAmJiB2Ll9kb2MgIT0gbnVsbCkge1xuICAgIGlmIChpbmNsdWRlRXh0cmFLZXlzKSB7XG4gICAgICBjb25zdCBleHRyYUtleXMgPSB7fTtcbiAgICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKHYpKSB7XG4gICAgICAgIGlmICh0eXBlb2Yga2V5ID09PSAnc3ltYm9sJykge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChrZXlbMF0gPT09ICckJykge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChrZXlzVG9Ta2lwLmhhcyhrZXkpKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgZXh0cmFLZXlzW2tleV0gPSB2W2tleV07XG4gICAgICB9XG4gICAgICByZXR1cm4geyAuLi52Ll9kb2MsIC4uLmV4dHJhS2V5cyB9O1xuICAgIH1cbiAgICByZXR1cm4gdi5fZG9jO1xuICB9XG5cbiAgcmV0dXJuIHY7XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../server/node_modules/mongoose/lib/helpers/document/handleSpreadDoc.js\n");

/***/ }),

/***/ "../server/node_modules/mongoose/lib/helpers/each.js":
/*!***********************************************************!*\
  !*** ../server/node_modules/mongoose/lib/helpers/each.js ***!
  \***********************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nmodule.exports = function each(arr, cb, done) {\n  if (arr.length === 0) {\n    return done();\n  }\n\n  let remaining = arr.length;\n  let err = null;\n  for (const v of arr) {\n    cb(v, function(_err) {\n      if (err != null) {\n        return;\n      }\n      if (_err != null) {\n        err = _err;\n        return done(err);\n      }\n\n      if (--remaining <= 0) {\n        return done();\n      }\n    });\n  }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9lYWNoLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbGllbnQvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9lYWNoLmpzPzk0MTMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGVhY2goYXJyLCBjYiwgZG9uZSkge1xuICBpZiAoYXJyLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBkb25lKCk7XG4gIH1cblxuICBsZXQgcmVtYWluaW5nID0gYXJyLmxlbmd0aDtcbiAgbGV0IGVyciA9IG51bGw7XG4gIGZvciAoY29uc3QgdiBvZiBhcnIpIHtcbiAgICBjYih2LCBmdW5jdGlvbihfZXJyKSB7XG4gICAgICBpZiAoZXJyICE9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKF9lcnIgIT0gbnVsbCkge1xuICAgICAgICBlcnIgPSBfZXJyO1xuICAgICAgICByZXR1cm4gZG9uZShlcnIpO1xuICAgICAgfVxuXG4gICAgICBpZiAoLS1yZW1haW5pbmcgPD0gMCkge1xuICAgICAgICByZXR1cm4gZG9uZSgpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../server/node_modules/mongoose/lib/helpers/each.js\n");

/***/ }),

/***/ "../server/node_modules/mongoose/lib/helpers/error/combinePathErrors.js":
/*!******************************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/helpers/error/combinePathErrors.js ***!
  \******************************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/*!\n * ignore\n */\n\nmodule.exports = function combinePathErrors(err) {\n  const keys = Object.keys(err.errors || {});\n  const len = keys.length;\n  const msgs = [];\n  let key;\n\n  for (let i = 0; i < len; ++i) {\n    key = keys[i];\n    if (err === err.errors[key]) {\n      continue;\n    }\n    msgs.push(key + ': ' + err.errors[key].message);\n  }\n\n  return msgs.join(', ');\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9lcnJvci9jb21iaW5lUGF0aEVycm9ycy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBOztBQUVBLGtCQUFrQixTQUFTO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2xpZW50Ly4uL3NlcnZlci9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvZXJyb3IvY29tYmluZVBhdGhFcnJvcnMuanM/M2MzOCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBjb21iaW5lUGF0aEVycm9ycyhlcnIpIHtcbiAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKGVyci5lcnJvcnMgfHwge30pO1xuICBjb25zdCBsZW4gPSBrZXlzLmxlbmd0aDtcbiAgY29uc3QgbXNncyA9IFtdO1xuICBsZXQga2V5O1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICBrZXkgPSBrZXlzW2ldO1xuICAgIGlmIChlcnIgPT09IGVyci5lcnJvcnNba2V5XSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIG1zZ3MucHVzaChrZXkgKyAnOiAnICsgZXJyLmVycm9yc1trZXldLm1lc3NhZ2UpO1xuICB9XG5cbiAgcmV0dXJuIG1zZ3Muam9pbignLCAnKTtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../server/node_modules/mongoose/lib/helpers/error/combinePathErrors.js\n");

/***/ }),

/***/ "../server/node_modules/mongoose/lib/helpers/firstKey.js":
/*!***************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/helpers/firstKey.js ***!
  \***************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nmodule.exports = function firstKey(obj) {\n  if (obj == null) {\n    return null;\n  }\n  return Object.keys(obj)[0];\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9maXJzdEtleS5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbGllbnQvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9maXJzdEtleS5qcz80YjlkIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBmaXJzdEtleShvYmopIHtcbiAgaWYgKG9iaiA9PSBudWxsKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmV0dXJuIE9iamVjdC5rZXlzKG9iailbMF07XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../server/node_modules/mongoose/lib/helpers/firstKey.js\n");

/***/ }),

/***/ "../server/node_modules/mongoose/lib/helpers/get.js":
/*!**********************************************************!*\
  !*** ../server/node_modules/mongoose/lib/helpers/get.js ***!
  \**********************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/**\n * Simplified lodash.get to work around the annoying null quirk. See:\n * https://github.com/lodash/lodash/issues/3659\n * @api private\n */\n\nmodule.exports = function get(obj, path, def) {\n  let parts;\n  let isPathArray = false;\n  if (typeof path === 'string') {\n    if (path.indexOf('.') === -1) {\n      const _v = getProperty(obj, path);\n      if (_v == null) {\n        return def;\n      }\n      return _v;\n    }\n\n    parts = path.split('.');\n  } else {\n    isPathArray = true;\n    parts = path;\n\n    if (parts.length === 1) {\n      const _v = getProperty(obj, parts[0]);\n      if (_v == null) {\n        return def;\n      }\n      return _v;\n    }\n  }\n  let rest = path;\n  let cur = obj;\n  for (const part of parts) {\n    if (cur == null) {\n      return def;\n    }\n\n    // `lib/cast.js` depends on being able to get dotted paths in updates,\n    // like `{ $set: { 'a.b': 42 } }`\n    if (!isPathArray && cur[rest] != null) {\n      return cur[rest];\n    }\n\n    cur = getProperty(cur, part);\n\n    if (!isPathArray) {\n      rest = rest.substr(part.length + 1);\n    }\n  }\n\n  return cur == null ? def : cur;\n};\n\nfunction getProperty(obj, prop) {\n  if (obj == null) {\n    return obj;\n  }\n  if (obj instanceof Map) {\n    return obj.get(prop);\n  }\n  return obj[prop];\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9nZXQuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWUsUUFBUSxhQUFhO0FBQ3BDO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2NsaWVudC8uLi9zZXJ2ZXIvbm9kZV9tb2R1bGVzL21vbmdvb3NlL2xpYi9oZWxwZXJzL2dldC5qcz9hZWEzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBTaW1wbGlmaWVkIGxvZGFzaC5nZXQgdG8gd29yayBhcm91bmQgdGhlIGFubm95aW5nIG51bGwgcXVpcmsuIFNlZTpcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9sb2Rhc2gvbG9kYXNoL2lzc3Vlcy8zNjU5XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGdldChvYmosIHBhdGgsIGRlZikge1xuICBsZXQgcGFydHM7XG4gIGxldCBpc1BhdGhBcnJheSA9IGZhbHNlO1xuICBpZiAodHlwZW9mIHBhdGggPT09ICdzdHJpbmcnKSB7XG4gICAgaWYgKHBhdGguaW5kZXhPZignLicpID09PSAtMSkge1xuICAgICAgY29uc3QgX3YgPSBnZXRQcm9wZXJ0eShvYmosIHBhdGgpO1xuICAgICAgaWYgKF92ID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGRlZjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBfdjtcbiAgICB9XG5cbiAgICBwYXJ0cyA9IHBhdGguc3BsaXQoJy4nKTtcbiAgfSBlbHNlIHtcbiAgICBpc1BhdGhBcnJheSA9IHRydWU7XG4gICAgcGFydHMgPSBwYXRoO1xuXG4gICAgaWYgKHBhcnRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgY29uc3QgX3YgPSBnZXRQcm9wZXJ0eShvYmosIHBhcnRzWzBdKTtcbiAgICAgIGlmIChfdiA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBkZWY7XG4gICAgICB9XG4gICAgICByZXR1cm4gX3Y7XG4gICAgfVxuICB9XG4gIGxldCByZXN0ID0gcGF0aDtcbiAgbGV0IGN1ciA9IG9iajtcbiAgZm9yIChjb25zdCBwYXJ0IG9mIHBhcnRzKSB7XG4gICAgaWYgKGN1ciA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gZGVmO1xuICAgIH1cblxuICAgIC8vIGBsaWIvY2FzdC5qc2AgZGVwZW5kcyBvbiBiZWluZyBhYmxlIHRvIGdldCBkb3R0ZWQgcGF0aHMgaW4gdXBkYXRlcyxcbiAgICAvLyBsaWtlIGB7ICRzZXQ6IHsgJ2EuYic6IDQyIH0gfWBcbiAgICBpZiAoIWlzUGF0aEFycmF5ICYmIGN1cltyZXN0XSAhPSBudWxsKSB7XG4gICAgICByZXR1cm4gY3VyW3Jlc3RdO1xuICAgIH1cblxuICAgIGN1ciA9IGdldFByb3BlcnR5KGN1ciwgcGFydCk7XG5cbiAgICBpZiAoIWlzUGF0aEFycmF5KSB7XG4gICAgICByZXN0ID0gcmVzdC5zdWJzdHIocGFydC5sZW5ndGggKyAxKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gY3VyID09IG51bGwgPyBkZWYgOiBjdXI7XG59O1xuXG5mdW5jdGlvbiBnZXRQcm9wZXJ0eShvYmosIHByb3ApIHtcbiAgaWYgKG9iaiA9PSBudWxsKSB7XG4gICAgcmV0dXJuIG9iajtcbiAgfVxuICBpZiAob2JqIGluc3RhbmNlb2YgTWFwKSB7XG4gICAgcmV0dXJuIG9iai5nZXQocHJvcCk7XG4gIH1cbiAgcmV0dXJuIG9ialtwcm9wXTtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../server/node_modules/mongoose/lib/helpers/get.js\n");

/***/ }),

/***/ "../server/node_modules/mongoose/lib/helpers/getConstructorName.js":
/*!*************************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/helpers/getConstructorName.js ***!
  \*************************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/**\n * If `val` is an object, returns constructor name, if possible. Otherwise returns undefined.\n * @api private\n */\n\nmodule.exports = function getConstructorName(val) {\n  if (val == null) {\n    return void 0;\n  }\n  if (typeof val.constructor !== 'function') {\n    return void 0;\n  }\n  return val.constructor.name;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9nZXRDb25zdHJ1Y3Rvck5hbWUuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2xpZW50Ly4uL3NlcnZlci9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvZ2V0Q29uc3RydWN0b3JOYW1lLmpzPzEwNzQiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIElmIGB2YWxgIGlzIGFuIG9iamVjdCwgcmV0dXJucyBjb25zdHJ1Y3RvciBuYW1lLCBpZiBwb3NzaWJsZS4gT3RoZXJ3aXNlIHJldHVybnMgdW5kZWZpbmVkLlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBnZXRDb25zdHJ1Y3Rvck5hbWUodmFsKSB7XG4gIGlmICh2YWwgPT0gbnVsbCkge1xuICAgIHJldHVybiB2b2lkIDA7XG4gIH1cbiAgaWYgKHR5cGVvZiB2YWwuY29uc3RydWN0b3IgIT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG4gIHJldHVybiB2YWwuY29uc3RydWN0b3IubmFtZTtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../server/node_modules/mongoose/lib/helpers/getConstructorName.js\n");

/***/ }),

/***/ "../server/node_modules/mongoose/lib/helpers/getDefaultBulkwriteResult.js":
/*!********************************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/helpers/getDefaultBulkwriteResult.js ***!
  \********************************************************************************/
/***/ ((module) => {

"use strict";
eval("\nfunction getDefaultBulkwriteResult() {\n  return {\n    result: {\n      ok: 1,\n      writeErrors: [],\n      writeConcernErrors: [],\n      insertedIds: [],\n      nInserted: 0,\n      nUpserted: 0,\n      nMatched: 0,\n      nModified: 0,\n      nRemoved: 0,\n      upserted: []\n    },\n    insertedCount: 0,\n    matchedCount: 0,\n    modifiedCount: 0,\n    deletedCount: 0,\n    upsertedCount: 0,\n    upsertedIds: {},\n    insertedIds: {},\n    n: 0\n  };\n}\n\nmodule.exports = getDefaultBulkwriteResult;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9nZXREZWZhdWx0QnVsa3dyaXRlUmVzdWx0LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQixtQkFBbUI7QUFDbkI7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2xpZW50Ly4uL3NlcnZlci9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvZ2V0RGVmYXVsdEJ1bGt3cml0ZVJlc3VsdC5qcz80ZWQ5Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcbmZ1bmN0aW9uIGdldERlZmF1bHRCdWxrd3JpdGVSZXN1bHQoKSB7XG4gIHJldHVybiB7XG4gICAgcmVzdWx0OiB7XG4gICAgICBvazogMSxcbiAgICAgIHdyaXRlRXJyb3JzOiBbXSxcbiAgICAgIHdyaXRlQ29uY2VybkVycm9yczogW10sXG4gICAgICBpbnNlcnRlZElkczogW10sXG4gICAgICBuSW5zZXJ0ZWQ6IDAsXG4gICAgICBuVXBzZXJ0ZWQ6IDAsXG4gICAgICBuTWF0Y2hlZDogMCxcbiAgICAgIG5Nb2RpZmllZDogMCxcbiAgICAgIG5SZW1vdmVkOiAwLFxuICAgICAgdXBzZXJ0ZWQ6IFtdXG4gICAgfSxcbiAgICBpbnNlcnRlZENvdW50OiAwLFxuICAgIG1hdGNoZWRDb3VudDogMCxcbiAgICBtb2RpZmllZENvdW50OiAwLFxuICAgIGRlbGV0ZWRDb3VudDogMCxcbiAgICB1cHNlcnRlZENvdW50OiAwLFxuICAgIHVwc2VydGVkSWRzOiB7fSxcbiAgICBpbnNlcnRlZElkczoge30sXG4gICAgbjogMFxuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldERlZmF1bHRCdWxrd3JpdGVSZXN1bHQ7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../server/node_modules/mongoose/lib/helpers/getDefaultBulkwriteResult.js\n");

/***/ }),

/***/ "../server/node_modules/mongoose/lib/helpers/getFunctionName.js":
/*!**********************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/helpers/getFunctionName.js ***!
  \**********************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nconst functionNameRE = /^function\\s*([^\\s(]+)/;\n\nmodule.exports = function(fn) {\n  return (\n    fn.name ||\n    (fn.toString().trim().match(functionNameRE) || [])[1]\n  );\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9nZXRGdW5jdGlvbk5hbWUuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2xpZW50Ly4uL3NlcnZlci9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvZ2V0RnVuY3Rpb25OYW1lLmpzPzhmNGMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBmdW5jdGlvbk5hbWVSRSA9IC9eZnVuY3Rpb25cXHMqKFteXFxzKF0rKS87XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oZm4pIHtcbiAgcmV0dXJuIChcbiAgICBmbi5uYW1lIHx8XG4gICAgKGZuLnRvU3RyaW5nKCkudHJpbSgpLm1hdGNoKGZ1bmN0aW9uTmFtZVJFKSB8fCBbXSlbMV1cbiAgKTtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../server/node_modules/mongoose/lib/helpers/getFunctionName.js\n");

/***/ }),

/***/ "../server/node_modules/mongoose/lib/helpers/immediate.js":
/*!****************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/helpers/immediate.js ***!
  \****************************************************************/
/***/ ((module) => {

"use strict";
eval("/*!\n * Centralize this so we can more easily work around issues with people\n * stubbing out `process.nextTick()` in tests using sinon:\n * https://github.com/sinonjs/lolex#automatically-incrementing-mocked-time\n * See gh-6074\n */\n\n\n\nconst nextTick = typeof process !== 'undefined' && typeof process.nextTick === 'function' ?\n  process.nextTick.bind(process) :\n  cb => setTimeout(cb, 0); // Fallback for browser build\n\nmodule.exports = function immediate(cb) {\n  return nextTick(cb);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9pbW1lZGlhdGUuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVhOztBQUViO0FBQ0E7QUFDQSwyQkFBMkI7O0FBRTNCO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2NsaWVudC8uLi9zZXJ2ZXIvbm9kZV9tb2R1bGVzL21vbmdvb3NlL2xpYi9oZWxwZXJzL2ltbWVkaWF0ZS5qcz8wM2VmIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogQ2VudHJhbGl6ZSB0aGlzIHNvIHdlIGNhbiBtb3JlIGVhc2lseSB3b3JrIGFyb3VuZCBpc3N1ZXMgd2l0aCBwZW9wbGVcbiAqIHN0dWJiaW5nIG91dCBgcHJvY2Vzcy5uZXh0VGljaygpYCBpbiB0ZXN0cyB1c2luZyBzaW5vbjpcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9zaW5vbmpzL2xvbGV4I2F1dG9tYXRpY2FsbHktaW5jcmVtZW50aW5nLW1vY2tlZC10aW1lXG4gKiBTZWUgZ2gtNjA3NFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuY29uc3QgbmV4dFRpY2sgPSB0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHByb2Nlc3MubmV4dFRpY2sgPT09ICdmdW5jdGlvbicgP1xuICBwcm9jZXNzLm5leHRUaWNrLmJpbmQocHJvY2VzcykgOlxuICBjYiA9PiBzZXRUaW1lb3V0KGNiLCAwKTsgLy8gRmFsbGJhY2sgZm9yIGJyb3dzZXIgYnVpbGRcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpbW1lZGlhdGUoY2IpIHtcbiAgcmV0dXJuIG5leHRUaWNrKGNiKTtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../server/node_modules/mongoose/lib/helpers/immediate.js\n");

/***/ }),

/***/ "../server/node_modules/mongoose/lib/helpers/indexes/applySchemaCollation.js":
/*!***********************************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/helpers/indexes/applySchemaCollation.js ***!
  \***********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst isTextIndex = __webpack_require__(/*! ./isTextIndex */ \"../server/node_modules/mongoose/lib/helpers/indexes/isTextIndex.js\");\n\nmodule.exports = function applySchemaCollation(indexKeys, indexOptions, schemaOptions) {\n  if (isTextIndex(indexKeys)) {\n    return;\n  }\n\n  if (schemaOptions.hasOwnProperty('collation') && !indexOptions.hasOwnProperty('collation')) {\n    indexOptions.collation = schemaOptions.collation;\n  }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9pbmRleGVzL2FwcGx5U2NoZW1hQ29sbGF0aW9uLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLG9CQUFvQixtQkFBTyxDQUFDLHlGQUFlOztBQUUzQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2NsaWVudC8uLi9zZXJ2ZXIvbm9kZV9tb2R1bGVzL21vbmdvb3NlL2xpYi9oZWxwZXJzL2luZGV4ZXMvYXBwbHlTY2hlbWFDb2xsYXRpb24uanM/MmIwNCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IGlzVGV4dEluZGV4ID0gcmVxdWlyZSgnLi9pc1RleHRJbmRleCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGFwcGx5U2NoZW1hQ29sbGF0aW9uKGluZGV4S2V5cywgaW5kZXhPcHRpb25zLCBzY2hlbWFPcHRpb25zKSB7XG4gIGlmIChpc1RleHRJbmRleChpbmRleEtleXMpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKHNjaGVtYU9wdGlvbnMuaGFzT3duUHJvcGVydHkoJ2NvbGxhdGlvbicpICYmICFpbmRleE9wdGlvbnMuaGFzT3duUHJvcGVydHkoJ2NvbGxhdGlvbicpKSB7XG4gICAgaW5kZXhPcHRpb25zLmNvbGxhdGlvbiA9IHNjaGVtYU9wdGlvbnMuY29sbGF0aW9uO1xuICB9XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../server/node_modules/mongoose/lib/helpers/indexes/applySchemaCollation.js\n");

/***/ }),

/***/ "../server/node_modules/mongoose/lib/helpers/indexes/decorateDiscriminatorIndexOptions.js":
/*!************************************************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/helpers/indexes/decorateDiscriminatorIndexOptions.js ***!
  \************************************************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nmodule.exports = function decorateDiscriminatorIndexOptions(schema, indexOptions) {\n  // If the model is a discriminator and has an index, add a\n  // partialFilterExpression by default so the index will only apply\n  // to that discriminator.\n  const discriminatorName = schema.discriminatorMapping && schema.discriminatorMapping.value;\n  if (discriminatorName && !('sparse' in indexOptions)) {\n    const discriminatorKey = schema.options.discriminatorKey;\n    indexOptions.partialFilterExpression = indexOptions.partialFilterExpression || {};\n    indexOptions.partialFilterExpression[discriminatorKey] = discriminatorName;\n  }\n  return indexOptions;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9pbmRleGVzL2RlY29yYXRlRGlzY3JpbWluYXRvckluZGV4T3B0aW9ucy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbGllbnQvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9pbmRleGVzL2RlY29yYXRlRGlzY3JpbWluYXRvckluZGV4T3B0aW9ucy5qcz8zZjVhIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBkZWNvcmF0ZURpc2NyaW1pbmF0b3JJbmRleE9wdGlvbnMoc2NoZW1hLCBpbmRleE9wdGlvbnMpIHtcbiAgLy8gSWYgdGhlIG1vZGVsIGlzIGEgZGlzY3JpbWluYXRvciBhbmQgaGFzIGFuIGluZGV4LCBhZGQgYVxuICAvLyBwYXJ0aWFsRmlsdGVyRXhwcmVzc2lvbiBieSBkZWZhdWx0IHNvIHRoZSBpbmRleCB3aWxsIG9ubHkgYXBwbHlcbiAgLy8gdG8gdGhhdCBkaXNjcmltaW5hdG9yLlxuICBjb25zdCBkaXNjcmltaW5hdG9yTmFtZSA9IHNjaGVtYS5kaXNjcmltaW5hdG9yTWFwcGluZyAmJiBzY2hlbWEuZGlzY3JpbWluYXRvck1hcHBpbmcudmFsdWU7XG4gIGlmIChkaXNjcmltaW5hdG9yTmFtZSAmJiAhKCdzcGFyc2UnIGluIGluZGV4T3B0aW9ucykpIHtcbiAgICBjb25zdCBkaXNjcmltaW5hdG9yS2V5ID0gc2NoZW1hLm9wdGlvbnMuZGlzY3JpbWluYXRvcktleTtcbiAgICBpbmRleE9wdGlvbnMucGFydGlhbEZpbHRlckV4cHJlc3Npb24gPSBpbmRleE9wdGlvbnMucGFydGlhbEZpbHRlckV4cHJlc3Npb24gfHwge307XG4gICAgaW5kZXhPcHRpb25zLnBhcnRpYWxGaWx0ZXJFeHByZXNzaW9uW2Rpc2NyaW1pbmF0b3JLZXldID0gZGlzY3JpbWluYXRvck5hbWU7XG4gIH1cbiAgcmV0dXJuIGluZGV4T3B0aW9ucztcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../server/node_modules/mongoose/lib/helpers/indexes/decorateDiscriminatorIndexOptions.js\n");

/***/ }),

/***/ "../server/node_modules/mongoose/lib/helpers/indexes/getRelatedIndexes.js":
/*!********************************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/helpers/indexes/getRelatedIndexes.js ***!
  \********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst hasDollarKeys = __webpack_require__(/*! ../query/hasDollarKeys */ \"../server/node_modules/mongoose/lib/helpers/query/hasDollarKeys.js\");\n\nfunction getRelatedSchemaIndexes(model, schemaIndexes) {\n  return getRelatedIndexes({\n    baseModelName: model.baseModelName,\n    discriminatorMapping: model.schema.discriminatorMapping,\n    indexes: schemaIndexes,\n    indexesType: 'schema'\n  });\n}\n\nfunction getRelatedDBIndexes(model, dbIndexes) {\n  return getRelatedIndexes({\n    baseModelName: model.baseModelName,\n    discriminatorMapping: model.schema.discriminatorMapping,\n    indexes: dbIndexes,\n    indexesType: 'db'\n  });\n}\n\nmodule.exports = {\n  getRelatedSchemaIndexes,\n  getRelatedDBIndexes\n};\n\nfunction getRelatedIndexes({\n  baseModelName,\n  discriminatorMapping,\n  indexes,\n  indexesType\n}) {\n  const discriminatorKey = discriminatorMapping && discriminatorMapping.key;\n  const discriminatorValue = discriminatorMapping && discriminatorMapping.value;\n\n  if (!discriminatorKey) {\n    return indexes;\n  }\n\n  const isChildDiscriminatorModel = Boolean(baseModelName);\n  if (isChildDiscriminatorModel) {\n    return indexes.filter(index => {\n      const partialFilterExpression = getPartialFilterExpression(index, indexesType);\n      return partialFilterExpression && partialFilterExpression[discriminatorKey] === discriminatorValue;\n    });\n  }\n\n  return indexes.filter(index => {\n    const partialFilterExpression = getPartialFilterExpression(index, indexesType);\n    return !partialFilterExpression\n      || !partialFilterExpression[discriminatorKey]\n      || (hasDollarKeys(partialFilterExpression[discriminatorKey]) && !('$eq' in partialFilterExpression[discriminatorKey]));\n  });\n}\n\nfunction getPartialFilterExpression(index, indexesType) {\n  if (indexesType === 'schema') {\n    const options = index[1];\n    return options && options.partialFilterExpression;\n  }\n  return index.partialFilterExpression;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9pbmRleGVzL2dldFJlbGF0ZWRJbmRleGVzLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLHNCQUFzQixtQkFBTyxDQUFDLGtHQUF3Qjs7QUFFdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2NsaWVudC8uLi9zZXJ2ZXIvbm9kZV9tb2R1bGVzL21vbmdvb3NlL2xpYi9oZWxwZXJzL2luZGV4ZXMvZ2V0UmVsYXRlZEluZGV4ZXMuanM/Y2RlMSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IGhhc0RvbGxhcktleXMgPSByZXF1aXJlKCcuLi9xdWVyeS9oYXNEb2xsYXJLZXlzJyk7XG5cbmZ1bmN0aW9uIGdldFJlbGF0ZWRTY2hlbWFJbmRleGVzKG1vZGVsLCBzY2hlbWFJbmRleGVzKSB7XG4gIHJldHVybiBnZXRSZWxhdGVkSW5kZXhlcyh7XG4gICAgYmFzZU1vZGVsTmFtZTogbW9kZWwuYmFzZU1vZGVsTmFtZSxcbiAgICBkaXNjcmltaW5hdG9yTWFwcGluZzogbW9kZWwuc2NoZW1hLmRpc2NyaW1pbmF0b3JNYXBwaW5nLFxuICAgIGluZGV4ZXM6IHNjaGVtYUluZGV4ZXMsXG4gICAgaW5kZXhlc1R5cGU6ICdzY2hlbWEnXG4gIH0pO1xufVxuXG5mdW5jdGlvbiBnZXRSZWxhdGVkREJJbmRleGVzKG1vZGVsLCBkYkluZGV4ZXMpIHtcbiAgcmV0dXJuIGdldFJlbGF0ZWRJbmRleGVzKHtcbiAgICBiYXNlTW9kZWxOYW1lOiBtb2RlbC5iYXNlTW9kZWxOYW1lLFxuICAgIGRpc2NyaW1pbmF0b3JNYXBwaW5nOiBtb2RlbC5zY2hlbWEuZGlzY3JpbWluYXRvck1hcHBpbmcsXG4gICAgaW5kZXhlczogZGJJbmRleGVzLFxuICAgIGluZGV4ZXNUeXBlOiAnZGInXG4gIH0pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgZ2V0UmVsYXRlZFNjaGVtYUluZGV4ZXMsXG4gIGdldFJlbGF0ZWREQkluZGV4ZXNcbn07XG5cbmZ1bmN0aW9uIGdldFJlbGF0ZWRJbmRleGVzKHtcbiAgYmFzZU1vZGVsTmFtZSxcbiAgZGlzY3JpbWluYXRvck1hcHBpbmcsXG4gIGluZGV4ZXMsXG4gIGluZGV4ZXNUeXBlXG59KSB7XG4gIGNvbnN0IGRpc2NyaW1pbmF0b3JLZXkgPSBkaXNjcmltaW5hdG9yTWFwcGluZyAmJiBkaXNjcmltaW5hdG9yTWFwcGluZy5rZXk7XG4gIGNvbnN0IGRpc2NyaW1pbmF0b3JWYWx1ZSA9IGRpc2NyaW1pbmF0b3JNYXBwaW5nICYmIGRpc2NyaW1pbmF0b3JNYXBwaW5nLnZhbHVlO1xuXG4gIGlmICghZGlzY3JpbWluYXRvcktleSkge1xuICAgIHJldHVybiBpbmRleGVzO1xuICB9XG5cbiAgY29uc3QgaXNDaGlsZERpc2NyaW1pbmF0b3JNb2RlbCA9IEJvb2xlYW4oYmFzZU1vZGVsTmFtZSk7XG4gIGlmIChpc0NoaWxkRGlzY3JpbWluYXRvck1vZGVsKSB7XG4gICAgcmV0dXJuIGluZGV4ZXMuZmlsdGVyKGluZGV4ID0+IHtcbiAgICAgIGNvbnN0IHBhcnRpYWxGaWx0ZXJFeHByZXNzaW9uID0gZ2V0UGFydGlhbEZpbHRlckV4cHJlc3Npb24oaW5kZXgsIGluZGV4ZXNUeXBlKTtcbiAgICAgIHJldHVybiBwYXJ0aWFsRmlsdGVyRXhwcmVzc2lvbiAmJiBwYXJ0aWFsRmlsdGVyRXhwcmVzc2lvbltkaXNjcmltaW5hdG9yS2V5XSA9PT0gZGlzY3JpbWluYXRvclZhbHVlO1xuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIGluZGV4ZXMuZmlsdGVyKGluZGV4ID0+IHtcbiAgICBjb25zdCBwYXJ0aWFsRmlsdGVyRXhwcmVzc2lvbiA9IGdldFBhcnRpYWxGaWx0ZXJFeHByZXNzaW9uKGluZGV4LCBpbmRleGVzVHlwZSk7XG4gICAgcmV0dXJuICFwYXJ0aWFsRmlsdGVyRXhwcmVzc2lvblxuICAgICAgfHwgIXBhcnRpYWxGaWx0ZXJFeHByZXNzaW9uW2Rpc2NyaW1pbmF0b3JLZXldXG4gICAgICB8fCAoaGFzRG9sbGFyS2V5cyhwYXJ0aWFsRmlsdGVyRXhwcmVzc2lvbltkaXNjcmltaW5hdG9yS2V5XSkgJiYgISgnJGVxJyBpbiBwYXJ0aWFsRmlsdGVyRXhwcmVzc2lvbltkaXNjcmltaW5hdG9yS2V5XSkpO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gZ2V0UGFydGlhbEZpbHRlckV4cHJlc3Npb24oaW5kZXgsIGluZGV4ZXNUeXBlKSB7XG4gIGlmIChpbmRleGVzVHlwZSA9PT0gJ3NjaGVtYScpIHtcbiAgICBjb25zdCBvcHRpb25zID0gaW5kZXhbMV07XG4gICAgcmV0dXJuIG9wdGlvbnMgJiYgb3B0aW9ucy5wYXJ0aWFsRmlsdGVyRXhwcmVzc2lvbjtcbiAgfVxuICByZXR1cm4gaW5kZXgucGFydGlhbEZpbHRlckV4cHJlc3Npb247XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../server/node_modules/mongoose/lib/helpers/indexes/getRelatedIndexes.js\n");

/***/ }),

/***/ "../server/node_modules/mongoose/lib/helpers/indexes/isDefaultIdIndex.js":
/*!*******************************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/helpers/indexes/isDefaultIdIndex.js ***!
  \*******************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst get = __webpack_require__(/*! ../get */ \"../server/node_modules/mongoose/lib/helpers/get.js\");\n\nmodule.exports = function isDefaultIdIndex(index) {\n  if (Array.isArray(index)) {\n    // Mongoose syntax\n    const keys = Object.keys(index[0]);\n    return keys.length === 1 && keys[0] === '_id' && index[0]._id !== 'hashed';\n  }\n\n  if (typeof index !== 'object') {\n    return false;\n  }\n\n  const key = get(index, 'key', {});\n  return Object.keys(key).length === 1 && key.hasOwnProperty('_id');\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9pbmRleGVzL2lzRGVmYXVsdElkSW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsWUFBWSxtQkFBTyxDQUFDLGtFQUFROztBQUU1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGtDQUFrQztBQUNsQztBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2xpZW50Ly4uL3NlcnZlci9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvaW5kZXhlcy9pc0RlZmF1bHRJZEluZGV4LmpzPzM0OGUiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBnZXQgPSByZXF1aXJlKCcuLi9nZXQnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc0RlZmF1bHRJZEluZGV4KGluZGV4KSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGluZGV4KSkge1xuICAgIC8vIE1vbmdvb3NlIHN5bnRheFxuICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhpbmRleFswXSk7XG4gICAgcmV0dXJuIGtleXMubGVuZ3RoID09PSAxICYmIGtleXNbMF0gPT09ICdfaWQnICYmIGluZGV4WzBdLl9pZCAhPT0gJ2hhc2hlZCc7XG4gIH1cblxuICBpZiAodHlwZW9mIGluZGV4ICE9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGNvbnN0IGtleSA9IGdldChpbmRleCwgJ2tleScsIHt9KTtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKGtleSkubGVuZ3RoID09PSAxICYmIGtleS5oYXNPd25Qcm9wZXJ0eSgnX2lkJyk7XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../server/node_modules/mongoose/lib/helpers/indexes/isDefaultIdIndex.js\n");

/***/ }),

/***/ "../server/node_modules/mongoose/lib/helpers/indexes/isIndexEqual.js":
/*!***************************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/helpers/indexes/isIndexEqual.js ***!
  \***************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst get = __webpack_require__(/*! ../get */ \"../server/node_modules/mongoose/lib/helpers/get.js\");\nconst utils = __webpack_require__(/*! ../../utils */ \"../server/node_modules/mongoose/lib/utils.js\");\n/**\n * Given a Mongoose index definition (key + options objects) and a MongoDB server\n * index definition, determine if the two indexes are equal.\n *\n * @param {Object} schemaIndexKeysObject the Mongoose index spec\n * @param {Object} options the Mongoose index definition's options\n * @param {Object} dbIndex the index in MongoDB as returned by `listIndexes()`\n * @api private\n */\n\nmodule.exports = function isIndexEqual(schemaIndexKeysObject, options, dbIndex) {\n  // Special case: text indexes have a special format in the db. For example,\n  // `{ name: 'text' }` becomes:\n  // {\n  //   v: 2,\n  //   key: { _fts: 'text', _ftsx: 1 },\n  //   name: 'name_text',\n  //   ns: 'test.tests',\n  //   background: true,\n  //   weights: { name: 1 },\n  //   default_language: 'english',\n  //   language_override: 'language',\n  //   textIndexVersion: 3\n  // }\n  if (dbIndex.textIndexVersion != null) {\n    delete dbIndex.key._fts;\n    delete dbIndex.key._ftsx;\n    const weights = { ...dbIndex.weights, ...dbIndex.key };\n    if (Object.keys(weights).length !== Object.keys(schemaIndexKeysObject).length) {\n      return false;\n    }\n    for (const prop of Object.keys(weights)) {\n      if (!(prop in schemaIndexKeysObject)) {\n        return false;\n      }\n      const weight = weights[prop];\n      if (weight !== get(options, 'weights.' + prop) && !(weight === 1 && get(options, 'weights.' + prop) == null)) {\n        return false;\n      }\n    }\n\n    if (options['default_language'] !== dbIndex['default_language']) {\n      return dbIndex['default_language'] === 'english' && options['default_language'] == null;\n    }\n\n    return true;\n  }\n\n  const optionKeys = [\n    'unique',\n    'partialFilterExpression',\n    'sparse',\n    'expireAfterSeconds',\n    'collation'\n  ];\n  for (const key of optionKeys) {\n    if (!(key in options) && !(key in dbIndex)) {\n      continue;\n    }\n    if (key === 'collation') {\n      if (options[key] == null || dbIndex[key] == null) {\n        return options[key] == null && dbIndex[key] == null;\n      }\n      const definedKeys = Object.keys(options.collation);\n      const schemaCollation = options.collation;\n      const dbCollation = dbIndex.collation;\n      for (const opt of definedKeys) {\n        if (get(schemaCollation, opt) !== get(dbCollation, opt)) {\n          return false;\n        }\n      }\n    } else if (!utils.deepEqual(options[key], dbIndex[key])) {\n      return false;\n    }\n  }\n\n  const schemaIndexKeys = Object.keys(schemaIndexKeysObject);\n  const dbIndexKeys = Object.keys(dbIndex.key);\n  if (schemaIndexKeys.length !== dbIndexKeys.length) {\n    return false;\n  }\n  for (let i = 0; i < schemaIndexKeys.length; ++i) {\n    if (schemaIndexKeys[i] !== dbIndexKeys[i]) {\n      return false;\n    }\n    if (!utils.deepEqual(schemaIndexKeysObject[schemaIndexKeys[i]], dbIndex.key[dbIndexKeys[i]])) {\n      return false;\n    }\n  }\n\n  return true;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9pbmRleGVzL2lzSW5kZXhFcXVhbC5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixZQUFZLG1CQUFPLENBQUMsa0VBQVE7QUFDNUIsY0FBYyxtQkFBTyxDQUFDLGlFQUFhO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUSxjQUFjO0FBQ3RCO0FBQ0E7QUFDQSxjQUFjLHdCQUF3QjtBQUN0QztBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsU0FBUztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQiw0QkFBNEI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2NsaWVudC8uLi9zZXJ2ZXIvbm9kZV9tb2R1bGVzL21vbmdvb3NlL2xpYi9oZWxwZXJzL2luZGV4ZXMvaXNJbmRleEVxdWFsLmpzP2E2NmIiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBnZXQgPSByZXF1aXJlKCcuLi9nZXQnKTtcbmNvbnN0IHV0aWxzID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMnKTtcbi8qKlxuICogR2l2ZW4gYSBNb25nb29zZSBpbmRleCBkZWZpbml0aW9uIChrZXkgKyBvcHRpb25zIG9iamVjdHMpIGFuZCBhIE1vbmdvREIgc2VydmVyXG4gKiBpbmRleCBkZWZpbml0aW9uLCBkZXRlcm1pbmUgaWYgdGhlIHR3byBpbmRleGVzIGFyZSBlcXVhbC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gc2NoZW1hSW5kZXhLZXlzT2JqZWN0IHRoZSBNb25nb29zZSBpbmRleCBzcGVjXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyB0aGUgTW9uZ29vc2UgaW5kZXggZGVmaW5pdGlvbidzIG9wdGlvbnNcbiAqIEBwYXJhbSB7T2JqZWN0fSBkYkluZGV4IHRoZSBpbmRleCBpbiBNb25nb0RCIGFzIHJldHVybmVkIGJ5IGBsaXN0SW5kZXhlcygpYFxuICogQGFwaSBwcml2YXRlXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc0luZGV4RXF1YWwoc2NoZW1hSW5kZXhLZXlzT2JqZWN0LCBvcHRpb25zLCBkYkluZGV4KSB7XG4gIC8vIFNwZWNpYWwgY2FzZTogdGV4dCBpbmRleGVzIGhhdmUgYSBzcGVjaWFsIGZvcm1hdCBpbiB0aGUgZGIuIEZvciBleGFtcGxlLFxuICAvLyBgeyBuYW1lOiAndGV4dCcgfWAgYmVjb21lczpcbiAgLy8ge1xuICAvLyAgIHY6IDIsXG4gIC8vICAga2V5OiB7IF9mdHM6ICd0ZXh0JywgX2Z0c3g6IDEgfSxcbiAgLy8gICBuYW1lOiAnbmFtZV90ZXh0JyxcbiAgLy8gICBuczogJ3Rlc3QudGVzdHMnLFxuICAvLyAgIGJhY2tncm91bmQ6IHRydWUsXG4gIC8vICAgd2VpZ2h0czogeyBuYW1lOiAxIH0sXG4gIC8vICAgZGVmYXVsdF9sYW5ndWFnZTogJ2VuZ2xpc2gnLFxuICAvLyAgIGxhbmd1YWdlX292ZXJyaWRlOiAnbGFuZ3VhZ2UnLFxuICAvLyAgIHRleHRJbmRleFZlcnNpb246IDNcbiAgLy8gfVxuICBpZiAoZGJJbmRleC50ZXh0SW5kZXhWZXJzaW9uICE9IG51bGwpIHtcbiAgICBkZWxldGUgZGJJbmRleC5rZXkuX2Z0cztcbiAgICBkZWxldGUgZGJJbmRleC5rZXkuX2Z0c3g7XG4gICAgY29uc3Qgd2VpZ2h0cyA9IHsgLi4uZGJJbmRleC53ZWlnaHRzLCAuLi5kYkluZGV4LmtleSB9O1xuICAgIGlmIChPYmplY3Qua2V5cyh3ZWlnaHRzKS5sZW5ndGggIT09IE9iamVjdC5rZXlzKHNjaGVtYUluZGV4S2V5c09iamVjdCkubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGZvciAoY29uc3QgcHJvcCBvZiBPYmplY3Qua2V5cyh3ZWlnaHRzKSkge1xuICAgICAgaWYgKCEocHJvcCBpbiBzY2hlbWFJbmRleEtleXNPYmplY3QpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHdlaWdodCA9IHdlaWdodHNbcHJvcF07XG4gICAgICBpZiAod2VpZ2h0ICE9PSBnZXQob3B0aW9ucywgJ3dlaWdodHMuJyArIHByb3ApICYmICEod2VpZ2h0ID09PSAxICYmIGdldChvcHRpb25zLCAnd2VpZ2h0cy4nICsgcHJvcCkgPT0gbnVsbCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChvcHRpb25zWydkZWZhdWx0X2xhbmd1YWdlJ10gIT09IGRiSW5kZXhbJ2RlZmF1bHRfbGFuZ3VhZ2UnXSkge1xuICAgICAgcmV0dXJuIGRiSW5kZXhbJ2RlZmF1bHRfbGFuZ3VhZ2UnXSA9PT0gJ2VuZ2xpc2gnICYmIG9wdGlvbnNbJ2RlZmF1bHRfbGFuZ3VhZ2UnXSA9PSBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgY29uc3Qgb3B0aW9uS2V5cyA9IFtcbiAgICAndW5pcXVlJyxcbiAgICAncGFydGlhbEZpbHRlckV4cHJlc3Npb24nLFxuICAgICdzcGFyc2UnLFxuICAgICdleHBpcmVBZnRlclNlY29uZHMnLFxuICAgICdjb2xsYXRpb24nXG4gIF07XG4gIGZvciAoY29uc3Qga2V5IG9mIG9wdGlvbktleXMpIHtcbiAgICBpZiAoIShrZXkgaW4gb3B0aW9ucykgJiYgIShrZXkgaW4gZGJJbmRleCkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAoa2V5ID09PSAnY29sbGF0aW9uJykge1xuICAgICAgaWYgKG9wdGlvbnNba2V5XSA9PSBudWxsIHx8IGRiSW5kZXhba2V5XSA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBvcHRpb25zW2tleV0gPT0gbnVsbCAmJiBkYkluZGV4W2tleV0gPT0gbnVsbDtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGRlZmluZWRLZXlzID0gT2JqZWN0LmtleXMob3B0aW9ucy5jb2xsYXRpb24pO1xuICAgICAgY29uc3Qgc2NoZW1hQ29sbGF0aW9uID0gb3B0aW9ucy5jb2xsYXRpb247XG4gICAgICBjb25zdCBkYkNvbGxhdGlvbiA9IGRiSW5kZXguY29sbGF0aW9uO1xuICAgICAgZm9yIChjb25zdCBvcHQgb2YgZGVmaW5lZEtleXMpIHtcbiAgICAgICAgaWYgKGdldChzY2hlbWFDb2xsYXRpb24sIG9wdCkgIT09IGdldChkYkNvbGxhdGlvbiwgb3B0KSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIXV0aWxzLmRlZXBFcXVhbChvcHRpb25zW2tleV0sIGRiSW5kZXhba2V5XSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBjb25zdCBzY2hlbWFJbmRleEtleXMgPSBPYmplY3Qua2V5cyhzY2hlbWFJbmRleEtleXNPYmplY3QpO1xuICBjb25zdCBkYkluZGV4S2V5cyA9IE9iamVjdC5rZXlzKGRiSW5kZXgua2V5KTtcbiAgaWYgKHNjaGVtYUluZGV4S2V5cy5sZW5ndGggIT09IGRiSW5kZXhLZXlzLmxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBmb3IgKGxldCBpID0gMDsgaSA8IHNjaGVtYUluZGV4S2V5cy5sZW5ndGg7ICsraSkge1xuICAgIGlmIChzY2hlbWFJbmRleEtleXNbaV0gIT09IGRiSW5kZXhLZXlzW2ldKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICghdXRpbHMuZGVlcEVxdWFsKHNjaGVtYUluZGV4S2V5c09iamVjdFtzY2hlbWFJbmRleEtleXNbaV1dLCBkYkluZGV4LmtleVtkYkluZGV4S2V5c1tpXV0pKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../server/node_modules/mongoose/lib/helpers/indexes/isIndexEqual.js\n");

/***/ }),

/***/ "../server/node_modules/mongoose/lib/helpers/indexes/isTextIndex.js":
/*!**************************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/helpers/indexes/isTextIndex.js ***!
  \**************************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/**\n * Returns `true` if the given index options have a `text` option.\n */\n\nmodule.exports = function isTextIndex(indexKeys) {\n  let isTextIndex = false;\n  for (const key of Object.keys(indexKeys)) {\n    if (indexKeys[key] === 'text') {\n      isTextIndex = true;\n    }\n  }\n\n  return isTextIndex;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9pbmRleGVzL2lzVGV4dEluZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2xpZW50Ly4uL3NlcnZlci9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvaW5kZXhlcy9pc1RleHRJbmRleC5qcz9hYWQyIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZ2l2ZW4gaW5kZXggb3B0aW9ucyBoYXZlIGEgYHRleHRgIG9wdGlvbi5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzVGV4dEluZGV4KGluZGV4S2V5cykge1xuICBsZXQgaXNUZXh0SW5kZXggPSBmYWxzZTtcbiAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMoaW5kZXhLZXlzKSkge1xuICAgIGlmIChpbmRleEtleXNba2V5XSA9PT0gJ3RleHQnKSB7XG4gICAgICBpc1RleHRJbmRleCA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGlzVGV4dEluZGV4O1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../server/node_modules/mongoose/lib/helpers/indexes/isTextIndex.js\n");

/***/ }),

/***/ "../server/node_modules/mongoose/lib/helpers/isAsyncFunction.js":
/*!**********************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/helpers/isAsyncFunction.js ***!
  \**********************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nmodule.exports = function isAsyncFunction(v) {\n  return (\n    typeof v === 'function' &&\n    v.constructor &&\n    v.constructor.name === 'AsyncFunction'\n  );\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9pc0FzeW5jRnVuY3Rpb24uanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbGllbnQvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9pc0FzeW5jRnVuY3Rpb24uanM/Njg2YSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNBc3luY0Z1bmN0aW9uKHYpIHtcbiAgcmV0dXJuIChcbiAgICB0eXBlb2YgdiA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgIHYuY29uc3RydWN0b3IgJiZcbiAgICB2LmNvbnN0cnVjdG9yLm5hbWUgPT09ICdBc3luY0Z1bmN0aW9uJ1xuICApO1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../server/node_modules/mongoose/lib/helpers/isAsyncFunction.js\n");

/***/ }),

/***/ "../server/node_modules/mongoose/lib/helpers/isBsonType.js":
/*!*****************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/helpers/isBsonType.js ***!
  \*****************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/**\n * Get the bson type, if it exists\n * @api private\n */\n\nfunction isBsonType(obj, typename) {\n  return (\n    typeof obj === 'object' &&\n    obj !== null &&\n    obj._bsontype === typename\n  );\n}\n\nmodule.exports = isBsonType;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9pc0Jzb25UeXBlLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2xpZW50Ly4uL3NlcnZlci9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvaXNCc29uVHlwZS5qcz8zMDdkIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBHZXQgdGhlIGJzb24gdHlwZSwgaWYgaXQgZXhpc3RzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBpc0Jzb25UeXBlKG9iaiwgdHlwZW5hbWUpIHtcbiAgcmV0dXJuIChcbiAgICB0eXBlb2Ygb2JqID09PSAnb2JqZWN0JyAmJlxuICAgIG9iaiAhPT0gbnVsbCAmJlxuICAgIG9iai5fYnNvbnR5cGUgPT09IHR5cGVuYW1lXG4gICk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNCc29uVHlwZTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../server/node_modules/mongoose/lib/helpers/isBsonType.js\n");

/***/ }),

/***/ "../server/node_modules/mongoose/lib/helpers/isMongooseObject.js":
/*!***********************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/helpers/isMongooseObject.js ***!
  \***********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst isMongooseArray = (__webpack_require__(/*! ../types/array/isMongooseArray */ \"../server/node_modules/mongoose/lib/types/array/isMongooseArray.js\").isMongooseArray);\n/**\n * Returns if `v` is a mongoose object that has a `toObject()` method we can use.\n *\n * This is for compatibility with libs like Date.js which do foolish things to Natives.\n *\n * @param {Any} v\n * @api private\n */\n\nmodule.exports = function(v) {\n  return (\n    v != null && (\n      isMongooseArray(v) || // Array or Document Array\n      v.$__ != null || // Document\n      v.isMongooseBuffer || // Buffer\n      v.$isMongooseMap // Map\n    )\n  );\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9pc01vbmdvb3NlT2JqZWN0LmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLHdCQUF3QixpSkFBeUQ7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2xpZW50Ly4uL3NlcnZlci9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvaXNNb25nb29zZU9iamVjdC5qcz8yNDA2Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3QgaXNNb25nb29zZUFycmF5ID0gcmVxdWlyZSgnLi4vdHlwZXMvYXJyYXkvaXNNb25nb29zZUFycmF5JykuaXNNb25nb29zZUFycmF5O1xuLyoqXG4gKiBSZXR1cm5zIGlmIGB2YCBpcyBhIG1vbmdvb3NlIG9iamVjdCB0aGF0IGhhcyBhIGB0b09iamVjdCgpYCBtZXRob2Qgd2UgY2FuIHVzZS5cbiAqXG4gKiBUaGlzIGlzIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbGlicyBsaWtlIERhdGUuanMgd2hpY2ggZG8gZm9vbGlzaCB0aGluZ3MgdG8gTmF0aXZlcy5cbiAqXG4gKiBAcGFyYW0ge0FueX0gdlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbih2KSB7XG4gIHJldHVybiAoXG4gICAgdiAhPSBudWxsICYmIChcbiAgICAgIGlzTW9uZ29vc2VBcnJheSh2KSB8fCAvLyBBcnJheSBvciBEb2N1bWVudCBBcnJheVxuICAgICAgdi4kX18gIT0gbnVsbCB8fCAvLyBEb2N1bWVudFxuICAgICAgdi5pc01vbmdvb3NlQnVmZmVyIHx8IC8vIEJ1ZmZlclxuICAgICAgdi4kaXNNb25nb29zZU1hcCAvLyBNYXBcbiAgICApXG4gICk7XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../server/node_modules/mongoose/lib/helpers/isMongooseObject.js\n");

/***/ }),

/***/ "../server/node_modules/mongoose/lib/helpers/isObject.js":
/*!***************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/helpers/isObject.js ***!
  \***************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/**\n * Determines if `arg` is an object.\n *\n * @param {Object|Array|String|Function|RegExp|any} arg\n * @api private\n * @return {Boolean}\n */\n\nmodule.exports = function(arg) {\n  return (\n    Buffer.isBuffer(arg) ||\n    Object.prototype.toString.call(arg) === '[object Object]'\n  );\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9pc09iamVjdC5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQSxXQUFXLHlDQUF5QztBQUNwRDtBQUNBLFlBQVk7QUFDWjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbGllbnQvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9pc09iamVjdC5qcz9mOTNjIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBEZXRlcm1pbmVzIGlmIGBhcmdgIGlzIGFuIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdHxBcnJheXxTdHJpbmd8RnVuY3Rpb258UmVnRXhwfGFueX0gYXJnXG4gKiBAYXBpIHByaXZhdGVcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihhcmcpIHtcbiAgcmV0dXJuIChcbiAgICBCdWZmZXIuaXNCdWZmZXIoYXJnKSB8fFxuICAgIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChhcmcpID09PSAnW29iamVjdCBPYmplY3RdJ1xuICApO1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../server/node_modules/mongoose/lib/helpers/isObject.js\n");

/***/ }),

/***/ "../server/node_modules/mongoose/lib/helpers/isPOJO.js":
/*!*************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/helpers/isPOJO.js ***!
  \*************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nmodule.exports = function isPOJO(arg) {\n  if (arg == null || typeof arg !== 'object') {\n    return false;\n  }\n  const proto = Object.getPrototypeOf(arg);\n  // Prototype may be null if you used `Object.create(null)`\n  // Checking `proto`'s constructor is safe because `getPrototypeOf()`\n  // explicitly crosses the boundary from object data to object metadata\n  return !proto || proto.constructor.name === 'Object';\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9pc1BPSk8uanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbGllbnQvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9pc1BPSk8uanM/MzZkMiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNQT0pPKGFyZykge1xuICBpZiAoYXJnID09IG51bGwgfHwgdHlwZW9mIGFyZyAhPT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3QgcHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YoYXJnKTtcbiAgLy8gUHJvdG90eXBlIG1heSBiZSBudWxsIGlmIHlvdSB1c2VkIGBPYmplY3QuY3JlYXRlKG51bGwpYFxuICAvLyBDaGVja2luZyBgcHJvdG9gJ3MgY29uc3RydWN0b3IgaXMgc2FmZSBiZWNhdXNlIGBnZXRQcm90b3R5cGVPZigpYFxuICAvLyBleHBsaWNpdGx5IGNyb3NzZXMgdGhlIGJvdW5kYXJ5IGZyb20gb2JqZWN0IGRhdGEgdG8gb2JqZWN0IG1ldGFkYXRhXG4gIHJldHVybiAhcHJvdG8gfHwgcHJvdG8uY29uc3RydWN0b3IubmFtZSA9PT0gJ09iamVjdCc7XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../server/node_modules/mongoose/lib/helpers/isPOJO.js\n");

/***/ }),

/***/ "../server/node_modules/mongoose/lib/helpers/isPromise.js":
/*!****************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/helpers/isPromise.js ***!
  \****************************************************************/
/***/ ((module) => {

"use strict";
eval("\nfunction isPromise(val) {\n  return !!val && (typeof val === 'object' || typeof val === 'function') && typeof val.then === 'function';\n}\n\nmodule.exports = isPromise;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9pc1Byb21pc2UuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbGllbnQvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9pc1Byb21pc2UuanM/NTg1MyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5mdW5jdGlvbiBpc1Byb21pc2UodmFsKSB7XG4gIHJldHVybiAhIXZhbCAmJiAodHlwZW9mIHZhbCA9PT0gJ29iamVjdCcgfHwgdHlwZW9mIHZhbCA9PT0gJ2Z1bmN0aW9uJykgJiYgdHlwZW9mIHZhbC50aGVuID09PSAnZnVuY3Rpb24nO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzUHJvbWlzZTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../server/node_modules/mongoose/lib/helpers/isPromise.js\n");

/***/ }),

/***/ "../server/node_modules/mongoose/lib/helpers/isSimpleValidator.js":
/*!************************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/helpers/isSimpleValidator.js ***!
  \************************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/**\n * Determines if `arg` is a flat object.\n *\n * @param {Object|Array|String|Function|RegExp|any} arg\n * @api private\n * @return {Boolean}\n */\n\nmodule.exports = function isSimpleValidator(obj) {\n  const keys = Object.keys(obj);\n  let result = true;\n  for (let i = 0, len = keys.length; i < len; ++i) {\n    if (typeof obj[keys[i]] === 'object' && obj[keys[i]] !== null) {\n      result = false;\n      break;\n    }\n  }\n\n  return result;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9pc1NpbXBsZVZhbGlkYXRvci5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQSxXQUFXLHlDQUF5QztBQUNwRDtBQUNBLFlBQVk7QUFDWjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsU0FBUztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbGllbnQvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9pc1NpbXBsZVZhbGlkYXRvci5qcz83MTdjIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBEZXRlcm1pbmVzIGlmIGBhcmdgIGlzIGEgZmxhdCBvYmplY3QuXG4gKlxuICogQHBhcmFtIHtPYmplY3R8QXJyYXl8U3RyaW5nfEZ1bmN0aW9ufFJlZ0V4cHxhbnl9IGFyZ1xuICogQGFwaSBwcml2YXRlXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNTaW1wbGVWYWxpZGF0b3Iob2JqKSB7XG4gIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhvYmopO1xuICBsZXQgcmVzdWx0ID0gdHJ1ZTtcbiAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IGtleXMubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICBpZiAodHlwZW9mIG9ialtrZXlzW2ldXSA9PT0gJ29iamVjdCcgJiYgb2JqW2tleXNbaV1dICE9PSBudWxsKSB7XG4gICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../server/node_modules/mongoose/lib/helpers/isSimpleValidator.js\n");

/***/ }),

/***/ "../server/node_modules/mongoose/lib/helpers/minimize.js":
/*!***************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/helpers/minimize.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst { isPOJO } = __webpack_require__(/*! ../utils */ \"../server/node_modules/mongoose/lib/utils.js\");\n\nmodule.exports = minimize;\n\n/**\n * Minimizes an object, removing undefined values and empty objects\n *\n * @param {Object} object to minimize\n * @return {Object|undefined}\n * @api private\n */\n\nfunction minimize(obj) {\n  const keys = Object.keys(obj);\n  let i = keys.length;\n  let hasKeys;\n  let key;\n  let val;\n\n  while (i--) {\n    key = keys[i];\n    val = obj[key];\n\n    if (isPOJO(val)) {\n      obj[key] = minimize(val);\n    }\n\n    if (undefined === obj[key]) {\n      delete obj[key];\n      continue;\n    }\n\n    hasKeys = true;\n  }\n\n  return hasKeys\n    ? obj\n    : undefined;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9taW5pbWl6ZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixRQUFRLFNBQVMsRUFBRSxtQkFBTyxDQUFDLDhEQUFVOztBQUVyQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2NsaWVudC8uLi9zZXJ2ZXIvbm9kZV9tb2R1bGVzL21vbmdvb3NlL2xpYi9oZWxwZXJzL21pbmltaXplLmpzPzUyMmYiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCB7IGlzUE9KTyB9ID0gcmVxdWlyZSgnLi4vdXRpbHMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBtaW5pbWl6ZTtcblxuLyoqXG4gKiBNaW5pbWl6ZXMgYW4gb2JqZWN0LCByZW1vdmluZyB1bmRlZmluZWQgdmFsdWVzIGFuZCBlbXB0eSBvYmplY3RzXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCB0byBtaW5pbWl6ZVxuICogQHJldHVybiB7T2JqZWN0fHVuZGVmaW5lZH1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIG1pbmltaXplKG9iaikge1xuICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMob2JqKTtcbiAgbGV0IGkgPSBrZXlzLmxlbmd0aDtcbiAgbGV0IGhhc0tleXM7XG4gIGxldCBrZXk7XG4gIGxldCB2YWw7XG5cbiAgd2hpbGUgKGktLSkge1xuICAgIGtleSA9IGtleXNbaV07XG4gICAgdmFsID0gb2JqW2tleV07XG5cbiAgICBpZiAoaXNQT0pPKHZhbCkpIHtcbiAgICAgIG9ialtrZXldID0gbWluaW1pemUodmFsKTtcbiAgICB9XG5cbiAgICBpZiAodW5kZWZpbmVkID09PSBvYmpba2V5XSkge1xuICAgICAgZGVsZXRlIG9ialtrZXldO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaGFzS2V5cyA9IHRydWU7XG4gIH1cblxuICByZXR1cm4gaGFzS2V5c1xuICAgID8gb2JqXG4gICAgOiB1bmRlZmluZWQ7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../server/node_modules/mongoose/lib/helpers/minimize.js\n");

/***/ }),

/***/ "../server/node_modules/mongoose/lib/helpers/model/applyDefaultsToPOJO.js":
/*!********************************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/helpers/model/applyDefaultsToPOJO.js ***!
  \********************************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nmodule.exports = function applyDefaultsToPOJO(doc, schema) {\n  const paths = Object.keys(schema.paths);\n  const plen = paths.length;\n\n  for (let i = 0; i < plen; ++i) {\n    let curPath = '';\n    const p = paths[i];\n\n    const type = schema.paths[p];\n    const path = type.splitPath();\n    const len = path.length;\n    let doc_ = doc;\n    for (let j = 0; j < len; ++j) {\n      if (doc_ == null) {\n        break;\n      }\n\n      const piece = path[j];\n      curPath += (!curPath.length ? '' : '.') + piece;\n\n      if (j === len - 1) {\n        if (typeof doc_[piece] !== 'undefined') {\n          if (type.$isSingleNested) {\n            applyDefaultsToPOJO(doc_[piece], type.caster.schema);\n          } else if (type.$isMongooseDocumentArray && Array.isArray(doc_[piece])) {\n            doc_[piece].forEach(el => applyDefaultsToPOJO(el, type.schema));\n          }\n\n          break;\n        }\n\n        const def = type.getDefault(doc, false, { skipCast: true });\n        if (typeof def !== 'undefined') {\n          doc_[piece] = def;\n\n          if (type.$isSingleNested) {\n            applyDefaultsToPOJO(def, type.caster.schema);\n          } else if (type.$isMongooseDocumentArray && Array.isArray(def)) {\n            def.forEach(el => applyDefaultsToPOJO(el, type.schema));\n          }\n        }\n      } else {\n        if (doc_[piece] == null) {\n          doc_[piece] = {};\n        }\n        doc_ = doc_[piece];\n      }\n    }\n  }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9tb2RlbC9hcHBseURlZmF1bHRzVG9QT0pPLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0IsVUFBVTtBQUM1QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGtEQUFrRCxnQkFBZ0I7QUFDbEU7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2xpZW50Ly4uL3NlcnZlci9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvbW9kZWwvYXBwbHlEZWZhdWx0c1RvUE9KTy5qcz9jOTkxIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBhcHBseURlZmF1bHRzVG9QT0pPKGRvYywgc2NoZW1hKSB7XG4gIGNvbnN0IHBhdGhzID0gT2JqZWN0LmtleXMoc2NoZW1hLnBhdGhzKTtcbiAgY29uc3QgcGxlbiA9IHBhdGhzLmxlbmd0aDtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IHBsZW47ICsraSkge1xuICAgIGxldCBjdXJQYXRoID0gJyc7XG4gICAgY29uc3QgcCA9IHBhdGhzW2ldO1xuXG4gICAgY29uc3QgdHlwZSA9IHNjaGVtYS5wYXRoc1twXTtcbiAgICBjb25zdCBwYXRoID0gdHlwZS5zcGxpdFBhdGgoKTtcbiAgICBjb25zdCBsZW4gPSBwYXRoLmxlbmd0aDtcbiAgICBsZXQgZG9jXyA9IGRvYztcbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IGxlbjsgKytqKSB7XG4gICAgICBpZiAoZG9jXyA9PSBudWxsKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBwaWVjZSA9IHBhdGhbal07XG4gICAgICBjdXJQYXRoICs9ICghY3VyUGF0aC5sZW5ndGggPyAnJyA6ICcuJykgKyBwaWVjZTtcblxuICAgICAgaWYgKGogPT09IGxlbiAtIDEpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBkb2NfW3BpZWNlXSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICBpZiAodHlwZS4kaXNTaW5nbGVOZXN0ZWQpIHtcbiAgICAgICAgICAgIGFwcGx5RGVmYXVsdHNUb1BPSk8oZG9jX1twaWVjZV0sIHR5cGUuY2FzdGVyLnNjaGVtYSk7XG4gICAgICAgICAgfSBlbHNlIGlmICh0eXBlLiRpc01vbmdvb3NlRG9jdW1lbnRBcnJheSAmJiBBcnJheS5pc0FycmF5KGRvY19bcGllY2VdKSkge1xuICAgICAgICAgICAgZG9jX1twaWVjZV0uZm9yRWFjaChlbCA9PiBhcHBseURlZmF1bHRzVG9QT0pPKGVsLCB0eXBlLnNjaGVtYSkpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgZGVmID0gdHlwZS5nZXREZWZhdWx0KGRvYywgZmFsc2UsIHsgc2tpcENhc3Q6IHRydWUgfSk7XG4gICAgICAgIGlmICh0eXBlb2YgZGVmICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIGRvY19bcGllY2VdID0gZGVmO1xuXG4gICAgICAgICAgaWYgKHR5cGUuJGlzU2luZ2xlTmVzdGVkKSB7XG4gICAgICAgICAgICBhcHBseURlZmF1bHRzVG9QT0pPKGRlZiwgdHlwZS5jYXN0ZXIuc2NoZW1hKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHR5cGUuJGlzTW9uZ29vc2VEb2N1bWVudEFycmF5ICYmIEFycmF5LmlzQXJyYXkoZGVmKSkge1xuICAgICAgICAgICAgZGVmLmZvckVhY2goZWwgPT4gYXBwbHlEZWZhdWx0c1RvUE9KTyhlbCwgdHlwZS5zY2hlbWEpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChkb2NfW3BpZWNlXSA9PSBudWxsKSB7XG4gICAgICAgICAgZG9jX1twaWVjZV0gPSB7fTtcbiAgICAgICAgfVxuICAgICAgICBkb2NfID0gZG9jX1twaWVjZV07XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../server/node_modules/mongoose/lib/helpers/model/applyDefaultsToPOJO.js\n");

/***/ }),

/***/ "../server/node_modules/mongoose/lib/helpers/model/applyHooks.js":
/*!***********************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/helpers/model/applyHooks.js ***!
  \***********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst symbols = __webpack_require__(/*! ../../schema/symbols */ \"../server/node_modules/mongoose/lib/schema/symbols.js\");\nconst promiseOrCallback = __webpack_require__(/*! ../promiseOrCallback */ \"../server/node_modules/mongoose/lib/helpers/promiseOrCallback.js\");\n\n/*!\n * ignore\n */\n\nmodule.exports = applyHooks;\n\n/*!\n * ignore\n */\n\napplyHooks.middlewareFunctions = [\n  'deleteOne',\n  'save',\n  'validate',\n  'remove',\n  'updateOne',\n  'init'\n];\n\n/*!\n * ignore\n */\n\nconst alreadyHookedFunctions = new Set(applyHooks.middlewareFunctions.flatMap(fn => ([fn, `$__${fn}`])));\n\n/**\n * Register hooks for this model\n *\n * @param {Model} model\n * @param {Schema} schema\n * @param {Object} options\n * @api private\n */\n\nfunction applyHooks(model, schema, options) {\n  options = options || {};\n\n  const kareemOptions = {\n    useErrorHandlers: true,\n    numCallbackParams: 1,\n    nullResultByDefault: true,\n    contextParameter: true\n  };\n  const objToDecorate = options.decorateDoc ? model : model.prototype;\n\n  model.$appliedHooks = true;\n  for (const key of Object.keys(schema.paths)) {\n    const type = schema.paths[key];\n    let childModel = null;\n    if (type.$isSingleNested) {\n      childModel = type.caster;\n    } else if (type.$isMongooseDocumentArray) {\n      childModel = type.Constructor;\n    } else {\n      continue;\n    }\n\n    if (childModel.$appliedHooks) {\n      continue;\n    }\n\n    applyHooks(childModel, type.schema, { ...options, isChildSchema: true });\n    if (childModel.discriminators != null) {\n      const keys = Object.keys(childModel.discriminators);\n      for (const key of keys) {\n        applyHooks(childModel.discriminators[key],\n          childModel.discriminators[key].schema, options);\n      }\n    }\n  }\n\n  // Built-in hooks rely on hooking internal functions in order to support\n  // promises and make it so that `doc.save.toString()` provides meaningful\n  // information.\n\n  const middleware = schema.s.hooks.\n    filter(hook => {\n      if (hook.name === 'updateOne' || hook.name === 'deleteOne') {\n        return !!hook['document'];\n      }\n      if (hook.name === 'remove' || hook.name === 'init') {\n        return hook['document'] == null || !!hook['document'];\n      }\n      if (hook.query != null || hook.document != null) {\n        return hook.document !== false;\n      }\n      return true;\n    }).\n    filter(hook => {\n      // If user has overwritten the method, don't apply built-in middleware\n      if (schema.methods[hook.name]) {\n        return !hook.fn[symbols.builtInMiddleware];\n      }\n\n      return true;\n    });\n\n  model._middleware = middleware;\n\n  objToDecorate.$__originalValidate = objToDecorate.$__originalValidate || objToDecorate.$__validate;\n\n  const internalMethodsToWrap = options && options.isChildSchema ? ['save', 'validate', 'deleteOne'] : ['save', 'validate'];\n  for (const method of internalMethodsToWrap) {\n    const toWrap = method === 'validate' ? '$__originalValidate' : `$__${method}`;\n    const wrapped = middleware.\n      createWrapper(method, objToDecorate[toWrap], null, kareemOptions);\n    objToDecorate[`$__${method}`] = wrapped;\n  }\n  objToDecorate.$__init = middleware.\n    createWrapperSync('init', objToDecorate.$__init, null, kareemOptions);\n\n  // Support hooks for custom methods\n  const customMethods = Object.keys(schema.methods);\n  const customMethodOptions = Object.assign({}, kareemOptions, {\n    // Only use `checkForPromise` for custom methods, because mongoose\n    // query thunks are not as consistent as I would like about returning\n    // a nullish value rather than the query. If a query thunk returns\n    // a query, `checkForPromise` causes infinite recursion\n    checkForPromise: true\n  });\n  for (const method of customMethods) {\n    if (alreadyHookedFunctions.has(method)) {\n      continue;\n    }\n    if (!middleware.hasHooks(method)) {\n      // Don't wrap if there are no hooks for the custom method to avoid\n      // surprises. Also, `createWrapper()` enforces consistent async,\n      // so wrapping a sync method would break it.\n      continue;\n    }\n    const originalMethod = objToDecorate[method];\n    objToDecorate[method] = function() {\n      const args = Array.prototype.slice.call(arguments);\n      const cb = args.slice(-1).pop();\n      const argsWithoutCallback = typeof cb === 'function' ?\n        args.slice(0, args.length - 1) : args;\n      return promiseOrCallback(cb, callback => {\n        return this[`$__${method}`].apply(this,\n          argsWithoutCallback.concat([callback]));\n      }, model.events);\n    };\n    objToDecorate[`$__${method}`] = middleware.\n      createWrapper(method, originalMethod, null, customMethodOptions);\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9tb2RlbC9hcHBseUhvb2tzLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLGdCQUFnQixtQkFBTyxDQUFDLG1GQUFzQjtBQUM5QywwQkFBMEIsbUJBQU8sQ0FBQyw4RkFBc0I7O0FBRXhEO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsZ0dBQWdHLEdBQUc7O0FBRW5HO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsMENBQTBDLGlDQUFpQztBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLHlFQUF5RSxPQUFPO0FBQ2hGO0FBQ0E7QUFDQSx3QkFBd0IsT0FBTztBQUMvQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDhDQUE4QztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsT0FBTztBQUNqQztBQUNBLE9BQU87QUFDUDtBQUNBLHdCQUF3QixPQUFPO0FBQy9CO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2NsaWVudC8uLi9zZXJ2ZXIvbm9kZV9tb2R1bGVzL21vbmdvb3NlL2xpYi9oZWxwZXJzL21vZGVsL2FwcGx5SG9va3MuanM/YTg2MSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IHN5bWJvbHMgPSByZXF1aXJlKCcuLi8uLi9zY2hlbWEvc3ltYm9scycpO1xuY29uc3QgcHJvbWlzZU9yQ2FsbGJhY2sgPSByZXF1aXJlKCcuLi9wcm9taXNlT3JDYWxsYmFjaycpO1xuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gYXBwbHlIb29rcztcblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5hcHBseUhvb2tzLm1pZGRsZXdhcmVGdW5jdGlvbnMgPSBbXG4gICdkZWxldGVPbmUnLFxuICAnc2F2ZScsXG4gICd2YWxpZGF0ZScsXG4gICdyZW1vdmUnLFxuICAndXBkYXRlT25lJyxcbiAgJ2luaXQnXG5dO1xuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cbmNvbnN0IGFscmVhZHlIb29rZWRGdW5jdGlvbnMgPSBuZXcgU2V0KGFwcGx5SG9va3MubWlkZGxld2FyZUZ1bmN0aW9ucy5mbGF0TWFwKGZuID0+IChbZm4sIGAkX18ke2ZufWBdKSkpO1xuXG4vKipcbiAqIFJlZ2lzdGVyIGhvb2tzIGZvciB0aGlzIG1vZGVsXG4gKlxuICogQHBhcmFtIHtNb2RlbH0gbW9kZWxcbiAqIEBwYXJhbSB7U2NoZW1hfSBzY2hlbWFcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBhcHBseUhvb2tzKG1vZGVsLCBzY2hlbWEsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgY29uc3Qga2FyZWVtT3B0aW9ucyA9IHtcbiAgICB1c2VFcnJvckhhbmRsZXJzOiB0cnVlLFxuICAgIG51bUNhbGxiYWNrUGFyYW1zOiAxLFxuICAgIG51bGxSZXN1bHRCeURlZmF1bHQ6IHRydWUsXG4gICAgY29udGV4dFBhcmFtZXRlcjogdHJ1ZVxuICB9O1xuICBjb25zdCBvYmpUb0RlY29yYXRlID0gb3B0aW9ucy5kZWNvcmF0ZURvYyA/IG1vZGVsIDogbW9kZWwucHJvdG90eXBlO1xuXG4gIG1vZGVsLiRhcHBsaWVkSG9va3MgPSB0cnVlO1xuICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhzY2hlbWEucGF0aHMpKSB7XG4gICAgY29uc3QgdHlwZSA9IHNjaGVtYS5wYXRoc1trZXldO1xuICAgIGxldCBjaGlsZE1vZGVsID0gbnVsbDtcbiAgICBpZiAodHlwZS4kaXNTaW5nbGVOZXN0ZWQpIHtcbiAgICAgIGNoaWxkTW9kZWwgPSB0eXBlLmNhc3RlcjtcbiAgICB9IGVsc2UgaWYgKHR5cGUuJGlzTW9uZ29vc2VEb2N1bWVudEFycmF5KSB7XG4gICAgICBjaGlsZE1vZGVsID0gdHlwZS5Db25zdHJ1Y3RvcjtcbiAgICB9IGVsc2Uge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKGNoaWxkTW9kZWwuJGFwcGxpZWRIb29rcykge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgYXBwbHlIb29rcyhjaGlsZE1vZGVsLCB0eXBlLnNjaGVtYSwgeyAuLi5vcHRpb25zLCBpc0NoaWxkU2NoZW1hOiB0cnVlIH0pO1xuICAgIGlmIChjaGlsZE1vZGVsLmRpc2NyaW1pbmF0b3JzICE9IG51bGwpIHtcbiAgICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhjaGlsZE1vZGVsLmRpc2NyaW1pbmF0b3JzKTtcbiAgICAgIGZvciAoY29uc3Qga2V5IG9mIGtleXMpIHtcbiAgICAgICAgYXBwbHlIb29rcyhjaGlsZE1vZGVsLmRpc2NyaW1pbmF0b3JzW2tleV0sXG4gICAgICAgICAgY2hpbGRNb2RlbC5kaXNjcmltaW5hdG9yc1trZXldLnNjaGVtYSwgb3B0aW9ucyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gQnVpbHQtaW4gaG9va3MgcmVseSBvbiBob29raW5nIGludGVybmFsIGZ1bmN0aW9ucyBpbiBvcmRlciB0byBzdXBwb3J0XG4gIC8vIHByb21pc2VzIGFuZCBtYWtlIGl0IHNvIHRoYXQgYGRvYy5zYXZlLnRvU3RyaW5nKClgIHByb3ZpZGVzIG1lYW5pbmdmdWxcbiAgLy8gaW5mb3JtYXRpb24uXG5cbiAgY29uc3QgbWlkZGxld2FyZSA9IHNjaGVtYS5zLmhvb2tzLlxuICAgIGZpbHRlcihob29rID0+IHtcbiAgICAgIGlmIChob29rLm5hbWUgPT09ICd1cGRhdGVPbmUnIHx8IGhvb2submFtZSA9PT0gJ2RlbGV0ZU9uZScpIHtcbiAgICAgICAgcmV0dXJuICEhaG9va1snZG9jdW1lbnQnXTtcbiAgICAgIH1cbiAgICAgIGlmIChob29rLm5hbWUgPT09ICdyZW1vdmUnIHx8IGhvb2submFtZSA9PT0gJ2luaXQnKSB7XG4gICAgICAgIHJldHVybiBob29rWydkb2N1bWVudCddID09IG51bGwgfHwgISFob29rWydkb2N1bWVudCddO1xuICAgICAgfVxuICAgICAgaWYgKGhvb2sucXVlcnkgIT0gbnVsbCB8fCBob29rLmRvY3VtZW50ICE9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGhvb2suZG9jdW1lbnQgIT09IGZhbHNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSkuXG4gICAgZmlsdGVyKGhvb2sgPT4ge1xuICAgICAgLy8gSWYgdXNlciBoYXMgb3ZlcndyaXR0ZW4gdGhlIG1ldGhvZCwgZG9uJ3QgYXBwbHkgYnVpbHQtaW4gbWlkZGxld2FyZVxuICAgICAgaWYgKHNjaGVtYS5tZXRob2RzW2hvb2submFtZV0pIHtcbiAgICAgICAgcmV0dXJuICFob29rLmZuW3N5bWJvbHMuYnVpbHRJbk1pZGRsZXdhcmVdO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9KTtcblxuICBtb2RlbC5fbWlkZGxld2FyZSA9IG1pZGRsZXdhcmU7XG5cbiAgb2JqVG9EZWNvcmF0ZS4kX19vcmlnaW5hbFZhbGlkYXRlID0gb2JqVG9EZWNvcmF0ZS4kX19vcmlnaW5hbFZhbGlkYXRlIHx8IG9ialRvRGVjb3JhdGUuJF9fdmFsaWRhdGU7XG5cbiAgY29uc3QgaW50ZXJuYWxNZXRob2RzVG9XcmFwID0gb3B0aW9ucyAmJiBvcHRpb25zLmlzQ2hpbGRTY2hlbWEgPyBbJ3NhdmUnLCAndmFsaWRhdGUnLCAnZGVsZXRlT25lJ10gOiBbJ3NhdmUnLCAndmFsaWRhdGUnXTtcbiAgZm9yIChjb25zdCBtZXRob2Qgb2YgaW50ZXJuYWxNZXRob2RzVG9XcmFwKSB7XG4gICAgY29uc3QgdG9XcmFwID0gbWV0aG9kID09PSAndmFsaWRhdGUnID8gJyRfX29yaWdpbmFsVmFsaWRhdGUnIDogYCRfXyR7bWV0aG9kfWA7XG4gICAgY29uc3Qgd3JhcHBlZCA9IG1pZGRsZXdhcmUuXG4gICAgICBjcmVhdGVXcmFwcGVyKG1ldGhvZCwgb2JqVG9EZWNvcmF0ZVt0b1dyYXBdLCBudWxsLCBrYXJlZW1PcHRpb25zKTtcbiAgICBvYmpUb0RlY29yYXRlW2AkX18ke21ldGhvZH1gXSA9IHdyYXBwZWQ7XG4gIH1cbiAgb2JqVG9EZWNvcmF0ZS4kX19pbml0ID0gbWlkZGxld2FyZS5cbiAgICBjcmVhdGVXcmFwcGVyU3luYygnaW5pdCcsIG9ialRvRGVjb3JhdGUuJF9faW5pdCwgbnVsbCwga2FyZWVtT3B0aW9ucyk7XG5cbiAgLy8gU3VwcG9ydCBob29rcyBmb3IgY3VzdG9tIG1ldGhvZHNcbiAgY29uc3QgY3VzdG9tTWV0aG9kcyA9IE9iamVjdC5rZXlzKHNjaGVtYS5tZXRob2RzKTtcbiAgY29uc3QgY3VzdG9tTWV0aG9kT3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIGthcmVlbU9wdGlvbnMsIHtcbiAgICAvLyBPbmx5IHVzZSBgY2hlY2tGb3JQcm9taXNlYCBmb3IgY3VzdG9tIG1ldGhvZHMsIGJlY2F1c2UgbW9uZ29vc2VcbiAgICAvLyBxdWVyeSB0aHVua3MgYXJlIG5vdCBhcyBjb25zaXN0ZW50IGFzIEkgd291bGQgbGlrZSBhYm91dCByZXR1cm5pbmdcbiAgICAvLyBhIG51bGxpc2ggdmFsdWUgcmF0aGVyIHRoYW4gdGhlIHF1ZXJ5LiBJZiBhIHF1ZXJ5IHRodW5rIHJldHVybnNcbiAgICAvLyBhIHF1ZXJ5LCBgY2hlY2tGb3JQcm9taXNlYCBjYXVzZXMgaW5maW5pdGUgcmVjdXJzaW9uXG4gICAgY2hlY2tGb3JQcm9taXNlOiB0cnVlXG4gIH0pO1xuICBmb3IgKGNvbnN0IG1ldGhvZCBvZiBjdXN0b21NZXRob2RzKSB7XG4gICAgaWYgKGFscmVhZHlIb29rZWRGdW5jdGlvbnMuaGFzKG1ldGhvZCkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAoIW1pZGRsZXdhcmUuaGFzSG9va3MobWV0aG9kKSkge1xuICAgICAgLy8gRG9uJ3Qgd3JhcCBpZiB0aGVyZSBhcmUgbm8gaG9va3MgZm9yIHRoZSBjdXN0b20gbWV0aG9kIHRvIGF2b2lkXG4gICAgICAvLyBzdXJwcmlzZXMuIEFsc28sIGBjcmVhdGVXcmFwcGVyKClgIGVuZm9yY2VzIGNvbnNpc3RlbnQgYXN5bmMsXG4gICAgICAvLyBzbyB3cmFwcGluZyBhIHN5bmMgbWV0aG9kIHdvdWxkIGJyZWFrIGl0LlxuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGNvbnN0IG9yaWdpbmFsTWV0aG9kID0gb2JqVG9EZWNvcmF0ZVttZXRob2RdO1xuICAgIG9ialRvRGVjb3JhdGVbbWV0aG9kXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgY29uc3QgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgICBjb25zdCBjYiA9IGFyZ3Muc2xpY2UoLTEpLnBvcCgpO1xuICAgICAgY29uc3QgYXJnc1dpdGhvdXRDYWxsYmFjayA9IHR5cGVvZiBjYiA9PT0gJ2Z1bmN0aW9uJyA/XG4gICAgICAgIGFyZ3Muc2xpY2UoMCwgYXJncy5sZW5ndGggLSAxKSA6IGFyZ3M7XG4gICAgICByZXR1cm4gcHJvbWlzZU9yQ2FsbGJhY2soY2IsIGNhbGxiYWNrID0+IHtcbiAgICAgICAgcmV0dXJuIHRoaXNbYCRfXyR7bWV0aG9kfWBdLmFwcGx5KHRoaXMsXG4gICAgICAgICAgYXJnc1dpdGhvdXRDYWxsYmFjay5jb25jYXQoW2NhbGxiYWNrXSkpO1xuICAgICAgfSwgbW9kZWwuZXZlbnRzKTtcbiAgICB9O1xuICAgIG9ialRvRGVjb3JhdGVbYCRfXyR7bWV0aG9kfWBdID0gbWlkZGxld2FyZS5cbiAgICAgIGNyZWF0ZVdyYXBwZXIobWV0aG9kLCBvcmlnaW5hbE1ldGhvZCwgbnVsbCwgY3VzdG9tTWV0aG9kT3B0aW9ucyk7XG4gIH1cbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../server/node_modules/mongoose/lib/helpers/model/applyHooks.js\n");

/***/ }),

/***/ "../server/node_modules/mongoose/lib/helpers/model/applyMethods.js":
/*!*************************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/helpers/model/applyMethods.js ***!
  \*************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst get = __webpack_require__(/*! ../get */ \"../server/node_modules/mongoose/lib/helpers/get.js\");\nconst utils = __webpack_require__(/*! ../../utils */ \"../server/node_modules/mongoose/lib/utils.js\");\n\n/**\n * Register methods for this model\n *\n * @param {Model} model\n * @param {Schema} schema\n * @api private\n */\n\nmodule.exports = function applyMethods(model, schema) {\n  const Model = __webpack_require__(/*! ../../model */ \"../server/node_modules/mongoose/lib/model.js\");\n\n  function apply(method, schema) {\n    Object.defineProperty(model.prototype, method, {\n      get: function() {\n        const h = {};\n        for (const k in schema.methods[method]) {\n          h[k] = schema.methods[method][k].bind(this);\n        }\n        return h;\n      },\n      configurable: true\n    });\n  }\n  for (const method of Object.keys(schema.methods)) {\n    const fn = schema.methods[method];\n    if (schema.tree.hasOwnProperty(method)) {\n      throw new Error('You have a method and a property in your schema both ' +\n        'named \"' + method + '\"');\n    }\n\n    // Avoid making custom methods if user sets a method to itself, e.g.\n    // `schema.method(save, Document.prototype.save)`. Can happen when\n    // calling `loadClass()` with a class that `extends Document`. See gh-12254\n    if (typeof fn === 'function' &&\n        Model.prototype[method] === fn) {\n      delete schema.methods[method];\n      continue;\n    }\n\n    if (schema.reserved[method] &&\n        !get(schema, `methodOptions.${method}.suppressWarning`, false)) {\n      utils.warn(`mongoose: the method name \"${method}\" is used by mongoose ` +\n        'internally, overwriting it may cause bugs. If you\\'re sure you know ' +\n        'what you\\'re doing, you can suppress this error by using ' +\n        `\\`schema.method('${method}', fn, { suppressWarning: true })\\`.`);\n    }\n    if (typeof fn === 'function') {\n      model.prototype[method] = fn;\n    } else {\n      apply(method, schema);\n    }\n  }\n\n  // Recursively call `applyMethods()` on child schemas\n  model.$appliedMethods = true;\n  for (const key of Object.keys(schema.paths)) {\n    const type = schema.paths[key];\n    if (type.$isSingleNested && !type.caster.$appliedMethods) {\n      applyMethods(type.caster, type.schema);\n    }\n    if (type.$isMongooseDocumentArray && !type.Constructor.$appliedMethods) {\n      applyMethods(type.Constructor, type.schema);\n    }\n  }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9tb2RlbC9hcHBseU1ldGhvZHMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsWUFBWSxtQkFBTyxDQUFDLGtFQUFRO0FBQzVCLGNBQWMsbUJBQU8sQ0FBQyxpRUFBYTs7QUFFbkM7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsUUFBUTtBQUNuQjtBQUNBOztBQUVBO0FBQ0EsZ0JBQWdCLG1CQUFPLENBQUMsaUVBQWE7O0FBRXJDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNDQUFzQyxPQUFPO0FBQzdDLCtDQUErQyxPQUFPO0FBQ3REO0FBQ0E7QUFDQSw0QkFBNEIsT0FBTyxTQUFTLHVCQUF1QjtBQUNuRTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2NsaWVudC8uLi9zZXJ2ZXIvbm9kZV9tb2R1bGVzL21vbmdvb3NlL2xpYi9oZWxwZXJzL21vZGVsL2FwcGx5TWV0aG9kcy5qcz9iZGJjIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3QgZ2V0ID0gcmVxdWlyZSgnLi4vZ2V0Jyk7XG5jb25zdCB1dGlscyA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzJyk7XG5cbi8qKlxuICogUmVnaXN0ZXIgbWV0aG9kcyBmb3IgdGhpcyBtb2RlbFxuICpcbiAqIEBwYXJhbSB7TW9kZWx9IG1vZGVsXG4gKiBAcGFyYW0ge1NjaGVtYX0gc2NoZW1hXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGFwcGx5TWV0aG9kcyhtb2RlbCwgc2NoZW1hKSB7XG4gIGNvbnN0IE1vZGVsID0gcmVxdWlyZSgnLi4vLi4vbW9kZWwnKTtcblxuICBmdW5jdGlvbiBhcHBseShtZXRob2QsIHNjaGVtYSkge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtb2RlbC5wcm90b3R5cGUsIG1ldGhvZCwge1xuICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgY29uc3QgaCA9IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IGsgaW4gc2NoZW1hLm1ldGhvZHNbbWV0aG9kXSkge1xuICAgICAgICAgIGhba10gPSBzY2hlbWEubWV0aG9kc1ttZXRob2RdW2tdLmJpbmQodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGg7XG4gICAgICB9LFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gIH1cbiAgZm9yIChjb25zdCBtZXRob2Qgb2YgT2JqZWN0LmtleXMoc2NoZW1hLm1ldGhvZHMpKSB7XG4gICAgY29uc3QgZm4gPSBzY2hlbWEubWV0aG9kc1ttZXRob2RdO1xuICAgIGlmIChzY2hlbWEudHJlZS5oYXNPd25Qcm9wZXJ0eShtZXRob2QpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1lvdSBoYXZlIGEgbWV0aG9kIGFuZCBhIHByb3BlcnR5IGluIHlvdXIgc2NoZW1hIGJvdGggJyArXG4gICAgICAgICduYW1lZCBcIicgKyBtZXRob2QgKyAnXCInKTtcbiAgICB9XG5cbiAgICAvLyBBdm9pZCBtYWtpbmcgY3VzdG9tIG1ldGhvZHMgaWYgdXNlciBzZXRzIGEgbWV0aG9kIHRvIGl0c2VsZiwgZS5nLlxuICAgIC8vIGBzY2hlbWEubWV0aG9kKHNhdmUsIERvY3VtZW50LnByb3RvdHlwZS5zYXZlKWAuIENhbiBoYXBwZW4gd2hlblxuICAgIC8vIGNhbGxpbmcgYGxvYWRDbGFzcygpYCB3aXRoIGEgY2xhc3MgdGhhdCBgZXh0ZW5kcyBEb2N1bWVudGAuIFNlZSBnaC0xMjI1NFxuICAgIGlmICh0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicgJiZcbiAgICAgICAgTW9kZWwucHJvdG90eXBlW21ldGhvZF0gPT09IGZuKSB7XG4gICAgICBkZWxldGUgc2NoZW1hLm1ldGhvZHNbbWV0aG9kXTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGlmIChzY2hlbWEucmVzZXJ2ZWRbbWV0aG9kXSAmJlxuICAgICAgICAhZ2V0KHNjaGVtYSwgYG1ldGhvZE9wdGlvbnMuJHttZXRob2R9LnN1cHByZXNzV2FybmluZ2AsIGZhbHNlKSkge1xuICAgICAgdXRpbHMud2FybihgbW9uZ29vc2U6IHRoZSBtZXRob2QgbmFtZSBcIiR7bWV0aG9kfVwiIGlzIHVzZWQgYnkgbW9uZ29vc2UgYCArXG4gICAgICAgICdpbnRlcm5hbGx5LCBvdmVyd3JpdGluZyBpdCBtYXkgY2F1c2UgYnVncy4gSWYgeW91XFwncmUgc3VyZSB5b3Uga25vdyAnICtcbiAgICAgICAgJ3doYXQgeW91XFwncmUgZG9pbmcsIHlvdSBjYW4gc3VwcHJlc3MgdGhpcyBlcnJvciBieSB1c2luZyAnICtcbiAgICAgICAgYFxcYHNjaGVtYS5tZXRob2QoJyR7bWV0aG9kfScsIGZuLCB7IHN1cHByZXNzV2FybmluZzogdHJ1ZSB9KVxcYC5gKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgbW9kZWwucHJvdG90eXBlW21ldGhvZF0gPSBmbjtcbiAgICB9IGVsc2Uge1xuICAgICAgYXBwbHkobWV0aG9kLCBzY2hlbWEpO1xuICAgIH1cbiAgfVxuXG4gIC8vIFJlY3Vyc2l2ZWx5IGNhbGwgYGFwcGx5TWV0aG9kcygpYCBvbiBjaGlsZCBzY2hlbWFzXG4gIG1vZGVsLiRhcHBsaWVkTWV0aG9kcyA9IHRydWU7XG4gIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKHNjaGVtYS5wYXRocykpIHtcbiAgICBjb25zdCB0eXBlID0gc2NoZW1hLnBhdGhzW2tleV07XG4gICAgaWYgKHR5cGUuJGlzU2luZ2xlTmVzdGVkICYmICF0eXBlLmNhc3Rlci4kYXBwbGllZE1ldGhvZHMpIHtcbiAgICAgIGFwcGx5TWV0aG9kcyh0eXBlLmNhc3RlciwgdHlwZS5zY2hlbWEpO1xuICAgIH1cbiAgICBpZiAodHlwZS4kaXNNb25nb29zZURvY3VtZW50QXJyYXkgJiYgIXR5cGUuQ29uc3RydWN0b3IuJGFwcGxpZWRNZXRob2RzKSB7XG4gICAgICBhcHBseU1ldGhvZHModHlwZS5Db25zdHJ1Y3RvciwgdHlwZS5zY2hlbWEpO1xuICAgIH1cbiAgfVxufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../server/node_modules/mongoose/lib/helpers/model/applyMethods.js\n");

/***/ }),

/***/ "../server/node_modules/mongoose/lib/helpers/model/applyStaticHooks.js":
/*!*****************************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/helpers/model/applyStaticHooks.js ***!
  \*****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst middlewareFunctions = (__webpack_require__(/*! ../../constants */ \"../server/node_modules/mongoose/lib/constants.js\").queryMiddlewareFunctions);\nconst promiseOrCallback = __webpack_require__(/*! ../promiseOrCallback */ \"../server/node_modules/mongoose/lib/helpers/promiseOrCallback.js\");\n\nmodule.exports = function applyStaticHooks(model, hooks, statics) {\n  const kareemOptions = {\n    useErrorHandlers: true,\n    numCallbackParams: 1\n  };\n\n  hooks = hooks.filter(hook => {\n    // If the custom static overwrites an existing query middleware, don't apply\n    // middleware to it by default. This avoids a potential backwards breaking\n    // change with plugins like `mongoose-delete` that use statics to overwrite\n    // built-in Mongoose functions.\n    if (middlewareFunctions.indexOf(hook.name) !== -1) {\n      return !!hook.model;\n    }\n    return hook.model !== false;\n  });\n\n  model.$__insertMany = hooks.createWrapper('insertMany',\n    model.$__insertMany, model, kareemOptions);\n\n  for (const key of Object.keys(statics)) {\n    if (hooks.hasHooks(key)) {\n      const original = model[key];\n\n      model[key] = function() {\n        const numArgs = arguments.length;\n        const lastArg = numArgs > 0 ? arguments[numArgs - 1] : null;\n        const cb = typeof lastArg === 'function' ? lastArg : null;\n        const args = Array.prototype.slice.\n          call(arguments, 0, cb == null ? numArgs : numArgs - 1);\n        // Special case: can't use `Kareem#wrap()` because it doesn't currently\n        // support wrapped functions that return a promise.\n        return promiseOrCallback(cb, callback => {\n          hooks.execPre(key, model, args, function(err) {\n            if (err != null) {\n              return callback(err);\n            }\n\n            let postCalled = 0;\n            const ret = original.apply(model, args.concat(post));\n            if (ret != null && typeof ret.then === 'function') {\n              ret.then(res => post(null, res), err => post(err));\n            }\n\n            function post(error, res) {\n              if (postCalled++ > 0) {\n                return;\n              }\n\n              if (error != null) {\n                return callback(error);\n              }\n\n              hooks.execPost(key, model, [res], function(error) {\n                if (error != null) {\n                  return callback(error);\n                }\n                callback(null, res);\n              });\n            }\n          });\n        }, model.events);\n      };\n    }\n  }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9tb2RlbC9hcHBseVN0YXRpY0hvb2tzLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLDRCQUE0Qix5SEFBbUQ7QUFDL0UsMEJBQTBCLG1CQUFPLENBQUMsOEZBQXNCOztBQUV4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbGllbnQvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9tb2RlbC9hcHBseVN0YXRpY0hvb2tzLmpzP2Q3YjgiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBtaWRkbGV3YXJlRnVuY3Rpb25zID0gcmVxdWlyZSgnLi4vLi4vY29uc3RhbnRzJykucXVlcnlNaWRkbGV3YXJlRnVuY3Rpb25zO1xuY29uc3QgcHJvbWlzZU9yQ2FsbGJhY2sgPSByZXF1aXJlKCcuLi9wcm9taXNlT3JDYWxsYmFjaycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGFwcGx5U3RhdGljSG9va3MobW9kZWwsIGhvb2tzLCBzdGF0aWNzKSB7XG4gIGNvbnN0IGthcmVlbU9wdGlvbnMgPSB7XG4gICAgdXNlRXJyb3JIYW5kbGVyczogdHJ1ZSxcbiAgICBudW1DYWxsYmFja1BhcmFtczogMVxuICB9O1xuXG4gIGhvb2tzID0gaG9va3MuZmlsdGVyKGhvb2sgPT4ge1xuICAgIC8vIElmIHRoZSBjdXN0b20gc3RhdGljIG92ZXJ3cml0ZXMgYW4gZXhpc3RpbmcgcXVlcnkgbWlkZGxld2FyZSwgZG9uJ3QgYXBwbHlcbiAgICAvLyBtaWRkbGV3YXJlIHRvIGl0IGJ5IGRlZmF1bHQuIFRoaXMgYXZvaWRzIGEgcG90ZW50aWFsIGJhY2t3YXJkcyBicmVha2luZ1xuICAgIC8vIGNoYW5nZSB3aXRoIHBsdWdpbnMgbGlrZSBgbW9uZ29vc2UtZGVsZXRlYCB0aGF0IHVzZSBzdGF0aWNzIHRvIG92ZXJ3cml0ZVxuICAgIC8vIGJ1aWx0LWluIE1vbmdvb3NlIGZ1bmN0aW9ucy5cbiAgICBpZiAobWlkZGxld2FyZUZ1bmN0aW9ucy5pbmRleE9mKGhvb2submFtZSkgIT09IC0xKSB7XG4gICAgICByZXR1cm4gISFob29rLm1vZGVsO1xuICAgIH1cbiAgICByZXR1cm4gaG9vay5tb2RlbCAhPT0gZmFsc2U7XG4gIH0pO1xuXG4gIG1vZGVsLiRfX2luc2VydE1hbnkgPSBob29rcy5jcmVhdGVXcmFwcGVyKCdpbnNlcnRNYW55JyxcbiAgICBtb2RlbC4kX19pbnNlcnRNYW55LCBtb2RlbCwga2FyZWVtT3B0aW9ucyk7XG5cbiAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMoc3RhdGljcykpIHtcbiAgICBpZiAoaG9va3MuaGFzSG9va3Moa2V5KSkge1xuICAgICAgY29uc3Qgb3JpZ2luYWwgPSBtb2RlbFtrZXldO1xuXG4gICAgICBtb2RlbFtrZXldID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGNvbnN0IG51bUFyZ3MgPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgICBjb25zdCBsYXN0QXJnID0gbnVtQXJncyA+IDAgPyBhcmd1bWVudHNbbnVtQXJncyAtIDFdIDogbnVsbDtcbiAgICAgICAgY29uc3QgY2IgPSB0eXBlb2YgbGFzdEFyZyA9PT0gJ2Z1bmN0aW9uJyA/IGxhc3RBcmcgOiBudWxsO1xuICAgICAgICBjb25zdCBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLlxuICAgICAgICAgIGNhbGwoYXJndW1lbnRzLCAwLCBjYiA9PSBudWxsID8gbnVtQXJncyA6IG51bUFyZ3MgLSAxKTtcbiAgICAgICAgLy8gU3BlY2lhbCBjYXNlOiBjYW4ndCB1c2UgYEthcmVlbSN3cmFwKClgIGJlY2F1c2UgaXQgZG9lc24ndCBjdXJyZW50bHlcbiAgICAgICAgLy8gc3VwcG9ydCB3cmFwcGVkIGZ1bmN0aW9ucyB0aGF0IHJldHVybiBhIHByb21pc2UuXG4gICAgICAgIHJldHVybiBwcm9taXNlT3JDYWxsYmFjayhjYiwgY2FsbGJhY2sgPT4ge1xuICAgICAgICAgIGhvb2tzLmV4ZWNQcmUoa2V5LCBtb2RlbCwgYXJncywgZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgICBpZiAoZXJyICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxldCBwb3N0Q2FsbGVkID0gMDtcbiAgICAgICAgICAgIGNvbnN0IHJldCA9IG9yaWdpbmFsLmFwcGx5KG1vZGVsLCBhcmdzLmNvbmNhdChwb3N0KSk7XG4gICAgICAgICAgICBpZiAocmV0ICE9IG51bGwgJiYgdHlwZW9mIHJldC50aGVuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgIHJldC50aGVuKHJlcyA9PiBwb3N0KG51bGwsIHJlcyksIGVyciA9PiBwb3N0KGVycikpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmdW5jdGlvbiBwb3N0KGVycm9yLCByZXMpIHtcbiAgICAgICAgICAgICAgaWYgKHBvc3RDYWxsZWQrKyA+IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAoZXJyb3IgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnJvcik7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBob29rcy5leGVjUG9zdChrZXksIG1vZGVsLCBbcmVzXSwgZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3IgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycm9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgcmVzKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0sIG1vZGVsLmV2ZW50cyk7XG4gICAgICB9O1xuICAgIH1cbiAgfVxufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../server/node_modules/mongoose/lib/helpers/model/applyStaticHooks.js\n");

/***/ }),

/***/ "../server/node_modules/mongoose/lib/helpers/model/applyStatics.js":
/*!*************************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/helpers/model/applyStatics.js ***!
  \*************************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/**\n * Register statics for this model\n * @param {Model} model\n * @param {Schema} schema\n * @api private\n */\nmodule.exports = function applyStatics(model, schema) {\n  for (const i in schema.statics) {\n    model[i] = schema.statics[i];\n  }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9tb2RlbC9hcHBseVN0YXRpY3MuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbGllbnQvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9tb2RlbC9hcHBseVN0YXRpY3MuanM/Y2NkZiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogUmVnaXN0ZXIgc3RhdGljcyBmb3IgdGhpcyBtb2RlbFxuICogQHBhcmFtIHtNb2RlbH0gbW9kZWxcbiAqIEBwYXJhbSB7U2NoZW1hfSBzY2hlbWFcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGFwcGx5U3RhdGljcyhtb2RlbCwgc2NoZW1hKSB7XG4gIGZvciAoY29uc3QgaSBpbiBzY2hlbWEuc3RhdGljcykge1xuICAgIG1vZGVsW2ldID0gc2NoZW1hLnN0YXRpY3NbaV07XG4gIH1cbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../server/node_modules/mongoose/lib/helpers/model/applyStatics.js\n");

/***/ }),

/***/ "../server/node_modules/mongoose/lib/helpers/model/castBulkWrite.js":
/*!**************************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/helpers/model/castBulkWrite.js ***!
  \**************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst MongooseError = __webpack_require__(/*! ../../error/mongooseError */ \"../server/node_modules/mongoose/lib/error/mongooseError.js\");\nconst getDiscriminatorByValue = __webpack_require__(/*! ../../helpers/discriminator/getDiscriminatorByValue */ \"../server/node_modules/mongoose/lib/helpers/discriminator/getDiscriminatorByValue.js\");\nconst applyTimestampsToChildren = __webpack_require__(/*! ../update/applyTimestampsToChildren */ \"../server/node_modules/mongoose/lib/helpers/update/applyTimestampsToChildren.js\");\nconst applyTimestampsToUpdate = __webpack_require__(/*! ../update/applyTimestampsToUpdate */ \"../server/node_modules/mongoose/lib/helpers/update/applyTimestampsToUpdate.js\");\nconst cast = __webpack_require__(/*! ../../cast */ \"../server/node_modules/mongoose/lib/cast.js\");\nconst castUpdate = __webpack_require__(/*! ../query/castUpdate */ \"../server/node_modules/mongoose/lib/helpers/query/castUpdate.js\");\nconst clone = __webpack_require__(/*! ../clone */ \"../server/node_modules/mongoose/lib/helpers/clone.js\");\nconst decorateUpdateWithVersionKey = __webpack_require__(/*! ../update/decorateUpdateWithVersionKey */ \"../server/node_modules/mongoose/lib/helpers/update/decorateUpdateWithVersionKey.js\");\nconst { inspect } = __webpack_require__(/*! util */ \"util\");\nconst setDefaultsOnInsert = __webpack_require__(/*! ../setDefaultsOnInsert */ \"../server/node_modules/mongoose/lib/helpers/setDefaultsOnInsert.js\");\n\n/**\n * Given a model and a bulkWrite op, return a thunk that handles casting and\n * validating the individual op.\n * @param {Model} originalModel\n * @param {Object} op\n * @param {Object} [options]\n * @api private\n */\n\nmodule.exports = function castBulkWrite(originalModel, op, options) {\n  const now = originalModel.base.now();\n\n  const globalSetDefaultsOnInsert = originalModel.base.options.setDefaultsOnInsert;\n  if (op['insertOne']) {\n    return (callback) => {\n      const model = decideModelByObject(originalModel, op['insertOne']['document']);\n\n      const doc = new model(op['insertOne']['document']);\n      if (model.schema.options.timestamps && options.timestamps !== false) {\n        doc.initializeTimestamps();\n      }\n      if (options.session != null) {\n        doc.$session(options.session);\n      }\n      const versionKey = model?.schema?.options?.versionKey;\n      if (versionKey && doc[versionKey] == null) {\n        doc[versionKey] = 0;\n      }\n      op['insertOne']['document'] = doc;\n\n      if (options.skipValidation || op['insertOne'].skipValidation) {\n        callback(null);\n        return;\n      }\n\n      op['insertOne']['document'].$validate().then(\n        () => { callback(null); },\n        err => { callback(err, null); }\n      );\n    };\n  } else if (op['updateOne']) {\n    return (callback) => {\n      try {\n        if (!op['updateOne']['filter']) {\n          throw new Error('Must provide a filter object.');\n        }\n        if (!op['updateOne']['update']) {\n          throw new Error('Must provide an update object.');\n        }\n\n        const model = decideModelByObject(originalModel, op['updateOne']['filter']);\n        const schema = model.schema;\n        const strict = options.strict != null ? options.strict : model.schema.options.strict;\n\n        const update = clone(op['updateOne']['update']);\n\n        _addDiscriminatorToObject(schema, op['updateOne']['filter']);\n\n        if (model.schema.$timestamps != null && op['updateOne'].timestamps !== false) {\n          const createdAt = model.schema.$timestamps.createdAt;\n          const updatedAt = model.schema.$timestamps.updatedAt;\n          applyTimestampsToUpdate(now, createdAt, updatedAt, update, {});\n        }\n\n        if (op['updateOne'].timestamps !== false) {\n          applyTimestampsToChildren(now, update, model.schema);\n        }\n\n        const shouldSetDefaultsOnInsert = op['updateOne'].setDefaultsOnInsert == null ?\n          globalSetDefaultsOnInsert :\n          op['updateOne'].setDefaultsOnInsert;\n        if (shouldSetDefaultsOnInsert !== false) {\n          setDefaultsOnInsert(op['updateOne']['filter'], model.schema, update, {\n            setDefaultsOnInsert: true,\n            upsert: op['updateOne'].upsert\n          });\n        }\n\n        decorateUpdateWithVersionKey(\n          update,\n          op['updateOne'],\n          model.schema.options.versionKey\n        );\n\n        op['updateOne']['filter'] = cast(model.schema, op['updateOne']['filter'], {\n          strict: strict,\n          upsert: op['updateOne'].upsert\n        });\n        op['updateOne']['update'] = castUpdate(model.schema, update, {\n          strict: strict,\n          upsert: op['updateOne'].upsert\n        }, model, op['updateOne']['filter']);\n      } catch (error) {\n        return callback(error, null);\n      }\n\n      callback(null);\n    };\n  } else if (op['updateMany']) {\n    return (callback) => {\n      try {\n        if (!op['updateMany']['filter']) {\n          throw new Error('Must provide a filter object.');\n        }\n        if (!op['updateMany']['update']) {\n          throw new Error('Must provide an update object.');\n        }\n\n        const model = decideModelByObject(originalModel, op['updateMany']['filter']);\n        const schema = model.schema;\n        const strict = options.strict != null ? options.strict : model.schema.options.strict;\n\n        const shouldSetDefaultsOnInsert = op['updateMany'].setDefaultsOnInsert == null ?\n          globalSetDefaultsOnInsert :\n          op['updateMany'].setDefaultsOnInsert;\n\n        if (shouldSetDefaultsOnInsert !== false) {\n          setDefaultsOnInsert(op['updateMany']['filter'], model.schema, op['updateMany']['update'], {\n            setDefaultsOnInsert: true,\n            upsert: op['updateMany'].upsert\n          });\n        }\n\n        if (model.schema.$timestamps != null && op['updateMany'].timestamps !== false) {\n          const createdAt = model.schema.$timestamps.createdAt;\n          const updatedAt = model.schema.$timestamps.updatedAt;\n          applyTimestampsToUpdate(now, createdAt, updatedAt, op['updateMany']['update'], {});\n        }\n        if (op['updateMany'].timestamps !== false) {\n          applyTimestampsToChildren(now, op['updateMany']['update'], model.schema);\n        }\n\n        _addDiscriminatorToObject(schema, op['updateMany']['filter']);\n\n        decorateUpdateWithVersionKey(\n          op['updateMany']['update'],\n          op['updateMany'],\n          model.schema.options.versionKey\n        );\n\n        op['updateMany']['filter'] = cast(model.schema, op['updateMany']['filter'], {\n          strict: strict,\n          upsert: op['updateMany'].upsert\n        });\n\n        op['updateMany']['update'] = castUpdate(model.schema, op['updateMany']['update'], {\n          strict: strict,\n          upsert: op['updateMany'].upsert\n        }, model, op['updateMany']['filter']);\n      } catch (error) {\n        return callback(error, null);\n      }\n\n      callback(null);\n    };\n  } else if (op['replaceOne']) {\n    return (callback) => {\n      const model = decideModelByObject(originalModel, op['replaceOne']['filter']);\n      const schema = model.schema;\n      const strict = options.strict != null ? options.strict : model.schema.options.strict;\n\n      _addDiscriminatorToObject(schema, op['replaceOne']['filter']);\n      try {\n        op['replaceOne']['filter'] = cast(model.schema, op['replaceOne']['filter'], {\n          strict: strict,\n          upsert: op['replaceOne'].upsert\n        });\n      } catch (error) {\n        return callback(error, null);\n      }\n\n      // set `skipId`, otherwise we get \"_id field cannot be changed\"\n      const doc = new model(op['replaceOne']['replacement'], strict, true);\n      if (model.schema.options.timestamps) {\n        doc.initializeTimestamps();\n      }\n      if (options.session != null) {\n        doc.$session(options.session);\n      }\n      const versionKey = model?.schema?.options?.versionKey;\n      if (versionKey && doc[versionKey] == null) {\n        doc[versionKey] = 0;\n      }\n      op['replaceOne']['replacement'] = doc;\n\n      if (options.skipValidation || op['replaceOne'].skipValidation) {\n        op['replaceOne']['replacement'] = op['replaceOne']['replacement'].toBSON();\n        callback(null);\n        return;\n      }\n\n      op['replaceOne']['replacement'].$validate().then(\n        () => {\n          op['replaceOne']['replacement'] = op['replaceOne']['replacement'].toBSON();\n          callback(null);\n        },\n        error => {\n          callback(error, null);\n        }\n      );\n    };\n  } else if (op['deleteOne']) {\n    return (callback) => {\n      const model = decideModelByObject(originalModel, op['deleteOne']['filter']);\n      const schema = model.schema;\n\n      _addDiscriminatorToObject(schema, op['deleteOne']['filter']);\n\n      try {\n        op['deleteOne']['filter'] = cast(model.schema,\n          op['deleteOne']['filter']);\n      } catch (error) {\n        return callback(error, null);\n      }\n\n      callback(null);\n    };\n  } else if (op['deleteMany']) {\n    return (callback) => {\n      const model = decideModelByObject(originalModel, op['deleteMany']['filter']);\n      const schema = model.schema;\n\n      _addDiscriminatorToObject(schema, op['deleteMany']['filter']);\n\n      try {\n        op['deleteMany']['filter'] = cast(model.schema,\n          op['deleteMany']['filter']);\n      } catch (error) {\n        return callback(error, null);\n      }\n\n      callback(null);\n    };\n  } else {\n    return (callback) => {\n      const error = new MongooseError(`Invalid op passed to \\`bulkWrite()\\`: ${inspect(op)}`);\n      callback(error, null);\n    };\n  }\n};\n\nfunction _addDiscriminatorToObject(schema, obj) {\n  if (schema == null) {\n    return;\n  }\n  if (schema.discriminatorMapping && !schema.discriminatorMapping.isRoot) {\n    obj[schema.discriminatorMapping.key] = schema.discriminatorMapping.value;\n  }\n}\n\n/**\n * gets discriminator model if discriminator key is present in object\n * @api private\n */\n\nfunction decideModelByObject(model, object) {\n  const discriminatorKey = model.schema.options.discriminatorKey;\n  if (object != null && object.hasOwnProperty(discriminatorKey)) {\n    model = getDiscriminatorByValue(model.discriminators, object[discriminatorKey]) || model;\n  }\n  return model;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9tb2RlbC9jYXN0QnVsa1dyaXRlLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLHNCQUFzQixtQkFBTyxDQUFDLDZGQUEyQjtBQUN6RCxnQ0FBZ0MsbUJBQU8sQ0FBQyxpSkFBcUQ7QUFDN0Ysa0NBQWtDLG1CQUFPLENBQUMsNEhBQXFDO0FBQy9FLGdDQUFnQyxtQkFBTyxDQUFDLHdIQUFtQztBQUMzRSxhQUFhLG1CQUFPLENBQUMsK0RBQVk7QUFDakMsbUJBQW1CLG1CQUFPLENBQUMsNEZBQXFCO0FBQ2hELGNBQWMsbUJBQU8sQ0FBQyxzRUFBVTtBQUNoQyxxQ0FBcUMsbUJBQU8sQ0FBQyxrSUFBd0M7QUFDckYsUUFBUSxVQUFVLEVBQUUsbUJBQU8sQ0FBQyxrQkFBTTtBQUNsQyw0QkFBNEIsbUJBQU8sQ0FBQyxrR0FBd0I7O0FBRTVEO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQkFBZ0IsaUJBQWlCO0FBQ2pDLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHVFQUF1RTtBQUN2RTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDJGQUEyRjtBQUMzRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSwrRUFBK0UsWUFBWTtBQUMzRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2xpZW50Ly4uL3NlcnZlci9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvbW9kZWwvY2FzdEJ1bGtXcml0ZS5qcz81ZTZkIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3QgTW9uZ29vc2VFcnJvciA9IHJlcXVpcmUoJy4uLy4uL2Vycm9yL21vbmdvb3NlRXJyb3InKTtcbmNvbnN0IGdldERpc2NyaW1pbmF0b3JCeVZhbHVlID0gcmVxdWlyZSgnLi4vLi4vaGVscGVycy9kaXNjcmltaW5hdG9yL2dldERpc2NyaW1pbmF0b3JCeVZhbHVlJyk7XG5jb25zdCBhcHBseVRpbWVzdGFtcHNUb0NoaWxkcmVuID0gcmVxdWlyZSgnLi4vdXBkYXRlL2FwcGx5VGltZXN0YW1wc1RvQ2hpbGRyZW4nKTtcbmNvbnN0IGFwcGx5VGltZXN0YW1wc1RvVXBkYXRlID0gcmVxdWlyZSgnLi4vdXBkYXRlL2FwcGx5VGltZXN0YW1wc1RvVXBkYXRlJyk7XG5jb25zdCBjYXN0ID0gcmVxdWlyZSgnLi4vLi4vY2FzdCcpO1xuY29uc3QgY2FzdFVwZGF0ZSA9IHJlcXVpcmUoJy4uL3F1ZXJ5L2Nhc3RVcGRhdGUnKTtcbmNvbnN0IGNsb25lID0gcmVxdWlyZSgnLi4vY2xvbmUnKTtcbmNvbnN0IGRlY29yYXRlVXBkYXRlV2l0aFZlcnNpb25LZXkgPSByZXF1aXJlKCcuLi91cGRhdGUvZGVjb3JhdGVVcGRhdGVXaXRoVmVyc2lvbktleScpO1xuY29uc3QgeyBpbnNwZWN0IH0gPSByZXF1aXJlKCd1dGlsJyk7XG5jb25zdCBzZXREZWZhdWx0c09uSW5zZXJ0ID0gcmVxdWlyZSgnLi4vc2V0RGVmYXVsdHNPbkluc2VydCcpO1xuXG4vKipcbiAqIEdpdmVuIGEgbW9kZWwgYW5kIGEgYnVsa1dyaXRlIG9wLCByZXR1cm4gYSB0aHVuayB0aGF0IGhhbmRsZXMgY2FzdGluZyBhbmRcbiAqIHZhbGlkYXRpbmcgdGhlIGluZGl2aWR1YWwgb3AuXG4gKiBAcGFyYW0ge01vZGVsfSBvcmlnaW5hbE1vZGVsXG4gKiBAcGFyYW0ge09iamVjdH0gb3BcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gY2FzdEJ1bGtXcml0ZShvcmlnaW5hbE1vZGVsLCBvcCwgb3B0aW9ucykge1xuICBjb25zdCBub3cgPSBvcmlnaW5hbE1vZGVsLmJhc2Uubm93KCk7XG5cbiAgY29uc3QgZ2xvYmFsU2V0RGVmYXVsdHNPbkluc2VydCA9IG9yaWdpbmFsTW9kZWwuYmFzZS5vcHRpb25zLnNldERlZmF1bHRzT25JbnNlcnQ7XG4gIGlmIChvcFsnaW5zZXJ0T25lJ10pIHtcbiAgICByZXR1cm4gKGNhbGxiYWNrKSA9PiB7XG4gICAgICBjb25zdCBtb2RlbCA9IGRlY2lkZU1vZGVsQnlPYmplY3Qob3JpZ2luYWxNb2RlbCwgb3BbJ2luc2VydE9uZSddWydkb2N1bWVudCddKTtcblxuICAgICAgY29uc3QgZG9jID0gbmV3IG1vZGVsKG9wWydpbnNlcnRPbmUnXVsnZG9jdW1lbnQnXSk7XG4gICAgICBpZiAobW9kZWwuc2NoZW1hLm9wdGlvbnMudGltZXN0YW1wcyAmJiBvcHRpb25zLnRpbWVzdGFtcHMgIT09IGZhbHNlKSB7XG4gICAgICAgIGRvYy5pbml0aWFsaXplVGltZXN0YW1wcygpO1xuICAgICAgfVxuICAgICAgaWYgKG9wdGlvbnMuc2Vzc2lvbiAhPSBudWxsKSB7XG4gICAgICAgIGRvYy4kc2Vzc2lvbihvcHRpb25zLnNlc3Npb24pO1xuICAgICAgfVxuICAgICAgY29uc3QgdmVyc2lvbktleSA9IG1vZGVsPy5zY2hlbWE/Lm9wdGlvbnM/LnZlcnNpb25LZXk7XG4gICAgICBpZiAodmVyc2lvbktleSAmJiBkb2NbdmVyc2lvbktleV0gPT0gbnVsbCkge1xuICAgICAgICBkb2NbdmVyc2lvbktleV0gPSAwO1xuICAgICAgfVxuICAgICAgb3BbJ2luc2VydE9uZSddWydkb2N1bWVudCddID0gZG9jO1xuXG4gICAgICBpZiAob3B0aW9ucy5za2lwVmFsaWRhdGlvbiB8fCBvcFsnaW5zZXJ0T25lJ10uc2tpcFZhbGlkYXRpb24pIHtcbiAgICAgICAgY2FsbGJhY2sobnVsbCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgb3BbJ2luc2VydE9uZSddWydkb2N1bWVudCddLiR2YWxpZGF0ZSgpLnRoZW4oXG4gICAgICAgICgpID0+IHsgY2FsbGJhY2sobnVsbCk7IH0sXG4gICAgICAgIGVyciA9PiB7IGNhbGxiYWNrKGVyciwgbnVsbCk7IH1cbiAgICAgICk7XG4gICAgfTtcbiAgfSBlbHNlIGlmIChvcFsndXBkYXRlT25lJ10pIHtcbiAgICByZXR1cm4gKGNhbGxiYWNrKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAoIW9wWyd1cGRhdGVPbmUnXVsnZmlsdGVyJ10pIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ011c3QgcHJvdmlkZSBhIGZpbHRlciBvYmplY3QuJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFvcFsndXBkYXRlT25lJ11bJ3VwZGF0ZSddKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNdXN0IHByb3ZpZGUgYW4gdXBkYXRlIG9iamVjdC4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IG1vZGVsID0gZGVjaWRlTW9kZWxCeU9iamVjdChvcmlnaW5hbE1vZGVsLCBvcFsndXBkYXRlT25lJ11bJ2ZpbHRlciddKTtcbiAgICAgICAgY29uc3Qgc2NoZW1hID0gbW9kZWwuc2NoZW1hO1xuICAgICAgICBjb25zdCBzdHJpY3QgPSBvcHRpb25zLnN0cmljdCAhPSBudWxsID8gb3B0aW9ucy5zdHJpY3QgOiBtb2RlbC5zY2hlbWEub3B0aW9ucy5zdHJpY3Q7XG5cbiAgICAgICAgY29uc3QgdXBkYXRlID0gY2xvbmUob3BbJ3VwZGF0ZU9uZSddWyd1cGRhdGUnXSk7XG5cbiAgICAgICAgX2FkZERpc2NyaW1pbmF0b3JUb09iamVjdChzY2hlbWEsIG9wWyd1cGRhdGVPbmUnXVsnZmlsdGVyJ10pO1xuXG4gICAgICAgIGlmIChtb2RlbC5zY2hlbWEuJHRpbWVzdGFtcHMgIT0gbnVsbCAmJiBvcFsndXBkYXRlT25lJ10udGltZXN0YW1wcyAhPT0gZmFsc2UpIHtcbiAgICAgICAgICBjb25zdCBjcmVhdGVkQXQgPSBtb2RlbC5zY2hlbWEuJHRpbWVzdGFtcHMuY3JlYXRlZEF0O1xuICAgICAgICAgIGNvbnN0IHVwZGF0ZWRBdCA9IG1vZGVsLnNjaGVtYS4kdGltZXN0YW1wcy51cGRhdGVkQXQ7XG4gICAgICAgICAgYXBwbHlUaW1lc3RhbXBzVG9VcGRhdGUobm93LCBjcmVhdGVkQXQsIHVwZGF0ZWRBdCwgdXBkYXRlLCB7fSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob3BbJ3VwZGF0ZU9uZSddLnRpbWVzdGFtcHMgIT09IGZhbHNlKSB7XG4gICAgICAgICAgYXBwbHlUaW1lc3RhbXBzVG9DaGlsZHJlbihub3csIHVwZGF0ZSwgbW9kZWwuc2NoZW1hKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHNob3VsZFNldERlZmF1bHRzT25JbnNlcnQgPSBvcFsndXBkYXRlT25lJ10uc2V0RGVmYXVsdHNPbkluc2VydCA9PSBudWxsID9cbiAgICAgICAgICBnbG9iYWxTZXREZWZhdWx0c09uSW5zZXJ0IDpcbiAgICAgICAgICBvcFsndXBkYXRlT25lJ10uc2V0RGVmYXVsdHNPbkluc2VydDtcbiAgICAgICAgaWYgKHNob3VsZFNldERlZmF1bHRzT25JbnNlcnQgIT09IGZhbHNlKSB7XG4gICAgICAgICAgc2V0RGVmYXVsdHNPbkluc2VydChvcFsndXBkYXRlT25lJ11bJ2ZpbHRlciddLCBtb2RlbC5zY2hlbWEsIHVwZGF0ZSwge1xuICAgICAgICAgICAgc2V0RGVmYXVsdHNPbkluc2VydDogdHJ1ZSxcbiAgICAgICAgICAgIHVwc2VydDogb3BbJ3VwZGF0ZU9uZSddLnVwc2VydFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgZGVjb3JhdGVVcGRhdGVXaXRoVmVyc2lvbktleShcbiAgICAgICAgICB1cGRhdGUsXG4gICAgICAgICAgb3BbJ3VwZGF0ZU9uZSddLFxuICAgICAgICAgIG1vZGVsLnNjaGVtYS5vcHRpb25zLnZlcnNpb25LZXlcbiAgICAgICAgKTtcblxuICAgICAgICBvcFsndXBkYXRlT25lJ11bJ2ZpbHRlciddID0gY2FzdChtb2RlbC5zY2hlbWEsIG9wWyd1cGRhdGVPbmUnXVsnZmlsdGVyJ10sIHtcbiAgICAgICAgICBzdHJpY3Q6IHN0cmljdCxcbiAgICAgICAgICB1cHNlcnQ6IG9wWyd1cGRhdGVPbmUnXS51cHNlcnRcbiAgICAgICAgfSk7XG4gICAgICAgIG9wWyd1cGRhdGVPbmUnXVsndXBkYXRlJ10gPSBjYXN0VXBkYXRlKG1vZGVsLnNjaGVtYSwgdXBkYXRlLCB7XG4gICAgICAgICAgc3RyaWN0OiBzdHJpY3QsXG4gICAgICAgICAgdXBzZXJ0OiBvcFsndXBkYXRlT25lJ10udXBzZXJ0XG4gICAgICAgIH0sIG1vZGVsLCBvcFsndXBkYXRlT25lJ11bJ2ZpbHRlciddKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjayhlcnJvciwgbnVsbCk7XG4gICAgICB9XG5cbiAgICAgIGNhbGxiYWNrKG51bGwpO1xuICAgIH07XG4gIH0gZWxzZSBpZiAob3BbJ3VwZGF0ZU1hbnknXSkge1xuICAgIHJldHVybiAoY2FsbGJhY2spID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmICghb3BbJ3VwZGF0ZU1hbnknXVsnZmlsdGVyJ10pIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ011c3QgcHJvdmlkZSBhIGZpbHRlciBvYmplY3QuJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFvcFsndXBkYXRlTWFueSddWyd1cGRhdGUnXSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTXVzdCBwcm92aWRlIGFuIHVwZGF0ZSBvYmplY3QuJyk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBtb2RlbCA9IGRlY2lkZU1vZGVsQnlPYmplY3Qob3JpZ2luYWxNb2RlbCwgb3BbJ3VwZGF0ZU1hbnknXVsnZmlsdGVyJ10pO1xuICAgICAgICBjb25zdCBzY2hlbWEgPSBtb2RlbC5zY2hlbWE7XG4gICAgICAgIGNvbnN0IHN0cmljdCA9IG9wdGlvbnMuc3RyaWN0ICE9IG51bGwgPyBvcHRpb25zLnN0cmljdCA6IG1vZGVsLnNjaGVtYS5vcHRpb25zLnN0cmljdDtcblxuICAgICAgICBjb25zdCBzaG91bGRTZXREZWZhdWx0c09uSW5zZXJ0ID0gb3BbJ3VwZGF0ZU1hbnknXS5zZXREZWZhdWx0c09uSW5zZXJ0ID09IG51bGwgP1xuICAgICAgICAgIGdsb2JhbFNldERlZmF1bHRzT25JbnNlcnQgOlxuICAgICAgICAgIG9wWyd1cGRhdGVNYW55J10uc2V0RGVmYXVsdHNPbkluc2VydDtcblxuICAgICAgICBpZiAoc2hvdWxkU2V0RGVmYXVsdHNPbkluc2VydCAhPT0gZmFsc2UpIHtcbiAgICAgICAgICBzZXREZWZhdWx0c09uSW5zZXJ0KG9wWyd1cGRhdGVNYW55J11bJ2ZpbHRlciddLCBtb2RlbC5zY2hlbWEsIG9wWyd1cGRhdGVNYW55J11bJ3VwZGF0ZSddLCB7XG4gICAgICAgICAgICBzZXREZWZhdWx0c09uSW5zZXJ0OiB0cnVlLFxuICAgICAgICAgICAgdXBzZXJ0OiBvcFsndXBkYXRlTWFueSddLnVwc2VydFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1vZGVsLnNjaGVtYS4kdGltZXN0YW1wcyAhPSBudWxsICYmIG9wWyd1cGRhdGVNYW55J10udGltZXN0YW1wcyAhPT0gZmFsc2UpIHtcbiAgICAgICAgICBjb25zdCBjcmVhdGVkQXQgPSBtb2RlbC5zY2hlbWEuJHRpbWVzdGFtcHMuY3JlYXRlZEF0O1xuICAgICAgICAgIGNvbnN0IHVwZGF0ZWRBdCA9IG1vZGVsLnNjaGVtYS4kdGltZXN0YW1wcy51cGRhdGVkQXQ7XG4gICAgICAgICAgYXBwbHlUaW1lc3RhbXBzVG9VcGRhdGUobm93LCBjcmVhdGVkQXQsIHVwZGF0ZWRBdCwgb3BbJ3VwZGF0ZU1hbnknXVsndXBkYXRlJ10sIHt9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3BbJ3VwZGF0ZU1hbnknXS50aW1lc3RhbXBzICE9PSBmYWxzZSkge1xuICAgICAgICAgIGFwcGx5VGltZXN0YW1wc1RvQ2hpbGRyZW4obm93LCBvcFsndXBkYXRlTWFueSddWyd1cGRhdGUnXSwgbW9kZWwuc2NoZW1hKTtcbiAgICAgICAgfVxuXG4gICAgICAgIF9hZGREaXNjcmltaW5hdG9yVG9PYmplY3Qoc2NoZW1hLCBvcFsndXBkYXRlTWFueSddWydmaWx0ZXInXSk7XG5cbiAgICAgICAgZGVjb3JhdGVVcGRhdGVXaXRoVmVyc2lvbktleShcbiAgICAgICAgICBvcFsndXBkYXRlTWFueSddWyd1cGRhdGUnXSxcbiAgICAgICAgICBvcFsndXBkYXRlTWFueSddLFxuICAgICAgICAgIG1vZGVsLnNjaGVtYS5vcHRpb25zLnZlcnNpb25LZXlcbiAgICAgICAgKTtcblxuICAgICAgICBvcFsndXBkYXRlTWFueSddWydmaWx0ZXInXSA9IGNhc3QobW9kZWwuc2NoZW1hLCBvcFsndXBkYXRlTWFueSddWydmaWx0ZXInXSwge1xuICAgICAgICAgIHN0cmljdDogc3RyaWN0LFxuICAgICAgICAgIHVwc2VydDogb3BbJ3VwZGF0ZU1hbnknXS51cHNlcnRcbiAgICAgICAgfSk7XG5cbiAgICAgICAgb3BbJ3VwZGF0ZU1hbnknXVsndXBkYXRlJ10gPSBjYXN0VXBkYXRlKG1vZGVsLnNjaGVtYSwgb3BbJ3VwZGF0ZU1hbnknXVsndXBkYXRlJ10sIHtcbiAgICAgICAgICBzdHJpY3Q6IHN0cmljdCxcbiAgICAgICAgICB1cHNlcnQ6IG9wWyd1cGRhdGVNYW55J10udXBzZXJ0XG4gICAgICAgIH0sIG1vZGVsLCBvcFsndXBkYXRlTWFueSddWydmaWx0ZXInXSk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyb3IsIG51bGwpO1xuICAgICAgfVxuXG4gICAgICBjYWxsYmFjayhudWxsKTtcbiAgICB9O1xuICB9IGVsc2UgaWYgKG9wWydyZXBsYWNlT25lJ10pIHtcbiAgICByZXR1cm4gKGNhbGxiYWNrKSA9PiB7XG4gICAgICBjb25zdCBtb2RlbCA9IGRlY2lkZU1vZGVsQnlPYmplY3Qob3JpZ2luYWxNb2RlbCwgb3BbJ3JlcGxhY2VPbmUnXVsnZmlsdGVyJ10pO1xuICAgICAgY29uc3Qgc2NoZW1hID0gbW9kZWwuc2NoZW1hO1xuICAgICAgY29uc3Qgc3RyaWN0ID0gb3B0aW9ucy5zdHJpY3QgIT0gbnVsbCA/IG9wdGlvbnMuc3RyaWN0IDogbW9kZWwuc2NoZW1hLm9wdGlvbnMuc3RyaWN0O1xuXG4gICAgICBfYWRkRGlzY3JpbWluYXRvclRvT2JqZWN0KHNjaGVtYSwgb3BbJ3JlcGxhY2VPbmUnXVsnZmlsdGVyJ10pO1xuICAgICAgdHJ5IHtcbiAgICAgICAgb3BbJ3JlcGxhY2VPbmUnXVsnZmlsdGVyJ10gPSBjYXN0KG1vZGVsLnNjaGVtYSwgb3BbJ3JlcGxhY2VPbmUnXVsnZmlsdGVyJ10sIHtcbiAgICAgICAgICBzdHJpY3Q6IHN0cmljdCxcbiAgICAgICAgICB1cHNlcnQ6IG9wWydyZXBsYWNlT25lJ10udXBzZXJ0XG4gICAgICAgIH0pO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycm9yLCBudWxsKTtcbiAgICAgIH1cblxuICAgICAgLy8gc2V0IGBza2lwSWRgLCBvdGhlcndpc2Ugd2UgZ2V0IFwiX2lkIGZpZWxkIGNhbm5vdCBiZSBjaGFuZ2VkXCJcbiAgICAgIGNvbnN0IGRvYyA9IG5ldyBtb2RlbChvcFsncmVwbGFjZU9uZSddWydyZXBsYWNlbWVudCddLCBzdHJpY3QsIHRydWUpO1xuICAgICAgaWYgKG1vZGVsLnNjaGVtYS5vcHRpb25zLnRpbWVzdGFtcHMpIHtcbiAgICAgICAgZG9jLmluaXRpYWxpemVUaW1lc3RhbXBzKCk7XG4gICAgICB9XG4gICAgICBpZiAob3B0aW9ucy5zZXNzaW9uICE9IG51bGwpIHtcbiAgICAgICAgZG9jLiRzZXNzaW9uKG9wdGlvbnMuc2Vzc2lvbik7XG4gICAgICB9XG4gICAgICBjb25zdCB2ZXJzaW9uS2V5ID0gbW9kZWw/LnNjaGVtYT8ub3B0aW9ucz8udmVyc2lvbktleTtcbiAgICAgIGlmICh2ZXJzaW9uS2V5ICYmIGRvY1t2ZXJzaW9uS2V5XSA9PSBudWxsKSB7XG4gICAgICAgIGRvY1t2ZXJzaW9uS2V5XSA9IDA7XG4gICAgICB9XG4gICAgICBvcFsncmVwbGFjZU9uZSddWydyZXBsYWNlbWVudCddID0gZG9jO1xuXG4gICAgICBpZiAob3B0aW9ucy5za2lwVmFsaWRhdGlvbiB8fCBvcFsncmVwbGFjZU9uZSddLnNraXBWYWxpZGF0aW9uKSB7XG4gICAgICAgIG9wWydyZXBsYWNlT25lJ11bJ3JlcGxhY2VtZW50J10gPSBvcFsncmVwbGFjZU9uZSddWydyZXBsYWNlbWVudCddLnRvQlNPTigpO1xuICAgICAgICBjYWxsYmFjayhudWxsKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBvcFsncmVwbGFjZU9uZSddWydyZXBsYWNlbWVudCddLiR2YWxpZGF0ZSgpLnRoZW4oXG4gICAgICAgICgpID0+IHtcbiAgICAgICAgICBvcFsncmVwbGFjZU9uZSddWydyZXBsYWNlbWVudCddID0gb3BbJ3JlcGxhY2VPbmUnXVsncmVwbGFjZW1lbnQnXS50b0JTT04oKTtcbiAgICAgICAgICBjYWxsYmFjayhudWxsKTtcbiAgICAgICAgfSxcbiAgICAgICAgZXJyb3IgPT4ge1xuICAgICAgICAgIGNhbGxiYWNrKGVycm9yLCBudWxsKTtcbiAgICAgICAgfVxuICAgICAgKTtcbiAgICB9O1xuICB9IGVsc2UgaWYgKG9wWydkZWxldGVPbmUnXSkge1xuICAgIHJldHVybiAoY2FsbGJhY2spID0+IHtcbiAgICAgIGNvbnN0IG1vZGVsID0gZGVjaWRlTW9kZWxCeU9iamVjdChvcmlnaW5hbE1vZGVsLCBvcFsnZGVsZXRlT25lJ11bJ2ZpbHRlciddKTtcbiAgICAgIGNvbnN0IHNjaGVtYSA9IG1vZGVsLnNjaGVtYTtcblxuICAgICAgX2FkZERpc2NyaW1pbmF0b3JUb09iamVjdChzY2hlbWEsIG9wWydkZWxldGVPbmUnXVsnZmlsdGVyJ10pO1xuXG4gICAgICB0cnkge1xuICAgICAgICBvcFsnZGVsZXRlT25lJ11bJ2ZpbHRlciddID0gY2FzdChtb2RlbC5zY2hlbWEsXG4gICAgICAgICAgb3BbJ2RlbGV0ZU9uZSddWydmaWx0ZXInXSk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyb3IsIG51bGwpO1xuICAgICAgfVxuXG4gICAgICBjYWxsYmFjayhudWxsKTtcbiAgICB9O1xuICB9IGVsc2UgaWYgKG9wWydkZWxldGVNYW55J10pIHtcbiAgICByZXR1cm4gKGNhbGxiYWNrKSA9PiB7XG4gICAgICBjb25zdCBtb2RlbCA9IGRlY2lkZU1vZGVsQnlPYmplY3Qob3JpZ2luYWxNb2RlbCwgb3BbJ2RlbGV0ZU1hbnknXVsnZmlsdGVyJ10pO1xuICAgICAgY29uc3Qgc2NoZW1hID0gbW9kZWwuc2NoZW1hO1xuXG4gICAgICBfYWRkRGlzY3JpbWluYXRvclRvT2JqZWN0KHNjaGVtYSwgb3BbJ2RlbGV0ZU1hbnknXVsnZmlsdGVyJ10pO1xuXG4gICAgICB0cnkge1xuICAgICAgICBvcFsnZGVsZXRlTWFueSddWydmaWx0ZXInXSA9IGNhc3QobW9kZWwuc2NoZW1hLFxuICAgICAgICAgIG9wWydkZWxldGVNYW55J11bJ2ZpbHRlciddKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjayhlcnJvciwgbnVsbCk7XG4gICAgICB9XG5cbiAgICAgIGNhbGxiYWNrKG51bGwpO1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIChjYWxsYmFjaykgPT4ge1xuICAgICAgY29uc3QgZXJyb3IgPSBuZXcgTW9uZ29vc2VFcnJvcihgSW52YWxpZCBvcCBwYXNzZWQgdG8gXFxgYnVsa1dyaXRlKClcXGA6ICR7aW5zcGVjdChvcCl9YCk7XG4gICAgICBjYWxsYmFjayhlcnJvciwgbnVsbCk7XG4gICAgfTtcbiAgfVxufTtcblxuZnVuY3Rpb24gX2FkZERpc2NyaW1pbmF0b3JUb09iamVjdChzY2hlbWEsIG9iaikge1xuICBpZiAoc2NoZW1hID09IG51bGwpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKHNjaGVtYS5kaXNjcmltaW5hdG9yTWFwcGluZyAmJiAhc2NoZW1hLmRpc2NyaW1pbmF0b3JNYXBwaW5nLmlzUm9vdCkge1xuICAgIG9ialtzY2hlbWEuZGlzY3JpbWluYXRvck1hcHBpbmcua2V5XSA9IHNjaGVtYS5kaXNjcmltaW5hdG9yTWFwcGluZy52YWx1ZTtcbiAgfVxufVxuXG4vKipcbiAqIGdldHMgZGlzY3JpbWluYXRvciBtb2RlbCBpZiBkaXNjcmltaW5hdG9yIGtleSBpcyBwcmVzZW50IGluIG9iamVjdFxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gZGVjaWRlTW9kZWxCeU9iamVjdChtb2RlbCwgb2JqZWN0KSB7XG4gIGNvbnN0IGRpc2NyaW1pbmF0b3JLZXkgPSBtb2RlbC5zY2hlbWEub3B0aW9ucy5kaXNjcmltaW5hdG9yS2V5O1xuICBpZiAob2JqZWN0ICE9IG51bGwgJiYgb2JqZWN0Lmhhc093blByb3BlcnR5KGRpc2NyaW1pbmF0b3JLZXkpKSB7XG4gICAgbW9kZWwgPSBnZXREaXNjcmltaW5hdG9yQnlWYWx1ZShtb2RlbC5kaXNjcmltaW5hdG9ycywgb2JqZWN0W2Rpc2NyaW1pbmF0b3JLZXldKSB8fCBtb2RlbDtcbiAgfVxuICByZXR1cm4gbW9kZWw7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../server/node_modules/mongoose/lib/helpers/model/castBulkWrite.js\n");

/***/ }),

/***/ "../server/node_modules/mongoose/lib/helpers/model/discriminator.js":
/*!**************************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/helpers/model/discriminator.js ***!
  \**************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst Mixed = __webpack_require__(/*! ../../schema/mixed */ \"../server/node_modules/mongoose/lib/schema/mixed.js\");\nconst applyBuiltinPlugins = __webpack_require__(/*! ../schema/applyBuiltinPlugins */ \"../server/node_modules/mongoose/lib/helpers/schema/applyBuiltinPlugins.js\");\nconst clone = __webpack_require__(/*! ../clone */ \"../server/node_modules/mongoose/lib/helpers/clone.js\");\nconst defineKey = (__webpack_require__(/*! ../document/compile */ \"../server/node_modules/mongoose/lib/helpers/document/compile.js\").defineKey);\nconst get = __webpack_require__(/*! ../get */ \"../server/node_modules/mongoose/lib/helpers/get.js\");\nconst utils = __webpack_require__(/*! ../../utils */ \"../server/node_modules/mongoose/lib/utils.js\");\nconst mergeDiscriminatorSchema = __webpack_require__(/*! ../../helpers/discriminator/mergeDiscriminatorSchema */ \"../server/node_modules/mongoose/lib/helpers/discriminator/mergeDiscriminatorSchema.js\");\n\nconst CUSTOMIZABLE_DISCRIMINATOR_OPTIONS = {\n  toJSON: true,\n  toObject: true,\n  _id: true,\n  id: true,\n  virtuals: true,\n  methods: true\n};\n\n/*!\n * ignore\n */\n\nmodule.exports = function discriminator(model, name, schema, tiedValue, applyPlugins, mergeHooks) {\n  if (!(schema && schema.instanceOfSchema)) {\n    throw new Error('You must pass a valid discriminator Schema');\n  }\n\n  mergeHooks = mergeHooks == null ? true : mergeHooks;\n\n  if (model.schema.discriminatorMapping &&\n      !model.schema.discriminatorMapping.isRoot) {\n    throw new Error('Discriminator \"' + name +\n        '\" can only be a discriminator of the root model');\n  }\n\n  if (applyPlugins) {\n    const applyPluginsToDiscriminators = get(model.base,\n      'options.applyPluginsToDiscriminators', false) || !mergeHooks;\n    // Even if `applyPluginsToDiscriminators` isn't set, we should still apply\n    // global plugins to schemas embedded in the discriminator schema (gh-7370)\n    model.base._applyPlugins(schema, {\n      skipTopLevel: !applyPluginsToDiscriminators\n    });\n  } else if (!mergeHooks) {\n    applyBuiltinPlugins(schema);\n  }\n\n  const key = model.schema.options.discriminatorKey;\n\n  const existingPath = model.schema.path(key);\n  if (existingPath != null) {\n    if (!utils.hasUserDefinedProperty(existingPath.options, 'select')) {\n      existingPath.options.select = true;\n    }\n    existingPath.options.$skipDiscriminatorCheck = true;\n  } else {\n    const baseSchemaAddition = {};\n    baseSchemaAddition[key] = {\n      default: void 0,\n      select: true,\n      $skipDiscriminatorCheck: true\n    };\n    baseSchemaAddition[key][model.schema.options.typeKey] = String;\n    model.schema.add(baseSchemaAddition);\n    defineKey({\n      prop: key,\n      prototype: model.prototype,\n      options: model.schema.options\n    });\n  }\n\n  if (schema.path(key) && schema.path(key).options.$skipDiscriminatorCheck !== true) {\n    throw new Error('Discriminator \"' + name +\n        '\" cannot have field with name \"' + key + '\"');\n  }\n\n  let value = name;\n  if ((typeof tiedValue === 'string' && tiedValue.length) || tiedValue != null) {\n    value = tiedValue;\n  }\n\n  function merge(schema, baseSchema) {\n    // Retain original schema before merging base schema\n    schema._baseSchema = baseSchema;\n    if (baseSchema.paths._id &&\n        baseSchema.paths._id.options &&\n        !baseSchema.paths._id.options.auto) {\n      schema.remove('_id');\n    }\n\n    // Find conflicting paths: if something is a path in the base schema\n    // and a nested path in the child schema, overwrite the base schema path.\n    // See gh-6076\n    const baseSchemaPaths = Object.keys(baseSchema.paths);\n    const conflictingPaths = [];\n\n    for (const path of baseSchemaPaths) {\n      if (schema.nested[path]) {\n        conflictingPaths.push(path);\n        continue;\n      }\n\n      if (path.indexOf('.') === -1) {\n        continue;\n      }\n      const sp = path.split('.').slice(0, -1);\n      let cur = '';\n      for (const piece of sp) {\n        cur += (cur.length ? '.' : '') + piece;\n        if (schema.paths[cur] instanceof Mixed ||\n            schema.singleNestedPaths[cur] instanceof Mixed) {\n          conflictingPaths.push(path);\n        }\n      }\n    }\n\n    mergeDiscriminatorSchema(schema, baseSchema);\n\n    // Clean up conflicting paths _after_ merging re: gh-6076\n    for (const conflictingPath of conflictingPaths) {\n      delete schema.paths[conflictingPath];\n    }\n\n    // Rebuild schema models because schemas may have been merged re: #7884\n    schema.childSchemas.forEach(obj => {\n      obj.model.prototype.$__setSchema(obj.schema);\n    });\n\n    const obj = {};\n    obj[key] = {\n      default: value,\n      select: true,\n      set: function(newName) {\n        if (newName === value || (Array.isArray(value) && utils.deepEqual(newName, value))) {\n          return value;\n        }\n        throw new Error('Can\\'t set discriminator key \"' + key + '\"');\n      },\n      $skipDiscriminatorCheck: true\n    };\n    obj[key][schema.options.typeKey] = existingPath ? existingPath.options[schema.options.typeKey] : String;\n    schema.add(obj);\n\n    schema.discriminatorMapping = { key: key, value: value, isRoot: false };\n\n    if (baseSchema.options.collection) {\n      schema.options.collection = baseSchema.options.collection;\n    }\n    const toJSON = schema.options.toJSON;\n    const toObject = schema.options.toObject;\n    const _id = schema.options._id;\n    const id = schema.options.id;\n\n    const keys = Object.keys(schema.options);\n    schema.options.discriminatorKey = baseSchema.options.discriminatorKey;\n    const userProvidedOptions = schema._userProvidedOptions;\n    for (const _key of keys) {\n      if (!CUSTOMIZABLE_DISCRIMINATOR_OPTIONS[_key]) {\n        // Use `schema.options` in `deepEqual()` because of `discriminatorKey`\n        // set above. We don't allow customizing discriminator key, always\n        // overwrite. See gh-9238\n        if (_key in userProvidedOptions && !utils.deepEqual(schema.options[_key], baseSchema.options[_key])) {\n          throw new Error('Can\\'t customize discriminator option ' + _key +\n            ' (can only modify ' +\n            Object.keys(CUSTOMIZABLE_DISCRIMINATOR_OPTIONS).join(', ') +\n            ')');\n        }\n      }\n    }\n    schema.options = clone(baseSchema.options);\n\n    for (const _key of Object.keys(userProvidedOptions)) {\n      schema.options[_key] = userProvidedOptions[_key];\n    }\n    if (toJSON) schema.options.toJSON = toJSON;\n    if (toObject) schema.options.toObject = toObject;\n    if (typeof _id !== 'undefined') {\n      schema.options._id = _id;\n    }\n    schema.options.id = id;\n    if (mergeHooks) {\n      schema.s.hooks = model.schema.s.hooks.merge(schema.s.hooks);\n    }\n    if (applyPlugins) {\n      schema.plugins = Array.prototype.slice.call(baseSchema.plugins);\n    }\n    schema.callQueue = baseSchema.callQueue.concat(schema.callQueue);\n    delete schema._requiredpaths; // reset just in case Schema#requiredPaths() was called on either schema\n  }\n\n  // merges base schema into new discriminator schema and sets new type field.\n  merge(schema, model.schema);\n\n  if (!model.discriminators) {\n    model.discriminators = {};\n  }\n\n  if (!model.schema.discriminatorMapping) {\n    model.schema.discriminatorMapping = { key: key, value: null, isRoot: true };\n  }\n  if (!model.schema.discriminators) {\n    model.schema.discriminators = {};\n  }\n\n  model.schema.discriminators[name] = schema;\n\n  if (model.discriminators[name] && !schema.options.overwriteModels) {\n    throw new Error('Discriminator with name \"' + name + '\" already exists');\n  }\n\n  return schema;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9tb2RlbC9kaXNjcmltaW5hdG9yLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLGNBQWMsbUJBQU8sQ0FBQywrRUFBb0I7QUFDMUMsNEJBQTRCLG1CQUFPLENBQUMsZ0hBQStCO0FBQ25FLGNBQWMsbUJBQU8sQ0FBQyxzRUFBVTtBQUNoQyxrQkFBa0IsNkhBQXdDO0FBQzFELFlBQVksbUJBQU8sQ0FBQyxrRUFBUTtBQUM1QixjQUFjLG1CQUFPLENBQUMsaUVBQWE7QUFDbkMsaUNBQWlDLG1CQUFPLENBQUMsbUpBQXNEOztBQUUvRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0NBQW9DOztBQUVwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2xpZW50Ly4uL3NlcnZlci9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvbW9kZWwvZGlzY3JpbWluYXRvci5qcz8yZDFkIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3QgTWl4ZWQgPSByZXF1aXJlKCcuLi8uLi9zY2hlbWEvbWl4ZWQnKTtcbmNvbnN0IGFwcGx5QnVpbHRpblBsdWdpbnMgPSByZXF1aXJlKCcuLi9zY2hlbWEvYXBwbHlCdWlsdGluUGx1Z2lucycpO1xuY29uc3QgY2xvbmUgPSByZXF1aXJlKCcuLi9jbG9uZScpO1xuY29uc3QgZGVmaW5lS2V5ID0gcmVxdWlyZSgnLi4vZG9jdW1lbnQvY29tcGlsZScpLmRlZmluZUtleTtcbmNvbnN0IGdldCA9IHJlcXVpcmUoJy4uL2dldCcpO1xuY29uc3QgdXRpbHMgPSByZXF1aXJlKCcuLi8uLi91dGlscycpO1xuY29uc3QgbWVyZ2VEaXNjcmltaW5hdG9yU2NoZW1hID0gcmVxdWlyZSgnLi4vLi4vaGVscGVycy9kaXNjcmltaW5hdG9yL21lcmdlRGlzY3JpbWluYXRvclNjaGVtYScpO1xuXG5jb25zdCBDVVNUT01JWkFCTEVfRElTQ1JJTUlOQVRPUl9PUFRJT05TID0ge1xuICB0b0pTT046IHRydWUsXG4gIHRvT2JqZWN0OiB0cnVlLFxuICBfaWQ6IHRydWUsXG4gIGlkOiB0cnVlLFxuICB2aXJ0dWFsczogdHJ1ZSxcbiAgbWV0aG9kczogdHJ1ZVxufTtcblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGRpc2NyaW1pbmF0b3IobW9kZWwsIG5hbWUsIHNjaGVtYSwgdGllZFZhbHVlLCBhcHBseVBsdWdpbnMsIG1lcmdlSG9va3MpIHtcbiAgaWYgKCEoc2NoZW1hICYmIHNjaGVtYS5pbnN0YW5jZU9mU2NoZW1hKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignWW91IG11c3QgcGFzcyBhIHZhbGlkIGRpc2NyaW1pbmF0b3IgU2NoZW1hJyk7XG4gIH1cblxuICBtZXJnZUhvb2tzID0gbWVyZ2VIb29rcyA9PSBudWxsID8gdHJ1ZSA6IG1lcmdlSG9va3M7XG5cbiAgaWYgKG1vZGVsLnNjaGVtYS5kaXNjcmltaW5hdG9yTWFwcGluZyAmJlxuICAgICAgIW1vZGVsLnNjaGVtYS5kaXNjcmltaW5hdG9yTWFwcGluZy5pc1Jvb3QpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0Rpc2NyaW1pbmF0b3IgXCInICsgbmFtZSArXG4gICAgICAgICdcIiBjYW4gb25seSBiZSBhIGRpc2NyaW1pbmF0b3Igb2YgdGhlIHJvb3QgbW9kZWwnKTtcbiAgfVxuXG4gIGlmIChhcHBseVBsdWdpbnMpIHtcbiAgICBjb25zdCBhcHBseVBsdWdpbnNUb0Rpc2NyaW1pbmF0b3JzID0gZ2V0KG1vZGVsLmJhc2UsXG4gICAgICAnb3B0aW9ucy5hcHBseVBsdWdpbnNUb0Rpc2NyaW1pbmF0b3JzJywgZmFsc2UpIHx8ICFtZXJnZUhvb2tzO1xuICAgIC8vIEV2ZW4gaWYgYGFwcGx5UGx1Z2luc1RvRGlzY3JpbWluYXRvcnNgIGlzbid0IHNldCwgd2Ugc2hvdWxkIHN0aWxsIGFwcGx5XG4gICAgLy8gZ2xvYmFsIHBsdWdpbnMgdG8gc2NoZW1hcyBlbWJlZGRlZCBpbiB0aGUgZGlzY3JpbWluYXRvciBzY2hlbWEgKGdoLTczNzApXG4gICAgbW9kZWwuYmFzZS5fYXBwbHlQbHVnaW5zKHNjaGVtYSwge1xuICAgICAgc2tpcFRvcExldmVsOiAhYXBwbHlQbHVnaW5zVG9EaXNjcmltaW5hdG9yc1xuICAgIH0pO1xuICB9IGVsc2UgaWYgKCFtZXJnZUhvb2tzKSB7XG4gICAgYXBwbHlCdWlsdGluUGx1Z2lucyhzY2hlbWEpO1xuICB9XG5cbiAgY29uc3Qga2V5ID0gbW9kZWwuc2NoZW1hLm9wdGlvbnMuZGlzY3JpbWluYXRvcktleTtcblxuICBjb25zdCBleGlzdGluZ1BhdGggPSBtb2RlbC5zY2hlbWEucGF0aChrZXkpO1xuICBpZiAoZXhpc3RpbmdQYXRoICE9IG51bGwpIHtcbiAgICBpZiAoIXV0aWxzLmhhc1VzZXJEZWZpbmVkUHJvcGVydHkoZXhpc3RpbmdQYXRoLm9wdGlvbnMsICdzZWxlY3QnKSkge1xuICAgICAgZXhpc3RpbmdQYXRoLm9wdGlvbnMuc2VsZWN0ID0gdHJ1ZTtcbiAgICB9XG4gICAgZXhpc3RpbmdQYXRoLm9wdGlvbnMuJHNraXBEaXNjcmltaW5hdG9yQ2hlY2sgPSB0cnVlO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IGJhc2VTY2hlbWFBZGRpdGlvbiA9IHt9O1xuICAgIGJhc2VTY2hlbWFBZGRpdGlvbltrZXldID0ge1xuICAgICAgZGVmYXVsdDogdm9pZCAwLFxuICAgICAgc2VsZWN0OiB0cnVlLFxuICAgICAgJHNraXBEaXNjcmltaW5hdG9yQ2hlY2s6IHRydWVcbiAgICB9O1xuICAgIGJhc2VTY2hlbWFBZGRpdGlvbltrZXldW21vZGVsLnNjaGVtYS5vcHRpb25zLnR5cGVLZXldID0gU3RyaW5nO1xuICAgIG1vZGVsLnNjaGVtYS5hZGQoYmFzZVNjaGVtYUFkZGl0aW9uKTtcbiAgICBkZWZpbmVLZXkoe1xuICAgICAgcHJvcDoga2V5LFxuICAgICAgcHJvdG90eXBlOiBtb2RlbC5wcm90b3R5cGUsXG4gICAgICBvcHRpb25zOiBtb2RlbC5zY2hlbWEub3B0aW9uc1xuICAgIH0pO1xuICB9XG5cbiAgaWYgKHNjaGVtYS5wYXRoKGtleSkgJiYgc2NoZW1hLnBhdGgoa2V5KS5vcHRpb25zLiRza2lwRGlzY3JpbWluYXRvckNoZWNrICE9PSB0cnVlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdEaXNjcmltaW5hdG9yIFwiJyArIG5hbWUgK1xuICAgICAgICAnXCIgY2Fubm90IGhhdmUgZmllbGQgd2l0aCBuYW1lIFwiJyArIGtleSArICdcIicpO1xuICB9XG5cbiAgbGV0IHZhbHVlID0gbmFtZTtcbiAgaWYgKCh0eXBlb2YgdGllZFZhbHVlID09PSAnc3RyaW5nJyAmJiB0aWVkVmFsdWUubGVuZ3RoKSB8fCB0aWVkVmFsdWUgIT0gbnVsbCkge1xuICAgIHZhbHVlID0gdGllZFZhbHVlO1xuICB9XG5cbiAgZnVuY3Rpb24gbWVyZ2Uoc2NoZW1hLCBiYXNlU2NoZW1hKSB7XG4gICAgLy8gUmV0YWluIG9yaWdpbmFsIHNjaGVtYSBiZWZvcmUgbWVyZ2luZyBiYXNlIHNjaGVtYVxuICAgIHNjaGVtYS5fYmFzZVNjaGVtYSA9IGJhc2VTY2hlbWE7XG4gICAgaWYgKGJhc2VTY2hlbWEucGF0aHMuX2lkICYmXG4gICAgICAgIGJhc2VTY2hlbWEucGF0aHMuX2lkLm9wdGlvbnMgJiZcbiAgICAgICAgIWJhc2VTY2hlbWEucGF0aHMuX2lkLm9wdGlvbnMuYXV0bykge1xuICAgICAgc2NoZW1hLnJlbW92ZSgnX2lkJyk7XG4gICAgfVxuXG4gICAgLy8gRmluZCBjb25mbGljdGluZyBwYXRoczogaWYgc29tZXRoaW5nIGlzIGEgcGF0aCBpbiB0aGUgYmFzZSBzY2hlbWFcbiAgICAvLyBhbmQgYSBuZXN0ZWQgcGF0aCBpbiB0aGUgY2hpbGQgc2NoZW1hLCBvdmVyd3JpdGUgdGhlIGJhc2Ugc2NoZW1hIHBhdGguXG4gICAgLy8gU2VlIGdoLTYwNzZcbiAgICBjb25zdCBiYXNlU2NoZW1hUGF0aHMgPSBPYmplY3Qua2V5cyhiYXNlU2NoZW1hLnBhdGhzKTtcbiAgICBjb25zdCBjb25mbGljdGluZ1BhdGhzID0gW107XG5cbiAgICBmb3IgKGNvbnN0IHBhdGggb2YgYmFzZVNjaGVtYVBhdGhzKSB7XG4gICAgICBpZiAoc2NoZW1hLm5lc3RlZFtwYXRoXSkge1xuICAgICAgICBjb25mbGljdGluZ1BhdGhzLnB1c2gocGF0aCk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAocGF0aC5pbmRleE9mKCcuJykgPT09IC0xKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgY29uc3Qgc3AgPSBwYXRoLnNwbGl0KCcuJykuc2xpY2UoMCwgLTEpO1xuICAgICAgbGV0IGN1ciA9ICcnO1xuICAgICAgZm9yIChjb25zdCBwaWVjZSBvZiBzcCkge1xuICAgICAgICBjdXIgKz0gKGN1ci5sZW5ndGggPyAnLicgOiAnJykgKyBwaWVjZTtcbiAgICAgICAgaWYgKHNjaGVtYS5wYXRoc1tjdXJdIGluc3RhbmNlb2YgTWl4ZWQgfHxcbiAgICAgICAgICAgIHNjaGVtYS5zaW5nbGVOZXN0ZWRQYXRoc1tjdXJdIGluc3RhbmNlb2YgTWl4ZWQpIHtcbiAgICAgICAgICBjb25mbGljdGluZ1BhdGhzLnB1c2gocGF0aCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBtZXJnZURpc2NyaW1pbmF0b3JTY2hlbWEoc2NoZW1hLCBiYXNlU2NoZW1hKTtcblxuICAgIC8vIENsZWFuIHVwIGNvbmZsaWN0aW5nIHBhdGhzIF9hZnRlcl8gbWVyZ2luZyByZTogZ2gtNjA3NlxuICAgIGZvciAoY29uc3QgY29uZmxpY3RpbmdQYXRoIG9mIGNvbmZsaWN0aW5nUGF0aHMpIHtcbiAgICAgIGRlbGV0ZSBzY2hlbWEucGF0aHNbY29uZmxpY3RpbmdQYXRoXTtcbiAgICB9XG5cbiAgICAvLyBSZWJ1aWxkIHNjaGVtYSBtb2RlbHMgYmVjYXVzZSBzY2hlbWFzIG1heSBoYXZlIGJlZW4gbWVyZ2VkIHJlOiAjNzg4NFxuICAgIHNjaGVtYS5jaGlsZFNjaGVtYXMuZm9yRWFjaChvYmogPT4ge1xuICAgICAgb2JqLm1vZGVsLnByb3RvdHlwZS4kX19zZXRTY2hlbWEob2JqLnNjaGVtYSk7XG4gICAgfSk7XG5cbiAgICBjb25zdCBvYmogPSB7fTtcbiAgICBvYmpba2V5XSA9IHtcbiAgICAgIGRlZmF1bHQ6IHZhbHVlLFxuICAgICAgc2VsZWN0OiB0cnVlLFxuICAgICAgc2V0OiBmdW5jdGlvbihuZXdOYW1lKSB7XG4gICAgICAgIGlmIChuZXdOYW1lID09PSB2YWx1ZSB8fCAoQXJyYXkuaXNBcnJheSh2YWx1ZSkgJiYgdXRpbHMuZGVlcEVxdWFsKG5ld05hbWUsIHZhbHVlKSkpIHtcbiAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5cXCd0IHNldCBkaXNjcmltaW5hdG9yIGtleSBcIicgKyBrZXkgKyAnXCInKTtcbiAgICAgIH0sXG4gICAgICAkc2tpcERpc2NyaW1pbmF0b3JDaGVjazogdHJ1ZVxuICAgIH07XG4gICAgb2JqW2tleV1bc2NoZW1hLm9wdGlvbnMudHlwZUtleV0gPSBleGlzdGluZ1BhdGggPyBleGlzdGluZ1BhdGgub3B0aW9uc1tzY2hlbWEub3B0aW9ucy50eXBlS2V5XSA6IFN0cmluZztcbiAgICBzY2hlbWEuYWRkKG9iaik7XG5cbiAgICBzY2hlbWEuZGlzY3JpbWluYXRvck1hcHBpbmcgPSB7IGtleToga2V5LCB2YWx1ZTogdmFsdWUsIGlzUm9vdDogZmFsc2UgfTtcblxuICAgIGlmIChiYXNlU2NoZW1hLm9wdGlvbnMuY29sbGVjdGlvbikge1xuICAgICAgc2NoZW1hLm9wdGlvbnMuY29sbGVjdGlvbiA9IGJhc2VTY2hlbWEub3B0aW9ucy5jb2xsZWN0aW9uO1xuICAgIH1cbiAgICBjb25zdCB0b0pTT04gPSBzY2hlbWEub3B0aW9ucy50b0pTT047XG4gICAgY29uc3QgdG9PYmplY3QgPSBzY2hlbWEub3B0aW9ucy50b09iamVjdDtcbiAgICBjb25zdCBfaWQgPSBzY2hlbWEub3B0aW9ucy5faWQ7XG4gICAgY29uc3QgaWQgPSBzY2hlbWEub3B0aW9ucy5pZDtcblxuICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhzY2hlbWEub3B0aW9ucyk7XG4gICAgc2NoZW1hLm9wdGlvbnMuZGlzY3JpbWluYXRvcktleSA9IGJhc2VTY2hlbWEub3B0aW9ucy5kaXNjcmltaW5hdG9yS2V5O1xuICAgIGNvbnN0IHVzZXJQcm92aWRlZE9wdGlvbnMgPSBzY2hlbWEuX3VzZXJQcm92aWRlZE9wdGlvbnM7XG4gICAgZm9yIChjb25zdCBfa2V5IG9mIGtleXMpIHtcbiAgICAgIGlmICghQ1VTVE9NSVpBQkxFX0RJU0NSSU1JTkFUT1JfT1BUSU9OU1tfa2V5XSkge1xuICAgICAgICAvLyBVc2UgYHNjaGVtYS5vcHRpb25zYCBpbiBgZGVlcEVxdWFsKClgIGJlY2F1c2Ugb2YgYGRpc2NyaW1pbmF0b3JLZXlgXG4gICAgICAgIC8vIHNldCBhYm92ZS4gV2UgZG9uJ3QgYWxsb3cgY3VzdG9taXppbmcgZGlzY3JpbWluYXRvciBrZXksIGFsd2F5c1xuICAgICAgICAvLyBvdmVyd3JpdGUuIFNlZSBnaC05MjM4XG4gICAgICAgIGlmIChfa2V5IGluIHVzZXJQcm92aWRlZE9wdGlvbnMgJiYgIXV0aWxzLmRlZXBFcXVhbChzY2hlbWEub3B0aW9uc1tfa2V5XSwgYmFzZVNjaGVtYS5vcHRpb25zW19rZXldKSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2FuXFwndCBjdXN0b21pemUgZGlzY3JpbWluYXRvciBvcHRpb24gJyArIF9rZXkgK1xuICAgICAgICAgICAgJyAoY2FuIG9ubHkgbW9kaWZ5ICcgK1xuICAgICAgICAgICAgT2JqZWN0LmtleXMoQ1VTVE9NSVpBQkxFX0RJU0NSSU1JTkFUT1JfT1BUSU9OUykuam9pbignLCAnKSArXG4gICAgICAgICAgICAnKScpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHNjaGVtYS5vcHRpb25zID0gY2xvbmUoYmFzZVNjaGVtYS5vcHRpb25zKTtcblxuICAgIGZvciAoY29uc3QgX2tleSBvZiBPYmplY3Qua2V5cyh1c2VyUHJvdmlkZWRPcHRpb25zKSkge1xuICAgICAgc2NoZW1hLm9wdGlvbnNbX2tleV0gPSB1c2VyUHJvdmlkZWRPcHRpb25zW19rZXldO1xuICAgIH1cbiAgICBpZiAodG9KU09OKSBzY2hlbWEub3B0aW9ucy50b0pTT04gPSB0b0pTT047XG4gICAgaWYgKHRvT2JqZWN0KSBzY2hlbWEub3B0aW9ucy50b09iamVjdCA9IHRvT2JqZWN0O1xuICAgIGlmICh0eXBlb2YgX2lkICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgc2NoZW1hLm9wdGlvbnMuX2lkID0gX2lkO1xuICAgIH1cbiAgICBzY2hlbWEub3B0aW9ucy5pZCA9IGlkO1xuICAgIGlmIChtZXJnZUhvb2tzKSB7XG4gICAgICBzY2hlbWEucy5ob29rcyA9IG1vZGVsLnNjaGVtYS5zLmhvb2tzLm1lcmdlKHNjaGVtYS5zLmhvb2tzKTtcbiAgICB9XG4gICAgaWYgKGFwcGx5UGx1Z2lucykge1xuICAgICAgc2NoZW1hLnBsdWdpbnMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChiYXNlU2NoZW1hLnBsdWdpbnMpO1xuICAgIH1cbiAgICBzY2hlbWEuY2FsbFF1ZXVlID0gYmFzZVNjaGVtYS5jYWxsUXVldWUuY29uY2F0KHNjaGVtYS5jYWxsUXVldWUpO1xuICAgIGRlbGV0ZSBzY2hlbWEuX3JlcXVpcmVkcGF0aHM7IC8vIHJlc2V0IGp1c3QgaW4gY2FzZSBTY2hlbWEjcmVxdWlyZWRQYXRocygpIHdhcyBjYWxsZWQgb24gZWl0aGVyIHNjaGVtYVxuICB9XG5cbiAgLy8gbWVyZ2VzIGJhc2Ugc2NoZW1hIGludG8gbmV3IGRpc2NyaW1pbmF0b3Igc2NoZW1hIGFuZCBzZXRzIG5ldyB0eXBlIGZpZWxkLlxuICBtZXJnZShzY2hlbWEsIG1vZGVsLnNjaGVtYSk7XG5cbiAgaWYgKCFtb2RlbC5kaXNjcmltaW5hdG9ycykge1xuICAgIG1vZGVsLmRpc2NyaW1pbmF0b3JzID0ge307XG4gIH1cblxuICBpZiAoIW1vZGVsLnNjaGVtYS5kaXNjcmltaW5hdG9yTWFwcGluZykge1xuICAgIG1vZGVsLnNjaGVtYS5kaXNjcmltaW5hdG9yTWFwcGluZyA9IHsga2V5OiBrZXksIHZhbHVlOiBudWxsLCBpc1Jvb3Q6IHRydWUgfTtcbiAgfVxuICBpZiAoIW1vZGVsLnNjaGVtYS5kaXNjcmltaW5hdG9ycykge1xuICAgIG1vZGVsLnNjaGVtYS5kaXNjcmltaW5hdG9ycyA9IHt9O1xuICB9XG5cbiAgbW9kZWwuc2NoZW1hLmRpc2NyaW1pbmF0b3JzW25hbWVdID0gc2NoZW1hO1xuXG4gIGlmIChtb2RlbC5kaXNjcmltaW5hdG9yc1tuYW1lXSAmJiAhc2NoZW1hLm9wdGlvbnMub3ZlcndyaXRlTW9kZWxzKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdEaXNjcmltaW5hdG9yIHdpdGggbmFtZSBcIicgKyBuYW1lICsgJ1wiIGFscmVhZHkgZXhpc3RzJyk7XG4gIH1cblxuICByZXR1cm4gc2NoZW1hO1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../server/node_modules/mongoose/lib/helpers/model/discriminator.js\n");

/***/ }),

/***/ "../server/node_modules/mongoose/lib/helpers/model/pushNestedArrayPaths.js":
/*!*********************************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/helpers/model/pushNestedArrayPaths.js ***!
  \*********************************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nmodule.exports = function pushNestedArrayPaths(paths, nestedArray, path) {\n  if (nestedArray == null) {\n    return;\n  }\n\n  for (let i = 0; i < nestedArray.length; ++i) {\n    if (Array.isArray(nestedArray[i])) {\n      pushNestedArrayPaths(paths, nestedArray[i], path + '.' + i);\n    } else {\n      paths.push(path + '.' + i);\n    }\n  }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9tb2RlbC9wdXNoTmVzdGVkQXJyYXlQYXRocy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0Isd0JBQXdCO0FBQzFDO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbGllbnQvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9tb2RlbC9wdXNoTmVzdGVkQXJyYXlQYXRocy5qcz85ZGUzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBwdXNoTmVzdGVkQXJyYXlQYXRocyhwYXRocywgbmVzdGVkQXJyYXksIHBhdGgpIHtcbiAgaWYgKG5lc3RlZEFycmF5ID09IG51bGwpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBmb3IgKGxldCBpID0gMDsgaSA8IG5lc3RlZEFycmF5Lmxlbmd0aDsgKytpKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkobmVzdGVkQXJyYXlbaV0pKSB7XG4gICAgICBwdXNoTmVzdGVkQXJyYXlQYXRocyhwYXRocywgbmVzdGVkQXJyYXlbaV0sIHBhdGggKyAnLicgKyBpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcGF0aHMucHVzaChwYXRoICsgJy4nICsgaSk7XG4gICAgfVxuICB9XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../server/node_modules/mongoose/lib/helpers/model/pushNestedArrayPaths.js\n");

/***/ }),

/***/ "../server/node_modules/mongoose/lib/helpers/parallelLimit.js":
/*!********************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/helpers/parallelLimit.js ***!
  \********************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nmodule.exports = parallelLimit;\n\n/*!\n * ignore\n */\n\nfunction parallelLimit(fns, limit, callback) {\n  let numInProgress = 0;\n  let numFinished = 0;\n  let error = null;\n\n  if (limit <= 0) {\n    throw new Error('Limit must be positive');\n  }\n\n  if (fns.length === 0) {\n    return callback(null, []);\n  }\n\n  for (let i = 0; i < fns.length && i < limit; ++i) {\n    _start();\n  }\n\n  function _start() {\n    fns[numFinished + numInProgress](_done(numFinished + numInProgress));\n    ++numInProgress;\n  }\n\n  const results = [];\n\n  function _done(index) {\n    return (err, res) => {\n      --numInProgress;\n      ++numFinished;\n\n      if (error != null) {\n        return;\n      }\n      if (err != null) {\n        error = err;\n        return callback(error);\n      }\n\n      results[index] = res;\n\n      if (numFinished === fns.length) {\n        return callback(null, results);\n      } else if (numFinished + numInProgress < fns.length) {\n        _start();\n      }\n    };\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9wYXJhbGxlbExpbWl0LmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGtCQUFrQiw2QkFBNkI7QUFDL0M7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbGllbnQvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9wYXJhbGxlbExpbWl0LmpzP2I4MzQiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHBhcmFsbGVsTGltaXQ7XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxuZnVuY3Rpb24gcGFyYWxsZWxMaW1pdChmbnMsIGxpbWl0LCBjYWxsYmFjaykge1xuICBsZXQgbnVtSW5Qcm9ncmVzcyA9IDA7XG4gIGxldCBudW1GaW5pc2hlZCA9IDA7XG4gIGxldCBlcnJvciA9IG51bGw7XG5cbiAgaWYgKGxpbWl0IDw9IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0xpbWl0IG11c3QgYmUgcG9zaXRpdmUnKTtcbiAgfVxuXG4gIGlmIChmbnMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsIFtdKTtcbiAgfVxuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgZm5zLmxlbmd0aCAmJiBpIDwgbGltaXQ7ICsraSkge1xuICAgIF9zdGFydCgpO1xuICB9XG5cbiAgZnVuY3Rpb24gX3N0YXJ0KCkge1xuICAgIGZuc1tudW1GaW5pc2hlZCArIG51bUluUHJvZ3Jlc3NdKF9kb25lKG51bUZpbmlzaGVkICsgbnVtSW5Qcm9ncmVzcykpO1xuICAgICsrbnVtSW5Qcm9ncmVzcztcbiAgfVxuXG4gIGNvbnN0IHJlc3VsdHMgPSBbXTtcblxuICBmdW5jdGlvbiBfZG9uZShpbmRleCkge1xuICAgIHJldHVybiAoZXJyLCByZXMpID0+IHtcbiAgICAgIC0tbnVtSW5Qcm9ncmVzcztcbiAgICAgICsrbnVtRmluaXNoZWQ7XG5cbiAgICAgIGlmIChlcnJvciAhPSBudWxsKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChlcnIgIT0gbnVsbCkge1xuICAgICAgICBlcnJvciA9IGVycjtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycm9yKTtcbiAgICAgIH1cblxuICAgICAgcmVzdWx0c1tpbmRleF0gPSByZXM7XG5cbiAgICAgIGlmIChudW1GaW5pc2hlZCA9PT0gZm5zLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCwgcmVzdWx0cyk7XG4gICAgICB9IGVsc2UgaWYgKG51bUZpbmlzaGVkICsgbnVtSW5Qcm9ncmVzcyA8IGZucy5sZW5ndGgpIHtcbiAgICAgICAgX3N0YXJ0KCk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../server/node_modules/mongoose/lib/helpers/parallelLimit.js\n");

/***/ }),

/***/ "../server/node_modules/mongoose/lib/helpers/path/parentPaths.js":
/*!***********************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/helpers/path/parentPaths.js ***!
  \***********************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nconst dotRE = /\\./g;\nmodule.exports = function parentPaths(path) {\n  if (path.indexOf('.') === -1) {\n    return [path];\n  }\n  const pieces = path.split(dotRE);\n  const len = pieces.length;\n  const ret = new Array(len);\n  let cur = '';\n  for (let i = 0; i < len; ++i) {\n    cur += (cur.length !== 0) ? '.' + pieces[i] : pieces[i];\n    ret[i] = cur;\n  }\n\n  return ret;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9wYXRoL3BhcmVudFBhdGhzLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixTQUFTO0FBQzNCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2xpZW50Ly4uL3NlcnZlci9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvcGF0aC9wYXJlbnRQYXRocy5qcz85YzRhIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3QgZG90UkUgPSAvXFwuL2c7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHBhcmVudFBhdGhzKHBhdGgpIHtcbiAgaWYgKHBhdGguaW5kZXhPZignLicpID09PSAtMSkge1xuICAgIHJldHVybiBbcGF0aF07XG4gIH1cbiAgY29uc3QgcGllY2VzID0gcGF0aC5zcGxpdChkb3RSRSk7XG4gIGNvbnN0IGxlbiA9IHBpZWNlcy5sZW5ndGg7XG4gIGNvbnN0IHJldCA9IG5ldyBBcnJheShsZW4pO1xuICBsZXQgY3VyID0gJyc7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICBjdXIgKz0gKGN1ci5sZW5ndGggIT09IDApID8gJy4nICsgcGllY2VzW2ldIDogcGllY2VzW2ldO1xuICAgIHJldFtpXSA9IGN1cjtcbiAgfVxuXG4gIHJldHVybiByZXQ7XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../server/node_modules/mongoose/lib/helpers/path/parentPaths.js\n");

/***/ }),

/***/ "../server/node_modules/mongoose/lib/helpers/path/setDottedPath.js":
/*!*************************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/helpers/path/setDottedPath.js ***!
  \*************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst specialProperties = __webpack_require__(/*! ../specialProperties */ \"../server/node_modules/mongoose/lib/helpers/specialProperties.js\");\n\n\nmodule.exports = function setDottedPath(obj, path, val) {\n  if (path.indexOf('.') === -1) {\n    if (specialProperties.has(path)) {\n      return;\n    }\n\n    obj[path] = val;\n    return;\n  }\n  const parts = path.split('.');\n\n  const last = parts.pop();\n  let cur = obj;\n  for (const part of parts) {\n    if (specialProperties.has(part)) {\n      continue;\n    }\n    if (cur[part] == null) {\n      cur[part] = {};\n    }\n\n    cur = cur[part];\n  }\n\n  if (!specialProperties.has(last)) {\n    cur[last] = val;\n  }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9wYXRoL3NldERvdHRlZFBhdGguanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsMEJBQTBCLG1CQUFPLENBQUMsOEZBQXNCOzs7QUFHeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2NsaWVudC8uLi9zZXJ2ZXIvbm9kZV9tb2R1bGVzL21vbmdvb3NlL2xpYi9oZWxwZXJzL3BhdGgvc2V0RG90dGVkUGF0aC5qcz9iYWFkIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3Qgc3BlY2lhbFByb3BlcnRpZXMgPSByZXF1aXJlKCcuLi9zcGVjaWFsUHJvcGVydGllcycpO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gc2V0RG90dGVkUGF0aChvYmosIHBhdGgsIHZhbCkge1xuICBpZiAocGF0aC5pbmRleE9mKCcuJykgPT09IC0xKSB7XG4gICAgaWYgKHNwZWNpYWxQcm9wZXJ0aWVzLmhhcyhwYXRoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIG9ialtwYXRoXSA9IHZhbDtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgcGFydHMgPSBwYXRoLnNwbGl0KCcuJyk7XG5cbiAgY29uc3QgbGFzdCA9IHBhcnRzLnBvcCgpO1xuICBsZXQgY3VyID0gb2JqO1xuICBmb3IgKGNvbnN0IHBhcnQgb2YgcGFydHMpIHtcbiAgICBpZiAoc3BlY2lhbFByb3BlcnRpZXMuaGFzKHBhcnQpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKGN1cltwYXJ0XSA9PSBudWxsKSB7XG4gICAgICBjdXJbcGFydF0gPSB7fTtcbiAgICB9XG5cbiAgICBjdXIgPSBjdXJbcGFydF07XG4gIH1cblxuICBpZiAoIXNwZWNpYWxQcm9wZXJ0aWVzLmhhcyhsYXN0KSkge1xuICAgIGN1cltsYXN0XSA9IHZhbDtcbiAgfVxufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../server/node_modules/mongoose/lib/helpers/path/setDottedPath.js\n");

/***/ }),

/***/ "../server/node_modules/mongoose/lib/helpers/pluralize.js":
/*!****************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/helpers/pluralize.js ***!
  \****************************************************************/
/***/ ((module, exports) => {

"use strict";
eval("\n\nmodule.exports = pluralize;\n\n/**\n * Pluralization rules.\n */\n\nexports.pluralization = [\n  [/human$/gi, 'humans'],\n  [/(m)an$/gi, '$1en'],\n  [/(pe)rson$/gi, '$1ople'],\n  [/(child)$/gi, '$1ren'],\n  [/^(ox)$/gi, '$1en'],\n  [/(ax|test)is$/gi, '$1es'],\n  [/(octop|vir)us$/gi, '$1i'],\n  [/(alias|status)$/gi, '$1es'],\n  [/(bu)s$/gi, '$1ses'],\n  [/(buffal|tomat|potat)o$/gi, '$1oes'],\n  [/([ti])um$/gi, '$1a'],\n  [/sis$/gi, 'ses'],\n  [/(?:([^f])fe|([lr])f)$/gi, '$1$2ves'],\n  [/(hive)$/gi, '$1s'],\n  [/([^aeiouy]|qu)y$/gi, '$1ies'],\n  [/(x|ch|ss|sh)$/gi, '$1es'],\n  [/(matr|vert|ind)ix|ex$/gi, '$1ices'],\n  [/([m|l])ouse$/gi, '$1ice'],\n  [/(kn|w|l)ife$/gi, '$1ives'],\n  [/(quiz)$/gi, '$1zes'],\n  [/^goose$/i, 'geese'],\n  [/s$/gi, 's'],\n  [/([^a-z])$/, '$1'],\n  [/$/gi, 's']\n];\nconst rules = exports.pluralization;\n\n/**\n * Uncountable words.\n *\n * These words are applied while processing the argument to `toCollectionName`.\n * @api public\n */\n\nexports.uncountables = [\n  'advice',\n  'energy',\n  'excretion',\n  'digestion',\n  'cooperation',\n  'health',\n  'justice',\n  'labour',\n  'machinery',\n  'equipment',\n  'information',\n  'pollution',\n  'sewage',\n  'paper',\n  'money',\n  'species',\n  'series',\n  'rain',\n  'rice',\n  'fish',\n  'sheep',\n  'moose',\n  'deer',\n  'news',\n  'expertise',\n  'status',\n  'media'\n];\nconst uncountables = exports.uncountables;\n\n/**\n * Pluralize function.\n *\n * @author TJ Holowaychuk (extracted from _ext.js_)\n * @param {String} string to pluralize\n * @api private\n */\n\nfunction pluralize(str) {\n  let found;\n  str = str.toLowerCase();\n  if (!~uncountables.indexOf(str)) {\n    found = rules.filter(function(rule) {\n      return str.match(rule[0]);\n    });\n    if (found[0]) {\n      return str.replace(found[0][0], found[0][1]);\n    }\n  }\n  return str;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9wbHVyYWxpemUuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbGllbnQvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9wbHVyYWxpemUuanM/NTgyMyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gcGx1cmFsaXplO1xuXG4vKipcbiAqIFBsdXJhbGl6YXRpb24gcnVsZXMuXG4gKi9cblxuZXhwb3J0cy5wbHVyYWxpemF0aW9uID0gW1xuICBbL2h1bWFuJC9naSwgJ2h1bWFucyddLFxuICBbLyhtKWFuJC9naSwgJyQxZW4nXSxcbiAgWy8ocGUpcnNvbiQvZ2ksICckMW9wbGUnXSxcbiAgWy8oY2hpbGQpJC9naSwgJyQxcmVuJ10sXG4gIFsvXihveCkkL2dpLCAnJDFlbiddLFxuICBbLyhheHx0ZXN0KWlzJC9naSwgJyQxZXMnXSxcbiAgWy8ob2N0b3B8dmlyKXVzJC9naSwgJyQxaSddLFxuICBbLyhhbGlhc3xzdGF0dXMpJC9naSwgJyQxZXMnXSxcbiAgWy8oYnUpcyQvZ2ksICckMXNlcyddLFxuICBbLyhidWZmYWx8dG9tYXR8cG90YXQpbyQvZ2ksICckMW9lcyddLFxuICBbLyhbdGldKXVtJC9naSwgJyQxYSddLFxuICBbL3NpcyQvZ2ksICdzZXMnXSxcbiAgWy8oPzooW15mXSlmZXwoW2xyXSlmKSQvZ2ksICckMSQydmVzJ10sXG4gIFsvKGhpdmUpJC9naSwgJyQxcyddLFxuICBbLyhbXmFlaW91eV18cXUpeSQvZ2ksICckMWllcyddLFxuICBbLyh4fGNofHNzfHNoKSQvZ2ksICckMWVzJ10sXG4gIFsvKG1hdHJ8dmVydHxpbmQpaXh8ZXgkL2dpLCAnJDFpY2VzJ10sXG4gIFsvKFttfGxdKW91c2UkL2dpLCAnJDFpY2UnXSxcbiAgWy8oa258d3xsKWlmZSQvZ2ksICckMWl2ZXMnXSxcbiAgWy8ocXVpeikkL2dpLCAnJDF6ZXMnXSxcbiAgWy9eZ29vc2UkL2ksICdnZWVzZSddLFxuICBbL3MkL2dpLCAncyddLFxuICBbLyhbXmEtel0pJC8sICckMSddLFxuICBbLyQvZ2ksICdzJ11cbl07XG5jb25zdCBydWxlcyA9IGV4cG9ydHMucGx1cmFsaXphdGlvbjtcblxuLyoqXG4gKiBVbmNvdW50YWJsZSB3b3Jkcy5cbiAqXG4gKiBUaGVzZSB3b3JkcyBhcmUgYXBwbGllZCB3aGlsZSBwcm9jZXNzaW5nIHRoZSBhcmd1bWVudCB0byBgdG9Db2xsZWN0aW9uTmFtZWAuXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMudW5jb3VudGFibGVzID0gW1xuICAnYWR2aWNlJyxcbiAgJ2VuZXJneScsXG4gICdleGNyZXRpb24nLFxuICAnZGlnZXN0aW9uJyxcbiAgJ2Nvb3BlcmF0aW9uJyxcbiAgJ2hlYWx0aCcsXG4gICdqdXN0aWNlJyxcbiAgJ2xhYm91cicsXG4gICdtYWNoaW5lcnknLFxuICAnZXF1aXBtZW50JyxcbiAgJ2luZm9ybWF0aW9uJyxcbiAgJ3BvbGx1dGlvbicsXG4gICdzZXdhZ2UnLFxuICAncGFwZXInLFxuICAnbW9uZXknLFxuICAnc3BlY2llcycsXG4gICdzZXJpZXMnLFxuICAncmFpbicsXG4gICdyaWNlJyxcbiAgJ2Zpc2gnLFxuICAnc2hlZXAnLFxuICAnbW9vc2UnLFxuICAnZGVlcicsXG4gICduZXdzJyxcbiAgJ2V4cGVydGlzZScsXG4gICdzdGF0dXMnLFxuICAnbWVkaWEnXG5dO1xuY29uc3QgdW5jb3VudGFibGVzID0gZXhwb3J0cy51bmNvdW50YWJsZXM7XG5cbi8qKlxuICogUGx1cmFsaXplIGZ1bmN0aW9uLlxuICpcbiAqIEBhdXRob3IgVEogSG9sb3dheWNodWsgKGV4dHJhY3RlZCBmcm9tIF9leHQuanNfKVxuICogQHBhcmFtIHtTdHJpbmd9IHN0cmluZyB0byBwbHVyYWxpemVcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHBsdXJhbGl6ZShzdHIpIHtcbiAgbGV0IGZvdW5kO1xuICBzdHIgPSBzdHIudG9Mb3dlckNhc2UoKTtcbiAgaWYgKCF+dW5jb3VudGFibGVzLmluZGV4T2Yoc3RyKSkge1xuICAgIGZvdW5kID0gcnVsZXMuZmlsdGVyKGZ1bmN0aW9uKHJ1bGUpIHtcbiAgICAgIHJldHVybiBzdHIubWF0Y2gocnVsZVswXSk7XG4gICAgfSk7XG4gICAgaWYgKGZvdW5kWzBdKSB7XG4gICAgICByZXR1cm4gc3RyLnJlcGxhY2UoZm91bmRbMF1bMF0sIGZvdW5kWzBdWzFdKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHN0cjtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../server/node_modules/mongoose/lib/helpers/pluralize.js\n");

/***/ }),

/***/ "../server/node_modules/mongoose/lib/helpers/populate/assignRawDocsToIdStructure.js":
/*!******************************************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/helpers/populate/assignRawDocsToIdStructure.js ***!
  \******************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst clone = __webpack_require__(/*! ../../helpers/clone */ \"../server/node_modules/mongoose/lib/helpers/clone.js\");\nconst leanPopulateMap = __webpack_require__(/*! ./leanPopulateMap */ \"../server/node_modules/mongoose/lib/helpers/populate/leanPopulateMap.js\");\nconst modelSymbol = (__webpack_require__(/*! ../symbols */ \"../server/node_modules/mongoose/lib/helpers/symbols.js\").modelSymbol);\nconst utils = __webpack_require__(/*! ../../utils */ \"../server/node_modules/mongoose/lib/utils.js\");\n\nmodule.exports = assignRawDocsToIdStructure;\n\nconst kHasArray = Symbol('mongoose#assignRawDocsToIdStructure#hasArray');\n\n/**\n * Assign `vals` returned by mongo query to the `rawIds`\n * structure returned from utils.getVals() honoring\n * query sort order if specified by user.\n *\n * This can be optimized.\n *\n * Rules:\n *\n *   if the value of the path is not an array, use findOne rules, else find.\n *   for findOne the results are assigned directly to doc path (including null results).\n *   for find, if user specified sort order, results are assigned directly\n *   else documents are put back in original order of array if found in results\n *\n * @param {Array} rawIds\n * @param {Array} resultDocs\n * @param {Array} resultOrder\n * @param {Object} options\n * @param {Boolean} recursed\n * @api private\n */\n\nfunction assignRawDocsToIdStructure(rawIds, resultDocs, resultOrder, options, recursed) {\n  // honor user specified sort order, unless we're populating a single\n  // virtual underneath an array (e.g. populating `employees.mostRecentShift` where\n  // `mostRecentShift` is a virtual with `justOne`)\n  const newOrder = [];\n  const sorting = options.isVirtual && options.justOne && rawIds.length > 1\n    ? false :\n    options.sort && rawIds.length > 1;\n  const nullIfNotFound = options.$nullIfNotFound;\n  let doc;\n  let sid;\n  let id;\n\n  if (utils.isMongooseArray(rawIds)) {\n    rawIds = rawIds.__array;\n  }\n\n  let i = 0;\n  const len = rawIds.length;\n\n  if (sorting && recursed && options[kHasArray] === undefined) {\n    options[kHasArray] = false;\n    for (const key in resultOrder) {\n      if (Array.isArray(resultOrder[key])) {\n        options[kHasArray] = true;\n        break;\n      }\n    }\n  }\n\n  for (i = 0; i < len; ++i) {\n    id = rawIds[i];\n\n    if (Array.isArray(id)) {\n      // handle [ [id0, id2], [id3] ]\n      assignRawDocsToIdStructure(id, resultDocs, resultOrder, options, true);\n      newOrder.push(id);\n      continue;\n    }\n\n    if (id === null && sorting === false) {\n      // keep nulls for findOne unless sorting, which always\n      // removes them (backward compat)\n      newOrder.push(id);\n      continue;\n    }\n\n    sid = String(id);\n    doc = resultDocs[sid];\n    // If user wants separate copies of same doc, use this option\n    if (options.clone && doc != null) {\n      if (options.lean) {\n        const _model = leanPopulateMap.get(doc);\n        doc = clone(doc);\n        leanPopulateMap.set(doc, _model);\n      } else {\n        doc = doc.constructor.hydrate(doc._doc);\n      }\n    }\n\n    if (recursed) {\n      if (doc) {\n        if (sorting) {\n          const _resultOrder = resultOrder[sid];\n          if (options[kHasArray]) {\n            // If result arrays, rely on the MongoDB server response for ordering\n            newOrder.push(doc);\n          } else {\n            newOrder[_resultOrder] = doc;\n          }\n        } else {\n          newOrder.push(doc);\n        }\n      } else if (id != null && id[modelSymbol] != null) {\n        newOrder.push(id);\n      } else {\n        newOrder.push(options.retainNullValues || nullIfNotFound ? null : id);\n      }\n    } else {\n      // apply findOne behavior - if document in results, assign, else assign null\n      newOrder[i] = doc || null;\n    }\n  }\n\n  rawIds.length = 0;\n  if (newOrder.length) {\n    // reassign the documents based on corrected order\n\n    // forEach skips over sparse entries in arrays so we\n    // can safely use this to our advantage dealing with sorted\n    // result sets too.\n    newOrder.forEach(function(doc, i) {\n      rawIds[i] = doc;\n    });\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9wb3B1bGF0ZS9hc3NpZ25SYXdEb2NzVG9JZFN0cnVjdHVyZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixjQUFjLG1CQUFPLENBQUMsaUZBQXFCO0FBQzNDLHdCQUF3QixtQkFBTyxDQUFDLGtHQUFtQjtBQUNuRCxvQkFBb0IsNkdBQWlDO0FBQ3JELGNBQWMsbUJBQU8sQ0FBQyxpRUFBYTs7QUFFbkM7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsUUFBUTtBQUNuQixXQUFXLFNBQVM7QUFDcEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGNBQWMsU0FBUztBQUN2Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbGllbnQvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9wb3B1bGF0ZS9hc3NpZ25SYXdEb2NzVG9JZFN0cnVjdHVyZS5qcz80Yjg2Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3QgY2xvbmUgPSByZXF1aXJlKCcuLi8uLi9oZWxwZXJzL2Nsb25lJyk7XG5jb25zdCBsZWFuUG9wdWxhdGVNYXAgPSByZXF1aXJlKCcuL2xlYW5Qb3B1bGF0ZU1hcCcpO1xuY29uc3QgbW9kZWxTeW1ib2wgPSByZXF1aXJlKCcuLi9zeW1ib2xzJykubW9kZWxTeW1ib2w7XG5jb25zdCB1dGlscyA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gYXNzaWduUmF3RG9jc1RvSWRTdHJ1Y3R1cmU7XG5cbmNvbnN0IGtIYXNBcnJheSA9IFN5bWJvbCgnbW9uZ29vc2UjYXNzaWduUmF3RG9jc1RvSWRTdHJ1Y3R1cmUjaGFzQXJyYXknKTtcblxuLyoqXG4gKiBBc3NpZ24gYHZhbHNgIHJldHVybmVkIGJ5IG1vbmdvIHF1ZXJ5IHRvIHRoZSBgcmF3SWRzYFxuICogc3RydWN0dXJlIHJldHVybmVkIGZyb20gdXRpbHMuZ2V0VmFscygpIGhvbm9yaW5nXG4gKiBxdWVyeSBzb3J0IG9yZGVyIGlmIHNwZWNpZmllZCBieSB1c2VyLlxuICpcbiAqIFRoaXMgY2FuIGJlIG9wdGltaXplZC5cbiAqXG4gKiBSdWxlczpcbiAqXG4gKiAgIGlmIHRoZSB2YWx1ZSBvZiB0aGUgcGF0aCBpcyBub3QgYW4gYXJyYXksIHVzZSBmaW5kT25lIHJ1bGVzLCBlbHNlIGZpbmQuXG4gKiAgIGZvciBmaW5kT25lIHRoZSByZXN1bHRzIGFyZSBhc3NpZ25lZCBkaXJlY3RseSB0byBkb2MgcGF0aCAoaW5jbHVkaW5nIG51bGwgcmVzdWx0cykuXG4gKiAgIGZvciBmaW5kLCBpZiB1c2VyIHNwZWNpZmllZCBzb3J0IG9yZGVyLCByZXN1bHRzIGFyZSBhc3NpZ25lZCBkaXJlY3RseVxuICogICBlbHNlIGRvY3VtZW50cyBhcmUgcHV0IGJhY2sgaW4gb3JpZ2luYWwgb3JkZXIgb2YgYXJyYXkgaWYgZm91bmQgaW4gcmVzdWx0c1xuICpcbiAqIEBwYXJhbSB7QXJyYXl9IHJhd0lkc1xuICogQHBhcmFtIHtBcnJheX0gcmVzdWx0RG9jc1xuICogQHBhcmFtIHtBcnJheX0gcmVzdWx0T3JkZXJcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAcGFyYW0ge0Jvb2xlYW59IHJlY3Vyc2VkXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBhc3NpZ25SYXdEb2NzVG9JZFN0cnVjdHVyZShyYXdJZHMsIHJlc3VsdERvY3MsIHJlc3VsdE9yZGVyLCBvcHRpb25zLCByZWN1cnNlZCkge1xuICAvLyBob25vciB1c2VyIHNwZWNpZmllZCBzb3J0IG9yZGVyLCB1bmxlc3Mgd2UncmUgcG9wdWxhdGluZyBhIHNpbmdsZVxuICAvLyB2aXJ0dWFsIHVuZGVybmVhdGggYW4gYXJyYXkgKGUuZy4gcG9wdWxhdGluZyBgZW1wbG95ZWVzLm1vc3RSZWNlbnRTaGlmdGAgd2hlcmVcbiAgLy8gYG1vc3RSZWNlbnRTaGlmdGAgaXMgYSB2aXJ0dWFsIHdpdGggYGp1c3RPbmVgKVxuICBjb25zdCBuZXdPcmRlciA9IFtdO1xuICBjb25zdCBzb3J0aW5nID0gb3B0aW9ucy5pc1ZpcnR1YWwgJiYgb3B0aW9ucy5qdXN0T25lICYmIHJhd0lkcy5sZW5ndGggPiAxXG4gICAgPyBmYWxzZSA6XG4gICAgb3B0aW9ucy5zb3J0ICYmIHJhd0lkcy5sZW5ndGggPiAxO1xuICBjb25zdCBudWxsSWZOb3RGb3VuZCA9IG9wdGlvbnMuJG51bGxJZk5vdEZvdW5kO1xuICBsZXQgZG9jO1xuICBsZXQgc2lkO1xuICBsZXQgaWQ7XG5cbiAgaWYgKHV0aWxzLmlzTW9uZ29vc2VBcnJheShyYXdJZHMpKSB7XG4gICAgcmF3SWRzID0gcmF3SWRzLl9fYXJyYXk7XG4gIH1cblxuICBsZXQgaSA9IDA7XG4gIGNvbnN0IGxlbiA9IHJhd0lkcy5sZW5ndGg7XG5cbiAgaWYgKHNvcnRpbmcgJiYgcmVjdXJzZWQgJiYgb3B0aW9uc1trSGFzQXJyYXldID09PSB1bmRlZmluZWQpIHtcbiAgICBvcHRpb25zW2tIYXNBcnJheV0gPSBmYWxzZTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiByZXN1bHRPcmRlcikge1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkocmVzdWx0T3JkZXJba2V5XSkpIHtcbiAgICAgICAgb3B0aW9uc1trSGFzQXJyYXldID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZm9yIChpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgaWQgPSByYXdJZHNbaV07XG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheShpZCkpIHtcbiAgICAgIC8vIGhhbmRsZSBbIFtpZDAsIGlkMl0sIFtpZDNdIF1cbiAgICAgIGFzc2lnblJhd0RvY3NUb0lkU3RydWN0dXJlKGlkLCByZXN1bHREb2NzLCByZXN1bHRPcmRlciwgb3B0aW9ucywgdHJ1ZSk7XG4gICAgICBuZXdPcmRlci5wdXNoKGlkKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGlmIChpZCA9PT0gbnVsbCAmJiBzb3J0aW5nID09PSBmYWxzZSkge1xuICAgICAgLy8ga2VlcCBudWxscyBmb3IgZmluZE9uZSB1bmxlc3Mgc29ydGluZywgd2hpY2ggYWx3YXlzXG4gICAgICAvLyByZW1vdmVzIHRoZW0gKGJhY2t3YXJkIGNvbXBhdClcbiAgICAgIG5ld09yZGVyLnB1c2goaWQpO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgc2lkID0gU3RyaW5nKGlkKTtcbiAgICBkb2MgPSByZXN1bHREb2NzW3NpZF07XG4gICAgLy8gSWYgdXNlciB3YW50cyBzZXBhcmF0ZSBjb3BpZXMgb2Ygc2FtZSBkb2MsIHVzZSB0aGlzIG9wdGlvblxuICAgIGlmIChvcHRpb25zLmNsb25lICYmIGRvYyAhPSBudWxsKSB7XG4gICAgICBpZiAob3B0aW9ucy5sZWFuKSB7XG4gICAgICAgIGNvbnN0IF9tb2RlbCA9IGxlYW5Qb3B1bGF0ZU1hcC5nZXQoZG9jKTtcbiAgICAgICAgZG9jID0gY2xvbmUoZG9jKTtcbiAgICAgICAgbGVhblBvcHVsYXRlTWFwLnNldChkb2MsIF9tb2RlbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkb2MgPSBkb2MuY29uc3RydWN0b3IuaHlkcmF0ZShkb2MuX2RvYyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHJlY3Vyc2VkKSB7XG4gICAgICBpZiAoZG9jKSB7XG4gICAgICAgIGlmIChzb3J0aW5nKSB7XG4gICAgICAgICAgY29uc3QgX3Jlc3VsdE9yZGVyID0gcmVzdWx0T3JkZXJbc2lkXTtcbiAgICAgICAgICBpZiAob3B0aW9uc1trSGFzQXJyYXldKSB7XG4gICAgICAgICAgICAvLyBJZiByZXN1bHQgYXJyYXlzLCByZWx5IG9uIHRoZSBNb25nb0RCIHNlcnZlciByZXNwb25zZSBmb3Igb3JkZXJpbmdcbiAgICAgICAgICAgIG5ld09yZGVyLnB1c2goZG9jKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbmV3T3JkZXJbX3Jlc3VsdE9yZGVyXSA9IGRvYztcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbmV3T3JkZXIucHVzaChkb2MpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGlkICE9IG51bGwgJiYgaWRbbW9kZWxTeW1ib2xdICE9IG51bGwpIHtcbiAgICAgICAgbmV3T3JkZXIucHVzaChpZCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuZXdPcmRlci5wdXNoKG9wdGlvbnMucmV0YWluTnVsbFZhbHVlcyB8fCBudWxsSWZOb3RGb3VuZCA/IG51bGwgOiBpZCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGFwcGx5IGZpbmRPbmUgYmVoYXZpb3IgLSBpZiBkb2N1bWVudCBpbiByZXN1bHRzLCBhc3NpZ24sIGVsc2UgYXNzaWduIG51bGxcbiAgICAgIG5ld09yZGVyW2ldID0gZG9jIHx8IG51bGw7XG4gICAgfVxuICB9XG5cbiAgcmF3SWRzLmxlbmd0aCA9IDA7XG4gIGlmIChuZXdPcmRlci5sZW5ndGgpIHtcbiAgICAvLyByZWFzc2lnbiB0aGUgZG9jdW1lbnRzIGJhc2VkIG9uIGNvcnJlY3RlZCBvcmRlclxuXG4gICAgLy8gZm9yRWFjaCBza2lwcyBvdmVyIHNwYXJzZSBlbnRyaWVzIGluIGFycmF5cyBzbyB3ZVxuICAgIC8vIGNhbiBzYWZlbHkgdXNlIHRoaXMgdG8gb3VyIGFkdmFudGFnZSBkZWFsaW5nIHdpdGggc29ydGVkXG4gICAgLy8gcmVzdWx0IHNldHMgdG9vLlxuICAgIG5ld09yZGVyLmZvckVhY2goZnVuY3Rpb24oZG9jLCBpKSB7XG4gICAgICByYXdJZHNbaV0gPSBkb2M7XG4gICAgfSk7XG4gIH1cbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../server/node_modules/mongoose/lib/helpers/populate/assignRawDocsToIdStructure.js\n");

/***/ }),

/***/ "../server/node_modules/mongoose/lib/helpers/populate/assignVals.js":
/*!**************************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/helpers/populate/assignVals.js ***!
  \**************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst MongooseMap = __webpack_require__(/*! ../../types/map */ \"../server/node_modules/mongoose/lib/types/map.js\");\nconst SkipPopulateValue = __webpack_require__(/*! ./skipPopulateValue */ \"../server/node_modules/mongoose/lib/helpers/populate/skipPopulateValue.js\");\nconst assignRawDocsToIdStructure = __webpack_require__(/*! ./assignRawDocsToIdStructure */ \"../server/node_modules/mongoose/lib/helpers/populate/assignRawDocsToIdStructure.js\");\nconst get = __webpack_require__(/*! ../get */ \"../server/node_modules/mongoose/lib/helpers/get.js\");\nconst getVirtual = __webpack_require__(/*! ./getVirtual */ \"../server/node_modules/mongoose/lib/helpers/populate/getVirtual.js\");\nconst leanPopulateMap = __webpack_require__(/*! ./leanPopulateMap */ \"../server/node_modules/mongoose/lib/helpers/populate/leanPopulateMap.js\");\nconst lookupLocalFields = __webpack_require__(/*! ./lookupLocalFields */ \"../server/node_modules/mongoose/lib/helpers/populate/lookupLocalFields.js\");\nconst markArraySubdocsPopulated = __webpack_require__(/*! ./markArraySubdocsPopulated */ \"../server/node_modules/mongoose/lib/helpers/populate/markArraySubdocsPopulated.js\");\nconst mpath = __webpack_require__(/*! mpath */ \"../server/node_modules/mpath/index.js\");\nconst sift = (__webpack_require__(/*! sift */ \"../server/node_modules/sift/index.js\")[\"default\"]);\nconst utils = __webpack_require__(/*! ../../utils */ \"../server/node_modules/mongoose/lib/utils.js\");\nconst { populateModelSymbol } = __webpack_require__(/*! ../symbols */ \"../server/node_modules/mongoose/lib/helpers/symbols.js\");\n\nmodule.exports = function assignVals(o) {\n  // Options that aren't explicitly listed in `populateOptions`\n  const userOptions = Object.assign({}, get(o, 'allOptions.options.options'), get(o, 'allOptions.options'));\n  // `o.options` contains options explicitly listed in `populateOptions`, like\n  // `match` and `limit`.\n  const populateOptions = Object.assign({}, o.options, userOptions, {\n    justOne: o.justOne,\n    isVirtual: o.isVirtual\n  });\n  populateOptions.$nullIfNotFound = o.isVirtual;\n  const populatedModel = o.populatedModel;\n\n  const originalIds = [].concat(o.rawIds);\n\n  // replace the original ids in our intermediate _ids structure\n  // with the documents found by query\n  o.allIds = [].concat(o.allIds);\n  assignRawDocsToIdStructure(o.rawIds, o.rawDocs, o.rawOrder, populateOptions);\n\n  // now update the original documents being populated using the\n  // result structure that contains real documents.\n  const docs = o.docs;\n  const rawIds = o.rawIds;\n  const options = o.options;\n  const count = o.count && o.isVirtual;\n  let i;\n  let setValueIndex = 0;\n\n  function setValue(val) {\n    ++setValueIndex;\n    if (count) {\n      return val;\n    }\n    if (val instanceof SkipPopulateValue) {\n      return val.val;\n    }\n    if (val === void 0) {\n      return val;\n    }\n\n    const _allIds = o.allIds[i];\n\n    if (o.path.endsWith('.$*')) {\n      // Skip maps re: gh-12494\n      return valueFilter(val, options, populateOptions, _allIds);\n    }\n\n    if (o.justOne === true && Array.isArray(val)) {\n      // Might be an embedded discriminator (re: gh-9244) with multiple models, so make sure to pick the right\n      // model before assigning.\n      const ret = [];\n      for (const doc of val) {\n        const _docPopulatedModel = leanPopulateMap.get(doc);\n        if (_docPopulatedModel == null || _docPopulatedModel === populatedModel) {\n          ret.push(doc);\n        }\n      }\n      // Since we don't want to have to create a new mongoosearray, make sure to\n      // modify the array in place\n      while (val.length > ret.length) {\n        Array.prototype.pop.apply(val, []);\n      }\n      for (let i = 0; i < ret.length; ++i) {\n        val[i] = ret[i];\n      }\n\n      return valueFilter(val[0], options, populateOptions, _allIds);\n    } else if (o.justOne === false && !Array.isArray(val)) {\n      return valueFilter([val], options, populateOptions, _allIds);\n    } else if (o.justOne === true && !Array.isArray(val) && Array.isArray(_allIds)) {\n      return valueFilter(val, options, populateOptions, val == null ? val : _allIds[setValueIndex - 1]);\n    }\n    return valueFilter(val, options, populateOptions, _allIds);\n  }\n\n  for (i = 0; i < docs.length; ++i) {\n    setValueIndex = 0;\n    const _path = o.path.endsWith('.$*') ? o.path.slice(0, -3) : o.path;\n    const existingVal = mpath.get(_path, docs[i], lookupLocalFields);\n    if (existingVal == null && !getVirtual(o.originalModel.schema, _path)) {\n      continue;\n    }\n\n    let valueToSet;\n    if (count) {\n      valueToSet = numDocs(rawIds[i]);\n    } else if (Array.isArray(o.match)) {\n      valueToSet = Array.isArray(rawIds[i]) ?\n        rawIds[i].filter(sift(o.match[i])) :\n        [rawIds[i]].filter(sift(o.match[i]))[0];\n    } else {\n      valueToSet = rawIds[i];\n    }\n\n    // If we're populating a map, the existing value will be an object, so\n    // we need to transform again\n    const originalSchema = o.originalModel.schema;\n    const isDoc = get(docs[i], '$__', null) != null;\n    let isMap = isDoc ?\n      existingVal instanceof Map :\n      utils.isPOJO(existingVal);\n    // If we pass the first check, also make sure the local field's schematype\n    // is map (re: gh-6460)\n    isMap = isMap && get(originalSchema._getSchema(_path), '$isSchemaMap');\n    if (!o.isVirtual && isMap) {\n      const _keys = existingVal instanceof Map ?\n        Array.from(existingVal.keys()) :\n        Object.keys(existingVal);\n      valueToSet = valueToSet.reduce((cur, v, i) => {\n        cur.set(_keys[i], v);\n        return cur;\n      }, new Map());\n    }\n\n    if (isDoc && Array.isArray(valueToSet)) {\n      for (const val of valueToSet) {\n        if (val != null && val.$__ != null) {\n          val.$__.parent = docs[i];\n        }\n      }\n    } else if (isDoc && valueToSet != null && valueToSet.$__ != null) {\n      valueToSet.$__.parent = docs[i];\n    }\n\n    if (o.isVirtual && isDoc) {\n      docs[i].$populated(_path, o.justOne ? originalIds[0] : originalIds, o.allOptions);\n      // If virtual populate and doc is already init-ed, need to walk through\n      // the actual doc to set rather than setting `_doc` directly\n      if (Array.isArray(valueToSet)) {\n        valueToSet = valueToSet.map(v => v == null ? void 0 : v);\n      }\n      mpath.set(_path, valueToSet, docs[i], void 0, setValue, false);\n      continue;\n    }\n\n    const parts = _path.split('.');\n    let cur = docs[i];\n    for (let j = 0; j < parts.length - 1; ++j) {\n      // If we get to an array with a dotted path, like `arr.foo`, don't set\n      // `foo` on the array.\n      if (Array.isArray(cur) && !utils.isArrayIndex(parts[j])) {\n        break;\n      }\n\n      if (parts[j] === '$*') {\n        break;\n      }\n\n      if (cur[parts[j]] == null) {\n        // If nothing to set, avoid creating an unnecessary array. Otherwise\n        // we'll end up with a single doc in the array with only defaults.\n        // See gh-8342, gh-8455\n        const curPath = parts.slice(0, j + 1).join('.');\n        const schematype = originalSchema._getSchema(curPath);\n        if (valueToSet == null && schematype != null && schematype.$isMongooseArray) {\n          break;\n        }\n        cur[parts[j]] = {};\n      }\n      cur = cur[parts[j]];\n      // If the property in MongoDB is a primitive, we won't be able to populate\n      // the nested path, so skip it. See gh-7545\n      if (typeof cur !== 'object') {\n        break;\n      }\n    }\n    if (docs[i].$__) {\n      o.allOptions.options[populateModelSymbol] = o.allOptions.model;\n      docs[i].$populated(_path, o.unpopulatedValues[i], o.allOptions.options);\n\n      if (valueToSet != null && valueToSet.$__ != null) {\n        valueToSet.$__.wasPopulated = { value: o.unpopulatedValues[i] };\n      }\n\n      if (valueToSet instanceof Map && !valueToSet.$isMongooseMap) {\n        valueToSet = new MongooseMap(valueToSet, _path, docs[i], docs[i].schema.path(_path).$__schemaType);\n      }\n    }\n\n    // If lean, need to check that each individual virtual respects\n    // `justOne`, because you may have a populated virtual with `justOne`\n    // underneath an array. See gh-6867\n    mpath.set(_path, valueToSet, docs[i], lookupLocalFields, setValue, false);\n\n    if (docs[i].$__) {\n      markArraySubdocsPopulated(docs[i], [o.allOptions.options]);\n    }\n  }\n};\n\nfunction numDocs(v) {\n  if (Array.isArray(v)) {\n    // If setting underneath an array of populated subdocs, we may have an\n    // array of arrays. See gh-7573\n    if (v.some(el => Array.isArray(el) || el === null)) {\n      return v.map(el => {\n        if (el == null) {\n          return 0;\n        }\n        if (Array.isArray(el)) {\n          return el.filter(el => el != null).length;\n        }\n        return 1;\n      });\n    }\n    return v.filter(el => el != null).length;\n  }\n  return v == null ? 0 : 1;\n}\n\n/**\n * 1) Apply backwards compatible find/findOne behavior to sub documents\n *\n *    find logic:\n *      a) filter out non-documents\n *      b) remove _id from sub docs when user specified\n *\n *    findOne\n *      a) if no doc found, set to null\n *      b) remove _id from sub docs when user specified\n *\n * 2) Remove _ids when specified by users query.\n *\n * background:\n * _ids are left in the query even when user excludes them so\n * that population mapping can occur.\n * @param {Any} val\n * @param {Object} assignmentOpts\n * @param {Object} populateOptions\n * @param {Function} [populateOptions.transform]\n * @param {Boolean} allIds\n * @api private\n */\n\nfunction valueFilter(val, assignmentOpts, populateOptions, allIds) {\n  const userSpecifiedTransform = typeof populateOptions.transform === 'function';\n  const transform = userSpecifiedTransform ? populateOptions.transform : noop;\n  if (Array.isArray(val)) {\n    // find logic\n    const ret = [];\n    const numValues = val.length;\n    for (let i = 0; i < numValues; ++i) {\n      let subdoc = val[i];\n      const _allIds = Array.isArray(allIds) ? allIds[i] : allIds;\n      if (!isPopulatedObject(subdoc) && (!populateOptions.retainNullValues || subdoc != null) && !userSpecifiedTransform) {\n        continue;\n      } else if (!populateOptions.retainNullValues && subdoc == null) {\n        continue;\n      } else if (userSpecifiedTransform) {\n        subdoc = transform(isPopulatedObject(subdoc) ? subdoc : null, _allIds);\n      }\n      maybeRemoveId(subdoc, assignmentOpts);\n      ret.push(subdoc);\n      if (assignmentOpts.originalLimit &&\n          ret.length >= assignmentOpts.originalLimit) {\n        break;\n      }\n    }\n\n    const rLen = ret.length;\n    // Since we don't want to have to create a new mongoosearray, make sure to\n    // modify the array in place\n    while (val.length > rLen) {\n      Array.prototype.pop.apply(val, []);\n    }\n    let i = 0;\n    if (utils.isMongooseArray(val)) {\n      for (i = 0; i < rLen; ++i) {\n        val.set(i, ret[i], true);\n      }\n    } else {\n      for (i = 0; i < rLen; ++i) {\n        val[i] = ret[i];\n      }\n    }\n    return val;\n  }\n\n  // findOne\n  if (isPopulatedObject(val) || utils.isPOJO(val)) {\n    maybeRemoveId(val, assignmentOpts);\n    return transform(val, allIds);\n  }\n  if (val instanceof Map) {\n    return val;\n  }\n\n  if (populateOptions.justOne === false) {\n    return [];\n  }\n\n  return val == null ? transform(val, allIds) : transform(null, allIds);\n}\n\n/**\n * Remove _id from `subdoc` if user specified \"lean\" query option\n * @param {Document} subdoc\n * @param {Object} assignmentOpts\n * @api private\n */\n\nfunction maybeRemoveId(subdoc, assignmentOpts) {\n  if (subdoc != null && assignmentOpts.excludeId) {\n    if (typeof subdoc.$__setValue === 'function') {\n      delete subdoc._doc._id;\n    } else {\n      delete subdoc._id;\n    }\n  }\n}\n\n/**\n * Determine if `obj` is something we can set a populated path to. Can be a\n * document, a lean document, or an array/map that contains docs.\n * @param {Any} obj\n * @api private\n */\n\nfunction isPopulatedObject(obj) {\n  if (obj == null) {\n    return false;\n  }\n\n  return Array.isArray(obj) ||\n    obj.$isMongooseMap ||\n    obj.$__ != null ||\n    leanPopulateMap.has(obj);\n}\n\nfunction noop(v) {\n  return v;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9wb3B1bGF0ZS9hc3NpZ25WYWxzLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLG9CQUFvQixtQkFBTyxDQUFDLHlFQUFpQjtBQUM3QywwQkFBMEIsbUJBQU8sQ0FBQyxzR0FBcUI7QUFDdkQsbUNBQW1DLG1CQUFPLENBQUMsd0hBQThCO0FBQ3pFLFlBQVksbUJBQU8sQ0FBQyxrRUFBUTtBQUM1QixtQkFBbUIsbUJBQU8sQ0FBQyx3RkFBYztBQUN6Qyx3QkFBd0IsbUJBQU8sQ0FBQyxrR0FBbUI7QUFDbkQsMEJBQTBCLG1CQUFPLENBQUMsc0dBQXFCO0FBQ3ZELGtDQUFrQyxtQkFBTyxDQUFDLHNIQUE2QjtBQUN2RSxjQUFjLG1CQUFPLENBQUMsb0RBQU87QUFDN0IsYUFBYSxvRkFBdUI7QUFDcEMsY0FBYyxtQkFBTyxDQUFDLGlFQUFhO0FBQ25DLFFBQVEsc0JBQXNCLEVBQUUsbUJBQU8sQ0FBQywwRUFBWTs7QUFFcEQ7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGdCQUFnQjtBQUN0QztBQUNBOztBQUVBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGNBQWMsaUJBQWlCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0JBQW9CLHNCQUFzQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3Q0FBd0M7QUFDeEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxVQUFVO0FBQ3JCLFdBQVcsU0FBUztBQUNwQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGVBQWU7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsVUFBVTtBQUM1QjtBQUNBO0FBQ0EsTUFBTTtBQUNOLGtCQUFrQixVQUFVO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCLFdBQVcsUUFBUTtBQUNuQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2xpZW50Ly4uL3NlcnZlci9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvcG9wdWxhdGUvYXNzaWduVmFscy5qcz9mZTc2Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3QgTW9uZ29vc2VNYXAgPSByZXF1aXJlKCcuLi8uLi90eXBlcy9tYXAnKTtcbmNvbnN0IFNraXBQb3B1bGF0ZVZhbHVlID0gcmVxdWlyZSgnLi9za2lwUG9wdWxhdGVWYWx1ZScpO1xuY29uc3QgYXNzaWduUmF3RG9jc1RvSWRTdHJ1Y3R1cmUgPSByZXF1aXJlKCcuL2Fzc2lnblJhd0RvY3NUb0lkU3RydWN0dXJlJyk7XG5jb25zdCBnZXQgPSByZXF1aXJlKCcuLi9nZXQnKTtcbmNvbnN0IGdldFZpcnR1YWwgPSByZXF1aXJlKCcuL2dldFZpcnR1YWwnKTtcbmNvbnN0IGxlYW5Qb3B1bGF0ZU1hcCA9IHJlcXVpcmUoJy4vbGVhblBvcHVsYXRlTWFwJyk7XG5jb25zdCBsb29rdXBMb2NhbEZpZWxkcyA9IHJlcXVpcmUoJy4vbG9va3VwTG9jYWxGaWVsZHMnKTtcbmNvbnN0IG1hcmtBcnJheVN1YmRvY3NQb3B1bGF0ZWQgPSByZXF1aXJlKCcuL21hcmtBcnJheVN1YmRvY3NQb3B1bGF0ZWQnKTtcbmNvbnN0IG1wYXRoID0gcmVxdWlyZSgnbXBhdGgnKTtcbmNvbnN0IHNpZnQgPSByZXF1aXJlKCdzaWZ0JykuZGVmYXVsdDtcbmNvbnN0IHV0aWxzID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMnKTtcbmNvbnN0IHsgcG9wdWxhdGVNb2RlbFN5bWJvbCB9ID0gcmVxdWlyZSgnLi4vc3ltYm9scycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGFzc2lnblZhbHMobykge1xuICAvLyBPcHRpb25zIHRoYXQgYXJlbid0IGV4cGxpY2l0bHkgbGlzdGVkIGluIGBwb3B1bGF0ZU9wdGlvbnNgXG4gIGNvbnN0IHVzZXJPcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgZ2V0KG8sICdhbGxPcHRpb25zLm9wdGlvbnMub3B0aW9ucycpLCBnZXQobywgJ2FsbE9wdGlvbnMub3B0aW9ucycpKTtcbiAgLy8gYG8ub3B0aW9uc2AgY29udGFpbnMgb3B0aW9ucyBleHBsaWNpdGx5IGxpc3RlZCBpbiBgcG9wdWxhdGVPcHRpb25zYCwgbGlrZVxuICAvLyBgbWF0Y2hgIGFuZCBgbGltaXRgLlxuICBjb25zdCBwb3B1bGF0ZU9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBvLm9wdGlvbnMsIHVzZXJPcHRpb25zLCB7XG4gICAganVzdE9uZTogby5qdXN0T25lLFxuICAgIGlzVmlydHVhbDogby5pc1ZpcnR1YWxcbiAgfSk7XG4gIHBvcHVsYXRlT3B0aW9ucy4kbnVsbElmTm90Rm91bmQgPSBvLmlzVmlydHVhbDtcbiAgY29uc3QgcG9wdWxhdGVkTW9kZWwgPSBvLnBvcHVsYXRlZE1vZGVsO1xuXG4gIGNvbnN0IG9yaWdpbmFsSWRzID0gW10uY29uY2F0KG8ucmF3SWRzKTtcblxuICAvLyByZXBsYWNlIHRoZSBvcmlnaW5hbCBpZHMgaW4gb3VyIGludGVybWVkaWF0ZSBfaWRzIHN0cnVjdHVyZVxuICAvLyB3aXRoIHRoZSBkb2N1bWVudHMgZm91bmQgYnkgcXVlcnlcbiAgby5hbGxJZHMgPSBbXS5jb25jYXQoby5hbGxJZHMpO1xuICBhc3NpZ25SYXdEb2NzVG9JZFN0cnVjdHVyZShvLnJhd0lkcywgby5yYXdEb2NzLCBvLnJhd09yZGVyLCBwb3B1bGF0ZU9wdGlvbnMpO1xuXG4gIC8vIG5vdyB1cGRhdGUgdGhlIG9yaWdpbmFsIGRvY3VtZW50cyBiZWluZyBwb3B1bGF0ZWQgdXNpbmcgdGhlXG4gIC8vIHJlc3VsdCBzdHJ1Y3R1cmUgdGhhdCBjb250YWlucyByZWFsIGRvY3VtZW50cy5cbiAgY29uc3QgZG9jcyA9IG8uZG9jcztcbiAgY29uc3QgcmF3SWRzID0gby5yYXdJZHM7XG4gIGNvbnN0IG9wdGlvbnMgPSBvLm9wdGlvbnM7XG4gIGNvbnN0IGNvdW50ID0gby5jb3VudCAmJiBvLmlzVmlydHVhbDtcbiAgbGV0IGk7XG4gIGxldCBzZXRWYWx1ZUluZGV4ID0gMDtcblxuICBmdW5jdGlvbiBzZXRWYWx1ZSh2YWwpIHtcbiAgICArK3NldFZhbHVlSW5kZXg7XG4gICAgaWYgKGNvdW50KSB7XG4gICAgICByZXR1cm4gdmFsO1xuICAgIH1cbiAgICBpZiAodmFsIGluc3RhbmNlb2YgU2tpcFBvcHVsYXRlVmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWwudmFsO1xuICAgIH1cbiAgICBpZiAodmFsID09PSB2b2lkIDApIHtcbiAgICAgIHJldHVybiB2YWw7XG4gICAgfVxuXG4gICAgY29uc3QgX2FsbElkcyA9IG8uYWxsSWRzW2ldO1xuXG4gICAgaWYgKG8ucGF0aC5lbmRzV2l0aCgnLiQqJykpIHtcbiAgICAgIC8vIFNraXAgbWFwcyByZTogZ2gtMTI0OTRcbiAgICAgIHJldHVybiB2YWx1ZUZpbHRlcih2YWwsIG9wdGlvbnMsIHBvcHVsYXRlT3B0aW9ucywgX2FsbElkcyk7XG4gICAgfVxuXG4gICAgaWYgKG8uanVzdE9uZSA9PT0gdHJ1ZSAmJiBBcnJheS5pc0FycmF5KHZhbCkpIHtcbiAgICAgIC8vIE1pZ2h0IGJlIGFuIGVtYmVkZGVkIGRpc2NyaW1pbmF0b3IgKHJlOiBnaC05MjQ0KSB3aXRoIG11bHRpcGxlIG1vZGVscywgc28gbWFrZSBzdXJlIHRvIHBpY2sgdGhlIHJpZ2h0XG4gICAgICAvLyBtb2RlbCBiZWZvcmUgYXNzaWduaW5nLlxuICAgICAgY29uc3QgcmV0ID0gW107XG4gICAgICBmb3IgKGNvbnN0IGRvYyBvZiB2YWwpIHtcbiAgICAgICAgY29uc3QgX2RvY1BvcHVsYXRlZE1vZGVsID0gbGVhblBvcHVsYXRlTWFwLmdldChkb2MpO1xuICAgICAgICBpZiAoX2RvY1BvcHVsYXRlZE1vZGVsID09IG51bGwgfHwgX2RvY1BvcHVsYXRlZE1vZGVsID09PSBwb3B1bGF0ZWRNb2RlbCkge1xuICAgICAgICAgIHJldC5wdXNoKGRvYyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIFNpbmNlIHdlIGRvbid0IHdhbnQgdG8gaGF2ZSB0byBjcmVhdGUgYSBuZXcgbW9uZ29vc2VhcnJheSwgbWFrZSBzdXJlIHRvXG4gICAgICAvLyBtb2RpZnkgdGhlIGFycmF5IGluIHBsYWNlXG4gICAgICB3aGlsZSAodmFsLmxlbmd0aCA+IHJldC5sZW5ndGgpIHtcbiAgICAgICAgQXJyYXkucHJvdG90eXBlLnBvcC5hcHBseSh2YWwsIFtdKTtcbiAgICAgIH1cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmV0Lmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhbFtpXSA9IHJldFtpXTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHZhbHVlRmlsdGVyKHZhbFswXSwgb3B0aW9ucywgcG9wdWxhdGVPcHRpb25zLCBfYWxsSWRzKTtcbiAgICB9IGVsc2UgaWYgKG8uanVzdE9uZSA9PT0gZmFsc2UgJiYgIUFycmF5LmlzQXJyYXkodmFsKSkge1xuICAgICAgcmV0dXJuIHZhbHVlRmlsdGVyKFt2YWxdLCBvcHRpb25zLCBwb3B1bGF0ZU9wdGlvbnMsIF9hbGxJZHMpO1xuICAgIH0gZWxzZSBpZiAoby5qdXN0T25lID09PSB0cnVlICYmICFBcnJheS5pc0FycmF5KHZhbCkgJiYgQXJyYXkuaXNBcnJheShfYWxsSWRzKSkge1xuICAgICAgcmV0dXJuIHZhbHVlRmlsdGVyKHZhbCwgb3B0aW9ucywgcG9wdWxhdGVPcHRpb25zLCB2YWwgPT0gbnVsbCA/IHZhbCA6IF9hbGxJZHNbc2V0VmFsdWVJbmRleCAtIDFdKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlRmlsdGVyKHZhbCwgb3B0aW9ucywgcG9wdWxhdGVPcHRpb25zLCBfYWxsSWRzKTtcbiAgfVxuXG4gIGZvciAoaSA9IDA7IGkgPCBkb2NzLmxlbmd0aDsgKytpKSB7XG4gICAgc2V0VmFsdWVJbmRleCA9IDA7XG4gICAgY29uc3QgX3BhdGggPSBvLnBhdGguZW5kc1dpdGgoJy4kKicpID8gby5wYXRoLnNsaWNlKDAsIC0zKSA6IG8ucGF0aDtcbiAgICBjb25zdCBleGlzdGluZ1ZhbCA9IG1wYXRoLmdldChfcGF0aCwgZG9jc1tpXSwgbG9va3VwTG9jYWxGaWVsZHMpO1xuICAgIGlmIChleGlzdGluZ1ZhbCA9PSBudWxsICYmICFnZXRWaXJ0dWFsKG8ub3JpZ2luYWxNb2RlbC5zY2hlbWEsIF9wYXRoKSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgbGV0IHZhbHVlVG9TZXQ7XG4gICAgaWYgKGNvdW50KSB7XG4gICAgICB2YWx1ZVRvU2V0ID0gbnVtRG9jcyhyYXdJZHNbaV0pO1xuICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShvLm1hdGNoKSkge1xuICAgICAgdmFsdWVUb1NldCA9IEFycmF5LmlzQXJyYXkocmF3SWRzW2ldKSA/XG4gICAgICAgIHJhd0lkc1tpXS5maWx0ZXIoc2lmdChvLm1hdGNoW2ldKSkgOlxuICAgICAgICBbcmF3SWRzW2ldXS5maWx0ZXIoc2lmdChvLm1hdGNoW2ldKSlbMF07XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbHVlVG9TZXQgPSByYXdJZHNbaV07XG4gICAgfVxuXG4gICAgLy8gSWYgd2UncmUgcG9wdWxhdGluZyBhIG1hcCwgdGhlIGV4aXN0aW5nIHZhbHVlIHdpbGwgYmUgYW4gb2JqZWN0LCBzb1xuICAgIC8vIHdlIG5lZWQgdG8gdHJhbnNmb3JtIGFnYWluXG4gICAgY29uc3Qgb3JpZ2luYWxTY2hlbWEgPSBvLm9yaWdpbmFsTW9kZWwuc2NoZW1hO1xuICAgIGNvbnN0IGlzRG9jID0gZ2V0KGRvY3NbaV0sICckX18nLCBudWxsKSAhPSBudWxsO1xuICAgIGxldCBpc01hcCA9IGlzRG9jID9cbiAgICAgIGV4aXN0aW5nVmFsIGluc3RhbmNlb2YgTWFwIDpcbiAgICAgIHV0aWxzLmlzUE9KTyhleGlzdGluZ1ZhbCk7XG4gICAgLy8gSWYgd2UgcGFzcyB0aGUgZmlyc3QgY2hlY2ssIGFsc28gbWFrZSBzdXJlIHRoZSBsb2NhbCBmaWVsZCdzIHNjaGVtYXR5cGVcbiAgICAvLyBpcyBtYXAgKHJlOiBnaC02NDYwKVxuICAgIGlzTWFwID0gaXNNYXAgJiYgZ2V0KG9yaWdpbmFsU2NoZW1hLl9nZXRTY2hlbWEoX3BhdGgpLCAnJGlzU2NoZW1hTWFwJyk7XG4gICAgaWYgKCFvLmlzVmlydHVhbCAmJiBpc01hcCkge1xuICAgICAgY29uc3QgX2tleXMgPSBleGlzdGluZ1ZhbCBpbnN0YW5jZW9mIE1hcCA/XG4gICAgICAgIEFycmF5LmZyb20oZXhpc3RpbmdWYWwua2V5cygpKSA6XG4gICAgICAgIE9iamVjdC5rZXlzKGV4aXN0aW5nVmFsKTtcbiAgICAgIHZhbHVlVG9TZXQgPSB2YWx1ZVRvU2V0LnJlZHVjZSgoY3VyLCB2LCBpKSA9PiB7XG4gICAgICAgIGN1ci5zZXQoX2tleXNbaV0sIHYpO1xuICAgICAgICByZXR1cm4gY3VyO1xuICAgICAgfSwgbmV3IE1hcCgpKTtcbiAgICB9XG5cbiAgICBpZiAoaXNEb2MgJiYgQXJyYXkuaXNBcnJheSh2YWx1ZVRvU2V0KSkge1xuICAgICAgZm9yIChjb25zdCB2YWwgb2YgdmFsdWVUb1NldCkge1xuICAgICAgICBpZiAodmFsICE9IG51bGwgJiYgdmFsLiRfXyAhPSBudWxsKSB7XG4gICAgICAgICAgdmFsLiRfXy5wYXJlbnQgPSBkb2NzW2ldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpc0RvYyAmJiB2YWx1ZVRvU2V0ICE9IG51bGwgJiYgdmFsdWVUb1NldC4kX18gIT0gbnVsbCkge1xuICAgICAgdmFsdWVUb1NldC4kX18ucGFyZW50ID0gZG9jc1tpXTtcbiAgICB9XG5cbiAgICBpZiAoby5pc1ZpcnR1YWwgJiYgaXNEb2MpIHtcbiAgICAgIGRvY3NbaV0uJHBvcHVsYXRlZChfcGF0aCwgby5qdXN0T25lID8gb3JpZ2luYWxJZHNbMF0gOiBvcmlnaW5hbElkcywgby5hbGxPcHRpb25zKTtcbiAgICAgIC8vIElmIHZpcnR1YWwgcG9wdWxhdGUgYW5kIGRvYyBpcyBhbHJlYWR5IGluaXQtZWQsIG5lZWQgdG8gd2FsayB0aHJvdWdoXG4gICAgICAvLyB0aGUgYWN0dWFsIGRvYyB0byBzZXQgcmF0aGVyIHRoYW4gc2V0dGluZyBgX2RvY2AgZGlyZWN0bHlcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlVG9TZXQpKSB7XG4gICAgICAgIHZhbHVlVG9TZXQgPSB2YWx1ZVRvU2V0Lm1hcCh2ID0+IHYgPT0gbnVsbCA/IHZvaWQgMCA6IHYpO1xuICAgICAgfVxuICAgICAgbXBhdGguc2V0KF9wYXRoLCB2YWx1ZVRvU2V0LCBkb2NzW2ldLCB2b2lkIDAsIHNldFZhbHVlLCBmYWxzZSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBjb25zdCBwYXJ0cyA9IF9wYXRoLnNwbGl0KCcuJyk7XG4gICAgbGV0IGN1ciA9IGRvY3NbaV07XG4gICAgZm9yIChsZXQgaiA9IDA7IGogPCBwYXJ0cy5sZW5ndGggLSAxOyArK2opIHtcbiAgICAgIC8vIElmIHdlIGdldCB0byBhbiBhcnJheSB3aXRoIGEgZG90dGVkIHBhdGgsIGxpa2UgYGFyci5mb29gLCBkb24ndCBzZXRcbiAgICAgIC8vIGBmb29gIG9uIHRoZSBhcnJheS5cbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGN1cikgJiYgIXV0aWxzLmlzQXJyYXlJbmRleChwYXJ0c1tqXSkpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGlmIChwYXJ0c1tqXSA9PT0gJyQqJykge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgaWYgKGN1cltwYXJ0c1tqXV0gPT0gbnVsbCkge1xuICAgICAgICAvLyBJZiBub3RoaW5nIHRvIHNldCwgYXZvaWQgY3JlYXRpbmcgYW4gdW5uZWNlc3NhcnkgYXJyYXkuIE90aGVyd2lzZVxuICAgICAgICAvLyB3ZSdsbCBlbmQgdXAgd2l0aCBhIHNpbmdsZSBkb2MgaW4gdGhlIGFycmF5IHdpdGggb25seSBkZWZhdWx0cy5cbiAgICAgICAgLy8gU2VlIGdoLTgzNDIsIGdoLTg0NTVcbiAgICAgICAgY29uc3QgY3VyUGF0aCA9IHBhcnRzLnNsaWNlKDAsIGogKyAxKS5qb2luKCcuJyk7XG4gICAgICAgIGNvbnN0IHNjaGVtYXR5cGUgPSBvcmlnaW5hbFNjaGVtYS5fZ2V0U2NoZW1hKGN1clBhdGgpO1xuICAgICAgICBpZiAodmFsdWVUb1NldCA9PSBudWxsICYmIHNjaGVtYXR5cGUgIT0gbnVsbCAmJiBzY2hlbWF0eXBlLiRpc01vbmdvb3NlQXJyYXkpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjdXJbcGFydHNbal1dID0ge307XG4gICAgICB9XG4gICAgICBjdXIgPSBjdXJbcGFydHNbal1dO1xuICAgICAgLy8gSWYgdGhlIHByb3BlcnR5IGluIE1vbmdvREIgaXMgYSBwcmltaXRpdmUsIHdlIHdvbid0IGJlIGFibGUgdG8gcG9wdWxhdGVcbiAgICAgIC8vIHRoZSBuZXN0ZWQgcGF0aCwgc28gc2tpcCBpdC4gU2VlIGdoLTc1NDVcbiAgICAgIGlmICh0eXBlb2YgY3VyICE9PSAnb2JqZWN0Jykge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGRvY3NbaV0uJF9fKSB7XG4gICAgICBvLmFsbE9wdGlvbnMub3B0aW9uc1twb3B1bGF0ZU1vZGVsU3ltYm9sXSA9IG8uYWxsT3B0aW9ucy5tb2RlbDtcbiAgICAgIGRvY3NbaV0uJHBvcHVsYXRlZChfcGF0aCwgby51bnBvcHVsYXRlZFZhbHVlc1tpXSwgby5hbGxPcHRpb25zLm9wdGlvbnMpO1xuXG4gICAgICBpZiAodmFsdWVUb1NldCAhPSBudWxsICYmIHZhbHVlVG9TZXQuJF9fICE9IG51bGwpIHtcbiAgICAgICAgdmFsdWVUb1NldC4kX18ud2FzUG9wdWxhdGVkID0geyB2YWx1ZTogby51bnBvcHVsYXRlZFZhbHVlc1tpXSB9O1xuICAgICAgfVxuXG4gICAgICBpZiAodmFsdWVUb1NldCBpbnN0YW5jZW9mIE1hcCAmJiAhdmFsdWVUb1NldC4kaXNNb25nb29zZU1hcCkge1xuICAgICAgICB2YWx1ZVRvU2V0ID0gbmV3IE1vbmdvb3NlTWFwKHZhbHVlVG9TZXQsIF9wYXRoLCBkb2NzW2ldLCBkb2NzW2ldLnNjaGVtYS5wYXRoKF9wYXRoKS4kX19zY2hlbWFUeXBlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBJZiBsZWFuLCBuZWVkIHRvIGNoZWNrIHRoYXQgZWFjaCBpbmRpdmlkdWFsIHZpcnR1YWwgcmVzcGVjdHNcbiAgICAvLyBganVzdE9uZWAsIGJlY2F1c2UgeW91IG1heSBoYXZlIGEgcG9wdWxhdGVkIHZpcnR1YWwgd2l0aCBganVzdE9uZWBcbiAgICAvLyB1bmRlcm5lYXRoIGFuIGFycmF5LiBTZWUgZ2gtNjg2N1xuICAgIG1wYXRoLnNldChfcGF0aCwgdmFsdWVUb1NldCwgZG9jc1tpXSwgbG9va3VwTG9jYWxGaWVsZHMsIHNldFZhbHVlLCBmYWxzZSk7XG5cbiAgICBpZiAoZG9jc1tpXS4kX18pIHtcbiAgICAgIG1hcmtBcnJheVN1YmRvY3NQb3B1bGF0ZWQoZG9jc1tpXSwgW28uYWxsT3B0aW9ucy5vcHRpb25zXSk7XG4gICAgfVxuICB9XG59O1xuXG5mdW5jdGlvbiBudW1Eb2NzKHYpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkodikpIHtcbiAgICAvLyBJZiBzZXR0aW5nIHVuZGVybmVhdGggYW4gYXJyYXkgb2YgcG9wdWxhdGVkIHN1YmRvY3MsIHdlIG1heSBoYXZlIGFuXG4gICAgLy8gYXJyYXkgb2YgYXJyYXlzLiBTZWUgZ2gtNzU3M1xuICAgIGlmICh2LnNvbWUoZWwgPT4gQXJyYXkuaXNBcnJheShlbCkgfHwgZWwgPT09IG51bGwpKSB7XG4gICAgICByZXR1cm4gdi5tYXAoZWwgPT4ge1xuICAgICAgICBpZiAoZWwgPT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGVsKSkge1xuICAgICAgICAgIHJldHVybiBlbC5maWx0ZXIoZWwgPT4gZWwgIT0gbnVsbCkubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAxO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB2LmZpbHRlcihlbCA9PiBlbCAhPSBudWxsKS5sZW5ndGg7XG4gIH1cbiAgcmV0dXJuIHYgPT0gbnVsbCA/IDAgOiAxO1xufVxuXG4vKipcbiAqIDEpIEFwcGx5IGJhY2t3YXJkcyBjb21wYXRpYmxlIGZpbmQvZmluZE9uZSBiZWhhdmlvciB0byBzdWIgZG9jdW1lbnRzXG4gKlxuICogICAgZmluZCBsb2dpYzpcbiAqICAgICAgYSkgZmlsdGVyIG91dCBub24tZG9jdW1lbnRzXG4gKiAgICAgIGIpIHJlbW92ZSBfaWQgZnJvbSBzdWIgZG9jcyB3aGVuIHVzZXIgc3BlY2lmaWVkXG4gKlxuICogICAgZmluZE9uZVxuICogICAgICBhKSBpZiBubyBkb2MgZm91bmQsIHNldCB0byBudWxsXG4gKiAgICAgIGIpIHJlbW92ZSBfaWQgZnJvbSBzdWIgZG9jcyB3aGVuIHVzZXIgc3BlY2lmaWVkXG4gKlxuICogMikgUmVtb3ZlIF9pZHMgd2hlbiBzcGVjaWZpZWQgYnkgdXNlcnMgcXVlcnkuXG4gKlxuICogYmFja2dyb3VuZDpcbiAqIF9pZHMgYXJlIGxlZnQgaW4gdGhlIHF1ZXJ5IGV2ZW4gd2hlbiB1c2VyIGV4Y2x1ZGVzIHRoZW0gc29cbiAqIHRoYXQgcG9wdWxhdGlvbiBtYXBwaW5nIGNhbiBvY2N1ci5cbiAqIEBwYXJhbSB7QW55fSB2YWxcbiAqIEBwYXJhbSB7T2JqZWN0fSBhc3NpZ25tZW50T3B0c1xuICogQHBhcmFtIHtPYmplY3R9IHBvcHVsYXRlT3B0aW9uc1xuICogQHBhcmFtIHtGdW5jdGlvbn0gW3BvcHVsYXRlT3B0aW9ucy50cmFuc2Zvcm1dXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGFsbElkc1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gdmFsdWVGaWx0ZXIodmFsLCBhc3NpZ25tZW50T3B0cywgcG9wdWxhdGVPcHRpb25zLCBhbGxJZHMpIHtcbiAgY29uc3QgdXNlclNwZWNpZmllZFRyYW5zZm9ybSA9IHR5cGVvZiBwb3B1bGF0ZU9wdGlvbnMudHJhbnNmb3JtID09PSAnZnVuY3Rpb24nO1xuICBjb25zdCB0cmFuc2Zvcm0gPSB1c2VyU3BlY2lmaWVkVHJhbnNmb3JtID8gcG9wdWxhdGVPcHRpb25zLnRyYW5zZm9ybSA6IG5vb3A7XG4gIGlmIChBcnJheS5pc0FycmF5KHZhbCkpIHtcbiAgICAvLyBmaW5kIGxvZ2ljXG4gICAgY29uc3QgcmV0ID0gW107XG4gICAgY29uc3QgbnVtVmFsdWVzID0gdmFsLmxlbmd0aDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bVZhbHVlczsgKytpKSB7XG4gICAgICBsZXQgc3ViZG9jID0gdmFsW2ldO1xuICAgICAgY29uc3QgX2FsbElkcyA9IEFycmF5LmlzQXJyYXkoYWxsSWRzKSA/IGFsbElkc1tpXSA6IGFsbElkcztcbiAgICAgIGlmICghaXNQb3B1bGF0ZWRPYmplY3Qoc3ViZG9jKSAmJiAoIXBvcHVsYXRlT3B0aW9ucy5yZXRhaW5OdWxsVmFsdWVzIHx8IHN1YmRvYyAhPSBudWxsKSAmJiAhdXNlclNwZWNpZmllZFRyYW5zZm9ybSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH0gZWxzZSBpZiAoIXBvcHVsYXRlT3B0aW9ucy5yZXRhaW5OdWxsVmFsdWVzICYmIHN1YmRvYyA9PSBudWxsKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfSBlbHNlIGlmICh1c2VyU3BlY2lmaWVkVHJhbnNmb3JtKSB7XG4gICAgICAgIHN1YmRvYyA9IHRyYW5zZm9ybShpc1BvcHVsYXRlZE9iamVjdChzdWJkb2MpID8gc3ViZG9jIDogbnVsbCwgX2FsbElkcyk7XG4gICAgICB9XG4gICAgICBtYXliZVJlbW92ZUlkKHN1YmRvYywgYXNzaWdubWVudE9wdHMpO1xuICAgICAgcmV0LnB1c2goc3ViZG9jKTtcbiAgICAgIGlmIChhc3NpZ25tZW50T3B0cy5vcmlnaW5hbExpbWl0ICYmXG4gICAgICAgICAgcmV0Lmxlbmd0aCA+PSBhc3NpZ25tZW50T3B0cy5vcmlnaW5hbExpbWl0KSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IHJMZW4gPSByZXQubGVuZ3RoO1xuICAgIC8vIFNpbmNlIHdlIGRvbid0IHdhbnQgdG8gaGF2ZSB0byBjcmVhdGUgYSBuZXcgbW9uZ29vc2VhcnJheSwgbWFrZSBzdXJlIHRvXG4gICAgLy8gbW9kaWZ5IHRoZSBhcnJheSBpbiBwbGFjZVxuICAgIHdoaWxlICh2YWwubGVuZ3RoID4gckxlbikge1xuICAgICAgQXJyYXkucHJvdG90eXBlLnBvcC5hcHBseSh2YWwsIFtdKTtcbiAgICB9XG4gICAgbGV0IGkgPSAwO1xuICAgIGlmICh1dGlscy5pc01vbmdvb3NlQXJyYXkodmFsKSkge1xuICAgICAgZm9yIChpID0gMDsgaSA8IHJMZW47ICsraSkge1xuICAgICAgICB2YWwuc2V0KGksIHJldFtpXSwgdHJ1ZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCByTGVuOyArK2kpIHtcbiAgICAgICAgdmFsW2ldID0gcmV0W2ldO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdmFsO1xuICB9XG5cbiAgLy8gZmluZE9uZVxuICBpZiAoaXNQb3B1bGF0ZWRPYmplY3QodmFsKSB8fCB1dGlscy5pc1BPSk8odmFsKSkge1xuICAgIG1heWJlUmVtb3ZlSWQodmFsLCBhc3NpZ25tZW50T3B0cyk7XG4gICAgcmV0dXJuIHRyYW5zZm9ybSh2YWwsIGFsbElkcyk7XG4gIH1cbiAgaWYgKHZhbCBpbnN0YW5jZW9mIE1hcCkge1xuICAgIHJldHVybiB2YWw7XG4gIH1cblxuICBpZiAocG9wdWxhdGVPcHRpb25zLmp1c3RPbmUgPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG5cbiAgcmV0dXJuIHZhbCA9PSBudWxsID8gdHJhbnNmb3JtKHZhbCwgYWxsSWRzKSA6IHRyYW5zZm9ybShudWxsLCBhbGxJZHMpO1xufVxuXG4vKipcbiAqIFJlbW92ZSBfaWQgZnJvbSBgc3ViZG9jYCBpZiB1c2VyIHNwZWNpZmllZCBcImxlYW5cIiBxdWVyeSBvcHRpb25cbiAqIEBwYXJhbSB7RG9jdW1lbnR9IHN1YmRvY1xuICogQHBhcmFtIHtPYmplY3R9IGFzc2lnbm1lbnRPcHRzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBtYXliZVJlbW92ZUlkKHN1YmRvYywgYXNzaWdubWVudE9wdHMpIHtcbiAgaWYgKHN1YmRvYyAhPSBudWxsICYmIGFzc2lnbm1lbnRPcHRzLmV4Y2x1ZGVJZCkge1xuICAgIGlmICh0eXBlb2Ygc3ViZG9jLiRfX3NldFZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBkZWxldGUgc3ViZG9jLl9kb2MuX2lkO1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWxldGUgc3ViZG9jLl9pZDtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYG9iamAgaXMgc29tZXRoaW5nIHdlIGNhbiBzZXQgYSBwb3B1bGF0ZWQgcGF0aCB0by4gQ2FuIGJlIGFcbiAqIGRvY3VtZW50LCBhIGxlYW4gZG9jdW1lbnQsIG9yIGFuIGFycmF5L21hcCB0aGF0IGNvbnRhaW5zIGRvY3MuXG4gKiBAcGFyYW0ge0FueX0gb2JqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBpc1BvcHVsYXRlZE9iamVjdChvYmopIHtcbiAgaWYgKG9iaiA9PSBudWxsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkob2JqKSB8fFxuICAgIG9iai4kaXNNb25nb29zZU1hcCB8fFxuICAgIG9iai4kX18gIT0gbnVsbCB8fFxuICAgIGxlYW5Qb3B1bGF0ZU1hcC5oYXMob2JqKTtcbn1cblxuZnVuY3Rpb24gbm9vcCh2KSB7XG4gIHJldHVybiB2O1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../server/node_modules/mongoose/lib/helpers/populate/assignVals.js\n");

/***/ }),

/***/ "../server/node_modules/mongoose/lib/helpers/populate/createPopulateQueryFilter.js":
/*!*****************************************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/helpers/populate/createPopulateQueryFilter.js ***!
  \*****************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst SkipPopulateValue = __webpack_require__(/*! ./skipPopulateValue */ \"../server/node_modules/mongoose/lib/helpers/populate/skipPopulateValue.js\");\nconst parentPaths = __webpack_require__(/*! ../path/parentPaths */ \"../server/node_modules/mongoose/lib/helpers/path/parentPaths.js\");\nconst { trusted } = __webpack_require__(/*! ../query/trusted */ \"../server/node_modules/mongoose/lib/helpers/query/trusted.js\");\nconst hasDollarKeys = __webpack_require__(/*! ../query/hasDollarKeys */ \"../server/node_modules/mongoose/lib/helpers/query/hasDollarKeys.js\");\n\nmodule.exports = function createPopulateQueryFilter(ids, _match, _foreignField, model, skipInvalidIds) {\n  const match = _formatMatch(_match);\n\n  if (_foreignField.size === 1) {\n    const foreignField = Array.from(_foreignField)[0];\n    const foreignSchemaType = model.schema.path(foreignField);\n    if (foreignField !== '_id' || !match['_id']) {\n      ids = _filterInvalidIds(ids, foreignSchemaType, skipInvalidIds);\n      match[foreignField] = trusted({ $in: ids });\n    } else if (foreignField === '_id' && match['_id']) {\n      const userSpecifiedMatch = hasDollarKeys(match[foreignField]) ?\n        match[foreignField] :\n        { $eq: match[foreignField] };\n      match[foreignField] = { ...trusted({ $in: ids }), ...userSpecifiedMatch };\n    }\n\n    const _parentPaths = parentPaths(foreignField);\n    for (let i = 0; i < _parentPaths.length - 1; ++i) {\n      const cur = _parentPaths[i];\n      if (match[cur] != null && match[cur].$elemMatch != null) {\n        match[cur].$elemMatch[foreignField.slice(cur.length + 1)] = trusted({ $in: ids });\n        delete match[foreignField];\n        break;\n      }\n    }\n  } else {\n    const $or = [];\n    if (Array.isArray(match.$or)) {\n      match.$and = [{ $or: match.$or }, { $or: $or }];\n      delete match.$or;\n    } else {\n      match.$or = $or;\n    }\n    for (const foreignField of _foreignField) {\n      if (foreignField !== '_id' || !match['_id']) {\n        const foreignSchemaType = model.schema.path(foreignField);\n        ids = _filterInvalidIds(ids, foreignSchemaType, skipInvalidIds);\n        $or.push({ [foreignField]: { $in: ids } });\n      } else if (foreignField === '_id' && match['_id']) {\n        const userSpecifiedMatch = hasDollarKeys(match[foreignField]) ?\n          match[foreignField] :\n          { $eq: match[foreignField] };\n        match[foreignField] = { ...trusted({ $in: ids }), ...userSpecifiedMatch };\n      }\n    }\n  }\n\n  return match;\n};\n\n/**\n * Optionally filter out invalid ids that don't conform to foreign field's schema\n * to avoid cast errors (gh-7706)\n * @param {Array} ids\n * @param {SchemaType} foreignSchemaType\n * @param {Boolean} [skipInvalidIds]\n * @api private\n */\n\nfunction _filterInvalidIds(ids, foreignSchemaType, skipInvalidIds) {\n  ids = ids.filter(v => !(v instanceof SkipPopulateValue));\n  if (!skipInvalidIds) {\n    return ids;\n  }\n  return ids.filter(id => {\n    try {\n      foreignSchemaType.cast(id);\n      return true;\n    } catch (err) {\n      return false;\n    }\n  });\n}\n\n/**\n * Format `mod.match` given that it may be an array that we need to $or if\n * the client has multiple docs with match functions\n * @param {Array|Any} match\n * @api private\n */\n\nfunction _formatMatch(match) {\n  if (Array.isArray(match)) {\n    if (match.length > 1) {\n      return { $or: [].concat(match.map(m => Object.assign({}, m))) };\n    }\n    return Object.assign({}, match[0]);\n  }\n  return Object.assign({}, match);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9wb3B1bGF0ZS9jcmVhdGVQb3B1bGF0ZVF1ZXJ5RmlsdGVyLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLDBCQUEwQixtQkFBTyxDQUFDLHNHQUFxQjtBQUN2RCxvQkFBb0IsbUJBQU8sQ0FBQyw0RkFBcUI7QUFDakQsUUFBUSxVQUFVLEVBQUUsbUJBQU8sQ0FBQyxzRkFBa0I7QUFDOUMsc0JBQXNCLG1CQUFPLENBQUMsa0dBQXdCOztBQUV0RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsVUFBVTtBQUNoRCxNQUFNO0FBQ047QUFDQTtBQUNBLFVBQVU7QUFDViw4QkFBOEIsYUFBYSxVQUFVO0FBQ3JEOztBQUVBO0FBQ0Esb0JBQW9CLDZCQUE2QjtBQUNqRDtBQUNBO0FBQ0EsOEVBQThFLFVBQVU7QUFDeEY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLHNCQUFzQixnQkFBZ0IsSUFBSSxVQUFVO0FBQ3BEO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixrQkFBa0IsWUFBWTtBQUNqRCxRQUFRO0FBQ1I7QUFDQTtBQUNBLFlBQVk7QUFDWixnQ0FBZ0MsYUFBYSxVQUFVO0FBQ3ZEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLFlBQVk7QUFDdkIsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxXQUFXO0FBQ3RCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSw4Q0FBOEM7QUFDN0Q7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQSx5QkFBeUI7QUFDekIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbGllbnQvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9wb3B1bGF0ZS9jcmVhdGVQb3B1bGF0ZVF1ZXJ5RmlsdGVyLmpzPzlhOTQiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBTa2lwUG9wdWxhdGVWYWx1ZSA9IHJlcXVpcmUoJy4vc2tpcFBvcHVsYXRlVmFsdWUnKTtcbmNvbnN0IHBhcmVudFBhdGhzID0gcmVxdWlyZSgnLi4vcGF0aC9wYXJlbnRQYXRocycpO1xuY29uc3QgeyB0cnVzdGVkIH0gPSByZXF1aXJlKCcuLi9xdWVyeS90cnVzdGVkJyk7XG5jb25zdCBoYXNEb2xsYXJLZXlzID0gcmVxdWlyZSgnLi4vcXVlcnkvaGFzRG9sbGFyS2V5cycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGNyZWF0ZVBvcHVsYXRlUXVlcnlGaWx0ZXIoaWRzLCBfbWF0Y2gsIF9mb3JlaWduRmllbGQsIG1vZGVsLCBza2lwSW52YWxpZElkcykge1xuICBjb25zdCBtYXRjaCA9IF9mb3JtYXRNYXRjaChfbWF0Y2gpO1xuXG4gIGlmIChfZm9yZWlnbkZpZWxkLnNpemUgPT09IDEpIHtcbiAgICBjb25zdCBmb3JlaWduRmllbGQgPSBBcnJheS5mcm9tKF9mb3JlaWduRmllbGQpWzBdO1xuICAgIGNvbnN0IGZvcmVpZ25TY2hlbWFUeXBlID0gbW9kZWwuc2NoZW1hLnBhdGgoZm9yZWlnbkZpZWxkKTtcbiAgICBpZiAoZm9yZWlnbkZpZWxkICE9PSAnX2lkJyB8fCAhbWF0Y2hbJ19pZCddKSB7XG4gICAgICBpZHMgPSBfZmlsdGVySW52YWxpZElkcyhpZHMsIGZvcmVpZ25TY2hlbWFUeXBlLCBza2lwSW52YWxpZElkcyk7XG4gICAgICBtYXRjaFtmb3JlaWduRmllbGRdID0gdHJ1c3RlZCh7ICRpbjogaWRzIH0pO1xuICAgIH0gZWxzZSBpZiAoZm9yZWlnbkZpZWxkID09PSAnX2lkJyAmJiBtYXRjaFsnX2lkJ10pIHtcbiAgICAgIGNvbnN0IHVzZXJTcGVjaWZpZWRNYXRjaCA9IGhhc0RvbGxhcktleXMobWF0Y2hbZm9yZWlnbkZpZWxkXSkgP1xuICAgICAgICBtYXRjaFtmb3JlaWduRmllbGRdIDpcbiAgICAgICAgeyAkZXE6IG1hdGNoW2ZvcmVpZ25GaWVsZF0gfTtcbiAgICAgIG1hdGNoW2ZvcmVpZ25GaWVsZF0gPSB7IC4uLnRydXN0ZWQoeyAkaW46IGlkcyB9KSwgLi4udXNlclNwZWNpZmllZE1hdGNoIH07XG4gICAgfVxuXG4gICAgY29uc3QgX3BhcmVudFBhdGhzID0gcGFyZW50UGF0aHMoZm9yZWlnbkZpZWxkKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IF9wYXJlbnRQYXRocy5sZW5ndGggLSAxOyArK2kpIHtcbiAgICAgIGNvbnN0IGN1ciA9IF9wYXJlbnRQYXRoc1tpXTtcbiAgICAgIGlmIChtYXRjaFtjdXJdICE9IG51bGwgJiYgbWF0Y2hbY3VyXS4kZWxlbU1hdGNoICE9IG51bGwpIHtcbiAgICAgICAgbWF0Y2hbY3VyXS4kZWxlbU1hdGNoW2ZvcmVpZ25GaWVsZC5zbGljZShjdXIubGVuZ3RoICsgMSldID0gdHJ1c3RlZCh7ICRpbjogaWRzIH0pO1xuICAgICAgICBkZWxldGUgbWF0Y2hbZm9yZWlnbkZpZWxkXTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGNvbnN0ICRvciA9IFtdO1xuICAgIGlmIChBcnJheS5pc0FycmF5KG1hdGNoLiRvcikpIHtcbiAgICAgIG1hdGNoLiRhbmQgPSBbeyAkb3I6IG1hdGNoLiRvciB9LCB7ICRvcjogJG9yIH1dO1xuICAgICAgZGVsZXRlIG1hdGNoLiRvcjtcbiAgICB9IGVsc2Uge1xuICAgICAgbWF0Y2guJG9yID0gJG9yO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGZvcmVpZ25GaWVsZCBvZiBfZm9yZWlnbkZpZWxkKSB7XG4gICAgICBpZiAoZm9yZWlnbkZpZWxkICE9PSAnX2lkJyB8fCAhbWF0Y2hbJ19pZCddKSB7XG4gICAgICAgIGNvbnN0IGZvcmVpZ25TY2hlbWFUeXBlID0gbW9kZWwuc2NoZW1hLnBhdGgoZm9yZWlnbkZpZWxkKTtcbiAgICAgICAgaWRzID0gX2ZpbHRlckludmFsaWRJZHMoaWRzLCBmb3JlaWduU2NoZW1hVHlwZSwgc2tpcEludmFsaWRJZHMpO1xuICAgICAgICAkb3IucHVzaCh7IFtmb3JlaWduRmllbGRdOiB7ICRpbjogaWRzIH0gfSk7XG4gICAgICB9IGVsc2UgaWYgKGZvcmVpZ25GaWVsZCA9PT0gJ19pZCcgJiYgbWF0Y2hbJ19pZCddKSB7XG4gICAgICAgIGNvbnN0IHVzZXJTcGVjaWZpZWRNYXRjaCA9IGhhc0RvbGxhcktleXMobWF0Y2hbZm9yZWlnbkZpZWxkXSkgP1xuICAgICAgICAgIG1hdGNoW2ZvcmVpZ25GaWVsZF0gOlxuICAgICAgICAgIHsgJGVxOiBtYXRjaFtmb3JlaWduRmllbGRdIH07XG4gICAgICAgIG1hdGNoW2ZvcmVpZ25GaWVsZF0gPSB7IC4uLnRydXN0ZWQoeyAkaW46IGlkcyB9KSwgLi4udXNlclNwZWNpZmllZE1hdGNoIH07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG1hdGNoO1xufTtcblxuLyoqXG4gKiBPcHRpb25hbGx5IGZpbHRlciBvdXQgaW52YWxpZCBpZHMgdGhhdCBkb24ndCBjb25mb3JtIHRvIGZvcmVpZ24gZmllbGQncyBzY2hlbWFcbiAqIHRvIGF2b2lkIGNhc3QgZXJyb3JzIChnaC03NzA2KVxuICogQHBhcmFtIHtBcnJheX0gaWRzXG4gKiBAcGFyYW0ge1NjaGVtYVR5cGV9IGZvcmVpZ25TY2hlbWFUeXBlXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtza2lwSW52YWxpZElkc11cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIF9maWx0ZXJJbnZhbGlkSWRzKGlkcywgZm9yZWlnblNjaGVtYVR5cGUsIHNraXBJbnZhbGlkSWRzKSB7XG4gIGlkcyA9IGlkcy5maWx0ZXIodiA9PiAhKHYgaW5zdGFuY2VvZiBTa2lwUG9wdWxhdGVWYWx1ZSkpO1xuICBpZiAoIXNraXBJbnZhbGlkSWRzKSB7XG4gICAgcmV0dXJuIGlkcztcbiAgfVxuICByZXR1cm4gaWRzLmZpbHRlcihpZCA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGZvcmVpZ25TY2hlbWFUeXBlLmNhc3QoaWQpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9KTtcbn1cblxuLyoqXG4gKiBGb3JtYXQgYG1vZC5tYXRjaGAgZ2l2ZW4gdGhhdCBpdCBtYXkgYmUgYW4gYXJyYXkgdGhhdCB3ZSBuZWVkIHRvICRvciBpZlxuICogdGhlIGNsaWVudCBoYXMgbXVsdGlwbGUgZG9jcyB3aXRoIG1hdGNoIGZ1bmN0aW9uc1xuICogQHBhcmFtIHtBcnJheXxBbnl9IG1hdGNoXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBfZm9ybWF0TWF0Y2gobWF0Y2gpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkobWF0Y2gpKSB7XG4gICAgaWYgKG1hdGNoLmxlbmd0aCA+IDEpIHtcbiAgICAgIHJldHVybiB7ICRvcjogW10uY29uY2F0KG1hdGNoLm1hcChtID0+IE9iamVjdC5hc3NpZ24oe30sIG0pKSkgfTtcbiAgICB9XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIG1hdGNoWzBdKTtcbiAgfVxuICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgbWF0Y2gpO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../server/node_modules/mongoose/lib/helpers/populate/createPopulateQueryFilter.js\n");

/***/ }),

/***/ "../server/node_modules/mongoose/lib/helpers/populate/getModelsMapForPopulate.js":
/*!***************************************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/helpers/populate/getModelsMapForPopulate.js ***!
  \***************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst MongooseError = __webpack_require__(/*! ../../error/index */ \"../server/node_modules/mongoose/lib/error/index.js\");\nconst SkipPopulateValue = __webpack_require__(/*! ./skipPopulateValue */ \"../server/node_modules/mongoose/lib/helpers/populate/skipPopulateValue.js\");\nconst clone = __webpack_require__(/*! ../clone */ \"../server/node_modules/mongoose/lib/helpers/clone.js\");\nconst get = __webpack_require__(/*! ../get */ \"../server/node_modules/mongoose/lib/helpers/get.js\");\nconst getDiscriminatorByValue = __webpack_require__(/*! ../discriminator/getDiscriminatorByValue */ \"../server/node_modules/mongoose/lib/helpers/discriminator/getDiscriminatorByValue.js\");\nconst getConstructorName = __webpack_require__(/*! ../getConstructorName */ \"../server/node_modules/mongoose/lib/helpers/getConstructorName.js\");\nconst getSchemaTypes = __webpack_require__(/*! ./getSchemaTypes */ \"../server/node_modules/mongoose/lib/helpers/populate/getSchemaTypes.js\");\nconst getVirtual = __webpack_require__(/*! ./getVirtual */ \"../server/node_modules/mongoose/lib/helpers/populate/getVirtual.js\");\nconst lookupLocalFields = __webpack_require__(/*! ./lookupLocalFields */ \"../server/node_modules/mongoose/lib/helpers/populate/lookupLocalFields.js\");\nconst mpath = __webpack_require__(/*! mpath */ \"../server/node_modules/mpath/index.js\");\nconst modelNamesFromRefPath = __webpack_require__(/*! ./modelNamesFromRefPath */ \"../server/node_modules/mongoose/lib/helpers/populate/modelNamesFromRefPath.js\");\nconst utils = __webpack_require__(/*! ../../utils */ \"../server/node_modules/mongoose/lib/utils.js\");\n\nconst modelSymbol = (__webpack_require__(/*! ../symbols */ \"../server/node_modules/mongoose/lib/helpers/symbols.js\").modelSymbol);\nconst populateModelSymbol = (__webpack_require__(/*! ../symbols */ \"../server/node_modules/mongoose/lib/helpers/symbols.js\").populateModelSymbol);\nconst schemaMixedSymbol = (__webpack_require__(/*! ../../schema/symbols */ \"../server/node_modules/mongoose/lib/schema/symbols.js\").schemaMixedSymbol);\nconst StrictPopulate = __webpack_require__(/*! ../../error/strictPopulate */ \"../server/node_modules/mongoose/lib/error/strictPopulate.js\");\n\nmodule.exports = function getModelsMapForPopulate(model, docs, options) {\n  let doc;\n  const len = docs.length;\n  const map = [];\n  const modelNameFromQuery = options.model && options.model.modelName || options.model;\n  let schema;\n  let refPath;\n  let modelNames;\n  const available = {};\n\n  const modelSchema = model.schema;\n\n  // Populating a nested path should always be a no-op re: #9073.\n  // People shouldn't do this, but apparently they do.\n  if (options._localModel != null && options._localModel.schema.nested[options.path]) {\n    return [];\n  }\n\n  const _virtualRes = getVirtual(model.schema, options.path);\n  const virtual = _virtualRes == null ? null : _virtualRes.virtual;\n  if (virtual != null) {\n    return _virtualPopulate(model, docs, options, _virtualRes);\n  }\n\n  let allSchemaTypes = getSchemaTypes(model, modelSchema, null, options.path);\n  allSchemaTypes = Array.isArray(allSchemaTypes) ? allSchemaTypes : [allSchemaTypes].filter(v => v != null);\n\n  const isStrictPopulateDisabled = options.strictPopulate === false || options.options?.strictPopulate === false;\n  if (!isStrictPopulateDisabled && allSchemaTypes.length === 0 && options._localModel != null) {\n    return new StrictPopulate(options._fullPath || options.path);\n  }\n\n  for (let i = 0; i < len; i++) {\n    doc = docs[i];\n    let justOne = null;\n\n    const docSchema = doc != null && doc.$__ != null ? doc.$__schema : modelSchema;\n    schema = getSchemaTypes(model, docSchema, doc, options.path);\n\n    // Special case: populating a path that's a DocumentArray unless\n    // there's an explicit `ref` or `refPath` re: gh-8946\n    if (schema != null &&\n        schema.$isMongooseDocumentArray &&\n        schema.options.ref == null &&\n        schema.options.refPath == null) {\n      continue;\n    }\n    const isUnderneathDocArray = schema && schema.$parentSchemaDocArray;\n    if (isUnderneathDocArray && get(options, 'options.sort') != null) {\n      return new MongooseError('Cannot populate with `sort` on path ' + options.path +\n        ' because it is a subproperty of a document array');\n    }\n\n    modelNames = null;\n    let isRefPath = false;\n    let normalizedRefPath = null;\n    let schemaOptions = null;\n    let modelNamesInOrder = null;\n\n    if (schema != null && schema.instance === 'Embedded') {\n      if (schema.options.ref) {\n        const data = {\n          localField: options.path + '._id',\n          foreignField: '_id',\n          justOne: true\n        };\n        const res = _getModelNames(doc, schema, modelNameFromQuery, model);\n\n        const unpopulatedValue = mpath.get(options.path, doc);\n        const id = mpath.get('_id', unpopulatedValue);\n        addModelNamesToMap(model, map, available, res.modelNames, options, data, id, doc, schemaOptions, unpopulatedValue);\n      }\n      // No-op if no `ref` set. See gh-11538\n      continue;\n    }\n\n    if (Array.isArray(schema)) {\n      const schemasArray = schema;\n      for (const _schema of schemasArray) {\n        let _modelNames;\n        let res;\n        try {\n          res = _getModelNames(doc, _schema, modelNameFromQuery, model);\n          _modelNames = res.modelNames;\n          isRefPath = isRefPath || res.isRefPath;\n          normalizedRefPath = normalizedRefPath || res.refPath;\n          justOne = res.justOne;\n        } catch (error) {\n          return error;\n        }\n\n        if (isRefPath && !res.isRefPath) {\n          continue;\n        }\n        if (!_modelNames) {\n          continue;\n        }\n        modelNames = modelNames || [];\n        for (const modelName of _modelNames) {\n          if (modelNames.indexOf(modelName) === -1) {\n            modelNames.push(modelName);\n          }\n        }\n      }\n    } else {\n      try {\n        const res = _getModelNames(doc, schema, modelNameFromQuery, model);\n        modelNames = res.modelNames;\n        isRefPath = res.isRefPath;\n        normalizedRefPath = normalizedRefPath || res.refPath;\n        justOne = res.justOne;\n        schemaOptions = get(schema, 'options.populate', null);\n        // Dedupe, because `refPath` can return duplicates of the same model name,\n        // and that causes perf issues.\n        if (isRefPath) {\n          modelNamesInOrder = modelNames;\n          modelNames = Array.from(new Set(modelNames));\n        }\n      } catch (error) {\n        return error;\n      }\n\n      if (!modelNames) {\n        continue;\n      }\n    }\n\n    const data = {};\n    const localField = options.path;\n    const foreignField = '_id';\n\n    // `justOne = null` means we don't know from the schema whether the end\n    // result should be an array or a single doc. This can result from\n    // populating a POJO using `Model.populate()`\n    if ('justOne' in options && options.justOne !== void 0) {\n      justOne = options.justOne;\n    } else if (schema && !schema[schemaMixedSymbol]) {\n      // Skip Mixed types because we explicitly don't do casting on those.\n      if (options.path.endsWith('.' + schema.path) || options.path === schema.path) {\n        justOne = Array.isArray(schema) ?\n          schema.every(schema => !schema.$isMongooseArray) :\n          !schema.$isMongooseArray;\n      }\n    }\n\n    if (!modelNames) {\n      continue;\n    }\n\n    data.isVirtual = false;\n    data.justOne = justOne;\n    data.localField = localField;\n    data.foreignField = foreignField;\n\n    // Get local fields\n    const ret = _getLocalFieldValues(doc, localField, model, options, null, schema);\n\n    const id = String(utils.getValue(foreignField, doc));\n    options._docs[id] = Array.isArray(ret) ? ret.slice() : ret;\n\n    let match = get(options, 'match', null);\n\n    const hasMatchFunction = typeof match === 'function';\n    if (hasMatchFunction) {\n      match = match.call(doc, doc);\n    }\n    data.match = match;\n    data.hasMatchFunction = hasMatchFunction;\n    data.isRefPath = isRefPath;\n    data.modelNamesInOrder = modelNamesInOrder;\n\n    if (isRefPath) {\n      const embeddedDiscriminatorModelNames = _findRefPathForDiscriminators(doc,\n        modelSchema, data, options, normalizedRefPath, ret);\n\n      modelNames = embeddedDiscriminatorModelNames || modelNames;\n    }\n\n    try {\n      addModelNamesToMap(model, map, available, modelNames, options, data, ret, doc, schemaOptions);\n    } catch (err) {\n      return err;\n    }\n  }\n  return map;\n\n  function _getModelNames(doc, schema, modelNameFromQuery, model) {\n    let modelNames;\n    let isRefPath = false;\n    let justOne = null;\n\n    const originalSchema = schema;\n    if (schema && schema.instance === 'Array') {\n      schema = schema.caster;\n    }\n    if (schema && schema.$isSchemaMap) {\n      schema = schema.$__schemaType;\n    }\n\n    const ref = schema && schema.options && schema.options.ref;\n    refPath = schema && schema.options && schema.options.refPath;\n    if (schema != null &&\n        schema[schemaMixedSymbol] &&\n        !ref &&\n        !refPath &&\n        !modelNameFromQuery) {\n      return { modelNames: null };\n    }\n\n    if (modelNameFromQuery) {\n      modelNames = [modelNameFromQuery]; // query options\n    } else if (refPath != null) {\n      if (typeof refPath === 'function') {\n        const subdocPath = options.path.slice(0, options.path.length - schema.path.length - 1);\n        const vals = mpath.get(subdocPath, doc, lookupLocalFields);\n        const subdocsBeingPopulated = Array.isArray(vals) ?\n          utils.array.flatten(vals) :\n          (vals ? [vals] : []);\n\n        modelNames = new Set();\n        for (const subdoc of subdocsBeingPopulated) {\n          refPath = refPath.call(subdoc, subdoc, options.path);\n          modelNamesFromRefPath(refPath, doc, options.path, modelSchema, options._queryProjection).\n            forEach(name => modelNames.add(name));\n        }\n        modelNames = Array.from(modelNames);\n      } else {\n        modelNames = modelNamesFromRefPath(refPath, doc, options.path, modelSchema, options._queryProjection);\n      }\n\n      isRefPath = true;\n    } else {\n      let ref;\n      let refPath;\n      let schemaForCurrentDoc;\n      let discriminatorValue;\n      let modelForCurrentDoc = model;\n      const discriminatorKey = model.schema.options.discriminatorKey;\n\n      if (!schema && discriminatorKey && (discriminatorValue = utils.getValue(discriminatorKey, doc))) {\n        // `modelNameForFind` is the discriminator value, so we might need\n        // find the discriminated model name\n        const discriminatorModel = getDiscriminatorByValue(model.discriminators, discriminatorValue) || model;\n        if (discriminatorModel != null) {\n          modelForCurrentDoc = discriminatorModel;\n        } else {\n          try {\n            modelForCurrentDoc = _getModelFromConn(model.db, discriminatorValue);\n          } catch (error) {\n            return error;\n          }\n        }\n\n        schemaForCurrentDoc = modelForCurrentDoc.schema._getSchema(options.path);\n\n        if (schemaForCurrentDoc && schemaForCurrentDoc.caster) {\n          schemaForCurrentDoc = schemaForCurrentDoc.caster;\n        }\n      } else {\n        schemaForCurrentDoc = schema;\n      }\n\n      if (originalSchema && originalSchema.path.endsWith('.$*')) {\n        justOne = !originalSchema.$isMongooseArray && !originalSchema._arrayPath;\n      } else if (schemaForCurrentDoc != null) {\n        justOne = !schemaForCurrentDoc.$isMongooseArray && !schemaForCurrentDoc._arrayPath;\n      }\n\n      if ((ref = get(schemaForCurrentDoc, 'options.ref')) != null) {\n        if (schemaForCurrentDoc != null &&\n            typeof ref === 'function' &&\n            options.path.endsWith('.' + schemaForCurrentDoc.path)) {\n          // Ensure correct context for ref functions: subdoc, not top-level doc. See gh-8469\n          modelNames = new Set();\n\n          const subdocPath = options.path.slice(0, options.path.length - schemaForCurrentDoc.path.length - 1);\n          const vals = mpath.get(subdocPath, doc, lookupLocalFields);\n          const subdocsBeingPopulated = Array.isArray(vals) ?\n            utils.array.flatten(vals) :\n            (vals ? [vals] : []);\n          for (const subdoc of subdocsBeingPopulated) {\n            modelNames.add(handleRefFunction(ref, subdoc));\n          }\n\n          if (subdocsBeingPopulated.length === 0) {\n            modelNames = [handleRefFunction(ref, doc)];\n          } else {\n            modelNames = Array.from(modelNames);\n          }\n        } else {\n          ref = handleRefFunction(ref, doc);\n          modelNames = [ref];\n        }\n      } else if ((schemaForCurrentDoc = get(schema, 'options.refPath')) != null) {\n        isRefPath = true;\n        if (typeof refPath === 'function') {\n          const subdocPath = options.path.slice(0, options.path.length - schemaForCurrentDoc.path.length - 1);\n          const vals = mpath.get(subdocPath, doc, lookupLocalFields);\n          const subdocsBeingPopulated = Array.isArray(vals) ?\n            utils.array.flatten(vals) :\n            (vals ? [vals] : []);\n\n          modelNames = new Set();\n          for (const subdoc of subdocsBeingPopulated) {\n            refPath = refPath.call(subdoc, subdoc, options.path);\n            modelNamesFromRefPath(refPath, doc, options.path, modelSchema, options._queryProjection).\n              forEach(name => modelNames.add(name));\n          }\n          modelNames = Array.from(modelNames);\n        } else {\n          modelNames = modelNamesFromRefPath(refPath, doc, options.path, modelSchema, options._queryProjection);\n        }\n      }\n    }\n\n    if (!modelNames) {\n      // `Model.populate()` on a POJO with no known local model. Default to using the `Model`\n      if (options._localModel == null) {\n        modelNames = [model.modelName];\n      } else {\n        return { modelNames: modelNames, justOne: justOne, isRefPath: isRefPath, refPath: refPath };\n      }\n    }\n\n    if (!Array.isArray(modelNames)) {\n      modelNames = [modelNames];\n    }\n\n    return { modelNames: modelNames, justOne: justOne, isRefPath: isRefPath, refPath: refPath };\n  }\n};\n\n/*!\n * ignore\n */\n\nfunction _virtualPopulate(model, docs, options, _virtualRes) {\n  const map = [];\n  const available = {};\n  const virtual = _virtualRes.virtual;\n\n  for (const doc of docs) {\n    let modelNames = null;\n    const data = {};\n\n    // localField and foreignField\n    let localField;\n    const virtualPrefix = _virtualRes.nestedSchemaPath ?\n      _virtualRes.nestedSchemaPath + '.' : '';\n    if (typeof options.localField === 'string') {\n      localField = options.localField;\n    } else if (typeof virtual.options.localField === 'function') {\n      localField = virtualPrefix + virtual.options.localField.call(doc, doc);\n    } else if (Array.isArray(virtual.options.localField)) {\n      localField = virtual.options.localField.map(field => virtualPrefix + field);\n    } else {\n      localField = virtualPrefix + virtual.options.localField;\n    }\n    data.count = virtual.options.count;\n\n    if (virtual.options.skip != null && !options.hasOwnProperty('skip')) {\n      options.skip = virtual.options.skip;\n    }\n    if (virtual.options.limit != null && !options.hasOwnProperty('limit')) {\n      options.limit = virtual.options.limit;\n    }\n    if (virtual.options.perDocumentLimit != null && !options.hasOwnProperty('perDocumentLimit')) {\n      options.perDocumentLimit = virtual.options.perDocumentLimit;\n    }\n    let foreignField = virtual.options.foreignField;\n\n    if (!localField || !foreignField) {\n      return new MongooseError(`Cannot populate virtual \\`${options.path}\\` on model \\`${model.modelName}\\`, because options \\`localField\\` and / or \\`foreignField\\` are missing`);\n    }\n\n    if (typeof localField === 'function') {\n      localField = localField.call(doc, doc);\n    }\n    if (typeof foreignField === 'function') {\n      foreignField = foreignField.call(doc, doc);\n    }\n\n    data.isRefPath = false;\n\n    // `justOne = null` means we don't know from the schema whether the end\n    // result should be an array or a single doc. This can result from\n    // populating a POJO using `Model.populate()`\n    let justOne = null;\n    if ('justOne' in options && options.justOne !== void 0) {\n      justOne = options.justOne;\n    }\n\n    if (virtual.options.refPath) {\n      modelNames =\n        modelNamesFromRefPath(virtual.options.refPath, doc, options.path);\n      justOne = !!virtual.options.justOne;\n      data.isRefPath = true;\n    } else if (virtual.options.ref) {\n      let normalizedRef;\n      if (typeof virtual.options.ref === 'function' && !virtual.options.ref[modelSymbol]) {\n        normalizedRef = virtual.options.ref.call(doc, doc);\n      } else {\n        normalizedRef = virtual.options.ref;\n      }\n      justOne = !!virtual.options.justOne;\n      // When referencing nested arrays, the ref should be an Array\n      // of modelNames.\n      if (Array.isArray(normalizedRef)) {\n        modelNames = normalizedRef;\n      } else {\n        modelNames = [normalizedRef];\n      }\n    }\n\n    data.isVirtual = true;\n    data.virtual = virtual;\n    data.justOne = justOne;\n\n    // `match`\n    const baseMatch = get(data, 'virtual.options.match', null) ||\n      get(data, 'virtual.options.options.match', null);\n    let match = get(options, 'match', null) || baseMatch;\n\n    let hasMatchFunction = typeof match === 'function';\n    if (hasMatchFunction) {\n      match = match.call(doc, doc, data.virtual);\n    }\n\n    if (Array.isArray(localField) && Array.isArray(foreignField) && localField.length === foreignField.length) {\n      match = Object.assign({}, match);\n      for (let i = 1; i < localField.length; ++i) {\n        match[foreignField[i]] = convertTo_id(mpath.get(localField[i], doc, lookupLocalFields), model.schema);\n        hasMatchFunction = true;\n      }\n\n      localField = localField[0];\n      foreignField = foreignField[0];\n    }\n    data.localField = localField;\n    data.foreignField = foreignField;\n    data.match = match;\n    data.hasMatchFunction = hasMatchFunction;\n\n    // Get local fields\n    const ret = _getLocalFieldValues(doc, localField, model, options, virtual);\n\n    try {\n      addModelNamesToMap(model, map, available, modelNames, options, data, ret, doc);\n    } catch (err) {\n      return err;\n    }\n  }\n\n  return map;\n}\n\n/*!\n * ignore\n */\n\nfunction addModelNamesToMap(model, map, available, modelNames, options, data, ret, doc, schemaOptions, unpopulatedValue) {\n  // `PopulateOptions#connection`: if the model is passed as a string, the\n  // connection matters because different connections have different models.\n  const connection = options.connection != null ? options.connection : model.db;\n\n  unpopulatedValue = unpopulatedValue === void 0 ? ret : unpopulatedValue;\n  if (Array.isArray(unpopulatedValue)) {\n    unpopulatedValue = utils.cloneArrays(unpopulatedValue);\n  }\n\n  if (modelNames == null) {\n    return;\n  }\n\n  let k = modelNames.length;\n  while (k--) {\n    let modelName = modelNames[k];\n    if (modelName == null) {\n      continue;\n    }\n\n    let Model;\n    if (options.model && options.model[modelSymbol]) {\n      Model = options.model;\n    } else if (modelName[modelSymbol]) {\n      Model = modelName;\n      modelName = Model.modelName;\n    } else {\n      try {\n        Model = _getModelFromConn(connection, modelName);\n      } catch (err) {\n        if (ret !== void 0) {\n          throw err;\n        }\n        Model = null;\n      }\n    }\n\n    let ids = ret;\n    const flat = Array.isArray(ret) ? utils.array.flatten(ret) : [];\n\n    const modelNamesForRefPath = data.modelNamesInOrder ? data.modelNamesInOrder : modelNames;\n    if (data.isRefPath && Array.isArray(ret) && flat.length === modelNamesForRefPath.length) {\n      ids = flat.filter((val, i) => modelNamesForRefPath[i] === modelName);\n    }\n\n    const perDocumentLimit = options.perDocumentLimit == null ?\n      get(options, 'options.perDocumentLimit', null) :\n      options.perDocumentLimit;\n\n    if (!available[modelName] || perDocumentLimit != null) {\n      const currentOptions = {\n        model: Model\n      };\n      if (data.isVirtual && get(data.virtual, 'options.options')) {\n        currentOptions.options = clone(data.virtual.options.options);\n      } else if (schemaOptions != null) {\n        currentOptions.options = Object.assign({}, schemaOptions);\n      }\n      utils.merge(currentOptions, options);\n\n      // Used internally for checking what model was used to populate this\n      // path.\n      options[populateModelSymbol] = Model;\n      currentOptions[populateModelSymbol] = Model;\n      available[modelName] = {\n        model: Model,\n        options: currentOptions,\n        match: data.hasMatchFunction ? [data.match] : data.match,\n        docs: [doc],\n        ids: [ids],\n        allIds: [ret],\n        unpopulatedValues: [unpopulatedValue],\n        localField: new Set([data.localField]),\n        foreignField: new Set([data.foreignField]),\n        justOne: data.justOne,\n        isVirtual: data.isVirtual,\n        virtual: data.virtual,\n        count: data.count,\n        [populateModelSymbol]: Model\n      };\n      map.push(available[modelName]);\n    } else {\n      available[modelName].localField.add(data.localField);\n      available[modelName].foreignField.add(data.foreignField);\n      available[modelName].docs.push(doc);\n      available[modelName].ids.push(ids);\n      available[modelName].allIds.push(ret);\n      available[modelName].unpopulatedValues.push(unpopulatedValue);\n      if (data.hasMatchFunction) {\n        available[modelName].match.push(data.match);\n      }\n    }\n  }\n}\n\nfunction _getModelFromConn(conn, modelName) {\n  /* If this connection has a parent from `useDb()`, bubble up to parent's models */\n  if (conn.models[modelName] == null && conn._parent != null) {\n    return _getModelFromConn(conn._parent, modelName);\n  }\n\n  return conn.model(modelName);\n}\n\n/*!\n * ignore\n */\n\nfunction handleRefFunction(ref, doc) {\n  if (typeof ref === 'function' && !ref[modelSymbol]) {\n    return ref.call(doc, doc);\n  }\n  return ref;\n}\n\n/*!\n * ignore\n */\n\nfunction _getLocalFieldValues(doc, localField, model, options, virtual, schema) {\n  // Get Local fields\n  const localFieldPathType = model.schema._getPathType(localField);\n  const localFieldPath = localFieldPathType === 'real' ?\n    model.schema.path(localField) :\n    localFieldPathType.schema;\n  const localFieldGetters = localFieldPath && localFieldPath.getters ?\n    localFieldPath.getters : [];\n\n  localField = localFieldPath != null && localFieldPath.instance === 'Embedded' ? localField + '._id' : localField;\n\n  const _populateOptions = get(options, 'options', {});\n\n  const getters = 'getters' in _populateOptions ?\n    _populateOptions.getters :\n    get(virtual, 'options.getters', false);\n  if (localFieldGetters.length !== 0 && getters) {\n    const hydratedDoc = (doc.$__ != null) ? doc : model.hydrate(doc);\n    const localFieldValue = utils.getValue(localField, doc);\n    if (Array.isArray(localFieldValue)) {\n      const localFieldHydratedValue = utils.getValue(localField.split('.').slice(0, -1), hydratedDoc);\n      return localFieldValue.map((localFieldArrVal, localFieldArrIndex) =>\n        localFieldPath.applyGetters(localFieldArrVal, localFieldHydratedValue[localFieldArrIndex]));\n    } else {\n      return localFieldPath.applyGetters(localFieldValue, hydratedDoc);\n    }\n  } else {\n    return convertTo_id(mpath.get(localField, doc, lookupLocalFields), schema);\n  }\n}\n\n/**\n * Retrieve the _id of `val` if a Document or Array of Documents.\n *\n * @param {Array|Document|Any} val\n * @param {Schema} schema\n * @return {Array|Document|Any}\n * @api private\n */\n\nfunction convertTo_id(val, schema) {\n  if (val != null && val.$__ != null) {\n    return val._id;\n  }\n  if (val != null && val._id != null && (schema == null || !schema.$isSchemaMap)) {\n    return val._id;\n  }\n\n  if (Array.isArray(val)) {\n    const rawVal = val.__array != null ? val.__array : val;\n    for (let i = 0; i < rawVal.length; ++i) {\n      if (rawVal[i] != null && rawVal[i].$__ != null) {\n        rawVal[i] = rawVal[i]._id;\n      }\n    }\n    if (utils.isMongooseArray(val) && val.$schema()) {\n      return val.$schema()._castForPopulate(val, val.$parent());\n    }\n\n    return [].concat(val);\n  }\n\n  // `populate('map')` may be an object if populating on a doc that hasn't\n  // been hydrated yet\n  if (getConstructorName(val) === 'Object' &&\n      // The intent here is we should only flatten the object if we expect\n      // to get a Map in the end. Avoid doing this for mixed types.\n      (schema == null || schema[schemaMixedSymbol] == null)) {\n    const ret = [];\n    for (const key of Object.keys(val)) {\n      ret.push(val[key]);\n    }\n    return ret;\n  }\n  // If doc has already been hydrated, e.g. `doc.populate('map')`\n  // then `val` will already be a map\n  if (val instanceof Map) {\n    return Array.from(val.values());\n  }\n\n  return val;\n}\n\n/*!\n * ignore\n */\n\nfunction _findRefPathForDiscriminators(doc, modelSchema, data, options, normalizedRefPath, ret) {\n  // Re: gh-8452. Embedded discriminators may not have `refPath`, so clear\n  // out embedded discriminator docs that don't have a `refPath` on the\n  // populated path.\n  if (!data.isRefPath || normalizedRefPath == null) {\n    return;\n  }\n\n  const pieces = normalizedRefPath.split('.');\n  let cur = '';\n  let modelNames = void 0;\n  for (let i = 0; i < pieces.length; ++i) {\n    const piece = pieces[i];\n    cur = cur + (cur.length === 0 ? '' : '.') + piece;\n    const schematype = modelSchema.path(cur);\n    if (schematype != null &&\n        schematype.$isMongooseArray &&\n        schematype.caster.discriminators != null &&\n        Object.keys(schematype.caster.discriminators).length !== 0) {\n      const subdocs = utils.getValue(cur, doc);\n      const remnant = options.path.substring(cur.length + 1);\n      const discriminatorKey = schematype.caster.schema.options.discriminatorKey;\n      modelNames = [];\n      for (const subdoc of subdocs) {\n        const discriminatorName = utils.getValue(discriminatorKey, subdoc);\n        const discriminator = schematype.caster.discriminators[discriminatorName];\n        const discriminatorSchema = discriminator && discriminator.schema;\n        if (discriminatorSchema == null) {\n          continue;\n        }\n        const _path = discriminatorSchema.path(remnant);\n        if (_path == null || _path.options.refPath == null) {\n          const docValue = utils.getValue(data.localField.substring(cur.length + 1), subdoc);\n          ret.forEach((v, i) => {\n            if (v === docValue) {\n              ret[i] = SkipPopulateValue(v);\n            }\n          });\n          continue;\n        }\n        const modelName = utils.getValue(pieces.slice(i + 1).join('.'), subdoc);\n        modelNames.push(modelName);\n      }\n    }\n  }\n\n  return modelNames;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9wb3B1bGF0ZS9nZXRNb2RlbHNNYXBGb3JQb3B1bGF0ZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixzQkFBc0IsbUJBQU8sQ0FBQyw2RUFBbUI7QUFDakQsMEJBQTBCLG1CQUFPLENBQUMsc0dBQXFCO0FBQ3ZELGNBQWMsbUJBQU8sQ0FBQyxzRUFBVTtBQUNoQyxZQUFZLG1CQUFPLENBQUMsa0VBQVE7QUFDNUIsZ0NBQWdDLG1CQUFPLENBQUMsc0lBQTBDO0FBQ2xGLDJCQUEyQixtQkFBTyxDQUFDLGdHQUF1QjtBQUMxRCx1QkFBdUIsbUJBQU8sQ0FBQyxnR0FBa0I7QUFDakQsbUJBQW1CLG1CQUFPLENBQUMsd0ZBQWM7QUFDekMsMEJBQTBCLG1CQUFPLENBQUMsc0dBQXFCO0FBQ3ZELGNBQWMsbUJBQU8sQ0FBQyxvREFBTztBQUM3Qiw4QkFBOEIsbUJBQU8sQ0FBQyw4R0FBeUI7QUFDL0QsY0FBYyxtQkFBTyxDQUFDLGlFQUFhOztBQUVuQyxvQkFBb0IsNkdBQWlDO0FBQ3JELDRCQUE0QixxSEFBeUM7QUFDckUsMEJBQTBCLDRIQUFpRDtBQUMzRSx1QkFBdUIsbUJBQU8sQ0FBQywrRkFBNEI7O0FBRTNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0IsU0FBUztBQUMzQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmOztBQUVBO0FBQ0EseUNBQXlDO0FBQ3pDLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLGlCQUFpQjtBQUNqQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw0REFBNEQsYUFBYSxnQkFBZ0IsZ0JBQWdCO0FBQ3pHOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsOEJBQThCO0FBQzlCLHNCQUFzQix1QkFBdUI7QUFDN0M7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1IsaURBQWlEO0FBQ2pEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxxREFBcUQ7O0FBRXJEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsb0JBQW9CO0FBQy9CLFdBQVcsUUFBUTtBQUNuQixZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0JBQW9CLG1CQUFtQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLG1CQUFtQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2xpZW50Ly4uL3NlcnZlci9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvcG9wdWxhdGUvZ2V0TW9kZWxzTWFwRm9yUG9wdWxhdGUuanM/Mjg2NyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IE1vbmdvb3NlRXJyb3IgPSByZXF1aXJlKCcuLi8uLi9lcnJvci9pbmRleCcpO1xuY29uc3QgU2tpcFBvcHVsYXRlVmFsdWUgPSByZXF1aXJlKCcuL3NraXBQb3B1bGF0ZVZhbHVlJyk7XG5jb25zdCBjbG9uZSA9IHJlcXVpcmUoJy4uL2Nsb25lJyk7XG5jb25zdCBnZXQgPSByZXF1aXJlKCcuLi9nZXQnKTtcbmNvbnN0IGdldERpc2NyaW1pbmF0b3JCeVZhbHVlID0gcmVxdWlyZSgnLi4vZGlzY3JpbWluYXRvci9nZXREaXNjcmltaW5hdG9yQnlWYWx1ZScpO1xuY29uc3QgZ2V0Q29uc3RydWN0b3JOYW1lID0gcmVxdWlyZSgnLi4vZ2V0Q29uc3RydWN0b3JOYW1lJyk7XG5jb25zdCBnZXRTY2hlbWFUeXBlcyA9IHJlcXVpcmUoJy4vZ2V0U2NoZW1hVHlwZXMnKTtcbmNvbnN0IGdldFZpcnR1YWwgPSByZXF1aXJlKCcuL2dldFZpcnR1YWwnKTtcbmNvbnN0IGxvb2t1cExvY2FsRmllbGRzID0gcmVxdWlyZSgnLi9sb29rdXBMb2NhbEZpZWxkcycpO1xuY29uc3QgbXBhdGggPSByZXF1aXJlKCdtcGF0aCcpO1xuY29uc3QgbW9kZWxOYW1lc0Zyb21SZWZQYXRoID0gcmVxdWlyZSgnLi9tb2RlbE5hbWVzRnJvbVJlZlBhdGgnKTtcbmNvbnN0IHV0aWxzID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMnKTtcblxuY29uc3QgbW9kZWxTeW1ib2wgPSByZXF1aXJlKCcuLi9zeW1ib2xzJykubW9kZWxTeW1ib2w7XG5jb25zdCBwb3B1bGF0ZU1vZGVsU3ltYm9sID0gcmVxdWlyZSgnLi4vc3ltYm9scycpLnBvcHVsYXRlTW9kZWxTeW1ib2w7XG5jb25zdCBzY2hlbWFNaXhlZFN5bWJvbCA9IHJlcXVpcmUoJy4uLy4uL3NjaGVtYS9zeW1ib2xzJykuc2NoZW1hTWl4ZWRTeW1ib2w7XG5jb25zdCBTdHJpY3RQb3B1bGF0ZSA9IHJlcXVpcmUoJy4uLy4uL2Vycm9yL3N0cmljdFBvcHVsYXRlJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZ2V0TW9kZWxzTWFwRm9yUG9wdWxhdGUobW9kZWwsIGRvY3MsIG9wdGlvbnMpIHtcbiAgbGV0IGRvYztcbiAgY29uc3QgbGVuID0gZG9jcy5sZW5ndGg7XG4gIGNvbnN0IG1hcCA9IFtdO1xuICBjb25zdCBtb2RlbE5hbWVGcm9tUXVlcnkgPSBvcHRpb25zLm1vZGVsICYmIG9wdGlvbnMubW9kZWwubW9kZWxOYW1lIHx8IG9wdGlvbnMubW9kZWw7XG4gIGxldCBzY2hlbWE7XG4gIGxldCByZWZQYXRoO1xuICBsZXQgbW9kZWxOYW1lcztcbiAgY29uc3QgYXZhaWxhYmxlID0ge307XG5cbiAgY29uc3QgbW9kZWxTY2hlbWEgPSBtb2RlbC5zY2hlbWE7XG5cbiAgLy8gUG9wdWxhdGluZyBhIG5lc3RlZCBwYXRoIHNob3VsZCBhbHdheXMgYmUgYSBuby1vcCByZTogIzkwNzMuXG4gIC8vIFBlb3BsZSBzaG91bGRuJ3QgZG8gdGhpcywgYnV0IGFwcGFyZW50bHkgdGhleSBkby5cbiAgaWYgKG9wdGlvbnMuX2xvY2FsTW9kZWwgIT0gbnVsbCAmJiBvcHRpb25zLl9sb2NhbE1vZGVsLnNjaGVtYS5uZXN0ZWRbb3B0aW9ucy5wYXRoXSkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuXG4gIGNvbnN0IF92aXJ0dWFsUmVzID0gZ2V0VmlydHVhbChtb2RlbC5zY2hlbWEsIG9wdGlvbnMucGF0aCk7XG4gIGNvbnN0IHZpcnR1YWwgPSBfdmlydHVhbFJlcyA9PSBudWxsID8gbnVsbCA6IF92aXJ0dWFsUmVzLnZpcnR1YWw7XG4gIGlmICh2aXJ0dWFsICE9IG51bGwpIHtcbiAgICByZXR1cm4gX3ZpcnR1YWxQb3B1bGF0ZShtb2RlbCwgZG9jcywgb3B0aW9ucywgX3ZpcnR1YWxSZXMpO1xuICB9XG5cbiAgbGV0IGFsbFNjaGVtYVR5cGVzID0gZ2V0U2NoZW1hVHlwZXMobW9kZWwsIG1vZGVsU2NoZW1hLCBudWxsLCBvcHRpb25zLnBhdGgpO1xuICBhbGxTY2hlbWFUeXBlcyA9IEFycmF5LmlzQXJyYXkoYWxsU2NoZW1hVHlwZXMpID8gYWxsU2NoZW1hVHlwZXMgOiBbYWxsU2NoZW1hVHlwZXNdLmZpbHRlcih2ID0+IHYgIT0gbnVsbCk7XG5cbiAgY29uc3QgaXNTdHJpY3RQb3B1bGF0ZURpc2FibGVkID0gb3B0aW9ucy5zdHJpY3RQb3B1bGF0ZSA9PT0gZmFsc2UgfHwgb3B0aW9ucy5vcHRpb25zPy5zdHJpY3RQb3B1bGF0ZSA9PT0gZmFsc2U7XG4gIGlmICghaXNTdHJpY3RQb3B1bGF0ZURpc2FibGVkICYmIGFsbFNjaGVtYVR5cGVzLmxlbmd0aCA9PT0gMCAmJiBvcHRpb25zLl9sb2NhbE1vZGVsICE9IG51bGwpIHtcbiAgICByZXR1cm4gbmV3IFN0cmljdFBvcHVsYXRlKG9wdGlvbnMuX2Z1bGxQYXRoIHx8IG9wdGlvbnMucGF0aCk7XG4gIH1cblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgZG9jID0gZG9jc1tpXTtcbiAgICBsZXQganVzdE9uZSA9IG51bGw7XG5cbiAgICBjb25zdCBkb2NTY2hlbWEgPSBkb2MgIT0gbnVsbCAmJiBkb2MuJF9fICE9IG51bGwgPyBkb2MuJF9fc2NoZW1hIDogbW9kZWxTY2hlbWE7XG4gICAgc2NoZW1hID0gZ2V0U2NoZW1hVHlwZXMobW9kZWwsIGRvY1NjaGVtYSwgZG9jLCBvcHRpb25zLnBhdGgpO1xuXG4gICAgLy8gU3BlY2lhbCBjYXNlOiBwb3B1bGF0aW5nIGEgcGF0aCB0aGF0J3MgYSBEb2N1bWVudEFycmF5IHVubGVzc1xuICAgIC8vIHRoZXJlJ3MgYW4gZXhwbGljaXQgYHJlZmAgb3IgYHJlZlBhdGhgIHJlOiBnaC04OTQ2XG4gICAgaWYgKHNjaGVtYSAhPSBudWxsICYmXG4gICAgICAgIHNjaGVtYS4kaXNNb25nb29zZURvY3VtZW50QXJyYXkgJiZcbiAgICAgICAgc2NoZW1hLm9wdGlvbnMucmVmID09IG51bGwgJiZcbiAgICAgICAgc2NoZW1hLm9wdGlvbnMucmVmUGF0aCA9PSBudWxsKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgY29uc3QgaXNVbmRlcm5lYXRoRG9jQXJyYXkgPSBzY2hlbWEgJiYgc2NoZW1hLiRwYXJlbnRTY2hlbWFEb2NBcnJheTtcbiAgICBpZiAoaXNVbmRlcm5lYXRoRG9jQXJyYXkgJiYgZ2V0KG9wdGlvbnMsICdvcHRpb25zLnNvcnQnKSAhPSBudWxsKSB7XG4gICAgICByZXR1cm4gbmV3IE1vbmdvb3NlRXJyb3IoJ0Nhbm5vdCBwb3B1bGF0ZSB3aXRoIGBzb3J0YCBvbiBwYXRoICcgKyBvcHRpb25zLnBhdGggK1xuICAgICAgICAnIGJlY2F1c2UgaXQgaXMgYSBzdWJwcm9wZXJ0eSBvZiBhIGRvY3VtZW50IGFycmF5Jyk7XG4gICAgfVxuXG4gICAgbW9kZWxOYW1lcyA9IG51bGw7XG4gICAgbGV0IGlzUmVmUGF0aCA9IGZhbHNlO1xuICAgIGxldCBub3JtYWxpemVkUmVmUGF0aCA9IG51bGw7XG4gICAgbGV0IHNjaGVtYU9wdGlvbnMgPSBudWxsO1xuICAgIGxldCBtb2RlbE5hbWVzSW5PcmRlciA9IG51bGw7XG5cbiAgICBpZiAoc2NoZW1hICE9IG51bGwgJiYgc2NoZW1hLmluc3RhbmNlID09PSAnRW1iZWRkZWQnKSB7XG4gICAgICBpZiAoc2NoZW1hLm9wdGlvbnMucmVmKSB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSB7XG4gICAgICAgICAgbG9jYWxGaWVsZDogb3B0aW9ucy5wYXRoICsgJy5faWQnLFxuICAgICAgICAgIGZvcmVpZ25GaWVsZDogJ19pZCcsXG4gICAgICAgICAganVzdE9uZTogdHJ1ZVxuICAgICAgICB9O1xuICAgICAgICBjb25zdCByZXMgPSBfZ2V0TW9kZWxOYW1lcyhkb2MsIHNjaGVtYSwgbW9kZWxOYW1lRnJvbVF1ZXJ5LCBtb2RlbCk7XG5cbiAgICAgICAgY29uc3QgdW5wb3B1bGF0ZWRWYWx1ZSA9IG1wYXRoLmdldChvcHRpb25zLnBhdGgsIGRvYyk7XG4gICAgICAgIGNvbnN0IGlkID0gbXBhdGguZ2V0KCdfaWQnLCB1bnBvcHVsYXRlZFZhbHVlKTtcbiAgICAgICAgYWRkTW9kZWxOYW1lc1RvTWFwKG1vZGVsLCBtYXAsIGF2YWlsYWJsZSwgcmVzLm1vZGVsTmFtZXMsIG9wdGlvbnMsIGRhdGEsIGlkLCBkb2MsIHNjaGVtYU9wdGlvbnMsIHVucG9wdWxhdGVkVmFsdWUpO1xuICAgICAgfVxuICAgICAgLy8gTm8tb3AgaWYgbm8gYHJlZmAgc2V0LiBTZWUgZ2gtMTE1MzhcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGlmIChBcnJheS5pc0FycmF5KHNjaGVtYSkpIHtcbiAgICAgIGNvbnN0IHNjaGVtYXNBcnJheSA9IHNjaGVtYTtcbiAgICAgIGZvciAoY29uc3QgX3NjaGVtYSBvZiBzY2hlbWFzQXJyYXkpIHtcbiAgICAgICAgbGV0IF9tb2RlbE5hbWVzO1xuICAgICAgICBsZXQgcmVzO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHJlcyA9IF9nZXRNb2RlbE5hbWVzKGRvYywgX3NjaGVtYSwgbW9kZWxOYW1lRnJvbVF1ZXJ5LCBtb2RlbCk7XG4gICAgICAgICAgX21vZGVsTmFtZXMgPSByZXMubW9kZWxOYW1lcztcbiAgICAgICAgICBpc1JlZlBhdGggPSBpc1JlZlBhdGggfHwgcmVzLmlzUmVmUGF0aDtcbiAgICAgICAgICBub3JtYWxpemVkUmVmUGF0aCA9IG5vcm1hbGl6ZWRSZWZQYXRoIHx8IHJlcy5yZWZQYXRoO1xuICAgICAgICAgIGp1c3RPbmUgPSByZXMuanVzdE9uZTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNSZWZQYXRoICYmICFyZXMuaXNSZWZQYXRoKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFfbW9kZWxOYW1lcykge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIG1vZGVsTmFtZXMgPSBtb2RlbE5hbWVzIHx8IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IG1vZGVsTmFtZSBvZiBfbW9kZWxOYW1lcykge1xuICAgICAgICAgIGlmIChtb2RlbE5hbWVzLmluZGV4T2YobW9kZWxOYW1lKSA9PT0gLTEpIHtcbiAgICAgICAgICAgIG1vZGVsTmFtZXMucHVzaChtb2RlbE5hbWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCByZXMgPSBfZ2V0TW9kZWxOYW1lcyhkb2MsIHNjaGVtYSwgbW9kZWxOYW1lRnJvbVF1ZXJ5LCBtb2RlbCk7XG4gICAgICAgIG1vZGVsTmFtZXMgPSByZXMubW9kZWxOYW1lcztcbiAgICAgICAgaXNSZWZQYXRoID0gcmVzLmlzUmVmUGF0aDtcbiAgICAgICAgbm9ybWFsaXplZFJlZlBhdGggPSBub3JtYWxpemVkUmVmUGF0aCB8fCByZXMucmVmUGF0aDtcbiAgICAgICAganVzdE9uZSA9IHJlcy5qdXN0T25lO1xuICAgICAgICBzY2hlbWFPcHRpb25zID0gZ2V0KHNjaGVtYSwgJ29wdGlvbnMucG9wdWxhdGUnLCBudWxsKTtcbiAgICAgICAgLy8gRGVkdXBlLCBiZWNhdXNlIGByZWZQYXRoYCBjYW4gcmV0dXJuIGR1cGxpY2F0ZXMgb2YgdGhlIHNhbWUgbW9kZWwgbmFtZSxcbiAgICAgICAgLy8gYW5kIHRoYXQgY2F1c2VzIHBlcmYgaXNzdWVzLlxuICAgICAgICBpZiAoaXNSZWZQYXRoKSB7XG4gICAgICAgICAgbW9kZWxOYW1lc0luT3JkZXIgPSBtb2RlbE5hbWVzO1xuICAgICAgICAgIG1vZGVsTmFtZXMgPSBBcnJheS5mcm9tKG5ldyBTZXQobW9kZWxOYW1lcykpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgICB9XG5cbiAgICAgIGlmICghbW9kZWxOYW1lcykge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBkYXRhID0ge307XG4gICAgY29uc3QgbG9jYWxGaWVsZCA9IG9wdGlvbnMucGF0aDtcbiAgICBjb25zdCBmb3JlaWduRmllbGQgPSAnX2lkJztcblxuICAgIC8vIGBqdXN0T25lID0gbnVsbGAgbWVhbnMgd2UgZG9uJ3Qga25vdyBmcm9tIHRoZSBzY2hlbWEgd2hldGhlciB0aGUgZW5kXG4gICAgLy8gcmVzdWx0IHNob3VsZCBiZSBhbiBhcnJheSBvciBhIHNpbmdsZSBkb2MuIFRoaXMgY2FuIHJlc3VsdCBmcm9tXG4gICAgLy8gcG9wdWxhdGluZyBhIFBPSk8gdXNpbmcgYE1vZGVsLnBvcHVsYXRlKClgXG4gICAgaWYgKCdqdXN0T25lJyBpbiBvcHRpb25zICYmIG9wdGlvbnMuanVzdE9uZSAhPT0gdm9pZCAwKSB7XG4gICAgICBqdXN0T25lID0gb3B0aW9ucy5qdXN0T25lO1xuICAgIH0gZWxzZSBpZiAoc2NoZW1hICYmICFzY2hlbWFbc2NoZW1hTWl4ZWRTeW1ib2xdKSB7XG4gICAgICAvLyBTa2lwIE1peGVkIHR5cGVzIGJlY2F1c2Ugd2UgZXhwbGljaXRseSBkb24ndCBkbyBjYXN0aW5nIG9uIHRob3NlLlxuICAgICAgaWYgKG9wdGlvbnMucGF0aC5lbmRzV2l0aCgnLicgKyBzY2hlbWEucGF0aCkgfHwgb3B0aW9ucy5wYXRoID09PSBzY2hlbWEucGF0aCkge1xuICAgICAgICBqdXN0T25lID0gQXJyYXkuaXNBcnJheShzY2hlbWEpID9cbiAgICAgICAgICBzY2hlbWEuZXZlcnkoc2NoZW1hID0+ICFzY2hlbWEuJGlzTW9uZ29vc2VBcnJheSkgOlxuICAgICAgICAgICFzY2hlbWEuJGlzTW9uZ29vc2VBcnJheTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIW1vZGVsTmFtZXMpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGRhdGEuaXNWaXJ0dWFsID0gZmFsc2U7XG4gICAgZGF0YS5qdXN0T25lID0ganVzdE9uZTtcbiAgICBkYXRhLmxvY2FsRmllbGQgPSBsb2NhbEZpZWxkO1xuICAgIGRhdGEuZm9yZWlnbkZpZWxkID0gZm9yZWlnbkZpZWxkO1xuXG4gICAgLy8gR2V0IGxvY2FsIGZpZWxkc1xuICAgIGNvbnN0IHJldCA9IF9nZXRMb2NhbEZpZWxkVmFsdWVzKGRvYywgbG9jYWxGaWVsZCwgbW9kZWwsIG9wdGlvbnMsIG51bGwsIHNjaGVtYSk7XG5cbiAgICBjb25zdCBpZCA9IFN0cmluZyh1dGlscy5nZXRWYWx1ZShmb3JlaWduRmllbGQsIGRvYykpO1xuICAgIG9wdGlvbnMuX2RvY3NbaWRdID0gQXJyYXkuaXNBcnJheShyZXQpID8gcmV0LnNsaWNlKCkgOiByZXQ7XG5cbiAgICBsZXQgbWF0Y2ggPSBnZXQob3B0aW9ucywgJ21hdGNoJywgbnVsbCk7XG5cbiAgICBjb25zdCBoYXNNYXRjaEZ1bmN0aW9uID0gdHlwZW9mIG1hdGNoID09PSAnZnVuY3Rpb24nO1xuICAgIGlmIChoYXNNYXRjaEZ1bmN0aW9uKSB7XG4gICAgICBtYXRjaCA9IG1hdGNoLmNhbGwoZG9jLCBkb2MpO1xuICAgIH1cbiAgICBkYXRhLm1hdGNoID0gbWF0Y2g7XG4gICAgZGF0YS5oYXNNYXRjaEZ1bmN0aW9uID0gaGFzTWF0Y2hGdW5jdGlvbjtcbiAgICBkYXRhLmlzUmVmUGF0aCA9IGlzUmVmUGF0aDtcbiAgICBkYXRhLm1vZGVsTmFtZXNJbk9yZGVyID0gbW9kZWxOYW1lc0luT3JkZXI7XG5cbiAgICBpZiAoaXNSZWZQYXRoKSB7XG4gICAgICBjb25zdCBlbWJlZGRlZERpc2NyaW1pbmF0b3JNb2RlbE5hbWVzID0gX2ZpbmRSZWZQYXRoRm9yRGlzY3JpbWluYXRvcnMoZG9jLFxuICAgICAgICBtb2RlbFNjaGVtYSwgZGF0YSwgb3B0aW9ucywgbm9ybWFsaXplZFJlZlBhdGgsIHJldCk7XG5cbiAgICAgIG1vZGVsTmFtZXMgPSBlbWJlZGRlZERpc2NyaW1pbmF0b3JNb2RlbE5hbWVzIHx8IG1vZGVsTmFtZXM7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIGFkZE1vZGVsTmFtZXNUb01hcChtb2RlbCwgbWFwLCBhdmFpbGFibGUsIG1vZGVsTmFtZXMsIG9wdGlvbnMsIGRhdGEsIHJldCwgZG9jLCBzY2hlbWFPcHRpb25zKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHJldHVybiBlcnI7XG4gICAgfVxuICB9XG4gIHJldHVybiBtYXA7XG5cbiAgZnVuY3Rpb24gX2dldE1vZGVsTmFtZXMoZG9jLCBzY2hlbWEsIG1vZGVsTmFtZUZyb21RdWVyeSwgbW9kZWwpIHtcbiAgICBsZXQgbW9kZWxOYW1lcztcbiAgICBsZXQgaXNSZWZQYXRoID0gZmFsc2U7XG4gICAgbGV0IGp1c3RPbmUgPSBudWxsO1xuXG4gICAgY29uc3Qgb3JpZ2luYWxTY2hlbWEgPSBzY2hlbWE7XG4gICAgaWYgKHNjaGVtYSAmJiBzY2hlbWEuaW5zdGFuY2UgPT09ICdBcnJheScpIHtcbiAgICAgIHNjaGVtYSA9IHNjaGVtYS5jYXN0ZXI7XG4gICAgfVxuICAgIGlmIChzY2hlbWEgJiYgc2NoZW1hLiRpc1NjaGVtYU1hcCkge1xuICAgICAgc2NoZW1hID0gc2NoZW1hLiRfX3NjaGVtYVR5cGU7XG4gICAgfVxuXG4gICAgY29uc3QgcmVmID0gc2NoZW1hICYmIHNjaGVtYS5vcHRpb25zICYmIHNjaGVtYS5vcHRpb25zLnJlZjtcbiAgICByZWZQYXRoID0gc2NoZW1hICYmIHNjaGVtYS5vcHRpb25zICYmIHNjaGVtYS5vcHRpb25zLnJlZlBhdGg7XG4gICAgaWYgKHNjaGVtYSAhPSBudWxsICYmXG4gICAgICAgIHNjaGVtYVtzY2hlbWFNaXhlZFN5bWJvbF0gJiZcbiAgICAgICAgIXJlZiAmJlxuICAgICAgICAhcmVmUGF0aCAmJlxuICAgICAgICAhbW9kZWxOYW1lRnJvbVF1ZXJ5KSB7XG4gICAgICByZXR1cm4geyBtb2RlbE5hbWVzOiBudWxsIH07XG4gICAgfVxuXG4gICAgaWYgKG1vZGVsTmFtZUZyb21RdWVyeSkge1xuICAgICAgbW9kZWxOYW1lcyA9IFttb2RlbE5hbWVGcm9tUXVlcnldOyAvLyBxdWVyeSBvcHRpb25zXG4gICAgfSBlbHNlIGlmIChyZWZQYXRoICE9IG51bGwpIHtcbiAgICAgIGlmICh0eXBlb2YgcmVmUGF0aCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBjb25zdCBzdWJkb2NQYXRoID0gb3B0aW9ucy5wYXRoLnNsaWNlKDAsIG9wdGlvbnMucGF0aC5sZW5ndGggLSBzY2hlbWEucGF0aC5sZW5ndGggLSAxKTtcbiAgICAgICAgY29uc3QgdmFscyA9IG1wYXRoLmdldChzdWJkb2NQYXRoLCBkb2MsIGxvb2t1cExvY2FsRmllbGRzKTtcbiAgICAgICAgY29uc3Qgc3ViZG9jc0JlaW5nUG9wdWxhdGVkID0gQXJyYXkuaXNBcnJheSh2YWxzKSA/XG4gICAgICAgICAgdXRpbHMuYXJyYXkuZmxhdHRlbih2YWxzKSA6XG4gICAgICAgICAgKHZhbHMgPyBbdmFsc10gOiBbXSk7XG5cbiAgICAgICAgbW9kZWxOYW1lcyA9IG5ldyBTZXQoKTtcbiAgICAgICAgZm9yIChjb25zdCBzdWJkb2Mgb2Ygc3ViZG9jc0JlaW5nUG9wdWxhdGVkKSB7XG4gICAgICAgICAgcmVmUGF0aCA9IHJlZlBhdGguY2FsbChzdWJkb2MsIHN1YmRvYywgb3B0aW9ucy5wYXRoKTtcbiAgICAgICAgICBtb2RlbE5hbWVzRnJvbVJlZlBhdGgocmVmUGF0aCwgZG9jLCBvcHRpb25zLnBhdGgsIG1vZGVsU2NoZW1hLCBvcHRpb25zLl9xdWVyeVByb2plY3Rpb24pLlxuICAgICAgICAgICAgZm9yRWFjaChuYW1lID0+IG1vZGVsTmFtZXMuYWRkKG5hbWUpKTtcbiAgICAgICAgfVxuICAgICAgICBtb2RlbE5hbWVzID0gQXJyYXkuZnJvbShtb2RlbE5hbWVzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1vZGVsTmFtZXMgPSBtb2RlbE5hbWVzRnJvbVJlZlBhdGgocmVmUGF0aCwgZG9jLCBvcHRpb25zLnBhdGgsIG1vZGVsU2NoZW1hLCBvcHRpb25zLl9xdWVyeVByb2plY3Rpb24pO1xuICAgICAgfVxuXG4gICAgICBpc1JlZlBhdGggPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgcmVmO1xuICAgICAgbGV0IHJlZlBhdGg7XG4gICAgICBsZXQgc2NoZW1hRm9yQ3VycmVudERvYztcbiAgICAgIGxldCBkaXNjcmltaW5hdG9yVmFsdWU7XG4gICAgICBsZXQgbW9kZWxGb3JDdXJyZW50RG9jID0gbW9kZWw7XG4gICAgICBjb25zdCBkaXNjcmltaW5hdG9yS2V5ID0gbW9kZWwuc2NoZW1hLm9wdGlvbnMuZGlzY3JpbWluYXRvcktleTtcblxuICAgICAgaWYgKCFzY2hlbWEgJiYgZGlzY3JpbWluYXRvcktleSAmJiAoZGlzY3JpbWluYXRvclZhbHVlID0gdXRpbHMuZ2V0VmFsdWUoZGlzY3JpbWluYXRvcktleSwgZG9jKSkpIHtcbiAgICAgICAgLy8gYG1vZGVsTmFtZUZvckZpbmRgIGlzIHRoZSBkaXNjcmltaW5hdG9yIHZhbHVlLCBzbyB3ZSBtaWdodCBuZWVkXG4gICAgICAgIC8vIGZpbmQgdGhlIGRpc2NyaW1pbmF0ZWQgbW9kZWwgbmFtZVxuICAgICAgICBjb25zdCBkaXNjcmltaW5hdG9yTW9kZWwgPSBnZXREaXNjcmltaW5hdG9yQnlWYWx1ZShtb2RlbC5kaXNjcmltaW5hdG9ycywgZGlzY3JpbWluYXRvclZhbHVlKSB8fCBtb2RlbDtcbiAgICAgICAgaWYgKGRpc2NyaW1pbmF0b3JNb2RlbCAhPSBudWxsKSB7XG4gICAgICAgICAgbW9kZWxGb3JDdXJyZW50RG9jID0gZGlzY3JpbWluYXRvck1vZGVsO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBtb2RlbEZvckN1cnJlbnREb2MgPSBfZ2V0TW9kZWxGcm9tQ29ubihtb2RlbC5kYiwgZGlzY3JpbWluYXRvclZhbHVlKTtcbiAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHNjaGVtYUZvckN1cnJlbnREb2MgPSBtb2RlbEZvckN1cnJlbnREb2Muc2NoZW1hLl9nZXRTY2hlbWEob3B0aW9ucy5wYXRoKTtcblxuICAgICAgICBpZiAoc2NoZW1hRm9yQ3VycmVudERvYyAmJiBzY2hlbWFGb3JDdXJyZW50RG9jLmNhc3Rlcikge1xuICAgICAgICAgIHNjaGVtYUZvckN1cnJlbnREb2MgPSBzY2hlbWFGb3JDdXJyZW50RG9jLmNhc3RlcjtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2NoZW1hRm9yQ3VycmVudERvYyA9IHNjaGVtYTtcbiAgICAgIH1cblxuICAgICAgaWYgKG9yaWdpbmFsU2NoZW1hICYmIG9yaWdpbmFsU2NoZW1hLnBhdGguZW5kc1dpdGgoJy4kKicpKSB7XG4gICAgICAgIGp1c3RPbmUgPSAhb3JpZ2luYWxTY2hlbWEuJGlzTW9uZ29vc2VBcnJheSAmJiAhb3JpZ2luYWxTY2hlbWEuX2FycmF5UGF0aDtcbiAgICAgIH0gZWxzZSBpZiAoc2NoZW1hRm9yQ3VycmVudERvYyAhPSBudWxsKSB7XG4gICAgICAgIGp1c3RPbmUgPSAhc2NoZW1hRm9yQ3VycmVudERvYy4kaXNNb25nb29zZUFycmF5ICYmICFzY2hlbWFGb3JDdXJyZW50RG9jLl9hcnJheVBhdGg7XG4gICAgICB9XG5cbiAgICAgIGlmICgocmVmID0gZ2V0KHNjaGVtYUZvckN1cnJlbnREb2MsICdvcHRpb25zLnJlZicpKSAhPSBudWxsKSB7XG4gICAgICAgIGlmIChzY2hlbWFGb3JDdXJyZW50RG9jICE9IG51bGwgJiZcbiAgICAgICAgICAgIHR5cGVvZiByZWYgPT09ICdmdW5jdGlvbicgJiZcbiAgICAgICAgICAgIG9wdGlvbnMucGF0aC5lbmRzV2l0aCgnLicgKyBzY2hlbWFGb3JDdXJyZW50RG9jLnBhdGgpKSB7XG4gICAgICAgICAgLy8gRW5zdXJlIGNvcnJlY3QgY29udGV4dCBmb3IgcmVmIGZ1bmN0aW9uczogc3ViZG9jLCBub3QgdG9wLWxldmVsIGRvYy4gU2VlIGdoLTg0NjlcbiAgICAgICAgICBtb2RlbE5hbWVzID0gbmV3IFNldCgpO1xuXG4gICAgICAgICAgY29uc3Qgc3ViZG9jUGF0aCA9IG9wdGlvbnMucGF0aC5zbGljZSgwLCBvcHRpb25zLnBhdGgubGVuZ3RoIC0gc2NoZW1hRm9yQ3VycmVudERvYy5wYXRoLmxlbmd0aCAtIDEpO1xuICAgICAgICAgIGNvbnN0IHZhbHMgPSBtcGF0aC5nZXQoc3ViZG9jUGF0aCwgZG9jLCBsb29rdXBMb2NhbEZpZWxkcyk7XG4gICAgICAgICAgY29uc3Qgc3ViZG9jc0JlaW5nUG9wdWxhdGVkID0gQXJyYXkuaXNBcnJheSh2YWxzKSA/XG4gICAgICAgICAgICB1dGlscy5hcnJheS5mbGF0dGVuKHZhbHMpIDpcbiAgICAgICAgICAgICh2YWxzID8gW3ZhbHNdIDogW10pO1xuICAgICAgICAgIGZvciAoY29uc3Qgc3ViZG9jIG9mIHN1YmRvY3NCZWluZ1BvcHVsYXRlZCkge1xuICAgICAgICAgICAgbW9kZWxOYW1lcy5hZGQoaGFuZGxlUmVmRnVuY3Rpb24ocmVmLCBzdWJkb2MpKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoc3ViZG9jc0JlaW5nUG9wdWxhdGVkLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgbW9kZWxOYW1lcyA9IFtoYW5kbGVSZWZGdW5jdGlvbihyZWYsIGRvYyldO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtb2RlbE5hbWVzID0gQXJyYXkuZnJvbShtb2RlbE5hbWVzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVmID0gaGFuZGxlUmVmRnVuY3Rpb24ocmVmLCBkb2MpO1xuICAgICAgICAgIG1vZGVsTmFtZXMgPSBbcmVmXTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICgoc2NoZW1hRm9yQ3VycmVudERvYyA9IGdldChzY2hlbWEsICdvcHRpb25zLnJlZlBhdGgnKSkgIT0gbnVsbCkge1xuICAgICAgICBpc1JlZlBhdGggPSB0cnVlO1xuICAgICAgICBpZiAodHlwZW9mIHJlZlBhdGggPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBjb25zdCBzdWJkb2NQYXRoID0gb3B0aW9ucy5wYXRoLnNsaWNlKDAsIG9wdGlvbnMucGF0aC5sZW5ndGggLSBzY2hlbWFGb3JDdXJyZW50RG9jLnBhdGgubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgY29uc3QgdmFscyA9IG1wYXRoLmdldChzdWJkb2NQYXRoLCBkb2MsIGxvb2t1cExvY2FsRmllbGRzKTtcbiAgICAgICAgICBjb25zdCBzdWJkb2NzQmVpbmdQb3B1bGF0ZWQgPSBBcnJheS5pc0FycmF5KHZhbHMpID9cbiAgICAgICAgICAgIHV0aWxzLmFycmF5LmZsYXR0ZW4odmFscykgOlxuICAgICAgICAgICAgKHZhbHMgPyBbdmFsc10gOiBbXSk7XG5cbiAgICAgICAgICBtb2RlbE5hbWVzID0gbmV3IFNldCgpO1xuICAgICAgICAgIGZvciAoY29uc3Qgc3ViZG9jIG9mIHN1YmRvY3NCZWluZ1BvcHVsYXRlZCkge1xuICAgICAgICAgICAgcmVmUGF0aCA9IHJlZlBhdGguY2FsbChzdWJkb2MsIHN1YmRvYywgb3B0aW9ucy5wYXRoKTtcbiAgICAgICAgICAgIG1vZGVsTmFtZXNGcm9tUmVmUGF0aChyZWZQYXRoLCBkb2MsIG9wdGlvbnMucGF0aCwgbW9kZWxTY2hlbWEsIG9wdGlvbnMuX3F1ZXJ5UHJvamVjdGlvbikuXG4gICAgICAgICAgICAgIGZvckVhY2gobmFtZSA9PiBtb2RlbE5hbWVzLmFkZChuYW1lKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIG1vZGVsTmFtZXMgPSBBcnJheS5mcm9tKG1vZGVsTmFtZXMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG1vZGVsTmFtZXMgPSBtb2RlbE5hbWVzRnJvbVJlZlBhdGgocmVmUGF0aCwgZG9jLCBvcHRpb25zLnBhdGgsIG1vZGVsU2NoZW1hLCBvcHRpb25zLl9xdWVyeVByb2plY3Rpb24pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFtb2RlbE5hbWVzKSB7XG4gICAgICAvLyBgTW9kZWwucG9wdWxhdGUoKWAgb24gYSBQT0pPIHdpdGggbm8ga25vd24gbG9jYWwgbW9kZWwuIERlZmF1bHQgdG8gdXNpbmcgdGhlIGBNb2RlbGBcbiAgICAgIGlmIChvcHRpb25zLl9sb2NhbE1vZGVsID09IG51bGwpIHtcbiAgICAgICAgbW9kZWxOYW1lcyA9IFttb2RlbC5tb2RlbE5hbWVdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHsgbW9kZWxOYW1lczogbW9kZWxOYW1lcywganVzdE9uZToganVzdE9uZSwgaXNSZWZQYXRoOiBpc1JlZlBhdGgsIHJlZlBhdGg6IHJlZlBhdGggfTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIUFycmF5LmlzQXJyYXkobW9kZWxOYW1lcykpIHtcbiAgICAgIG1vZGVsTmFtZXMgPSBbbW9kZWxOYW1lc107XG4gICAgfVxuXG4gICAgcmV0dXJuIHsgbW9kZWxOYW1lczogbW9kZWxOYW1lcywganVzdE9uZToganVzdE9uZSwgaXNSZWZQYXRoOiBpc1JlZlBhdGgsIHJlZlBhdGg6IHJlZlBhdGggfTtcbiAgfVxufTtcblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5mdW5jdGlvbiBfdmlydHVhbFBvcHVsYXRlKG1vZGVsLCBkb2NzLCBvcHRpb25zLCBfdmlydHVhbFJlcykge1xuICBjb25zdCBtYXAgPSBbXTtcbiAgY29uc3QgYXZhaWxhYmxlID0ge307XG4gIGNvbnN0IHZpcnR1YWwgPSBfdmlydHVhbFJlcy52aXJ0dWFsO1xuXG4gIGZvciAoY29uc3QgZG9jIG9mIGRvY3MpIHtcbiAgICBsZXQgbW9kZWxOYW1lcyA9IG51bGw7XG4gICAgY29uc3QgZGF0YSA9IHt9O1xuXG4gICAgLy8gbG9jYWxGaWVsZCBhbmQgZm9yZWlnbkZpZWxkXG4gICAgbGV0IGxvY2FsRmllbGQ7XG4gICAgY29uc3QgdmlydHVhbFByZWZpeCA9IF92aXJ0dWFsUmVzLm5lc3RlZFNjaGVtYVBhdGggP1xuICAgICAgX3ZpcnR1YWxSZXMubmVzdGVkU2NoZW1hUGF0aCArICcuJyA6ICcnO1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5sb2NhbEZpZWxkID09PSAnc3RyaW5nJykge1xuICAgICAgbG9jYWxGaWVsZCA9IG9wdGlvbnMubG9jYWxGaWVsZDtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB2aXJ0dWFsLm9wdGlvbnMubG9jYWxGaWVsZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgbG9jYWxGaWVsZCA9IHZpcnR1YWxQcmVmaXggKyB2aXJ0dWFsLm9wdGlvbnMubG9jYWxGaWVsZC5jYWxsKGRvYywgZG9jKTtcbiAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodmlydHVhbC5vcHRpb25zLmxvY2FsRmllbGQpKSB7XG4gICAgICBsb2NhbEZpZWxkID0gdmlydHVhbC5vcHRpb25zLmxvY2FsRmllbGQubWFwKGZpZWxkID0+IHZpcnR1YWxQcmVmaXggKyBmaWVsZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxvY2FsRmllbGQgPSB2aXJ0dWFsUHJlZml4ICsgdmlydHVhbC5vcHRpb25zLmxvY2FsRmllbGQ7XG4gICAgfVxuICAgIGRhdGEuY291bnQgPSB2aXJ0dWFsLm9wdGlvbnMuY291bnQ7XG5cbiAgICBpZiAodmlydHVhbC5vcHRpb25zLnNraXAgIT0gbnVsbCAmJiAhb3B0aW9ucy5oYXNPd25Qcm9wZXJ0eSgnc2tpcCcpKSB7XG4gICAgICBvcHRpb25zLnNraXAgPSB2aXJ0dWFsLm9wdGlvbnMuc2tpcDtcbiAgICB9XG4gICAgaWYgKHZpcnR1YWwub3B0aW9ucy5saW1pdCAhPSBudWxsICYmICFvcHRpb25zLmhhc093blByb3BlcnR5KCdsaW1pdCcpKSB7XG4gICAgICBvcHRpb25zLmxpbWl0ID0gdmlydHVhbC5vcHRpb25zLmxpbWl0O1xuICAgIH1cbiAgICBpZiAodmlydHVhbC5vcHRpb25zLnBlckRvY3VtZW50TGltaXQgIT0gbnVsbCAmJiAhb3B0aW9ucy5oYXNPd25Qcm9wZXJ0eSgncGVyRG9jdW1lbnRMaW1pdCcpKSB7XG4gICAgICBvcHRpb25zLnBlckRvY3VtZW50TGltaXQgPSB2aXJ0dWFsLm9wdGlvbnMucGVyRG9jdW1lbnRMaW1pdDtcbiAgICB9XG4gICAgbGV0IGZvcmVpZ25GaWVsZCA9IHZpcnR1YWwub3B0aW9ucy5mb3JlaWduRmllbGQ7XG5cbiAgICBpZiAoIWxvY2FsRmllbGQgfHwgIWZvcmVpZ25GaWVsZCkge1xuICAgICAgcmV0dXJuIG5ldyBNb25nb29zZUVycm9yKGBDYW5ub3QgcG9wdWxhdGUgdmlydHVhbCBcXGAke29wdGlvbnMucGF0aH1cXGAgb24gbW9kZWwgXFxgJHttb2RlbC5tb2RlbE5hbWV9XFxgLCBiZWNhdXNlIG9wdGlvbnMgXFxgbG9jYWxGaWVsZFxcYCBhbmQgLyBvciBcXGBmb3JlaWduRmllbGRcXGAgYXJlIG1pc3NpbmdgKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGxvY2FsRmllbGQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGxvY2FsRmllbGQgPSBsb2NhbEZpZWxkLmNhbGwoZG9jLCBkb2MpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGZvcmVpZ25GaWVsZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgZm9yZWlnbkZpZWxkID0gZm9yZWlnbkZpZWxkLmNhbGwoZG9jLCBkb2MpO1xuICAgIH1cblxuICAgIGRhdGEuaXNSZWZQYXRoID0gZmFsc2U7XG5cbiAgICAvLyBganVzdE9uZSA9IG51bGxgIG1lYW5zIHdlIGRvbid0IGtub3cgZnJvbSB0aGUgc2NoZW1hIHdoZXRoZXIgdGhlIGVuZFxuICAgIC8vIHJlc3VsdCBzaG91bGQgYmUgYW4gYXJyYXkgb3IgYSBzaW5nbGUgZG9jLiBUaGlzIGNhbiByZXN1bHQgZnJvbVxuICAgIC8vIHBvcHVsYXRpbmcgYSBQT0pPIHVzaW5nIGBNb2RlbC5wb3B1bGF0ZSgpYFxuICAgIGxldCBqdXN0T25lID0gbnVsbDtcbiAgICBpZiAoJ2p1c3RPbmUnIGluIG9wdGlvbnMgJiYgb3B0aW9ucy5qdXN0T25lICE9PSB2b2lkIDApIHtcbiAgICAgIGp1c3RPbmUgPSBvcHRpb25zLmp1c3RPbmU7XG4gICAgfVxuXG4gICAgaWYgKHZpcnR1YWwub3B0aW9ucy5yZWZQYXRoKSB7XG4gICAgICBtb2RlbE5hbWVzID1cbiAgICAgICAgbW9kZWxOYW1lc0Zyb21SZWZQYXRoKHZpcnR1YWwub3B0aW9ucy5yZWZQYXRoLCBkb2MsIG9wdGlvbnMucGF0aCk7XG4gICAgICBqdXN0T25lID0gISF2aXJ0dWFsLm9wdGlvbnMuanVzdE9uZTtcbiAgICAgIGRhdGEuaXNSZWZQYXRoID0gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKHZpcnR1YWwub3B0aW9ucy5yZWYpIHtcbiAgICAgIGxldCBub3JtYWxpemVkUmVmO1xuICAgICAgaWYgKHR5cGVvZiB2aXJ0dWFsLm9wdGlvbnMucmVmID09PSAnZnVuY3Rpb24nICYmICF2aXJ0dWFsLm9wdGlvbnMucmVmW21vZGVsU3ltYm9sXSkge1xuICAgICAgICBub3JtYWxpemVkUmVmID0gdmlydHVhbC5vcHRpb25zLnJlZi5jYWxsKGRvYywgZG9jKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5vcm1hbGl6ZWRSZWYgPSB2aXJ0dWFsLm9wdGlvbnMucmVmO1xuICAgICAgfVxuICAgICAganVzdE9uZSA9ICEhdmlydHVhbC5vcHRpb25zLmp1c3RPbmU7XG4gICAgICAvLyBXaGVuIHJlZmVyZW5jaW5nIG5lc3RlZCBhcnJheXMsIHRoZSByZWYgc2hvdWxkIGJlIGFuIEFycmF5XG4gICAgICAvLyBvZiBtb2RlbE5hbWVzLlxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkobm9ybWFsaXplZFJlZikpIHtcbiAgICAgICAgbW9kZWxOYW1lcyA9IG5vcm1hbGl6ZWRSZWY7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtb2RlbE5hbWVzID0gW25vcm1hbGl6ZWRSZWZdO1xuICAgICAgfVxuICAgIH1cblxuICAgIGRhdGEuaXNWaXJ0dWFsID0gdHJ1ZTtcbiAgICBkYXRhLnZpcnR1YWwgPSB2aXJ0dWFsO1xuICAgIGRhdGEuanVzdE9uZSA9IGp1c3RPbmU7XG5cbiAgICAvLyBgbWF0Y2hgXG4gICAgY29uc3QgYmFzZU1hdGNoID0gZ2V0KGRhdGEsICd2aXJ0dWFsLm9wdGlvbnMubWF0Y2gnLCBudWxsKSB8fFxuICAgICAgZ2V0KGRhdGEsICd2aXJ0dWFsLm9wdGlvbnMub3B0aW9ucy5tYXRjaCcsIG51bGwpO1xuICAgIGxldCBtYXRjaCA9IGdldChvcHRpb25zLCAnbWF0Y2gnLCBudWxsKSB8fCBiYXNlTWF0Y2g7XG5cbiAgICBsZXQgaGFzTWF0Y2hGdW5jdGlvbiA9IHR5cGVvZiBtYXRjaCA9PT0gJ2Z1bmN0aW9uJztcbiAgICBpZiAoaGFzTWF0Y2hGdW5jdGlvbikge1xuICAgICAgbWF0Y2ggPSBtYXRjaC5jYWxsKGRvYywgZG9jLCBkYXRhLnZpcnR1YWwpO1xuICAgIH1cblxuICAgIGlmIChBcnJheS5pc0FycmF5KGxvY2FsRmllbGQpICYmIEFycmF5LmlzQXJyYXkoZm9yZWlnbkZpZWxkKSAmJiBsb2NhbEZpZWxkLmxlbmd0aCA9PT0gZm9yZWlnbkZpZWxkLmxlbmd0aCkge1xuICAgICAgbWF0Y2ggPSBPYmplY3QuYXNzaWduKHt9LCBtYXRjaCk7XG4gICAgICBmb3IgKGxldCBpID0gMTsgaSA8IGxvY2FsRmllbGQubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgbWF0Y2hbZm9yZWlnbkZpZWxkW2ldXSA9IGNvbnZlcnRUb19pZChtcGF0aC5nZXQobG9jYWxGaWVsZFtpXSwgZG9jLCBsb29rdXBMb2NhbEZpZWxkcyksIG1vZGVsLnNjaGVtYSk7XG4gICAgICAgIGhhc01hdGNoRnVuY3Rpb24gPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBsb2NhbEZpZWxkID0gbG9jYWxGaWVsZFswXTtcbiAgICAgIGZvcmVpZ25GaWVsZCA9IGZvcmVpZ25GaWVsZFswXTtcbiAgICB9XG4gICAgZGF0YS5sb2NhbEZpZWxkID0gbG9jYWxGaWVsZDtcbiAgICBkYXRhLmZvcmVpZ25GaWVsZCA9IGZvcmVpZ25GaWVsZDtcbiAgICBkYXRhLm1hdGNoID0gbWF0Y2g7XG4gICAgZGF0YS5oYXNNYXRjaEZ1bmN0aW9uID0gaGFzTWF0Y2hGdW5jdGlvbjtcblxuICAgIC8vIEdldCBsb2NhbCBmaWVsZHNcbiAgICBjb25zdCByZXQgPSBfZ2V0TG9jYWxGaWVsZFZhbHVlcyhkb2MsIGxvY2FsRmllbGQsIG1vZGVsLCBvcHRpb25zLCB2aXJ0dWFsKTtcblxuICAgIHRyeSB7XG4gICAgICBhZGRNb2RlbE5hbWVzVG9NYXAobW9kZWwsIG1hcCwgYXZhaWxhYmxlLCBtb2RlbE5hbWVzLCBvcHRpb25zLCBkYXRhLCByZXQsIGRvYyk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICByZXR1cm4gZXJyO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBtYXA7XG59XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxuZnVuY3Rpb24gYWRkTW9kZWxOYW1lc1RvTWFwKG1vZGVsLCBtYXAsIGF2YWlsYWJsZSwgbW9kZWxOYW1lcywgb3B0aW9ucywgZGF0YSwgcmV0LCBkb2MsIHNjaGVtYU9wdGlvbnMsIHVucG9wdWxhdGVkVmFsdWUpIHtcbiAgLy8gYFBvcHVsYXRlT3B0aW9ucyNjb25uZWN0aW9uYDogaWYgdGhlIG1vZGVsIGlzIHBhc3NlZCBhcyBhIHN0cmluZywgdGhlXG4gIC8vIGNvbm5lY3Rpb24gbWF0dGVycyBiZWNhdXNlIGRpZmZlcmVudCBjb25uZWN0aW9ucyBoYXZlIGRpZmZlcmVudCBtb2RlbHMuXG4gIGNvbnN0IGNvbm5lY3Rpb24gPSBvcHRpb25zLmNvbm5lY3Rpb24gIT0gbnVsbCA/IG9wdGlvbnMuY29ubmVjdGlvbiA6IG1vZGVsLmRiO1xuXG4gIHVucG9wdWxhdGVkVmFsdWUgPSB1bnBvcHVsYXRlZFZhbHVlID09PSB2b2lkIDAgPyByZXQgOiB1bnBvcHVsYXRlZFZhbHVlO1xuICBpZiAoQXJyYXkuaXNBcnJheSh1bnBvcHVsYXRlZFZhbHVlKSkge1xuICAgIHVucG9wdWxhdGVkVmFsdWUgPSB1dGlscy5jbG9uZUFycmF5cyh1bnBvcHVsYXRlZFZhbHVlKTtcbiAgfVxuXG4gIGlmIChtb2RlbE5hbWVzID09IG51bGwpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBsZXQgayA9IG1vZGVsTmFtZXMubGVuZ3RoO1xuICB3aGlsZSAoay0tKSB7XG4gICAgbGV0IG1vZGVsTmFtZSA9IG1vZGVsTmFtZXNba107XG4gICAgaWYgKG1vZGVsTmFtZSA9PSBudWxsKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBsZXQgTW9kZWw7XG4gICAgaWYgKG9wdGlvbnMubW9kZWwgJiYgb3B0aW9ucy5tb2RlbFttb2RlbFN5bWJvbF0pIHtcbiAgICAgIE1vZGVsID0gb3B0aW9ucy5tb2RlbDtcbiAgICB9IGVsc2UgaWYgKG1vZGVsTmFtZVttb2RlbFN5bWJvbF0pIHtcbiAgICAgIE1vZGVsID0gbW9kZWxOYW1lO1xuICAgICAgbW9kZWxOYW1lID0gTW9kZWwubW9kZWxOYW1lO1xuICAgIH0gZWxzZSB7XG4gICAgICB0cnkge1xuICAgICAgICBNb2RlbCA9IF9nZXRNb2RlbEZyb21Db25uKGNvbm5lY3Rpb24sIG1vZGVsTmFtZSk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgaWYgKHJldCAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9XG4gICAgICAgIE1vZGVsID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBsZXQgaWRzID0gcmV0O1xuICAgIGNvbnN0IGZsYXQgPSBBcnJheS5pc0FycmF5KHJldCkgPyB1dGlscy5hcnJheS5mbGF0dGVuKHJldCkgOiBbXTtcblxuICAgIGNvbnN0IG1vZGVsTmFtZXNGb3JSZWZQYXRoID0gZGF0YS5tb2RlbE5hbWVzSW5PcmRlciA/IGRhdGEubW9kZWxOYW1lc0luT3JkZXIgOiBtb2RlbE5hbWVzO1xuICAgIGlmIChkYXRhLmlzUmVmUGF0aCAmJiBBcnJheS5pc0FycmF5KHJldCkgJiYgZmxhdC5sZW5ndGggPT09IG1vZGVsTmFtZXNGb3JSZWZQYXRoLmxlbmd0aCkge1xuICAgICAgaWRzID0gZmxhdC5maWx0ZXIoKHZhbCwgaSkgPT4gbW9kZWxOYW1lc0ZvclJlZlBhdGhbaV0gPT09IG1vZGVsTmFtZSk7XG4gICAgfVxuXG4gICAgY29uc3QgcGVyRG9jdW1lbnRMaW1pdCA9IG9wdGlvbnMucGVyRG9jdW1lbnRMaW1pdCA9PSBudWxsID9cbiAgICAgIGdldChvcHRpb25zLCAnb3B0aW9ucy5wZXJEb2N1bWVudExpbWl0JywgbnVsbCkgOlxuICAgICAgb3B0aW9ucy5wZXJEb2N1bWVudExpbWl0O1xuXG4gICAgaWYgKCFhdmFpbGFibGVbbW9kZWxOYW1lXSB8fCBwZXJEb2N1bWVudExpbWl0ICE9IG51bGwpIHtcbiAgICAgIGNvbnN0IGN1cnJlbnRPcHRpb25zID0ge1xuICAgICAgICBtb2RlbDogTW9kZWxcbiAgICAgIH07XG4gICAgICBpZiAoZGF0YS5pc1ZpcnR1YWwgJiYgZ2V0KGRhdGEudmlydHVhbCwgJ29wdGlvbnMub3B0aW9ucycpKSB7XG4gICAgICAgIGN1cnJlbnRPcHRpb25zLm9wdGlvbnMgPSBjbG9uZShkYXRhLnZpcnR1YWwub3B0aW9ucy5vcHRpb25zKTtcbiAgICAgIH0gZWxzZSBpZiAoc2NoZW1hT3B0aW9ucyAhPSBudWxsKSB7XG4gICAgICAgIGN1cnJlbnRPcHRpb25zLm9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBzY2hlbWFPcHRpb25zKTtcbiAgICAgIH1cbiAgICAgIHV0aWxzLm1lcmdlKGN1cnJlbnRPcHRpb25zLCBvcHRpb25zKTtcblxuICAgICAgLy8gVXNlZCBpbnRlcm5hbGx5IGZvciBjaGVja2luZyB3aGF0IG1vZGVsIHdhcyB1c2VkIHRvIHBvcHVsYXRlIHRoaXNcbiAgICAgIC8vIHBhdGguXG4gICAgICBvcHRpb25zW3BvcHVsYXRlTW9kZWxTeW1ib2xdID0gTW9kZWw7XG4gICAgICBjdXJyZW50T3B0aW9uc1twb3B1bGF0ZU1vZGVsU3ltYm9sXSA9IE1vZGVsO1xuICAgICAgYXZhaWxhYmxlW21vZGVsTmFtZV0gPSB7XG4gICAgICAgIG1vZGVsOiBNb2RlbCxcbiAgICAgICAgb3B0aW9uczogY3VycmVudE9wdGlvbnMsXG4gICAgICAgIG1hdGNoOiBkYXRhLmhhc01hdGNoRnVuY3Rpb24gPyBbZGF0YS5tYXRjaF0gOiBkYXRhLm1hdGNoLFxuICAgICAgICBkb2NzOiBbZG9jXSxcbiAgICAgICAgaWRzOiBbaWRzXSxcbiAgICAgICAgYWxsSWRzOiBbcmV0XSxcbiAgICAgICAgdW5wb3B1bGF0ZWRWYWx1ZXM6IFt1bnBvcHVsYXRlZFZhbHVlXSxcbiAgICAgICAgbG9jYWxGaWVsZDogbmV3IFNldChbZGF0YS5sb2NhbEZpZWxkXSksXG4gICAgICAgIGZvcmVpZ25GaWVsZDogbmV3IFNldChbZGF0YS5mb3JlaWduRmllbGRdKSxcbiAgICAgICAganVzdE9uZTogZGF0YS5qdXN0T25lLFxuICAgICAgICBpc1ZpcnR1YWw6IGRhdGEuaXNWaXJ0dWFsLFxuICAgICAgICB2aXJ0dWFsOiBkYXRhLnZpcnR1YWwsXG4gICAgICAgIGNvdW50OiBkYXRhLmNvdW50LFxuICAgICAgICBbcG9wdWxhdGVNb2RlbFN5bWJvbF06IE1vZGVsXG4gICAgICB9O1xuICAgICAgbWFwLnB1c2goYXZhaWxhYmxlW21vZGVsTmFtZV0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBhdmFpbGFibGVbbW9kZWxOYW1lXS5sb2NhbEZpZWxkLmFkZChkYXRhLmxvY2FsRmllbGQpO1xuICAgICAgYXZhaWxhYmxlW21vZGVsTmFtZV0uZm9yZWlnbkZpZWxkLmFkZChkYXRhLmZvcmVpZ25GaWVsZCk7XG4gICAgICBhdmFpbGFibGVbbW9kZWxOYW1lXS5kb2NzLnB1c2goZG9jKTtcbiAgICAgIGF2YWlsYWJsZVttb2RlbE5hbWVdLmlkcy5wdXNoKGlkcyk7XG4gICAgICBhdmFpbGFibGVbbW9kZWxOYW1lXS5hbGxJZHMucHVzaChyZXQpO1xuICAgICAgYXZhaWxhYmxlW21vZGVsTmFtZV0udW5wb3B1bGF0ZWRWYWx1ZXMucHVzaCh1bnBvcHVsYXRlZFZhbHVlKTtcbiAgICAgIGlmIChkYXRhLmhhc01hdGNoRnVuY3Rpb24pIHtcbiAgICAgICAgYXZhaWxhYmxlW21vZGVsTmFtZV0ubWF0Y2gucHVzaChkYXRhLm1hdGNoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gX2dldE1vZGVsRnJvbUNvbm4oY29ubiwgbW9kZWxOYW1lKSB7XG4gIC8qIElmIHRoaXMgY29ubmVjdGlvbiBoYXMgYSBwYXJlbnQgZnJvbSBgdXNlRGIoKWAsIGJ1YmJsZSB1cCB0byBwYXJlbnQncyBtb2RlbHMgKi9cbiAgaWYgKGNvbm4ubW9kZWxzW21vZGVsTmFtZV0gPT0gbnVsbCAmJiBjb25uLl9wYXJlbnQgIT0gbnVsbCkge1xuICAgIHJldHVybiBfZ2V0TW9kZWxGcm9tQ29ubihjb25uLl9wYXJlbnQsIG1vZGVsTmFtZSk7XG4gIH1cblxuICByZXR1cm4gY29ubi5tb2RlbChtb2RlbE5hbWUpO1xufVxuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cbmZ1bmN0aW9uIGhhbmRsZVJlZkZ1bmN0aW9uKHJlZiwgZG9jKSB7XG4gIGlmICh0eXBlb2YgcmVmID09PSAnZnVuY3Rpb24nICYmICFyZWZbbW9kZWxTeW1ib2xdKSB7XG4gICAgcmV0dXJuIHJlZi5jYWxsKGRvYywgZG9jKTtcbiAgfVxuICByZXR1cm4gcmVmO1xufVxuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cbmZ1bmN0aW9uIF9nZXRMb2NhbEZpZWxkVmFsdWVzKGRvYywgbG9jYWxGaWVsZCwgbW9kZWwsIG9wdGlvbnMsIHZpcnR1YWwsIHNjaGVtYSkge1xuICAvLyBHZXQgTG9jYWwgZmllbGRzXG4gIGNvbnN0IGxvY2FsRmllbGRQYXRoVHlwZSA9IG1vZGVsLnNjaGVtYS5fZ2V0UGF0aFR5cGUobG9jYWxGaWVsZCk7XG4gIGNvbnN0IGxvY2FsRmllbGRQYXRoID0gbG9jYWxGaWVsZFBhdGhUeXBlID09PSAncmVhbCcgP1xuICAgIG1vZGVsLnNjaGVtYS5wYXRoKGxvY2FsRmllbGQpIDpcbiAgICBsb2NhbEZpZWxkUGF0aFR5cGUuc2NoZW1hO1xuICBjb25zdCBsb2NhbEZpZWxkR2V0dGVycyA9IGxvY2FsRmllbGRQYXRoICYmIGxvY2FsRmllbGRQYXRoLmdldHRlcnMgP1xuICAgIGxvY2FsRmllbGRQYXRoLmdldHRlcnMgOiBbXTtcblxuICBsb2NhbEZpZWxkID0gbG9jYWxGaWVsZFBhdGggIT0gbnVsbCAmJiBsb2NhbEZpZWxkUGF0aC5pbnN0YW5jZSA9PT0gJ0VtYmVkZGVkJyA/IGxvY2FsRmllbGQgKyAnLl9pZCcgOiBsb2NhbEZpZWxkO1xuXG4gIGNvbnN0IF9wb3B1bGF0ZU9wdGlvbnMgPSBnZXQob3B0aW9ucywgJ29wdGlvbnMnLCB7fSk7XG5cbiAgY29uc3QgZ2V0dGVycyA9ICdnZXR0ZXJzJyBpbiBfcG9wdWxhdGVPcHRpb25zID9cbiAgICBfcG9wdWxhdGVPcHRpb25zLmdldHRlcnMgOlxuICAgIGdldCh2aXJ0dWFsLCAnb3B0aW9ucy5nZXR0ZXJzJywgZmFsc2UpO1xuICBpZiAobG9jYWxGaWVsZEdldHRlcnMubGVuZ3RoICE9PSAwICYmIGdldHRlcnMpIHtcbiAgICBjb25zdCBoeWRyYXRlZERvYyA9IChkb2MuJF9fICE9IG51bGwpID8gZG9jIDogbW9kZWwuaHlkcmF0ZShkb2MpO1xuICAgIGNvbnN0IGxvY2FsRmllbGRWYWx1ZSA9IHV0aWxzLmdldFZhbHVlKGxvY2FsRmllbGQsIGRvYyk7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkobG9jYWxGaWVsZFZhbHVlKSkge1xuICAgICAgY29uc3QgbG9jYWxGaWVsZEh5ZHJhdGVkVmFsdWUgPSB1dGlscy5nZXRWYWx1ZShsb2NhbEZpZWxkLnNwbGl0KCcuJykuc2xpY2UoMCwgLTEpLCBoeWRyYXRlZERvYyk7XG4gICAgICByZXR1cm4gbG9jYWxGaWVsZFZhbHVlLm1hcCgobG9jYWxGaWVsZEFyclZhbCwgbG9jYWxGaWVsZEFyckluZGV4KSA9PlxuICAgICAgICBsb2NhbEZpZWxkUGF0aC5hcHBseUdldHRlcnMobG9jYWxGaWVsZEFyclZhbCwgbG9jYWxGaWVsZEh5ZHJhdGVkVmFsdWVbbG9jYWxGaWVsZEFyckluZGV4XSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbG9jYWxGaWVsZFBhdGguYXBwbHlHZXR0ZXJzKGxvY2FsRmllbGRWYWx1ZSwgaHlkcmF0ZWREb2MpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gY29udmVydFRvX2lkKG1wYXRoLmdldChsb2NhbEZpZWxkLCBkb2MsIGxvb2t1cExvY2FsRmllbGRzKSwgc2NoZW1hKTtcbiAgfVxufVxuXG4vKipcbiAqIFJldHJpZXZlIHRoZSBfaWQgb2YgYHZhbGAgaWYgYSBEb2N1bWVudCBvciBBcnJheSBvZiBEb2N1bWVudHMuXG4gKlxuICogQHBhcmFtIHtBcnJheXxEb2N1bWVudHxBbnl9IHZhbFxuICogQHBhcmFtIHtTY2hlbWF9IHNjaGVtYVxuICogQHJldHVybiB7QXJyYXl8RG9jdW1lbnR8QW55fVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gY29udmVydFRvX2lkKHZhbCwgc2NoZW1hKSB7XG4gIGlmICh2YWwgIT0gbnVsbCAmJiB2YWwuJF9fICE9IG51bGwpIHtcbiAgICByZXR1cm4gdmFsLl9pZDtcbiAgfVxuICBpZiAodmFsICE9IG51bGwgJiYgdmFsLl9pZCAhPSBudWxsICYmIChzY2hlbWEgPT0gbnVsbCB8fCAhc2NoZW1hLiRpc1NjaGVtYU1hcCkpIHtcbiAgICByZXR1cm4gdmFsLl9pZDtcbiAgfVxuXG4gIGlmIChBcnJheS5pc0FycmF5KHZhbCkpIHtcbiAgICBjb25zdCByYXdWYWwgPSB2YWwuX19hcnJheSAhPSBudWxsID8gdmFsLl9fYXJyYXkgOiB2YWw7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCByYXdWYWwubGVuZ3RoOyArK2kpIHtcbiAgICAgIGlmIChyYXdWYWxbaV0gIT0gbnVsbCAmJiByYXdWYWxbaV0uJF9fICE9IG51bGwpIHtcbiAgICAgICAgcmF3VmFsW2ldID0gcmF3VmFsW2ldLl9pZDtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHV0aWxzLmlzTW9uZ29vc2VBcnJheSh2YWwpICYmIHZhbC4kc2NoZW1hKCkpIHtcbiAgICAgIHJldHVybiB2YWwuJHNjaGVtYSgpLl9jYXN0Rm9yUG9wdWxhdGUodmFsLCB2YWwuJHBhcmVudCgpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gW10uY29uY2F0KHZhbCk7XG4gIH1cblxuICAvLyBgcG9wdWxhdGUoJ21hcCcpYCBtYXkgYmUgYW4gb2JqZWN0IGlmIHBvcHVsYXRpbmcgb24gYSBkb2MgdGhhdCBoYXNuJ3RcbiAgLy8gYmVlbiBoeWRyYXRlZCB5ZXRcbiAgaWYgKGdldENvbnN0cnVjdG9yTmFtZSh2YWwpID09PSAnT2JqZWN0JyAmJlxuICAgICAgLy8gVGhlIGludGVudCBoZXJlIGlzIHdlIHNob3VsZCBvbmx5IGZsYXR0ZW4gdGhlIG9iamVjdCBpZiB3ZSBleHBlY3RcbiAgICAgIC8vIHRvIGdldCBhIE1hcCBpbiB0aGUgZW5kLiBBdm9pZCBkb2luZyB0aGlzIGZvciBtaXhlZCB0eXBlcy5cbiAgICAgIChzY2hlbWEgPT0gbnVsbCB8fCBzY2hlbWFbc2NoZW1hTWl4ZWRTeW1ib2xdID09IG51bGwpKSB7XG4gICAgY29uc3QgcmV0ID0gW107XG4gICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXModmFsKSkge1xuICAgICAgcmV0LnB1c2godmFsW2tleV0pO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xuICB9XG4gIC8vIElmIGRvYyBoYXMgYWxyZWFkeSBiZWVuIGh5ZHJhdGVkLCBlLmcuIGBkb2MucG9wdWxhdGUoJ21hcCcpYFxuICAvLyB0aGVuIGB2YWxgIHdpbGwgYWxyZWFkeSBiZSBhIG1hcFxuICBpZiAodmFsIGluc3RhbmNlb2YgTWFwKSB7XG4gICAgcmV0dXJuIEFycmF5LmZyb20odmFsLnZhbHVlcygpKTtcbiAgfVxuXG4gIHJldHVybiB2YWw7XG59XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxuZnVuY3Rpb24gX2ZpbmRSZWZQYXRoRm9yRGlzY3JpbWluYXRvcnMoZG9jLCBtb2RlbFNjaGVtYSwgZGF0YSwgb3B0aW9ucywgbm9ybWFsaXplZFJlZlBhdGgsIHJldCkge1xuICAvLyBSZTogZ2gtODQ1Mi4gRW1iZWRkZWQgZGlzY3JpbWluYXRvcnMgbWF5IG5vdCBoYXZlIGByZWZQYXRoYCwgc28gY2xlYXJcbiAgLy8gb3V0IGVtYmVkZGVkIGRpc2NyaW1pbmF0b3IgZG9jcyB0aGF0IGRvbid0IGhhdmUgYSBgcmVmUGF0aGAgb24gdGhlXG4gIC8vIHBvcHVsYXRlZCBwYXRoLlxuICBpZiAoIWRhdGEuaXNSZWZQYXRoIHx8IG5vcm1hbGl6ZWRSZWZQYXRoID09IG51bGwpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBjb25zdCBwaWVjZXMgPSBub3JtYWxpemVkUmVmUGF0aC5zcGxpdCgnLicpO1xuICBsZXQgY3VyID0gJyc7XG4gIGxldCBtb2RlbE5hbWVzID0gdm9pZCAwO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHBpZWNlcy5sZW5ndGg7ICsraSkge1xuICAgIGNvbnN0IHBpZWNlID0gcGllY2VzW2ldO1xuICAgIGN1ciA9IGN1ciArIChjdXIubGVuZ3RoID09PSAwID8gJycgOiAnLicpICsgcGllY2U7XG4gICAgY29uc3Qgc2NoZW1hdHlwZSA9IG1vZGVsU2NoZW1hLnBhdGgoY3VyKTtcbiAgICBpZiAoc2NoZW1hdHlwZSAhPSBudWxsICYmXG4gICAgICAgIHNjaGVtYXR5cGUuJGlzTW9uZ29vc2VBcnJheSAmJlxuICAgICAgICBzY2hlbWF0eXBlLmNhc3Rlci5kaXNjcmltaW5hdG9ycyAhPSBudWxsICYmXG4gICAgICAgIE9iamVjdC5rZXlzKHNjaGVtYXR5cGUuY2FzdGVyLmRpc2NyaW1pbmF0b3JzKS5sZW5ndGggIT09IDApIHtcbiAgICAgIGNvbnN0IHN1YmRvY3MgPSB1dGlscy5nZXRWYWx1ZShjdXIsIGRvYyk7XG4gICAgICBjb25zdCByZW1uYW50ID0gb3B0aW9ucy5wYXRoLnN1YnN0cmluZyhjdXIubGVuZ3RoICsgMSk7XG4gICAgICBjb25zdCBkaXNjcmltaW5hdG9yS2V5ID0gc2NoZW1hdHlwZS5jYXN0ZXIuc2NoZW1hLm9wdGlvbnMuZGlzY3JpbWluYXRvcktleTtcbiAgICAgIG1vZGVsTmFtZXMgPSBbXTtcbiAgICAgIGZvciAoY29uc3Qgc3ViZG9jIG9mIHN1YmRvY3MpIHtcbiAgICAgICAgY29uc3QgZGlzY3JpbWluYXRvck5hbWUgPSB1dGlscy5nZXRWYWx1ZShkaXNjcmltaW5hdG9yS2V5LCBzdWJkb2MpO1xuICAgICAgICBjb25zdCBkaXNjcmltaW5hdG9yID0gc2NoZW1hdHlwZS5jYXN0ZXIuZGlzY3JpbWluYXRvcnNbZGlzY3JpbWluYXRvck5hbWVdO1xuICAgICAgICBjb25zdCBkaXNjcmltaW5hdG9yU2NoZW1hID0gZGlzY3JpbWluYXRvciAmJiBkaXNjcmltaW5hdG9yLnNjaGVtYTtcbiAgICAgICAgaWYgKGRpc2NyaW1pbmF0b3JTY2hlbWEgPT0gbnVsbCkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IF9wYXRoID0gZGlzY3JpbWluYXRvclNjaGVtYS5wYXRoKHJlbW5hbnQpO1xuICAgICAgICBpZiAoX3BhdGggPT0gbnVsbCB8fCBfcGF0aC5vcHRpb25zLnJlZlBhdGggPT0gbnVsbCkge1xuICAgICAgICAgIGNvbnN0IGRvY1ZhbHVlID0gdXRpbHMuZ2V0VmFsdWUoZGF0YS5sb2NhbEZpZWxkLnN1YnN0cmluZyhjdXIubGVuZ3RoICsgMSksIHN1YmRvYyk7XG4gICAgICAgICAgcmV0LmZvckVhY2goKHYsIGkpID0+IHtcbiAgICAgICAgICAgIGlmICh2ID09PSBkb2NWYWx1ZSkge1xuICAgICAgICAgICAgICByZXRbaV0gPSBTa2lwUG9wdWxhdGVWYWx1ZSh2KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtb2RlbE5hbWUgPSB1dGlscy5nZXRWYWx1ZShwaWVjZXMuc2xpY2UoaSArIDEpLmpvaW4oJy4nKSwgc3ViZG9jKTtcbiAgICAgICAgbW9kZWxOYW1lcy5wdXNoKG1vZGVsTmFtZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG1vZGVsTmFtZXM7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../server/node_modules/mongoose/lib/helpers/populate/getModelsMapForPopulate.js\n");

/***/ }),

/***/ "../server/node_modules/mongoose/lib/helpers/populate/getSchemaTypes.js":
/*!******************************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/helpers/populate/getSchemaTypes.js ***!
  \******************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\n/*!\n * ignore\n */\n\nconst Mixed = __webpack_require__(/*! ../../schema/mixed */ \"../server/node_modules/mongoose/lib/schema/mixed.js\");\nconst get = __webpack_require__(/*! ../get */ \"../server/node_modules/mongoose/lib/helpers/get.js\");\nconst getDiscriminatorByValue = __webpack_require__(/*! ../discriminator/getDiscriminatorByValue */ \"../server/node_modules/mongoose/lib/helpers/discriminator/getDiscriminatorByValue.js\");\nconst leanPopulateMap = __webpack_require__(/*! ./leanPopulateMap */ \"../server/node_modules/mongoose/lib/helpers/populate/leanPopulateMap.js\");\nconst mpath = __webpack_require__(/*! mpath */ \"../server/node_modules/mpath/index.js\");\n\nconst populateModelSymbol = (__webpack_require__(/*! ../symbols */ \"../server/node_modules/mongoose/lib/helpers/symbols.js\").populateModelSymbol);\n\n/**\n * Given a model and its schema, find all possible schema types for `path`,\n * including searching through discriminators. If `doc` is specified, will\n * use the doc's values for discriminator keys when searching, otherwise\n * will search all discriminators.\n *\n * @param {Model} model\n * @param {Schema} schema\n * @param {Object} doc POJO\n * @param {string} path\n * @api private\n */\n\nmodule.exports = function getSchemaTypes(model, schema, doc, path) {\n  const pathschema = schema.path(path);\n  const topLevelDoc = doc;\n  if (pathschema) {\n    return pathschema;\n  }\n\n  const discriminatorKey = schema.discriminatorMapping &&\n    schema.discriminatorMapping.key;\n  if (discriminatorKey && model != null) {\n    if (doc != null && doc[discriminatorKey] != null) {\n      const discriminator = getDiscriminatorByValue(model.discriminators, doc[discriminatorKey]);\n      schema = discriminator ? discriminator.schema : schema;\n    } else if (model.discriminators != null) {\n      return Object.keys(model.discriminators).reduce((arr, name) => {\n        const disc = model.discriminators[name];\n        return arr.concat(getSchemaTypes(disc, disc.schema, null, path));\n      }, []);\n    }\n  }\n\n  function search(parts, schema, subdoc, nestedPath) {\n    let p = parts.length + 1;\n    let foundschema;\n    let trypath;\n\n    while (p--) {\n      trypath = parts.slice(0, p).join('.');\n      foundschema = schema.path(trypath);\n      if (foundschema == null) {\n        continue;\n      }\n\n      if (foundschema.caster) {\n        // array of Mixed?\n        if (foundschema.caster instanceof Mixed) {\n          return foundschema.caster;\n        }\n\n        let schemas = null;\n        if (foundschema.schema != null && foundschema.schema.discriminators != null) {\n          const discriminators = foundschema.schema.discriminators;\n          const discriminatorKeyPath = trypath + '.' +\n            foundschema.schema.options.discriminatorKey;\n          const keys = subdoc ? mpath.get(discriminatorKeyPath, subdoc) || [] : [];\n          schemas = Object.keys(discriminators).\n            reduce(function(cur, discriminator) {\n              const tiedValue = discriminators[discriminator].discriminatorMapping.value;\n              if (doc == null || keys.indexOf(discriminator) !== -1 || keys.indexOf(tiedValue) !== -1) {\n                cur.push(discriminators[discriminator]);\n              }\n              return cur;\n            }, []);\n        }\n\n        // Now that we found the array, we need to check if there\n        // are remaining document paths to look up for casting.\n        // Also we need to handle array.$.path since schema.path\n        // doesn't work for that.\n        // If there is no foundschema.schema we are dealing with\n        // a path like array.$\n        if (p !== parts.length && foundschema.schema) {\n          let ret;\n          if (parts[p] === '$') {\n            if (p + 1 === parts.length) {\n              // comments.$\n              return foundschema;\n            }\n            // comments.$.comments.$.title\n            ret = search(\n              parts.slice(p + 1),\n              schema,\n              subdoc ? mpath.get(trypath, subdoc) : null,\n              nestedPath.concat(parts.slice(0, p))\n            );\n            if (ret) {\n              ret.$parentSchemaDocArray = ret.$parentSchemaDocArray ||\n                (foundschema.schema.$isSingleNested ? null : foundschema);\n            }\n            return ret;\n          }\n\n          if (schemas != null && schemas.length > 0) {\n            ret = [];\n            for (const schema of schemas) {\n              const _ret = search(\n                parts.slice(p),\n                schema,\n                subdoc ? mpath.get(trypath, subdoc) : null,\n                nestedPath.concat(parts.slice(0, p))\n              );\n              if (_ret != null) {\n                _ret.$parentSchemaDocArray = _ret.$parentSchemaDocArray ||\n                  (foundschema.schema.$isSingleNested ? null : foundschema);\n                if (_ret.$parentSchemaDocArray) {\n                  ret.$parentSchemaDocArray = _ret.$parentSchemaDocArray;\n                }\n                ret.push(_ret);\n              }\n            }\n            return ret;\n          } else {\n            ret = search(\n              parts.slice(p),\n              foundschema.schema,\n              subdoc ? mpath.get(trypath, subdoc) : null,\n              nestedPath.concat(parts.slice(0, p))\n            );\n\n            if (ret) {\n              ret.$parentSchemaDocArray = ret.$parentSchemaDocArray ||\n                (foundschema.schema.$isSingleNested ? null : foundschema);\n            }\n            return ret;\n          }\n        } else if (p !== parts.length &&\n            foundschema.$isMongooseArray &&\n            foundschema.casterConstructor.$isMongooseArray) {\n          // Nested arrays. Drill down to the bottom of the nested array.\n          let type = foundschema;\n          while (type.$isMongooseArray && !type.$isMongooseDocumentArray) {\n            type = type.casterConstructor;\n          }\n\n          const ret = search(\n            parts.slice(p),\n            type.schema,\n            null,\n            nestedPath.concat(parts.slice(0, p))\n          );\n          if (ret != null) {\n            return ret;\n          }\n\n          if (type.schema.discriminators) {\n            const discriminatorPaths = [];\n            for (const discriminatorName of Object.keys(type.schema.discriminators)) {\n              const _schema = type.schema.discriminators[discriminatorName] || type.schema;\n              const ret = search(parts.slice(p), _schema, null, nestedPath.concat(parts.slice(0, p)));\n              if (ret != null) {\n                discriminatorPaths.push(ret);\n              }\n            }\n            if (discriminatorPaths.length > 0) {\n              return discriminatorPaths;\n            }\n          }\n        }\n      } else if (foundschema.$isSchemaMap && foundschema.$__schemaType instanceof Mixed) {\n        return foundschema.$__schemaType;\n      }\n\n      const fullPath = nestedPath.concat([trypath]).join('.');\n      if (topLevelDoc != null && topLevelDoc.$__ && topLevelDoc.$populated(fullPath) && p < parts.length) {\n        const model = doc.$__.populated[fullPath].options[populateModelSymbol];\n        if (model != null) {\n          const ret = search(\n            parts.slice(p),\n            model.schema,\n            subdoc ? mpath.get(trypath, subdoc) : null,\n            nestedPath.concat(parts.slice(0, p))\n          );\n\n          return ret;\n        }\n      }\n\n      const _val = get(topLevelDoc, trypath);\n      if (_val != null) {\n        const model = Array.isArray(_val) && _val.length > 0 ?\n          leanPopulateMap.get(_val[0]) :\n          leanPopulateMap.get(_val);\n        // Populated using lean, `leanPopulateMap` value is the foreign model\n        const schema = model != null ? model.schema : null;\n        if (schema != null) {\n          const ret = search(\n            parts.slice(p),\n            schema,\n            subdoc ? mpath.get(trypath, subdoc) : null,\n            nestedPath.concat(parts.slice(0, p))\n          );\n\n          if (ret != null) {\n            ret.$parentSchemaDocArray = ret.$parentSchemaDocArray ||\n              (schema.$isSingleNested ? null : schema);\n            return ret;\n          }\n        }\n      }\n      return foundschema;\n    }\n  }\n  // look for arrays\n  const parts = path.split('.');\n  for (let i = 0; i < parts.length; ++i) {\n    if (parts[i] === '$') {\n      // Re: gh-5628, because `schema.path()` doesn't take $ into account.\n      parts[i] = '0';\n    }\n  }\n  return search(parts, schema, doc, []);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9wb3B1bGF0ZS9nZXRTY2hlbWFUeXBlcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBO0FBQ0E7O0FBRUEsY0FBYyxtQkFBTyxDQUFDLCtFQUFvQjtBQUMxQyxZQUFZLG1CQUFPLENBQUMsa0VBQVE7QUFDNUIsZ0NBQWdDLG1CQUFPLENBQUMsc0lBQTBDO0FBQ2xGLHdCQUF3QixtQkFBTyxDQUFDLGtHQUFtQjtBQUNuRCxjQUFjLG1CQUFPLENBQUMsb0RBQU87O0FBRTdCLDRCQUE0QixxSEFBeUM7O0FBRXJFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGtCQUFrQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2NsaWVudC8uLi9zZXJ2ZXIvbm9kZV9tb2R1bGVzL21vbmdvb3NlL2xpYi9oZWxwZXJzL3BvcHVsYXRlL2dldFNjaGVtYVR5cGVzLmpzP2QzMjkiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cbmNvbnN0IE1peGVkID0gcmVxdWlyZSgnLi4vLi4vc2NoZW1hL21peGVkJyk7XG5jb25zdCBnZXQgPSByZXF1aXJlKCcuLi9nZXQnKTtcbmNvbnN0IGdldERpc2NyaW1pbmF0b3JCeVZhbHVlID0gcmVxdWlyZSgnLi4vZGlzY3JpbWluYXRvci9nZXREaXNjcmltaW5hdG9yQnlWYWx1ZScpO1xuY29uc3QgbGVhblBvcHVsYXRlTWFwID0gcmVxdWlyZSgnLi9sZWFuUG9wdWxhdGVNYXAnKTtcbmNvbnN0IG1wYXRoID0gcmVxdWlyZSgnbXBhdGgnKTtcblxuY29uc3QgcG9wdWxhdGVNb2RlbFN5bWJvbCA9IHJlcXVpcmUoJy4uL3N5bWJvbHMnKS5wb3B1bGF0ZU1vZGVsU3ltYm9sO1xuXG4vKipcbiAqIEdpdmVuIGEgbW9kZWwgYW5kIGl0cyBzY2hlbWEsIGZpbmQgYWxsIHBvc3NpYmxlIHNjaGVtYSB0eXBlcyBmb3IgYHBhdGhgLFxuICogaW5jbHVkaW5nIHNlYXJjaGluZyB0aHJvdWdoIGRpc2NyaW1pbmF0b3JzLiBJZiBgZG9jYCBpcyBzcGVjaWZpZWQsIHdpbGxcbiAqIHVzZSB0aGUgZG9jJ3MgdmFsdWVzIGZvciBkaXNjcmltaW5hdG9yIGtleXMgd2hlbiBzZWFyY2hpbmcsIG90aGVyd2lzZVxuICogd2lsbCBzZWFyY2ggYWxsIGRpc2NyaW1pbmF0b3JzLlxuICpcbiAqIEBwYXJhbSB7TW9kZWx9IG1vZGVsXG4gKiBAcGFyYW0ge1NjaGVtYX0gc2NoZW1hXG4gKiBAcGFyYW0ge09iamVjdH0gZG9jIFBPSk9cbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGdldFNjaGVtYVR5cGVzKG1vZGVsLCBzY2hlbWEsIGRvYywgcGF0aCkge1xuICBjb25zdCBwYXRoc2NoZW1hID0gc2NoZW1hLnBhdGgocGF0aCk7XG4gIGNvbnN0IHRvcExldmVsRG9jID0gZG9jO1xuICBpZiAocGF0aHNjaGVtYSkge1xuICAgIHJldHVybiBwYXRoc2NoZW1hO1xuICB9XG5cbiAgY29uc3QgZGlzY3JpbWluYXRvcktleSA9IHNjaGVtYS5kaXNjcmltaW5hdG9yTWFwcGluZyAmJlxuICAgIHNjaGVtYS5kaXNjcmltaW5hdG9yTWFwcGluZy5rZXk7XG4gIGlmIChkaXNjcmltaW5hdG9yS2V5ICYmIG1vZGVsICE9IG51bGwpIHtcbiAgICBpZiAoZG9jICE9IG51bGwgJiYgZG9jW2Rpc2NyaW1pbmF0b3JLZXldICE9IG51bGwpIHtcbiAgICAgIGNvbnN0IGRpc2NyaW1pbmF0b3IgPSBnZXREaXNjcmltaW5hdG9yQnlWYWx1ZShtb2RlbC5kaXNjcmltaW5hdG9ycywgZG9jW2Rpc2NyaW1pbmF0b3JLZXldKTtcbiAgICAgIHNjaGVtYSA9IGRpc2NyaW1pbmF0b3IgPyBkaXNjcmltaW5hdG9yLnNjaGVtYSA6IHNjaGVtYTtcbiAgICB9IGVsc2UgaWYgKG1vZGVsLmRpc2NyaW1pbmF0b3JzICE9IG51bGwpIHtcbiAgICAgIHJldHVybiBPYmplY3Qua2V5cyhtb2RlbC5kaXNjcmltaW5hdG9ycykucmVkdWNlKChhcnIsIG5hbWUpID0+IHtcbiAgICAgICAgY29uc3QgZGlzYyA9IG1vZGVsLmRpc2NyaW1pbmF0b3JzW25hbWVdO1xuICAgICAgICByZXR1cm4gYXJyLmNvbmNhdChnZXRTY2hlbWFUeXBlcyhkaXNjLCBkaXNjLnNjaGVtYSwgbnVsbCwgcGF0aCkpO1xuICAgICAgfSwgW10pO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHNlYXJjaChwYXJ0cywgc2NoZW1hLCBzdWJkb2MsIG5lc3RlZFBhdGgpIHtcbiAgICBsZXQgcCA9IHBhcnRzLmxlbmd0aCArIDE7XG4gICAgbGV0IGZvdW5kc2NoZW1hO1xuICAgIGxldCB0cnlwYXRoO1xuXG4gICAgd2hpbGUgKHAtLSkge1xuICAgICAgdHJ5cGF0aCA9IHBhcnRzLnNsaWNlKDAsIHApLmpvaW4oJy4nKTtcbiAgICAgIGZvdW5kc2NoZW1hID0gc2NoZW1hLnBhdGgodHJ5cGF0aCk7XG4gICAgICBpZiAoZm91bmRzY2hlbWEgPT0gbnVsbCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKGZvdW5kc2NoZW1hLmNhc3Rlcikge1xuICAgICAgICAvLyBhcnJheSBvZiBNaXhlZD9cbiAgICAgICAgaWYgKGZvdW5kc2NoZW1hLmNhc3RlciBpbnN0YW5jZW9mIE1peGVkKSB7XG4gICAgICAgICAgcmV0dXJuIGZvdW5kc2NoZW1hLmNhc3RlcjtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBzY2hlbWFzID0gbnVsbDtcbiAgICAgICAgaWYgKGZvdW5kc2NoZW1hLnNjaGVtYSAhPSBudWxsICYmIGZvdW5kc2NoZW1hLnNjaGVtYS5kaXNjcmltaW5hdG9ycyAhPSBudWxsKSB7XG4gICAgICAgICAgY29uc3QgZGlzY3JpbWluYXRvcnMgPSBmb3VuZHNjaGVtYS5zY2hlbWEuZGlzY3JpbWluYXRvcnM7XG4gICAgICAgICAgY29uc3QgZGlzY3JpbWluYXRvcktleVBhdGggPSB0cnlwYXRoICsgJy4nICtcbiAgICAgICAgICAgIGZvdW5kc2NoZW1hLnNjaGVtYS5vcHRpb25zLmRpc2NyaW1pbmF0b3JLZXk7XG4gICAgICAgICAgY29uc3Qga2V5cyA9IHN1YmRvYyA/IG1wYXRoLmdldChkaXNjcmltaW5hdG9yS2V5UGF0aCwgc3ViZG9jKSB8fCBbXSA6IFtdO1xuICAgICAgICAgIHNjaGVtYXMgPSBPYmplY3Qua2V5cyhkaXNjcmltaW5hdG9ycykuXG4gICAgICAgICAgICByZWR1Y2UoZnVuY3Rpb24oY3VyLCBkaXNjcmltaW5hdG9yKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHRpZWRWYWx1ZSA9IGRpc2NyaW1pbmF0b3JzW2Rpc2NyaW1pbmF0b3JdLmRpc2NyaW1pbmF0b3JNYXBwaW5nLnZhbHVlO1xuICAgICAgICAgICAgICBpZiAoZG9jID09IG51bGwgfHwga2V5cy5pbmRleE9mKGRpc2NyaW1pbmF0b3IpICE9PSAtMSB8fCBrZXlzLmluZGV4T2YodGllZFZhbHVlKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICBjdXIucHVzaChkaXNjcmltaW5hdG9yc1tkaXNjcmltaW5hdG9yXSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIGN1cjtcbiAgICAgICAgICAgIH0sIFtdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE5vdyB0aGF0IHdlIGZvdW5kIHRoZSBhcnJheSwgd2UgbmVlZCB0byBjaGVjayBpZiB0aGVyZVxuICAgICAgICAvLyBhcmUgcmVtYWluaW5nIGRvY3VtZW50IHBhdGhzIHRvIGxvb2sgdXAgZm9yIGNhc3RpbmcuXG4gICAgICAgIC8vIEFsc28gd2UgbmVlZCB0byBoYW5kbGUgYXJyYXkuJC5wYXRoIHNpbmNlIHNjaGVtYS5wYXRoXG4gICAgICAgIC8vIGRvZXNuJ3Qgd29yayBmb3IgdGhhdC5cbiAgICAgICAgLy8gSWYgdGhlcmUgaXMgbm8gZm91bmRzY2hlbWEuc2NoZW1hIHdlIGFyZSBkZWFsaW5nIHdpdGhcbiAgICAgICAgLy8gYSBwYXRoIGxpa2UgYXJyYXkuJFxuICAgICAgICBpZiAocCAhPT0gcGFydHMubGVuZ3RoICYmIGZvdW5kc2NoZW1hLnNjaGVtYSkge1xuICAgICAgICAgIGxldCByZXQ7XG4gICAgICAgICAgaWYgKHBhcnRzW3BdID09PSAnJCcpIHtcbiAgICAgICAgICAgIGlmIChwICsgMSA9PT0gcGFydHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIC8vIGNvbW1lbnRzLiRcbiAgICAgICAgICAgICAgcmV0dXJuIGZvdW5kc2NoZW1hO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gY29tbWVudHMuJC5jb21tZW50cy4kLnRpdGxlXG4gICAgICAgICAgICByZXQgPSBzZWFyY2goXG4gICAgICAgICAgICAgIHBhcnRzLnNsaWNlKHAgKyAxKSxcbiAgICAgICAgICAgICAgc2NoZW1hLFxuICAgICAgICAgICAgICBzdWJkb2MgPyBtcGF0aC5nZXQodHJ5cGF0aCwgc3ViZG9jKSA6IG51bGwsXG4gICAgICAgICAgICAgIG5lc3RlZFBhdGguY29uY2F0KHBhcnRzLnNsaWNlKDAsIHApKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGlmIChyZXQpIHtcbiAgICAgICAgICAgICAgcmV0LiRwYXJlbnRTY2hlbWFEb2NBcnJheSA9IHJldC4kcGFyZW50U2NoZW1hRG9jQXJyYXkgfHxcbiAgICAgICAgICAgICAgICAoZm91bmRzY2hlbWEuc2NoZW1hLiRpc1NpbmdsZU5lc3RlZCA/IG51bGwgOiBmb3VuZHNjaGVtYSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChzY2hlbWFzICE9IG51bGwgJiYgc2NoZW1hcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICByZXQgPSBbXTtcbiAgICAgICAgICAgIGZvciAoY29uc3Qgc2NoZW1hIG9mIHNjaGVtYXMpIHtcbiAgICAgICAgICAgICAgY29uc3QgX3JldCA9IHNlYXJjaChcbiAgICAgICAgICAgICAgICBwYXJ0cy5zbGljZShwKSxcbiAgICAgICAgICAgICAgICBzY2hlbWEsXG4gICAgICAgICAgICAgICAgc3ViZG9jID8gbXBhdGguZ2V0KHRyeXBhdGgsIHN1YmRvYykgOiBudWxsLFxuICAgICAgICAgICAgICAgIG5lc3RlZFBhdGguY29uY2F0KHBhcnRzLnNsaWNlKDAsIHApKVxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICBpZiAoX3JldCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgX3JldC4kcGFyZW50U2NoZW1hRG9jQXJyYXkgPSBfcmV0LiRwYXJlbnRTY2hlbWFEb2NBcnJheSB8fFxuICAgICAgICAgICAgICAgICAgKGZvdW5kc2NoZW1hLnNjaGVtYS4kaXNTaW5nbGVOZXN0ZWQgPyBudWxsIDogZm91bmRzY2hlbWEpO1xuICAgICAgICAgICAgICAgIGlmIChfcmV0LiRwYXJlbnRTY2hlbWFEb2NBcnJheSkge1xuICAgICAgICAgICAgICAgICAgcmV0LiRwYXJlbnRTY2hlbWFEb2NBcnJheSA9IF9yZXQuJHBhcmVudFNjaGVtYURvY0FycmF5O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXQucHVzaChfcmV0KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0ID0gc2VhcmNoKFxuICAgICAgICAgICAgICBwYXJ0cy5zbGljZShwKSxcbiAgICAgICAgICAgICAgZm91bmRzY2hlbWEuc2NoZW1hLFxuICAgICAgICAgICAgICBzdWJkb2MgPyBtcGF0aC5nZXQodHJ5cGF0aCwgc3ViZG9jKSA6IG51bGwsXG4gICAgICAgICAgICAgIG5lc3RlZFBhdGguY29uY2F0KHBhcnRzLnNsaWNlKDAsIHApKVxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgaWYgKHJldCkge1xuICAgICAgICAgICAgICByZXQuJHBhcmVudFNjaGVtYURvY0FycmF5ID0gcmV0LiRwYXJlbnRTY2hlbWFEb2NBcnJheSB8fFxuICAgICAgICAgICAgICAgIChmb3VuZHNjaGVtYS5zY2hlbWEuJGlzU2luZ2xlTmVzdGVkID8gbnVsbCA6IGZvdW5kc2NoZW1hKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHAgIT09IHBhcnRzLmxlbmd0aCAmJlxuICAgICAgICAgICAgZm91bmRzY2hlbWEuJGlzTW9uZ29vc2VBcnJheSAmJlxuICAgICAgICAgICAgZm91bmRzY2hlbWEuY2FzdGVyQ29uc3RydWN0b3IuJGlzTW9uZ29vc2VBcnJheSkge1xuICAgICAgICAgIC8vIE5lc3RlZCBhcnJheXMuIERyaWxsIGRvd24gdG8gdGhlIGJvdHRvbSBvZiB0aGUgbmVzdGVkIGFycmF5LlxuICAgICAgICAgIGxldCB0eXBlID0gZm91bmRzY2hlbWE7XG4gICAgICAgICAgd2hpbGUgKHR5cGUuJGlzTW9uZ29vc2VBcnJheSAmJiAhdHlwZS4kaXNNb25nb29zZURvY3VtZW50QXJyYXkpIHtcbiAgICAgICAgICAgIHR5cGUgPSB0eXBlLmNhc3RlckNvbnN0cnVjdG9yO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnN0IHJldCA9IHNlYXJjaChcbiAgICAgICAgICAgIHBhcnRzLnNsaWNlKHApLFxuICAgICAgICAgICAgdHlwZS5zY2hlbWEsXG4gICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgbmVzdGVkUGF0aC5jb25jYXQocGFydHMuc2xpY2UoMCwgcCkpXG4gICAgICAgICAgKTtcbiAgICAgICAgICBpZiAocmV0ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHR5cGUuc2NoZW1hLmRpc2NyaW1pbmF0b3JzKSB7XG4gICAgICAgICAgICBjb25zdCBkaXNjcmltaW5hdG9yUGF0aHMgPSBbXTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgZGlzY3JpbWluYXRvck5hbWUgb2YgT2JqZWN0LmtleXModHlwZS5zY2hlbWEuZGlzY3JpbWluYXRvcnMpKSB7XG4gICAgICAgICAgICAgIGNvbnN0IF9zY2hlbWEgPSB0eXBlLnNjaGVtYS5kaXNjcmltaW5hdG9yc1tkaXNjcmltaW5hdG9yTmFtZV0gfHwgdHlwZS5zY2hlbWE7XG4gICAgICAgICAgICAgIGNvbnN0IHJldCA9IHNlYXJjaChwYXJ0cy5zbGljZShwKSwgX3NjaGVtYSwgbnVsbCwgbmVzdGVkUGF0aC5jb25jYXQocGFydHMuc2xpY2UoMCwgcCkpKTtcbiAgICAgICAgICAgICAgaWYgKHJldCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZGlzY3JpbWluYXRvclBhdGhzLnB1c2gocmV0KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRpc2NyaW1pbmF0b3JQYXRocy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgIHJldHVybiBkaXNjcmltaW5hdG9yUGF0aHM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGZvdW5kc2NoZW1hLiRpc1NjaGVtYU1hcCAmJiBmb3VuZHNjaGVtYS4kX19zY2hlbWFUeXBlIGluc3RhbmNlb2YgTWl4ZWQpIHtcbiAgICAgICAgcmV0dXJuIGZvdW5kc2NoZW1hLiRfX3NjaGVtYVR5cGU7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGZ1bGxQYXRoID0gbmVzdGVkUGF0aC5jb25jYXQoW3RyeXBhdGhdKS5qb2luKCcuJyk7XG4gICAgICBpZiAodG9wTGV2ZWxEb2MgIT0gbnVsbCAmJiB0b3BMZXZlbERvYy4kX18gJiYgdG9wTGV2ZWxEb2MuJHBvcHVsYXRlZChmdWxsUGF0aCkgJiYgcCA8IHBhcnRzLmxlbmd0aCkge1xuICAgICAgICBjb25zdCBtb2RlbCA9IGRvYy4kX18ucG9wdWxhdGVkW2Z1bGxQYXRoXS5vcHRpb25zW3BvcHVsYXRlTW9kZWxTeW1ib2xdO1xuICAgICAgICBpZiAobW9kZWwgIT0gbnVsbCkge1xuICAgICAgICAgIGNvbnN0IHJldCA9IHNlYXJjaChcbiAgICAgICAgICAgIHBhcnRzLnNsaWNlKHApLFxuICAgICAgICAgICAgbW9kZWwuc2NoZW1hLFxuICAgICAgICAgICAgc3ViZG9jID8gbXBhdGguZ2V0KHRyeXBhdGgsIHN1YmRvYykgOiBudWxsLFxuICAgICAgICAgICAgbmVzdGVkUGF0aC5jb25jYXQocGFydHMuc2xpY2UoMCwgcCkpXG4gICAgICAgICAgKTtcblxuICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY29uc3QgX3ZhbCA9IGdldCh0b3BMZXZlbERvYywgdHJ5cGF0aCk7XG4gICAgICBpZiAoX3ZhbCAhPSBudWxsKSB7XG4gICAgICAgIGNvbnN0IG1vZGVsID0gQXJyYXkuaXNBcnJheShfdmFsKSAmJiBfdmFsLmxlbmd0aCA+IDAgP1xuICAgICAgICAgIGxlYW5Qb3B1bGF0ZU1hcC5nZXQoX3ZhbFswXSkgOlxuICAgICAgICAgIGxlYW5Qb3B1bGF0ZU1hcC5nZXQoX3ZhbCk7XG4gICAgICAgIC8vIFBvcHVsYXRlZCB1c2luZyBsZWFuLCBgbGVhblBvcHVsYXRlTWFwYCB2YWx1ZSBpcyB0aGUgZm9yZWlnbiBtb2RlbFxuICAgICAgICBjb25zdCBzY2hlbWEgPSBtb2RlbCAhPSBudWxsID8gbW9kZWwuc2NoZW1hIDogbnVsbDtcbiAgICAgICAgaWYgKHNjaGVtYSAhPSBudWxsKSB7XG4gICAgICAgICAgY29uc3QgcmV0ID0gc2VhcmNoKFxuICAgICAgICAgICAgcGFydHMuc2xpY2UocCksXG4gICAgICAgICAgICBzY2hlbWEsXG4gICAgICAgICAgICBzdWJkb2MgPyBtcGF0aC5nZXQodHJ5cGF0aCwgc3ViZG9jKSA6IG51bGwsXG4gICAgICAgICAgICBuZXN0ZWRQYXRoLmNvbmNhdChwYXJ0cy5zbGljZSgwLCBwKSlcbiAgICAgICAgICApO1xuXG4gICAgICAgICAgaWYgKHJldCAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXQuJHBhcmVudFNjaGVtYURvY0FycmF5ID0gcmV0LiRwYXJlbnRTY2hlbWFEb2NBcnJheSB8fFxuICAgICAgICAgICAgICAoc2NoZW1hLiRpc1NpbmdsZU5lc3RlZCA/IG51bGwgOiBzY2hlbWEpO1xuICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBmb3VuZHNjaGVtYTtcbiAgICB9XG4gIH1cbiAgLy8gbG9vayBmb3IgYXJyYXlzXG4gIGNvbnN0IHBhcnRzID0gcGF0aC5zcGxpdCgnLicpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHBhcnRzLmxlbmd0aDsgKytpKSB7XG4gICAgaWYgKHBhcnRzW2ldID09PSAnJCcpIHtcbiAgICAgIC8vIFJlOiBnaC01NjI4LCBiZWNhdXNlIGBzY2hlbWEucGF0aCgpYCBkb2Vzbid0IHRha2UgJCBpbnRvIGFjY291bnQuXG4gICAgICBwYXJ0c1tpXSA9ICcwJztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHNlYXJjaChwYXJ0cywgc2NoZW1hLCBkb2MsIFtdKTtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../server/node_modules/mongoose/lib/helpers/populate/getSchemaTypes.js\n");

/***/ }),

/***/ "../server/node_modules/mongoose/lib/helpers/populate/getVirtual.js":
/*!**************************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/helpers/populate/getVirtual.js ***!
  \**************************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nmodule.exports = getVirtual;\n\n/*!\n * ignore\n */\n\nfunction getVirtual(schema, name) {\n  if (schema.virtuals[name]) {\n    return { virtual: schema.virtuals[name], path: void 0 };\n  }\n\n  const parts = name.split('.');\n  let cur = '';\n  let nestedSchemaPath = '';\n  for (let i = 0; i < parts.length; ++i) {\n    cur += (cur.length > 0 ? '.' : '') + parts[i];\n    if (schema.virtuals[cur]) {\n      if (i === parts.length - 1) {\n        return { virtual: schema.virtuals[cur], path: nestedSchemaPath };\n      }\n      continue;\n    }\n\n    if (schema.nested[cur]) {\n      continue;\n    }\n\n    if (schema.paths[cur] && schema.paths[cur].schema) {\n      schema = schema.paths[cur].schema;\n      const rest = parts.slice(i + 1).join('.');\n\n      if (schema.virtuals[rest]) {\n        if (i === parts.length - 2) {\n          return {\n            virtual: schema.virtuals[rest],\n            nestedSchemaPath: [nestedSchemaPath, cur].filter(v => !!v).join('.')\n          };\n        }\n        continue;\n      }\n\n      if (i + 1 < parts.length && schema.discriminators) {\n        for (const key of Object.keys(schema.discriminators)) {\n          const res = getVirtual(schema.discriminators[key], rest);\n          if (res != null) {\n            const _path = [nestedSchemaPath, cur, res.nestedSchemaPath].\n              filter(v => !!v).join('.');\n            return {\n              virtual: res.virtual,\n              nestedSchemaPath: _path\n            };\n          }\n        }\n      }\n\n      nestedSchemaPath += (nestedSchemaPath.length > 0 ? '.' : '') + cur;\n      cur = '';\n      continue;\n    }\n\n    if (schema.discriminators) {\n      for (const discriminatorKey of Object.keys(schema.discriminators)) {\n        const virtualFromDiscriminator = getVirtual(schema.discriminators[discriminatorKey], name);\n        if (virtualFromDiscriminator) return virtualFromDiscriminator;\n      }\n    }\n\n    return null;\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9wb3B1bGF0ZS9nZXRWaXJ0dWFsLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixrQkFBa0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2xpZW50Ly4uL3NlcnZlci9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvcG9wdWxhdGUvZ2V0VmlydHVhbC5qcz80Y2ExIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBnZXRWaXJ0dWFsO1xuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cbmZ1bmN0aW9uIGdldFZpcnR1YWwoc2NoZW1hLCBuYW1lKSB7XG4gIGlmIChzY2hlbWEudmlydHVhbHNbbmFtZV0pIHtcbiAgICByZXR1cm4geyB2aXJ0dWFsOiBzY2hlbWEudmlydHVhbHNbbmFtZV0sIHBhdGg6IHZvaWQgMCB9O1xuICB9XG5cbiAgY29uc3QgcGFydHMgPSBuYW1lLnNwbGl0KCcuJyk7XG4gIGxldCBjdXIgPSAnJztcbiAgbGV0IG5lc3RlZFNjaGVtYVBhdGggPSAnJztcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXJ0cy5sZW5ndGg7ICsraSkge1xuICAgIGN1ciArPSAoY3VyLmxlbmd0aCA+IDAgPyAnLicgOiAnJykgKyBwYXJ0c1tpXTtcbiAgICBpZiAoc2NoZW1hLnZpcnR1YWxzW2N1cl0pIHtcbiAgICAgIGlmIChpID09PSBwYXJ0cy5sZW5ndGggLSAxKSB7XG4gICAgICAgIHJldHVybiB7IHZpcnR1YWw6IHNjaGVtYS52aXJ0dWFsc1tjdXJdLCBwYXRoOiBuZXN0ZWRTY2hlbWFQYXRoIH07XG4gICAgICB9XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAoc2NoZW1hLm5lc3RlZFtjdXJdKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAoc2NoZW1hLnBhdGhzW2N1cl0gJiYgc2NoZW1hLnBhdGhzW2N1cl0uc2NoZW1hKSB7XG4gICAgICBzY2hlbWEgPSBzY2hlbWEucGF0aHNbY3VyXS5zY2hlbWE7XG4gICAgICBjb25zdCByZXN0ID0gcGFydHMuc2xpY2UoaSArIDEpLmpvaW4oJy4nKTtcblxuICAgICAgaWYgKHNjaGVtYS52aXJ0dWFsc1tyZXN0XSkge1xuICAgICAgICBpZiAoaSA9PT0gcGFydHMubGVuZ3RoIC0gMikge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB2aXJ0dWFsOiBzY2hlbWEudmlydHVhbHNbcmVzdF0sXG4gICAgICAgICAgICBuZXN0ZWRTY2hlbWFQYXRoOiBbbmVzdGVkU2NoZW1hUGF0aCwgY3VyXS5maWx0ZXIodiA9PiAhIXYpLmpvaW4oJy4nKVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChpICsgMSA8IHBhcnRzLmxlbmd0aCAmJiBzY2hlbWEuZGlzY3JpbWluYXRvcnMpIHtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMoc2NoZW1hLmRpc2NyaW1pbmF0b3JzKSkge1xuICAgICAgICAgIGNvbnN0IHJlcyA9IGdldFZpcnR1YWwoc2NoZW1hLmRpc2NyaW1pbmF0b3JzW2tleV0sIHJlc3QpO1xuICAgICAgICAgIGlmIChyZXMgIT0gbnVsbCkge1xuICAgICAgICAgICAgY29uc3QgX3BhdGggPSBbbmVzdGVkU2NoZW1hUGF0aCwgY3VyLCByZXMubmVzdGVkU2NoZW1hUGF0aF0uXG4gICAgICAgICAgICAgIGZpbHRlcih2ID0+ICEhdikuam9pbignLicpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgdmlydHVhbDogcmVzLnZpcnR1YWwsXG4gICAgICAgICAgICAgIG5lc3RlZFNjaGVtYVBhdGg6IF9wYXRoXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBuZXN0ZWRTY2hlbWFQYXRoICs9IChuZXN0ZWRTY2hlbWFQYXRoLmxlbmd0aCA+IDAgPyAnLicgOiAnJykgKyBjdXI7XG4gICAgICBjdXIgPSAnJztcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGlmIChzY2hlbWEuZGlzY3JpbWluYXRvcnMpIHtcbiAgICAgIGZvciAoY29uc3QgZGlzY3JpbWluYXRvcktleSBvZiBPYmplY3Qua2V5cyhzY2hlbWEuZGlzY3JpbWluYXRvcnMpKSB7XG4gICAgICAgIGNvbnN0IHZpcnR1YWxGcm9tRGlzY3JpbWluYXRvciA9IGdldFZpcnR1YWwoc2NoZW1hLmRpc2NyaW1pbmF0b3JzW2Rpc2NyaW1pbmF0b3JLZXldLCBuYW1lKTtcbiAgICAgICAgaWYgKHZpcnR1YWxGcm9tRGlzY3JpbWluYXRvcikgcmV0dXJuIHZpcnR1YWxGcm9tRGlzY3JpbWluYXRvcjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../server/node_modules/mongoose/lib/helpers/populate/getVirtual.js\n");

/***/ }),

/***/ "../server/node_modules/mongoose/lib/helpers/populate/leanPopulateMap.js":
/*!*******************************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/helpers/populate/leanPopulateMap.js ***!
  \*******************************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/*!\n * ignore\n */\n\nmodule.exports = new WeakMap();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9wb3B1bGF0ZS9sZWFuUG9wdWxhdGVNYXAuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2xpZW50Ly4uL3NlcnZlci9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvcG9wdWxhdGUvbGVhblBvcHVsYXRlTWFwLmpzPzI2MTkiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gbmV3IFdlYWtNYXAoKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../server/node_modules/mongoose/lib/helpers/populate/leanPopulateMap.js\n");

/***/ }),

/***/ "../server/node_modules/mongoose/lib/helpers/populate/lookupLocalFields.js":
/*!*********************************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/helpers/populate/lookupLocalFields.js ***!
  \*********************************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nmodule.exports = function lookupLocalFields(cur, path, val) {\n  if (cur == null) {\n    return cur;\n  }\n\n  if (cur._doc != null) {\n    cur = cur._doc;\n  }\n\n  if (arguments.length >= 3) {\n    if (typeof cur !== 'object') {\n      return void 0;\n    }\n    if (val === void 0) {\n      return void 0;\n    }\n    if (cur instanceof Map) {\n      cur.set(path, val);\n    } else {\n      cur[path] = val;\n    }\n    return val;\n  }\n\n\n  // Support populating paths under maps using `map.$*.subpath`\n  if (path === '$*') {\n    return cur instanceof Map ?\n      Array.from(cur.values()) :\n      Object.keys(cur).map(key => cur[key]);\n  }\n\n  if (cur instanceof Map) {\n    return cur.get(path);\n  }\n\n  return cur[path];\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9wb3B1bGF0ZS9sb29rdXBMb2NhbEZpZWxkcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbGllbnQvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9wb3B1bGF0ZS9sb29rdXBMb2NhbEZpZWxkcy5qcz9kOWRkIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBsb29rdXBMb2NhbEZpZWxkcyhjdXIsIHBhdGgsIHZhbCkge1xuICBpZiAoY3VyID09IG51bGwpIHtcbiAgICByZXR1cm4gY3VyO1xuICB9XG5cbiAgaWYgKGN1ci5fZG9jICE9IG51bGwpIHtcbiAgICBjdXIgPSBjdXIuX2RvYztcbiAgfVxuXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID49IDMpIHtcbiAgICBpZiAodHlwZW9mIGN1ciAhPT0gJ29iamVjdCcpIHtcbiAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgfVxuICAgIGlmICh2YWwgPT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICB9XG4gICAgaWYgKGN1ciBpbnN0YW5jZW9mIE1hcCkge1xuICAgICAgY3VyLnNldChwYXRoLCB2YWwpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjdXJbcGF0aF0gPSB2YWw7XG4gICAgfVxuICAgIHJldHVybiB2YWw7XG4gIH1cblxuXG4gIC8vIFN1cHBvcnQgcG9wdWxhdGluZyBwYXRocyB1bmRlciBtYXBzIHVzaW5nIGBtYXAuJCouc3VicGF0aGBcbiAgaWYgKHBhdGggPT09ICckKicpIHtcbiAgICByZXR1cm4gY3VyIGluc3RhbmNlb2YgTWFwID9cbiAgICAgIEFycmF5LmZyb20oY3VyLnZhbHVlcygpKSA6XG4gICAgICBPYmplY3Qua2V5cyhjdXIpLm1hcChrZXkgPT4gY3VyW2tleV0pO1xuICB9XG5cbiAgaWYgKGN1ciBpbnN0YW5jZW9mIE1hcCkge1xuICAgIHJldHVybiBjdXIuZ2V0KHBhdGgpO1xuICB9XG5cbiAgcmV0dXJuIGN1cltwYXRoXTtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../server/node_modules/mongoose/lib/helpers/populate/lookupLocalFields.js\n");

/***/ }),

/***/ "../server/node_modules/mongoose/lib/helpers/populate/markArraySubdocsPopulated.js":
/*!*****************************************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/helpers/populate/markArraySubdocsPopulated.js ***!
  \*****************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst utils = __webpack_require__(/*! ../../utils */ \"../server/node_modules/mongoose/lib/utils.js\");\n\n/**\n * If populating a path within a document array, make sure each\n * subdoc within the array knows its subpaths are populated.\n *\n * #### Example:\n *\n *     const doc = await Article.findOne().populate('comments.author');\n *     doc.comments[0].populated('author'); // Should be set\n *\n * @param {Document} doc\n * @param {Object} [populated]\n * @api private\n */\n\nmodule.exports = function markArraySubdocsPopulated(doc, populated) {\n  if (doc._id == null || populated == null || populated.length === 0) {\n    return;\n  }\n\n  const id = String(doc._id);\n  for (const item of populated) {\n    if (item.isVirtual) {\n      continue;\n    }\n    const path = item.path;\n    const pieces = path.split('.');\n    for (let i = 0; i < pieces.length - 1; ++i) {\n      const subpath = pieces.slice(0, i + 1).join('.');\n      const rest = pieces.slice(i + 1).join('.');\n      const val = doc.get(subpath);\n      if (val == null) {\n        continue;\n      }\n\n      if (utils.isMongooseDocumentArray(val)) {\n        for (let j = 0; j < val.length; ++j) {\n          if (val[j]) {\n            val[j].populated(rest, item._docs[id] == null ? void 0 : item._docs[id][j], item);\n          }\n        }\n        break;\n      }\n    }\n  }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9wb3B1bGF0ZS9tYXJrQXJyYXlTdWJkb2NzUG9wdWxhdGVkLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLGNBQWMsbUJBQU8sQ0FBQyxpRUFBYTs7QUFFbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQSxXQUFXLFVBQVU7QUFDckIsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsdUJBQXVCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHdCQUF3QixnQkFBZ0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2xpZW50Ly4uL3NlcnZlci9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvcG9wdWxhdGUvbWFya0FycmF5U3ViZG9jc1BvcHVsYXRlZC5qcz9kYTBkIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3QgdXRpbHMgPSByZXF1aXJlKCcuLi8uLi91dGlscycpO1xuXG4vKipcbiAqIElmIHBvcHVsYXRpbmcgYSBwYXRoIHdpdGhpbiBhIGRvY3VtZW50IGFycmF5LCBtYWtlIHN1cmUgZWFjaFxuICogc3ViZG9jIHdpdGhpbiB0aGUgYXJyYXkga25vd3MgaXRzIHN1YnBhdGhzIGFyZSBwb3B1bGF0ZWQuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBjb25zdCBkb2MgPSBhd2FpdCBBcnRpY2xlLmZpbmRPbmUoKS5wb3B1bGF0ZSgnY29tbWVudHMuYXV0aG9yJyk7XG4gKiAgICAgZG9jLmNvbW1lbnRzWzBdLnBvcHVsYXRlZCgnYXV0aG9yJyk7IC8vIFNob3VsZCBiZSBzZXRcbiAqXG4gKiBAcGFyYW0ge0RvY3VtZW50fSBkb2NcbiAqIEBwYXJhbSB7T2JqZWN0fSBbcG9wdWxhdGVkXVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBtYXJrQXJyYXlTdWJkb2NzUG9wdWxhdGVkKGRvYywgcG9wdWxhdGVkKSB7XG4gIGlmIChkb2MuX2lkID09IG51bGwgfHwgcG9wdWxhdGVkID09IG51bGwgfHwgcG9wdWxhdGVkLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGNvbnN0IGlkID0gU3RyaW5nKGRvYy5faWQpO1xuICBmb3IgKGNvbnN0IGl0ZW0gb2YgcG9wdWxhdGVkKSB7XG4gICAgaWYgKGl0ZW0uaXNWaXJ0dWFsKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgY29uc3QgcGF0aCA9IGl0ZW0ucGF0aDtcbiAgICBjb25zdCBwaWVjZXMgPSBwYXRoLnNwbGl0KCcuJyk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwaWVjZXMubGVuZ3RoIC0gMTsgKytpKSB7XG4gICAgICBjb25zdCBzdWJwYXRoID0gcGllY2VzLnNsaWNlKDAsIGkgKyAxKS5qb2luKCcuJyk7XG4gICAgICBjb25zdCByZXN0ID0gcGllY2VzLnNsaWNlKGkgKyAxKS5qb2luKCcuJyk7XG4gICAgICBjb25zdCB2YWwgPSBkb2MuZ2V0KHN1YnBhdGgpO1xuICAgICAgaWYgKHZhbCA9PSBudWxsKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAodXRpbHMuaXNNb25nb29zZURvY3VtZW50QXJyYXkodmFsKSkge1xuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHZhbC5sZW5ndGg7ICsraikge1xuICAgICAgICAgIGlmICh2YWxbal0pIHtcbiAgICAgICAgICAgIHZhbFtqXS5wb3B1bGF0ZWQocmVzdCwgaXRlbS5fZG9jc1tpZF0gPT0gbnVsbCA/IHZvaWQgMCA6IGl0ZW0uX2RvY3NbaWRdW2pdLCBpdGVtKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../server/node_modules/mongoose/lib/helpers/populate/markArraySubdocsPopulated.js\n");

/***/ }),

/***/ "../server/node_modules/mongoose/lib/helpers/populate/modelNamesFromRefPath.js":
/*!*************************************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/helpers/populate/modelNamesFromRefPath.js ***!
  \*************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst MongooseError = __webpack_require__(/*! ../../error/mongooseError */ \"../server/node_modules/mongoose/lib/error/mongooseError.js\");\nconst isPathExcluded = __webpack_require__(/*! ../projection/isPathExcluded */ \"../server/node_modules/mongoose/lib/helpers/projection/isPathExcluded.js\");\nconst lookupLocalFields = __webpack_require__(/*! ./lookupLocalFields */ \"../server/node_modules/mongoose/lib/helpers/populate/lookupLocalFields.js\");\nconst mpath = __webpack_require__(/*! mpath */ \"../server/node_modules/mpath/index.js\");\nconst util = __webpack_require__(/*! util */ \"util\");\nconst utils = __webpack_require__(/*! ../../utils */ \"../server/node_modules/mongoose/lib/utils.js\");\n\nconst hasNumericPropRE = /(\\.\\d+$|\\.\\d+\\.)/g;\n\nmodule.exports = function modelNamesFromRefPath(refPath, doc, populatedPath, modelSchema, queryProjection) {\n  if (refPath == null) {\n    return [];\n  }\n\n  if (typeof refPath === 'string' && queryProjection != null && isPathExcluded(queryProjection, refPath)) {\n    throw new MongooseError('refPath `' + refPath + '` must not be excluded in projection, got ' +\n      util.inspect(queryProjection));\n  }\n\n  // If populated path has numerics, the end `refPath` should too. For example,\n  // if populating `a.0.b` instead of `a.b` and `b` has `refPath = a.c`, we\n  // should return `a.0.c` for the refPath.\n\n  if (hasNumericPropRE.test(populatedPath)) {\n    const chunks = populatedPath.split(hasNumericPropRE);\n\n    if (chunks[chunks.length - 1] === '') {\n      throw new Error('Can\\'t populate individual element in an array');\n    }\n\n    let _refPath = '';\n    let _remaining = refPath;\n    // 2nd, 4th, etc. will be numeric props. For example: `[ 'a', '.0.', 'b' ]`\n    for (let i = 0; i < chunks.length; i += 2) {\n      const chunk = chunks[i];\n      if (_remaining.startsWith(chunk + '.')) {\n        _refPath += _remaining.substring(0, chunk.length) + chunks[i + 1];\n        _remaining = _remaining.substring(chunk.length + 1);\n      } else if (i === chunks.length - 1) {\n        _refPath += _remaining;\n        _remaining = '';\n        break;\n      } else {\n        throw new Error('Could not normalize ref path, chunk ' + chunk + ' not in populated path');\n      }\n    }\n\n    const refValue = mpath.get(_refPath, doc, lookupLocalFields);\n    let modelNames = Array.isArray(refValue) ? refValue : [refValue];\n    modelNames = utils.array.flatten(modelNames);\n    return modelNames;\n  }\n\n  const refValue = mpath.get(refPath, doc, lookupLocalFields);\n\n  let modelNames;\n  if (modelSchema != null && modelSchema.virtuals.hasOwnProperty(refPath)) {\n    modelNames = [modelSchema.virtuals[refPath].applyGetters(void 0, doc)];\n  } else {\n    modelNames = Array.isArray(refValue) ? refValue : [refValue];\n  }\n\n  modelNames = utils.array.flatten(modelNames);\n\n  return modelNames;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9wb3B1bGF0ZS9tb2RlbE5hbWVzRnJvbVJlZlBhdGguanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsc0JBQXNCLG1CQUFPLENBQUMsNkZBQTJCO0FBQ3pELHVCQUF1QixtQkFBTyxDQUFDLDhHQUE4QjtBQUM3RCwwQkFBMEIsbUJBQU8sQ0FBQyxzR0FBcUI7QUFDdkQsY0FBYyxtQkFBTyxDQUFDLG9EQUFPO0FBQzdCLGFBQWEsbUJBQU8sQ0FBQyxrQkFBTTtBQUMzQixjQUFjLG1CQUFPLENBQUMsaUVBQWE7O0FBRW5DOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsbUJBQW1CO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTs7QUFFQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2xpZW50Ly4uL3NlcnZlci9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvcG9wdWxhdGUvbW9kZWxOYW1lc0Zyb21SZWZQYXRoLmpzPzc1NzIiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBNb25nb29zZUVycm9yID0gcmVxdWlyZSgnLi4vLi4vZXJyb3IvbW9uZ29vc2VFcnJvcicpO1xuY29uc3QgaXNQYXRoRXhjbHVkZWQgPSByZXF1aXJlKCcuLi9wcm9qZWN0aW9uL2lzUGF0aEV4Y2x1ZGVkJyk7XG5jb25zdCBsb29rdXBMb2NhbEZpZWxkcyA9IHJlcXVpcmUoJy4vbG9va3VwTG9jYWxGaWVsZHMnKTtcbmNvbnN0IG1wYXRoID0gcmVxdWlyZSgnbXBhdGgnKTtcbmNvbnN0IHV0aWwgPSByZXF1aXJlKCd1dGlsJyk7XG5jb25zdCB1dGlscyA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzJyk7XG5cbmNvbnN0IGhhc051bWVyaWNQcm9wUkUgPSAvKFxcLlxcZCskfFxcLlxcZCtcXC4pL2c7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gbW9kZWxOYW1lc0Zyb21SZWZQYXRoKHJlZlBhdGgsIGRvYywgcG9wdWxhdGVkUGF0aCwgbW9kZWxTY2hlbWEsIHF1ZXJ5UHJvamVjdGlvbikge1xuICBpZiAocmVmUGF0aCA9PSBudWxsKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG5cbiAgaWYgKHR5cGVvZiByZWZQYXRoID09PSAnc3RyaW5nJyAmJiBxdWVyeVByb2plY3Rpb24gIT0gbnVsbCAmJiBpc1BhdGhFeGNsdWRlZChxdWVyeVByb2plY3Rpb24sIHJlZlBhdGgpKSB7XG4gICAgdGhyb3cgbmV3IE1vbmdvb3NlRXJyb3IoJ3JlZlBhdGggYCcgKyByZWZQYXRoICsgJ2AgbXVzdCBub3QgYmUgZXhjbHVkZWQgaW4gcHJvamVjdGlvbiwgZ290ICcgK1xuICAgICAgdXRpbC5pbnNwZWN0KHF1ZXJ5UHJvamVjdGlvbikpO1xuICB9XG5cbiAgLy8gSWYgcG9wdWxhdGVkIHBhdGggaGFzIG51bWVyaWNzLCB0aGUgZW5kIGByZWZQYXRoYCBzaG91bGQgdG9vLiBGb3IgZXhhbXBsZSxcbiAgLy8gaWYgcG9wdWxhdGluZyBgYS4wLmJgIGluc3RlYWQgb2YgYGEuYmAgYW5kIGBiYCBoYXMgYHJlZlBhdGggPSBhLmNgLCB3ZVxuICAvLyBzaG91bGQgcmV0dXJuIGBhLjAuY2AgZm9yIHRoZSByZWZQYXRoLlxuXG4gIGlmIChoYXNOdW1lcmljUHJvcFJFLnRlc3QocG9wdWxhdGVkUGF0aCkpIHtcbiAgICBjb25zdCBjaHVua3MgPSBwb3B1bGF0ZWRQYXRoLnNwbGl0KGhhc051bWVyaWNQcm9wUkUpO1xuXG4gICAgaWYgKGNodW5rc1tjaHVua3MubGVuZ3RoIC0gMV0gPT09ICcnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NhblxcJ3QgcG9wdWxhdGUgaW5kaXZpZHVhbCBlbGVtZW50IGluIGFuIGFycmF5Jyk7XG4gICAgfVxuXG4gICAgbGV0IF9yZWZQYXRoID0gJyc7XG4gICAgbGV0IF9yZW1haW5pbmcgPSByZWZQYXRoO1xuICAgIC8vIDJuZCwgNHRoLCBldGMuIHdpbGwgYmUgbnVtZXJpYyBwcm9wcy4gRm9yIGV4YW1wbGU6IGBbICdhJywgJy4wLicsICdiJyBdYFxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2h1bmtzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICBjb25zdCBjaHVuayA9IGNodW5rc1tpXTtcbiAgICAgIGlmIChfcmVtYWluaW5nLnN0YXJ0c1dpdGgoY2h1bmsgKyAnLicpKSB7XG4gICAgICAgIF9yZWZQYXRoICs9IF9yZW1haW5pbmcuc3Vic3RyaW5nKDAsIGNodW5rLmxlbmd0aCkgKyBjaHVua3NbaSArIDFdO1xuICAgICAgICBfcmVtYWluaW5nID0gX3JlbWFpbmluZy5zdWJzdHJpbmcoY2h1bmsubGVuZ3RoICsgMSk7XG4gICAgICB9IGVsc2UgaWYgKGkgPT09IGNodW5rcy5sZW5ndGggLSAxKSB7XG4gICAgICAgIF9yZWZQYXRoICs9IF9yZW1haW5pbmc7XG4gICAgICAgIF9yZW1haW5pbmcgPSAnJztcbiAgICAgICAgYnJlYWs7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvdWxkIG5vdCBub3JtYWxpemUgcmVmIHBhdGgsIGNodW5rICcgKyBjaHVuayArICcgbm90IGluIHBvcHVsYXRlZCBwYXRoJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgcmVmVmFsdWUgPSBtcGF0aC5nZXQoX3JlZlBhdGgsIGRvYywgbG9va3VwTG9jYWxGaWVsZHMpO1xuICAgIGxldCBtb2RlbE5hbWVzID0gQXJyYXkuaXNBcnJheShyZWZWYWx1ZSkgPyByZWZWYWx1ZSA6IFtyZWZWYWx1ZV07XG4gICAgbW9kZWxOYW1lcyA9IHV0aWxzLmFycmF5LmZsYXR0ZW4obW9kZWxOYW1lcyk7XG4gICAgcmV0dXJuIG1vZGVsTmFtZXM7XG4gIH1cblxuICBjb25zdCByZWZWYWx1ZSA9IG1wYXRoLmdldChyZWZQYXRoLCBkb2MsIGxvb2t1cExvY2FsRmllbGRzKTtcblxuICBsZXQgbW9kZWxOYW1lcztcbiAgaWYgKG1vZGVsU2NoZW1hICE9IG51bGwgJiYgbW9kZWxTY2hlbWEudmlydHVhbHMuaGFzT3duUHJvcGVydHkocmVmUGF0aCkpIHtcbiAgICBtb2RlbE5hbWVzID0gW21vZGVsU2NoZW1hLnZpcnR1YWxzW3JlZlBhdGhdLmFwcGx5R2V0dGVycyh2b2lkIDAsIGRvYyldO1xuICB9IGVsc2Uge1xuICAgIG1vZGVsTmFtZXMgPSBBcnJheS5pc0FycmF5KHJlZlZhbHVlKSA/IHJlZlZhbHVlIDogW3JlZlZhbHVlXTtcbiAgfVxuXG4gIG1vZGVsTmFtZXMgPSB1dGlscy5hcnJheS5mbGF0dGVuKG1vZGVsTmFtZXMpO1xuXG4gIHJldHVybiBtb2RlbE5hbWVzO1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../server/node_modules/mongoose/lib/helpers/populate/modelNamesFromRefPath.js\n");

/***/ }),

/***/ "../server/node_modules/mongoose/lib/helpers/populate/removeDeselectedForeignField.js":
/*!********************************************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/helpers/populate/removeDeselectedForeignField.js ***!
  \********************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst get = __webpack_require__(/*! ../get */ \"../server/node_modules/mongoose/lib/helpers/get.js\");\nconst mpath = __webpack_require__(/*! mpath */ \"../server/node_modules/mpath/index.js\");\nconst parseProjection = __webpack_require__(/*! ../projection/parseProjection */ \"../server/node_modules/mongoose/lib/helpers/projection/parseProjection.js\");\n\n/*!\n * ignore\n */\n\nmodule.exports = function removeDeselectedForeignField(foreignFields, options, docs) {\n  const projection = parseProjection(get(options, 'select', null), true) ||\n    parseProjection(get(options, 'options.select', null), true);\n\n  if (projection == null) {\n    return;\n  }\n  for (const foreignField of foreignFields) {\n    if (!projection.hasOwnProperty('-' + foreignField)) {\n      continue;\n    }\n\n    for (const val of docs) {\n      if (val.$__ != null) {\n        mpath.unset(foreignField, val._doc);\n      } else {\n        mpath.unset(foreignField, val);\n      }\n    }\n  }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9wb3B1bGF0ZS9yZW1vdmVEZXNlbGVjdGVkRm9yZWlnbkZpZWxkLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLFlBQVksbUJBQU8sQ0FBQyxrRUFBUTtBQUM1QixjQUFjLG1CQUFPLENBQUMsb0RBQU87QUFDN0Isd0JBQXdCLG1CQUFPLENBQUMsZ0hBQStCOztBQUUvRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2xpZW50Ly4uL3NlcnZlci9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvcG9wdWxhdGUvcmVtb3ZlRGVzZWxlY3RlZEZvcmVpZ25GaWVsZC5qcz84ZjA3Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3QgZ2V0ID0gcmVxdWlyZSgnLi4vZ2V0Jyk7XG5jb25zdCBtcGF0aCA9IHJlcXVpcmUoJ21wYXRoJyk7XG5jb25zdCBwYXJzZVByb2plY3Rpb24gPSByZXF1aXJlKCcuLi9wcm9qZWN0aW9uL3BhcnNlUHJvamVjdGlvbicpO1xuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gcmVtb3ZlRGVzZWxlY3RlZEZvcmVpZ25GaWVsZChmb3JlaWduRmllbGRzLCBvcHRpb25zLCBkb2NzKSB7XG4gIGNvbnN0IHByb2plY3Rpb24gPSBwYXJzZVByb2plY3Rpb24oZ2V0KG9wdGlvbnMsICdzZWxlY3QnLCBudWxsKSwgdHJ1ZSkgfHxcbiAgICBwYXJzZVByb2plY3Rpb24oZ2V0KG9wdGlvbnMsICdvcHRpb25zLnNlbGVjdCcsIG51bGwpLCB0cnVlKTtcblxuICBpZiAocHJvamVjdGlvbiA9PSBudWxsKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGZvciAoY29uc3QgZm9yZWlnbkZpZWxkIG9mIGZvcmVpZ25GaWVsZHMpIHtcbiAgICBpZiAoIXByb2plY3Rpb24uaGFzT3duUHJvcGVydHkoJy0nICsgZm9yZWlnbkZpZWxkKSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgZm9yIChjb25zdCB2YWwgb2YgZG9jcykge1xuICAgICAgaWYgKHZhbC4kX18gIT0gbnVsbCkge1xuICAgICAgICBtcGF0aC51bnNldChmb3JlaWduRmllbGQsIHZhbC5fZG9jKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1wYXRoLnVuc2V0KGZvcmVpZ25GaWVsZCwgdmFsKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../server/node_modules/mongoose/lib/helpers/populate/removeDeselectedForeignField.js\n");

/***/ }),

/***/ "../server/node_modules/mongoose/lib/helpers/populate/setPopulatedVirtualValue.js":
/*!****************************************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/helpers/populate/setPopulatedVirtualValue.js ***!
  \****************************************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/**\n * Set a populated virtual value on a document's `$$populatedVirtuals` value\n *\n * @param {*} populatedVirtuals A document's `$$populatedVirtuals`\n * @param {*} name The virtual name\n * @param {*} v The result of the populate query\n * @param {*} options The populate options. This function handles `justOne` and `count` options.\n * @returns {Array<Document>|Document|Object|Array<Object>} the populated virtual value that was set\n */\n\nmodule.exports = function setPopulatedVirtualValue(populatedVirtuals, name, v, options) {\n  if (options.justOne || options.count) {\n    populatedVirtuals[name] = Array.isArray(v) ?\n      v[0] :\n      v;\n\n    if (typeof populatedVirtuals[name] !== 'object') {\n      populatedVirtuals[name] = options.count ? v : null;\n    }\n  } else {\n    populatedVirtuals[name] = Array.isArray(v) ?\n      v :\n      v == null ? [] : [v];\n\n    populatedVirtuals[name] = populatedVirtuals[name].filter(function(doc) {\n      return doc && typeof doc === 'object';\n    });\n  }\n\n  return populatedVirtuals[name];\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9wb3B1bGF0ZS9zZXRQb3B1bGF0ZWRWaXJ0dWFsVmFsdWUuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0EsV0FBVyxHQUFHO0FBQ2QsV0FBVyxHQUFHO0FBQ2QsV0FBVyxHQUFHO0FBQ2QsV0FBVyxHQUFHO0FBQ2QsYUFBYSwrQ0FBK0M7QUFDNUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2NsaWVudC8uLi9zZXJ2ZXIvbm9kZV9tb2R1bGVzL21vbmdvb3NlL2xpYi9oZWxwZXJzL3BvcHVsYXRlL3NldFBvcHVsYXRlZFZpcnR1YWxWYWx1ZS5qcz8zYjEwIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBTZXQgYSBwb3B1bGF0ZWQgdmlydHVhbCB2YWx1ZSBvbiBhIGRvY3VtZW50J3MgYCQkcG9wdWxhdGVkVmlydHVhbHNgIHZhbHVlXG4gKlxuICogQHBhcmFtIHsqfSBwb3B1bGF0ZWRWaXJ0dWFscyBBIGRvY3VtZW50J3MgYCQkcG9wdWxhdGVkVmlydHVhbHNgXG4gKiBAcGFyYW0geyp9IG5hbWUgVGhlIHZpcnR1YWwgbmFtZVxuICogQHBhcmFtIHsqfSB2IFRoZSByZXN1bHQgb2YgdGhlIHBvcHVsYXRlIHF1ZXJ5XG4gKiBAcGFyYW0geyp9IG9wdGlvbnMgVGhlIHBvcHVsYXRlIG9wdGlvbnMuIFRoaXMgZnVuY3Rpb24gaGFuZGxlcyBganVzdE9uZWAgYW5kIGBjb3VudGAgb3B0aW9ucy5cbiAqIEByZXR1cm5zIHtBcnJheTxEb2N1bWVudD58RG9jdW1lbnR8T2JqZWN0fEFycmF5PE9iamVjdD59IHRoZSBwb3B1bGF0ZWQgdmlydHVhbCB2YWx1ZSB0aGF0IHdhcyBzZXRcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHNldFBvcHVsYXRlZFZpcnR1YWxWYWx1ZShwb3B1bGF0ZWRWaXJ0dWFscywgbmFtZSwgdiwgb3B0aW9ucykge1xuICBpZiAob3B0aW9ucy5qdXN0T25lIHx8IG9wdGlvbnMuY291bnQpIHtcbiAgICBwb3B1bGF0ZWRWaXJ0dWFsc1tuYW1lXSA9IEFycmF5LmlzQXJyYXkodikgP1xuICAgICAgdlswXSA6XG4gICAgICB2O1xuXG4gICAgaWYgKHR5cGVvZiBwb3B1bGF0ZWRWaXJ0dWFsc1tuYW1lXSAhPT0gJ29iamVjdCcpIHtcbiAgICAgIHBvcHVsYXRlZFZpcnR1YWxzW25hbWVdID0gb3B0aW9ucy5jb3VudCA/IHYgOiBudWxsO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBwb3B1bGF0ZWRWaXJ0dWFsc1tuYW1lXSA9IEFycmF5LmlzQXJyYXkodikgP1xuICAgICAgdiA6XG4gICAgICB2ID09IG51bGwgPyBbXSA6IFt2XTtcblxuICAgIHBvcHVsYXRlZFZpcnR1YWxzW25hbWVdID0gcG9wdWxhdGVkVmlydHVhbHNbbmFtZV0uZmlsdGVyKGZ1bmN0aW9uKGRvYykge1xuICAgICAgcmV0dXJuIGRvYyAmJiB0eXBlb2YgZG9jID09PSAnb2JqZWN0JztcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiBwb3B1bGF0ZWRWaXJ0dWFsc1tuYW1lXTtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../server/node_modules/mongoose/lib/helpers/populate/setPopulatedVirtualValue.js\n");

/***/ }),

/***/ "../server/node_modules/mongoose/lib/helpers/populate/skipPopulateValue.js":
/*!*********************************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/helpers/populate/skipPopulateValue.js ***!
  \*********************************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nmodule.exports = function SkipPopulateValue(val) {\n  if (!(this instanceof SkipPopulateValue)) {\n    return new SkipPopulateValue(val);\n  }\n\n  this.val = val;\n  return this;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9wb3B1bGF0ZS9za2lwUG9wdWxhdGVWYWx1ZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbGllbnQvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9wb3B1bGF0ZS9za2lwUG9wdWxhdGVWYWx1ZS5qcz9kYzljIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBTa2lwUG9wdWxhdGVWYWx1ZSh2YWwpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFNraXBQb3B1bGF0ZVZhbHVlKSkge1xuICAgIHJldHVybiBuZXcgU2tpcFBvcHVsYXRlVmFsdWUodmFsKTtcbiAgfVxuXG4gIHRoaXMudmFsID0gdmFsO1xuICByZXR1cm4gdGhpcztcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../server/node_modules/mongoose/lib/helpers/populate/skipPopulateValue.js\n");

/***/ }),

/***/ "../server/node_modules/mongoose/lib/helpers/populate/validateRef.js":
/*!***************************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/helpers/populate/validateRef.js ***!
  \***************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst MongooseError = __webpack_require__(/*! ../../error/mongooseError */ \"../server/node_modules/mongoose/lib/error/mongooseError.js\");\nconst util = __webpack_require__(/*! util */ \"util\");\n\nmodule.exports = validateRef;\n\nfunction validateRef(ref, path) {\n  if (typeof ref === 'string') {\n    return;\n  }\n\n  if (typeof ref === 'function') {\n    return;\n  }\n\n  throw new MongooseError('Invalid ref at path \"' + path + '\". Got ' +\n    util.inspect(ref, { depth: 0 }));\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9wb3B1bGF0ZS92YWxpZGF0ZVJlZi5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixzQkFBc0IsbUJBQU8sQ0FBQyw2RkFBMkI7QUFDekQsYUFBYSxtQkFBTyxDQUFDLGtCQUFNOztBQUUzQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3QkFBd0IsVUFBVTtBQUNsQyIsInNvdXJjZXMiOlsid2VicGFjazovL2NsaWVudC8uLi9zZXJ2ZXIvbm9kZV9tb2R1bGVzL21vbmdvb3NlL2xpYi9oZWxwZXJzL3BvcHVsYXRlL3ZhbGlkYXRlUmVmLmpzPzExMjEiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBNb25nb29zZUVycm9yID0gcmVxdWlyZSgnLi4vLi4vZXJyb3IvbW9uZ29vc2VFcnJvcicpO1xuY29uc3QgdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcblxubW9kdWxlLmV4cG9ydHMgPSB2YWxpZGF0ZVJlZjtcblxuZnVuY3Rpb24gdmFsaWRhdGVSZWYocmVmLCBwYXRoKSB7XG4gIGlmICh0eXBlb2YgcmVmID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmICh0eXBlb2YgcmVmID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdGhyb3cgbmV3IE1vbmdvb3NlRXJyb3IoJ0ludmFsaWQgcmVmIGF0IHBhdGggXCInICsgcGF0aCArICdcIi4gR290ICcgK1xuICAgIHV0aWwuaW5zcGVjdChyZWYsIHsgZGVwdGg6IDAgfSkpO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../server/node_modules/mongoose/lib/helpers/populate/validateRef.js\n");

/***/ }),

/***/ "../server/node_modules/mongoose/lib/helpers/printJestWarning.js":
/*!***********************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/helpers/printJestWarning.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst utils = __webpack_require__(/*! ../utils */ \"../server/node_modules/mongoose/lib/utils.js\");\n\nif (typeof jest !== 'undefined' && !process.env.SUPPRESS_JEST_WARNINGS) {\n  if (typeof window !== 'undefined') {\n    utils.warn('Mongoose: looks like you\\'re trying to test a Mongoose app ' +\n      'with Jest\\'s default jsdom test environment. Please make sure you read ' +\n      'Mongoose\\'s docs on configuring Jest to test Node.js apps: ' +\n      'https://mongoosejs.com/docs/jest.html. Set the SUPPRESS_JEST_WARNINGS to true ' +\n      'to hide this warning.');\n  }\n\n  if (setTimeout.clock != null && typeof setTimeout.clock.Date === 'function') {\n    utils.warn('Mongoose: looks like you\\'re trying to test a Mongoose app ' +\n      'with Jest\\'s mock timers enabled. Please make sure you read ' +\n      'Mongoose\\'s docs on configuring Jest to test Node.js apps: ' +\n      'https://mongoosejs.com/docs/jest.html. Set the SUPPRESS_JEST_WARNINGS to true ' +\n      'to hide this warning.');\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9wcmludEplc3RXYXJuaW5nLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLGNBQWMsbUJBQU8sQ0FBQyw4REFBVTs7QUFFaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2xpZW50Ly4uL3NlcnZlci9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvcHJpbnRKZXN0V2FybmluZy5qcz8yMGZjIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3QgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscycpO1xuXG5pZiAodHlwZW9mIGplc3QgIT09ICd1bmRlZmluZWQnICYmICFwcm9jZXNzLmVudi5TVVBQUkVTU19KRVNUX1dBUk5JTkdTKSB7XG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgIHV0aWxzLndhcm4oJ01vbmdvb3NlOiBsb29rcyBsaWtlIHlvdVxcJ3JlIHRyeWluZyB0byB0ZXN0IGEgTW9uZ29vc2UgYXBwICcgK1xuICAgICAgJ3dpdGggSmVzdFxcJ3MgZGVmYXVsdCBqc2RvbSB0ZXN0IGVudmlyb25tZW50LiBQbGVhc2UgbWFrZSBzdXJlIHlvdSByZWFkICcgK1xuICAgICAgJ01vbmdvb3NlXFwncyBkb2NzIG9uIGNvbmZpZ3VyaW5nIEplc3QgdG8gdGVzdCBOb2RlLmpzIGFwcHM6ICcgK1xuICAgICAgJ2h0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9qZXN0Lmh0bWwuIFNldCB0aGUgU1VQUFJFU1NfSkVTVF9XQVJOSU5HUyB0byB0cnVlICcgK1xuICAgICAgJ3RvIGhpZGUgdGhpcyB3YXJuaW5nLicpO1xuICB9XG5cbiAgaWYgKHNldFRpbWVvdXQuY2xvY2sgIT0gbnVsbCAmJiB0eXBlb2Ygc2V0VGltZW91dC5jbG9jay5EYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdXRpbHMud2FybignTW9uZ29vc2U6IGxvb2tzIGxpa2UgeW91XFwncmUgdHJ5aW5nIHRvIHRlc3QgYSBNb25nb29zZSBhcHAgJyArXG4gICAgICAnd2l0aCBKZXN0XFwncyBtb2NrIHRpbWVycyBlbmFibGVkLiBQbGVhc2UgbWFrZSBzdXJlIHlvdSByZWFkICcgK1xuICAgICAgJ01vbmdvb3NlXFwncyBkb2NzIG9uIGNvbmZpZ3VyaW5nIEplc3QgdG8gdGVzdCBOb2RlLmpzIGFwcHM6ICcgK1xuICAgICAgJ2h0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9qZXN0Lmh0bWwuIFNldCB0aGUgU1VQUFJFU1NfSkVTVF9XQVJOSU5HUyB0byB0cnVlICcgK1xuICAgICAgJ3RvIGhpZGUgdGhpcyB3YXJuaW5nLicpO1xuICB9XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../server/node_modules/mongoose/lib/helpers/printJestWarning.js\n");

/***/ }),

/***/ "../server/node_modules/mongoose/lib/helpers/processConnectionOptions.js":
/*!*******************************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/helpers/processConnectionOptions.js ***!
  \*******************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst clone = __webpack_require__(/*! ./clone */ \"../server/node_modules/mongoose/lib/helpers/clone.js\");\nconst MongooseError = __webpack_require__(/*! ../error/index */ \"../server/node_modules/mongoose/lib/error/index.js\");\n\nfunction processConnectionOptions(uri, options) {\n  const opts = options ? options : {};\n  const readPreference = opts.readPreference\n    ? opts.readPreference\n    : getUriReadPreference(uri);\n\n  const clonedOpts = clone(opts);\n  const resolvedOpts = (readPreference && readPreference !== 'primary' && readPreference !== 'primaryPreferred')\n    ? resolveOptsConflicts(readPreference, clonedOpts)\n    : clonedOpts;\n\n  return resolvedOpts;\n}\n\nfunction resolveOptsConflicts(pref, opts) {\n  // don't silently override user-provided indexing options\n  if (setsIndexOptions(opts) && setsSecondaryRead(pref)) {\n    throwReadPreferenceError();\n  }\n\n  // if user has not explicitly set any auto-indexing options,\n  // we can silently default them all to false\n  else {\n    return defaultIndexOptsToFalse(opts);\n  }\n}\n\nfunction setsIndexOptions(opts) {\n  const configIdx = opts.config && opts.config.autoIndex;\n  const { autoCreate, autoIndex } = opts;\n  return !!(configIdx || autoCreate || autoIndex);\n}\n\nfunction setsSecondaryRead(prefString) {\n  return !!(prefString === 'secondary' || prefString === 'secondaryPreferred');\n}\n\nfunction getUriReadPreference(connectionString) {\n  const exp = /(?:&|\\?)readPreference=(\\w+)(?:&|$)/;\n  const match = exp.exec(connectionString);\n  return match ? match[1] : null;\n}\n\nfunction defaultIndexOptsToFalse(opts) {\n  opts.config = { autoIndex: false };\n  opts.autoCreate = false;\n  opts.autoIndex = false;\n  return opts;\n}\n\nfunction throwReadPreferenceError() {\n  throw new MongooseError(\n    'MongoDB prohibits index creation on connections that read from ' +\n            'non-primary replicas.  Connections that set \"readPreference\" to \"secondary\" or ' +\n            '\"secondaryPreferred\" may not opt-in to the following connection options: ' +\n            'autoCreate, autoIndex'\n  );\n}\n\nmodule.exports = processConnectionOptions;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9wcm9jZXNzQ29ubmVjdGlvbk9wdGlvbnMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsY0FBYyxtQkFBTyxDQUFDLHFFQUFTO0FBQy9CLHNCQUFzQixtQkFBTyxDQUFDLDBFQUFnQjs7QUFFOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVLHdCQUF3QjtBQUNsQztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbGllbnQvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9wcm9jZXNzQ29ubmVjdGlvbk9wdGlvbnMuanM/YzJiMSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IGNsb25lID0gcmVxdWlyZSgnLi9jbG9uZScpO1xuY29uc3QgTW9uZ29vc2VFcnJvciA9IHJlcXVpcmUoJy4uL2Vycm9yL2luZGV4Jyk7XG5cbmZ1bmN0aW9uIHByb2Nlc3NDb25uZWN0aW9uT3B0aW9ucyh1cmksIG9wdGlvbnMpIHtcbiAgY29uc3Qgb3B0cyA9IG9wdGlvbnMgPyBvcHRpb25zIDoge307XG4gIGNvbnN0IHJlYWRQcmVmZXJlbmNlID0gb3B0cy5yZWFkUHJlZmVyZW5jZVxuICAgID8gb3B0cy5yZWFkUHJlZmVyZW5jZVxuICAgIDogZ2V0VXJpUmVhZFByZWZlcmVuY2UodXJpKTtcblxuICBjb25zdCBjbG9uZWRPcHRzID0gY2xvbmUob3B0cyk7XG4gIGNvbnN0IHJlc29sdmVkT3B0cyA9IChyZWFkUHJlZmVyZW5jZSAmJiByZWFkUHJlZmVyZW5jZSAhPT0gJ3ByaW1hcnknICYmIHJlYWRQcmVmZXJlbmNlICE9PSAncHJpbWFyeVByZWZlcnJlZCcpXG4gICAgPyByZXNvbHZlT3B0c0NvbmZsaWN0cyhyZWFkUHJlZmVyZW5jZSwgY2xvbmVkT3B0cylcbiAgICA6IGNsb25lZE9wdHM7XG5cbiAgcmV0dXJuIHJlc29sdmVkT3B0cztcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZU9wdHNDb25mbGljdHMocHJlZiwgb3B0cykge1xuICAvLyBkb24ndCBzaWxlbnRseSBvdmVycmlkZSB1c2VyLXByb3ZpZGVkIGluZGV4aW5nIG9wdGlvbnNcbiAgaWYgKHNldHNJbmRleE9wdGlvbnMob3B0cykgJiYgc2V0c1NlY29uZGFyeVJlYWQocHJlZikpIHtcbiAgICB0aHJvd1JlYWRQcmVmZXJlbmNlRXJyb3IoKTtcbiAgfVxuXG4gIC8vIGlmIHVzZXIgaGFzIG5vdCBleHBsaWNpdGx5IHNldCBhbnkgYXV0by1pbmRleGluZyBvcHRpb25zLFxuICAvLyB3ZSBjYW4gc2lsZW50bHkgZGVmYXVsdCB0aGVtIGFsbCB0byBmYWxzZVxuICBlbHNlIHtcbiAgICByZXR1cm4gZGVmYXVsdEluZGV4T3B0c1RvRmFsc2Uob3B0cyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gc2V0c0luZGV4T3B0aW9ucyhvcHRzKSB7XG4gIGNvbnN0IGNvbmZpZ0lkeCA9IG9wdHMuY29uZmlnICYmIG9wdHMuY29uZmlnLmF1dG9JbmRleDtcbiAgY29uc3QgeyBhdXRvQ3JlYXRlLCBhdXRvSW5kZXggfSA9IG9wdHM7XG4gIHJldHVybiAhIShjb25maWdJZHggfHwgYXV0b0NyZWF0ZSB8fCBhdXRvSW5kZXgpO1xufVxuXG5mdW5jdGlvbiBzZXRzU2Vjb25kYXJ5UmVhZChwcmVmU3RyaW5nKSB7XG4gIHJldHVybiAhIShwcmVmU3RyaW5nID09PSAnc2Vjb25kYXJ5JyB8fCBwcmVmU3RyaW5nID09PSAnc2Vjb25kYXJ5UHJlZmVycmVkJyk7XG59XG5cbmZ1bmN0aW9uIGdldFVyaVJlYWRQcmVmZXJlbmNlKGNvbm5lY3Rpb25TdHJpbmcpIHtcbiAgY29uc3QgZXhwID0gLyg/OiZ8XFw/KXJlYWRQcmVmZXJlbmNlPShcXHcrKSg/OiZ8JCkvO1xuICBjb25zdCBtYXRjaCA9IGV4cC5leGVjKGNvbm5lY3Rpb25TdHJpbmcpO1xuICByZXR1cm4gbWF0Y2ggPyBtYXRjaFsxXSA6IG51bGw7XG59XG5cbmZ1bmN0aW9uIGRlZmF1bHRJbmRleE9wdHNUb0ZhbHNlKG9wdHMpIHtcbiAgb3B0cy5jb25maWcgPSB7IGF1dG9JbmRleDogZmFsc2UgfTtcbiAgb3B0cy5hdXRvQ3JlYXRlID0gZmFsc2U7XG4gIG9wdHMuYXV0b0luZGV4ID0gZmFsc2U7XG4gIHJldHVybiBvcHRzO1xufVxuXG5mdW5jdGlvbiB0aHJvd1JlYWRQcmVmZXJlbmNlRXJyb3IoKSB7XG4gIHRocm93IG5ldyBNb25nb29zZUVycm9yKFxuICAgICdNb25nb0RCIHByb2hpYml0cyBpbmRleCBjcmVhdGlvbiBvbiBjb25uZWN0aW9ucyB0aGF0IHJlYWQgZnJvbSAnICtcbiAgICAgICAgICAgICdub24tcHJpbWFyeSByZXBsaWNhcy4gIENvbm5lY3Rpb25zIHRoYXQgc2V0IFwicmVhZFByZWZlcmVuY2VcIiB0byBcInNlY29uZGFyeVwiIG9yICcgK1xuICAgICAgICAgICAgJ1wic2Vjb25kYXJ5UHJlZmVycmVkXCIgbWF5IG5vdCBvcHQtaW4gdG8gdGhlIGZvbGxvd2luZyBjb25uZWN0aW9uIG9wdGlvbnM6ICcgK1xuICAgICAgICAgICAgJ2F1dG9DcmVhdGUsIGF1dG9JbmRleCdcbiAgKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBwcm9jZXNzQ29ubmVjdGlvbk9wdGlvbnM7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../server/node_modules/mongoose/lib/helpers/processConnectionOptions.js\n");

/***/ }),

/***/ "../server/node_modules/mongoose/lib/helpers/projection/applyProjection.js":
/*!*********************************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/helpers/projection/applyProjection.js ***!
  \*********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst hasIncludedChildren = __webpack_require__(/*! ./hasIncludedChildren */ \"../server/node_modules/mongoose/lib/helpers/projection/hasIncludedChildren.js\");\nconst isExclusive = __webpack_require__(/*! ./isExclusive */ \"../server/node_modules/mongoose/lib/helpers/projection/isExclusive.js\");\nconst isInclusive = __webpack_require__(/*! ./isInclusive */ \"../server/node_modules/mongoose/lib/helpers/projection/isInclusive.js\");\nconst isPOJO = (__webpack_require__(/*! ../../utils */ \"../server/node_modules/mongoose/lib/utils.js\").isPOJO);\n\nmodule.exports = function applyProjection(doc, projection, _hasIncludedChildren) {\n  if (projection == null) {\n    return doc;\n  }\n  if (doc == null) {\n    return doc;\n  }\n\n  let exclude = null;\n  if (isInclusive(projection)) {\n    exclude = false;\n  } else if (isExclusive(projection)) {\n    exclude = true;\n  }\n\n  if (exclude == null) {\n    return doc;\n  } else if (exclude) {\n    _hasIncludedChildren = _hasIncludedChildren || hasIncludedChildren(projection);\n    return applyExclusiveProjection(doc, projection, _hasIncludedChildren);\n  } else {\n    _hasIncludedChildren = _hasIncludedChildren || hasIncludedChildren(projection);\n    return applyInclusiveProjection(doc, projection, _hasIncludedChildren);\n  }\n};\n\nfunction applyExclusiveProjection(doc, projection, hasIncludedChildren, projectionLimb, prefix) {\n  if (doc == null || typeof doc !== 'object') {\n    return doc;\n  }\n  const ret = { ...doc };\n  projectionLimb = prefix ? (projectionLimb || {}) : projection;\n\n  for (const key of Object.keys(ret)) {\n    const fullPath = prefix ? prefix + '.' + key : key;\n    if (projection.hasOwnProperty(fullPath) || projectionLimb.hasOwnProperty(key)) {\n      if (isPOJO(projection[fullPath]) || isPOJO(projectionLimb[key])) {\n        ret[key] = applyExclusiveProjection(ret[key], projection, hasIncludedChildren, projectionLimb[key], fullPath);\n      } else {\n        delete ret[key];\n      }\n    } else if (hasIncludedChildren[fullPath]) {\n      ret[key] = applyExclusiveProjection(ret[key], projection, hasIncludedChildren, projectionLimb[key], fullPath);\n    }\n  }\n  return ret;\n}\n\nfunction applyInclusiveProjection(doc, projection, hasIncludedChildren, projectionLimb, prefix) {\n  if (doc == null || typeof doc !== 'object') {\n    return doc;\n  }\n  const ret = { ...doc };\n  projectionLimb = prefix ? (projectionLimb || {}) : projection;\n\n  for (const key of Object.keys(ret)) {\n    const fullPath = prefix ? prefix + '.' + key : key;\n    if (projection.hasOwnProperty(fullPath) || projectionLimb.hasOwnProperty(key)) {\n      if (isPOJO(projection[fullPath]) || isPOJO(projectionLimb[key])) {\n        ret[key] = applyInclusiveProjection(ret[key], projection, hasIncludedChildren, projectionLimb[key], fullPath);\n      }\n      continue;\n    } else if (hasIncludedChildren[fullPath]) {\n      ret[key] = applyInclusiveProjection(ret[key], projection, hasIncludedChildren, projectionLimb[key], fullPath);\n    } else {\n      delete ret[key];\n    }\n  }\n  return ret;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9wcm9qZWN0aW9uL2FwcGx5UHJvamVjdGlvbi5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYiw0QkFBNEIsbUJBQU8sQ0FBQyw0R0FBdUI7QUFDM0Qsb0JBQW9CLG1CQUFPLENBQUMsNEZBQWU7QUFDM0Msb0JBQW9CLG1CQUFPLENBQUMsNEZBQWU7QUFDM0MsZUFBZSwrRkFBNkI7O0FBRTVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQixpREFBaUQ7O0FBRWpEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCLGlEQUFpRDs7QUFFakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2NsaWVudC8uLi9zZXJ2ZXIvbm9kZV9tb2R1bGVzL21vbmdvb3NlL2xpYi9oZWxwZXJzL3Byb2plY3Rpb24vYXBwbHlQcm9qZWN0aW9uLmpzP2ZjYWYiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBoYXNJbmNsdWRlZENoaWxkcmVuID0gcmVxdWlyZSgnLi9oYXNJbmNsdWRlZENoaWxkcmVuJyk7XG5jb25zdCBpc0V4Y2x1c2l2ZSA9IHJlcXVpcmUoJy4vaXNFeGNsdXNpdmUnKTtcbmNvbnN0IGlzSW5jbHVzaXZlID0gcmVxdWlyZSgnLi9pc0luY2x1c2l2ZScpO1xuY29uc3QgaXNQT0pPID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMnKS5pc1BPSk87XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gYXBwbHlQcm9qZWN0aW9uKGRvYywgcHJvamVjdGlvbiwgX2hhc0luY2x1ZGVkQ2hpbGRyZW4pIHtcbiAgaWYgKHByb2plY3Rpb24gPT0gbnVsbCkge1xuICAgIHJldHVybiBkb2M7XG4gIH1cbiAgaWYgKGRvYyA9PSBudWxsKSB7XG4gICAgcmV0dXJuIGRvYztcbiAgfVxuXG4gIGxldCBleGNsdWRlID0gbnVsbDtcbiAgaWYgKGlzSW5jbHVzaXZlKHByb2plY3Rpb24pKSB7XG4gICAgZXhjbHVkZSA9IGZhbHNlO1xuICB9IGVsc2UgaWYgKGlzRXhjbHVzaXZlKHByb2plY3Rpb24pKSB7XG4gICAgZXhjbHVkZSA9IHRydWU7XG4gIH1cblxuICBpZiAoZXhjbHVkZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuIGRvYztcbiAgfSBlbHNlIGlmIChleGNsdWRlKSB7XG4gICAgX2hhc0luY2x1ZGVkQ2hpbGRyZW4gPSBfaGFzSW5jbHVkZWRDaGlsZHJlbiB8fCBoYXNJbmNsdWRlZENoaWxkcmVuKHByb2plY3Rpb24pO1xuICAgIHJldHVybiBhcHBseUV4Y2x1c2l2ZVByb2plY3Rpb24oZG9jLCBwcm9qZWN0aW9uLCBfaGFzSW5jbHVkZWRDaGlsZHJlbik7XG4gIH0gZWxzZSB7XG4gICAgX2hhc0luY2x1ZGVkQ2hpbGRyZW4gPSBfaGFzSW5jbHVkZWRDaGlsZHJlbiB8fCBoYXNJbmNsdWRlZENoaWxkcmVuKHByb2plY3Rpb24pO1xuICAgIHJldHVybiBhcHBseUluY2x1c2l2ZVByb2plY3Rpb24oZG9jLCBwcm9qZWN0aW9uLCBfaGFzSW5jbHVkZWRDaGlsZHJlbik7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGFwcGx5RXhjbHVzaXZlUHJvamVjdGlvbihkb2MsIHByb2plY3Rpb24sIGhhc0luY2x1ZGVkQ2hpbGRyZW4sIHByb2plY3Rpb25MaW1iLCBwcmVmaXgpIHtcbiAgaWYgKGRvYyA9PSBudWxsIHx8IHR5cGVvZiBkb2MgIT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIGRvYztcbiAgfVxuICBjb25zdCByZXQgPSB7IC4uLmRvYyB9O1xuICBwcm9qZWN0aW9uTGltYiA9IHByZWZpeCA/IChwcm9qZWN0aW9uTGltYiB8fCB7fSkgOiBwcm9qZWN0aW9uO1xuXG4gIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKHJldCkpIHtcbiAgICBjb25zdCBmdWxsUGF0aCA9IHByZWZpeCA/IHByZWZpeCArICcuJyArIGtleSA6IGtleTtcbiAgICBpZiAocHJvamVjdGlvbi5oYXNPd25Qcm9wZXJ0eShmdWxsUGF0aCkgfHwgcHJvamVjdGlvbkxpbWIuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgaWYgKGlzUE9KTyhwcm9qZWN0aW9uW2Z1bGxQYXRoXSkgfHwgaXNQT0pPKHByb2plY3Rpb25MaW1iW2tleV0pKSB7XG4gICAgICAgIHJldFtrZXldID0gYXBwbHlFeGNsdXNpdmVQcm9qZWN0aW9uKHJldFtrZXldLCBwcm9qZWN0aW9uLCBoYXNJbmNsdWRlZENoaWxkcmVuLCBwcm9qZWN0aW9uTGltYltrZXldLCBmdWxsUGF0aCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWxldGUgcmV0W2tleV07XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChoYXNJbmNsdWRlZENoaWxkcmVuW2Z1bGxQYXRoXSkge1xuICAgICAgcmV0W2tleV0gPSBhcHBseUV4Y2x1c2l2ZVByb2plY3Rpb24ocmV0W2tleV0sIHByb2plY3Rpb24sIGhhc0luY2x1ZGVkQ2hpbGRyZW4sIHByb2plY3Rpb25MaW1iW2tleV0sIGZ1bGxQYXRoKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gYXBwbHlJbmNsdXNpdmVQcm9qZWN0aW9uKGRvYywgcHJvamVjdGlvbiwgaGFzSW5jbHVkZWRDaGlsZHJlbiwgcHJvamVjdGlvbkxpbWIsIHByZWZpeCkge1xuICBpZiAoZG9jID09IG51bGwgfHwgdHlwZW9mIGRvYyAhPT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gZG9jO1xuICB9XG4gIGNvbnN0IHJldCA9IHsgLi4uZG9jIH07XG4gIHByb2plY3Rpb25MaW1iID0gcHJlZml4ID8gKHByb2plY3Rpb25MaW1iIHx8IHt9KSA6IHByb2plY3Rpb247XG5cbiAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMocmV0KSkge1xuICAgIGNvbnN0IGZ1bGxQYXRoID0gcHJlZml4ID8gcHJlZml4ICsgJy4nICsga2V5IDoga2V5O1xuICAgIGlmIChwcm9qZWN0aW9uLmhhc093blByb3BlcnR5KGZ1bGxQYXRoKSB8fCBwcm9qZWN0aW9uTGltYi5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICBpZiAoaXNQT0pPKHByb2plY3Rpb25bZnVsbFBhdGhdKSB8fCBpc1BPSk8ocHJvamVjdGlvbkxpbWJba2V5XSkpIHtcbiAgICAgICAgcmV0W2tleV0gPSBhcHBseUluY2x1c2l2ZVByb2plY3Rpb24ocmV0W2tleV0sIHByb2plY3Rpb24sIGhhc0luY2x1ZGVkQ2hpbGRyZW4sIHByb2plY3Rpb25MaW1iW2tleV0sIGZ1bGxQYXRoKTtcbiAgICAgIH1cbiAgICAgIGNvbnRpbnVlO1xuICAgIH0gZWxzZSBpZiAoaGFzSW5jbHVkZWRDaGlsZHJlbltmdWxsUGF0aF0pIHtcbiAgICAgIHJldFtrZXldID0gYXBwbHlJbmNsdXNpdmVQcm9qZWN0aW9uKHJldFtrZXldLCBwcm9qZWN0aW9uLCBoYXNJbmNsdWRlZENoaWxkcmVuLCBwcm9qZWN0aW9uTGltYltrZXldLCBmdWxsUGF0aCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlbGV0ZSByZXRba2V5XTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../server/node_modules/mongoose/lib/helpers/projection/applyProjection.js\n");

/***/ }),

/***/ "../server/node_modules/mongoose/lib/helpers/projection/hasIncludedChildren.js":
/*!*************************************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/helpers/projection/hasIncludedChildren.js ***!
  \*************************************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/**\n * Creates an object that precomputes whether a given path has child fields in\n * the projection.\n *\n * #### Example:\n *\n *     const res = hasIncludedChildren({ 'a.b.c': 0 });\n *     res.a; // 1\n *     res['a.b']; // 1\n *     res['a.b.c']; // 1\n *     res['a.c']; // undefined\n *\n * @param {Object} fields\n * @api private\n */\n\nmodule.exports = function hasIncludedChildren(fields) {\n  const hasIncludedChildren = {};\n  const keys = Object.keys(fields);\n\n  for (const key of keys) {\n\n    if (key.indexOf('.') === -1) {\n      hasIncludedChildren[key] = 1;\n      continue;\n    }\n    const parts = key.split('.');\n    let c = parts[0];\n\n    for (let i = 0; i < parts.length; ++i) {\n      hasIncludedChildren[c] = 1;\n      if (i + 1 < parts.length) {\n        c = c + '.' + parts[i + 1];\n      }\n    }\n  }\n\n  return hasIncludedChildren;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9wcm9qZWN0aW9uL2hhc0luY2x1ZGVkQ2hpbGRyZW4uanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLFlBQVk7QUFDckQsY0FBYztBQUNkLG1CQUFtQjtBQUNuQixxQkFBcUI7QUFDckIsbUJBQW1CO0FBQ25CO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2xpZW50Ly4uL3NlcnZlci9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvcHJvamVjdGlvbi9oYXNJbmNsdWRlZENoaWxkcmVuLmpzPzM2MjAiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gb2JqZWN0IHRoYXQgcHJlY29tcHV0ZXMgd2hldGhlciBhIGdpdmVuIHBhdGggaGFzIGNoaWxkIGZpZWxkcyBpblxuICogdGhlIHByb2plY3Rpb24uXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBjb25zdCByZXMgPSBoYXNJbmNsdWRlZENoaWxkcmVuKHsgJ2EuYi5jJzogMCB9KTtcbiAqICAgICByZXMuYTsgLy8gMVxuICogICAgIHJlc1snYS5iJ107IC8vIDFcbiAqICAgICByZXNbJ2EuYi5jJ107IC8vIDFcbiAqICAgICByZXNbJ2EuYyddOyAvLyB1bmRlZmluZWRcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gZmllbGRzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGhhc0luY2x1ZGVkQ2hpbGRyZW4oZmllbGRzKSB7XG4gIGNvbnN0IGhhc0luY2x1ZGVkQ2hpbGRyZW4gPSB7fTtcbiAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKGZpZWxkcyk7XG5cbiAgZm9yIChjb25zdCBrZXkgb2Yga2V5cykge1xuXG4gICAgaWYgKGtleS5pbmRleE9mKCcuJykgPT09IC0xKSB7XG4gICAgICBoYXNJbmNsdWRlZENoaWxkcmVuW2tleV0gPSAxO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGNvbnN0IHBhcnRzID0ga2V5LnNwbGl0KCcuJyk7XG4gICAgbGV0IGMgPSBwYXJ0c1swXTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFydHMubGVuZ3RoOyArK2kpIHtcbiAgICAgIGhhc0luY2x1ZGVkQ2hpbGRyZW5bY10gPSAxO1xuICAgICAgaWYgKGkgKyAxIDwgcGFydHMubGVuZ3RoKSB7XG4gICAgICAgIGMgPSBjICsgJy4nICsgcGFydHNbaSArIDFdO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBoYXNJbmNsdWRlZENoaWxkcmVuO1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../server/node_modules/mongoose/lib/helpers/projection/hasIncludedChildren.js\n");

/***/ }),

/***/ "../server/node_modules/mongoose/lib/helpers/projection/isDefiningProjection.js":
/*!**************************************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/helpers/projection/isDefiningProjection.js ***!
  \**************************************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/*!\n * ignore\n */\n\nmodule.exports = function isDefiningProjection(val) {\n  if (val == null) {\n    // `undefined` or `null` become exclusive projections\n    return true;\n  }\n  if (typeof val === 'object') {\n    // Only cases where a value does **not** define whether the whole projection\n    // is inclusive or exclusive are `$meta` and `$slice`.\n    return !('$meta' in val) && !('$slice' in val);\n  }\n  return true;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9wcm9qZWN0aW9uL2lzRGVmaW5pbmdQcm9qZWN0aW9uLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbGllbnQvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9wcm9qZWN0aW9uL2lzRGVmaW5pbmdQcm9qZWN0aW9uLmpzPzIyYmIiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNEZWZpbmluZ1Byb2plY3Rpb24odmFsKSB7XG4gIGlmICh2YWwgPT0gbnVsbCkge1xuICAgIC8vIGB1bmRlZmluZWRgIG9yIGBudWxsYCBiZWNvbWUgZXhjbHVzaXZlIHByb2plY3Rpb25zXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdvYmplY3QnKSB7XG4gICAgLy8gT25seSBjYXNlcyB3aGVyZSBhIHZhbHVlIGRvZXMgKipub3QqKiBkZWZpbmUgd2hldGhlciB0aGUgd2hvbGUgcHJvamVjdGlvblxuICAgIC8vIGlzIGluY2x1c2l2ZSBvciBleGNsdXNpdmUgYXJlIGAkbWV0YWAgYW5kIGAkc2xpY2VgLlxuICAgIHJldHVybiAhKCckbWV0YScgaW4gdmFsKSAmJiAhKCckc2xpY2UnIGluIHZhbCk7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../server/node_modules/mongoose/lib/helpers/projection/isDefiningProjection.js\n");

/***/ }),

/***/ "../server/node_modules/mongoose/lib/helpers/projection/isExclusive.js":
/*!*****************************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/helpers/projection/isExclusive.js ***!
  \*****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst isDefiningProjection = __webpack_require__(/*! ./isDefiningProjection */ \"../server/node_modules/mongoose/lib/helpers/projection/isDefiningProjection.js\");\n\n/*!\n * ignore\n */\n\nmodule.exports = function isExclusive(projection) {\n  if (projection == null) {\n    return null;\n  }\n\n  const keys = Object.keys(projection);\n  let exclude = null;\n\n  if (keys.length === 1 && keys[0] === '_id') {\n    exclude = !projection._id;\n  } else {\n    for (let ki = 0; ki < keys.length; ++ki) {\n      // Does this projection explicitly define inclusion/exclusion?\n      // Explicitly avoid `$meta` and `$slice`\n      const key = keys[ki];\n      if (key !== '_id' && isDefiningProjection(projection[key])) {\n        exclude = (projection[key] != null && typeof projection[key] === 'object') ?\n          isExclusive(projection[key]) :\n          !projection[key];\n        break;\n      }\n    }\n  }\n\n  return exclude;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9wcm9qZWN0aW9uL2lzRXhjbHVzaXZlLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLDZCQUE2QixtQkFBTyxDQUFDLDhHQUF3Qjs7QUFFN0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSixxQkFBcUIsa0JBQWtCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2NsaWVudC8uLi9zZXJ2ZXIvbm9kZV9tb2R1bGVzL21vbmdvb3NlL2xpYi9oZWxwZXJzL3Byb2plY3Rpb24vaXNFeGNsdXNpdmUuanM/NzM2MSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IGlzRGVmaW5pbmdQcm9qZWN0aW9uID0gcmVxdWlyZSgnLi9pc0RlZmluaW5nUHJvamVjdGlvbicpO1xuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNFeGNsdXNpdmUocHJvamVjdGlvbikge1xuICBpZiAocHJvamVjdGlvbiA9PSBudWxsKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMocHJvamVjdGlvbik7XG4gIGxldCBleGNsdWRlID0gbnVsbDtcblxuICBpZiAoa2V5cy5sZW5ndGggPT09IDEgJiYga2V5c1swXSA9PT0gJ19pZCcpIHtcbiAgICBleGNsdWRlID0gIXByb2plY3Rpb24uX2lkO1xuICB9IGVsc2Uge1xuICAgIGZvciAobGV0IGtpID0gMDsga2kgPCBrZXlzLmxlbmd0aDsgKytraSkge1xuICAgICAgLy8gRG9lcyB0aGlzIHByb2plY3Rpb24gZXhwbGljaXRseSBkZWZpbmUgaW5jbHVzaW9uL2V4Y2x1c2lvbj9cbiAgICAgIC8vIEV4cGxpY2l0bHkgYXZvaWQgYCRtZXRhYCBhbmQgYCRzbGljZWBcbiAgICAgIGNvbnN0IGtleSA9IGtleXNba2ldO1xuICAgICAgaWYgKGtleSAhPT0gJ19pZCcgJiYgaXNEZWZpbmluZ1Byb2plY3Rpb24ocHJvamVjdGlvbltrZXldKSkge1xuICAgICAgICBleGNsdWRlID0gKHByb2plY3Rpb25ba2V5XSAhPSBudWxsICYmIHR5cGVvZiBwcm9qZWN0aW9uW2tleV0gPT09ICdvYmplY3QnKSA/XG4gICAgICAgICAgaXNFeGNsdXNpdmUocHJvamVjdGlvbltrZXldKSA6XG4gICAgICAgICAgIXByb2plY3Rpb25ba2V5XTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGV4Y2x1ZGU7XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../server/node_modules/mongoose/lib/helpers/projection/isExclusive.js\n");

/***/ }),

/***/ "../server/node_modules/mongoose/lib/helpers/projection/isInclusive.js":
/*!*****************************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/helpers/projection/isInclusive.js ***!
  \*****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst isDefiningProjection = __webpack_require__(/*! ./isDefiningProjection */ \"../server/node_modules/mongoose/lib/helpers/projection/isDefiningProjection.js\");\n\n/*!\n * ignore\n */\n\nmodule.exports = function isInclusive(projection) {\n  if (projection == null) {\n    return false;\n  }\n\n  const props = Object.keys(projection);\n  const numProps = props.length;\n  if (numProps === 0) {\n    return false;\n  }\n\n  for (let i = 0; i < numProps; ++i) {\n    const prop = props[i];\n    // Plus paths can't define the projection (see gh-7050)\n    if (prop.startsWith('+')) {\n      continue;\n    }\n    // If field is truthy (1, true, etc.) and not an object, then this\n    // projection must be inclusive. If object, assume its $meta, $slice, etc.\n    if (isDefiningProjection(projection[prop]) && !!projection[prop]) {\n      if (projection[prop] != null && typeof projection[prop] === 'object') {\n        return isInclusive(projection[prop]);\n      } else {\n        return !!projection[prop];\n      }\n    }\n  }\n\n  return false;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9wcm9qZWN0aW9uL2lzSW5jbHVzaXZlLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLDZCQUE2QixtQkFBTyxDQUFDLDhHQUF3Qjs7QUFFN0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLGNBQWM7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2NsaWVudC8uLi9zZXJ2ZXIvbm9kZV9tb2R1bGVzL21vbmdvb3NlL2xpYi9oZWxwZXJzL3Byb2plY3Rpb24vaXNJbmNsdXNpdmUuanM/NTQxYyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IGlzRGVmaW5pbmdQcm9qZWN0aW9uID0gcmVxdWlyZSgnLi9pc0RlZmluaW5nUHJvamVjdGlvbicpO1xuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNJbmNsdXNpdmUocHJvamVjdGlvbikge1xuICBpZiAocHJvamVjdGlvbiA9PSBudWxsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgY29uc3QgcHJvcHMgPSBPYmplY3Qua2V5cyhwcm9qZWN0aW9uKTtcbiAgY29uc3QgbnVtUHJvcHMgPSBwcm9wcy5sZW5ndGg7XG4gIGlmIChudW1Qcm9wcyA9PT0gMCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtUHJvcHM7ICsraSkge1xuICAgIGNvbnN0IHByb3AgPSBwcm9wc1tpXTtcbiAgICAvLyBQbHVzIHBhdGhzIGNhbid0IGRlZmluZSB0aGUgcHJvamVjdGlvbiAoc2VlIGdoLTcwNTApXG4gICAgaWYgKHByb3Auc3RhcnRzV2l0aCgnKycpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgLy8gSWYgZmllbGQgaXMgdHJ1dGh5ICgxLCB0cnVlLCBldGMuKSBhbmQgbm90IGFuIG9iamVjdCwgdGhlbiB0aGlzXG4gICAgLy8gcHJvamVjdGlvbiBtdXN0IGJlIGluY2x1c2l2ZS4gSWYgb2JqZWN0LCBhc3N1bWUgaXRzICRtZXRhLCAkc2xpY2UsIGV0Yy5cbiAgICBpZiAoaXNEZWZpbmluZ1Byb2plY3Rpb24ocHJvamVjdGlvbltwcm9wXSkgJiYgISFwcm9qZWN0aW9uW3Byb3BdKSB7XG4gICAgICBpZiAocHJvamVjdGlvbltwcm9wXSAhPSBudWxsICYmIHR5cGVvZiBwcm9qZWN0aW9uW3Byb3BdID09PSAnb2JqZWN0Jykge1xuICAgICAgICByZXR1cm4gaXNJbmNsdXNpdmUocHJvamVjdGlvbltwcm9wXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gISFwcm9qZWN0aW9uW3Byb3BdO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../server/node_modules/mongoose/lib/helpers/projection/isInclusive.js\n");

/***/ }),

/***/ "../server/node_modules/mongoose/lib/helpers/projection/isNestedProjection.js":
/*!************************************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/helpers/projection/isNestedProjection.js ***!
  \************************************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nmodule.exports = function isNestedProjection(val) {\n  if (val == null || typeof val !== 'object') {\n    return false;\n  }\n  return val.$slice == null && val.$elemMatch == null && val.$meta == null && val.$ == null;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9wcm9qZWN0aW9uL2lzTmVzdGVkUHJvamVjdGlvbi5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbGllbnQvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9wcm9qZWN0aW9uL2lzTmVzdGVkUHJvamVjdGlvbi5qcz80ODZmIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc05lc3RlZFByb2plY3Rpb24odmFsKSB7XG4gIGlmICh2YWwgPT0gbnVsbCB8fCB0eXBlb2YgdmFsICE9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdmFsLiRzbGljZSA9PSBudWxsICYmIHZhbC4kZWxlbU1hdGNoID09IG51bGwgJiYgdmFsLiRtZXRhID09IG51bGwgJiYgdmFsLiQgPT0gbnVsbDtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../server/node_modules/mongoose/lib/helpers/projection/isNestedProjection.js\n");

/***/ }),

/***/ "../server/node_modules/mongoose/lib/helpers/projection/isPathExcluded.js":
/*!********************************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/helpers/projection/isPathExcluded.js ***!
  \********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst isDefiningProjection = __webpack_require__(/*! ./isDefiningProjection */ \"../server/node_modules/mongoose/lib/helpers/projection/isDefiningProjection.js\");\n\n/**\n * Determines if `path` is excluded by `projection`\n *\n * @param {Object} projection\n * @param {String} path\n * @return {Boolean}\n * @api private\n */\n\nmodule.exports = function isPathExcluded(projection, path) {\n  if (projection == null) {\n    return false;\n  }\n\n  if (path === '_id') {\n    return projection._id === 0;\n  }\n\n  const paths = Object.keys(projection);\n  let type = null;\n\n  for (const _path of paths) {\n    if (isDefiningProjection(projection[_path])) {\n      type = projection[path] === 1 ? 'inclusive' : 'exclusive';\n      break;\n    }\n  }\n\n  if (type === 'inclusive') {\n    return projection[path] !== 1;\n  }\n  if (type === 'exclusive') {\n    return projection[path] === 0;\n  }\n  return false;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9wcm9qZWN0aW9uL2lzUGF0aEV4Y2x1ZGVkLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLDZCQUE2QixtQkFBTyxDQUFDLDhHQUF3Qjs7QUFFN0Q7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2NsaWVudC8uLi9zZXJ2ZXIvbm9kZV9tb2R1bGVzL21vbmdvb3NlL2xpYi9oZWxwZXJzL3Byb2plY3Rpb24vaXNQYXRoRXhjbHVkZWQuanM/YTZiNCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IGlzRGVmaW5pbmdQcm9qZWN0aW9uID0gcmVxdWlyZSgnLi9pc0RlZmluaW5nUHJvamVjdGlvbicpO1xuXG4vKipcbiAqIERldGVybWluZXMgaWYgYHBhdGhgIGlzIGV4Y2x1ZGVkIGJ5IGBwcm9qZWN0aW9uYFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwcm9qZWN0aW9uXG4gKiBAcGFyYW0ge1N0cmluZ30gcGF0aFxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNQYXRoRXhjbHVkZWQocHJvamVjdGlvbiwgcGF0aCkge1xuICBpZiAocHJvamVjdGlvbiA9PSBudWxsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKHBhdGggPT09ICdfaWQnKSB7XG4gICAgcmV0dXJuIHByb2plY3Rpb24uX2lkID09PSAwO1xuICB9XG5cbiAgY29uc3QgcGF0aHMgPSBPYmplY3Qua2V5cyhwcm9qZWN0aW9uKTtcbiAgbGV0IHR5cGUgPSBudWxsO1xuXG4gIGZvciAoY29uc3QgX3BhdGggb2YgcGF0aHMpIHtcbiAgICBpZiAoaXNEZWZpbmluZ1Byb2plY3Rpb24ocHJvamVjdGlvbltfcGF0aF0pKSB7XG4gICAgICB0eXBlID0gcHJvamVjdGlvbltwYXRoXSA9PT0gMSA/ICdpbmNsdXNpdmUnIDogJ2V4Y2x1c2l2ZSc7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICBpZiAodHlwZSA9PT0gJ2luY2x1c2l2ZScpIHtcbiAgICByZXR1cm4gcHJvamVjdGlvbltwYXRoXSAhPT0gMTtcbiAgfVxuICBpZiAodHlwZSA9PT0gJ2V4Y2x1c2l2ZScpIHtcbiAgICByZXR1cm4gcHJvamVjdGlvbltwYXRoXSA9PT0gMDtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../server/node_modules/mongoose/lib/helpers/projection/isPathExcluded.js\n");

/***/ }),

/***/ "../server/node_modules/mongoose/lib/helpers/projection/isPathSelectedInclusive.js":
/*!*****************************************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/helpers/projection/isPathSelectedInclusive.js ***!
  \*****************************************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/*!\n * ignore\n */\n\nmodule.exports = function isPathSelectedInclusive(fields, path) {\n  const chunks = path.split('.');\n  let cur = '';\n  let j;\n  let keys;\n  let numKeys;\n  for (let i = 0; i < chunks.length; ++i) {\n    cur += cur.length ? '.' : '' + chunks[i];\n    if (fields[cur]) {\n      keys = Object.keys(fields);\n      numKeys = keys.length;\n      for (j = 0; j < numKeys; ++j) {\n        if (keys[i].indexOf(cur + '.') === 0 && keys[i].indexOf(path) !== 0) {\n          continue;\n        }\n      }\n      return true;\n    }\n  }\n\n  return false;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9wcm9qZWN0aW9uL2lzUGF0aFNlbGVjdGVkSW5jbHVzaXZlLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsbUJBQW1CO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGFBQWE7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2NsaWVudC8uLi9zZXJ2ZXIvbm9kZV9tb2R1bGVzL21vbmdvb3NlL2xpYi9oZWxwZXJzL3Byb2plY3Rpb24vaXNQYXRoU2VsZWN0ZWRJbmNsdXNpdmUuanM/M2Y1NyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc1BhdGhTZWxlY3RlZEluY2x1c2l2ZShmaWVsZHMsIHBhdGgpIHtcbiAgY29uc3QgY2h1bmtzID0gcGF0aC5zcGxpdCgnLicpO1xuICBsZXQgY3VyID0gJyc7XG4gIGxldCBqO1xuICBsZXQga2V5cztcbiAgbGV0IG51bUtleXM7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgY2h1bmtzLmxlbmd0aDsgKytpKSB7XG4gICAgY3VyICs9IGN1ci5sZW5ndGggPyAnLicgOiAnJyArIGNodW5rc1tpXTtcbiAgICBpZiAoZmllbGRzW2N1cl0pIHtcbiAgICAgIGtleXMgPSBPYmplY3Qua2V5cyhmaWVsZHMpO1xuICAgICAgbnVtS2V5cyA9IGtleXMubGVuZ3RoO1xuICAgICAgZm9yIChqID0gMDsgaiA8IG51bUtleXM7ICsraikge1xuICAgICAgICBpZiAoa2V5c1tpXS5pbmRleE9mKGN1ciArICcuJykgPT09IDAgJiYga2V5c1tpXS5pbmRleE9mKHBhdGgpICE9PSAwKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../server/node_modules/mongoose/lib/helpers/projection/isPathSelectedInclusive.js\n");

/***/ }),

/***/ "../server/node_modules/mongoose/lib/helpers/projection/isSubpath.js":
/*!***************************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/helpers/projection/isSubpath.js ***!
  \***************************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/**\n * Determines if `path2` is a subpath of or equal to `path1`\n *\n * @param {string} path1\n * @param {string} path2\n * @return {Boolean}\n * @api private\n */\n\nmodule.exports = function isSubpath(path1, path2) {\n  return path1 === path2 || path2.startsWith(path1 + '.');\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9wcm9qZWN0aW9uL2lzU3VicGF0aC5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2NsaWVudC8uLi9zZXJ2ZXIvbm9kZV9tb2R1bGVzL21vbmdvb3NlL2xpYi9oZWxwZXJzL3Byb2plY3Rpb24vaXNTdWJwYXRoLmpzPzZmOTYiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIERldGVybWluZXMgaWYgYHBhdGgyYCBpcyBhIHN1YnBhdGggb2Ygb3IgZXF1YWwgdG8gYHBhdGgxYFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoMVxuICogQHBhcmFtIHtzdHJpbmd9IHBhdGgyXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc1N1YnBhdGgocGF0aDEsIHBhdGgyKSB7XG4gIHJldHVybiBwYXRoMSA9PT0gcGF0aDIgfHwgcGF0aDIuc3RhcnRzV2l0aChwYXRoMSArICcuJyk7XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../server/node_modules/mongoose/lib/helpers/projection/isSubpath.js\n");

/***/ }),

/***/ "../server/node_modules/mongoose/lib/helpers/projection/parseProjection.js":
/*!*********************************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/helpers/projection/parseProjection.js ***!
  \*********************************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/**\n * Convert a string or array into a projection object, retaining all\n * `-` and `+` paths.\n */\n\nmodule.exports = function parseProjection(v, retainMinusPaths) {\n  const type = typeof v;\n\n  if (type === 'string') {\n    v = v.split(/\\s+/);\n  }\n  if (!Array.isArray(v) && Object.prototype.toString.call(v) !== '[object Arguments]') {\n    return v;\n  }\n\n  const len = v.length;\n  const ret = {};\n  for (let i = 0; i < len; ++i) {\n    let field = v[i];\n    if (!field) {\n      continue;\n    }\n    const include = '-' == field[0] ? 0 : 1;\n    if (!retainMinusPaths && include === 0) {\n      field = field.substring(1);\n    }\n    ret[field] = include;\n  }\n\n  return ret;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9wcm9qZWN0aW9uL3BhcnNlUHJvamVjdGlvbi5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCLFNBQVM7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2NsaWVudC8uLi9zZXJ2ZXIvbm9kZV9tb2R1bGVzL21vbmdvb3NlL2xpYi9oZWxwZXJzL3Byb2plY3Rpb24vcGFyc2VQcm9qZWN0aW9uLmpzP2E1NWIiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIENvbnZlcnQgYSBzdHJpbmcgb3IgYXJyYXkgaW50byBhIHByb2plY3Rpb24gb2JqZWN0LCByZXRhaW5pbmcgYWxsXG4gKiBgLWAgYW5kIGArYCBwYXRocy5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHBhcnNlUHJvamVjdGlvbih2LCByZXRhaW5NaW51c1BhdGhzKSB7XG4gIGNvbnN0IHR5cGUgPSB0eXBlb2YgdjtcblxuICBpZiAodHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICB2ID0gdi5zcGxpdCgvXFxzKy8pO1xuICB9XG4gIGlmICghQXJyYXkuaXNBcnJheSh2KSAmJiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodikgIT09ICdbb2JqZWN0IEFyZ3VtZW50c10nKSB7XG4gICAgcmV0dXJuIHY7XG4gIH1cblxuICBjb25zdCBsZW4gPSB2Lmxlbmd0aDtcbiAgY29uc3QgcmV0ID0ge307XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICBsZXQgZmllbGQgPSB2W2ldO1xuICAgIGlmICghZmllbGQpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBjb25zdCBpbmNsdWRlID0gJy0nID09IGZpZWxkWzBdID8gMCA6IDE7XG4gICAgaWYgKCFyZXRhaW5NaW51c1BhdGhzICYmIGluY2x1ZGUgPT09IDApIHtcbiAgICAgIGZpZWxkID0gZmllbGQuc3Vic3RyaW5nKDEpO1xuICAgIH1cbiAgICByZXRbZmllbGRdID0gaW5jbHVkZTtcbiAgfVxuXG4gIHJldHVybiByZXQ7XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../server/node_modules/mongoose/lib/helpers/projection/parseProjection.js\n");

/***/ }),

/***/ "../server/node_modules/mongoose/lib/helpers/promiseOrCallback.js":
/*!************************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/helpers/promiseOrCallback.js ***!
  \************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst immediate = __webpack_require__(/*! ./immediate */ \"../server/node_modules/mongoose/lib/helpers/immediate.js\");\n\nconst emittedSymbol = Symbol('mongoose#emitted');\n\nmodule.exports = function promiseOrCallback(callback, fn, ee, Promise) {\n  if (typeof callback === 'function') {\n    try {\n      return fn(function(error) {\n        if (error != null) {\n          if (ee != null && ee.listeners != null && ee.listeners('error').length > 0 && !error[emittedSymbol]) {\n            error[emittedSymbol] = true;\n            ee.emit('error', error);\n          }\n          try {\n            callback(error);\n          } catch (error) {\n            return immediate(() => {\n              throw error;\n            });\n          }\n          return;\n        }\n        callback.apply(this, arguments);\n      });\n    } catch (error) {\n      if (ee != null && ee.listeners != null && ee.listeners('error').length > 0 && !error[emittedSymbol]) {\n        error[emittedSymbol] = true;\n        ee.emit('error', error);\n      }\n\n      return callback(error);\n    }\n  }\n\n  Promise = Promise || global.Promise;\n\n  return new Promise((resolve, reject) => {\n    fn(function(error, res) {\n      if (error != null) {\n        if (ee != null && ee.listeners != null && ee.listeners('error').length > 0 && !error[emittedSymbol]) {\n          error[emittedSymbol] = true;\n          ee.emit('error', error);\n        }\n        return reject(error);\n      }\n      if (arguments.length > 2) {\n        return resolve(Array.prototype.slice.call(arguments, 1));\n      }\n      resolve(res);\n    });\n  });\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9wcm9taXNlT3JDYWxsYmFjay5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixrQkFBa0IsbUJBQU8sQ0FBQyw2RUFBYTs7QUFFdkM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2xpZW50Ly4uL3NlcnZlci9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvcHJvbWlzZU9yQ2FsbGJhY2suanM/M2E4ZiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IGltbWVkaWF0ZSA9IHJlcXVpcmUoJy4vaW1tZWRpYXRlJyk7XG5cbmNvbnN0IGVtaXR0ZWRTeW1ib2wgPSBTeW1ib2woJ21vbmdvb3NlI2VtaXR0ZWQnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBwcm9taXNlT3JDYWxsYmFjayhjYWxsYmFjaywgZm4sIGVlLCBQcm9taXNlKSB7XG4gIGlmICh0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGZuKGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgICAgIGlmIChlcnJvciAhPSBudWxsKSB7XG4gICAgICAgICAgaWYgKGVlICE9IG51bGwgJiYgZWUubGlzdGVuZXJzICE9IG51bGwgJiYgZWUubGlzdGVuZXJzKCdlcnJvcicpLmxlbmd0aCA+IDAgJiYgIWVycm9yW2VtaXR0ZWRTeW1ib2xdKSB7XG4gICAgICAgICAgICBlcnJvcltlbWl0dGVkU3ltYm9sXSA9IHRydWU7XG4gICAgICAgICAgICBlZS5lbWl0KCdlcnJvcicsIGVycm9yKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNhbGxiYWNrKGVycm9yKTtcbiAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIGltbWVkaWF0ZSgoKSA9PiB7XG4gICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjYWxsYmFjay5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmIChlZSAhPSBudWxsICYmIGVlLmxpc3RlbmVycyAhPSBudWxsICYmIGVlLmxpc3RlbmVycygnZXJyb3InKS5sZW5ndGggPiAwICYmICFlcnJvcltlbWl0dGVkU3ltYm9sXSkge1xuICAgICAgICBlcnJvcltlbWl0dGVkU3ltYm9sXSA9IHRydWU7XG4gICAgICAgIGVlLmVtaXQoJ2Vycm9yJywgZXJyb3IpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY2FsbGJhY2soZXJyb3IpO1xuICAgIH1cbiAgfVxuXG4gIFByb21pc2UgPSBQcm9taXNlIHx8IGdsb2JhbC5Qcm9taXNlO1xuXG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgZm4oZnVuY3Rpb24oZXJyb3IsIHJlcykge1xuICAgICAgaWYgKGVycm9yICE9IG51bGwpIHtcbiAgICAgICAgaWYgKGVlICE9IG51bGwgJiYgZWUubGlzdGVuZXJzICE9IG51bGwgJiYgZWUubGlzdGVuZXJzKCdlcnJvcicpLmxlbmd0aCA+IDAgJiYgIWVycm9yW2VtaXR0ZWRTeW1ib2xdKSB7XG4gICAgICAgICAgZXJyb3JbZW1pdHRlZFN5bWJvbF0gPSB0cnVlO1xuICAgICAgICAgIGVlLmVtaXQoJ2Vycm9yJywgZXJyb3IpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZWplY3QoZXJyb3IpO1xuICAgICAgfVxuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAyKSB7XG4gICAgICAgIHJldHVybiByZXNvbHZlKEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSkpO1xuICAgICAgfVxuICAgICAgcmVzb2x2ZShyZXMpO1xuICAgIH0pO1xuICB9KTtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../server/node_modules/mongoose/lib/helpers/promiseOrCallback.js\n");

/***/ }),

/***/ "../server/node_modules/mongoose/lib/helpers/query/applyGlobalOption.js":
/*!******************************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/helpers/query/applyGlobalOption.js ***!
  \******************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst utils = __webpack_require__(/*! ../../utils */ \"../server/node_modules/mongoose/lib/utils.js\");\n\nfunction applyGlobalMaxTimeMS(options, connectionOptions, baseOptions) {\n  applyGlobalOption(options, connectionOptions, baseOptions, 'maxTimeMS');\n}\n\nfunction applyGlobalDiskUse(options, connectionOptions, baseOptions) {\n  applyGlobalOption(options, connectionOptions, baseOptions, 'allowDiskUse');\n}\n\nmodule.exports = {\n  applyGlobalMaxTimeMS,\n  applyGlobalDiskUse\n};\n\n\nfunction applyGlobalOption(options, connectionOptions, baseOptions, optionName) {\n  if (utils.hasUserDefinedProperty(options, optionName)) {\n    return;\n  }\n\n  if (utils.hasUserDefinedProperty(connectionOptions, optionName)) {\n    options[optionName] = connectionOptions[optionName];\n  } else if (utils.hasUserDefinedProperty(baseOptions, optionName)) {\n    options[optionName] = baseOptions[optionName];\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9xdWVyeS9hcHBseUdsb2JhbE9wdGlvbi5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixjQUFjLG1CQUFPLENBQUMsaUVBQWE7O0FBRW5DO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2xpZW50Ly4uL3NlcnZlci9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvcXVlcnkvYXBwbHlHbG9iYWxPcHRpb24uanM/Y2ExYiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IHV0aWxzID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMnKTtcblxuZnVuY3Rpb24gYXBwbHlHbG9iYWxNYXhUaW1lTVMob3B0aW9ucywgY29ubmVjdGlvbk9wdGlvbnMsIGJhc2VPcHRpb25zKSB7XG4gIGFwcGx5R2xvYmFsT3B0aW9uKG9wdGlvbnMsIGNvbm5lY3Rpb25PcHRpb25zLCBiYXNlT3B0aW9ucywgJ21heFRpbWVNUycpO1xufVxuXG5mdW5jdGlvbiBhcHBseUdsb2JhbERpc2tVc2Uob3B0aW9ucywgY29ubmVjdGlvbk9wdGlvbnMsIGJhc2VPcHRpb25zKSB7XG4gIGFwcGx5R2xvYmFsT3B0aW9uKG9wdGlvbnMsIGNvbm5lY3Rpb25PcHRpb25zLCBiYXNlT3B0aW9ucywgJ2FsbG93RGlza1VzZScpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgYXBwbHlHbG9iYWxNYXhUaW1lTVMsXG4gIGFwcGx5R2xvYmFsRGlza1VzZVxufTtcblxuXG5mdW5jdGlvbiBhcHBseUdsb2JhbE9wdGlvbihvcHRpb25zLCBjb25uZWN0aW9uT3B0aW9ucywgYmFzZU9wdGlvbnMsIG9wdGlvbk5hbWUpIHtcbiAgaWYgKHV0aWxzLmhhc1VzZXJEZWZpbmVkUHJvcGVydHkob3B0aW9ucywgb3B0aW9uTmFtZSkpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAodXRpbHMuaGFzVXNlckRlZmluZWRQcm9wZXJ0eShjb25uZWN0aW9uT3B0aW9ucywgb3B0aW9uTmFtZSkpIHtcbiAgICBvcHRpb25zW29wdGlvbk5hbWVdID0gY29ubmVjdGlvbk9wdGlvbnNbb3B0aW9uTmFtZV07XG4gIH0gZWxzZSBpZiAodXRpbHMuaGFzVXNlckRlZmluZWRQcm9wZXJ0eShiYXNlT3B0aW9ucywgb3B0aW9uTmFtZSkpIHtcbiAgICBvcHRpb25zW29wdGlvbk5hbWVdID0gYmFzZU9wdGlvbnNbb3B0aW9uTmFtZV07XG4gIH1cbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../server/node_modules/mongoose/lib/helpers/query/applyGlobalOption.js\n");

/***/ }),

/***/ "../server/node_modules/mongoose/lib/helpers/query/cast$expr.js":
/*!**********************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/helpers/query/cast$expr.js ***!
  \**********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst CastError = __webpack_require__(/*! ../../error/cast */ \"../server/node_modules/mongoose/lib/error/cast.js\");\nconst StrictModeError = __webpack_require__(/*! ../../error/strict */ \"../server/node_modules/mongoose/lib/error/strict.js\");\nconst castNumber = __webpack_require__(/*! ../../cast/number */ \"../server/node_modules/mongoose/lib/cast/number.js\");\n\nconst booleanComparison = new Set(['$and', '$or']);\nconst comparisonOperator = new Set(['$cmp', '$eq', '$lt', '$lte', '$gt', '$gte']);\nconst arithmeticOperatorArray = new Set([\n  // avoid casting '$add' or '$subtract', because expressions can be either number or date,\n  // and we don't have a good way of inferring which arguments should be numbers and which should\n  // be dates.\n  '$multiply',\n  '$divide',\n  '$log',\n  '$mod',\n  '$trunc',\n  '$avg',\n  '$max',\n  '$min',\n  '$stdDevPop',\n  '$stdDevSamp',\n  '$sum'\n]);\nconst arithmeticOperatorNumber = new Set([\n  '$abs',\n  '$exp',\n  '$ceil',\n  '$floor',\n  '$ln',\n  '$log10',\n  '$sqrt',\n  '$sin',\n  '$cos',\n  '$tan',\n  '$asin',\n  '$acos',\n  '$atan',\n  '$atan2',\n  '$asinh',\n  '$acosh',\n  '$atanh',\n  '$sinh',\n  '$cosh',\n  '$tanh',\n  '$degreesToRadians',\n  '$radiansToDegrees'\n]);\nconst arrayElementOperators = new Set([\n  '$arrayElemAt',\n  '$first',\n  '$last'\n]);\nconst dateOperators = new Set([\n  '$year',\n  '$month',\n  '$week',\n  '$dayOfMonth',\n  '$dayOfYear',\n  '$hour',\n  '$minute',\n  '$second',\n  '$isoDayOfWeek',\n  '$isoWeekYear',\n  '$isoWeek',\n  '$millisecond'\n]);\nconst expressionOperator = new Set(['$not']);\n\nmodule.exports = function cast$expr(val, schema, strictQuery) {\n  if (typeof val !== 'object' || val === null) {\n    throw new Error('`$expr` must be an object');\n  }\n\n  return _castExpression(val, schema, strictQuery);\n};\n\nfunction _castExpression(val, schema, strictQuery) {\n  // Preserve the value if it represents a path or if it's null\n  if (isPath(val) || val === null) {\n    return val;\n  }\n\n  if (val.$cond != null) {\n    if (Array.isArray(val.$cond)) {\n      val.$cond = val.$cond.map(expr => _castExpression(expr, schema, strictQuery));\n    } else {\n      val.$cond.if = _castExpression(val.$cond.if, schema, strictQuery);\n      val.$cond.then = _castExpression(val.$cond.then, schema, strictQuery);\n      val.$cond.else = _castExpression(val.$cond.else, schema, strictQuery);\n    }\n  } else if (val.$ifNull != null) {\n    val.$ifNull.map(v => _castExpression(v, schema, strictQuery));\n  } else if (val.$switch != null) {\n    val.branches.map(v => _castExpression(v, schema, strictQuery));\n    val.default = _castExpression(val.default, schema, strictQuery);\n  }\n\n  const keys = Object.keys(val);\n  for (const key of keys) {\n    if (booleanComparison.has(key)) {\n      val[key] = val[key].map(v => _castExpression(v, schema, strictQuery));\n    } else if (comparisonOperator.has(key)) {\n      val[key] = castComparison(val[key], schema, strictQuery);\n    } else if (arithmeticOperatorArray.has(key)) {\n      val[key] = castArithmetic(val[key], schema, strictQuery);\n    } else if (arithmeticOperatorNumber.has(key)) {\n      val[key] = castNumberOperator(val[key], schema, strictQuery);\n    } else if (expressionOperator.has(key)) {\n      val[key] = _castExpression(val[key], schema, strictQuery);\n    }\n  }\n\n  if (val.$in) {\n    val.$in = castIn(val.$in, schema, strictQuery);\n  }\n  if (val.$size) {\n    val.$size = castNumberOperator(val.$size, schema, strictQuery);\n  }\n  if (val.$round) {\n    const $round = val.$round;\n    if (!Array.isArray($round) || $round.length < 1 || $round.length > 2) {\n      throw new CastError('Array', $round, '$round');\n    }\n    val.$round = $round.map(v => castNumberOperator(v, schema, strictQuery));\n  }\n\n  _omitUndefined(val);\n\n  return val;\n}\n\nfunction _omitUndefined(val) {\n  const keys = Object.keys(val);\n  for (let i = 0, len = keys.length; i < len; ++i) {\n    (val[keys[i]] === void 0) && delete val[keys[i]];\n  }\n}\n\n// { $op: <number> }\nfunction castNumberOperator(val) {\n  if (!isLiteral(val)) {\n    return val;\n  }\n\n  try {\n    return castNumber(val);\n  } catch (err) {\n    throw new CastError('Number', val);\n  }\n}\n\nfunction castIn(val, schema, strictQuery) {\n  const path = val[1];\n  if (!isPath(path)) {\n    return val;\n  }\n  const search = val[0];\n\n  const schematype = schema.path(path.slice(1));\n  if (schematype === null) {\n    if (strictQuery === false) {\n      return val;\n    } else if (strictQuery === 'throw') {\n      throw new StrictModeError('$in');\n    }\n\n    return void 0;\n  }\n\n  if (!schematype.$isMongooseArray) {\n    throw new Error('Path must be an array for $in');\n  }\n\n  return [\n    schematype.$isMongooseDocumentArray ? schematype.$embeddedSchemaType.cast(search) : schematype.caster.cast(search),\n    path\n  ];\n}\n\n// { $op: [<number>, <number>] }\nfunction castArithmetic(val) {\n  if (!Array.isArray(val)) {\n    if (!isLiteral(val)) {\n      return val;\n    }\n    try {\n      return castNumber(val);\n    } catch (err) {\n      throw new CastError('Number', val);\n    }\n  }\n\n  return val.map(v => {\n    if (!isLiteral(v)) {\n      return v;\n    }\n    try {\n      return castNumber(v);\n    } catch (err) {\n      throw new CastError('Number', v);\n    }\n  });\n}\n\n// { $op: [expression, expression] }\nfunction castComparison(val, schema, strictQuery) {\n  if (!Array.isArray(val) || val.length !== 2) {\n    throw new Error('Comparison operator must be an array of length 2');\n  }\n\n  val[0] = _castExpression(val[0], schema, strictQuery);\n  const lhs = val[0];\n\n  if (isLiteral(val[1])) {\n    let path = null;\n    let schematype = null;\n    let caster = null;\n    if (isPath(lhs)) {\n      path = lhs.slice(1);\n      schematype = schema.path(path);\n    } else if (typeof lhs === 'object' && lhs != null) {\n      for (const key of Object.keys(lhs)) {\n        if (dateOperators.has(key) && isPath(lhs[key])) {\n          path = lhs[key].slice(1) + '.' + key;\n          caster = castNumber;\n        } else if (arrayElementOperators.has(key) && isPath(lhs[key])) {\n          path = lhs[key].slice(1) + '.' + key;\n          schematype = schema.path(lhs[key].slice(1));\n          if (schematype != null) {\n            if (schematype.$isMongooseDocumentArray) {\n              schematype = schematype.$embeddedSchemaType;\n            } else if (schematype.$isMongooseArray) {\n              schematype = schematype.caster;\n            }\n          }\n        }\n      }\n    }\n\n    const is$literal = typeof val[1] === 'object' && val[1] != null && val[1].$literal != null;\n    if (schematype != null) {\n      if (is$literal) {\n        val[1] = { $literal: schematype.cast(val[1].$literal) };\n      } else {\n        val[1] = schematype.cast(val[1]);\n      }\n    } else if (caster != null) {\n      if (is$literal) {\n        try {\n          val[1] = { $literal: caster(val[1].$literal) };\n        } catch (err) {\n          throw new CastError(caster.name.replace(/^cast/, ''), val[1], path + '.$literal');\n        }\n      } else {\n        try {\n          val[1] = caster(val[1]);\n        } catch (err) {\n          throw new CastError(caster.name.replace(/^cast/, ''), val[1], path);\n        }\n      }\n    } else if (path != null && strictQuery === true) {\n      return void 0;\n    } else if (path != null && strictQuery === 'throw') {\n      throw new StrictModeError(path);\n    }\n  } else {\n    val[1] = _castExpression(val[1]);\n  }\n\n  return val;\n}\n\nfunction isPath(val) {\n  return typeof val === 'string' && val[0] === '$';\n}\n\nfunction isLiteral(val) {\n  if (typeof val === 'string' && val[0] === '$') {\n    return false;\n  }\n  if (typeof val === 'object' && val !== null && Object.keys(val).find(key => key[0] === '$')) {\n    // The `$literal` expression can make an object a literal\n    // https://www.mongodb.com/docs/manual/reference/operator/aggregation/literal/#mongodb-expression-exp.-literal\n    return val.$literal != null;\n  }\n  return true;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9xdWVyeS9jYXN0JGV4cHIuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsa0JBQWtCLG1CQUFPLENBQUMsMkVBQWtCO0FBQzVDLHdCQUF3QixtQkFBTyxDQUFDLCtFQUFvQjtBQUNwRCxtQkFBbUIsbUJBQU8sQ0FBQyw2RUFBbUI7O0FBRTlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHFDQUFxQyxTQUFTO0FBQzlDO0FBQ0E7QUFDQTs7QUFFQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQixRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLFVBQVU7QUFDVjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2xpZW50Ly4uL3NlcnZlci9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvcXVlcnkvY2FzdCRleHByLmpzPzJhYWEiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBDYXN0RXJyb3IgPSByZXF1aXJlKCcuLi8uLi9lcnJvci9jYXN0Jyk7XG5jb25zdCBTdHJpY3RNb2RlRXJyb3IgPSByZXF1aXJlKCcuLi8uLi9lcnJvci9zdHJpY3QnKTtcbmNvbnN0IGNhc3ROdW1iZXIgPSByZXF1aXJlKCcuLi8uLi9jYXN0L251bWJlcicpO1xuXG5jb25zdCBib29sZWFuQ29tcGFyaXNvbiA9IG5ldyBTZXQoWyckYW5kJywgJyRvciddKTtcbmNvbnN0IGNvbXBhcmlzb25PcGVyYXRvciA9IG5ldyBTZXQoWyckY21wJywgJyRlcScsICckbHQnLCAnJGx0ZScsICckZ3QnLCAnJGd0ZSddKTtcbmNvbnN0IGFyaXRobWV0aWNPcGVyYXRvckFycmF5ID0gbmV3IFNldChbXG4gIC8vIGF2b2lkIGNhc3RpbmcgJyRhZGQnIG9yICckc3VidHJhY3QnLCBiZWNhdXNlIGV4cHJlc3Npb25zIGNhbiBiZSBlaXRoZXIgbnVtYmVyIG9yIGRhdGUsXG4gIC8vIGFuZCB3ZSBkb24ndCBoYXZlIGEgZ29vZCB3YXkgb2YgaW5mZXJyaW5nIHdoaWNoIGFyZ3VtZW50cyBzaG91bGQgYmUgbnVtYmVycyBhbmQgd2hpY2ggc2hvdWxkXG4gIC8vIGJlIGRhdGVzLlxuICAnJG11bHRpcGx5JyxcbiAgJyRkaXZpZGUnLFxuICAnJGxvZycsXG4gICckbW9kJyxcbiAgJyR0cnVuYycsXG4gICckYXZnJyxcbiAgJyRtYXgnLFxuICAnJG1pbicsXG4gICckc3RkRGV2UG9wJyxcbiAgJyRzdGREZXZTYW1wJyxcbiAgJyRzdW0nXG5dKTtcbmNvbnN0IGFyaXRobWV0aWNPcGVyYXRvck51bWJlciA9IG5ldyBTZXQoW1xuICAnJGFicycsXG4gICckZXhwJyxcbiAgJyRjZWlsJyxcbiAgJyRmbG9vcicsXG4gICckbG4nLFxuICAnJGxvZzEwJyxcbiAgJyRzcXJ0JyxcbiAgJyRzaW4nLFxuICAnJGNvcycsXG4gICckdGFuJyxcbiAgJyRhc2luJyxcbiAgJyRhY29zJyxcbiAgJyRhdGFuJyxcbiAgJyRhdGFuMicsXG4gICckYXNpbmgnLFxuICAnJGFjb3NoJyxcbiAgJyRhdGFuaCcsXG4gICckc2luaCcsXG4gICckY29zaCcsXG4gICckdGFuaCcsXG4gICckZGVncmVlc1RvUmFkaWFucycsXG4gICckcmFkaWFuc1RvRGVncmVlcydcbl0pO1xuY29uc3QgYXJyYXlFbGVtZW50T3BlcmF0b3JzID0gbmV3IFNldChbXG4gICckYXJyYXlFbGVtQXQnLFxuICAnJGZpcnN0JyxcbiAgJyRsYXN0J1xuXSk7XG5jb25zdCBkYXRlT3BlcmF0b3JzID0gbmV3IFNldChbXG4gICckeWVhcicsXG4gICckbW9udGgnLFxuICAnJHdlZWsnLFxuICAnJGRheU9mTW9udGgnLFxuICAnJGRheU9mWWVhcicsXG4gICckaG91cicsXG4gICckbWludXRlJyxcbiAgJyRzZWNvbmQnLFxuICAnJGlzb0RheU9mV2VlaycsXG4gICckaXNvV2Vla1llYXInLFxuICAnJGlzb1dlZWsnLFxuICAnJG1pbGxpc2Vjb25kJ1xuXSk7XG5jb25zdCBleHByZXNzaW9uT3BlcmF0b3IgPSBuZXcgU2V0KFsnJG5vdCddKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBjYXN0JGV4cHIodmFsLCBzY2hlbWEsIHN0cmljdFF1ZXJ5KSB7XG4gIGlmICh0eXBlb2YgdmFsICE9PSAnb2JqZWN0JyB8fCB2YWwgPT09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2AkZXhwcmAgbXVzdCBiZSBhbiBvYmplY3QnKTtcbiAgfVxuXG4gIHJldHVybiBfY2FzdEV4cHJlc3Npb24odmFsLCBzY2hlbWEsIHN0cmljdFF1ZXJ5KTtcbn07XG5cbmZ1bmN0aW9uIF9jYXN0RXhwcmVzc2lvbih2YWwsIHNjaGVtYSwgc3RyaWN0UXVlcnkpIHtcbiAgLy8gUHJlc2VydmUgdGhlIHZhbHVlIGlmIGl0IHJlcHJlc2VudHMgYSBwYXRoIG9yIGlmIGl0J3MgbnVsbFxuICBpZiAoaXNQYXRoKHZhbCkgfHwgdmFsID09PSBudWxsKSB7XG4gICAgcmV0dXJuIHZhbDtcbiAgfVxuXG4gIGlmICh2YWwuJGNvbmQgIT0gbnVsbCkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbC4kY29uZCkpIHtcbiAgICAgIHZhbC4kY29uZCA9IHZhbC4kY29uZC5tYXAoZXhwciA9PiBfY2FzdEV4cHJlc3Npb24oZXhwciwgc2NoZW1hLCBzdHJpY3RRdWVyeSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWwuJGNvbmQuaWYgPSBfY2FzdEV4cHJlc3Npb24odmFsLiRjb25kLmlmLCBzY2hlbWEsIHN0cmljdFF1ZXJ5KTtcbiAgICAgIHZhbC4kY29uZC50aGVuID0gX2Nhc3RFeHByZXNzaW9uKHZhbC4kY29uZC50aGVuLCBzY2hlbWEsIHN0cmljdFF1ZXJ5KTtcbiAgICAgIHZhbC4kY29uZC5lbHNlID0gX2Nhc3RFeHByZXNzaW9uKHZhbC4kY29uZC5lbHNlLCBzY2hlbWEsIHN0cmljdFF1ZXJ5KTtcbiAgICB9XG4gIH0gZWxzZSBpZiAodmFsLiRpZk51bGwgIT0gbnVsbCkge1xuICAgIHZhbC4kaWZOdWxsLm1hcCh2ID0+IF9jYXN0RXhwcmVzc2lvbih2LCBzY2hlbWEsIHN0cmljdFF1ZXJ5KSk7XG4gIH0gZWxzZSBpZiAodmFsLiRzd2l0Y2ggIT0gbnVsbCkge1xuICAgIHZhbC5icmFuY2hlcy5tYXAodiA9PiBfY2FzdEV4cHJlc3Npb24odiwgc2NoZW1hLCBzdHJpY3RRdWVyeSkpO1xuICAgIHZhbC5kZWZhdWx0ID0gX2Nhc3RFeHByZXNzaW9uKHZhbC5kZWZhdWx0LCBzY2hlbWEsIHN0cmljdFF1ZXJ5KTtcbiAgfVxuXG4gIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyh2YWwpO1xuICBmb3IgKGNvbnN0IGtleSBvZiBrZXlzKSB7XG4gICAgaWYgKGJvb2xlYW5Db21wYXJpc29uLmhhcyhrZXkpKSB7XG4gICAgICB2YWxba2V5XSA9IHZhbFtrZXldLm1hcCh2ID0+IF9jYXN0RXhwcmVzc2lvbih2LCBzY2hlbWEsIHN0cmljdFF1ZXJ5KSk7XG4gICAgfSBlbHNlIGlmIChjb21wYXJpc29uT3BlcmF0b3IuaGFzKGtleSkpIHtcbiAgICAgIHZhbFtrZXldID0gY2FzdENvbXBhcmlzb24odmFsW2tleV0sIHNjaGVtYSwgc3RyaWN0UXVlcnkpO1xuICAgIH0gZWxzZSBpZiAoYXJpdGhtZXRpY09wZXJhdG9yQXJyYXkuaGFzKGtleSkpIHtcbiAgICAgIHZhbFtrZXldID0gY2FzdEFyaXRobWV0aWModmFsW2tleV0sIHNjaGVtYSwgc3RyaWN0UXVlcnkpO1xuICAgIH0gZWxzZSBpZiAoYXJpdGhtZXRpY09wZXJhdG9yTnVtYmVyLmhhcyhrZXkpKSB7XG4gICAgICB2YWxba2V5XSA9IGNhc3ROdW1iZXJPcGVyYXRvcih2YWxba2V5XSwgc2NoZW1hLCBzdHJpY3RRdWVyeSk7XG4gICAgfSBlbHNlIGlmIChleHByZXNzaW9uT3BlcmF0b3IuaGFzKGtleSkpIHtcbiAgICAgIHZhbFtrZXldID0gX2Nhc3RFeHByZXNzaW9uKHZhbFtrZXldLCBzY2hlbWEsIHN0cmljdFF1ZXJ5KTtcbiAgICB9XG4gIH1cblxuICBpZiAodmFsLiRpbikge1xuICAgIHZhbC4kaW4gPSBjYXN0SW4odmFsLiRpbiwgc2NoZW1hLCBzdHJpY3RRdWVyeSk7XG4gIH1cbiAgaWYgKHZhbC4kc2l6ZSkge1xuICAgIHZhbC4kc2l6ZSA9IGNhc3ROdW1iZXJPcGVyYXRvcih2YWwuJHNpemUsIHNjaGVtYSwgc3RyaWN0UXVlcnkpO1xuICB9XG4gIGlmICh2YWwuJHJvdW5kKSB7XG4gICAgY29uc3QgJHJvdW5kID0gdmFsLiRyb3VuZDtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoJHJvdW5kKSB8fCAkcm91bmQubGVuZ3RoIDwgMSB8fCAkcm91bmQubGVuZ3RoID4gMikge1xuICAgICAgdGhyb3cgbmV3IENhc3RFcnJvcignQXJyYXknLCAkcm91bmQsICckcm91bmQnKTtcbiAgICB9XG4gICAgdmFsLiRyb3VuZCA9ICRyb3VuZC5tYXAodiA9PiBjYXN0TnVtYmVyT3BlcmF0b3Iodiwgc2NoZW1hLCBzdHJpY3RRdWVyeSkpO1xuICB9XG5cbiAgX29taXRVbmRlZmluZWQodmFsKTtcblxuICByZXR1cm4gdmFsO1xufVxuXG5mdW5jdGlvbiBfb21pdFVuZGVmaW5lZCh2YWwpIHtcbiAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHZhbCk7XG4gIGZvciAobGV0IGkgPSAwLCBsZW4gPSBrZXlzLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgKHZhbFtrZXlzW2ldXSA9PT0gdm9pZCAwKSAmJiBkZWxldGUgdmFsW2tleXNbaV1dO1xuICB9XG59XG5cbi8vIHsgJG9wOiA8bnVtYmVyPiB9XG5mdW5jdGlvbiBjYXN0TnVtYmVyT3BlcmF0b3IodmFsKSB7XG4gIGlmICghaXNMaXRlcmFsKHZhbCkpIHtcbiAgICByZXR1cm4gdmFsO1xuICB9XG5cbiAgdHJ5IHtcbiAgICByZXR1cm4gY2FzdE51bWJlcih2YWwpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICB0aHJvdyBuZXcgQ2FzdEVycm9yKCdOdW1iZXInLCB2YWwpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNhc3RJbih2YWwsIHNjaGVtYSwgc3RyaWN0UXVlcnkpIHtcbiAgY29uc3QgcGF0aCA9IHZhbFsxXTtcbiAgaWYgKCFpc1BhdGgocGF0aCkpIHtcbiAgICByZXR1cm4gdmFsO1xuICB9XG4gIGNvbnN0IHNlYXJjaCA9IHZhbFswXTtcblxuICBjb25zdCBzY2hlbWF0eXBlID0gc2NoZW1hLnBhdGgocGF0aC5zbGljZSgxKSk7XG4gIGlmIChzY2hlbWF0eXBlID09PSBudWxsKSB7XG4gICAgaWYgKHN0cmljdFF1ZXJ5ID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuIHZhbDtcbiAgICB9IGVsc2UgaWYgKHN0cmljdFF1ZXJ5ID09PSAndGhyb3cnKSB7XG4gICAgICB0aHJvdyBuZXcgU3RyaWN0TW9kZUVycm9yKCckaW4nKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG5cbiAgaWYgKCFzY2hlbWF0eXBlLiRpc01vbmdvb3NlQXJyYXkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1BhdGggbXVzdCBiZSBhbiBhcnJheSBmb3IgJGluJyk7XG4gIH1cblxuICByZXR1cm4gW1xuICAgIHNjaGVtYXR5cGUuJGlzTW9uZ29vc2VEb2N1bWVudEFycmF5ID8gc2NoZW1hdHlwZS4kZW1iZWRkZWRTY2hlbWFUeXBlLmNhc3Qoc2VhcmNoKSA6IHNjaGVtYXR5cGUuY2FzdGVyLmNhc3Qoc2VhcmNoKSxcbiAgICBwYXRoXG4gIF07XG59XG5cbi8vIHsgJG9wOiBbPG51bWJlcj4sIDxudW1iZXI+XSB9XG5mdW5jdGlvbiBjYXN0QXJpdGhtZXRpYyh2YWwpIHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KHZhbCkpIHtcbiAgICBpZiAoIWlzTGl0ZXJhbCh2YWwpKSB7XG4gICAgICByZXR1cm4gdmFsO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGNhc3ROdW1iZXIodmFsKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHRocm93IG5ldyBDYXN0RXJyb3IoJ051bWJlcicsIHZhbCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHZhbC5tYXAodiA9PiB7XG4gICAgaWYgKCFpc0xpdGVyYWwodikpIHtcbiAgICAgIHJldHVybiB2O1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGNhc3ROdW1iZXIodik7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICB0aHJvdyBuZXcgQ2FzdEVycm9yKCdOdW1iZXInLCB2KTtcbiAgICB9XG4gIH0pO1xufVxuXG4vLyB7ICRvcDogW2V4cHJlc3Npb24sIGV4cHJlc3Npb25dIH1cbmZ1bmN0aW9uIGNhc3RDb21wYXJpc29uKHZhbCwgc2NoZW1hLCBzdHJpY3RRdWVyeSkge1xuICBpZiAoIUFycmF5LmlzQXJyYXkodmFsKSB8fCB2YWwubGVuZ3RoICE9PSAyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdDb21wYXJpc29uIG9wZXJhdG9yIG11c3QgYmUgYW4gYXJyYXkgb2YgbGVuZ3RoIDInKTtcbiAgfVxuXG4gIHZhbFswXSA9IF9jYXN0RXhwcmVzc2lvbih2YWxbMF0sIHNjaGVtYSwgc3RyaWN0UXVlcnkpO1xuICBjb25zdCBsaHMgPSB2YWxbMF07XG5cbiAgaWYgKGlzTGl0ZXJhbCh2YWxbMV0pKSB7XG4gICAgbGV0IHBhdGggPSBudWxsO1xuICAgIGxldCBzY2hlbWF0eXBlID0gbnVsbDtcbiAgICBsZXQgY2FzdGVyID0gbnVsbDtcbiAgICBpZiAoaXNQYXRoKGxocykpIHtcbiAgICAgIHBhdGggPSBsaHMuc2xpY2UoMSk7XG4gICAgICBzY2hlbWF0eXBlID0gc2NoZW1hLnBhdGgocGF0aCk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgbGhzID09PSAnb2JqZWN0JyAmJiBsaHMgIT0gbnVsbCkge1xuICAgICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMobGhzKSkge1xuICAgICAgICBpZiAoZGF0ZU9wZXJhdG9ycy5oYXMoa2V5KSAmJiBpc1BhdGgobGhzW2tleV0pKSB7XG4gICAgICAgICAgcGF0aCA9IGxoc1trZXldLnNsaWNlKDEpICsgJy4nICsga2V5O1xuICAgICAgICAgIGNhc3RlciA9IGNhc3ROdW1iZXI7XG4gICAgICAgIH0gZWxzZSBpZiAoYXJyYXlFbGVtZW50T3BlcmF0b3JzLmhhcyhrZXkpICYmIGlzUGF0aChsaHNba2V5XSkpIHtcbiAgICAgICAgICBwYXRoID0gbGhzW2tleV0uc2xpY2UoMSkgKyAnLicgKyBrZXk7XG4gICAgICAgICAgc2NoZW1hdHlwZSA9IHNjaGVtYS5wYXRoKGxoc1trZXldLnNsaWNlKDEpKTtcbiAgICAgICAgICBpZiAoc2NoZW1hdHlwZSAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAoc2NoZW1hdHlwZS4kaXNNb25nb29zZURvY3VtZW50QXJyYXkpIHtcbiAgICAgICAgICAgICAgc2NoZW1hdHlwZSA9IHNjaGVtYXR5cGUuJGVtYmVkZGVkU2NoZW1hVHlwZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc2NoZW1hdHlwZS4kaXNNb25nb29zZUFycmF5KSB7XG4gICAgICAgICAgICAgIHNjaGVtYXR5cGUgPSBzY2hlbWF0eXBlLmNhc3RlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBpcyRsaXRlcmFsID0gdHlwZW9mIHZhbFsxXSA9PT0gJ29iamVjdCcgJiYgdmFsWzFdICE9IG51bGwgJiYgdmFsWzFdLiRsaXRlcmFsICE9IG51bGw7XG4gICAgaWYgKHNjaGVtYXR5cGUgIT0gbnVsbCkge1xuICAgICAgaWYgKGlzJGxpdGVyYWwpIHtcbiAgICAgICAgdmFsWzFdID0geyAkbGl0ZXJhbDogc2NoZW1hdHlwZS5jYXN0KHZhbFsxXS4kbGl0ZXJhbCkgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhbFsxXSA9IHNjaGVtYXR5cGUuY2FzdCh2YWxbMV0pO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoY2FzdGVyICE9IG51bGwpIHtcbiAgICAgIGlmIChpcyRsaXRlcmFsKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdmFsWzFdID0geyAkbGl0ZXJhbDogY2FzdGVyKHZhbFsxXS4kbGl0ZXJhbCkgfTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IENhc3RFcnJvcihjYXN0ZXIubmFtZS5yZXBsYWNlKC9eY2FzdC8sICcnKSwgdmFsWzFdLCBwYXRoICsgJy4kbGl0ZXJhbCcpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHZhbFsxXSA9IGNhc3Rlcih2YWxbMV0pO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgQ2FzdEVycm9yKGNhc3Rlci5uYW1lLnJlcGxhY2UoL15jYXN0LywgJycpLCB2YWxbMV0sIHBhdGgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChwYXRoICE9IG51bGwgJiYgc3RyaWN0UXVlcnkgPT09IHRydWUpIHtcbiAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgfSBlbHNlIGlmIChwYXRoICE9IG51bGwgJiYgc3RyaWN0UXVlcnkgPT09ICd0aHJvdycpIHtcbiAgICAgIHRocm93IG5ldyBTdHJpY3RNb2RlRXJyb3IocGF0aCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhbFsxXSA9IF9jYXN0RXhwcmVzc2lvbih2YWxbMV0pO1xuICB9XG5cbiAgcmV0dXJuIHZhbDtcbn1cblxuZnVuY3Rpb24gaXNQYXRoKHZhbCkge1xuICByZXR1cm4gdHlwZW9mIHZhbCA9PT0gJ3N0cmluZycgJiYgdmFsWzBdID09PSAnJCc7XG59XG5cbmZ1bmN0aW9uIGlzTGl0ZXJhbCh2YWwpIHtcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnICYmIHZhbFswXSA9PT0gJyQnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmICh0eXBlb2YgdmFsID09PSAnb2JqZWN0JyAmJiB2YWwgIT09IG51bGwgJiYgT2JqZWN0LmtleXModmFsKS5maW5kKGtleSA9PiBrZXlbMF0gPT09ICckJykpIHtcbiAgICAvLyBUaGUgYCRsaXRlcmFsYCBleHByZXNzaW9uIGNhbiBtYWtlIGFuIG9iamVjdCBhIGxpdGVyYWxcbiAgICAvLyBodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9yZWZlcmVuY2Uvb3BlcmF0b3IvYWdncmVnYXRpb24vbGl0ZXJhbC8jbW9uZ29kYi1leHByZXNzaW9uLWV4cC4tbGl0ZXJhbFxuICAgIHJldHVybiB2YWwuJGxpdGVyYWwgIT0gbnVsbDtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../server/node_modules/mongoose/lib/helpers/query/cast$expr.js\n");

/***/ }),

/***/ "../server/node_modules/mongoose/lib/helpers/query/castFilterPath.js":
/*!***************************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/helpers/query/castFilterPath.js ***!
  \***************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst isOperator = __webpack_require__(/*! ./isOperator */ \"../server/node_modules/mongoose/lib/helpers/query/isOperator.js\");\n\nmodule.exports = function castFilterPath(ctx, schematype, val) {\n  const any$conditionals = Object.keys(val).some(isOperator);\n\n  if (!any$conditionals) {\n    return schematype.castForQuery(\n      null,\n      val,\n      ctx\n    );\n  }\n\n  const ks = Object.keys(val);\n\n  let k = ks.length;\n\n  while (k--) {\n    const $cond = ks[k];\n    const nested = val[$cond];\n\n    if ($cond === '$not') {\n      if (nested && schematype && !schematype.caster) {\n        const _keys = Object.keys(nested);\n        if (_keys.length && isOperator(_keys[0])) {\n          for (const key of Object.keys(nested)) {\n            nested[key] = schematype.castForQuery(\n              key,\n              nested[key],\n              ctx\n            );\n          }\n        } else {\n          val[$cond] = schematype.castForQuery(\n            $cond,\n            nested,\n            ctx\n          );\n        }\n        continue;\n      }\n    } else {\n      val[$cond] = schematype.castForQuery(\n        $cond,\n        nested,\n        ctx\n      );\n    }\n  }\n\n  return val;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9xdWVyeS9jYXN0RmlsdGVyUGF0aC5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixtQkFBbUIsbUJBQU8sQ0FBQyxxRkFBYzs7QUFFekM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbGllbnQvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9xdWVyeS9jYXN0RmlsdGVyUGF0aC5qcz9hZTg5Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3QgaXNPcGVyYXRvciA9IHJlcXVpcmUoJy4vaXNPcGVyYXRvcicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGNhc3RGaWx0ZXJQYXRoKGN0eCwgc2NoZW1hdHlwZSwgdmFsKSB7XG4gIGNvbnN0IGFueSRjb25kaXRpb25hbHMgPSBPYmplY3Qua2V5cyh2YWwpLnNvbWUoaXNPcGVyYXRvcik7XG5cbiAgaWYgKCFhbnkkY29uZGl0aW9uYWxzKSB7XG4gICAgcmV0dXJuIHNjaGVtYXR5cGUuY2FzdEZvclF1ZXJ5KFxuICAgICAgbnVsbCxcbiAgICAgIHZhbCxcbiAgICAgIGN0eFxuICAgICk7XG4gIH1cblxuICBjb25zdCBrcyA9IE9iamVjdC5rZXlzKHZhbCk7XG5cbiAgbGV0IGsgPSBrcy5sZW5ndGg7XG5cbiAgd2hpbGUgKGstLSkge1xuICAgIGNvbnN0ICRjb25kID0ga3Nba107XG4gICAgY29uc3QgbmVzdGVkID0gdmFsWyRjb25kXTtcblxuICAgIGlmICgkY29uZCA9PT0gJyRub3QnKSB7XG4gICAgICBpZiAobmVzdGVkICYmIHNjaGVtYXR5cGUgJiYgIXNjaGVtYXR5cGUuY2FzdGVyKSB7XG4gICAgICAgIGNvbnN0IF9rZXlzID0gT2JqZWN0LmtleXMobmVzdGVkKTtcbiAgICAgICAgaWYgKF9rZXlzLmxlbmd0aCAmJiBpc09wZXJhdG9yKF9rZXlzWzBdKSkge1xuICAgICAgICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKG5lc3RlZCkpIHtcbiAgICAgICAgICAgIG5lc3RlZFtrZXldID0gc2NoZW1hdHlwZS5jYXN0Rm9yUXVlcnkoXG4gICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICAgbmVzdGVkW2tleV0sXG4gICAgICAgICAgICAgIGN0eFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFsWyRjb25kXSA9IHNjaGVtYXR5cGUuY2FzdEZvclF1ZXJ5KFxuICAgICAgICAgICAgJGNvbmQsXG4gICAgICAgICAgICBuZXN0ZWQsXG4gICAgICAgICAgICBjdHhcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2YWxbJGNvbmRdID0gc2NoZW1hdHlwZS5jYXN0Rm9yUXVlcnkoXG4gICAgICAgICRjb25kLFxuICAgICAgICBuZXN0ZWQsXG4gICAgICAgIGN0eFxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdmFsO1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../server/node_modules/mongoose/lib/helpers/query/castFilterPath.js\n");

/***/ }),

/***/ "../server/node_modules/mongoose/lib/helpers/query/castUpdate.js":
/*!***********************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/helpers/query/castUpdate.js ***!
  \***********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst CastError = __webpack_require__(/*! ../../error/cast */ \"../server/node_modules/mongoose/lib/error/cast.js\");\nconst MongooseError = __webpack_require__(/*! ../../error/mongooseError */ \"../server/node_modules/mongoose/lib/error/mongooseError.js\");\nconst StrictModeError = __webpack_require__(/*! ../../error/strict */ \"../server/node_modules/mongoose/lib/error/strict.js\");\nconst ValidationError = __webpack_require__(/*! ../../error/validation */ \"../server/node_modules/mongoose/lib/error/validation.js\");\nconst castNumber = __webpack_require__(/*! ../../cast/number */ \"../server/node_modules/mongoose/lib/cast/number.js\");\nconst cast = __webpack_require__(/*! ../../cast */ \"../server/node_modules/mongoose/lib/cast.js\");\nconst getConstructorName = __webpack_require__(/*! ../getConstructorName */ \"../server/node_modules/mongoose/lib/helpers/getConstructorName.js\");\nconst getEmbeddedDiscriminatorPath = __webpack_require__(/*! ./getEmbeddedDiscriminatorPath */ \"../server/node_modules/mongoose/lib/helpers/query/getEmbeddedDiscriminatorPath.js\");\nconst handleImmutable = __webpack_require__(/*! ./handleImmutable */ \"../server/node_modules/mongoose/lib/helpers/query/handleImmutable.js\");\nconst moveImmutableProperties = __webpack_require__(/*! ../update/moveImmutableProperties */ \"../server/node_modules/mongoose/lib/helpers/update/moveImmutableProperties.js\");\nconst schemaMixedSymbol = (__webpack_require__(/*! ../../schema/symbols */ \"../server/node_modules/mongoose/lib/schema/symbols.js\").schemaMixedSymbol);\nconst setDottedPath = __webpack_require__(/*! ../path/setDottedPath */ \"../server/node_modules/mongoose/lib/helpers/path/setDottedPath.js\");\nconst utils = __webpack_require__(/*! ../../utils */ \"../server/node_modules/mongoose/lib/utils.js\");\nconst { internalToObjectOptions } = __webpack_require__(/*! ../../options */ \"../server/node_modules/mongoose/lib/options.js\");\n\nconst mongodbUpdateOperators = new Set([\n  '$currentDate',\n  '$inc',\n  '$min',\n  '$max',\n  '$mul',\n  '$rename',\n  '$set',\n  '$setOnInsert',\n  '$unset',\n  '$addToSet',\n  '$pop',\n  '$pull',\n  '$push',\n  '$pullAll',\n  '$bit'\n]);\n\n/**\n * Casts an update op based on the given schema\n *\n * @param {Schema} schema\n * @param {Object} obj\n * @param {Object} [options]\n * @param {Boolean|String} [options.strict] defaults to true\n * @param {Query} context passed to setters\n * @return {Boolean} true iff the update is non-empty\n * @api private\n */\nmodule.exports = function castUpdate(schema, obj, options, context, filter) {\n  if (obj == null) {\n    return undefined;\n  }\n  options = options || {};\n  // Update pipeline\n  if (Array.isArray(obj)) {\n    const len = obj.length;\n    for (let i = 0; i < len; ++i) {\n      const ops = Object.keys(obj[i]);\n      for (const op of ops) {\n        obj[i][op] = castPipelineOperator(op, obj[i][op]);\n      }\n    }\n    return obj;\n  }\n\n  if (options.upsert) {\n    moveImmutableProperties(schema, obj, context);\n  }\n\n  const ops = Object.keys(obj);\n  let i = ops.length;\n  const ret = {};\n  let val;\n  let hasDollarKey = false;\n\n  filter = filter || {};\n  while (i--) {\n    const op = ops[i];\n    if (!mongodbUpdateOperators.has(op)) {\n      // fix up $set sugar\n      if (!ret.$set) {\n        if (obj.$set) {\n          ret.$set = obj.$set;\n        } else {\n          ret.$set = {};\n        }\n      }\n      ret.$set[op] = obj[op];\n      ops.splice(i, 1);\n      if (!~ops.indexOf('$set')) ops.push('$set');\n    } else if (op === '$set') {\n      if (!ret.$set) {\n        ret[op] = obj[op];\n      }\n    } else {\n      ret[op] = obj[op];\n    }\n  }\n  // cast each value\n  i = ops.length;\n  while (i--) {\n    const op = ops[i];\n    val = ret[op];\n    hasDollarKey = hasDollarKey || op.startsWith('$');\n    if (val != null && val.$__) {\n      val = val.toObject(internalToObjectOptions);\n      ret[op] = val;\n    }\n    if (val &&\n        typeof val === 'object' &&\n        !Buffer.isBuffer(val) &&\n        mongodbUpdateOperators.has(op)) {\n      walkUpdatePath(schema, val, op, options, context, filter);\n    } else {\n      const msg = 'Invalid atomic update value for ' + op + '. '\n          + 'Expected an object, received ' + typeof val;\n      throw new Error(msg);\n    }\n\n    if (op.startsWith('$') && utils.isEmptyObject(val)) {\n      delete ret[op];\n    }\n  }\n\n  if (Object.keys(ret).length === 0 &&\n      options.upsert &&\n      Object.keys(filter).length > 0) {\n    // Trick the driver into allowing empty upserts to work around\n    // https://github.com/mongodb/node-mongodb-native/pull/2490\n    // Shallow clone to avoid passing defaults in re: gh-13962\n    return { $setOnInsert: { ...filter } };\n  }\n  return ret;\n};\n\n/*!\n * ignore\n */\n\nfunction castPipelineOperator(op, val) {\n  if (op === '$unset') {\n    if (typeof val !== 'string' && (!Array.isArray(val) || val.find(v => typeof v !== 'string'))) {\n      throw new MongooseError('Invalid $unset in pipeline, must be ' +\n        ' a string or an array of strings');\n    }\n    return val;\n  }\n  if (op === '$project') {\n    if (val == null || typeof val !== 'object') {\n      throw new MongooseError('Invalid $project in pipeline, must be an object');\n    }\n    return val;\n  }\n  if (op === '$addFields' || op === '$set') {\n    if (val == null || typeof val !== 'object') {\n      throw new MongooseError('Invalid ' + op + ' in pipeline, must be an object');\n    }\n    return val;\n  } else if (op === '$replaceRoot' || op === '$replaceWith') {\n    if (val == null || typeof val !== 'object') {\n      throw new MongooseError('Invalid ' + op + ' in pipeline, must be an object');\n    }\n    return val;\n  }\n\n  throw new MongooseError('Invalid update pipeline operator: \"' + op + '\"');\n}\n\n/**\n * Walk each path of obj and cast its values\n * according to its schema.\n *\n * @param {Schema} schema\n * @param {Object} obj part of a query\n * @param {String} op the atomic operator ($pull, $set, etc)\n * @param {Object} [options]\n * @param {Boolean|String} [options.strict]\n * @param {Query} context\n * @param {Object} filter\n * @param {String} pref path prefix (internal only)\n * @return {Bool} true if this path has keys to update\n * @api private\n */\n\nfunction walkUpdatePath(schema, obj, op, options, context, filter, pref) {\n  const strict = options.strict;\n  const prefix = pref ? pref + '.' : '';\n  const keys = Object.keys(obj);\n  let i = keys.length;\n  let hasKeys = false;\n  let schematype;\n  let key;\n  let val;\n\n  let aggregatedError = null;\n\n  const strictMode = strict != null ? strict : schema.options.strict;\n\n  while (i--) {\n    key = keys[i];\n    val = obj[key];\n\n    // `$pull` is special because we need to cast the RHS as a query, not as\n    // an update.\n    if (op === '$pull') {\n      schematype = schema._getSchema(prefix + key);\n      if (schematype != null && schematype.schema != null) {\n        obj[key] = cast(schematype.schema, obj[key], options, context);\n        hasKeys = true;\n        continue;\n      }\n    }\n\n    const discriminatorKey = (prefix ? prefix + key : key);\n    if (\n      schema.discriminatorMapping != null &&\n      discriminatorKey === schema.options.discriminatorKey &&\n      schema.discriminatorMapping.value !== obj[key] &&\n      !options.overwriteDiscriminatorKey\n    ) {\n      if (strictMode === 'throw') {\n        const err = new Error('Can\\'t modify discriminator key \"' + discriminatorKey + '\" on discriminator model');\n        aggregatedError = _appendError(err, context, discriminatorKey, aggregatedError);\n        continue;\n      } else if (strictMode) {\n        delete obj[key];\n        continue;\n      }\n    }\n\n    if (getConstructorName(val) === 'Object') {\n      // watch for embedded doc schemas\n      schematype = schema._getSchema(prefix + key);\n\n      if (schematype == null) {\n        const _res = getEmbeddedDiscriminatorPath(schema, obj, filter, prefix + key, options);\n        if (_res.schematype != null) {\n          schematype = _res.schematype;\n        }\n      }\n\n      if (op !== '$setOnInsert' &&\n          handleImmutable(schematype, strict, obj, key, prefix + key, context)) {\n        continue;\n      }\n\n      if (schematype && schematype.caster && op in castOps) {\n        // embedded doc schema\n        if ('$each' in val) {\n          hasKeys = true;\n          try {\n            obj[key] = {\n              $each: castUpdateVal(schematype, val.$each, op, key, context, prefix + key)\n            };\n          } catch (error) {\n            aggregatedError = _appendError(error, context, key, aggregatedError);\n          }\n\n          if (val.$slice != null) {\n            obj[key].$slice = val.$slice | 0;\n          }\n\n          if (val.$sort) {\n            obj[key].$sort = val.$sort;\n          }\n\n          if (val.$position != null) {\n            obj[key].$position = castNumber(val.$position);\n          }\n        } else {\n          if (schematype != null && schematype.$isSingleNested) {\n            const _strict = strict == null ? schematype.schema.options.strict : strict;\n            try {\n              obj[key] = schematype.castForQuery(null, val, context, { strict: _strict });\n            } catch (error) {\n              aggregatedError = _appendError(error, context, key, aggregatedError);\n            }\n          } else {\n            try {\n              obj[key] = castUpdateVal(schematype, val, op, key, context, prefix + key);\n            } catch (error) {\n              aggregatedError = _appendError(error, context, key, aggregatedError);\n            }\n          }\n\n          if (obj[key] === void 0) {\n            delete obj[key];\n            continue;\n          }\n\n          hasKeys = true;\n        }\n      } else if ((op === '$currentDate') || (op in castOps && schematype)) {\n        // $currentDate can take an object\n        try {\n          obj[key] = castUpdateVal(schematype, val, op, key, context, prefix + key);\n        } catch (error) {\n          aggregatedError = _appendError(error, context, key, aggregatedError);\n        }\n\n        if (obj[key] === void 0) {\n          delete obj[key];\n          continue;\n        }\n\n        hasKeys = true;\n      } else {\n        const pathToCheck = (prefix + key);\n        const v = schema._getPathType(pathToCheck);\n        let _strict = strict;\n        if (v && v.schema && _strict == null) {\n          _strict = v.schema.options.strict;\n        }\n\n        if (v.pathType === 'undefined') {\n          if (_strict === 'throw') {\n            throw new StrictModeError(pathToCheck);\n          } else if (_strict) {\n            delete obj[key];\n            continue;\n          }\n        }\n\n        // gh-2314\n        // we should be able to set a schema-less field\n        // to an empty object literal\n        hasKeys |= walkUpdatePath(schema, val, op, options, context, filter, prefix + key) ||\n          (utils.isObject(val) && Object.keys(val).length === 0);\n      }\n    } else {\n      const checkPath = (key === '$each' || key === '$or' || key === '$and' || key === '$in') ?\n        pref : prefix + key;\n      schematype = schema._getSchema(checkPath);\n\n      // You can use `$setOnInsert` with immutable keys\n      if (op !== '$setOnInsert' &&\n          handleImmutable(schematype, strict, obj, key, prefix + key, context)) {\n        continue;\n      }\n\n      let pathDetails = schema._getPathType(checkPath);\n\n      // If no schema type, check for embedded discriminators because the\n      // filter or update may imply an embedded discriminator type. See #8378\n      if (schematype == null) {\n        const _res = getEmbeddedDiscriminatorPath(schema, obj, filter, checkPath, options);\n        if (_res.schematype != null) {\n          schematype = _res.schematype;\n          pathDetails = _res.type;\n        }\n      }\n\n      let isStrict = strict;\n      if (pathDetails && pathDetails.schema && strict == null) {\n        isStrict = pathDetails.schema.options.strict;\n      }\n\n      const skip = isStrict &&\n        !schematype &&\n        !/real|nested/.test(pathDetails.pathType);\n\n      if (skip) {\n        // Even if strict is `throw`, avoid throwing an error because of\n        // virtuals because of #6731\n        if (isStrict === 'throw' && schema.virtuals[checkPath] == null) {\n          throw new StrictModeError(prefix + key);\n        } else {\n          delete obj[key];\n        }\n      } else {\n        // gh-1845 temporary fix: ignore $rename. See gh-3027 for tracking\n        // improving this.\n        if (op === '$rename') {\n          hasKeys = true;\n          continue;\n        }\n\n        try {\n          if (prefix.length === 0 || key.indexOf('.') === -1) {\n            obj[key] = castUpdateVal(schematype, val, op, key, context, prefix + key);\n          } else if (isStrict !== false || schematype != null) {\n            // Setting a nested dotted path that's in the schema. We don't allow paths with '.' in\n            // a schema, so replace the dotted path with a nested object to avoid ending up with\n            // dotted properties in the updated object. See (gh-10200)\n            setDottedPath(obj, key, castUpdateVal(schematype, val, op, key, context, prefix + key));\n            delete obj[key];\n          }\n        } catch (error) {\n          aggregatedError = _appendError(error, context, key, aggregatedError);\n        }\n\n        if (Array.isArray(obj[key]) && (op === '$addToSet' || op === '$push') && key !== '$each') {\n          if (schematype &&\n              schematype.caster &&\n              !schematype.caster.$isMongooseArray &&\n              !schematype.caster[schemaMixedSymbol]) {\n            obj[key] = { $each: obj[key] };\n          }\n        }\n\n        if (obj[key] === void 0) {\n          delete obj[key];\n          continue;\n        }\n\n        hasKeys = true;\n      }\n    }\n  }\n\n  if (aggregatedError != null) {\n    throw aggregatedError;\n  }\n\n  return hasKeys;\n}\n\n/*!\n * ignore\n */\n\nfunction _appendError(error, query, key, aggregatedError) {\n  if (typeof query !== 'object' || !query.options.multipleCastError) {\n    throw error;\n  }\n  aggregatedError = aggregatedError || new ValidationError();\n  aggregatedError.addError(key, error);\n  return aggregatedError;\n}\n\n/**\n * These operators should be cast to numbers instead\n * of their path schema type.\n * @api private\n */\n\nconst numberOps = {\n  $pop: 1,\n  $inc: 1\n};\n\n/**\n * These ops require no casting because the RHS doesn't do anything.\n * @api private\n */\n\nconst noCastOps = {\n  $unset: 1\n};\n\n/**\n * These operators require casting docs\n * to real Documents for Update operations.\n * @api private\n */\n\nconst castOps = {\n  $push: 1,\n  $addToSet: 1,\n  $set: 1,\n  $setOnInsert: 1\n};\n\n/*!\n * ignore\n */\n\nconst overwriteOps = {\n  $set: 1,\n  $setOnInsert: 1\n};\n\n/**\n * Casts `val` according to `schema` and atomic `op`.\n *\n * @param {SchemaType} schema\n * @param {Object} val\n * @param {String} op the atomic operator ($pull, $set, etc)\n * @param {String} $conditional\n * @param {Query} context\n * @param {String} path\n * @api private\n */\n\nfunction castUpdateVal(schema, val, op, $conditional, context, path) {\n  if (!schema) {\n    // non-existing schema path\n    if (op in numberOps) {\n      try {\n        return castNumber(val);\n      } catch (err) {\n        throw new CastError('number', val, path);\n      }\n    }\n    return val;\n  }\n\n  // console.log('CastUpdateVal', path, op, val, schema);\n\n  const cond = schema.caster && op in castOps &&\n      (utils.isObject(val) || Array.isArray(val));\n  if (cond && !overwriteOps[op]) {\n    // Cast values for ops that add data to MongoDB.\n    // Ensures embedded documents get ObjectIds etc.\n    let schemaArrayDepth = 0;\n    let cur = schema;\n    while (cur.$isMongooseArray) {\n      ++schemaArrayDepth;\n      cur = cur.caster;\n    }\n    let arrayDepth = 0;\n    let _val = val;\n    while (Array.isArray(_val)) {\n      ++arrayDepth;\n      _val = _val[0];\n    }\n\n    const additionalNesting = schemaArrayDepth - arrayDepth;\n    while (arrayDepth < schemaArrayDepth) {\n      val = [val];\n      ++arrayDepth;\n    }\n\n    let tmp = schema.applySetters(Array.isArray(val) ? val : [val], context);\n\n    for (let i = 0; i < additionalNesting; ++i) {\n      tmp = tmp[0];\n    }\n    return tmp;\n  }\n\n  if (op in noCastOps) {\n    return val;\n  }\n  if (op in numberOps) {\n    // Null and undefined not allowed for $pop, $inc\n    if (val == null) {\n      throw new CastError('number', val, schema.path);\n    }\n    if (op === '$inc') {\n      // Support `$inc` with long, int32, etc. (gh-4283)\n      return schema.castForQuery(\n        null,\n        val,\n        context\n      );\n    }\n    try {\n      return castNumber(val);\n    } catch (error) {\n      throw new CastError('number', val, schema.path);\n    }\n  }\n  if (op === '$currentDate') {\n    if (typeof val === 'object') {\n      return { $type: val.$type };\n    }\n    return Boolean(val);\n  }\n\n  if (mongodbUpdateOperators.has($conditional)) {\n    return schema.castForQuery(\n      $conditional,\n      val,\n      context\n    );\n  }\n\n  if (overwriteOps[op]) {\n    const skipQueryCastForUpdate = val != null && schema.$isMongooseArray && schema.$fullPath != null && !schema.$fullPath.match(/\\d+$/);\n    const applySetters = schema[schemaMixedSymbol] != null;\n    if (skipQueryCastForUpdate || applySetters) {\n      return schema.applySetters(val, context);\n    }\n    return schema.castForQuery(\n      null,\n      val,\n      context\n    );\n  }\n\n  return schema.castForQuery(null, val, context);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9xdWVyeS9jYXN0VXBkYXRlLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLGtCQUFrQixtQkFBTyxDQUFDLDJFQUFrQjtBQUM1QyxzQkFBc0IsbUJBQU8sQ0FBQyw2RkFBMkI7QUFDekQsd0JBQXdCLG1CQUFPLENBQUMsK0VBQW9CO0FBQ3BELHdCQUF3QixtQkFBTyxDQUFDLHVGQUF3QjtBQUN4RCxtQkFBbUIsbUJBQU8sQ0FBQyw2RUFBbUI7QUFDOUMsYUFBYSxtQkFBTyxDQUFDLCtEQUFZO0FBQ2pDLDJCQUEyQixtQkFBTyxDQUFDLGdHQUF1QjtBQUMxRCxxQ0FBcUMsbUJBQU8sQ0FBQyx5SEFBZ0M7QUFDN0Usd0JBQXdCLG1CQUFPLENBQUMsK0ZBQW1CO0FBQ25ELGdDQUFnQyxtQkFBTyxDQUFDLHdIQUFtQztBQUMzRSwwQkFBMEIsNEhBQWlEO0FBQzNFLHNCQUFzQixtQkFBTyxDQUFDLGdHQUF1QjtBQUNyRCxjQUFjLG1CQUFPLENBQUMsaUVBQWE7QUFDbkMsUUFBUSwwQkFBMEIsRUFBRSxtQkFBTyxDQUFDLHFFQUFlOztBQUUzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsZ0JBQWdCO0FBQzNCLFdBQVcsT0FBTztBQUNsQixZQUFZLFNBQVM7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsWUFBWTtBQUN2QixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLE9BQU87QUFDbEIsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLG9CQUFvQix1QkFBdUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2xpZW50Ly4uL3NlcnZlci9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvcXVlcnkvY2FzdFVwZGF0ZS5qcz83NjEyIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3QgQ2FzdEVycm9yID0gcmVxdWlyZSgnLi4vLi4vZXJyb3IvY2FzdCcpO1xuY29uc3QgTW9uZ29vc2VFcnJvciA9IHJlcXVpcmUoJy4uLy4uL2Vycm9yL21vbmdvb3NlRXJyb3InKTtcbmNvbnN0IFN0cmljdE1vZGVFcnJvciA9IHJlcXVpcmUoJy4uLy4uL2Vycm9yL3N0cmljdCcpO1xuY29uc3QgVmFsaWRhdGlvbkVycm9yID0gcmVxdWlyZSgnLi4vLi4vZXJyb3IvdmFsaWRhdGlvbicpO1xuY29uc3QgY2FzdE51bWJlciA9IHJlcXVpcmUoJy4uLy4uL2Nhc3QvbnVtYmVyJyk7XG5jb25zdCBjYXN0ID0gcmVxdWlyZSgnLi4vLi4vY2FzdCcpO1xuY29uc3QgZ2V0Q29uc3RydWN0b3JOYW1lID0gcmVxdWlyZSgnLi4vZ2V0Q29uc3RydWN0b3JOYW1lJyk7XG5jb25zdCBnZXRFbWJlZGRlZERpc2NyaW1pbmF0b3JQYXRoID0gcmVxdWlyZSgnLi9nZXRFbWJlZGRlZERpc2NyaW1pbmF0b3JQYXRoJyk7XG5jb25zdCBoYW5kbGVJbW11dGFibGUgPSByZXF1aXJlKCcuL2hhbmRsZUltbXV0YWJsZScpO1xuY29uc3QgbW92ZUltbXV0YWJsZVByb3BlcnRpZXMgPSByZXF1aXJlKCcuLi91cGRhdGUvbW92ZUltbXV0YWJsZVByb3BlcnRpZXMnKTtcbmNvbnN0IHNjaGVtYU1peGVkU3ltYm9sID0gcmVxdWlyZSgnLi4vLi4vc2NoZW1hL3N5bWJvbHMnKS5zY2hlbWFNaXhlZFN5bWJvbDtcbmNvbnN0IHNldERvdHRlZFBhdGggPSByZXF1aXJlKCcuLi9wYXRoL3NldERvdHRlZFBhdGgnKTtcbmNvbnN0IHV0aWxzID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMnKTtcbmNvbnN0IHsgaW50ZXJuYWxUb09iamVjdE9wdGlvbnMgfSA9IHJlcXVpcmUoJy4uLy4uL29wdGlvbnMnKTtcblxuY29uc3QgbW9uZ29kYlVwZGF0ZU9wZXJhdG9ycyA9IG5ldyBTZXQoW1xuICAnJGN1cnJlbnREYXRlJyxcbiAgJyRpbmMnLFxuICAnJG1pbicsXG4gICckbWF4JyxcbiAgJyRtdWwnLFxuICAnJHJlbmFtZScsXG4gICckc2V0JyxcbiAgJyRzZXRPbkluc2VydCcsXG4gICckdW5zZXQnLFxuICAnJGFkZFRvU2V0JyxcbiAgJyRwb3AnLFxuICAnJHB1bGwnLFxuICAnJHB1c2gnLFxuICAnJHB1bGxBbGwnLFxuICAnJGJpdCdcbl0pO1xuXG4vKipcbiAqIENhc3RzIGFuIHVwZGF0ZSBvcCBiYXNlZCBvbiB0aGUgZ2l2ZW4gc2NoZW1hXG4gKlxuICogQHBhcmFtIHtTY2hlbWF9IHNjaGVtYVxuICogQHBhcmFtIHtPYmplY3R9IG9ialxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQHBhcmFtIHtCb29sZWFufFN0cmluZ30gW29wdGlvbnMuc3RyaWN0XSBkZWZhdWx0cyB0byB0cnVlXG4gKiBAcGFyYW0ge1F1ZXJ5fSBjb250ZXh0IHBhc3NlZCB0byBzZXR0ZXJzXG4gKiBAcmV0dXJuIHtCb29sZWFufSB0cnVlIGlmZiB0aGUgdXBkYXRlIGlzIG5vbi1lbXB0eVxuICogQGFwaSBwcml2YXRlXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gY2FzdFVwZGF0ZShzY2hlbWEsIG9iaiwgb3B0aW9ucywgY29udGV4dCwgZmlsdGVyKSB7XG4gIGlmIChvYmogPT0gbnVsbCkge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIC8vIFVwZGF0ZSBwaXBlbGluZVxuICBpZiAoQXJyYXkuaXNBcnJheShvYmopKSB7XG4gICAgY29uc3QgbGVuID0gb2JqLmxlbmd0aDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICBjb25zdCBvcHMgPSBPYmplY3Qua2V5cyhvYmpbaV0pO1xuICAgICAgZm9yIChjb25zdCBvcCBvZiBvcHMpIHtcbiAgICAgICAgb2JqW2ldW29wXSA9IGNhc3RQaXBlbGluZU9wZXJhdG9yKG9wLCBvYmpbaV1bb3BdKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG9iajtcbiAgfVxuXG4gIGlmIChvcHRpb25zLnVwc2VydCkge1xuICAgIG1vdmVJbW11dGFibGVQcm9wZXJ0aWVzKHNjaGVtYSwgb2JqLCBjb250ZXh0KTtcbiAgfVxuXG4gIGNvbnN0IG9wcyA9IE9iamVjdC5rZXlzKG9iaik7XG4gIGxldCBpID0gb3BzLmxlbmd0aDtcbiAgY29uc3QgcmV0ID0ge307XG4gIGxldCB2YWw7XG4gIGxldCBoYXNEb2xsYXJLZXkgPSBmYWxzZTtcblxuICBmaWx0ZXIgPSBmaWx0ZXIgfHwge307XG4gIHdoaWxlIChpLS0pIHtcbiAgICBjb25zdCBvcCA9IG9wc1tpXTtcbiAgICBpZiAoIW1vbmdvZGJVcGRhdGVPcGVyYXRvcnMuaGFzKG9wKSkge1xuICAgICAgLy8gZml4IHVwICRzZXQgc3VnYXJcbiAgICAgIGlmICghcmV0LiRzZXQpIHtcbiAgICAgICAgaWYgKG9iai4kc2V0KSB7XG4gICAgICAgICAgcmV0LiRzZXQgPSBvYmouJHNldDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXQuJHNldCA9IHt9O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXQuJHNldFtvcF0gPSBvYmpbb3BdO1xuICAgICAgb3BzLnNwbGljZShpLCAxKTtcbiAgICAgIGlmICghfm9wcy5pbmRleE9mKCckc2V0JykpIG9wcy5wdXNoKCckc2V0Jyk7XG4gICAgfSBlbHNlIGlmIChvcCA9PT0gJyRzZXQnKSB7XG4gICAgICBpZiAoIXJldC4kc2V0KSB7XG4gICAgICAgIHJldFtvcF0gPSBvYmpbb3BdO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZXRbb3BdID0gb2JqW29wXTtcbiAgICB9XG4gIH1cbiAgLy8gY2FzdCBlYWNoIHZhbHVlXG4gIGkgPSBvcHMubGVuZ3RoO1xuICB3aGlsZSAoaS0tKSB7XG4gICAgY29uc3Qgb3AgPSBvcHNbaV07XG4gICAgdmFsID0gcmV0W29wXTtcbiAgICBoYXNEb2xsYXJLZXkgPSBoYXNEb2xsYXJLZXkgfHwgb3Auc3RhcnRzV2l0aCgnJCcpO1xuICAgIGlmICh2YWwgIT0gbnVsbCAmJiB2YWwuJF9fKSB7XG4gICAgICB2YWwgPSB2YWwudG9PYmplY3QoaW50ZXJuYWxUb09iamVjdE9wdGlvbnMpO1xuICAgICAgcmV0W29wXSA9IHZhbDtcbiAgICB9XG4gICAgaWYgKHZhbCAmJlxuICAgICAgICB0eXBlb2YgdmFsID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAhQnVmZmVyLmlzQnVmZmVyKHZhbCkgJiZcbiAgICAgICAgbW9uZ29kYlVwZGF0ZU9wZXJhdG9ycy5oYXMob3ApKSB7XG4gICAgICB3YWxrVXBkYXRlUGF0aChzY2hlbWEsIHZhbCwgb3AsIG9wdGlvbnMsIGNvbnRleHQsIGZpbHRlcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IG1zZyA9ICdJbnZhbGlkIGF0b21pYyB1cGRhdGUgdmFsdWUgZm9yICcgKyBvcCArICcuICdcbiAgICAgICAgICArICdFeHBlY3RlZCBhbiBvYmplY3QsIHJlY2VpdmVkICcgKyB0eXBlb2YgdmFsO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gICAgfVxuXG4gICAgaWYgKG9wLnN0YXJ0c1dpdGgoJyQnKSAmJiB1dGlscy5pc0VtcHR5T2JqZWN0KHZhbCkpIHtcbiAgICAgIGRlbGV0ZSByZXRbb3BdO1xuICAgIH1cbiAgfVxuXG4gIGlmIChPYmplY3Qua2V5cyhyZXQpLmxlbmd0aCA9PT0gMCAmJlxuICAgICAgb3B0aW9ucy51cHNlcnQgJiZcbiAgICAgIE9iamVjdC5rZXlzKGZpbHRlcikubGVuZ3RoID4gMCkge1xuICAgIC8vIFRyaWNrIHRoZSBkcml2ZXIgaW50byBhbGxvd2luZyBlbXB0eSB1cHNlcnRzIHRvIHdvcmsgYXJvdW5kXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL21vbmdvZGIvbm9kZS1tb25nb2RiLW5hdGl2ZS9wdWxsLzI0OTBcbiAgICAvLyBTaGFsbG93IGNsb25lIHRvIGF2b2lkIHBhc3NpbmcgZGVmYXVsdHMgaW4gcmU6IGdoLTEzOTYyXG4gICAgcmV0dXJuIHsgJHNldE9uSW5zZXJ0OiB7IC4uLmZpbHRlciB9IH07XG4gIH1cbiAgcmV0dXJuIHJldDtcbn07XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxuZnVuY3Rpb24gY2FzdFBpcGVsaW5lT3BlcmF0b3Iob3AsIHZhbCkge1xuICBpZiAob3AgPT09ICckdW5zZXQnKSB7XG4gICAgaWYgKHR5cGVvZiB2YWwgIT09ICdzdHJpbmcnICYmICghQXJyYXkuaXNBcnJheSh2YWwpIHx8IHZhbC5maW5kKHYgPT4gdHlwZW9mIHYgIT09ICdzdHJpbmcnKSkpIHtcbiAgICAgIHRocm93IG5ldyBNb25nb29zZUVycm9yKCdJbnZhbGlkICR1bnNldCBpbiBwaXBlbGluZSwgbXVzdCBiZSAnICtcbiAgICAgICAgJyBhIHN0cmluZyBvciBhbiBhcnJheSBvZiBzdHJpbmdzJyk7XG4gICAgfVxuICAgIHJldHVybiB2YWw7XG4gIH1cbiAgaWYgKG9wID09PSAnJHByb2plY3QnKSB7XG4gICAgaWYgKHZhbCA9PSBudWxsIHx8IHR5cGVvZiB2YWwgIT09ICdvYmplY3QnKSB7XG4gICAgICB0aHJvdyBuZXcgTW9uZ29vc2VFcnJvcignSW52YWxpZCAkcHJvamVjdCBpbiBwaXBlbGluZSwgbXVzdCBiZSBhbiBvYmplY3QnKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbDtcbiAgfVxuICBpZiAob3AgPT09ICckYWRkRmllbGRzJyB8fCBvcCA9PT0gJyRzZXQnKSB7XG4gICAgaWYgKHZhbCA9PSBudWxsIHx8IHR5cGVvZiB2YWwgIT09ICdvYmplY3QnKSB7XG4gICAgICB0aHJvdyBuZXcgTW9uZ29vc2VFcnJvcignSW52YWxpZCAnICsgb3AgKyAnIGluIHBpcGVsaW5lLCBtdXN0IGJlIGFuIG9iamVjdCcpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsO1xuICB9IGVsc2UgaWYgKG9wID09PSAnJHJlcGxhY2VSb290JyB8fCBvcCA9PT0gJyRyZXBsYWNlV2l0aCcpIHtcbiAgICBpZiAodmFsID09IG51bGwgfHwgdHlwZW9mIHZhbCAhPT0gJ29iamVjdCcpIHtcbiAgICAgIHRocm93IG5ldyBNb25nb29zZUVycm9yKCdJbnZhbGlkICcgKyBvcCArICcgaW4gcGlwZWxpbmUsIG11c3QgYmUgYW4gb2JqZWN0Jyk7XG4gICAgfVxuICAgIHJldHVybiB2YWw7XG4gIH1cblxuICB0aHJvdyBuZXcgTW9uZ29vc2VFcnJvcignSW52YWxpZCB1cGRhdGUgcGlwZWxpbmUgb3BlcmF0b3I6IFwiJyArIG9wICsgJ1wiJyk7XG59XG5cbi8qKlxuICogV2FsayBlYWNoIHBhdGggb2Ygb2JqIGFuZCBjYXN0IGl0cyB2YWx1ZXNcbiAqIGFjY29yZGluZyB0byBpdHMgc2NoZW1hLlxuICpcbiAqIEBwYXJhbSB7U2NoZW1hfSBzY2hlbWFcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmogcGFydCBvZiBhIHF1ZXJ5XG4gKiBAcGFyYW0ge1N0cmluZ30gb3AgdGhlIGF0b21pYyBvcGVyYXRvciAoJHB1bGwsICRzZXQsIGV0YylcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEBwYXJhbSB7Qm9vbGVhbnxTdHJpbmd9IFtvcHRpb25zLnN0cmljdF1cbiAqIEBwYXJhbSB7UXVlcnl9IGNvbnRleHRcbiAqIEBwYXJhbSB7T2JqZWN0fSBmaWx0ZXJcbiAqIEBwYXJhbSB7U3RyaW5nfSBwcmVmIHBhdGggcHJlZml4IChpbnRlcm5hbCBvbmx5KVxuICogQHJldHVybiB7Qm9vbH0gdHJ1ZSBpZiB0aGlzIHBhdGggaGFzIGtleXMgdG8gdXBkYXRlXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiB3YWxrVXBkYXRlUGF0aChzY2hlbWEsIG9iaiwgb3AsIG9wdGlvbnMsIGNvbnRleHQsIGZpbHRlciwgcHJlZikge1xuICBjb25zdCBzdHJpY3QgPSBvcHRpb25zLnN0cmljdDtcbiAgY29uc3QgcHJlZml4ID0gcHJlZiA/IHByZWYgKyAnLicgOiAnJztcbiAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKG9iaik7XG4gIGxldCBpID0ga2V5cy5sZW5ndGg7XG4gIGxldCBoYXNLZXlzID0gZmFsc2U7XG4gIGxldCBzY2hlbWF0eXBlO1xuICBsZXQga2V5O1xuICBsZXQgdmFsO1xuXG4gIGxldCBhZ2dyZWdhdGVkRXJyb3IgPSBudWxsO1xuXG4gIGNvbnN0IHN0cmljdE1vZGUgPSBzdHJpY3QgIT0gbnVsbCA/IHN0cmljdCA6IHNjaGVtYS5vcHRpb25zLnN0cmljdDtcblxuICB3aGlsZSAoaS0tKSB7XG4gICAga2V5ID0ga2V5c1tpXTtcbiAgICB2YWwgPSBvYmpba2V5XTtcblxuICAgIC8vIGAkcHVsbGAgaXMgc3BlY2lhbCBiZWNhdXNlIHdlIG5lZWQgdG8gY2FzdCB0aGUgUkhTIGFzIGEgcXVlcnksIG5vdCBhc1xuICAgIC8vIGFuIHVwZGF0ZS5cbiAgICBpZiAob3AgPT09ICckcHVsbCcpIHtcbiAgICAgIHNjaGVtYXR5cGUgPSBzY2hlbWEuX2dldFNjaGVtYShwcmVmaXggKyBrZXkpO1xuICAgICAgaWYgKHNjaGVtYXR5cGUgIT0gbnVsbCAmJiBzY2hlbWF0eXBlLnNjaGVtYSAhPSBudWxsKSB7XG4gICAgICAgIG9ialtrZXldID0gY2FzdChzY2hlbWF0eXBlLnNjaGVtYSwgb2JqW2tleV0sIG9wdGlvbnMsIGNvbnRleHQpO1xuICAgICAgICBoYXNLZXlzID0gdHJ1ZTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgZGlzY3JpbWluYXRvcktleSA9IChwcmVmaXggPyBwcmVmaXggKyBrZXkgOiBrZXkpO1xuICAgIGlmIChcbiAgICAgIHNjaGVtYS5kaXNjcmltaW5hdG9yTWFwcGluZyAhPSBudWxsICYmXG4gICAgICBkaXNjcmltaW5hdG9yS2V5ID09PSBzY2hlbWEub3B0aW9ucy5kaXNjcmltaW5hdG9yS2V5ICYmXG4gICAgICBzY2hlbWEuZGlzY3JpbWluYXRvck1hcHBpbmcudmFsdWUgIT09IG9ialtrZXldICYmXG4gICAgICAhb3B0aW9ucy5vdmVyd3JpdGVEaXNjcmltaW5hdG9yS2V5XG4gICAgKSB7XG4gICAgICBpZiAoc3RyaWN0TW9kZSA9PT0gJ3Rocm93Jykge1xuICAgICAgICBjb25zdCBlcnIgPSBuZXcgRXJyb3IoJ0NhblxcJ3QgbW9kaWZ5IGRpc2NyaW1pbmF0b3Iga2V5IFwiJyArIGRpc2NyaW1pbmF0b3JLZXkgKyAnXCIgb24gZGlzY3JpbWluYXRvciBtb2RlbCcpO1xuICAgICAgICBhZ2dyZWdhdGVkRXJyb3IgPSBfYXBwZW5kRXJyb3IoZXJyLCBjb250ZXh0LCBkaXNjcmltaW5hdG9yS2V5LCBhZ2dyZWdhdGVkRXJyb3IpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH0gZWxzZSBpZiAoc3RyaWN0TW9kZSkge1xuICAgICAgICBkZWxldGUgb2JqW2tleV07XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChnZXRDb25zdHJ1Y3Rvck5hbWUodmFsKSA9PT0gJ09iamVjdCcpIHtcbiAgICAgIC8vIHdhdGNoIGZvciBlbWJlZGRlZCBkb2Mgc2NoZW1hc1xuICAgICAgc2NoZW1hdHlwZSA9IHNjaGVtYS5fZ2V0U2NoZW1hKHByZWZpeCArIGtleSk7XG5cbiAgICAgIGlmIChzY2hlbWF0eXBlID09IG51bGwpIHtcbiAgICAgICAgY29uc3QgX3JlcyA9IGdldEVtYmVkZGVkRGlzY3JpbWluYXRvclBhdGgoc2NoZW1hLCBvYmosIGZpbHRlciwgcHJlZml4ICsga2V5LCBvcHRpb25zKTtcbiAgICAgICAgaWYgKF9yZXMuc2NoZW1hdHlwZSAhPSBudWxsKSB7XG4gICAgICAgICAgc2NoZW1hdHlwZSA9IF9yZXMuc2NoZW1hdHlwZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAob3AgIT09ICckc2V0T25JbnNlcnQnICYmXG4gICAgICAgICAgaGFuZGxlSW1tdXRhYmxlKHNjaGVtYXR5cGUsIHN0cmljdCwgb2JqLCBrZXksIHByZWZpeCArIGtleSwgY29udGV4dCkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChzY2hlbWF0eXBlICYmIHNjaGVtYXR5cGUuY2FzdGVyICYmIG9wIGluIGNhc3RPcHMpIHtcbiAgICAgICAgLy8gZW1iZWRkZWQgZG9jIHNjaGVtYVxuICAgICAgICBpZiAoJyRlYWNoJyBpbiB2YWwpIHtcbiAgICAgICAgICBoYXNLZXlzID0gdHJ1ZTtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgb2JqW2tleV0gPSB7XG4gICAgICAgICAgICAgICRlYWNoOiBjYXN0VXBkYXRlVmFsKHNjaGVtYXR5cGUsIHZhbC4kZWFjaCwgb3AsIGtleSwgY29udGV4dCwgcHJlZml4ICsga2V5KVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgYWdncmVnYXRlZEVycm9yID0gX2FwcGVuZEVycm9yKGVycm9yLCBjb250ZXh0LCBrZXksIGFnZ3JlZ2F0ZWRFcnJvcik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHZhbC4kc2xpY2UgIT0gbnVsbCkge1xuICAgICAgICAgICAgb2JqW2tleV0uJHNsaWNlID0gdmFsLiRzbGljZSB8IDA7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHZhbC4kc29ydCkge1xuICAgICAgICAgICAgb2JqW2tleV0uJHNvcnQgPSB2YWwuJHNvcnQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHZhbC4kcG9zaXRpb24gIT0gbnVsbCkge1xuICAgICAgICAgICAgb2JqW2tleV0uJHBvc2l0aW9uID0gY2FzdE51bWJlcih2YWwuJHBvc2l0aW9uKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKHNjaGVtYXR5cGUgIT0gbnVsbCAmJiBzY2hlbWF0eXBlLiRpc1NpbmdsZU5lc3RlZCkge1xuICAgICAgICAgICAgY29uc3QgX3N0cmljdCA9IHN0cmljdCA9PSBudWxsID8gc2NoZW1hdHlwZS5zY2hlbWEub3B0aW9ucy5zdHJpY3QgOiBzdHJpY3Q7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBvYmpba2V5XSA9IHNjaGVtYXR5cGUuY2FzdEZvclF1ZXJ5KG51bGwsIHZhbCwgY29udGV4dCwgeyBzdHJpY3Q6IF9zdHJpY3QgfSk7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICBhZ2dyZWdhdGVkRXJyb3IgPSBfYXBwZW5kRXJyb3IoZXJyb3IsIGNvbnRleHQsIGtleSwgYWdncmVnYXRlZEVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgb2JqW2tleV0gPSBjYXN0VXBkYXRlVmFsKHNjaGVtYXR5cGUsIHZhbCwgb3AsIGtleSwgY29udGV4dCwgcHJlZml4ICsga2V5KTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgIGFnZ3JlZ2F0ZWRFcnJvciA9IF9hcHBlbmRFcnJvcihlcnJvciwgY29udGV4dCwga2V5LCBhZ2dyZWdhdGVkRXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChvYmpba2V5XSA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICBkZWxldGUgb2JqW2tleV07XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBoYXNLZXlzID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICgob3AgPT09ICckY3VycmVudERhdGUnKSB8fCAob3AgaW4gY2FzdE9wcyAmJiBzY2hlbWF0eXBlKSkge1xuICAgICAgICAvLyAkY3VycmVudERhdGUgY2FuIHRha2UgYW4gb2JqZWN0XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgb2JqW2tleV0gPSBjYXN0VXBkYXRlVmFsKHNjaGVtYXR5cGUsIHZhbCwgb3AsIGtleSwgY29udGV4dCwgcHJlZml4ICsga2V5KTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICBhZ2dyZWdhdGVkRXJyb3IgPSBfYXBwZW5kRXJyb3IoZXJyb3IsIGNvbnRleHQsIGtleSwgYWdncmVnYXRlZEVycm9yKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvYmpba2V5XSA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgZGVsZXRlIG9ialtrZXldO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaGFzS2V5cyA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBwYXRoVG9DaGVjayA9IChwcmVmaXggKyBrZXkpO1xuICAgICAgICBjb25zdCB2ID0gc2NoZW1hLl9nZXRQYXRoVHlwZShwYXRoVG9DaGVjayk7XG4gICAgICAgIGxldCBfc3RyaWN0ID0gc3RyaWN0O1xuICAgICAgICBpZiAodiAmJiB2LnNjaGVtYSAmJiBfc3RyaWN0ID09IG51bGwpIHtcbiAgICAgICAgICBfc3RyaWN0ID0gdi5zY2hlbWEub3B0aW9ucy5zdHJpY3Q7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodi5wYXRoVHlwZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICBpZiAoX3N0cmljdCA9PT0gJ3Rocm93Jykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFN0cmljdE1vZGVFcnJvcihwYXRoVG9DaGVjayk7XG4gICAgICAgICAgfSBlbHNlIGlmIChfc3RyaWN0KSB7XG4gICAgICAgICAgICBkZWxldGUgb2JqW2tleV07XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBnaC0yMzE0XG4gICAgICAgIC8vIHdlIHNob3VsZCBiZSBhYmxlIHRvIHNldCBhIHNjaGVtYS1sZXNzIGZpZWxkXG4gICAgICAgIC8vIHRvIGFuIGVtcHR5IG9iamVjdCBsaXRlcmFsXG4gICAgICAgIGhhc0tleXMgfD0gd2Fsa1VwZGF0ZVBhdGgoc2NoZW1hLCB2YWwsIG9wLCBvcHRpb25zLCBjb250ZXh0LCBmaWx0ZXIsIHByZWZpeCArIGtleSkgfHxcbiAgICAgICAgICAodXRpbHMuaXNPYmplY3QodmFsKSAmJiBPYmplY3Qua2V5cyh2YWwpLmxlbmd0aCA9PT0gMCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGNoZWNrUGF0aCA9IChrZXkgPT09ICckZWFjaCcgfHwga2V5ID09PSAnJG9yJyB8fCBrZXkgPT09ICckYW5kJyB8fCBrZXkgPT09ICckaW4nKSA/XG4gICAgICAgIHByZWYgOiBwcmVmaXggKyBrZXk7XG4gICAgICBzY2hlbWF0eXBlID0gc2NoZW1hLl9nZXRTY2hlbWEoY2hlY2tQYXRoKTtcblxuICAgICAgLy8gWW91IGNhbiB1c2UgYCRzZXRPbkluc2VydGAgd2l0aCBpbW11dGFibGUga2V5c1xuICAgICAgaWYgKG9wICE9PSAnJHNldE9uSW5zZXJ0JyAmJlxuICAgICAgICAgIGhhbmRsZUltbXV0YWJsZShzY2hlbWF0eXBlLCBzdHJpY3QsIG9iaiwga2V5LCBwcmVmaXggKyBrZXksIGNvbnRleHQpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBsZXQgcGF0aERldGFpbHMgPSBzY2hlbWEuX2dldFBhdGhUeXBlKGNoZWNrUGF0aCk7XG5cbiAgICAgIC8vIElmIG5vIHNjaGVtYSB0eXBlLCBjaGVjayBmb3IgZW1iZWRkZWQgZGlzY3JpbWluYXRvcnMgYmVjYXVzZSB0aGVcbiAgICAgIC8vIGZpbHRlciBvciB1cGRhdGUgbWF5IGltcGx5IGFuIGVtYmVkZGVkIGRpc2NyaW1pbmF0b3IgdHlwZS4gU2VlICM4Mzc4XG4gICAgICBpZiAoc2NoZW1hdHlwZSA9PSBudWxsKSB7XG4gICAgICAgIGNvbnN0IF9yZXMgPSBnZXRFbWJlZGRlZERpc2NyaW1pbmF0b3JQYXRoKHNjaGVtYSwgb2JqLCBmaWx0ZXIsIGNoZWNrUGF0aCwgb3B0aW9ucyk7XG4gICAgICAgIGlmIChfcmVzLnNjaGVtYXR5cGUgIT0gbnVsbCkge1xuICAgICAgICAgIHNjaGVtYXR5cGUgPSBfcmVzLnNjaGVtYXR5cGU7XG4gICAgICAgICAgcGF0aERldGFpbHMgPSBfcmVzLnR5cGU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgbGV0IGlzU3RyaWN0ID0gc3RyaWN0O1xuICAgICAgaWYgKHBhdGhEZXRhaWxzICYmIHBhdGhEZXRhaWxzLnNjaGVtYSAmJiBzdHJpY3QgPT0gbnVsbCkge1xuICAgICAgICBpc1N0cmljdCA9IHBhdGhEZXRhaWxzLnNjaGVtYS5vcHRpb25zLnN0cmljdDtcbiAgICAgIH1cblxuICAgICAgY29uc3Qgc2tpcCA9IGlzU3RyaWN0ICYmXG4gICAgICAgICFzY2hlbWF0eXBlICYmXG4gICAgICAgICEvcmVhbHxuZXN0ZWQvLnRlc3QocGF0aERldGFpbHMucGF0aFR5cGUpO1xuXG4gICAgICBpZiAoc2tpcCkge1xuICAgICAgICAvLyBFdmVuIGlmIHN0cmljdCBpcyBgdGhyb3dgLCBhdm9pZCB0aHJvd2luZyBhbiBlcnJvciBiZWNhdXNlIG9mXG4gICAgICAgIC8vIHZpcnR1YWxzIGJlY2F1c2Ugb2YgIzY3MzFcbiAgICAgICAgaWYgKGlzU3RyaWN0ID09PSAndGhyb3cnICYmIHNjaGVtYS52aXJ0dWFsc1tjaGVja1BhdGhdID09IG51bGwpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgU3RyaWN0TW9kZUVycm9yKHByZWZpeCArIGtleSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGVsZXRlIG9ialtrZXldO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBnaC0xODQ1IHRlbXBvcmFyeSBmaXg6IGlnbm9yZSAkcmVuYW1lLiBTZWUgZ2gtMzAyNyBmb3IgdHJhY2tpbmdcbiAgICAgICAgLy8gaW1wcm92aW5nIHRoaXMuXG4gICAgICAgIGlmIChvcCA9PT0gJyRyZW5hbWUnKSB7XG4gICAgICAgICAgaGFzS2V5cyA9IHRydWU7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICB0cnkge1xuICAgICAgICAgIGlmIChwcmVmaXgubGVuZ3RoID09PSAwIHx8IGtleS5pbmRleE9mKCcuJykgPT09IC0xKSB7XG4gICAgICAgICAgICBvYmpba2V5XSA9IGNhc3RVcGRhdGVWYWwoc2NoZW1hdHlwZSwgdmFsLCBvcCwga2V5LCBjb250ZXh0LCBwcmVmaXggKyBrZXkpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoaXNTdHJpY3QgIT09IGZhbHNlIHx8IHNjaGVtYXR5cGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gU2V0dGluZyBhIG5lc3RlZCBkb3R0ZWQgcGF0aCB0aGF0J3MgaW4gdGhlIHNjaGVtYS4gV2UgZG9uJ3QgYWxsb3cgcGF0aHMgd2l0aCAnLicgaW5cbiAgICAgICAgICAgIC8vIGEgc2NoZW1hLCBzbyByZXBsYWNlIHRoZSBkb3R0ZWQgcGF0aCB3aXRoIGEgbmVzdGVkIG9iamVjdCB0byBhdm9pZCBlbmRpbmcgdXAgd2l0aFxuICAgICAgICAgICAgLy8gZG90dGVkIHByb3BlcnRpZXMgaW4gdGhlIHVwZGF0ZWQgb2JqZWN0LiBTZWUgKGdoLTEwMjAwKVxuICAgICAgICAgICAgc2V0RG90dGVkUGF0aChvYmosIGtleSwgY2FzdFVwZGF0ZVZhbChzY2hlbWF0eXBlLCB2YWwsIG9wLCBrZXksIGNvbnRleHQsIHByZWZpeCArIGtleSkpO1xuICAgICAgICAgICAgZGVsZXRlIG9ialtrZXldO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICBhZ2dyZWdhdGVkRXJyb3IgPSBfYXBwZW5kRXJyb3IoZXJyb3IsIGNvbnRleHQsIGtleSwgYWdncmVnYXRlZEVycm9yKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KG9ialtrZXldKSAmJiAob3AgPT09ICckYWRkVG9TZXQnIHx8IG9wID09PSAnJHB1c2gnKSAmJiBrZXkgIT09ICckZWFjaCcpIHtcbiAgICAgICAgICBpZiAoc2NoZW1hdHlwZSAmJlxuICAgICAgICAgICAgICBzY2hlbWF0eXBlLmNhc3RlciAmJlxuICAgICAgICAgICAgICAhc2NoZW1hdHlwZS5jYXN0ZXIuJGlzTW9uZ29vc2VBcnJheSAmJlxuICAgICAgICAgICAgICAhc2NoZW1hdHlwZS5jYXN0ZXJbc2NoZW1hTWl4ZWRTeW1ib2xdKSB7XG4gICAgICAgICAgICBvYmpba2V5XSA9IHsgJGVhY2g6IG9ialtrZXldIH07XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9ialtrZXldID09PSB2b2lkIDApIHtcbiAgICAgICAgICBkZWxldGUgb2JqW2tleV07XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBoYXNLZXlzID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoYWdncmVnYXRlZEVycm9yICE9IG51bGwpIHtcbiAgICB0aHJvdyBhZ2dyZWdhdGVkRXJyb3I7XG4gIH1cblxuICByZXR1cm4gaGFzS2V5cztcbn1cblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5mdW5jdGlvbiBfYXBwZW5kRXJyb3IoZXJyb3IsIHF1ZXJ5LCBrZXksIGFnZ3JlZ2F0ZWRFcnJvcikge1xuICBpZiAodHlwZW9mIHF1ZXJ5ICE9PSAnb2JqZWN0JyB8fCAhcXVlcnkub3B0aW9ucy5tdWx0aXBsZUNhc3RFcnJvcikge1xuICAgIHRocm93IGVycm9yO1xuICB9XG4gIGFnZ3JlZ2F0ZWRFcnJvciA9IGFnZ3JlZ2F0ZWRFcnJvciB8fCBuZXcgVmFsaWRhdGlvbkVycm9yKCk7XG4gIGFnZ3JlZ2F0ZWRFcnJvci5hZGRFcnJvcihrZXksIGVycm9yKTtcbiAgcmV0dXJuIGFnZ3JlZ2F0ZWRFcnJvcjtcbn1cblxuLyoqXG4gKiBUaGVzZSBvcGVyYXRvcnMgc2hvdWxkIGJlIGNhc3QgdG8gbnVtYmVycyBpbnN0ZWFkXG4gKiBvZiB0aGVpciBwYXRoIHNjaGVtYSB0eXBlLlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuY29uc3QgbnVtYmVyT3BzID0ge1xuICAkcG9wOiAxLFxuICAkaW5jOiAxXG59O1xuXG4vKipcbiAqIFRoZXNlIG9wcyByZXF1aXJlIG5vIGNhc3RpbmcgYmVjYXVzZSB0aGUgUkhTIGRvZXNuJ3QgZG8gYW55dGhpbmcuXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5jb25zdCBub0Nhc3RPcHMgPSB7XG4gICR1bnNldDogMVxufTtcblxuLyoqXG4gKiBUaGVzZSBvcGVyYXRvcnMgcmVxdWlyZSBjYXN0aW5nIGRvY3NcbiAqIHRvIHJlYWwgRG9jdW1lbnRzIGZvciBVcGRhdGUgb3BlcmF0aW9ucy5cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmNvbnN0IGNhc3RPcHMgPSB7XG4gICRwdXNoOiAxLFxuICAkYWRkVG9TZXQ6IDEsXG4gICRzZXQ6IDEsXG4gICRzZXRPbkluc2VydDogMVxufTtcblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5jb25zdCBvdmVyd3JpdGVPcHMgPSB7XG4gICRzZXQ6IDEsXG4gICRzZXRPbkluc2VydDogMVxufTtcblxuLyoqXG4gKiBDYXN0cyBgdmFsYCBhY2NvcmRpbmcgdG8gYHNjaGVtYWAgYW5kIGF0b21pYyBgb3BgLlxuICpcbiAqIEBwYXJhbSB7U2NoZW1hVHlwZX0gc2NoZW1hXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsXG4gKiBAcGFyYW0ge1N0cmluZ30gb3AgdGhlIGF0b21pYyBvcGVyYXRvciAoJHB1bGwsICRzZXQsIGV0YylcbiAqIEBwYXJhbSB7U3RyaW5nfSAkY29uZGl0aW9uYWxcbiAqIEBwYXJhbSB7UXVlcnl9IGNvbnRleHRcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBjYXN0VXBkYXRlVmFsKHNjaGVtYSwgdmFsLCBvcCwgJGNvbmRpdGlvbmFsLCBjb250ZXh0LCBwYXRoKSB7XG4gIGlmICghc2NoZW1hKSB7XG4gICAgLy8gbm9uLWV4aXN0aW5nIHNjaGVtYSBwYXRoXG4gICAgaWYgKG9wIGluIG51bWJlck9wcykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGNhc3ROdW1iZXIodmFsKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICB0aHJvdyBuZXcgQ2FzdEVycm9yKCdudW1iZXInLCB2YWwsIHBhdGgpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdmFsO1xuICB9XG5cbiAgLy8gY29uc29sZS5sb2coJ0Nhc3RVcGRhdGVWYWwnLCBwYXRoLCBvcCwgdmFsLCBzY2hlbWEpO1xuXG4gIGNvbnN0IGNvbmQgPSBzY2hlbWEuY2FzdGVyICYmIG9wIGluIGNhc3RPcHMgJiZcbiAgICAgICh1dGlscy5pc09iamVjdCh2YWwpIHx8IEFycmF5LmlzQXJyYXkodmFsKSk7XG4gIGlmIChjb25kICYmICFvdmVyd3JpdGVPcHNbb3BdKSB7XG4gICAgLy8gQ2FzdCB2YWx1ZXMgZm9yIG9wcyB0aGF0IGFkZCBkYXRhIHRvIE1vbmdvREIuXG4gICAgLy8gRW5zdXJlcyBlbWJlZGRlZCBkb2N1bWVudHMgZ2V0IE9iamVjdElkcyBldGMuXG4gICAgbGV0IHNjaGVtYUFycmF5RGVwdGggPSAwO1xuICAgIGxldCBjdXIgPSBzY2hlbWE7XG4gICAgd2hpbGUgKGN1ci4kaXNNb25nb29zZUFycmF5KSB7XG4gICAgICArK3NjaGVtYUFycmF5RGVwdGg7XG4gICAgICBjdXIgPSBjdXIuY2FzdGVyO1xuICAgIH1cbiAgICBsZXQgYXJyYXlEZXB0aCA9IDA7XG4gICAgbGV0IF92YWwgPSB2YWw7XG4gICAgd2hpbGUgKEFycmF5LmlzQXJyYXkoX3ZhbCkpIHtcbiAgICAgICsrYXJyYXlEZXB0aDtcbiAgICAgIF92YWwgPSBfdmFsWzBdO1xuICAgIH1cblxuICAgIGNvbnN0IGFkZGl0aW9uYWxOZXN0aW5nID0gc2NoZW1hQXJyYXlEZXB0aCAtIGFycmF5RGVwdGg7XG4gICAgd2hpbGUgKGFycmF5RGVwdGggPCBzY2hlbWFBcnJheURlcHRoKSB7XG4gICAgICB2YWwgPSBbdmFsXTtcbiAgICAgICsrYXJyYXlEZXB0aDtcbiAgICB9XG5cbiAgICBsZXQgdG1wID0gc2NoZW1hLmFwcGx5U2V0dGVycyhBcnJheS5pc0FycmF5KHZhbCkgPyB2YWwgOiBbdmFsXSwgY29udGV4dCk7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFkZGl0aW9uYWxOZXN0aW5nOyArK2kpIHtcbiAgICAgIHRtcCA9IHRtcFswXTtcbiAgICB9XG4gICAgcmV0dXJuIHRtcDtcbiAgfVxuXG4gIGlmIChvcCBpbiBub0Nhc3RPcHMpIHtcbiAgICByZXR1cm4gdmFsO1xuICB9XG4gIGlmIChvcCBpbiBudW1iZXJPcHMpIHtcbiAgICAvLyBOdWxsIGFuZCB1bmRlZmluZWQgbm90IGFsbG93ZWQgZm9yICRwb3AsICRpbmNcbiAgICBpZiAodmFsID09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBDYXN0RXJyb3IoJ251bWJlcicsIHZhbCwgc2NoZW1hLnBhdGgpO1xuICAgIH1cbiAgICBpZiAob3AgPT09ICckaW5jJykge1xuICAgICAgLy8gU3VwcG9ydCBgJGluY2Agd2l0aCBsb25nLCBpbnQzMiwgZXRjLiAoZ2gtNDI4MylcbiAgICAgIHJldHVybiBzY2hlbWEuY2FzdEZvclF1ZXJ5KFxuICAgICAgICBudWxsLFxuICAgICAgICB2YWwsXG4gICAgICAgIGNvbnRleHRcbiAgICAgICk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICByZXR1cm4gY2FzdE51bWJlcih2YWwpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB0aHJvdyBuZXcgQ2FzdEVycm9yKCdudW1iZXInLCB2YWwsIHNjaGVtYS5wYXRoKTtcbiAgICB9XG4gIH1cbiAgaWYgKG9wID09PSAnJGN1cnJlbnREYXRlJykge1xuICAgIGlmICh0eXBlb2YgdmFsID09PSAnb2JqZWN0Jykge1xuICAgICAgcmV0dXJuIHsgJHR5cGU6IHZhbC4kdHlwZSB9O1xuICAgIH1cbiAgICByZXR1cm4gQm9vbGVhbih2YWwpO1xuICB9XG5cbiAgaWYgKG1vbmdvZGJVcGRhdGVPcGVyYXRvcnMuaGFzKCRjb25kaXRpb25hbCkpIHtcbiAgICByZXR1cm4gc2NoZW1hLmNhc3RGb3JRdWVyeShcbiAgICAgICRjb25kaXRpb25hbCxcbiAgICAgIHZhbCxcbiAgICAgIGNvbnRleHRcbiAgICApO1xuICB9XG5cbiAgaWYgKG92ZXJ3cml0ZU9wc1tvcF0pIHtcbiAgICBjb25zdCBza2lwUXVlcnlDYXN0Rm9yVXBkYXRlID0gdmFsICE9IG51bGwgJiYgc2NoZW1hLiRpc01vbmdvb3NlQXJyYXkgJiYgc2NoZW1hLiRmdWxsUGF0aCAhPSBudWxsICYmICFzY2hlbWEuJGZ1bGxQYXRoLm1hdGNoKC9cXGQrJC8pO1xuICAgIGNvbnN0IGFwcGx5U2V0dGVycyA9IHNjaGVtYVtzY2hlbWFNaXhlZFN5bWJvbF0gIT0gbnVsbDtcbiAgICBpZiAoc2tpcFF1ZXJ5Q2FzdEZvclVwZGF0ZSB8fCBhcHBseVNldHRlcnMpIHtcbiAgICAgIHJldHVybiBzY2hlbWEuYXBwbHlTZXR0ZXJzKHZhbCwgY29udGV4dCk7XG4gICAgfVxuICAgIHJldHVybiBzY2hlbWEuY2FzdEZvclF1ZXJ5KFxuICAgICAgbnVsbCxcbiAgICAgIHZhbCxcbiAgICAgIGNvbnRleHRcbiAgICApO1xuICB9XG5cbiAgcmV0dXJuIHNjaGVtYS5jYXN0Rm9yUXVlcnkobnVsbCwgdmFsLCBjb250ZXh0KTtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../server/node_modules/mongoose/lib/helpers/query/castUpdate.js\n");

/***/ }),

/***/ "../server/node_modules/mongoose/lib/helpers/query/getEmbeddedDiscriminatorPath.js":
/*!*****************************************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/helpers/query/getEmbeddedDiscriminatorPath.js ***!
  \*****************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst cleanPositionalOperators = __webpack_require__(/*! ../schema/cleanPositionalOperators */ \"../server/node_modules/mongoose/lib/helpers/schema/cleanPositionalOperators.js\");\nconst get = __webpack_require__(/*! ../get */ \"../server/node_modules/mongoose/lib/helpers/get.js\");\nconst getDiscriminatorByValue = __webpack_require__(/*! ../discriminator/getDiscriminatorByValue */ \"../server/node_modules/mongoose/lib/helpers/discriminator/getDiscriminatorByValue.js\");\nconst updatedPathsByArrayFilter = __webpack_require__(/*! ../update/updatedPathsByArrayFilter */ \"../server/node_modules/mongoose/lib/helpers/update/updatedPathsByArrayFilter.js\");\n\n/**\n * Like `schema.path()`, except with a document, because impossible to\n * determine path type without knowing the embedded discriminator key.\n * @param {Schema} schema\n * @param {Object} [update]\n * @param {Object} [filter]\n * @param {String} path\n * @param {Object} [options]\n * @api private\n */\n\nmodule.exports = function getEmbeddedDiscriminatorPath(schema, update, filter, path, options) {\n  const parts = path.split('.');\n  let schematype = null;\n  let type = 'adhocOrUndefined';\n\n  filter = filter || {};\n  update = update || {};\n  const arrayFilters = options != null && Array.isArray(options.arrayFilters) ?\n    options.arrayFilters : [];\n  const updatedPathsByFilter = updatedPathsByArrayFilter(update);\n\n  for (let i = 0; i < parts.length; ++i) {\n    const subpath = cleanPositionalOperators(parts.slice(0, i + 1).join('.'));\n    schematype = schema.path(subpath);\n    if (schematype == null) {\n      continue;\n    }\n\n    type = schema.pathType(subpath);\n    if ((schematype.$isSingleNested || schematype.$isMongooseDocumentArrayElement) &&\n        schematype.schema.discriminators != null) {\n      const key = get(schematype, 'schema.options.discriminatorKey');\n      const discriminatorValuePath = subpath + '.' + key;\n      const discriminatorFilterPath =\n        discriminatorValuePath.replace(/\\.\\d+\\./, '.');\n      let discriminatorKey = null;\n\n      if (discriminatorValuePath in filter) {\n        discriminatorKey = filter[discriminatorValuePath];\n      }\n      if (discriminatorFilterPath in filter) {\n        discriminatorKey = filter[discriminatorFilterPath];\n      }\n\n      const wrapperPath = subpath.replace(/\\.\\d+$/, '');\n      if (schematype.$isMongooseDocumentArrayElement &&\n          get(filter[wrapperPath], '$elemMatch.' + key) != null) {\n        discriminatorKey = filter[wrapperPath].$elemMatch[key];\n      }\n\n      if (discriminatorValuePath in update) {\n        discriminatorKey = update[discriminatorValuePath];\n      }\n\n      for (const filterKey of Object.keys(updatedPathsByFilter)) {\n        const schemaKey = updatedPathsByFilter[filterKey] + '.' + key;\n        const arrayFilterKey = filterKey + '.' + key;\n        if (schemaKey === discriminatorFilterPath) {\n          const filter = arrayFilters.find(filter => filter.hasOwnProperty(arrayFilterKey));\n          if (filter != null) {\n            discriminatorKey = filter[arrayFilterKey];\n          }\n        }\n      }\n\n      if (discriminatorKey == null) {\n        continue;\n      }\n\n      const discriminator = getDiscriminatorByValue(schematype.caster.discriminators, discriminatorKey);\n      const discriminatorSchema = discriminator && discriminator.schema;\n      if (discriminatorSchema == null) {\n        continue;\n      }\n\n      const rest = parts.slice(i + 1).join('.');\n      schematype = discriminatorSchema.path(rest);\n      if (schematype != null) {\n        type = discriminatorSchema._getPathType(rest);\n        break;\n      }\n    }\n  }\n\n  return { type: type, schematype: schematype };\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9xdWVyeS9nZXRFbWJlZGRlZERpc2NyaW1pbmF0b3JQYXRoLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLGlDQUFpQyxtQkFBTyxDQUFDLDBIQUFvQztBQUM3RSxZQUFZLG1CQUFPLENBQUMsa0VBQVE7QUFDNUIsZ0NBQWdDLG1CQUFPLENBQUMsc0lBQTBDO0FBQ2xGLGtDQUFrQyxtQkFBTyxDQUFDLDRIQUFxQzs7QUFFL0U7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLGtCQUFrQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsV0FBVztBQUNYIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2xpZW50Ly4uL3NlcnZlci9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvcXVlcnkvZ2V0RW1iZWRkZWREaXNjcmltaW5hdG9yUGF0aC5qcz8xZDMxIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3QgY2xlYW5Qb3NpdGlvbmFsT3BlcmF0b3JzID0gcmVxdWlyZSgnLi4vc2NoZW1hL2NsZWFuUG9zaXRpb25hbE9wZXJhdG9ycycpO1xuY29uc3QgZ2V0ID0gcmVxdWlyZSgnLi4vZ2V0Jyk7XG5jb25zdCBnZXREaXNjcmltaW5hdG9yQnlWYWx1ZSA9IHJlcXVpcmUoJy4uL2Rpc2NyaW1pbmF0b3IvZ2V0RGlzY3JpbWluYXRvckJ5VmFsdWUnKTtcbmNvbnN0IHVwZGF0ZWRQYXRoc0J5QXJyYXlGaWx0ZXIgPSByZXF1aXJlKCcuLi91cGRhdGUvdXBkYXRlZFBhdGhzQnlBcnJheUZpbHRlcicpO1xuXG4vKipcbiAqIExpa2UgYHNjaGVtYS5wYXRoKClgLCBleGNlcHQgd2l0aCBhIGRvY3VtZW50LCBiZWNhdXNlIGltcG9zc2libGUgdG9cbiAqIGRldGVybWluZSBwYXRoIHR5cGUgd2l0aG91dCBrbm93aW5nIHRoZSBlbWJlZGRlZCBkaXNjcmltaW5hdG9yIGtleS5cbiAqIEBwYXJhbSB7U2NoZW1hfSBzY2hlbWFcbiAqIEBwYXJhbSB7T2JqZWN0fSBbdXBkYXRlXVxuICogQHBhcmFtIHtPYmplY3R9IFtmaWx0ZXJdXG4gKiBAcGFyYW0ge1N0cmluZ30gcGF0aFxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBnZXRFbWJlZGRlZERpc2NyaW1pbmF0b3JQYXRoKHNjaGVtYSwgdXBkYXRlLCBmaWx0ZXIsIHBhdGgsIG9wdGlvbnMpIHtcbiAgY29uc3QgcGFydHMgPSBwYXRoLnNwbGl0KCcuJyk7XG4gIGxldCBzY2hlbWF0eXBlID0gbnVsbDtcbiAgbGV0IHR5cGUgPSAnYWRob2NPclVuZGVmaW5lZCc7XG5cbiAgZmlsdGVyID0gZmlsdGVyIHx8IHt9O1xuICB1cGRhdGUgPSB1cGRhdGUgfHwge307XG4gIGNvbnN0IGFycmF5RmlsdGVycyA9IG9wdGlvbnMgIT0gbnVsbCAmJiBBcnJheS5pc0FycmF5KG9wdGlvbnMuYXJyYXlGaWx0ZXJzKSA/XG4gICAgb3B0aW9ucy5hcnJheUZpbHRlcnMgOiBbXTtcbiAgY29uc3QgdXBkYXRlZFBhdGhzQnlGaWx0ZXIgPSB1cGRhdGVkUGF0aHNCeUFycmF5RmlsdGVyKHVwZGF0ZSk7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXJ0cy5sZW5ndGg7ICsraSkge1xuICAgIGNvbnN0IHN1YnBhdGggPSBjbGVhblBvc2l0aW9uYWxPcGVyYXRvcnMocGFydHMuc2xpY2UoMCwgaSArIDEpLmpvaW4oJy4nKSk7XG4gICAgc2NoZW1hdHlwZSA9IHNjaGVtYS5wYXRoKHN1YnBhdGgpO1xuICAgIGlmIChzY2hlbWF0eXBlID09IG51bGwpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHR5cGUgPSBzY2hlbWEucGF0aFR5cGUoc3VicGF0aCk7XG4gICAgaWYgKChzY2hlbWF0eXBlLiRpc1NpbmdsZU5lc3RlZCB8fCBzY2hlbWF0eXBlLiRpc01vbmdvb3NlRG9jdW1lbnRBcnJheUVsZW1lbnQpICYmXG4gICAgICAgIHNjaGVtYXR5cGUuc2NoZW1hLmRpc2NyaW1pbmF0b3JzICE9IG51bGwpIHtcbiAgICAgIGNvbnN0IGtleSA9IGdldChzY2hlbWF0eXBlLCAnc2NoZW1hLm9wdGlvbnMuZGlzY3JpbWluYXRvcktleScpO1xuICAgICAgY29uc3QgZGlzY3JpbWluYXRvclZhbHVlUGF0aCA9IHN1YnBhdGggKyAnLicgKyBrZXk7XG4gICAgICBjb25zdCBkaXNjcmltaW5hdG9yRmlsdGVyUGF0aCA9XG4gICAgICAgIGRpc2NyaW1pbmF0b3JWYWx1ZVBhdGgucmVwbGFjZSgvXFwuXFxkK1xcLi8sICcuJyk7XG4gICAgICBsZXQgZGlzY3JpbWluYXRvcktleSA9IG51bGw7XG5cbiAgICAgIGlmIChkaXNjcmltaW5hdG9yVmFsdWVQYXRoIGluIGZpbHRlcikge1xuICAgICAgICBkaXNjcmltaW5hdG9yS2V5ID0gZmlsdGVyW2Rpc2NyaW1pbmF0b3JWYWx1ZVBhdGhdO1xuICAgICAgfVxuICAgICAgaWYgKGRpc2NyaW1pbmF0b3JGaWx0ZXJQYXRoIGluIGZpbHRlcikge1xuICAgICAgICBkaXNjcmltaW5hdG9yS2V5ID0gZmlsdGVyW2Rpc2NyaW1pbmF0b3JGaWx0ZXJQYXRoXTtcbiAgICAgIH1cblxuICAgICAgY29uc3Qgd3JhcHBlclBhdGggPSBzdWJwYXRoLnJlcGxhY2UoL1xcLlxcZCskLywgJycpO1xuICAgICAgaWYgKHNjaGVtYXR5cGUuJGlzTW9uZ29vc2VEb2N1bWVudEFycmF5RWxlbWVudCAmJlxuICAgICAgICAgIGdldChmaWx0ZXJbd3JhcHBlclBhdGhdLCAnJGVsZW1NYXRjaC4nICsga2V5KSAhPSBudWxsKSB7XG4gICAgICAgIGRpc2NyaW1pbmF0b3JLZXkgPSBmaWx0ZXJbd3JhcHBlclBhdGhdLiRlbGVtTWF0Y2hba2V5XTtcbiAgICAgIH1cblxuICAgICAgaWYgKGRpc2NyaW1pbmF0b3JWYWx1ZVBhdGggaW4gdXBkYXRlKSB7XG4gICAgICAgIGRpc2NyaW1pbmF0b3JLZXkgPSB1cGRhdGVbZGlzY3JpbWluYXRvclZhbHVlUGF0aF07XG4gICAgICB9XG5cbiAgICAgIGZvciAoY29uc3QgZmlsdGVyS2V5IG9mIE9iamVjdC5rZXlzKHVwZGF0ZWRQYXRoc0J5RmlsdGVyKSkge1xuICAgICAgICBjb25zdCBzY2hlbWFLZXkgPSB1cGRhdGVkUGF0aHNCeUZpbHRlcltmaWx0ZXJLZXldICsgJy4nICsga2V5O1xuICAgICAgICBjb25zdCBhcnJheUZpbHRlcktleSA9IGZpbHRlcktleSArICcuJyArIGtleTtcbiAgICAgICAgaWYgKHNjaGVtYUtleSA9PT0gZGlzY3JpbWluYXRvckZpbHRlclBhdGgpIHtcbiAgICAgICAgICBjb25zdCBmaWx0ZXIgPSBhcnJheUZpbHRlcnMuZmluZChmaWx0ZXIgPT4gZmlsdGVyLmhhc093blByb3BlcnR5KGFycmF5RmlsdGVyS2V5KSk7XG4gICAgICAgICAgaWYgKGZpbHRlciAhPSBudWxsKSB7XG4gICAgICAgICAgICBkaXNjcmltaW5hdG9yS2V5ID0gZmlsdGVyW2FycmF5RmlsdGVyS2V5XTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGRpc2NyaW1pbmF0b3JLZXkgPT0gbnVsbCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgZGlzY3JpbWluYXRvciA9IGdldERpc2NyaW1pbmF0b3JCeVZhbHVlKHNjaGVtYXR5cGUuY2FzdGVyLmRpc2NyaW1pbmF0b3JzLCBkaXNjcmltaW5hdG9yS2V5KTtcbiAgICAgIGNvbnN0IGRpc2NyaW1pbmF0b3JTY2hlbWEgPSBkaXNjcmltaW5hdG9yICYmIGRpc2NyaW1pbmF0b3Iuc2NoZW1hO1xuICAgICAgaWYgKGRpc2NyaW1pbmF0b3JTY2hlbWEgPT0gbnVsbCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgcmVzdCA9IHBhcnRzLnNsaWNlKGkgKyAxKS5qb2luKCcuJyk7XG4gICAgICBzY2hlbWF0eXBlID0gZGlzY3JpbWluYXRvclNjaGVtYS5wYXRoKHJlc3QpO1xuICAgICAgaWYgKHNjaGVtYXR5cGUgIT0gbnVsbCkge1xuICAgICAgICB0eXBlID0gZGlzY3JpbWluYXRvclNjaGVtYS5fZ2V0UGF0aFR5cGUocmVzdCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7IHR5cGU6IHR5cGUsIHNjaGVtYXR5cGU6IHNjaGVtYXR5cGUgfTtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../server/node_modules/mongoose/lib/helpers/query/getEmbeddedDiscriminatorPath.js\n");

/***/ }),

/***/ "../server/node_modules/mongoose/lib/helpers/query/handleImmutable.js":
/*!****************************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/helpers/query/handleImmutable.js ***!
  \****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst StrictModeError = __webpack_require__(/*! ../../error/strict */ \"../server/node_modules/mongoose/lib/error/strict.js\");\n\nmodule.exports = function handleImmutable(schematype, strict, obj, key, fullPath, ctx) {\n  if (schematype == null || !schematype.options || !schematype.options.immutable) {\n    return false;\n  }\n  let immutable = schematype.options.immutable;\n\n  if (typeof immutable === 'function') {\n    immutable = immutable.call(ctx, ctx);\n  }\n  if (!immutable) {\n    return false;\n  }\n\n  if (strict === false) {\n    return false;\n  }\n  if (strict === 'throw') {\n    throw new StrictModeError(null,\n      `Field ${fullPath} is immutable and strict = 'throw'`);\n  }\n\n  delete obj[key];\n  return true;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9xdWVyeS9oYW5kbGVJbW11dGFibGUuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsd0JBQXdCLG1CQUFPLENBQUMsK0VBQW9COztBQUVwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxVQUFVO0FBQ3pCOztBQUVBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2NsaWVudC8uLi9zZXJ2ZXIvbm9kZV9tb2R1bGVzL21vbmdvb3NlL2xpYi9oZWxwZXJzL3F1ZXJ5L2hhbmRsZUltbXV0YWJsZS5qcz81M2Y3Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3QgU3RyaWN0TW9kZUVycm9yID0gcmVxdWlyZSgnLi4vLi4vZXJyb3Ivc3RyaWN0Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaGFuZGxlSW1tdXRhYmxlKHNjaGVtYXR5cGUsIHN0cmljdCwgb2JqLCBrZXksIGZ1bGxQYXRoLCBjdHgpIHtcbiAgaWYgKHNjaGVtYXR5cGUgPT0gbnVsbCB8fCAhc2NoZW1hdHlwZS5vcHRpb25zIHx8ICFzY2hlbWF0eXBlLm9wdGlvbnMuaW1tdXRhYmxlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGxldCBpbW11dGFibGUgPSBzY2hlbWF0eXBlLm9wdGlvbnMuaW1tdXRhYmxlO1xuXG4gIGlmICh0eXBlb2YgaW1tdXRhYmxlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgaW1tdXRhYmxlID0gaW1tdXRhYmxlLmNhbGwoY3R4LCBjdHgpO1xuICB9XG4gIGlmICghaW1tdXRhYmxlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKHN0cmljdCA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKHN0cmljdCA9PT0gJ3Rocm93Jykge1xuICAgIHRocm93IG5ldyBTdHJpY3RNb2RlRXJyb3IobnVsbCxcbiAgICAgIGBGaWVsZCAke2Z1bGxQYXRofSBpcyBpbW11dGFibGUgYW5kIHN0cmljdCA9ICd0aHJvdydgKTtcbiAgfVxuXG4gIGRlbGV0ZSBvYmpba2V5XTtcbiAgcmV0dXJuIHRydWU7XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../server/node_modules/mongoose/lib/helpers/query/handleImmutable.js\n");

/***/ }),

/***/ "../server/node_modules/mongoose/lib/helpers/query/handleReadPreferenceAliases.js":
/*!****************************************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/helpers/query/handleReadPreferenceAliases.js ***!
  \****************************************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nmodule.exports = function handleReadPreferenceAliases(pref) {\n  switch (pref) {\n    case 'p':\n      pref = 'primary';\n      break;\n    case 'pp':\n      pref = 'primaryPreferred';\n      break;\n    case 's':\n      pref = 'secondary';\n      break;\n    case 'sp':\n      pref = 'secondaryPreferred';\n      break;\n    case 'n':\n      pref = 'nearest';\n      break;\n  }\n\n  return pref;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9xdWVyeS9oYW5kbGVSZWFkUHJlZmVyZW5jZUFsaWFzZXMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbGllbnQvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9xdWVyeS9oYW5kbGVSZWFkUHJlZmVyZW5jZUFsaWFzZXMuanM/ZmE1MCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaGFuZGxlUmVhZFByZWZlcmVuY2VBbGlhc2VzKHByZWYpIHtcbiAgc3dpdGNoIChwcmVmKSB7XG4gICAgY2FzZSAncCc6XG4gICAgICBwcmVmID0gJ3ByaW1hcnknO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAncHAnOlxuICAgICAgcHJlZiA9ICdwcmltYXJ5UHJlZmVycmVkJztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3MnOlxuICAgICAgcHJlZiA9ICdzZWNvbmRhcnknO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnc3AnOlxuICAgICAgcHJlZiA9ICdzZWNvbmRhcnlQcmVmZXJyZWQnO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnbic6XG4gICAgICBwcmVmID0gJ25lYXJlc3QnO1xuICAgICAgYnJlYWs7XG4gIH1cblxuICByZXR1cm4gcHJlZjtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../server/node_modules/mongoose/lib/helpers/query/handleReadPreferenceAliases.js\n");

/***/ }),

/***/ "../server/node_modules/mongoose/lib/helpers/query/hasDollarKeys.js":
/*!**************************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/helpers/query/hasDollarKeys.js ***!
  \**************************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/*!\n * ignore\n */\n\nmodule.exports = function hasDollarKeys(obj) {\n\n  if (typeof obj !== 'object' || obj === null) {\n    return false;\n  }\n\n  const keys = Object.keys(obj);\n  const len = keys.length;\n\n  for (let i = 0; i < len; ++i) {\n    if (keys[i][0] === '$') {\n      return true;\n    }\n  }\n\n  return false;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9xdWVyeS9oYXNEb2xsYXJLZXlzLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxrQkFBa0IsU0FBUztBQUMzQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2xpZW50Ly4uL3NlcnZlci9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvcXVlcnkvaGFzRG9sbGFyS2V5cy5qcz9mMWM4Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGhhc0RvbGxhcktleXMob2JqKSB7XG5cbiAgaWYgKHR5cGVvZiBvYmogIT09ICdvYmplY3QnIHx8IG9iaiA9PT0gbnVsbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhvYmopO1xuICBjb25zdCBsZW4gPSBrZXlzLmxlbmd0aDtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgaWYgKGtleXNbaV1bMF0gPT09ICckJykge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../server/node_modules/mongoose/lib/helpers/query/hasDollarKeys.js\n");

/***/ }),

/***/ "../server/node_modules/mongoose/lib/helpers/query/isOperator.js":
/*!***********************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/helpers/query/isOperator.js ***!
  \***********************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nconst specialKeys = new Set([\n  '$ref',\n  '$id',\n  '$db'\n]);\n\nmodule.exports = function isOperator(path) {\n  return (\n    path[0] === '$' &&\n    !specialKeys.has(path)\n  );\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9xdWVyeS9pc09wZXJhdG9yLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2xpZW50Ly4uL3NlcnZlci9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvcXVlcnkvaXNPcGVyYXRvci5qcz8yM2JlIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3Qgc3BlY2lhbEtleXMgPSBuZXcgU2V0KFtcbiAgJyRyZWYnLFxuICAnJGlkJyxcbiAgJyRkYidcbl0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzT3BlcmF0b3IocGF0aCkge1xuICByZXR1cm4gKFxuICAgIHBhdGhbMF0gPT09ICckJyAmJlxuICAgICFzcGVjaWFsS2V5cy5oYXMocGF0aClcbiAgKTtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../server/node_modules/mongoose/lib/helpers/query/isOperator.js\n");

/***/ }),

/***/ "../server/node_modules/mongoose/lib/helpers/query/sanitizeFilter.js":
/*!***************************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/helpers/query/sanitizeFilter.js ***!
  \***************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst hasDollarKeys = __webpack_require__(/*! ./hasDollarKeys */ \"../server/node_modules/mongoose/lib/helpers/query/hasDollarKeys.js\");\nconst { trustedSymbol } = __webpack_require__(/*! ./trusted */ \"../server/node_modules/mongoose/lib/helpers/query/trusted.js\");\n\nmodule.exports = function sanitizeFilter(filter) {\n  if (filter == null || typeof filter !== 'object') {\n    return filter;\n  }\n  if (Array.isArray(filter)) {\n    for (const subfilter of filter) {\n      sanitizeFilter(subfilter);\n    }\n    return filter;\n  }\n\n  const filterKeys = Object.keys(filter);\n  for (const key of filterKeys) {\n    const value = filter[key];\n    if (value != null && value[trustedSymbol]) {\n      continue;\n    }\n    if (key === '$and' || key === '$or') {\n      sanitizeFilter(value);\n      continue;\n    }\n\n    if (hasDollarKeys(value)) {\n      const keys = Object.keys(value);\n      if (keys.length === 1 && keys[0] === '$eq') {\n        continue;\n      }\n      filter[key] = { $eq: filter[key] };\n    }\n  }\n\n  return filter;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9xdWVyeS9zYW5pdGl6ZUZpbHRlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixzQkFBc0IsbUJBQU8sQ0FBQywyRkFBaUI7QUFDL0MsUUFBUSxnQkFBZ0IsRUFBRSxtQkFBTyxDQUFDLCtFQUFXOztBQUU3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7O0FBRUE7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2NsaWVudC8uLi9zZXJ2ZXIvbm9kZV9tb2R1bGVzL21vbmdvb3NlL2xpYi9oZWxwZXJzL3F1ZXJ5L3Nhbml0aXplRmlsdGVyLmpzP2Y5MTEiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBoYXNEb2xsYXJLZXlzID0gcmVxdWlyZSgnLi9oYXNEb2xsYXJLZXlzJyk7XG5jb25zdCB7IHRydXN0ZWRTeW1ib2wgfSA9IHJlcXVpcmUoJy4vdHJ1c3RlZCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHNhbml0aXplRmlsdGVyKGZpbHRlcikge1xuICBpZiAoZmlsdGVyID09IG51bGwgfHwgdHlwZW9mIGZpbHRlciAhPT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gZmlsdGVyO1xuICB9XG4gIGlmIChBcnJheS5pc0FycmF5KGZpbHRlcikpIHtcbiAgICBmb3IgKGNvbnN0IHN1YmZpbHRlciBvZiBmaWx0ZXIpIHtcbiAgICAgIHNhbml0aXplRmlsdGVyKHN1YmZpbHRlcik7XG4gICAgfVxuICAgIHJldHVybiBmaWx0ZXI7XG4gIH1cblxuICBjb25zdCBmaWx0ZXJLZXlzID0gT2JqZWN0LmtleXMoZmlsdGVyKTtcbiAgZm9yIChjb25zdCBrZXkgb2YgZmlsdGVyS2V5cykge1xuICAgIGNvbnN0IHZhbHVlID0gZmlsdGVyW2tleV07XG4gICAgaWYgKHZhbHVlICE9IG51bGwgJiYgdmFsdWVbdHJ1c3RlZFN5bWJvbF0pIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAoa2V5ID09PSAnJGFuZCcgfHwga2V5ID09PSAnJG9yJykge1xuICAgICAgc2FuaXRpemVGaWx0ZXIodmFsdWUpO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKGhhc0RvbGxhcktleXModmFsdWUpKSB7XG4gICAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXModmFsdWUpO1xuICAgICAgaWYgKGtleXMubGVuZ3RoID09PSAxICYmIGtleXNbMF0gPT09ICckZXEnKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgZmlsdGVyW2tleV0gPSB7ICRlcTogZmlsdGVyW2tleV0gfTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmlsdGVyO1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../server/node_modules/mongoose/lib/helpers/query/sanitizeFilter.js\n");

/***/ }),

/***/ "../server/node_modules/mongoose/lib/helpers/query/sanitizeProjection.js":
/*!*******************************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/helpers/query/sanitizeProjection.js ***!
  \*******************************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nmodule.exports = function sanitizeProjection(projection) {\n  if (projection == null) {\n    return;\n  }\n\n  const keys = Object.keys(projection);\n  for (let i = 0; i < keys.length; ++i) {\n    if (typeof projection[keys[i]] === 'string') {\n      projection[keys[i]] = 1;\n    }\n  }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9xdWVyeS9zYW5pdGl6ZVByb2plY3Rpb24uanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0IsaUJBQWlCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbGllbnQvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9xdWVyeS9zYW5pdGl6ZVByb2plY3Rpb24uanM/OGQ0NyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gc2FuaXRpemVQcm9qZWN0aW9uKHByb2plY3Rpb24pIHtcbiAgaWYgKHByb2plY3Rpb24gPT0gbnVsbCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhwcm9qZWN0aW9uKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKSB7XG4gICAgaWYgKHR5cGVvZiBwcm9qZWN0aW9uW2tleXNbaV1dID09PSAnc3RyaW5nJykge1xuICAgICAgcHJvamVjdGlvbltrZXlzW2ldXSA9IDE7XG4gICAgfVxuICB9XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../server/node_modules/mongoose/lib/helpers/query/sanitizeProjection.js\n");

/***/ }),

/***/ "../server/node_modules/mongoose/lib/helpers/query/selectPopulatedFields.js":
/*!**********************************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/helpers/query/selectPopulatedFields.js ***!
  \**********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst isExclusive = __webpack_require__(/*! ../projection/isExclusive */ \"../server/node_modules/mongoose/lib/helpers/projection/isExclusive.js\");\nconst isInclusive = __webpack_require__(/*! ../projection/isInclusive */ \"../server/node_modules/mongoose/lib/helpers/projection/isInclusive.js\");\n\n/*!\n * ignore\n */\n\nmodule.exports = function selectPopulatedFields(fields, userProvidedFields, populateOptions) {\n  if (populateOptions == null) {\n    return;\n  }\n\n  const paths = Object.keys(populateOptions);\n  userProvidedFields = userProvidedFields || {};\n  if (isInclusive(fields)) {\n    for (const path of paths) {\n      if (!isPathInFields(userProvidedFields, path)) {\n        fields[path] = 1;\n      } else if (userProvidedFields[path] === 0) {\n        delete fields[path];\n      }\n\n      const refPath = populateOptions[path]?.refPath;\n      if (typeof refPath === 'string') {\n        if (!isPathInFields(userProvidedFields, refPath)) {\n          fields[refPath] = 1;\n        } else if (userProvidedFields[refPath] === 0) {\n          delete fields[refPath];\n        }\n      }\n    }\n  } else if (isExclusive(fields)) {\n    for (const path of paths) {\n      if (userProvidedFields[path] == null) {\n        delete fields[path];\n      }\n      const refPath = populateOptions[path]?.refPath;\n      if (typeof refPath === 'string' && userProvidedFields[refPath] == null) {\n        delete fields[refPath];\n      }\n    }\n  }\n};\n\n/*!\n * ignore\n */\n\nfunction isPathInFields(userProvidedFields, path) {\n  const pieces = path.split('.');\n  const len = pieces.length;\n  let cur = pieces[0];\n  for (let i = 1; i < len; ++i) {\n    if (userProvidedFields[cur] != null || userProvidedFields[cur + '.$'] != null) {\n      return true;\n    }\n    cur += '.' + pieces[i];\n  }\n  return userProvidedFields[cur] != null || userProvidedFields[cur + '.$'] != null;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9xdWVyeS9zZWxlY3RQb3B1bGF0ZWRGaWVsZHMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsb0JBQW9CLG1CQUFPLENBQUMsd0dBQTJCO0FBQ3ZELG9CQUFvQixtQkFBTyxDQUFDLHdHQUEyQjs7QUFFdkQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFNBQVM7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbGllbnQvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9xdWVyeS9zZWxlY3RQb3B1bGF0ZWRGaWVsZHMuanM/NmY3NSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IGlzRXhjbHVzaXZlID0gcmVxdWlyZSgnLi4vcHJvamVjdGlvbi9pc0V4Y2x1c2l2ZScpO1xuY29uc3QgaXNJbmNsdXNpdmUgPSByZXF1aXJlKCcuLi9wcm9qZWN0aW9uL2lzSW5jbHVzaXZlJyk7XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBzZWxlY3RQb3B1bGF0ZWRGaWVsZHMoZmllbGRzLCB1c2VyUHJvdmlkZWRGaWVsZHMsIHBvcHVsYXRlT3B0aW9ucykge1xuICBpZiAocG9wdWxhdGVPcHRpb25zID09IG51bGwpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBjb25zdCBwYXRocyA9IE9iamVjdC5rZXlzKHBvcHVsYXRlT3B0aW9ucyk7XG4gIHVzZXJQcm92aWRlZEZpZWxkcyA9IHVzZXJQcm92aWRlZEZpZWxkcyB8fCB7fTtcbiAgaWYgKGlzSW5jbHVzaXZlKGZpZWxkcykpIHtcbiAgICBmb3IgKGNvbnN0IHBhdGggb2YgcGF0aHMpIHtcbiAgICAgIGlmICghaXNQYXRoSW5GaWVsZHModXNlclByb3ZpZGVkRmllbGRzLCBwYXRoKSkge1xuICAgICAgICBmaWVsZHNbcGF0aF0gPSAxO1xuICAgICAgfSBlbHNlIGlmICh1c2VyUHJvdmlkZWRGaWVsZHNbcGF0aF0gPT09IDApIHtcbiAgICAgICAgZGVsZXRlIGZpZWxkc1twYXRoXTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgcmVmUGF0aCA9IHBvcHVsYXRlT3B0aW9uc1twYXRoXT8ucmVmUGF0aDtcbiAgICAgIGlmICh0eXBlb2YgcmVmUGF0aCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgaWYgKCFpc1BhdGhJbkZpZWxkcyh1c2VyUHJvdmlkZWRGaWVsZHMsIHJlZlBhdGgpKSB7XG4gICAgICAgICAgZmllbGRzW3JlZlBhdGhdID0gMTtcbiAgICAgICAgfSBlbHNlIGlmICh1c2VyUHJvdmlkZWRGaWVsZHNbcmVmUGF0aF0gPT09IDApIHtcbiAgICAgICAgICBkZWxldGUgZmllbGRzW3JlZlBhdGhdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzRXhjbHVzaXZlKGZpZWxkcykpIHtcbiAgICBmb3IgKGNvbnN0IHBhdGggb2YgcGF0aHMpIHtcbiAgICAgIGlmICh1c2VyUHJvdmlkZWRGaWVsZHNbcGF0aF0gPT0gbnVsbCkge1xuICAgICAgICBkZWxldGUgZmllbGRzW3BhdGhdO1xuICAgICAgfVxuICAgICAgY29uc3QgcmVmUGF0aCA9IHBvcHVsYXRlT3B0aW9uc1twYXRoXT8ucmVmUGF0aDtcbiAgICAgIGlmICh0eXBlb2YgcmVmUGF0aCA9PT0gJ3N0cmluZycgJiYgdXNlclByb3ZpZGVkRmllbGRzW3JlZlBhdGhdID09IG51bGwpIHtcbiAgICAgICAgZGVsZXRlIGZpZWxkc1tyZWZQYXRoXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxuZnVuY3Rpb24gaXNQYXRoSW5GaWVsZHModXNlclByb3ZpZGVkRmllbGRzLCBwYXRoKSB7XG4gIGNvbnN0IHBpZWNlcyA9IHBhdGguc3BsaXQoJy4nKTtcbiAgY29uc3QgbGVuID0gcGllY2VzLmxlbmd0aDtcbiAgbGV0IGN1ciA9IHBpZWNlc1swXTtcbiAgZm9yIChsZXQgaSA9IDE7IGkgPCBsZW47ICsraSkge1xuICAgIGlmICh1c2VyUHJvdmlkZWRGaWVsZHNbY3VyXSAhPSBudWxsIHx8IHVzZXJQcm92aWRlZEZpZWxkc1tjdXIgKyAnLiQnXSAhPSBudWxsKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgY3VyICs9ICcuJyArIHBpZWNlc1tpXTtcbiAgfVxuICByZXR1cm4gdXNlclByb3ZpZGVkRmllbGRzW2N1cl0gIT0gbnVsbCB8fCB1c2VyUHJvdmlkZWRGaWVsZHNbY3VyICsgJy4kJ10gIT0gbnVsbDtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../server/node_modules/mongoose/lib/helpers/query/selectPopulatedFields.js\n");

/***/ }),

/***/ "../server/node_modules/mongoose/lib/helpers/query/trusted.js":
/*!********************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/helpers/query/trusted.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\nconst trustedSymbol = Symbol('mongoose#trustedSymbol');\n\nexports.trustedSymbol = trustedSymbol;\n\nexports.trusted = function trusted(obj) {\n  if (obj == null || typeof obj !== 'object') {\n    return obj;\n  }\n  obj[trustedSymbol] = true;\n  return obj;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9xdWVyeS90cnVzdGVkLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViOztBQUVBLHFCQUFxQjs7QUFFckIsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2NsaWVudC8uLi9zZXJ2ZXIvbm9kZV9tb2R1bGVzL21vbmdvb3NlL2xpYi9oZWxwZXJzL3F1ZXJ5L3RydXN0ZWQuanM/MjgwNCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IHRydXN0ZWRTeW1ib2wgPSBTeW1ib2woJ21vbmdvb3NlI3RydXN0ZWRTeW1ib2wnKTtcblxuZXhwb3J0cy50cnVzdGVkU3ltYm9sID0gdHJ1c3RlZFN5bWJvbDtcblxuZXhwb3J0cy50cnVzdGVkID0gZnVuY3Rpb24gdHJ1c3RlZChvYmopIHtcbiAgaWYgKG9iaiA9PSBudWxsIHx8IHR5cGVvZiBvYmogIT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIG9iajtcbiAgfVxuICBvYmpbdHJ1c3RlZFN5bWJvbF0gPSB0cnVlO1xuICByZXR1cm4gb2JqO1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../server/node_modules/mongoose/lib/helpers/query/trusted.js\n");

/***/ }),

/***/ "../server/node_modules/mongoose/lib/helpers/schema/addAutoId.js":
/*!***********************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/helpers/schema/addAutoId.js ***!
  \***********************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nmodule.exports = function addAutoId(schema) {\n  const _obj = { _id: { auto: true } };\n  _obj._id[schema.options.typeKey] = 'ObjectId';\n  schema.add(_obj);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9zY2hlbWEvYWRkQXV0b0lkLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0EsaUJBQWlCLE9BQU87QUFDeEI7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2xpZW50Ly4uL3NlcnZlci9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvc2NoZW1hL2FkZEF1dG9JZC5qcz85MTliIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBhZGRBdXRvSWQoc2NoZW1hKSB7XG4gIGNvbnN0IF9vYmogPSB7IF9pZDogeyBhdXRvOiB0cnVlIH0gfTtcbiAgX29iai5faWRbc2NoZW1hLm9wdGlvbnMudHlwZUtleV0gPSAnT2JqZWN0SWQnO1xuICBzY2hlbWEuYWRkKF9vYmopO1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../server/node_modules/mongoose/lib/helpers/schema/addAutoId.js\n");

/***/ }),

/***/ "../server/node_modules/mongoose/lib/helpers/schema/applyBuiltinPlugins.js":
/*!*********************************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/helpers/schema/applyBuiltinPlugins.js ***!
  \*********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst builtinPlugins = __webpack_require__(/*! ../../plugins */ \"../server/node_modules/mongoose/lib/plugins/index.js\");\n\nmodule.exports = function applyBuiltinPlugins(schema) {\n  for (const plugin of Object.values(builtinPlugins)) {\n    plugin(schema, { deduplicate: true });\n  }\n  schema.plugins = Object.values(builtinPlugins).\n    map(fn => ({ fn, opts: { deduplicate: true } })).\n    concat(schema.plugins);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9zY2hlbWEvYXBwbHlCdWlsdGluUGx1Z2lucy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYix1QkFBdUIsbUJBQU8sQ0FBQywyRUFBZTs7QUFFOUM7QUFDQTtBQUNBLHFCQUFxQixtQkFBbUI7QUFDeEM7QUFDQTtBQUNBLGlCQUFpQixZQUFZLHFCQUFxQjtBQUNsRDtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2xpZW50Ly4uL3NlcnZlci9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvc2NoZW1hL2FwcGx5QnVpbHRpblBsdWdpbnMuanM/YzY3MSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IGJ1aWx0aW5QbHVnaW5zID0gcmVxdWlyZSgnLi4vLi4vcGx1Z2lucycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGFwcGx5QnVpbHRpblBsdWdpbnMoc2NoZW1hKSB7XG4gIGZvciAoY29uc3QgcGx1Z2luIG9mIE9iamVjdC52YWx1ZXMoYnVpbHRpblBsdWdpbnMpKSB7XG4gICAgcGx1Z2luKHNjaGVtYSwgeyBkZWR1cGxpY2F0ZTogdHJ1ZSB9KTtcbiAgfVxuICBzY2hlbWEucGx1Z2lucyA9IE9iamVjdC52YWx1ZXMoYnVpbHRpblBsdWdpbnMpLlxuICAgIG1hcChmbiA9PiAoeyBmbiwgb3B0czogeyBkZWR1cGxpY2F0ZTogdHJ1ZSB9IH0pKS5cbiAgICBjb25jYXQoc2NoZW1hLnBsdWdpbnMpO1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../server/node_modules/mongoose/lib/helpers/schema/applyBuiltinPlugins.js\n");

/***/ }),

/***/ "../server/node_modules/mongoose/lib/helpers/schema/applyPlugins.js":
/*!**************************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/helpers/schema/applyPlugins.js ***!
  \**************************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nmodule.exports = function applyPlugins(schema, plugins, options, cacheKey) {\n  if (schema[cacheKey]) {\n    return;\n  }\n  schema[cacheKey] = true;\n\n  if (!options || !options.skipTopLevel) {\n    let pluginTags = null;\n    for (const plugin of plugins) {\n      const tags = plugin[1] == null ? null : plugin[1].tags;\n      if (!Array.isArray(tags)) {\n        schema.plugin(plugin[0], plugin[1]);\n        continue;\n      }\n\n      pluginTags = pluginTags || new Set(schema.options.pluginTags || []);\n      if (!tags.find(tag => pluginTags.has(tag))) {\n        continue;\n      }\n      schema.plugin(plugin[0], plugin[1]);\n    }\n  }\n\n  options = Object.assign({}, options);\n  delete options.skipTopLevel;\n\n  if (options.applyPluginsToChildSchemas !== false) {\n    for (const path of Object.keys(schema.paths)) {\n      const type = schema.paths[path];\n      if (type.schema != null) {\n        applyPlugins(type.schema, plugins, options, cacheKey);\n\n        // Recompile schema because plugins may have changed it, see gh-7572\n        type.caster.prototype.$__setSchema(type.schema);\n      }\n    }\n  }\n\n  const discriminators = schema.discriminators;\n  if (discriminators == null) {\n    return;\n  }\n\n  const applyPluginsToDiscriminators = options.applyPluginsToDiscriminators;\n\n  const keys = Object.keys(discriminators);\n  for (const discriminatorKey of keys) {\n    const discriminatorSchema = discriminators[discriminatorKey];\n\n    applyPlugins(discriminatorSchema, plugins,\n      { skipTopLevel: !applyPluginsToDiscriminators }, cacheKey);\n  }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9zY2hlbWEvYXBwbHlQbHVnaW5zLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw0QkFBNEI7QUFDNUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVEsNkNBQTZDO0FBQ3JEO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbGllbnQvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9zY2hlbWEvYXBwbHlQbHVnaW5zLmpzP2I3ZTYiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGFwcGx5UGx1Z2lucyhzY2hlbWEsIHBsdWdpbnMsIG9wdGlvbnMsIGNhY2hlS2V5KSB7XG4gIGlmIChzY2hlbWFbY2FjaGVLZXldKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHNjaGVtYVtjYWNoZUtleV0gPSB0cnVlO1xuXG4gIGlmICghb3B0aW9ucyB8fCAhb3B0aW9ucy5za2lwVG9wTGV2ZWwpIHtcbiAgICBsZXQgcGx1Z2luVGFncyA9IG51bGw7XG4gICAgZm9yIChjb25zdCBwbHVnaW4gb2YgcGx1Z2lucykge1xuICAgICAgY29uc3QgdGFncyA9IHBsdWdpblsxXSA9PSBudWxsID8gbnVsbCA6IHBsdWdpblsxXS50YWdzO1xuICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHRhZ3MpKSB7XG4gICAgICAgIHNjaGVtYS5wbHVnaW4ocGx1Z2luWzBdLCBwbHVnaW5bMV0pO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgcGx1Z2luVGFncyA9IHBsdWdpblRhZ3MgfHwgbmV3IFNldChzY2hlbWEub3B0aW9ucy5wbHVnaW5UYWdzIHx8IFtdKTtcbiAgICAgIGlmICghdGFncy5maW5kKHRhZyA9PiBwbHVnaW5UYWdzLmhhcyh0YWcpKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHNjaGVtYS5wbHVnaW4ocGx1Z2luWzBdLCBwbHVnaW5bMV0pO1xuICAgIH1cbiAgfVxuXG4gIG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zKTtcbiAgZGVsZXRlIG9wdGlvbnMuc2tpcFRvcExldmVsO1xuXG4gIGlmIChvcHRpb25zLmFwcGx5UGx1Z2luc1RvQ2hpbGRTY2hlbWFzICE9PSBmYWxzZSkge1xuICAgIGZvciAoY29uc3QgcGF0aCBvZiBPYmplY3Qua2V5cyhzY2hlbWEucGF0aHMpKSB7XG4gICAgICBjb25zdCB0eXBlID0gc2NoZW1hLnBhdGhzW3BhdGhdO1xuICAgICAgaWYgKHR5cGUuc2NoZW1hICE9IG51bGwpIHtcbiAgICAgICAgYXBwbHlQbHVnaW5zKHR5cGUuc2NoZW1hLCBwbHVnaW5zLCBvcHRpb25zLCBjYWNoZUtleSk7XG5cbiAgICAgICAgLy8gUmVjb21waWxlIHNjaGVtYSBiZWNhdXNlIHBsdWdpbnMgbWF5IGhhdmUgY2hhbmdlZCBpdCwgc2VlIGdoLTc1NzJcbiAgICAgICAgdHlwZS5jYXN0ZXIucHJvdG90eXBlLiRfX3NldFNjaGVtYSh0eXBlLnNjaGVtYSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgY29uc3QgZGlzY3JpbWluYXRvcnMgPSBzY2hlbWEuZGlzY3JpbWluYXRvcnM7XG4gIGlmIChkaXNjcmltaW5hdG9ycyA9PSBudWxsKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29uc3QgYXBwbHlQbHVnaW5zVG9EaXNjcmltaW5hdG9ycyA9IG9wdGlvbnMuYXBwbHlQbHVnaW5zVG9EaXNjcmltaW5hdG9ycztcblxuICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoZGlzY3JpbWluYXRvcnMpO1xuICBmb3IgKGNvbnN0IGRpc2NyaW1pbmF0b3JLZXkgb2Yga2V5cykge1xuICAgIGNvbnN0IGRpc2NyaW1pbmF0b3JTY2hlbWEgPSBkaXNjcmltaW5hdG9yc1tkaXNjcmltaW5hdG9yS2V5XTtcblxuICAgIGFwcGx5UGx1Z2lucyhkaXNjcmltaW5hdG9yU2NoZW1hLCBwbHVnaW5zLFxuICAgICAgeyBza2lwVG9wTGV2ZWw6ICFhcHBseVBsdWdpbnNUb0Rpc2NyaW1pbmF0b3JzIH0sIGNhY2hlS2V5KTtcbiAgfVxufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../server/node_modules/mongoose/lib/helpers/schema/applyPlugins.js\n");

/***/ }),

/***/ "../server/node_modules/mongoose/lib/helpers/schema/applyWriteConcern.js":
/*!*******************************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/helpers/schema/applyWriteConcern.js ***!
  \*******************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst get = __webpack_require__(/*! ../get */ \"../server/node_modules/mongoose/lib/helpers/get.js\");\n\nmodule.exports = function applyWriteConcern(schema, options) {\n  if (options.writeConcern != null) {\n    return;\n  }\n  const writeConcern = get(schema, 'options.writeConcern', {});\n  if (Object.keys(writeConcern).length != 0) {\n    options.writeConcern = {};\n    if (!('w' in options) && writeConcern.w != null) {\n      options.writeConcern.w = writeConcern.w;\n    }\n    if (!('j' in options) && writeConcern.j != null) {\n      options.writeConcern.j = writeConcern.j;\n    }\n    if (!('wtimeout' in options) && writeConcern.wtimeout != null) {\n      options.writeConcern.wtimeout = writeConcern.wtimeout;\n    }\n  }\n  else {\n    if (!('w' in options) && writeConcern.w != null) {\n      options.w = writeConcern.w;\n    }\n    if (!('j' in options) && writeConcern.j != null) {\n      options.j = writeConcern.j;\n    }\n    if (!('wtimeout' in options) && writeConcern.wtimeout != null) {\n      options.wtimeout = writeConcern.wtimeout;\n    }\n  }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9zY2hlbWEvYXBwbHlXcml0ZUNvbmNlcm4uanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsWUFBWSxtQkFBTyxDQUFDLGtFQUFROztBQUU1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RDtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbGllbnQvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9zY2hlbWEvYXBwbHlXcml0ZUNvbmNlcm4uanM/YjVhYSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IGdldCA9IHJlcXVpcmUoJy4uL2dldCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGFwcGx5V3JpdGVDb25jZXJuKHNjaGVtYSwgb3B0aW9ucykge1xuICBpZiAob3B0aW9ucy53cml0ZUNvbmNlcm4gIT0gbnVsbCkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCB3cml0ZUNvbmNlcm4gPSBnZXQoc2NoZW1hLCAnb3B0aW9ucy53cml0ZUNvbmNlcm4nLCB7fSk7XG4gIGlmIChPYmplY3Qua2V5cyh3cml0ZUNvbmNlcm4pLmxlbmd0aCAhPSAwKSB7XG4gICAgb3B0aW9ucy53cml0ZUNvbmNlcm4gPSB7fTtcbiAgICBpZiAoISgndycgaW4gb3B0aW9ucykgJiYgd3JpdGVDb25jZXJuLncgIT0gbnVsbCkge1xuICAgICAgb3B0aW9ucy53cml0ZUNvbmNlcm4udyA9IHdyaXRlQ29uY2Vybi53O1xuICAgIH1cbiAgICBpZiAoISgnaicgaW4gb3B0aW9ucykgJiYgd3JpdGVDb25jZXJuLmogIT0gbnVsbCkge1xuICAgICAgb3B0aW9ucy53cml0ZUNvbmNlcm4uaiA9IHdyaXRlQ29uY2Vybi5qO1xuICAgIH1cbiAgICBpZiAoISgnd3RpbWVvdXQnIGluIG9wdGlvbnMpICYmIHdyaXRlQ29uY2Vybi53dGltZW91dCAhPSBudWxsKSB7XG4gICAgICBvcHRpb25zLndyaXRlQ29uY2Vybi53dGltZW91dCA9IHdyaXRlQ29uY2Vybi53dGltZW91dDtcbiAgICB9XG4gIH1cbiAgZWxzZSB7XG4gICAgaWYgKCEoJ3cnIGluIG9wdGlvbnMpICYmIHdyaXRlQ29uY2Vybi53ICE9IG51bGwpIHtcbiAgICAgIG9wdGlvbnMudyA9IHdyaXRlQ29uY2Vybi53O1xuICAgIH1cbiAgICBpZiAoISgnaicgaW4gb3B0aW9ucykgJiYgd3JpdGVDb25jZXJuLmogIT0gbnVsbCkge1xuICAgICAgb3B0aW9ucy5qID0gd3JpdGVDb25jZXJuLmo7XG4gICAgfVxuICAgIGlmICghKCd3dGltZW91dCcgaW4gb3B0aW9ucykgJiYgd3JpdGVDb25jZXJuLnd0aW1lb3V0ICE9IG51bGwpIHtcbiAgICAgIG9wdGlvbnMud3RpbWVvdXQgPSB3cml0ZUNvbmNlcm4ud3RpbWVvdXQ7XG4gICAgfVxuICB9XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../server/node_modules/mongoose/lib/helpers/schema/applyWriteConcern.js\n");

/***/ }),

/***/ "../server/node_modules/mongoose/lib/helpers/schema/cleanPositionalOperators.js":
/*!**************************************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/helpers/schema/cleanPositionalOperators.js ***!
  \**************************************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/**\n * For consistency's sake, we replace positional operator `$` and array filters\n * `$[]` and `$[foo]` with `0` when looking up schema paths.\n */\n\nmodule.exports = function cleanPositionalOperators(path) {\n  return path.\n    replace(/\\.\\$(\\[[^\\]]*\\])?(?=\\.)/g, '.0').\n    replace(/\\.\\$(\\[[^\\]]*\\])?$/g, '.0');\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9zY2hlbWEvY2xlYW5Qb3NpdGlvbmFsT3BlcmF0b3JzLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbGllbnQvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9zY2hlbWEvY2xlYW5Qb3NpdGlvbmFsT3BlcmF0b3JzLmpzP2QyMDQiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIEZvciBjb25zaXN0ZW5jeSdzIHNha2UsIHdlIHJlcGxhY2UgcG9zaXRpb25hbCBvcGVyYXRvciBgJGAgYW5kIGFycmF5IGZpbHRlcnNcbiAqIGAkW11gIGFuZCBgJFtmb29dYCB3aXRoIGAwYCB3aGVuIGxvb2tpbmcgdXAgc2NoZW1hIHBhdGhzLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gY2xlYW5Qb3NpdGlvbmFsT3BlcmF0b3JzKHBhdGgpIHtcbiAgcmV0dXJuIHBhdGguXG4gICAgcmVwbGFjZSgvXFwuXFwkKFxcW1teXFxdXSpcXF0pPyg/PVxcLikvZywgJy4wJykuXG4gICAgcmVwbGFjZSgvXFwuXFwkKFxcW1teXFxdXSpcXF0pPyQvZywgJy4wJyk7XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../server/node_modules/mongoose/lib/helpers/schema/cleanPositionalOperators.js\n");

/***/ }),

/***/ "../server/node_modules/mongoose/lib/helpers/schema/getIndexes.js":
/*!************************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/helpers/schema/getIndexes.js ***!
  \************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst get = __webpack_require__(/*! ../get */ \"../server/node_modules/mongoose/lib/helpers/get.js\");\nconst helperIsObject = __webpack_require__(/*! ../isObject */ \"../server/node_modules/mongoose/lib/helpers/isObject.js\");\nconst decorateDiscriminatorIndexOptions = __webpack_require__(/*! ../indexes/decorateDiscriminatorIndexOptions */ \"../server/node_modules/mongoose/lib/helpers/indexes/decorateDiscriminatorIndexOptions.js\");\n\n/**\n * Gather all indexes defined in the schema, including single nested,\n * document arrays, and embedded discriminators.\n * @param {Schema} schema\n * @api private\n */\n\nmodule.exports = function getIndexes(schema) {\n  let indexes = [];\n  const schemaStack = new WeakMap();\n  const indexTypes = schema.constructor.indexTypes;\n  const indexByName = new Map();\n\n  collectIndexes(schema);\n  return indexes;\n\n  function collectIndexes(schema, prefix, baseSchema) {\n    // Ignore infinitely nested schemas, if we've already seen this schema\n    // along this path there must be a cycle\n    if (schemaStack.has(schema)) {\n      return;\n    }\n    schemaStack.set(schema, true);\n\n    prefix = prefix || '';\n    const keys = Object.keys(schema.paths);\n\n    for (const key of keys) {\n      const path = schema.paths[key];\n      if (baseSchema != null && baseSchema.paths[key]) {\n        // If looking at an embedded discriminator schema, don't look at paths\n        // that the\n        continue;\n      }\n\n      if (path.$isMongooseDocumentArray || path.$isSingleNested) {\n        if (get(path, 'options.excludeIndexes') !== true &&\n            get(path, 'schemaOptions.excludeIndexes') !== true &&\n            get(path, 'schema.options.excludeIndexes') !== true) {\n          collectIndexes(path.schema, prefix + key + '.');\n        }\n\n        if (path.schema.discriminators != null) {\n          const discriminators = path.schema.discriminators;\n          const discriminatorKeys = Object.keys(discriminators);\n          for (const discriminatorKey of discriminatorKeys) {\n            collectIndexes(discriminators[discriminatorKey],\n              prefix + key + '.', path.schema);\n          }\n        }\n\n        // Retained to minimize risk of backwards breaking changes due to\n        // gh-6113\n        if (path.$isMongooseDocumentArray) {\n          continue;\n        }\n      }\n\n      const index = path._index || (path.caster && path.caster._index);\n\n      if (index !== false && index !== null && index !== undefined) {\n        const field = {};\n        const isObject = helperIsObject(index);\n        const options = isObject ? index : {};\n        const type = typeof index === 'string' ? index :\n          isObject ? index.type :\n            false;\n\n        if (type && indexTypes.indexOf(type) !== -1) {\n          field[prefix + key] = type;\n        } else if (options.text) {\n          field[prefix + key] = 'text';\n          delete options.text;\n        } else {\n          let isDescendingIndex = false;\n          if (index === 'descending' || index === 'desc') {\n            isDescendingIndex = true;\n          } else if (index === 'ascending' || index === 'asc') {\n            isDescendingIndex = false;\n          } else {\n            isDescendingIndex = Number(index) === -1;\n          }\n\n          field[prefix + key] = isDescendingIndex ? -1 : 1;\n        }\n\n        delete options.type;\n        if (!('background' in options)) {\n          options.background = true;\n        }\n        if (schema.options.autoIndex != null) {\n          options._autoIndex = schema.options.autoIndex;\n        }\n\n        const indexName = options && options.name;\n\n        if (typeof indexName === 'string') {\n          if (indexByName.has(indexName)) {\n            Object.assign(indexByName.get(indexName), field);\n          } else {\n            indexes.push([field, options]);\n            indexByName.set(indexName, field);\n          }\n        } else {\n          indexes.push([field, options]);\n          indexByName.set(indexName, field);\n        }\n      }\n    }\n\n    schemaStack.delete(schema);\n\n    if (prefix) {\n      fixSubIndexPaths(schema, prefix);\n    } else {\n      schema._indexes.forEach(function(index) {\n        const options = index[1];\n        if (!('background' in options)) {\n          options.background = true;\n        }\n        decorateDiscriminatorIndexOptions(schema, options);\n      });\n      indexes = indexes.concat(schema._indexes);\n    }\n  }\n\n  /**\n   * Checks for indexes added to subdocs using Schema.index().\n   * These indexes need their paths prefixed properly.\n   *\n   * schema._indexes = [ [indexObj, options], [indexObj, options] ..]\n   * @param {Schema} schema\n   * @param {String} prefix\n   * @api private\n   */\n\n  function fixSubIndexPaths(schema, prefix) {\n    const subindexes = schema._indexes;\n    const len = subindexes.length;\n    for (let i = 0; i < len; ++i) {\n      const indexObj = subindexes[i][0];\n      const indexOptions = subindexes[i][1];\n      const keys = Object.keys(indexObj);\n      const klen = keys.length;\n      const newindex = {};\n\n      // use forward iteration, order matters\n      for (let j = 0; j < klen; ++j) {\n        const key = keys[j];\n        newindex[prefix + key] = indexObj[key];\n      }\n\n      const newIndexOptions = Object.assign({}, indexOptions);\n      if (indexOptions != null && indexOptions.partialFilterExpression != null) {\n        newIndexOptions.partialFilterExpression = {};\n        const partialFilterExpression = indexOptions.partialFilterExpression;\n        for (const key of Object.keys(partialFilterExpression)) {\n          newIndexOptions.partialFilterExpression[prefix + key] =\n            partialFilterExpression[key];\n        }\n      }\n\n      indexes.push([newindex, newIndexOptions]);\n    }\n  }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9zY2hlbWEvZ2V0SW5kZXhlcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixZQUFZLG1CQUFPLENBQUMsa0VBQVE7QUFDNUIsdUJBQXVCLG1CQUFPLENBQUMsNEVBQWE7QUFDNUMsMENBQTBDLG1CQUFPLENBQUMsOElBQThDOztBQUVoRztBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzQkFBc0IsVUFBVTtBQUNoQztBQUNBO0FBQ0E7O0FBRUEsOENBQThDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbGllbnQvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9zY2hlbWEvZ2V0SW5kZXhlcy5qcz83NjQzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3QgZ2V0ID0gcmVxdWlyZSgnLi4vZ2V0Jyk7XG5jb25zdCBoZWxwZXJJc09iamVjdCA9IHJlcXVpcmUoJy4uL2lzT2JqZWN0Jyk7XG5jb25zdCBkZWNvcmF0ZURpc2NyaW1pbmF0b3JJbmRleE9wdGlvbnMgPSByZXF1aXJlKCcuLi9pbmRleGVzL2RlY29yYXRlRGlzY3JpbWluYXRvckluZGV4T3B0aW9ucycpO1xuXG4vKipcbiAqIEdhdGhlciBhbGwgaW5kZXhlcyBkZWZpbmVkIGluIHRoZSBzY2hlbWEsIGluY2x1ZGluZyBzaW5nbGUgbmVzdGVkLFxuICogZG9jdW1lbnQgYXJyYXlzLCBhbmQgZW1iZWRkZWQgZGlzY3JpbWluYXRvcnMuXG4gKiBAcGFyYW0ge1NjaGVtYX0gc2NoZW1hXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGdldEluZGV4ZXMoc2NoZW1hKSB7XG4gIGxldCBpbmRleGVzID0gW107XG4gIGNvbnN0IHNjaGVtYVN0YWNrID0gbmV3IFdlYWtNYXAoKTtcbiAgY29uc3QgaW5kZXhUeXBlcyA9IHNjaGVtYS5jb25zdHJ1Y3Rvci5pbmRleFR5cGVzO1xuICBjb25zdCBpbmRleEJ5TmFtZSA9IG5ldyBNYXAoKTtcblxuICBjb2xsZWN0SW5kZXhlcyhzY2hlbWEpO1xuICByZXR1cm4gaW5kZXhlcztcblxuICBmdW5jdGlvbiBjb2xsZWN0SW5kZXhlcyhzY2hlbWEsIHByZWZpeCwgYmFzZVNjaGVtYSkge1xuICAgIC8vIElnbm9yZSBpbmZpbml0ZWx5IG5lc3RlZCBzY2hlbWFzLCBpZiB3ZSd2ZSBhbHJlYWR5IHNlZW4gdGhpcyBzY2hlbWFcbiAgICAvLyBhbG9uZyB0aGlzIHBhdGggdGhlcmUgbXVzdCBiZSBhIGN5Y2xlXG4gICAgaWYgKHNjaGVtYVN0YWNrLmhhcyhzY2hlbWEpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHNjaGVtYVN0YWNrLnNldChzY2hlbWEsIHRydWUpO1xuXG4gICAgcHJlZml4ID0gcHJlZml4IHx8ICcnO1xuICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhzY2hlbWEucGF0aHMpO1xuXG4gICAgZm9yIChjb25zdCBrZXkgb2Yga2V5cykge1xuICAgICAgY29uc3QgcGF0aCA9IHNjaGVtYS5wYXRoc1trZXldO1xuICAgICAgaWYgKGJhc2VTY2hlbWEgIT0gbnVsbCAmJiBiYXNlU2NoZW1hLnBhdGhzW2tleV0pIHtcbiAgICAgICAgLy8gSWYgbG9va2luZyBhdCBhbiBlbWJlZGRlZCBkaXNjcmltaW5hdG9yIHNjaGVtYSwgZG9uJ3QgbG9vayBhdCBwYXRoc1xuICAgICAgICAvLyB0aGF0IHRoZVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHBhdGguJGlzTW9uZ29vc2VEb2N1bWVudEFycmF5IHx8IHBhdGguJGlzU2luZ2xlTmVzdGVkKSB7XG4gICAgICAgIGlmIChnZXQocGF0aCwgJ29wdGlvbnMuZXhjbHVkZUluZGV4ZXMnKSAhPT0gdHJ1ZSAmJlxuICAgICAgICAgICAgZ2V0KHBhdGgsICdzY2hlbWFPcHRpb25zLmV4Y2x1ZGVJbmRleGVzJykgIT09IHRydWUgJiZcbiAgICAgICAgICAgIGdldChwYXRoLCAnc2NoZW1hLm9wdGlvbnMuZXhjbHVkZUluZGV4ZXMnKSAhPT0gdHJ1ZSkge1xuICAgICAgICAgIGNvbGxlY3RJbmRleGVzKHBhdGguc2NoZW1hLCBwcmVmaXggKyBrZXkgKyAnLicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHBhdGguc2NoZW1hLmRpc2NyaW1pbmF0b3JzICE9IG51bGwpIHtcbiAgICAgICAgICBjb25zdCBkaXNjcmltaW5hdG9ycyA9IHBhdGguc2NoZW1hLmRpc2NyaW1pbmF0b3JzO1xuICAgICAgICAgIGNvbnN0IGRpc2NyaW1pbmF0b3JLZXlzID0gT2JqZWN0LmtleXMoZGlzY3JpbWluYXRvcnMpO1xuICAgICAgICAgIGZvciAoY29uc3QgZGlzY3JpbWluYXRvcktleSBvZiBkaXNjcmltaW5hdG9yS2V5cykge1xuICAgICAgICAgICAgY29sbGVjdEluZGV4ZXMoZGlzY3JpbWluYXRvcnNbZGlzY3JpbWluYXRvcktleV0sXG4gICAgICAgICAgICAgIHByZWZpeCArIGtleSArICcuJywgcGF0aC5zY2hlbWEpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFJldGFpbmVkIHRvIG1pbmltaXplIHJpc2sgb2YgYmFja3dhcmRzIGJyZWFraW5nIGNoYW5nZXMgZHVlIHRvXG4gICAgICAgIC8vIGdoLTYxMTNcbiAgICAgICAgaWYgKHBhdGguJGlzTW9uZ29vc2VEb2N1bWVudEFycmF5KSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY29uc3QgaW5kZXggPSBwYXRoLl9pbmRleCB8fCAocGF0aC5jYXN0ZXIgJiYgcGF0aC5jYXN0ZXIuX2luZGV4KTtcblxuICAgICAgaWYgKGluZGV4ICE9PSBmYWxzZSAmJiBpbmRleCAhPT0gbnVsbCAmJiBpbmRleCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnN0IGZpZWxkID0ge307XG4gICAgICAgIGNvbnN0IGlzT2JqZWN0ID0gaGVscGVySXNPYmplY3QoaW5kZXgpO1xuICAgICAgICBjb25zdCBvcHRpb25zID0gaXNPYmplY3QgPyBpbmRleCA6IHt9O1xuICAgICAgICBjb25zdCB0eXBlID0gdHlwZW9mIGluZGV4ID09PSAnc3RyaW5nJyA/IGluZGV4IDpcbiAgICAgICAgICBpc09iamVjdCA/IGluZGV4LnR5cGUgOlxuICAgICAgICAgICAgZmFsc2U7XG5cbiAgICAgICAgaWYgKHR5cGUgJiYgaW5kZXhUeXBlcy5pbmRleE9mKHR5cGUpICE9PSAtMSkge1xuICAgICAgICAgIGZpZWxkW3ByZWZpeCArIGtleV0gPSB0eXBlO1xuICAgICAgICB9IGVsc2UgaWYgKG9wdGlvbnMudGV4dCkge1xuICAgICAgICAgIGZpZWxkW3ByZWZpeCArIGtleV0gPSAndGV4dCc7XG4gICAgICAgICAgZGVsZXRlIG9wdGlvbnMudGV4dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsZXQgaXNEZXNjZW5kaW5nSW5kZXggPSBmYWxzZTtcbiAgICAgICAgICBpZiAoaW5kZXggPT09ICdkZXNjZW5kaW5nJyB8fCBpbmRleCA9PT0gJ2Rlc2MnKSB7XG4gICAgICAgICAgICBpc0Rlc2NlbmRpbmdJbmRleCA9IHRydWU7XG4gICAgICAgICAgfSBlbHNlIGlmIChpbmRleCA9PT0gJ2FzY2VuZGluZycgfHwgaW5kZXggPT09ICdhc2MnKSB7XG4gICAgICAgICAgICBpc0Rlc2NlbmRpbmdJbmRleCA9IGZhbHNlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpc0Rlc2NlbmRpbmdJbmRleCA9IE51bWJlcihpbmRleCkgPT09IC0xO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGZpZWxkW3ByZWZpeCArIGtleV0gPSBpc0Rlc2NlbmRpbmdJbmRleCA/IC0xIDogMTtcbiAgICAgICAgfVxuXG4gICAgICAgIGRlbGV0ZSBvcHRpb25zLnR5cGU7XG4gICAgICAgIGlmICghKCdiYWNrZ3JvdW5kJyBpbiBvcHRpb25zKSkge1xuICAgICAgICAgIG9wdGlvbnMuYmFja2dyb3VuZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNjaGVtYS5vcHRpb25zLmF1dG9JbmRleCAhPSBudWxsKSB7XG4gICAgICAgICAgb3B0aW9ucy5fYXV0b0luZGV4ID0gc2NoZW1hLm9wdGlvbnMuYXV0b0luZGV4O1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgaW5kZXhOYW1lID0gb3B0aW9ucyAmJiBvcHRpb25zLm5hbWU7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBpbmRleE5hbWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgaWYgKGluZGV4QnlOYW1lLmhhcyhpbmRleE5hbWUpKSB7XG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKGluZGV4QnlOYW1lLmdldChpbmRleE5hbWUpLCBmaWVsZCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGluZGV4ZXMucHVzaChbZmllbGQsIG9wdGlvbnNdKTtcbiAgICAgICAgICAgIGluZGV4QnlOYW1lLnNldChpbmRleE5hbWUsIGZpZWxkKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaW5kZXhlcy5wdXNoKFtmaWVsZCwgb3B0aW9uc10pO1xuICAgICAgICAgIGluZGV4QnlOYW1lLnNldChpbmRleE5hbWUsIGZpZWxkKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHNjaGVtYVN0YWNrLmRlbGV0ZShzY2hlbWEpO1xuXG4gICAgaWYgKHByZWZpeCkge1xuICAgICAgZml4U3ViSW5kZXhQYXRocyhzY2hlbWEsIHByZWZpeCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNjaGVtYS5faW5kZXhlcy5mb3JFYWNoKGZ1bmN0aW9uKGluZGV4KSB7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSBpbmRleFsxXTtcbiAgICAgICAgaWYgKCEoJ2JhY2tncm91bmQnIGluIG9wdGlvbnMpKSB7XG4gICAgICAgICAgb3B0aW9ucy5iYWNrZ3JvdW5kID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBkZWNvcmF0ZURpc2NyaW1pbmF0b3JJbmRleE9wdGlvbnMoc2NoZW1hLCBvcHRpb25zKTtcbiAgICAgIH0pO1xuICAgICAgaW5kZXhlcyA9IGluZGV4ZXMuY29uY2F0KHNjaGVtYS5faW5kZXhlcyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyBmb3IgaW5kZXhlcyBhZGRlZCB0byBzdWJkb2NzIHVzaW5nIFNjaGVtYS5pbmRleCgpLlxuICAgKiBUaGVzZSBpbmRleGVzIG5lZWQgdGhlaXIgcGF0aHMgcHJlZml4ZWQgcHJvcGVybHkuXG4gICAqXG4gICAqIHNjaGVtYS5faW5kZXhlcyA9IFsgW2luZGV4T2JqLCBvcHRpb25zXSwgW2luZGV4T2JqLCBvcHRpb25zXSAuLl1cbiAgICogQHBhcmFtIHtTY2hlbWF9IHNjaGVtYVxuICAgKiBAcGFyYW0ge1N0cmluZ30gcHJlZml4XG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cblxuICBmdW5jdGlvbiBmaXhTdWJJbmRleFBhdGhzKHNjaGVtYSwgcHJlZml4KSB7XG4gICAgY29uc3Qgc3ViaW5kZXhlcyA9IHNjaGVtYS5faW5kZXhlcztcbiAgICBjb25zdCBsZW4gPSBzdWJpbmRleGVzLmxlbmd0aDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICBjb25zdCBpbmRleE9iaiA9IHN1YmluZGV4ZXNbaV1bMF07XG4gICAgICBjb25zdCBpbmRleE9wdGlvbnMgPSBzdWJpbmRleGVzW2ldWzFdO1xuICAgICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKGluZGV4T2JqKTtcbiAgICAgIGNvbnN0IGtsZW4gPSBrZXlzLmxlbmd0aDtcbiAgICAgIGNvbnN0IG5ld2luZGV4ID0ge307XG5cbiAgICAgIC8vIHVzZSBmb3J3YXJkIGl0ZXJhdGlvbiwgb3JkZXIgbWF0dGVyc1xuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBrbGVuOyArK2opIHtcbiAgICAgICAgY29uc3Qga2V5ID0ga2V5c1tqXTtcbiAgICAgICAgbmV3aW5kZXhbcHJlZml4ICsga2V5XSA9IGluZGV4T2JqW2tleV07XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IG5ld0luZGV4T3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIGluZGV4T3B0aW9ucyk7XG4gICAgICBpZiAoaW5kZXhPcHRpb25zICE9IG51bGwgJiYgaW5kZXhPcHRpb25zLnBhcnRpYWxGaWx0ZXJFeHByZXNzaW9uICE9IG51bGwpIHtcbiAgICAgICAgbmV3SW5kZXhPcHRpb25zLnBhcnRpYWxGaWx0ZXJFeHByZXNzaW9uID0ge307XG4gICAgICAgIGNvbnN0IHBhcnRpYWxGaWx0ZXJFeHByZXNzaW9uID0gaW5kZXhPcHRpb25zLnBhcnRpYWxGaWx0ZXJFeHByZXNzaW9uO1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhwYXJ0aWFsRmlsdGVyRXhwcmVzc2lvbikpIHtcbiAgICAgICAgICBuZXdJbmRleE9wdGlvbnMucGFydGlhbEZpbHRlckV4cHJlc3Npb25bcHJlZml4ICsga2V5XSA9XG4gICAgICAgICAgICBwYXJ0aWFsRmlsdGVyRXhwcmVzc2lvbltrZXldO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGluZGV4ZXMucHVzaChbbmV3aW5kZXgsIG5ld0luZGV4T3B0aW9uc10pO1xuICAgIH1cbiAgfVxufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../server/node_modules/mongoose/lib/helpers/schema/getIndexes.js\n");

/***/ }),

/***/ "../server/node_modules/mongoose/lib/helpers/schema/getKeysInSchemaOrder.js":
/*!**********************************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/helpers/schema/getKeysInSchemaOrder.js ***!
  \**********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst get = __webpack_require__(/*! ../get */ \"../server/node_modules/mongoose/lib/helpers/get.js\");\n\nmodule.exports = function getKeysInSchemaOrder(schema, val, path) {\n  const schemaKeys = path != null ? Object.keys(get(schema.tree, path, {})) : Object.keys(schema.tree);\n  const valKeys = new Set(Object.keys(val));\n\n  let keys;\n  if (valKeys.size > 1) {\n    keys = new Set();\n    for (const key of schemaKeys) {\n      if (valKeys.has(key)) {\n        keys.add(key);\n      }\n    }\n    for (const key of valKeys) {\n      if (!keys.has(key)) {\n        keys.add(key);\n      }\n    }\n    keys = Array.from(keys);\n  } else {\n    keys = Array.from(valKeys);\n  }\n\n  return keys;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9zY2hlbWEvZ2V0S2V5c0luU2NoZW1hT3JkZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsWUFBWSxtQkFBTyxDQUFDLGtFQUFROztBQUU1QjtBQUNBLHlFQUF5RTtBQUN6RTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2NsaWVudC8uLi9zZXJ2ZXIvbm9kZV9tb2R1bGVzL21vbmdvb3NlL2xpYi9oZWxwZXJzL3NjaGVtYS9nZXRLZXlzSW5TY2hlbWFPcmRlci5qcz8xNGEzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3QgZ2V0ID0gcmVxdWlyZSgnLi4vZ2V0Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZ2V0S2V5c0luU2NoZW1hT3JkZXIoc2NoZW1hLCB2YWwsIHBhdGgpIHtcbiAgY29uc3Qgc2NoZW1hS2V5cyA9IHBhdGggIT0gbnVsbCA/IE9iamVjdC5rZXlzKGdldChzY2hlbWEudHJlZSwgcGF0aCwge30pKSA6IE9iamVjdC5rZXlzKHNjaGVtYS50cmVlKTtcbiAgY29uc3QgdmFsS2V5cyA9IG5ldyBTZXQoT2JqZWN0LmtleXModmFsKSk7XG5cbiAgbGV0IGtleXM7XG4gIGlmICh2YWxLZXlzLnNpemUgPiAxKSB7XG4gICAga2V5cyA9IG5ldyBTZXQoKTtcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBzY2hlbWFLZXlzKSB7XG4gICAgICBpZiAodmFsS2V5cy5oYXMoa2V5KSkge1xuICAgICAgICBrZXlzLmFkZChrZXkpO1xuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGNvbnN0IGtleSBvZiB2YWxLZXlzKSB7XG4gICAgICBpZiAoIWtleXMuaGFzKGtleSkpIHtcbiAgICAgICAga2V5cy5hZGQoa2V5KTtcbiAgICAgIH1cbiAgICB9XG4gICAga2V5cyA9IEFycmF5LmZyb20oa2V5cyk7XG4gIH0gZWxzZSB7XG4gICAga2V5cyA9IEFycmF5LmZyb20odmFsS2V5cyk7XG4gIH1cblxuICByZXR1cm4ga2V5cztcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../server/node_modules/mongoose/lib/helpers/schema/getKeysInSchemaOrder.js\n");

/***/ }),

/***/ "../server/node_modules/mongoose/lib/helpers/schema/getPath.js":
/*!*********************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/helpers/schema/getPath.js ***!
  \*********************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nconst numberRE = /^\\d+$/;\n\n/**\n * Behaves like `Schema#path()`, except for it also digs into arrays without\n * needing to put `.0.`, so `getPath(schema, 'docArr.elProp')` works.\n * @api private\n */\n\nmodule.exports = function getPath(schema, path) {\n  let schematype = schema.path(path);\n  if (schematype != null) {\n    return schematype;\n  }\n  const pieces = path.split('.');\n  let cur = '';\n  let isArray = false;\n\n  for (const piece of pieces) {\n    if (isArray && numberRE.test(piece)) {\n      continue;\n    }\n    cur = cur.length === 0 ? piece : cur + '.' + piece;\n\n    schematype = schema.path(cur);\n    if (schematype != null && schematype.schema) {\n      schema = schematype.schema;\n      cur = '';\n      if (!isArray && schematype.$isMongooseDocumentArray) {\n        isArray = true;\n      }\n    }\n  }\n\n  return schematype;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9zY2hlbWEvZ2V0UGF0aC5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2NsaWVudC8uLi9zZXJ2ZXIvbm9kZV9tb2R1bGVzL21vbmdvb3NlL2xpYi9oZWxwZXJzL3NjaGVtYS9nZXRQYXRoLmpzPzA3ZDMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBudW1iZXJSRSA9IC9eXFxkKyQvO1xuXG4vKipcbiAqIEJlaGF2ZXMgbGlrZSBgU2NoZW1hI3BhdGgoKWAsIGV4Y2VwdCBmb3IgaXQgYWxzbyBkaWdzIGludG8gYXJyYXlzIHdpdGhvdXRcbiAqIG5lZWRpbmcgdG8gcHV0IGAuMC5gLCBzbyBgZ2V0UGF0aChzY2hlbWEsICdkb2NBcnIuZWxQcm9wJylgIHdvcmtzLlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBnZXRQYXRoKHNjaGVtYSwgcGF0aCkge1xuICBsZXQgc2NoZW1hdHlwZSA9IHNjaGVtYS5wYXRoKHBhdGgpO1xuICBpZiAoc2NoZW1hdHlwZSAhPSBudWxsKSB7XG4gICAgcmV0dXJuIHNjaGVtYXR5cGU7XG4gIH1cbiAgY29uc3QgcGllY2VzID0gcGF0aC5zcGxpdCgnLicpO1xuICBsZXQgY3VyID0gJyc7XG4gIGxldCBpc0FycmF5ID0gZmFsc2U7XG5cbiAgZm9yIChjb25zdCBwaWVjZSBvZiBwaWVjZXMpIHtcbiAgICBpZiAoaXNBcnJheSAmJiBudW1iZXJSRS50ZXN0KHBpZWNlKSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGN1ciA9IGN1ci5sZW5ndGggPT09IDAgPyBwaWVjZSA6IGN1ciArICcuJyArIHBpZWNlO1xuXG4gICAgc2NoZW1hdHlwZSA9IHNjaGVtYS5wYXRoKGN1cik7XG4gICAgaWYgKHNjaGVtYXR5cGUgIT0gbnVsbCAmJiBzY2hlbWF0eXBlLnNjaGVtYSkge1xuICAgICAgc2NoZW1hID0gc2NoZW1hdHlwZS5zY2hlbWE7XG4gICAgICBjdXIgPSAnJztcbiAgICAgIGlmICghaXNBcnJheSAmJiBzY2hlbWF0eXBlLiRpc01vbmdvb3NlRG9jdW1lbnRBcnJheSkge1xuICAgICAgICBpc0FycmF5ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gc2NoZW1hdHlwZTtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../server/node_modules/mongoose/lib/helpers/schema/getPath.js\n");

/***/ }),

/***/ "../server/node_modules/mongoose/lib/helpers/schema/getSubdocumentStrictValue.js":
/*!***************************************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/helpers/schema/getSubdocumentStrictValue.js ***!
  \***************************************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/**\n * Find the `strict` mode setting for the deepest subdocument along a given path\n * to ensure we have the correct default value for `strict`. When setting values\n * underneath a subdocument, we should use the subdocument's `strict` setting by\n * default, not the top-level document's.\n *\n * @param {Schema} schema\n * @param {String[]} parts\n * @returns {boolean | 'throw' | undefined}\n */\n\nmodule.exports = function getSubdocumentStrictValue(schema, parts) {\n  if (parts.length === 1) {\n    return undefined;\n  }\n  let cur = parts[0];\n  let strict = undefined;\n  for (let i = 0; i < parts.length - 1; ++i) {\n    const curSchemaType = schema.path(cur);\n    if (curSchemaType && curSchemaType.schema) {\n      strict = curSchemaType.schema.options.strict;\n      schema = curSchemaType.schema;\n      cur = curSchemaType.$isMongooseDocumentArray && !isNaN(parts[i + 1]) ? '' : parts[i + 1];\n    } else {\n      cur += cur.length ? ('.' + parts[i + 1]) : parts[i + 1];\n    }\n  }\n\n  return strict;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9zY2hlbWEvZ2V0U3ViZG9jdW1lbnRTdHJpY3RWYWx1ZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxVQUFVO0FBQ3JCLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isc0JBQXNCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbGllbnQvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9zY2hlbWEvZ2V0U3ViZG9jdW1lbnRTdHJpY3RWYWx1ZS5qcz81MmRlIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBGaW5kIHRoZSBgc3RyaWN0YCBtb2RlIHNldHRpbmcgZm9yIHRoZSBkZWVwZXN0IHN1YmRvY3VtZW50IGFsb25nIGEgZ2l2ZW4gcGF0aFxuICogdG8gZW5zdXJlIHdlIGhhdmUgdGhlIGNvcnJlY3QgZGVmYXVsdCB2YWx1ZSBmb3IgYHN0cmljdGAuIFdoZW4gc2V0dGluZyB2YWx1ZXNcbiAqIHVuZGVybmVhdGggYSBzdWJkb2N1bWVudCwgd2Ugc2hvdWxkIHVzZSB0aGUgc3ViZG9jdW1lbnQncyBgc3RyaWN0YCBzZXR0aW5nIGJ5XG4gKiBkZWZhdWx0LCBub3QgdGhlIHRvcC1sZXZlbCBkb2N1bWVudCdzLlxuICpcbiAqIEBwYXJhbSB7U2NoZW1hfSBzY2hlbWFcbiAqIEBwYXJhbSB7U3RyaW5nW119IHBhcnRzXG4gKiBAcmV0dXJucyB7Ym9vbGVhbiB8ICd0aHJvdycgfCB1bmRlZmluZWR9XG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBnZXRTdWJkb2N1bWVudFN0cmljdFZhbHVlKHNjaGVtYSwgcGFydHMpIHtcbiAgaWYgKHBhcnRzLmxlbmd0aCA9PT0gMSkge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbiAgbGV0IGN1ciA9IHBhcnRzWzBdO1xuICBsZXQgc3RyaWN0ID0gdW5kZWZpbmVkO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHBhcnRzLmxlbmd0aCAtIDE7ICsraSkge1xuICAgIGNvbnN0IGN1clNjaGVtYVR5cGUgPSBzY2hlbWEucGF0aChjdXIpO1xuICAgIGlmIChjdXJTY2hlbWFUeXBlICYmIGN1clNjaGVtYVR5cGUuc2NoZW1hKSB7XG4gICAgICBzdHJpY3QgPSBjdXJTY2hlbWFUeXBlLnNjaGVtYS5vcHRpb25zLnN0cmljdDtcbiAgICAgIHNjaGVtYSA9IGN1clNjaGVtYVR5cGUuc2NoZW1hO1xuICAgICAgY3VyID0gY3VyU2NoZW1hVHlwZS4kaXNNb25nb29zZURvY3VtZW50QXJyYXkgJiYgIWlzTmFOKHBhcnRzW2kgKyAxXSkgPyAnJyA6IHBhcnRzW2kgKyAxXTtcbiAgICB9IGVsc2Uge1xuICAgICAgY3VyICs9IGN1ci5sZW5ndGggPyAoJy4nICsgcGFydHNbaSArIDFdKSA6IHBhcnRzW2kgKyAxXTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gc3RyaWN0O1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../server/node_modules/mongoose/lib/helpers/schema/getSubdocumentStrictValue.js\n");

/***/ }),

/***/ "../server/node_modules/mongoose/lib/helpers/schema/handleIdOption.js":
/*!****************************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/helpers/schema/handleIdOption.js ***!
  \****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst addAutoId = __webpack_require__(/*! ./addAutoId */ \"../server/node_modules/mongoose/lib/helpers/schema/addAutoId.js\");\n\nmodule.exports = function handleIdOption(schema, options) {\n  if (options == null || options._id == null) {\n    return schema;\n  }\n\n  schema = schema.clone();\n  if (!options._id) {\n    schema.remove('_id');\n    schema.options._id = false;\n  } else if (!schema.paths['_id']) {\n    addAutoId(schema);\n    schema.options._id = true;\n  }\n\n  return schema;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9zY2hlbWEvaGFuZGxlSWRPcHRpb24uanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsa0JBQWtCLG1CQUFPLENBQUMsb0ZBQWE7O0FBRXZDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2xpZW50Ly4uL3NlcnZlci9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvc2NoZW1hL2hhbmRsZUlkT3B0aW9uLmpzPzY3YTciXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBhZGRBdXRvSWQgPSByZXF1aXJlKCcuL2FkZEF1dG9JZCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGhhbmRsZUlkT3B0aW9uKHNjaGVtYSwgb3B0aW9ucykge1xuICBpZiAob3B0aW9ucyA9PSBudWxsIHx8IG9wdGlvbnMuX2lkID09IG51bGwpIHtcbiAgICByZXR1cm4gc2NoZW1hO1xuICB9XG5cbiAgc2NoZW1hID0gc2NoZW1hLmNsb25lKCk7XG4gIGlmICghb3B0aW9ucy5faWQpIHtcbiAgICBzY2hlbWEucmVtb3ZlKCdfaWQnKTtcbiAgICBzY2hlbWEub3B0aW9ucy5faWQgPSBmYWxzZTtcbiAgfSBlbHNlIGlmICghc2NoZW1hLnBhdGhzWydfaWQnXSkge1xuICAgIGFkZEF1dG9JZChzY2hlbWEpO1xuICAgIHNjaGVtYS5vcHRpb25zLl9pZCA9IHRydWU7XG4gIH1cblxuICByZXR1cm4gc2NoZW1hO1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../server/node_modules/mongoose/lib/helpers/schema/handleIdOption.js\n");

/***/ }),

/***/ "../server/node_modules/mongoose/lib/helpers/schema/handleTimestampOption.js":
/*!***********************************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/helpers/schema/handleTimestampOption.js ***!
  \***********************************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nmodule.exports = handleTimestampOption;\n\n/*!\n * ignore\n */\n\nfunction handleTimestampOption(arg, prop) {\n  if (arg == null) {\n    return null;\n  }\n\n  if (typeof arg === 'boolean') {\n    return prop;\n  }\n  if (typeof arg[prop] === 'boolean') {\n    return arg[prop] ? prop : null;\n  }\n  if (!(prop in arg)) {\n    return prop;\n  }\n  return arg[prop];\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9zY2hlbWEvaGFuZGxlVGltZXN0YW1wT3B0aW9uLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2xpZW50Ly4uL3NlcnZlci9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvc2NoZW1hL2hhbmRsZVRpbWVzdGFtcE9wdGlvbi5qcz84MTIxIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBoYW5kbGVUaW1lc3RhbXBPcHRpb247XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxuZnVuY3Rpb24gaGFuZGxlVGltZXN0YW1wT3B0aW9uKGFyZywgcHJvcCkge1xuICBpZiAoYXJnID09IG51bGwpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGlmICh0eXBlb2YgYXJnID09PSAnYm9vbGVhbicpIHtcbiAgICByZXR1cm4gcHJvcDtcbiAgfVxuICBpZiAodHlwZW9mIGFyZ1twcm9wXSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgcmV0dXJuIGFyZ1twcm9wXSA/IHByb3AgOiBudWxsO1xuICB9XG4gIGlmICghKHByb3AgaW4gYXJnKSkge1xuICAgIHJldHVybiBwcm9wO1xuICB9XG4gIHJldHVybiBhcmdbcHJvcF07XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../server/node_modules/mongoose/lib/helpers/schema/handleTimestampOption.js\n");

/***/ }),

/***/ "../server/node_modules/mongoose/lib/helpers/schema/idGetter.js":
/*!**********************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/helpers/schema/idGetter.js ***!
  \**********************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/*!\n * ignore\n */\n\nmodule.exports = function addIdGetter(schema) {\n  // ensure the documents receive an id getter unless disabled\n  const autoIdGetter = !schema.paths['id'] &&\n    schema.paths['_id'] &&\n    schema.options.id;\n  if (!autoIdGetter) {\n    return schema;\n  }\n  if (schema.aliases && schema.aliases.id) {\n    return schema;\n  }\n  schema.virtual('id').get(idGetter);\n\n  return schema;\n};\n\n/**\n * Returns this documents _id cast to a string.\n * @api private\n */\n\nfunction idGetter() {\n  if (this._id != null) {\n    return String(this._id);\n  }\n\n  return null;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9zY2hlbWEvaWRHZXR0ZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbGllbnQvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9zY2hlbWEvaWRHZXR0ZXIuanM/YjAwNiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBhZGRJZEdldHRlcihzY2hlbWEpIHtcbiAgLy8gZW5zdXJlIHRoZSBkb2N1bWVudHMgcmVjZWl2ZSBhbiBpZCBnZXR0ZXIgdW5sZXNzIGRpc2FibGVkXG4gIGNvbnN0IGF1dG9JZEdldHRlciA9ICFzY2hlbWEucGF0aHNbJ2lkJ10gJiZcbiAgICBzY2hlbWEucGF0aHNbJ19pZCddICYmXG4gICAgc2NoZW1hLm9wdGlvbnMuaWQ7XG4gIGlmICghYXV0b0lkR2V0dGVyKSB7XG4gICAgcmV0dXJuIHNjaGVtYTtcbiAgfVxuICBpZiAoc2NoZW1hLmFsaWFzZXMgJiYgc2NoZW1hLmFsaWFzZXMuaWQpIHtcbiAgICByZXR1cm4gc2NoZW1hO1xuICB9XG4gIHNjaGVtYS52aXJ0dWFsKCdpZCcpLmdldChpZEdldHRlcik7XG5cbiAgcmV0dXJuIHNjaGVtYTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGlzIGRvY3VtZW50cyBfaWQgY2FzdCB0byBhIHN0cmluZy5cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGlkR2V0dGVyKCkge1xuICBpZiAodGhpcy5faWQgIT0gbnVsbCkge1xuICAgIHJldHVybiBTdHJpbmcodGhpcy5faWQpO1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../server/node_modules/mongoose/lib/helpers/schema/idGetter.js\n");

/***/ }),

/***/ "../server/node_modules/mongoose/lib/helpers/schema/merge.js":
/*!*******************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/helpers/schema/merge.js ***!
  \*******************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nmodule.exports = function merge(s1, s2, skipConflictingPaths) {\n  const paths = Object.keys(s2.tree);\n  const pathsToAdd = {};\n  for (const key of paths) {\n    if (skipConflictingPaths && (s1.paths[key] || s1.nested[key] || s1.singleNestedPaths[key])) {\n      continue;\n    }\n    pathsToAdd[key] = s2.tree[key];\n  }\n  s1.options._isMerging = true;\n  s1.add(pathsToAdd, null);\n  delete s1.options._isMerging;\n\n  s1.callQueue = s1.callQueue.concat(s2.callQueue);\n  s1.method(s2.methods);\n  s1.static(s2.statics);\n\n  for (const [option, value] of Object.entries(s2._userProvidedOptions)) {\n    if (!(option in s1._userProvidedOptions)) {\n      s1.set(option, value);\n    }\n  }\n\n  for (const query in s2.query) {\n    s1.query[query] = s2.query[query];\n  }\n\n  for (const virtual in s2.virtuals) {\n    s1.virtuals[virtual] = s2.virtuals[virtual].clone();\n  }\n\n  s1._indexes = s1._indexes.concat(s2._indexes || []);\n  s1.s.hooks.merge(s2.s.hooks, false);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9zY2hlbWEvbWVyZ2UuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2xpZW50Ly4uL3NlcnZlci9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvc2NoZW1hL21lcmdlLmpzPzNiNzYiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIG1lcmdlKHMxLCBzMiwgc2tpcENvbmZsaWN0aW5nUGF0aHMpIHtcbiAgY29uc3QgcGF0aHMgPSBPYmplY3Qua2V5cyhzMi50cmVlKTtcbiAgY29uc3QgcGF0aHNUb0FkZCA9IHt9O1xuICBmb3IgKGNvbnN0IGtleSBvZiBwYXRocykge1xuICAgIGlmIChza2lwQ29uZmxpY3RpbmdQYXRocyAmJiAoczEucGF0aHNba2V5XSB8fCBzMS5uZXN0ZWRba2V5XSB8fCBzMS5zaW5nbGVOZXN0ZWRQYXRoc1trZXldKSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHBhdGhzVG9BZGRba2V5XSA9IHMyLnRyZWVba2V5XTtcbiAgfVxuICBzMS5vcHRpb25zLl9pc01lcmdpbmcgPSB0cnVlO1xuICBzMS5hZGQocGF0aHNUb0FkZCwgbnVsbCk7XG4gIGRlbGV0ZSBzMS5vcHRpb25zLl9pc01lcmdpbmc7XG5cbiAgczEuY2FsbFF1ZXVlID0gczEuY2FsbFF1ZXVlLmNvbmNhdChzMi5jYWxsUXVldWUpO1xuICBzMS5tZXRob2QoczIubWV0aG9kcyk7XG4gIHMxLnN0YXRpYyhzMi5zdGF0aWNzKTtcblxuICBmb3IgKGNvbnN0IFtvcHRpb24sIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhzMi5fdXNlclByb3ZpZGVkT3B0aW9ucykpIHtcbiAgICBpZiAoIShvcHRpb24gaW4gczEuX3VzZXJQcm92aWRlZE9wdGlvbnMpKSB7XG4gICAgICBzMS5zZXQob3B0aW9uLCB2YWx1ZSk7XG4gICAgfVxuICB9XG5cbiAgZm9yIChjb25zdCBxdWVyeSBpbiBzMi5xdWVyeSkge1xuICAgIHMxLnF1ZXJ5W3F1ZXJ5XSA9IHMyLnF1ZXJ5W3F1ZXJ5XTtcbiAgfVxuXG4gIGZvciAoY29uc3QgdmlydHVhbCBpbiBzMi52aXJ0dWFscykge1xuICAgIHMxLnZpcnR1YWxzW3ZpcnR1YWxdID0gczIudmlydHVhbHNbdmlydHVhbF0uY2xvbmUoKTtcbiAgfVxuXG4gIHMxLl9pbmRleGVzID0gczEuX2luZGV4ZXMuY29uY2F0KHMyLl9pbmRleGVzIHx8IFtdKTtcbiAgczEucy5ob29rcy5tZXJnZShzMi5zLmhvb2tzLCBmYWxzZSk7XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../server/node_modules/mongoose/lib/helpers/schema/merge.js\n");

/***/ }),

/***/ "../server/node_modules/mongoose/lib/helpers/schematype/handleImmutable.js":
/*!*********************************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/helpers/schematype/handleImmutable.js ***!
  \*********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst StrictModeError = __webpack_require__(/*! ../../error/strict */ \"../server/node_modules/mongoose/lib/error/strict.js\");\n\n/*!\n * ignore\n */\n\nmodule.exports = function(schematype) {\n  if (schematype.$immutable) {\n    schematype.$immutableSetter = createImmutableSetter(schematype.path,\n      schematype.options.immutable);\n    schematype.set(schematype.$immutableSetter);\n  } else if (schematype.$immutableSetter) {\n    schematype.setters = schematype.setters.\n      filter(fn => fn !== schematype.$immutableSetter);\n    delete schematype.$immutableSetter;\n  }\n};\n\nfunction createImmutableSetter(path, immutable) {\n  return function immutableSetter(v, _priorVal, _doc, options) {\n    if (this == null || this.$__ == null) {\n      return v;\n    }\n    if (this.isNew) {\n      return v;\n    }\n    if (options && options.overwriteImmutable) {\n      return v;\n    }\n\n    const _immutable = typeof immutable === 'function' ?\n      immutable.call(this, this) :\n      immutable;\n    if (!_immutable) {\n      return v;\n    }\n\n    const _value = this.$__.priorDoc != null ?\n      this.$__.priorDoc.$__getValue(path) :\n      this.$__getValue(path);\n    if (this.$__.strictMode === 'throw' && v !== _value) {\n      throw new StrictModeError(path, 'Path `' + path + '` is immutable ' +\n        'and strict mode is set to throw.', true);\n    }\n\n    return _value;\n  };\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9zY2hlbWF0eXBlL2hhbmRsZUltbXV0YWJsZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYix3QkFBd0IsbUJBQU8sQ0FBQywrRUFBb0I7O0FBRXBEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2xpZW50Ly4uL3NlcnZlci9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvc2NoZW1hdHlwZS9oYW5kbGVJbW11dGFibGUuanM/YTNmZSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IFN0cmljdE1vZGVFcnJvciA9IHJlcXVpcmUoJy4uLy4uL2Vycm9yL3N0cmljdCcpO1xuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oc2NoZW1hdHlwZSkge1xuICBpZiAoc2NoZW1hdHlwZS4kaW1tdXRhYmxlKSB7XG4gICAgc2NoZW1hdHlwZS4kaW1tdXRhYmxlU2V0dGVyID0gY3JlYXRlSW1tdXRhYmxlU2V0dGVyKHNjaGVtYXR5cGUucGF0aCxcbiAgICAgIHNjaGVtYXR5cGUub3B0aW9ucy5pbW11dGFibGUpO1xuICAgIHNjaGVtYXR5cGUuc2V0KHNjaGVtYXR5cGUuJGltbXV0YWJsZVNldHRlcik7XG4gIH0gZWxzZSBpZiAoc2NoZW1hdHlwZS4kaW1tdXRhYmxlU2V0dGVyKSB7XG4gICAgc2NoZW1hdHlwZS5zZXR0ZXJzID0gc2NoZW1hdHlwZS5zZXR0ZXJzLlxuICAgICAgZmlsdGVyKGZuID0+IGZuICE9PSBzY2hlbWF0eXBlLiRpbW11dGFibGVTZXR0ZXIpO1xuICAgIGRlbGV0ZSBzY2hlbWF0eXBlLiRpbW11dGFibGVTZXR0ZXI7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGNyZWF0ZUltbXV0YWJsZVNldHRlcihwYXRoLCBpbW11dGFibGUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGltbXV0YWJsZVNldHRlcih2LCBfcHJpb3JWYWwsIF9kb2MsIG9wdGlvbnMpIHtcbiAgICBpZiAodGhpcyA9PSBudWxsIHx8IHRoaXMuJF9fID09IG51bGwpIHtcbiAgICAgIHJldHVybiB2O1xuICAgIH1cbiAgICBpZiAodGhpcy5pc05ldykge1xuICAgICAgcmV0dXJuIHY7XG4gICAgfVxuICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMub3ZlcndyaXRlSW1tdXRhYmxlKSB7XG4gICAgICByZXR1cm4gdjtcbiAgICB9XG5cbiAgICBjb25zdCBfaW1tdXRhYmxlID0gdHlwZW9mIGltbXV0YWJsZSA9PT0gJ2Z1bmN0aW9uJyA/XG4gICAgICBpbW11dGFibGUuY2FsbCh0aGlzLCB0aGlzKSA6XG4gICAgICBpbW11dGFibGU7XG4gICAgaWYgKCFfaW1tdXRhYmxlKSB7XG4gICAgICByZXR1cm4gdjtcbiAgICB9XG5cbiAgICBjb25zdCBfdmFsdWUgPSB0aGlzLiRfXy5wcmlvckRvYyAhPSBudWxsID9cbiAgICAgIHRoaXMuJF9fLnByaW9yRG9jLiRfX2dldFZhbHVlKHBhdGgpIDpcbiAgICAgIHRoaXMuJF9fZ2V0VmFsdWUocGF0aCk7XG4gICAgaWYgKHRoaXMuJF9fLnN0cmljdE1vZGUgPT09ICd0aHJvdycgJiYgdiAhPT0gX3ZhbHVlKSB7XG4gICAgICB0aHJvdyBuZXcgU3RyaWN0TW9kZUVycm9yKHBhdGgsICdQYXRoIGAnICsgcGF0aCArICdgIGlzIGltbXV0YWJsZSAnICtcbiAgICAgICAgJ2FuZCBzdHJpY3QgbW9kZSBpcyBzZXQgdG8gdGhyb3cuJywgdHJ1ZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIF92YWx1ZTtcbiAgfTtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../server/node_modules/mongoose/lib/helpers/schematype/handleImmutable.js\n");

/***/ }),

/***/ "../server/node_modules/mongoose/lib/helpers/setDefaultsOnInsert.js":
/*!**************************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/helpers/setDefaultsOnInsert.js ***!
  \**************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst modifiedPaths = (__webpack_require__(/*! ./common */ \"../server/node_modules/mongoose/lib/helpers/common.js\").modifiedPaths);\nconst get = __webpack_require__(/*! ./get */ \"../server/node_modules/mongoose/lib/helpers/get.js\");\n\n/**\n * Applies defaults to update and findOneAndUpdate operations.\n *\n * @param {Object} filter\n * @param {Schema} schema\n * @param {Object} castedDoc\n * @param {Object} options\n * @method setDefaultsOnInsert\n * @api private\n */\n\nmodule.exports = function(filter, schema, castedDoc, options) {\n  options = options || {};\n\n  const shouldSetDefaultsOnInsert =\n    options.setDefaultsOnInsert != null ?\n      options.setDefaultsOnInsert :\n      schema.base.options.setDefaultsOnInsert;\n\n  if (!options.upsert || shouldSetDefaultsOnInsert === false) {\n    return castedDoc;\n  }\n\n  const keys = Object.keys(castedDoc || {});\n  const updatedKeys = {};\n  const updatedValues = {};\n  const numKeys = keys.length;\n  const modified = {};\n\n  let hasDollarUpdate = false;\n\n  for (let i = 0; i < numKeys; ++i) {\n    if (keys[i].startsWith('$')) {\n      modifiedPaths(castedDoc[keys[i]], '', modified);\n      hasDollarUpdate = true;\n    }\n  }\n\n  if (!hasDollarUpdate) {\n    modifiedPaths(castedDoc, '', modified);\n  }\n\n  const paths = Object.keys(filter);\n  const numPaths = paths.length;\n  for (let i = 0; i < numPaths; ++i) {\n    const path = paths[i];\n    const condition = filter[path];\n    if (condition && typeof condition === 'object') {\n      const conditionKeys = Object.keys(condition);\n      const numConditionKeys = conditionKeys.length;\n      let hasDollarKey = false;\n      for (let j = 0; j < numConditionKeys; ++j) {\n        if (conditionKeys[j].startsWith('$')) {\n          hasDollarKey = true;\n          break;\n        }\n      }\n      if (hasDollarKey) {\n        continue;\n      }\n    }\n    updatedKeys[path] = true;\n    modified[path] = true;\n  }\n\n  if (options && options.overwrite && !hasDollarUpdate) {\n    // Defaults will be set later, since we're overwriting we'll cast\n    // the whole update to a document\n    return castedDoc;\n  }\n\n  schema.eachPath(function(path, schemaType) {\n    // Skip single nested paths if underneath a map\n    if (schemaType.path === '_id' && schemaType.options.auto) {\n      return;\n    }\n    const def = schemaType.getDefault(null, true);\n    if (isModified(modified, path)) {\n      return;\n    }\n    if (typeof def === 'undefined') {\n      return;\n    }\n    if (schemaType.splitPath().includes('$*')) {\n      // Skip defaults underneath maps. We should never do `$setOnInsert` on a path with `$*`\n      return;\n    }\n\n    castedDoc = castedDoc || {};\n    castedDoc.$setOnInsert = castedDoc.$setOnInsert || {};\n    if (get(castedDoc, path) == null) {\n      castedDoc.$setOnInsert[path] = def;\n    }\n    updatedValues[path] = def;\n  });\n\n  return castedDoc;\n};\n\nfunction isModified(modified, path) {\n  if (modified[path]) {\n    return true;\n  }\n\n  // Is any parent path of `path` modified?\n  const sp = path.split('.');\n  let cur = sp[0];\n  for (let i = 1; i < sp.length; ++i) {\n    if (modified[cur]) {\n      return true;\n    }\n    cur += '.' + sp[i];\n  }\n\n  // Is any child of `path` modified?\n  const modifiedKeys = Object.keys(modified);\n  if (modifiedKeys.length) {\n    const parentPath = path + '.';\n\n    for (const modifiedPath of modifiedKeys) {\n      if (modifiedPath.slice(0, path.length + 1) === parentPath) {\n        return true;\n      }\n    }\n  }\n\n  return false;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9zZXREZWZhdWx0c09uSW5zZXJ0LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2Isc0JBQXNCLDRHQUFpQztBQUN2RCxZQUFZLG1CQUFPLENBQUMsaUVBQU87O0FBRTNCO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLGtCQUFrQixhQUFhO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0IsY0FBYztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isc0JBQXNCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsZUFBZTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2xpZW50Ly4uL3NlcnZlci9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvc2V0RGVmYXVsdHNPbkluc2VydC5qcz8wMDVlIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcbmNvbnN0IG1vZGlmaWVkUGF0aHMgPSByZXF1aXJlKCcuL2NvbW1vbicpLm1vZGlmaWVkUGF0aHM7XG5jb25zdCBnZXQgPSByZXF1aXJlKCcuL2dldCcpO1xuXG4vKipcbiAqIEFwcGxpZXMgZGVmYXVsdHMgdG8gdXBkYXRlIGFuZCBmaW5kT25lQW5kVXBkYXRlIG9wZXJhdGlvbnMuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGZpbHRlclxuICogQHBhcmFtIHtTY2hlbWF9IHNjaGVtYVxuICogQHBhcmFtIHtPYmplY3R9IGNhc3RlZERvY1xuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEBtZXRob2Qgc2V0RGVmYXVsdHNPbkluc2VydFxuICogQGFwaSBwcml2YXRlXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihmaWx0ZXIsIHNjaGVtYSwgY2FzdGVkRG9jLCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIGNvbnN0IHNob3VsZFNldERlZmF1bHRzT25JbnNlcnQgPVxuICAgIG9wdGlvbnMuc2V0RGVmYXVsdHNPbkluc2VydCAhPSBudWxsID9cbiAgICAgIG9wdGlvbnMuc2V0RGVmYXVsdHNPbkluc2VydCA6XG4gICAgICBzY2hlbWEuYmFzZS5vcHRpb25zLnNldERlZmF1bHRzT25JbnNlcnQ7XG5cbiAgaWYgKCFvcHRpb25zLnVwc2VydCB8fCBzaG91bGRTZXREZWZhdWx0c09uSW5zZXJ0ID09PSBmYWxzZSkge1xuICAgIHJldHVybiBjYXN0ZWREb2M7XG4gIH1cblxuICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoY2FzdGVkRG9jIHx8IHt9KTtcbiAgY29uc3QgdXBkYXRlZEtleXMgPSB7fTtcbiAgY29uc3QgdXBkYXRlZFZhbHVlcyA9IHt9O1xuICBjb25zdCBudW1LZXlzID0ga2V5cy5sZW5ndGg7XG4gIGNvbnN0IG1vZGlmaWVkID0ge307XG5cbiAgbGV0IGhhc0RvbGxhclVwZGF0ZSA9IGZhbHNlO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtS2V5czsgKytpKSB7XG4gICAgaWYgKGtleXNbaV0uc3RhcnRzV2l0aCgnJCcpKSB7XG4gICAgICBtb2RpZmllZFBhdGhzKGNhc3RlZERvY1trZXlzW2ldXSwgJycsIG1vZGlmaWVkKTtcbiAgICAgIGhhc0RvbGxhclVwZGF0ZSA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgaWYgKCFoYXNEb2xsYXJVcGRhdGUpIHtcbiAgICBtb2RpZmllZFBhdGhzKGNhc3RlZERvYywgJycsIG1vZGlmaWVkKTtcbiAgfVxuXG4gIGNvbnN0IHBhdGhzID0gT2JqZWN0LmtleXMoZmlsdGVyKTtcbiAgY29uc3QgbnVtUGF0aHMgPSBwYXRocy5sZW5ndGg7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtUGF0aHM7ICsraSkge1xuICAgIGNvbnN0IHBhdGggPSBwYXRoc1tpXTtcbiAgICBjb25zdCBjb25kaXRpb24gPSBmaWx0ZXJbcGF0aF07XG4gICAgaWYgKGNvbmRpdGlvbiAmJiB0eXBlb2YgY29uZGl0aW9uID09PSAnb2JqZWN0Jykge1xuICAgICAgY29uc3QgY29uZGl0aW9uS2V5cyA9IE9iamVjdC5rZXlzKGNvbmRpdGlvbik7XG4gICAgICBjb25zdCBudW1Db25kaXRpb25LZXlzID0gY29uZGl0aW9uS2V5cy5sZW5ndGg7XG4gICAgICBsZXQgaGFzRG9sbGFyS2V5ID0gZmFsc2U7XG4gICAgICBmb3IgKGxldCBqID0gMDsgaiA8IG51bUNvbmRpdGlvbktleXM7ICsraikge1xuICAgICAgICBpZiAoY29uZGl0aW9uS2V5c1tqXS5zdGFydHNXaXRoKCckJykpIHtcbiAgICAgICAgICBoYXNEb2xsYXJLZXkgPSB0cnVlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoaGFzRG9sbGFyS2V5KSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgIH1cbiAgICB1cGRhdGVkS2V5c1twYXRoXSA9IHRydWU7XG4gICAgbW9kaWZpZWRbcGF0aF0gPSB0cnVlO1xuICB9XG5cbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5vdmVyd3JpdGUgJiYgIWhhc0RvbGxhclVwZGF0ZSkge1xuICAgIC8vIERlZmF1bHRzIHdpbGwgYmUgc2V0IGxhdGVyLCBzaW5jZSB3ZSdyZSBvdmVyd3JpdGluZyB3ZSdsbCBjYXN0XG4gICAgLy8gdGhlIHdob2xlIHVwZGF0ZSB0byBhIGRvY3VtZW50XG4gICAgcmV0dXJuIGNhc3RlZERvYztcbiAgfVxuXG4gIHNjaGVtYS5lYWNoUGF0aChmdW5jdGlvbihwYXRoLCBzY2hlbWFUeXBlKSB7XG4gICAgLy8gU2tpcCBzaW5nbGUgbmVzdGVkIHBhdGhzIGlmIHVuZGVybmVhdGggYSBtYXBcbiAgICBpZiAoc2NoZW1hVHlwZS5wYXRoID09PSAnX2lkJyAmJiBzY2hlbWFUeXBlLm9wdGlvbnMuYXV0bykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBkZWYgPSBzY2hlbWFUeXBlLmdldERlZmF1bHQobnVsbCwgdHJ1ZSk7XG4gICAgaWYgKGlzTW9kaWZpZWQobW9kaWZpZWQsIHBhdGgpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0eXBlb2YgZGVmID09PSAndW5kZWZpbmVkJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoc2NoZW1hVHlwZS5zcGxpdFBhdGgoKS5pbmNsdWRlcygnJConKSkge1xuICAgICAgLy8gU2tpcCBkZWZhdWx0cyB1bmRlcm5lYXRoIG1hcHMuIFdlIHNob3VsZCBuZXZlciBkbyBgJHNldE9uSW5zZXJ0YCBvbiBhIHBhdGggd2l0aCBgJCpgXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY2FzdGVkRG9jID0gY2FzdGVkRG9jIHx8IHt9O1xuICAgIGNhc3RlZERvYy4kc2V0T25JbnNlcnQgPSBjYXN0ZWREb2MuJHNldE9uSW5zZXJ0IHx8IHt9O1xuICAgIGlmIChnZXQoY2FzdGVkRG9jLCBwYXRoKSA9PSBudWxsKSB7XG4gICAgICBjYXN0ZWREb2MuJHNldE9uSW5zZXJ0W3BhdGhdID0gZGVmO1xuICAgIH1cbiAgICB1cGRhdGVkVmFsdWVzW3BhdGhdID0gZGVmO1xuICB9KTtcblxuICByZXR1cm4gY2FzdGVkRG9jO1xufTtcblxuZnVuY3Rpb24gaXNNb2RpZmllZChtb2RpZmllZCwgcGF0aCkge1xuICBpZiAobW9kaWZpZWRbcGF0aF0pIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8vIElzIGFueSBwYXJlbnQgcGF0aCBvZiBgcGF0aGAgbW9kaWZpZWQ/XG4gIGNvbnN0IHNwID0gcGF0aC5zcGxpdCgnLicpO1xuICBsZXQgY3VyID0gc3BbMF07XG4gIGZvciAobGV0IGkgPSAxOyBpIDwgc3AubGVuZ3RoOyArK2kpIHtcbiAgICBpZiAobW9kaWZpZWRbY3VyXSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGN1ciArPSAnLicgKyBzcFtpXTtcbiAgfVxuXG4gIC8vIElzIGFueSBjaGlsZCBvZiBgcGF0aGAgbW9kaWZpZWQ/XG4gIGNvbnN0IG1vZGlmaWVkS2V5cyA9IE9iamVjdC5rZXlzKG1vZGlmaWVkKTtcbiAgaWYgKG1vZGlmaWVkS2V5cy5sZW5ndGgpIHtcbiAgICBjb25zdCBwYXJlbnRQYXRoID0gcGF0aCArICcuJztcblxuICAgIGZvciAoY29uc3QgbW9kaWZpZWRQYXRoIG9mIG1vZGlmaWVkS2V5cykge1xuICAgICAgaWYgKG1vZGlmaWVkUGF0aC5zbGljZSgwLCBwYXRoLmxlbmd0aCArIDEpID09PSBwYXJlbnRQYXRoKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../server/node_modules/mongoose/lib/helpers/setDefaultsOnInsert.js\n");

/***/ }),

/***/ "../server/node_modules/mongoose/lib/helpers/specialProperties.js":
/*!************************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/helpers/specialProperties.js ***!
  \************************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nmodule.exports = new Set(['__proto__', 'constructor', 'prototype']);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9zcGVjaWFsUHJvcGVydGllcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYiIsInNvdXJjZXMiOlsid2VicGFjazovL2NsaWVudC8uLi9zZXJ2ZXIvbm9kZV9tb2R1bGVzL21vbmdvb3NlL2xpYi9oZWxwZXJzL3NwZWNpYWxQcm9wZXJ0aWVzLmpzPzhhMGUiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IG5ldyBTZXQoWydfX3Byb3RvX18nLCAnY29uc3RydWN0b3InLCAncHJvdG90eXBlJ10pO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../server/node_modules/mongoose/lib/helpers/specialProperties.js\n");

/***/ }),

/***/ "../server/node_modules/mongoose/lib/helpers/symbols.js":
/*!**************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/helpers/symbols.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\nexports.arrayAtomicsBackupSymbol = Symbol('mongoose#Array#atomicsBackup');\nexports.arrayAtomicsSymbol = Symbol('mongoose#Array#_atomics');\nexports.arrayParentSymbol = Symbol('mongoose#Array#_parent');\nexports.arrayPathSymbol = Symbol('mongoose#Array#_path');\nexports.arraySchemaSymbol = Symbol('mongoose#Array#_schema');\nexports.documentArrayParent = Symbol('mongoose#documentArrayParent');\nexports.documentIsSelected = Symbol('mongoose#Document#isSelected');\nexports.documentIsModified = Symbol('mongoose#Document#isModified');\nexports.documentModifiedPaths = Symbol('mongoose#Document#modifiedPaths');\nexports.documentSchemaSymbol = Symbol('mongoose#Document#schema');\nexports.getSymbol = Symbol('mongoose#Document#get');\nexports.modelSymbol = Symbol('mongoose#Model');\nexports.objectIdSymbol = Symbol('mongoose#ObjectId');\nexports.populateModelSymbol = Symbol('mongoose#PopulateOptions#Model');\nexports.schemaTypeSymbol = Symbol('mongoose#schemaType');\nexports.sessionNewDocuments = Symbol('mongoose#ClientSession#newDocuments');\nexports.scopeSymbol = Symbol('mongoose#Document#scope');\nexports.validatorErrorSymbol = Symbol('mongoose#validatorError');\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9zeW1ib2xzLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLGdDQUFnQztBQUNoQywwQkFBMEI7QUFDMUIseUJBQXlCO0FBQ3pCLHVCQUF1QjtBQUN2Qix5QkFBeUI7QUFDekIsMkJBQTJCO0FBQzNCLDBCQUEwQjtBQUMxQiwwQkFBMEI7QUFDMUIsNkJBQTZCO0FBQzdCLDRCQUE0QjtBQUM1QixpQkFBaUI7QUFDakIsbUJBQW1CO0FBQ25CLHNCQUFzQjtBQUN0QiwyQkFBMkI7QUFDM0Isd0JBQXdCO0FBQ3hCLDJCQUEyQjtBQUMzQixtQkFBbUI7QUFDbkIsNEJBQTRCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2xpZW50Ly4uL3NlcnZlci9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvc3ltYm9scy5qcz81ZDc0Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5hcnJheUF0b21pY3NCYWNrdXBTeW1ib2wgPSBTeW1ib2woJ21vbmdvb3NlI0FycmF5I2F0b21pY3NCYWNrdXAnKTtcbmV4cG9ydHMuYXJyYXlBdG9taWNzU3ltYm9sID0gU3ltYm9sKCdtb25nb29zZSNBcnJheSNfYXRvbWljcycpO1xuZXhwb3J0cy5hcnJheVBhcmVudFN5bWJvbCA9IFN5bWJvbCgnbW9uZ29vc2UjQXJyYXkjX3BhcmVudCcpO1xuZXhwb3J0cy5hcnJheVBhdGhTeW1ib2wgPSBTeW1ib2woJ21vbmdvb3NlI0FycmF5I19wYXRoJyk7XG5leHBvcnRzLmFycmF5U2NoZW1hU3ltYm9sID0gU3ltYm9sKCdtb25nb29zZSNBcnJheSNfc2NoZW1hJyk7XG5leHBvcnRzLmRvY3VtZW50QXJyYXlQYXJlbnQgPSBTeW1ib2woJ21vbmdvb3NlI2RvY3VtZW50QXJyYXlQYXJlbnQnKTtcbmV4cG9ydHMuZG9jdW1lbnRJc1NlbGVjdGVkID0gU3ltYm9sKCdtb25nb29zZSNEb2N1bWVudCNpc1NlbGVjdGVkJyk7XG5leHBvcnRzLmRvY3VtZW50SXNNb2RpZmllZCA9IFN5bWJvbCgnbW9uZ29vc2UjRG9jdW1lbnQjaXNNb2RpZmllZCcpO1xuZXhwb3J0cy5kb2N1bWVudE1vZGlmaWVkUGF0aHMgPSBTeW1ib2woJ21vbmdvb3NlI0RvY3VtZW50I21vZGlmaWVkUGF0aHMnKTtcbmV4cG9ydHMuZG9jdW1lbnRTY2hlbWFTeW1ib2wgPSBTeW1ib2woJ21vbmdvb3NlI0RvY3VtZW50I3NjaGVtYScpO1xuZXhwb3J0cy5nZXRTeW1ib2wgPSBTeW1ib2woJ21vbmdvb3NlI0RvY3VtZW50I2dldCcpO1xuZXhwb3J0cy5tb2RlbFN5bWJvbCA9IFN5bWJvbCgnbW9uZ29vc2UjTW9kZWwnKTtcbmV4cG9ydHMub2JqZWN0SWRTeW1ib2wgPSBTeW1ib2woJ21vbmdvb3NlI09iamVjdElkJyk7XG5leHBvcnRzLnBvcHVsYXRlTW9kZWxTeW1ib2wgPSBTeW1ib2woJ21vbmdvb3NlI1BvcHVsYXRlT3B0aW9ucyNNb2RlbCcpO1xuZXhwb3J0cy5zY2hlbWFUeXBlU3ltYm9sID0gU3ltYm9sKCdtb25nb29zZSNzY2hlbWFUeXBlJyk7XG5leHBvcnRzLnNlc3Npb25OZXdEb2N1bWVudHMgPSBTeW1ib2woJ21vbmdvb3NlI0NsaWVudFNlc3Npb24jbmV3RG9jdW1lbnRzJyk7XG5leHBvcnRzLnNjb3BlU3ltYm9sID0gU3ltYm9sKCdtb25nb29zZSNEb2N1bWVudCNzY29wZScpO1xuZXhwb3J0cy52YWxpZGF0b3JFcnJvclN5bWJvbCA9IFN5bWJvbCgnbW9uZ29vc2UjdmFsaWRhdG9yRXJyb3InKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../server/node_modules/mongoose/lib/helpers/symbols.js\n");

/***/ }),

/***/ "../server/node_modules/mongoose/lib/helpers/timers.js":
/*!*************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/helpers/timers.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\nexports.setTimeout = setTimeout;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy90aW1lcnMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsa0JBQWtCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2xpZW50Ly4uL3NlcnZlci9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvdGltZXJzLmpzPzg0ZWUiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLnNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../server/node_modules/mongoose/lib/helpers/timers.js\n");

/***/ }),

/***/ "../server/node_modules/mongoose/lib/helpers/timestamps/setDocumentTimestamps.js":
/*!***************************************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/helpers/timestamps/setDocumentTimestamps.js ***!
  \***************************************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nmodule.exports = function setDocumentTimestamps(doc, timestampOption, currentTime, createdAt, updatedAt) {\n  const skipUpdatedAt = timestampOption != null && timestampOption.updatedAt === false;\n  const skipCreatedAt = timestampOption != null && timestampOption.createdAt === false;\n\n  const defaultTimestamp = currentTime != null ?\n    currentTime() :\n    doc.ownerDocument().constructor.base.now();\n\n  if (!skipCreatedAt &&\n      (doc.isNew || doc.$isSubdocument) &&\n      createdAt &&\n      !doc.$__getValue(createdAt) &&\n      doc.$__isSelected(createdAt)) {\n    doc.$set(createdAt, defaultTimestamp, undefined, { overwriteImmutable: true });\n  }\n\n  if (!skipUpdatedAt && updatedAt && (doc.isNew || doc.$isModified())) {\n    let ts = defaultTimestamp;\n    if (doc.isNew && createdAt != null) {\n      ts = doc.$__getValue(createdAt);\n    }\n    doc.$set(updatedAt, ts);\n  }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy90aW1lc3RhbXBzL3NldERvY3VtZW50VGltZXN0YW1wcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQsMEJBQTBCO0FBQ2pGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbGllbnQvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy90aW1lc3RhbXBzL3NldERvY3VtZW50VGltZXN0YW1wcy5qcz8xOGZhIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBzZXREb2N1bWVudFRpbWVzdGFtcHMoZG9jLCB0aW1lc3RhbXBPcHRpb24sIGN1cnJlbnRUaW1lLCBjcmVhdGVkQXQsIHVwZGF0ZWRBdCkge1xuICBjb25zdCBza2lwVXBkYXRlZEF0ID0gdGltZXN0YW1wT3B0aW9uICE9IG51bGwgJiYgdGltZXN0YW1wT3B0aW9uLnVwZGF0ZWRBdCA9PT0gZmFsc2U7XG4gIGNvbnN0IHNraXBDcmVhdGVkQXQgPSB0aW1lc3RhbXBPcHRpb24gIT0gbnVsbCAmJiB0aW1lc3RhbXBPcHRpb24uY3JlYXRlZEF0ID09PSBmYWxzZTtcblxuICBjb25zdCBkZWZhdWx0VGltZXN0YW1wID0gY3VycmVudFRpbWUgIT0gbnVsbCA/XG4gICAgY3VycmVudFRpbWUoKSA6XG4gICAgZG9jLm93bmVyRG9jdW1lbnQoKS5jb25zdHJ1Y3Rvci5iYXNlLm5vdygpO1xuXG4gIGlmICghc2tpcENyZWF0ZWRBdCAmJlxuICAgICAgKGRvYy5pc05ldyB8fCBkb2MuJGlzU3ViZG9jdW1lbnQpICYmXG4gICAgICBjcmVhdGVkQXQgJiZcbiAgICAgICFkb2MuJF9fZ2V0VmFsdWUoY3JlYXRlZEF0KSAmJlxuICAgICAgZG9jLiRfX2lzU2VsZWN0ZWQoY3JlYXRlZEF0KSkge1xuICAgIGRvYy4kc2V0KGNyZWF0ZWRBdCwgZGVmYXVsdFRpbWVzdGFtcCwgdW5kZWZpbmVkLCB7IG92ZXJ3cml0ZUltbXV0YWJsZTogdHJ1ZSB9KTtcbiAgfVxuXG4gIGlmICghc2tpcFVwZGF0ZWRBdCAmJiB1cGRhdGVkQXQgJiYgKGRvYy5pc05ldyB8fCBkb2MuJGlzTW9kaWZpZWQoKSkpIHtcbiAgICBsZXQgdHMgPSBkZWZhdWx0VGltZXN0YW1wO1xuICAgIGlmIChkb2MuaXNOZXcgJiYgY3JlYXRlZEF0ICE9IG51bGwpIHtcbiAgICAgIHRzID0gZG9jLiRfX2dldFZhbHVlKGNyZWF0ZWRBdCk7XG4gICAgfVxuICAgIGRvYy4kc2V0KHVwZGF0ZWRBdCwgdHMpO1xuICB9XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../server/node_modules/mongoose/lib/helpers/timestamps/setDocumentTimestamps.js\n");

/***/ }),

/***/ "../server/node_modules/mongoose/lib/helpers/timestamps/setupTimestamps.js":
/*!*********************************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/helpers/timestamps/setupTimestamps.js ***!
  \*********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst applyTimestampsToChildren = __webpack_require__(/*! ../update/applyTimestampsToChildren */ \"../server/node_modules/mongoose/lib/helpers/update/applyTimestampsToChildren.js\");\nconst applyTimestampsToUpdate = __webpack_require__(/*! ../update/applyTimestampsToUpdate */ \"../server/node_modules/mongoose/lib/helpers/update/applyTimestampsToUpdate.js\");\nconst get = __webpack_require__(/*! ../get */ \"../server/node_modules/mongoose/lib/helpers/get.js\");\nconst handleTimestampOption = __webpack_require__(/*! ../schema/handleTimestampOption */ \"../server/node_modules/mongoose/lib/helpers/schema/handleTimestampOption.js\");\nconst setDocumentTimestamps = __webpack_require__(/*! ./setDocumentTimestamps */ \"../server/node_modules/mongoose/lib/helpers/timestamps/setDocumentTimestamps.js\");\nconst symbols = __webpack_require__(/*! ../../schema/symbols */ \"../server/node_modules/mongoose/lib/schema/symbols.js\");\n\nconst replaceOps = new Set([\n  'replaceOne',\n  'findOneAndReplace'\n]);\n\nmodule.exports = function setupTimestamps(schema, timestamps) {\n  const childHasTimestamp = schema.childSchemas.find(withTimestamp);\n  function withTimestamp(s) {\n    const ts = s.schema.options.timestamps;\n    return !!ts;\n  }\n  if (!timestamps && !childHasTimestamp) {\n    return;\n  }\n  const createdAt = handleTimestampOption(timestamps, 'createdAt');\n  const updatedAt = handleTimestampOption(timestamps, 'updatedAt');\n  const currentTime = timestamps != null && timestamps.hasOwnProperty('currentTime') ?\n    timestamps.currentTime :\n    null;\n  const schemaAdditions = {};\n\n  schema.$timestamps = { createdAt: createdAt, updatedAt: updatedAt };\n\n  if (createdAt && !schema.paths[createdAt]) {\n    const baseImmutableCreatedAt = schema.base != null ? schema.base.get('timestamps.createdAt.immutable') : null;\n    const immutable = baseImmutableCreatedAt != null ? baseImmutableCreatedAt : true;\n    schemaAdditions[createdAt] = { [schema.options.typeKey || 'type']: Date, immutable };\n  }\n\n  if (updatedAt && !schema.paths[updatedAt]) {\n    schemaAdditions[updatedAt] = Date;\n  }\n\n  schema.add(schemaAdditions);\n\n  schema.pre('save', function timestampsPreSave(next) {\n    const timestampOption = get(this, '$__.saveOptions.timestamps');\n    if (timestampOption === false) {\n      return next();\n    }\n\n    setDocumentTimestamps(this, timestampOption, currentTime, createdAt, updatedAt);\n\n    next();\n  });\n\n  schema.methods.initializeTimestamps = function() {\n    const ts = currentTime != null ?\n      currentTime() : this.constructor.base.now();\n\n\n    if (createdAt && !this.get(createdAt)) {\n      this.$set(createdAt, ts);\n    }\n    if (updatedAt && !this.get(updatedAt)) {\n      this.$set(updatedAt, ts);\n    }\n    if (this.$isSubdocument) {\n      return this;\n    }\n\n    const subdocs = this.$getAllSubdocs();\n    for (const subdoc of subdocs) {\n      if (subdoc.initializeTimestamps) {\n        subdoc.initializeTimestamps();\n      }\n    }\n\n    return this;\n  };\n\n  _setTimestampsOnUpdate[symbols.builtInMiddleware] = true;\n\n  const opts = { query: true, model: false };\n  schema.pre('findOneAndReplace', opts, _setTimestampsOnUpdate);\n  schema.pre('findOneAndUpdate', opts, _setTimestampsOnUpdate);\n  schema.pre('replaceOne', opts, _setTimestampsOnUpdate);\n  schema.pre('update', opts, _setTimestampsOnUpdate);\n  schema.pre('updateOne', opts, _setTimestampsOnUpdate);\n  schema.pre('updateMany', opts, _setTimestampsOnUpdate);\n\n  function _setTimestampsOnUpdate(next) {\n    const now = currentTime != null ?\n      currentTime() :\n      this.model.base.now();\n    // Replacing with null update should still trigger timestamps\n    if (replaceOps.has(this.op) && this.getUpdate() == null) {\n      this.setUpdate({});\n    }\n    applyTimestampsToUpdate(\n      now,\n      createdAt,\n      updatedAt,\n      this.getUpdate(),\n      this._mongooseOptions,\n      replaceOps.has(this.op)\n    );\n    applyTimestampsToChildren(now, this.getUpdate(), this.model.schema);\n    next();\n  }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy90aW1lc3RhbXBzL3NldHVwVGltZXN0YW1wcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixrQ0FBa0MsbUJBQU8sQ0FBQyw0SEFBcUM7QUFDL0UsZ0NBQWdDLG1CQUFPLENBQUMsd0hBQW1DO0FBQzNFLFlBQVksbUJBQU8sQ0FBQyxrRUFBUTtBQUM1Qiw4QkFBOEIsbUJBQU8sQ0FBQyxvSEFBaUM7QUFDdkUsOEJBQThCLG1CQUFPLENBQUMsZ0hBQXlCO0FBQy9ELGdCQUFnQixtQkFBTyxDQUFDLG1GQUFzQjs7QUFFOUM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHlCQUF5Qjs7QUFFekI7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2NsaWVudC8uLi9zZXJ2ZXIvbm9kZV9tb2R1bGVzL21vbmdvb3NlL2xpYi9oZWxwZXJzL3RpbWVzdGFtcHMvc2V0dXBUaW1lc3RhbXBzLmpzPzA5MjQiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBhcHBseVRpbWVzdGFtcHNUb0NoaWxkcmVuID0gcmVxdWlyZSgnLi4vdXBkYXRlL2FwcGx5VGltZXN0YW1wc1RvQ2hpbGRyZW4nKTtcbmNvbnN0IGFwcGx5VGltZXN0YW1wc1RvVXBkYXRlID0gcmVxdWlyZSgnLi4vdXBkYXRlL2FwcGx5VGltZXN0YW1wc1RvVXBkYXRlJyk7XG5jb25zdCBnZXQgPSByZXF1aXJlKCcuLi9nZXQnKTtcbmNvbnN0IGhhbmRsZVRpbWVzdGFtcE9wdGlvbiA9IHJlcXVpcmUoJy4uL3NjaGVtYS9oYW5kbGVUaW1lc3RhbXBPcHRpb24nKTtcbmNvbnN0IHNldERvY3VtZW50VGltZXN0YW1wcyA9IHJlcXVpcmUoJy4vc2V0RG9jdW1lbnRUaW1lc3RhbXBzJyk7XG5jb25zdCBzeW1ib2xzID0gcmVxdWlyZSgnLi4vLi4vc2NoZW1hL3N5bWJvbHMnKTtcblxuY29uc3QgcmVwbGFjZU9wcyA9IG5ldyBTZXQoW1xuICAncmVwbGFjZU9uZScsXG4gICdmaW5kT25lQW5kUmVwbGFjZSdcbl0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHNldHVwVGltZXN0YW1wcyhzY2hlbWEsIHRpbWVzdGFtcHMpIHtcbiAgY29uc3QgY2hpbGRIYXNUaW1lc3RhbXAgPSBzY2hlbWEuY2hpbGRTY2hlbWFzLmZpbmQod2l0aFRpbWVzdGFtcCk7XG4gIGZ1bmN0aW9uIHdpdGhUaW1lc3RhbXAocykge1xuICAgIGNvbnN0IHRzID0gcy5zY2hlbWEub3B0aW9ucy50aW1lc3RhbXBzO1xuICAgIHJldHVybiAhIXRzO1xuICB9XG4gIGlmICghdGltZXN0YW1wcyAmJiAhY2hpbGRIYXNUaW1lc3RhbXApIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgY3JlYXRlZEF0ID0gaGFuZGxlVGltZXN0YW1wT3B0aW9uKHRpbWVzdGFtcHMsICdjcmVhdGVkQXQnKTtcbiAgY29uc3QgdXBkYXRlZEF0ID0gaGFuZGxlVGltZXN0YW1wT3B0aW9uKHRpbWVzdGFtcHMsICd1cGRhdGVkQXQnKTtcbiAgY29uc3QgY3VycmVudFRpbWUgPSB0aW1lc3RhbXBzICE9IG51bGwgJiYgdGltZXN0YW1wcy5oYXNPd25Qcm9wZXJ0eSgnY3VycmVudFRpbWUnKSA/XG4gICAgdGltZXN0YW1wcy5jdXJyZW50VGltZSA6XG4gICAgbnVsbDtcbiAgY29uc3Qgc2NoZW1hQWRkaXRpb25zID0ge307XG5cbiAgc2NoZW1hLiR0aW1lc3RhbXBzID0geyBjcmVhdGVkQXQ6IGNyZWF0ZWRBdCwgdXBkYXRlZEF0OiB1cGRhdGVkQXQgfTtcblxuICBpZiAoY3JlYXRlZEF0ICYmICFzY2hlbWEucGF0aHNbY3JlYXRlZEF0XSkge1xuICAgIGNvbnN0IGJhc2VJbW11dGFibGVDcmVhdGVkQXQgPSBzY2hlbWEuYmFzZSAhPSBudWxsID8gc2NoZW1hLmJhc2UuZ2V0KCd0aW1lc3RhbXBzLmNyZWF0ZWRBdC5pbW11dGFibGUnKSA6IG51bGw7XG4gICAgY29uc3QgaW1tdXRhYmxlID0gYmFzZUltbXV0YWJsZUNyZWF0ZWRBdCAhPSBudWxsID8gYmFzZUltbXV0YWJsZUNyZWF0ZWRBdCA6IHRydWU7XG4gICAgc2NoZW1hQWRkaXRpb25zW2NyZWF0ZWRBdF0gPSB7IFtzY2hlbWEub3B0aW9ucy50eXBlS2V5IHx8ICd0eXBlJ106IERhdGUsIGltbXV0YWJsZSB9O1xuICB9XG5cbiAgaWYgKHVwZGF0ZWRBdCAmJiAhc2NoZW1hLnBhdGhzW3VwZGF0ZWRBdF0pIHtcbiAgICBzY2hlbWFBZGRpdGlvbnNbdXBkYXRlZEF0XSA9IERhdGU7XG4gIH1cblxuICBzY2hlbWEuYWRkKHNjaGVtYUFkZGl0aW9ucyk7XG5cbiAgc2NoZW1hLnByZSgnc2F2ZScsIGZ1bmN0aW9uIHRpbWVzdGFtcHNQcmVTYXZlKG5leHQpIHtcbiAgICBjb25zdCB0aW1lc3RhbXBPcHRpb24gPSBnZXQodGhpcywgJyRfXy5zYXZlT3B0aW9ucy50aW1lc3RhbXBzJyk7XG4gICAgaWYgKHRpbWVzdGFtcE9wdGlvbiA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybiBuZXh0KCk7XG4gICAgfVxuXG4gICAgc2V0RG9jdW1lbnRUaW1lc3RhbXBzKHRoaXMsIHRpbWVzdGFtcE9wdGlvbiwgY3VycmVudFRpbWUsIGNyZWF0ZWRBdCwgdXBkYXRlZEF0KTtcblxuICAgIG5leHQoKTtcbiAgfSk7XG5cbiAgc2NoZW1hLm1ldGhvZHMuaW5pdGlhbGl6ZVRpbWVzdGFtcHMgPSBmdW5jdGlvbigpIHtcbiAgICBjb25zdCB0cyA9IGN1cnJlbnRUaW1lICE9IG51bGwgP1xuICAgICAgY3VycmVudFRpbWUoKSA6IHRoaXMuY29uc3RydWN0b3IuYmFzZS5ub3coKTtcblxuXG4gICAgaWYgKGNyZWF0ZWRBdCAmJiAhdGhpcy5nZXQoY3JlYXRlZEF0KSkge1xuICAgICAgdGhpcy4kc2V0KGNyZWF0ZWRBdCwgdHMpO1xuICAgIH1cbiAgICBpZiAodXBkYXRlZEF0ICYmICF0aGlzLmdldCh1cGRhdGVkQXQpKSB7XG4gICAgICB0aGlzLiRzZXQodXBkYXRlZEF0LCB0cyk7XG4gICAgfVxuICAgIGlmICh0aGlzLiRpc1N1YmRvY3VtZW50KSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBjb25zdCBzdWJkb2NzID0gdGhpcy4kZ2V0QWxsU3ViZG9jcygpO1xuICAgIGZvciAoY29uc3Qgc3ViZG9jIG9mIHN1YmRvY3MpIHtcbiAgICAgIGlmIChzdWJkb2MuaW5pdGlhbGl6ZVRpbWVzdGFtcHMpIHtcbiAgICAgICAgc3ViZG9jLmluaXRpYWxpemVUaW1lc3RhbXBzKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgX3NldFRpbWVzdGFtcHNPblVwZGF0ZVtzeW1ib2xzLmJ1aWx0SW5NaWRkbGV3YXJlXSA9IHRydWU7XG5cbiAgY29uc3Qgb3B0cyA9IHsgcXVlcnk6IHRydWUsIG1vZGVsOiBmYWxzZSB9O1xuICBzY2hlbWEucHJlKCdmaW5kT25lQW5kUmVwbGFjZScsIG9wdHMsIF9zZXRUaW1lc3RhbXBzT25VcGRhdGUpO1xuICBzY2hlbWEucHJlKCdmaW5kT25lQW5kVXBkYXRlJywgb3B0cywgX3NldFRpbWVzdGFtcHNPblVwZGF0ZSk7XG4gIHNjaGVtYS5wcmUoJ3JlcGxhY2VPbmUnLCBvcHRzLCBfc2V0VGltZXN0YW1wc09uVXBkYXRlKTtcbiAgc2NoZW1hLnByZSgndXBkYXRlJywgb3B0cywgX3NldFRpbWVzdGFtcHNPblVwZGF0ZSk7XG4gIHNjaGVtYS5wcmUoJ3VwZGF0ZU9uZScsIG9wdHMsIF9zZXRUaW1lc3RhbXBzT25VcGRhdGUpO1xuICBzY2hlbWEucHJlKCd1cGRhdGVNYW55Jywgb3B0cywgX3NldFRpbWVzdGFtcHNPblVwZGF0ZSk7XG5cbiAgZnVuY3Rpb24gX3NldFRpbWVzdGFtcHNPblVwZGF0ZShuZXh0KSB7XG4gICAgY29uc3Qgbm93ID0gY3VycmVudFRpbWUgIT0gbnVsbCA/XG4gICAgICBjdXJyZW50VGltZSgpIDpcbiAgICAgIHRoaXMubW9kZWwuYmFzZS5ub3coKTtcbiAgICAvLyBSZXBsYWNpbmcgd2l0aCBudWxsIHVwZGF0ZSBzaG91bGQgc3RpbGwgdHJpZ2dlciB0aW1lc3RhbXBzXG4gICAgaWYgKHJlcGxhY2VPcHMuaGFzKHRoaXMub3ApICYmIHRoaXMuZ2V0VXBkYXRlKCkgPT0gbnVsbCkge1xuICAgICAgdGhpcy5zZXRVcGRhdGUoe30pO1xuICAgIH1cbiAgICBhcHBseVRpbWVzdGFtcHNUb1VwZGF0ZShcbiAgICAgIG5vdyxcbiAgICAgIGNyZWF0ZWRBdCxcbiAgICAgIHVwZGF0ZWRBdCxcbiAgICAgIHRoaXMuZ2V0VXBkYXRlKCksXG4gICAgICB0aGlzLl9tb25nb29zZU9wdGlvbnMsXG4gICAgICByZXBsYWNlT3BzLmhhcyh0aGlzLm9wKVxuICAgICk7XG4gICAgYXBwbHlUaW1lc3RhbXBzVG9DaGlsZHJlbihub3csIHRoaXMuZ2V0VXBkYXRlKCksIHRoaXMubW9kZWwuc2NoZW1hKTtcbiAgICBuZXh0KCk7XG4gIH1cbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../server/node_modules/mongoose/lib/helpers/timestamps/setupTimestamps.js\n");

/***/ }),

/***/ "../server/node_modules/mongoose/lib/helpers/topology/allServersUnknown.js":
/*!*********************************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/helpers/topology/allServersUnknown.js ***!
  \*********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst getConstructorName = __webpack_require__(/*! ../getConstructorName */ \"../server/node_modules/mongoose/lib/helpers/getConstructorName.js\");\n\nmodule.exports = function allServersUnknown(topologyDescription) {\n  if (getConstructorName(topologyDescription) !== 'TopologyDescription') {\n    return false;\n  }\n\n  const servers = Array.from(topologyDescription.servers.values());\n  return servers.length > 0 && servers.every(server => server.type === 'Unknown');\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy90b3BvbG9neS9hbGxTZXJ2ZXJzVW5rbm93bi5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYiwyQkFBMkIsbUJBQU8sQ0FBQyxnR0FBdUI7O0FBRTFEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2NsaWVudC8uLi9zZXJ2ZXIvbm9kZV9tb2R1bGVzL21vbmdvb3NlL2xpYi9oZWxwZXJzL3RvcG9sb2d5L2FsbFNlcnZlcnNVbmtub3duLmpzP2VmZWYiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBnZXRDb25zdHJ1Y3Rvck5hbWUgPSByZXF1aXJlKCcuLi9nZXRDb25zdHJ1Y3Rvck5hbWUnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBhbGxTZXJ2ZXJzVW5rbm93bih0b3BvbG9neURlc2NyaXB0aW9uKSB7XG4gIGlmIChnZXRDb25zdHJ1Y3Rvck5hbWUodG9wb2xvZ3lEZXNjcmlwdGlvbikgIT09ICdUb3BvbG9neURlc2NyaXB0aW9uJykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGNvbnN0IHNlcnZlcnMgPSBBcnJheS5mcm9tKHRvcG9sb2d5RGVzY3JpcHRpb24uc2VydmVycy52YWx1ZXMoKSk7XG4gIHJldHVybiBzZXJ2ZXJzLmxlbmd0aCA+IDAgJiYgc2VydmVycy5ldmVyeShzZXJ2ZXIgPT4gc2VydmVyLnR5cGUgPT09ICdVbmtub3duJyk7XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../server/node_modules/mongoose/lib/helpers/topology/allServersUnknown.js\n");

/***/ }),

/***/ "../server/node_modules/mongoose/lib/helpers/topology/isAtlas.js":
/*!***********************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/helpers/topology/isAtlas.js ***!
  \***********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst getConstructorName = __webpack_require__(/*! ../getConstructorName */ \"../server/node_modules/mongoose/lib/helpers/getConstructorName.js\");\n\n/**\n * @typedef { import('mongodb').TopologyDescription } TopologyDescription\n */\n\n/**\n * Checks if topologyDescription contains servers connected to an atlas instance\n *\n * @param  {TopologyDescription} topologyDescription\n * @returns {boolean}\n */\nmodule.exports = function isAtlas(topologyDescription) {\n  if (getConstructorName(topologyDescription) !== 'TopologyDescription') {\n    return false;\n  }\n\n  if (topologyDescription.servers.size === 0) {\n    return false;\n  }\n\n  for (const server of topologyDescription.servers.values()) {\n    if (server.host.endsWith('.mongodb.net') === false || server.port !== 27017) {\n      return false;\n    }\n  }\n\n  return true;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy90b3BvbG9neS9pc0F0bGFzLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLDJCQUEyQixtQkFBTyxDQUFDLGdHQUF1Qjs7QUFFMUQ7QUFDQSxjQUFjLHdDQUF3QztBQUN0RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHFCQUFxQjtBQUNqQyxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2xpZW50Ly4uL3NlcnZlci9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvdG9wb2xvZ3kvaXNBdGxhcy5qcz85NzMyIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3QgZ2V0Q29uc3RydWN0b3JOYW1lID0gcmVxdWlyZSgnLi4vZ2V0Q29uc3RydWN0b3JOYW1lJyk7XG5cbi8qKlxuICogQHR5cGVkZWYgeyBpbXBvcnQoJ21vbmdvZGInKS5Ub3BvbG9neURlc2NyaXB0aW9uIH0gVG9wb2xvZ3lEZXNjcmlwdGlvblxuICovXG5cbi8qKlxuICogQ2hlY2tzIGlmIHRvcG9sb2d5RGVzY3JpcHRpb24gY29udGFpbnMgc2VydmVycyBjb25uZWN0ZWQgdG8gYW4gYXRsYXMgaW5zdGFuY2VcbiAqXG4gKiBAcGFyYW0gIHtUb3BvbG9neURlc2NyaXB0aW9ufSB0b3BvbG9neURlc2NyaXB0aW9uXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc0F0bGFzKHRvcG9sb2d5RGVzY3JpcHRpb24pIHtcbiAgaWYgKGdldENvbnN0cnVjdG9yTmFtZSh0b3BvbG9neURlc2NyaXB0aW9uKSAhPT0gJ1RvcG9sb2d5RGVzY3JpcHRpb24nKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKHRvcG9sb2d5RGVzY3JpcHRpb24uc2VydmVycy5zaXplID09PSAwKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgZm9yIChjb25zdCBzZXJ2ZXIgb2YgdG9wb2xvZ3lEZXNjcmlwdGlvbi5zZXJ2ZXJzLnZhbHVlcygpKSB7XG4gICAgaWYgKHNlcnZlci5ob3N0LmVuZHNXaXRoKCcubW9uZ29kYi5uZXQnKSA9PT0gZmFsc2UgfHwgc2VydmVyLnBvcnQgIT09IDI3MDE3KSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../server/node_modules/mongoose/lib/helpers/topology/isAtlas.js\n");

/***/ }),

/***/ "../server/node_modules/mongoose/lib/helpers/topology/isSSLError.js":
/*!**************************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/helpers/topology/isSSLError.js ***!
  \**************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst getConstructorName = __webpack_require__(/*! ../getConstructorName */ \"../server/node_modules/mongoose/lib/helpers/getConstructorName.js\");\n\nconst nonSSLMessage = 'Client network socket disconnected before secure TLS ' +\n  'connection was established';\n\nmodule.exports = function isSSLError(topologyDescription) {\n  if (getConstructorName(topologyDescription) !== 'TopologyDescription') {\n    return false;\n  }\n\n  const descriptions = Array.from(topologyDescription.servers.values());\n  return descriptions.length > 0 &&\n    descriptions.every(descr => descr.error && descr.error.message.indexOf(nonSSLMessage) !== -1);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy90b3BvbG9neS9pc1NTTEVycm9yLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLDJCQUEyQixtQkFBTyxDQUFDLGdHQUF1Qjs7QUFFMUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2NsaWVudC8uLi9zZXJ2ZXIvbm9kZV9tb2R1bGVzL21vbmdvb3NlL2xpYi9oZWxwZXJzL3RvcG9sb2d5L2lzU1NMRXJyb3IuanM/MzZmZiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IGdldENvbnN0cnVjdG9yTmFtZSA9IHJlcXVpcmUoJy4uL2dldENvbnN0cnVjdG9yTmFtZScpO1xuXG5jb25zdCBub25TU0xNZXNzYWdlID0gJ0NsaWVudCBuZXR3b3JrIHNvY2tldCBkaXNjb25uZWN0ZWQgYmVmb3JlIHNlY3VyZSBUTFMgJyArXG4gICdjb25uZWN0aW9uIHdhcyBlc3RhYmxpc2hlZCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNTU0xFcnJvcih0b3BvbG9neURlc2NyaXB0aW9uKSB7XG4gIGlmIChnZXRDb25zdHJ1Y3Rvck5hbWUodG9wb2xvZ3lEZXNjcmlwdGlvbikgIT09ICdUb3BvbG9neURlc2NyaXB0aW9uJykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGNvbnN0IGRlc2NyaXB0aW9ucyA9IEFycmF5LmZyb20odG9wb2xvZ3lEZXNjcmlwdGlvbi5zZXJ2ZXJzLnZhbHVlcygpKTtcbiAgcmV0dXJuIGRlc2NyaXB0aW9ucy5sZW5ndGggPiAwICYmXG4gICAgZGVzY3JpcHRpb25zLmV2ZXJ5KGRlc2NyID0+IGRlc2NyLmVycm9yICYmIGRlc2NyLmVycm9yLm1lc3NhZ2UuaW5kZXhPZihub25TU0xNZXNzYWdlKSAhPT0gLTEpO1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../server/node_modules/mongoose/lib/helpers/topology/isSSLError.js\n");

/***/ }),

/***/ "../server/node_modules/mongoose/lib/helpers/update/applyTimestampsToChildren.js":
/*!***************************************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/helpers/update/applyTimestampsToChildren.js ***!
  \***************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst cleanPositionalOperators = __webpack_require__(/*! ../schema/cleanPositionalOperators */ \"../server/node_modules/mongoose/lib/helpers/schema/cleanPositionalOperators.js\");\nconst handleTimestampOption = __webpack_require__(/*! ../schema/handleTimestampOption */ \"../server/node_modules/mongoose/lib/helpers/schema/handleTimestampOption.js\");\n\nmodule.exports = applyTimestampsToChildren;\n\n/*!\n * ignore\n */\n\nfunction applyTimestampsToChildren(now, update, schema) {\n  if (update == null) {\n    return;\n  }\n\n  const keys = Object.keys(update);\n  const hasDollarKey = keys.some(key => key[0] === '$');\n\n  if (hasDollarKey) {\n    if (update.$push) {\n      _applyTimestampToUpdateOperator(update.$push);\n    }\n    if (update.$addToSet) {\n      _applyTimestampToUpdateOperator(update.$addToSet);\n    }\n    if (update.$set != null) {\n      const keys = Object.keys(update.$set);\n      for (const key of keys) {\n        applyTimestampsToUpdateKey(schema, key, update.$set, now);\n      }\n    }\n    if (update.$setOnInsert != null) {\n      const keys = Object.keys(update.$setOnInsert);\n      for (const key of keys) {\n        applyTimestampsToUpdateKey(schema, key, update.$setOnInsert, now);\n      }\n    }\n  }\n\n  const updateKeys = Object.keys(update).filter(key => key[0] !== '$');\n  for (const key of updateKeys) {\n    applyTimestampsToUpdateKey(schema, key, update, now);\n  }\n\n  function _applyTimestampToUpdateOperator(op) {\n    for (const key of Object.keys(op)) {\n      const $path = schema.path(key.replace(/\\.\\$\\./i, '.').replace(/.\\$$/, ''));\n      if (op[key] &&\n          $path &&\n          $path.$isMongooseDocumentArray &&\n          $path.schema.options.timestamps) {\n        const timestamps = $path.schema.options.timestamps;\n        const createdAt = handleTimestampOption(timestamps, 'createdAt');\n        const updatedAt = handleTimestampOption(timestamps, 'updatedAt');\n        if (op[key].$each) {\n          op[key].$each.forEach(function(subdoc) {\n            if (updatedAt != null) {\n              subdoc[updatedAt] = now;\n            }\n            if (createdAt != null) {\n              subdoc[createdAt] = now;\n            }\n\n            applyTimestampsToChildren(now, subdoc, $path.schema);\n          });\n        } else {\n          if (updatedAt != null) {\n            op[key][updatedAt] = now;\n          }\n          if (createdAt != null) {\n            op[key][createdAt] = now;\n          }\n\n          applyTimestampsToChildren(now, op[key], $path.schema);\n        }\n      }\n    }\n  }\n}\n\nfunction applyTimestampsToDocumentArray(arr, schematype, now) {\n  const timestamps = schematype.schema.options.timestamps;\n\n  const len = arr.length;\n\n  if (!timestamps) {\n    for (let i = 0; i < len; ++i) {\n      applyTimestampsToChildren(now, arr[i], schematype.schema);\n    }\n    return;\n  }\n\n  const createdAt = handleTimestampOption(timestamps, 'createdAt');\n  const updatedAt = handleTimestampOption(timestamps, 'updatedAt');\n  for (let i = 0; i < len; ++i) {\n    if (updatedAt != null) {\n      arr[i][updatedAt] = now;\n    }\n    if (createdAt != null) {\n      arr[i][createdAt] = now;\n    }\n\n    applyTimestampsToChildren(now, arr[i], schematype.schema);\n  }\n}\n\nfunction applyTimestampsToSingleNested(subdoc, schematype, now) {\n  const timestamps = schematype.schema.options.timestamps;\n  if (!timestamps) {\n    applyTimestampsToChildren(now, subdoc, schematype.schema);\n    return;\n  }\n\n  const createdAt = handleTimestampOption(timestamps, 'createdAt');\n  const updatedAt = handleTimestampOption(timestamps, 'updatedAt');\n  if (updatedAt != null) {\n    subdoc[updatedAt] = now;\n  }\n  if (createdAt != null) {\n    subdoc[createdAt] = now;\n  }\n\n  applyTimestampsToChildren(now, subdoc, schematype.schema);\n}\n\nfunction applyTimestampsToUpdateKey(schema, key, update, now) {\n  // Replace positional operator `$` and array filters `$[]` and `$[.*]`\n  const keyToSearch = cleanPositionalOperators(key);\n  const path = schema.path(keyToSearch);\n  if (!path) {\n    return;\n  }\n\n  const parentSchemaTypes = [];\n  const pieces = keyToSearch.split('.');\n  for (let i = pieces.length - 1; i > 0; --i) {\n    const s = schema.path(pieces.slice(0, i).join('.'));\n    if (s != null &&\n      (s.$isMongooseDocumentArray || s.$isSingleNested)) {\n      parentSchemaTypes.push({ parentPath: key.split('.').slice(0, i).join('.'), parentSchemaType: s });\n    }\n  }\n\n  if (Array.isArray(update[key]) && path.$isMongooseDocumentArray) {\n    applyTimestampsToDocumentArray(update[key], path, now);\n  } else if (update[key] && path.$isSingleNested) {\n    applyTimestampsToSingleNested(update[key], path, now);\n  } else if (parentSchemaTypes.length > 0) {\n    for (const item of parentSchemaTypes) {\n      const parentPath = item.parentPath;\n      const parentSchemaType = item.parentSchemaType;\n      const timestamps = parentSchemaType.schema.options.timestamps;\n      const updatedAt = handleTimestampOption(timestamps, 'updatedAt');\n\n      if (!timestamps || updatedAt == null) {\n        continue;\n      }\n\n      if (parentSchemaType.$isSingleNested) {\n        // Single nested is easy\n        update[parentPath + '.' + updatedAt] = now;\n      } else if (parentSchemaType.$isMongooseDocumentArray) {\n        let childPath = key.substring(parentPath.length + 1);\n\n        if (/^\\d+$/.test(childPath)) {\n          update[parentPath + '.' + childPath][updatedAt] = now;\n          continue;\n        }\n\n        const firstDot = childPath.indexOf('.');\n        childPath = firstDot !== -1 ? childPath.substring(0, firstDot) : childPath;\n\n        update[parentPath + '.' + childPath + '.' + updatedAt] = now;\n      }\n    }\n  } else if (path.schema != null && path.schema != schema && update[key]) {\n    const timestamps = path.schema.options.timestamps;\n    const createdAt = handleTimestampOption(timestamps, 'createdAt');\n    const updatedAt = handleTimestampOption(timestamps, 'updatedAt');\n\n    if (!timestamps) {\n      return;\n    }\n\n    if (updatedAt != null) {\n      update[key][updatedAt] = now;\n    }\n    if (createdAt != null) {\n      update[key][createdAt] = now;\n    }\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy91cGRhdGUvYXBwbHlUaW1lc3RhbXBzVG9DaGlsZHJlbi5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixpQ0FBaUMsbUJBQU8sQ0FBQywwSEFBb0M7QUFDN0UsOEJBQThCLG1CQUFPLENBQUMsb0hBQWlDOztBQUV2RTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVc7QUFDWCxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQixTQUFTO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0NBQWtDLE9BQU87QUFDekM7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLHVFQUF1RTtBQUN0RztBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2NsaWVudC8uLi9zZXJ2ZXIvbm9kZV9tb2R1bGVzL21vbmdvb3NlL2xpYi9oZWxwZXJzL3VwZGF0ZS9hcHBseVRpbWVzdGFtcHNUb0NoaWxkcmVuLmpzPzVhNWMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBjbGVhblBvc2l0aW9uYWxPcGVyYXRvcnMgPSByZXF1aXJlKCcuLi9zY2hlbWEvY2xlYW5Qb3NpdGlvbmFsT3BlcmF0b3JzJyk7XG5jb25zdCBoYW5kbGVUaW1lc3RhbXBPcHRpb24gPSByZXF1aXJlKCcuLi9zY2hlbWEvaGFuZGxlVGltZXN0YW1wT3B0aW9uJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gYXBwbHlUaW1lc3RhbXBzVG9DaGlsZHJlbjtcblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5mdW5jdGlvbiBhcHBseVRpbWVzdGFtcHNUb0NoaWxkcmVuKG5vdywgdXBkYXRlLCBzY2hlbWEpIHtcbiAgaWYgKHVwZGF0ZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHVwZGF0ZSk7XG4gIGNvbnN0IGhhc0RvbGxhcktleSA9IGtleXMuc29tZShrZXkgPT4ga2V5WzBdID09PSAnJCcpO1xuXG4gIGlmIChoYXNEb2xsYXJLZXkpIHtcbiAgICBpZiAodXBkYXRlLiRwdXNoKSB7XG4gICAgICBfYXBwbHlUaW1lc3RhbXBUb1VwZGF0ZU9wZXJhdG9yKHVwZGF0ZS4kcHVzaCk7XG4gICAgfVxuICAgIGlmICh1cGRhdGUuJGFkZFRvU2V0KSB7XG4gICAgICBfYXBwbHlUaW1lc3RhbXBUb1VwZGF0ZU9wZXJhdG9yKHVwZGF0ZS4kYWRkVG9TZXQpO1xuICAgIH1cbiAgICBpZiAodXBkYXRlLiRzZXQgIT0gbnVsbCkge1xuICAgICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHVwZGF0ZS4kc2V0KTtcbiAgICAgIGZvciAoY29uc3Qga2V5IG9mIGtleXMpIHtcbiAgICAgICAgYXBwbHlUaW1lc3RhbXBzVG9VcGRhdGVLZXkoc2NoZW1hLCBrZXksIHVwZGF0ZS4kc2V0LCBub3cpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodXBkYXRlLiRzZXRPbkluc2VydCAhPSBudWxsKSB7XG4gICAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXModXBkYXRlLiRzZXRPbkluc2VydCk7XG4gICAgICBmb3IgKGNvbnN0IGtleSBvZiBrZXlzKSB7XG4gICAgICAgIGFwcGx5VGltZXN0YW1wc1RvVXBkYXRlS2V5KHNjaGVtYSwga2V5LCB1cGRhdGUuJHNldE9uSW5zZXJ0LCBub3cpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGNvbnN0IHVwZGF0ZUtleXMgPSBPYmplY3Qua2V5cyh1cGRhdGUpLmZpbHRlcihrZXkgPT4ga2V5WzBdICE9PSAnJCcpO1xuICBmb3IgKGNvbnN0IGtleSBvZiB1cGRhdGVLZXlzKSB7XG4gICAgYXBwbHlUaW1lc3RhbXBzVG9VcGRhdGVLZXkoc2NoZW1hLCBrZXksIHVwZGF0ZSwgbm93KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9hcHBseVRpbWVzdGFtcFRvVXBkYXRlT3BlcmF0b3Iob3ApIHtcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhvcCkpIHtcbiAgICAgIGNvbnN0ICRwYXRoID0gc2NoZW1hLnBhdGgoa2V5LnJlcGxhY2UoL1xcLlxcJFxcLi9pLCAnLicpLnJlcGxhY2UoLy5cXCQkLywgJycpKTtcbiAgICAgIGlmIChvcFtrZXldICYmXG4gICAgICAgICAgJHBhdGggJiZcbiAgICAgICAgICAkcGF0aC4kaXNNb25nb29zZURvY3VtZW50QXJyYXkgJiZcbiAgICAgICAgICAkcGF0aC5zY2hlbWEub3B0aW9ucy50aW1lc3RhbXBzKSB7XG4gICAgICAgIGNvbnN0IHRpbWVzdGFtcHMgPSAkcGF0aC5zY2hlbWEub3B0aW9ucy50aW1lc3RhbXBzO1xuICAgICAgICBjb25zdCBjcmVhdGVkQXQgPSBoYW5kbGVUaW1lc3RhbXBPcHRpb24odGltZXN0YW1wcywgJ2NyZWF0ZWRBdCcpO1xuICAgICAgICBjb25zdCB1cGRhdGVkQXQgPSBoYW5kbGVUaW1lc3RhbXBPcHRpb24odGltZXN0YW1wcywgJ3VwZGF0ZWRBdCcpO1xuICAgICAgICBpZiAob3Bba2V5XS4kZWFjaCkge1xuICAgICAgICAgIG9wW2tleV0uJGVhY2guZm9yRWFjaChmdW5jdGlvbihzdWJkb2MpIHtcbiAgICAgICAgICAgIGlmICh1cGRhdGVkQXQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICBzdWJkb2NbdXBkYXRlZEF0XSA9IG5vdztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjcmVhdGVkQXQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICBzdWJkb2NbY3JlYXRlZEF0XSA9IG5vdztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYXBwbHlUaW1lc3RhbXBzVG9DaGlsZHJlbihub3csIHN1YmRvYywgJHBhdGguc2NoZW1hKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAodXBkYXRlZEF0ICE9IG51bGwpIHtcbiAgICAgICAgICAgIG9wW2tleV1bdXBkYXRlZEF0XSA9IG5vdztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGNyZWF0ZWRBdCAhPSBudWxsKSB7XG4gICAgICAgICAgICBvcFtrZXldW2NyZWF0ZWRBdF0gPSBub3c7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYXBwbHlUaW1lc3RhbXBzVG9DaGlsZHJlbihub3csIG9wW2tleV0sICRwYXRoLnNjaGVtYSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gYXBwbHlUaW1lc3RhbXBzVG9Eb2N1bWVudEFycmF5KGFyciwgc2NoZW1hdHlwZSwgbm93KSB7XG4gIGNvbnN0IHRpbWVzdGFtcHMgPSBzY2hlbWF0eXBlLnNjaGVtYS5vcHRpb25zLnRpbWVzdGFtcHM7XG5cbiAgY29uc3QgbGVuID0gYXJyLmxlbmd0aDtcblxuICBpZiAoIXRpbWVzdGFtcHMpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICBhcHBseVRpbWVzdGFtcHNUb0NoaWxkcmVuKG5vdywgYXJyW2ldLCBzY2hlbWF0eXBlLnNjaGVtYSk7XG4gICAgfVxuICAgIHJldHVybjtcbiAgfVxuXG4gIGNvbnN0IGNyZWF0ZWRBdCA9IGhhbmRsZVRpbWVzdGFtcE9wdGlvbih0aW1lc3RhbXBzLCAnY3JlYXRlZEF0Jyk7XG4gIGNvbnN0IHVwZGF0ZWRBdCA9IGhhbmRsZVRpbWVzdGFtcE9wdGlvbih0aW1lc3RhbXBzLCAndXBkYXRlZEF0Jyk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICBpZiAodXBkYXRlZEF0ICE9IG51bGwpIHtcbiAgICAgIGFycltpXVt1cGRhdGVkQXRdID0gbm93O1xuICAgIH1cbiAgICBpZiAoY3JlYXRlZEF0ICE9IG51bGwpIHtcbiAgICAgIGFycltpXVtjcmVhdGVkQXRdID0gbm93O1xuICAgIH1cblxuICAgIGFwcGx5VGltZXN0YW1wc1RvQ2hpbGRyZW4obm93LCBhcnJbaV0sIHNjaGVtYXR5cGUuc2NoZW1hKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBhcHBseVRpbWVzdGFtcHNUb1NpbmdsZU5lc3RlZChzdWJkb2MsIHNjaGVtYXR5cGUsIG5vdykge1xuICBjb25zdCB0aW1lc3RhbXBzID0gc2NoZW1hdHlwZS5zY2hlbWEub3B0aW9ucy50aW1lc3RhbXBzO1xuICBpZiAoIXRpbWVzdGFtcHMpIHtcbiAgICBhcHBseVRpbWVzdGFtcHNUb0NoaWxkcmVuKG5vdywgc3ViZG9jLCBzY2hlbWF0eXBlLnNjaGVtYSk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29uc3QgY3JlYXRlZEF0ID0gaGFuZGxlVGltZXN0YW1wT3B0aW9uKHRpbWVzdGFtcHMsICdjcmVhdGVkQXQnKTtcbiAgY29uc3QgdXBkYXRlZEF0ID0gaGFuZGxlVGltZXN0YW1wT3B0aW9uKHRpbWVzdGFtcHMsICd1cGRhdGVkQXQnKTtcbiAgaWYgKHVwZGF0ZWRBdCAhPSBudWxsKSB7XG4gICAgc3ViZG9jW3VwZGF0ZWRBdF0gPSBub3c7XG4gIH1cbiAgaWYgKGNyZWF0ZWRBdCAhPSBudWxsKSB7XG4gICAgc3ViZG9jW2NyZWF0ZWRBdF0gPSBub3c7XG4gIH1cblxuICBhcHBseVRpbWVzdGFtcHNUb0NoaWxkcmVuKG5vdywgc3ViZG9jLCBzY2hlbWF0eXBlLnNjaGVtYSk7XG59XG5cbmZ1bmN0aW9uIGFwcGx5VGltZXN0YW1wc1RvVXBkYXRlS2V5KHNjaGVtYSwga2V5LCB1cGRhdGUsIG5vdykge1xuICAvLyBSZXBsYWNlIHBvc2l0aW9uYWwgb3BlcmF0b3IgYCRgIGFuZCBhcnJheSBmaWx0ZXJzIGAkW11gIGFuZCBgJFsuKl1gXG4gIGNvbnN0IGtleVRvU2VhcmNoID0gY2xlYW5Qb3NpdGlvbmFsT3BlcmF0b3JzKGtleSk7XG4gIGNvbnN0IHBhdGggPSBzY2hlbWEucGF0aChrZXlUb1NlYXJjaCk7XG4gIGlmICghcGF0aCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGNvbnN0IHBhcmVudFNjaGVtYVR5cGVzID0gW107XG4gIGNvbnN0IHBpZWNlcyA9IGtleVRvU2VhcmNoLnNwbGl0KCcuJyk7XG4gIGZvciAobGV0IGkgPSBwaWVjZXMubGVuZ3RoIC0gMTsgaSA+IDA7IC0taSkge1xuICAgIGNvbnN0IHMgPSBzY2hlbWEucGF0aChwaWVjZXMuc2xpY2UoMCwgaSkuam9pbignLicpKTtcbiAgICBpZiAocyAhPSBudWxsICYmXG4gICAgICAocy4kaXNNb25nb29zZURvY3VtZW50QXJyYXkgfHwgcy4kaXNTaW5nbGVOZXN0ZWQpKSB7XG4gICAgICBwYXJlbnRTY2hlbWFUeXBlcy5wdXNoKHsgcGFyZW50UGF0aDoga2V5LnNwbGl0KCcuJykuc2xpY2UoMCwgaSkuam9pbignLicpLCBwYXJlbnRTY2hlbWFUeXBlOiBzIH0pO1xuICAgIH1cbiAgfVxuXG4gIGlmIChBcnJheS5pc0FycmF5KHVwZGF0ZVtrZXldKSAmJiBwYXRoLiRpc01vbmdvb3NlRG9jdW1lbnRBcnJheSkge1xuICAgIGFwcGx5VGltZXN0YW1wc1RvRG9jdW1lbnRBcnJheSh1cGRhdGVba2V5XSwgcGF0aCwgbm93KTtcbiAgfSBlbHNlIGlmICh1cGRhdGVba2V5XSAmJiBwYXRoLiRpc1NpbmdsZU5lc3RlZCkge1xuICAgIGFwcGx5VGltZXN0YW1wc1RvU2luZ2xlTmVzdGVkKHVwZGF0ZVtrZXldLCBwYXRoLCBub3cpO1xuICB9IGVsc2UgaWYgKHBhcmVudFNjaGVtYVR5cGVzLmxlbmd0aCA+IDApIHtcbiAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgcGFyZW50U2NoZW1hVHlwZXMpIHtcbiAgICAgIGNvbnN0IHBhcmVudFBhdGggPSBpdGVtLnBhcmVudFBhdGg7XG4gICAgICBjb25zdCBwYXJlbnRTY2hlbWFUeXBlID0gaXRlbS5wYXJlbnRTY2hlbWFUeXBlO1xuICAgICAgY29uc3QgdGltZXN0YW1wcyA9IHBhcmVudFNjaGVtYVR5cGUuc2NoZW1hLm9wdGlvbnMudGltZXN0YW1wcztcbiAgICAgIGNvbnN0IHVwZGF0ZWRBdCA9IGhhbmRsZVRpbWVzdGFtcE9wdGlvbih0aW1lc3RhbXBzLCAndXBkYXRlZEF0Jyk7XG5cbiAgICAgIGlmICghdGltZXN0YW1wcyB8fCB1cGRhdGVkQXQgPT0gbnVsbCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHBhcmVudFNjaGVtYVR5cGUuJGlzU2luZ2xlTmVzdGVkKSB7XG4gICAgICAgIC8vIFNpbmdsZSBuZXN0ZWQgaXMgZWFzeVxuICAgICAgICB1cGRhdGVbcGFyZW50UGF0aCArICcuJyArIHVwZGF0ZWRBdF0gPSBub3c7XG4gICAgICB9IGVsc2UgaWYgKHBhcmVudFNjaGVtYVR5cGUuJGlzTW9uZ29vc2VEb2N1bWVudEFycmF5KSB7XG4gICAgICAgIGxldCBjaGlsZFBhdGggPSBrZXkuc3Vic3RyaW5nKHBhcmVudFBhdGgubGVuZ3RoICsgMSk7XG5cbiAgICAgICAgaWYgKC9eXFxkKyQvLnRlc3QoY2hpbGRQYXRoKSkge1xuICAgICAgICAgIHVwZGF0ZVtwYXJlbnRQYXRoICsgJy4nICsgY2hpbGRQYXRoXVt1cGRhdGVkQXRdID0gbm93O1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgZmlyc3REb3QgPSBjaGlsZFBhdGguaW5kZXhPZignLicpO1xuICAgICAgICBjaGlsZFBhdGggPSBmaXJzdERvdCAhPT0gLTEgPyBjaGlsZFBhdGguc3Vic3RyaW5nKDAsIGZpcnN0RG90KSA6IGNoaWxkUGF0aDtcblxuICAgICAgICB1cGRhdGVbcGFyZW50UGF0aCArICcuJyArIGNoaWxkUGF0aCArICcuJyArIHVwZGF0ZWRBdF0gPSBub3c7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKHBhdGguc2NoZW1hICE9IG51bGwgJiYgcGF0aC5zY2hlbWEgIT0gc2NoZW1hICYmIHVwZGF0ZVtrZXldKSB7XG4gICAgY29uc3QgdGltZXN0YW1wcyA9IHBhdGguc2NoZW1hLm9wdGlvbnMudGltZXN0YW1wcztcbiAgICBjb25zdCBjcmVhdGVkQXQgPSBoYW5kbGVUaW1lc3RhbXBPcHRpb24odGltZXN0YW1wcywgJ2NyZWF0ZWRBdCcpO1xuICAgIGNvbnN0IHVwZGF0ZWRBdCA9IGhhbmRsZVRpbWVzdGFtcE9wdGlvbih0aW1lc3RhbXBzLCAndXBkYXRlZEF0Jyk7XG5cbiAgICBpZiAoIXRpbWVzdGFtcHMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodXBkYXRlZEF0ICE9IG51bGwpIHtcbiAgICAgIHVwZGF0ZVtrZXldW3VwZGF0ZWRBdF0gPSBub3c7XG4gICAgfVxuICAgIGlmIChjcmVhdGVkQXQgIT0gbnVsbCkge1xuICAgICAgdXBkYXRlW2tleV1bY3JlYXRlZEF0XSA9IG5vdztcbiAgICB9XG4gIH1cbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../server/node_modules/mongoose/lib/helpers/update/applyTimestampsToChildren.js\n");

/***/ }),

/***/ "../server/node_modules/mongoose/lib/helpers/update/applyTimestampsToUpdate.js":
/*!*************************************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/helpers/update/applyTimestampsToUpdate.js ***!
  \*************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\n/*!\n * ignore\n */\n\nconst get = __webpack_require__(/*! ../get */ \"../server/node_modules/mongoose/lib/helpers/get.js\");\n\nmodule.exports = applyTimestampsToUpdate;\n\n/*!\n * ignore\n */\n\nfunction applyTimestampsToUpdate(now, createdAt, updatedAt, currentUpdate, options, isReplace) {\n  const updates = currentUpdate;\n  let _updates = updates;\n  const timestamps = get(options, 'timestamps', true);\n\n  // Support skipping timestamps at the query level, see gh-6980\n  if (!timestamps || updates == null) {\n    return currentUpdate;\n  }\n\n  const skipCreatedAt = timestamps != null && timestamps.createdAt === false;\n  const skipUpdatedAt = timestamps != null && timestamps.updatedAt === false;\n\n  if (isReplace) {\n    if (currentUpdate && currentUpdate.$set) {\n      currentUpdate = currentUpdate.$set;\n      updates.$set = {};\n      _updates = updates.$set;\n    }\n    if (!skipUpdatedAt && updatedAt && !currentUpdate[updatedAt]) {\n      _updates[updatedAt] = now;\n    }\n    if (!skipCreatedAt && createdAt && !currentUpdate[createdAt]) {\n      _updates[createdAt] = now;\n    }\n    return updates;\n  }\n  currentUpdate = currentUpdate || {};\n\n  if (Array.isArray(updates)) {\n    // Update with aggregation pipeline\n    if (updatedAt == null) {\n      return updates;\n    }\n    updates.push({ $set: { [updatedAt]: now } });\n    return updates;\n  }\n  updates.$set = updates.$set || {};\n  if (!skipUpdatedAt && updatedAt &&\n      (!currentUpdate.$currentDate || !currentUpdate.$currentDate[updatedAt])) {\n    let timestampSet = false;\n    if (updatedAt.indexOf('.') !== -1) {\n      const pieces = updatedAt.split('.');\n      for (let i = 1; i < pieces.length; ++i) {\n        const remnant = pieces.slice(-i).join('.');\n        const start = pieces.slice(0, -i).join('.');\n        if (currentUpdate[start] != null) {\n          currentUpdate[start][remnant] = now;\n          timestampSet = true;\n          break;\n        } else if (currentUpdate.$set && currentUpdate.$set[start]) {\n          currentUpdate.$set[start][remnant] = now;\n          timestampSet = true;\n          break;\n        }\n      }\n    }\n\n    if (!timestampSet) {\n      updates.$set[updatedAt] = now;\n    }\n\n    if (updates.hasOwnProperty(updatedAt)) {\n      delete updates[updatedAt];\n    }\n  }\n\n  if (!skipCreatedAt && createdAt) {\n    if (currentUpdate[createdAt]) {\n      delete currentUpdate[createdAt];\n    }\n    if (currentUpdate.$set && currentUpdate.$set[createdAt]) {\n      delete currentUpdate.$set[createdAt];\n    }\n    let timestampSet = false;\n    if (createdAt.indexOf('.') !== -1) {\n      const pieces = createdAt.split('.');\n      for (let i = 1; i < pieces.length; ++i) {\n        const remnant = pieces.slice(-i).join('.');\n        const start = pieces.slice(0, -i).join('.');\n        if (currentUpdate[start] != null) {\n          currentUpdate[start][remnant] = now;\n          timestampSet = true;\n          break;\n        } else if (currentUpdate.$set && currentUpdate.$set[start]) {\n          currentUpdate.$set[start][remnant] = now;\n          timestampSet = true;\n          break;\n        }\n      }\n    }\n\n    if (!timestampSet) {\n      updates.$setOnInsert = updates.$setOnInsert || {};\n      updates.$setOnInsert[createdAt] = now;\n    }\n  }\n\n  if (Object.keys(updates.$set).length === 0) {\n    delete updates.$set;\n  }\n  return updates;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy91cGRhdGUvYXBwbHlUaW1lc3RhbXBzVG9VcGRhdGUuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7QUFDQTtBQUNBOztBQUVBLFlBQVksbUJBQU8sQ0FBQyxrRUFBUTs7QUFFNUI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUSxvQkFBb0I7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixtQkFBbUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsbUJBQW1CO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2xpZW50Ly4uL3NlcnZlci9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvdXBkYXRlL2FwcGx5VGltZXN0YW1wc1RvVXBkYXRlLmpzPzM4MGEiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cbmNvbnN0IGdldCA9IHJlcXVpcmUoJy4uL2dldCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGFwcGx5VGltZXN0YW1wc1RvVXBkYXRlO1xuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cbmZ1bmN0aW9uIGFwcGx5VGltZXN0YW1wc1RvVXBkYXRlKG5vdywgY3JlYXRlZEF0LCB1cGRhdGVkQXQsIGN1cnJlbnRVcGRhdGUsIG9wdGlvbnMsIGlzUmVwbGFjZSkge1xuICBjb25zdCB1cGRhdGVzID0gY3VycmVudFVwZGF0ZTtcbiAgbGV0IF91cGRhdGVzID0gdXBkYXRlcztcbiAgY29uc3QgdGltZXN0YW1wcyA9IGdldChvcHRpb25zLCAndGltZXN0YW1wcycsIHRydWUpO1xuXG4gIC8vIFN1cHBvcnQgc2tpcHBpbmcgdGltZXN0YW1wcyBhdCB0aGUgcXVlcnkgbGV2ZWwsIHNlZSBnaC02OTgwXG4gIGlmICghdGltZXN0YW1wcyB8fCB1cGRhdGVzID09IG51bGwpIHtcbiAgICByZXR1cm4gY3VycmVudFVwZGF0ZTtcbiAgfVxuXG4gIGNvbnN0IHNraXBDcmVhdGVkQXQgPSB0aW1lc3RhbXBzICE9IG51bGwgJiYgdGltZXN0YW1wcy5jcmVhdGVkQXQgPT09IGZhbHNlO1xuICBjb25zdCBza2lwVXBkYXRlZEF0ID0gdGltZXN0YW1wcyAhPSBudWxsICYmIHRpbWVzdGFtcHMudXBkYXRlZEF0ID09PSBmYWxzZTtcblxuICBpZiAoaXNSZXBsYWNlKSB7XG4gICAgaWYgKGN1cnJlbnRVcGRhdGUgJiYgY3VycmVudFVwZGF0ZS4kc2V0KSB7XG4gICAgICBjdXJyZW50VXBkYXRlID0gY3VycmVudFVwZGF0ZS4kc2V0O1xuICAgICAgdXBkYXRlcy4kc2V0ID0ge307XG4gICAgICBfdXBkYXRlcyA9IHVwZGF0ZXMuJHNldDtcbiAgICB9XG4gICAgaWYgKCFza2lwVXBkYXRlZEF0ICYmIHVwZGF0ZWRBdCAmJiAhY3VycmVudFVwZGF0ZVt1cGRhdGVkQXRdKSB7XG4gICAgICBfdXBkYXRlc1t1cGRhdGVkQXRdID0gbm93O1xuICAgIH1cbiAgICBpZiAoIXNraXBDcmVhdGVkQXQgJiYgY3JlYXRlZEF0ICYmICFjdXJyZW50VXBkYXRlW2NyZWF0ZWRBdF0pIHtcbiAgICAgIF91cGRhdGVzW2NyZWF0ZWRBdF0gPSBub3c7XG4gICAgfVxuICAgIHJldHVybiB1cGRhdGVzO1xuICB9XG4gIGN1cnJlbnRVcGRhdGUgPSBjdXJyZW50VXBkYXRlIHx8IHt9O1xuXG4gIGlmIChBcnJheS5pc0FycmF5KHVwZGF0ZXMpKSB7XG4gICAgLy8gVXBkYXRlIHdpdGggYWdncmVnYXRpb24gcGlwZWxpbmVcbiAgICBpZiAodXBkYXRlZEF0ID09IG51bGwpIHtcbiAgICAgIHJldHVybiB1cGRhdGVzO1xuICAgIH1cbiAgICB1cGRhdGVzLnB1c2goeyAkc2V0OiB7IFt1cGRhdGVkQXRdOiBub3cgfSB9KTtcbiAgICByZXR1cm4gdXBkYXRlcztcbiAgfVxuICB1cGRhdGVzLiRzZXQgPSB1cGRhdGVzLiRzZXQgfHwge307XG4gIGlmICghc2tpcFVwZGF0ZWRBdCAmJiB1cGRhdGVkQXQgJiZcbiAgICAgICghY3VycmVudFVwZGF0ZS4kY3VycmVudERhdGUgfHwgIWN1cnJlbnRVcGRhdGUuJGN1cnJlbnREYXRlW3VwZGF0ZWRBdF0pKSB7XG4gICAgbGV0IHRpbWVzdGFtcFNldCA9IGZhbHNlO1xuICAgIGlmICh1cGRhdGVkQXQuaW5kZXhPZignLicpICE9PSAtMSkge1xuICAgICAgY29uc3QgcGllY2VzID0gdXBkYXRlZEF0LnNwbGl0KCcuJyk7XG4gICAgICBmb3IgKGxldCBpID0gMTsgaSA8IHBpZWNlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICBjb25zdCByZW1uYW50ID0gcGllY2VzLnNsaWNlKC1pKS5qb2luKCcuJyk7XG4gICAgICAgIGNvbnN0IHN0YXJ0ID0gcGllY2VzLnNsaWNlKDAsIC1pKS5qb2luKCcuJyk7XG4gICAgICAgIGlmIChjdXJyZW50VXBkYXRlW3N0YXJ0XSAhPSBudWxsKSB7XG4gICAgICAgICAgY3VycmVudFVwZGF0ZVtzdGFydF1bcmVtbmFudF0gPSBub3c7XG4gICAgICAgICAgdGltZXN0YW1wU2V0ID0gdHJ1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfSBlbHNlIGlmIChjdXJyZW50VXBkYXRlLiRzZXQgJiYgY3VycmVudFVwZGF0ZS4kc2V0W3N0YXJ0XSkge1xuICAgICAgICAgIGN1cnJlbnRVcGRhdGUuJHNldFtzdGFydF1bcmVtbmFudF0gPSBub3c7XG4gICAgICAgICAgdGltZXN0YW1wU2V0ID0gdHJ1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghdGltZXN0YW1wU2V0KSB7XG4gICAgICB1cGRhdGVzLiRzZXRbdXBkYXRlZEF0XSA9IG5vdztcbiAgICB9XG5cbiAgICBpZiAodXBkYXRlcy5oYXNPd25Qcm9wZXJ0eSh1cGRhdGVkQXQpKSB7XG4gICAgICBkZWxldGUgdXBkYXRlc1t1cGRhdGVkQXRdO1xuICAgIH1cbiAgfVxuXG4gIGlmICghc2tpcENyZWF0ZWRBdCAmJiBjcmVhdGVkQXQpIHtcbiAgICBpZiAoY3VycmVudFVwZGF0ZVtjcmVhdGVkQXRdKSB7XG4gICAgICBkZWxldGUgY3VycmVudFVwZGF0ZVtjcmVhdGVkQXRdO1xuICAgIH1cbiAgICBpZiAoY3VycmVudFVwZGF0ZS4kc2V0ICYmIGN1cnJlbnRVcGRhdGUuJHNldFtjcmVhdGVkQXRdKSB7XG4gICAgICBkZWxldGUgY3VycmVudFVwZGF0ZS4kc2V0W2NyZWF0ZWRBdF07XG4gICAgfVxuICAgIGxldCB0aW1lc3RhbXBTZXQgPSBmYWxzZTtcbiAgICBpZiAoY3JlYXRlZEF0LmluZGV4T2YoJy4nKSAhPT0gLTEpIHtcbiAgICAgIGNvbnN0IHBpZWNlcyA9IGNyZWF0ZWRBdC5zcGxpdCgnLicpO1xuICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCBwaWVjZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgY29uc3QgcmVtbmFudCA9IHBpZWNlcy5zbGljZSgtaSkuam9pbignLicpO1xuICAgICAgICBjb25zdCBzdGFydCA9IHBpZWNlcy5zbGljZSgwLCAtaSkuam9pbignLicpO1xuICAgICAgICBpZiAoY3VycmVudFVwZGF0ZVtzdGFydF0gIT0gbnVsbCkge1xuICAgICAgICAgIGN1cnJlbnRVcGRhdGVbc3RhcnRdW3JlbW5hbnRdID0gbm93O1xuICAgICAgICAgIHRpbWVzdGFtcFNldCA9IHRydWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH0gZWxzZSBpZiAoY3VycmVudFVwZGF0ZS4kc2V0ICYmIGN1cnJlbnRVcGRhdGUuJHNldFtzdGFydF0pIHtcbiAgICAgICAgICBjdXJyZW50VXBkYXRlLiRzZXRbc3RhcnRdW3JlbW5hbnRdID0gbm93O1xuICAgICAgICAgIHRpbWVzdGFtcFNldCA9IHRydWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIXRpbWVzdGFtcFNldCkge1xuICAgICAgdXBkYXRlcy4kc2V0T25JbnNlcnQgPSB1cGRhdGVzLiRzZXRPbkluc2VydCB8fCB7fTtcbiAgICAgIHVwZGF0ZXMuJHNldE9uSW5zZXJ0W2NyZWF0ZWRBdF0gPSBub3c7XG4gICAgfVxuICB9XG5cbiAgaWYgKE9iamVjdC5rZXlzKHVwZGF0ZXMuJHNldCkubGVuZ3RoID09PSAwKSB7XG4gICAgZGVsZXRlIHVwZGF0ZXMuJHNldDtcbiAgfVxuICByZXR1cm4gdXBkYXRlcztcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../server/node_modules/mongoose/lib/helpers/update/applyTimestampsToUpdate.js\n");

/***/ }),

/***/ "../server/node_modules/mongoose/lib/helpers/update/castArrayFilters.js":
/*!******************************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/helpers/update/castArrayFilters.js ***!
  \******************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst castFilterPath = __webpack_require__(/*! ../query/castFilterPath */ \"../server/node_modules/mongoose/lib/helpers/query/castFilterPath.js\");\nconst cleanPositionalOperators = __webpack_require__(/*! ../schema/cleanPositionalOperators */ \"../server/node_modules/mongoose/lib/helpers/schema/cleanPositionalOperators.js\");\nconst getPath = __webpack_require__(/*! ../schema/getPath */ \"../server/node_modules/mongoose/lib/helpers/schema/getPath.js\");\nconst updatedPathsByArrayFilter = __webpack_require__(/*! ./updatedPathsByArrayFilter */ \"../server/node_modules/mongoose/lib/helpers/update/updatedPathsByArrayFilter.js\");\n\nmodule.exports = function castArrayFilters(query) {\n  const arrayFilters = query.options.arrayFilters;\n  const update = query.getUpdate();\n  const schema = query.schema;\n  const updatedPathsByFilter = updatedPathsByArrayFilter(update);\n\n  let strictQuery = schema.options.strict;\n  if (query._mongooseOptions.strict != null) {\n    strictQuery = query._mongooseOptions.strict;\n  }\n  if (query.model && query.model.base.options.strictQuery != null) {\n    strictQuery = query.model.base.options.strictQuery;\n  }\n  if (schema._userProvidedOptions.strictQuery != null) {\n    strictQuery = schema._userProvidedOptions.strictQuery;\n  }\n  if (query._mongooseOptions.strictQuery != null) {\n    strictQuery = query._mongooseOptions.strictQuery;\n  }\n\n  _castArrayFilters(arrayFilters, schema, strictQuery, updatedPathsByFilter, query);\n};\n\nfunction _castArrayFilters(arrayFilters, schema, strictQuery, updatedPathsByFilter, query) {\n  if (!Array.isArray(arrayFilters)) {\n    return;\n  }\n\n  for (const filter of arrayFilters) {\n    if (filter == null) {\n      throw new Error(`Got null array filter in ${arrayFilters}`);\n    }\n    const keys = Object.keys(filter).filter(key => filter[key] != null);\n    if (keys.length === 0) {\n      continue;\n    }\n\n    const firstKey = keys[0];\n    if (firstKey === '$and' || firstKey === '$or') {\n      for (const key of keys) {\n        _castArrayFilters(filter[key], schema, strictQuery, updatedPathsByFilter, query);\n      }\n      continue;\n    }\n    const dot = firstKey.indexOf('.');\n    const filterWildcardPath = dot === -1 ? firstKey : firstKey.substring(0, dot);\n    if (updatedPathsByFilter[filterWildcardPath] == null) {\n      continue;\n    }\n    const baseFilterPath = cleanPositionalOperators(\n      updatedPathsByFilter[filterWildcardPath]\n    );\n\n    const baseSchematype = getPath(schema, baseFilterPath);\n    let filterBaseSchema = baseSchematype != null ? baseSchematype.schema : null;\n    if (filterBaseSchema != null &&\n        filterBaseSchema.discriminators != null &&\n        filter[filterWildcardPath + '.' + filterBaseSchema.options.discriminatorKey]) {\n      filterBaseSchema = filterBaseSchema.discriminators[filter[filterWildcardPath + '.' + filterBaseSchema.options.discriminatorKey]] || filterBaseSchema;\n    }\n\n    for (const key of keys) {\n      if (updatedPathsByFilter[key] === null) {\n        continue;\n      }\n      if (Object.keys(updatedPathsByFilter).length === 0) {\n        continue;\n      }\n      const dot = key.indexOf('.');\n\n      let filterPathRelativeToBase = dot === -1 ? null : key.substring(dot);\n      let schematype;\n      if (filterPathRelativeToBase == null || filterBaseSchema == null) {\n        schematype = baseSchematype;\n      } else {\n        // If there are multiple array filters in the path being updated, make sure\n        // to replace them so we can get the schema path.\n        filterPathRelativeToBase = cleanPositionalOperators(filterPathRelativeToBase);\n        schematype = getPath(filterBaseSchema, filterPathRelativeToBase);\n      }\n\n      if (schematype == null) {\n        if (!strictQuery) {\n          return;\n        }\n        const filterPath = filterPathRelativeToBase == null ?\n          baseFilterPath + '.0' :\n          baseFilterPath + '.0' + filterPathRelativeToBase;\n        // For now, treat `strictQuery = true` and `strictQuery = 'throw'` as\n        // equivalent for casting array filters. `strictQuery = true` doesn't\n        // quite work in this context because we never want to silently strip out\n        // array filters, even if the path isn't in the schema.\n        throw new Error(`Could not find path \"${filterPath}\" in schema`);\n      }\n      if (typeof filter[key] === 'object') {\n        filter[key] = castFilterPath(query, schematype, filter[key]);\n      } else {\n        filter[key] = schematype.castForQuery(null, filter[key]);\n      }\n    }\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy91cGRhdGUvY2FzdEFycmF5RmlsdGVycy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYix1QkFBdUIsbUJBQU8sQ0FBQyxvR0FBeUI7QUFDeEQsaUNBQWlDLG1CQUFPLENBQUMsMEhBQW9DO0FBQzdFLGdCQUFnQixtQkFBTyxDQUFDLHdGQUFtQjtBQUMzQyxrQ0FBa0MsbUJBQU8sQ0FBQyxvSEFBNkI7O0FBRXZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0RBQWtELGFBQWE7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsV0FBVztBQUMzRDtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2NsaWVudC8uLi9zZXJ2ZXIvbm9kZV9tb2R1bGVzL21vbmdvb3NlL2xpYi9oZWxwZXJzL3VwZGF0ZS9jYXN0QXJyYXlGaWx0ZXJzLmpzP2RhZTIiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBjYXN0RmlsdGVyUGF0aCA9IHJlcXVpcmUoJy4uL3F1ZXJ5L2Nhc3RGaWx0ZXJQYXRoJyk7XG5jb25zdCBjbGVhblBvc2l0aW9uYWxPcGVyYXRvcnMgPSByZXF1aXJlKCcuLi9zY2hlbWEvY2xlYW5Qb3NpdGlvbmFsT3BlcmF0b3JzJyk7XG5jb25zdCBnZXRQYXRoID0gcmVxdWlyZSgnLi4vc2NoZW1hL2dldFBhdGgnKTtcbmNvbnN0IHVwZGF0ZWRQYXRoc0J5QXJyYXlGaWx0ZXIgPSByZXF1aXJlKCcuL3VwZGF0ZWRQYXRoc0J5QXJyYXlGaWx0ZXInKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBjYXN0QXJyYXlGaWx0ZXJzKHF1ZXJ5KSB7XG4gIGNvbnN0IGFycmF5RmlsdGVycyA9IHF1ZXJ5Lm9wdGlvbnMuYXJyYXlGaWx0ZXJzO1xuICBjb25zdCB1cGRhdGUgPSBxdWVyeS5nZXRVcGRhdGUoKTtcbiAgY29uc3Qgc2NoZW1hID0gcXVlcnkuc2NoZW1hO1xuICBjb25zdCB1cGRhdGVkUGF0aHNCeUZpbHRlciA9IHVwZGF0ZWRQYXRoc0J5QXJyYXlGaWx0ZXIodXBkYXRlKTtcblxuICBsZXQgc3RyaWN0UXVlcnkgPSBzY2hlbWEub3B0aW9ucy5zdHJpY3Q7XG4gIGlmIChxdWVyeS5fbW9uZ29vc2VPcHRpb25zLnN0cmljdCAhPSBudWxsKSB7XG4gICAgc3RyaWN0UXVlcnkgPSBxdWVyeS5fbW9uZ29vc2VPcHRpb25zLnN0cmljdDtcbiAgfVxuICBpZiAocXVlcnkubW9kZWwgJiYgcXVlcnkubW9kZWwuYmFzZS5vcHRpb25zLnN0cmljdFF1ZXJ5ICE9IG51bGwpIHtcbiAgICBzdHJpY3RRdWVyeSA9IHF1ZXJ5Lm1vZGVsLmJhc2Uub3B0aW9ucy5zdHJpY3RRdWVyeTtcbiAgfVxuICBpZiAoc2NoZW1hLl91c2VyUHJvdmlkZWRPcHRpb25zLnN0cmljdFF1ZXJ5ICE9IG51bGwpIHtcbiAgICBzdHJpY3RRdWVyeSA9IHNjaGVtYS5fdXNlclByb3ZpZGVkT3B0aW9ucy5zdHJpY3RRdWVyeTtcbiAgfVxuICBpZiAocXVlcnkuX21vbmdvb3NlT3B0aW9ucy5zdHJpY3RRdWVyeSAhPSBudWxsKSB7XG4gICAgc3RyaWN0UXVlcnkgPSBxdWVyeS5fbW9uZ29vc2VPcHRpb25zLnN0cmljdFF1ZXJ5O1xuICB9XG5cbiAgX2Nhc3RBcnJheUZpbHRlcnMoYXJyYXlGaWx0ZXJzLCBzY2hlbWEsIHN0cmljdFF1ZXJ5LCB1cGRhdGVkUGF0aHNCeUZpbHRlciwgcXVlcnkpO1xufTtcblxuZnVuY3Rpb24gX2Nhc3RBcnJheUZpbHRlcnMoYXJyYXlGaWx0ZXJzLCBzY2hlbWEsIHN0cmljdFF1ZXJ5LCB1cGRhdGVkUGF0aHNCeUZpbHRlciwgcXVlcnkpIHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KGFycmF5RmlsdGVycykpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBmb3IgKGNvbnN0IGZpbHRlciBvZiBhcnJheUZpbHRlcnMpIHtcbiAgICBpZiAoZmlsdGVyID09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgR290IG51bGwgYXJyYXkgZmlsdGVyIGluICR7YXJyYXlGaWx0ZXJzfWApO1xuICAgIH1cbiAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoZmlsdGVyKS5maWx0ZXIoa2V5ID0+IGZpbHRlcltrZXldICE9IG51bGwpO1xuICAgIGlmIChrZXlzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgY29uc3QgZmlyc3RLZXkgPSBrZXlzWzBdO1xuICAgIGlmIChmaXJzdEtleSA9PT0gJyRhbmQnIHx8IGZpcnN0S2V5ID09PSAnJG9yJykge1xuICAgICAgZm9yIChjb25zdCBrZXkgb2Yga2V5cykge1xuICAgICAgICBfY2FzdEFycmF5RmlsdGVycyhmaWx0ZXJba2V5XSwgc2NoZW1hLCBzdHJpY3RRdWVyeSwgdXBkYXRlZFBhdGhzQnlGaWx0ZXIsIHF1ZXJ5KTtcbiAgICAgIH1cbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBjb25zdCBkb3QgPSBmaXJzdEtleS5pbmRleE9mKCcuJyk7XG4gICAgY29uc3QgZmlsdGVyV2lsZGNhcmRQYXRoID0gZG90ID09PSAtMSA/IGZpcnN0S2V5IDogZmlyc3RLZXkuc3Vic3RyaW5nKDAsIGRvdCk7XG4gICAgaWYgKHVwZGF0ZWRQYXRoc0J5RmlsdGVyW2ZpbHRlcldpbGRjYXJkUGF0aF0gPT0gbnVsbCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGNvbnN0IGJhc2VGaWx0ZXJQYXRoID0gY2xlYW5Qb3NpdGlvbmFsT3BlcmF0b3JzKFxuICAgICAgdXBkYXRlZFBhdGhzQnlGaWx0ZXJbZmlsdGVyV2lsZGNhcmRQYXRoXVxuICAgICk7XG5cbiAgICBjb25zdCBiYXNlU2NoZW1hdHlwZSA9IGdldFBhdGgoc2NoZW1hLCBiYXNlRmlsdGVyUGF0aCk7XG4gICAgbGV0IGZpbHRlckJhc2VTY2hlbWEgPSBiYXNlU2NoZW1hdHlwZSAhPSBudWxsID8gYmFzZVNjaGVtYXR5cGUuc2NoZW1hIDogbnVsbDtcbiAgICBpZiAoZmlsdGVyQmFzZVNjaGVtYSAhPSBudWxsICYmXG4gICAgICAgIGZpbHRlckJhc2VTY2hlbWEuZGlzY3JpbWluYXRvcnMgIT0gbnVsbCAmJlxuICAgICAgICBmaWx0ZXJbZmlsdGVyV2lsZGNhcmRQYXRoICsgJy4nICsgZmlsdGVyQmFzZVNjaGVtYS5vcHRpb25zLmRpc2NyaW1pbmF0b3JLZXldKSB7XG4gICAgICBmaWx0ZXJCYXNlU2NoZW1hID0gZmlsdGVyQmFzZVNjaGVtYS5kaXNjcmltaW5hdG9yc1tmaWx0ZXJbZmlsdGVyV2lsZGNhcmRQYXRoICsgJy4nICsgZmlsdGVyQmFzZVNjaGVtYS5vcHRpb25zLmRpc2NyaW1pbmF0b3JLZXldXSB8fCBmaWx0ZXJCYXNlU2NoZW1hO1xuICAgIH1cblxuICAgIGZvciAoY29uc3Qga2V5IG9mIGtleXMpIHtcbiAgICAgIGlmICh1cGRhdGVkUGF0aHNCeUZpbHRlcltrZXldID09PSBudWxsKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKE9iamVjdC5rZXlzKHVwZGF0ZWRQYXRoc0J5RmlsdGVyKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb25zdCBkb3QgPSBrZXkuaW5kZXhPZignLicpO1xuXG4gICAgICBsZXQgZmlsdGVyUGF0aFJlbGF0aXZlVG9CYXNlID0gZG90ID09PSAtMSA/IG51bGwgOiBrZXkuc3Vic3RyaW5nKGRvdCk7XG4gICAgICBsZXQgc2NoZW1hdHlwZTtcbiAgICAgIGlmIChmaWx0ZXJQYXRoUmVsYXRpdmVUb0Jhc2UgPT0gbnVsbCB8fCBmaWx0ZXJCYXNlU2NoZW1hID09IG51bGwpIHtcbiAgICAgICAgc2NoZW1hdHlwZSA9IGJhc2VTY2hlbWF0eXBlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gSWYgdGhlcmUgYXJlIG11bHRpcGxlIGFycmF5IGZpbHRlcnMgaW4gdGhlIHBhdGggYmVpbmcgdXBkYXRlZCwgbWFrZSBzdXJlXG4gICAgICAgIC8vIHRvIHJlcGxhY2UgdGhlbSBzbyB3ZSBjYW4gZ2V0IHRoZSBzY2hlbWEgcGF0aC5cbiAgICAgICAgZmlsdGVyUGF0aFJlbGF0aXZlVG9CYXNlID0gY2xlYW5Qb3NpdGlvbmFsT3BlcmF0b3JzKGZpbHRlclBhdGhSZWxhdGl2ZVRvQmFzZSk7XG4gICAgICAgIHNjaGVtYXR5cGUgPSBnZXRQYXRoKGZpbHRlckJhc2VTY2hlbWEsIGZpbHRlclBhdGhSZWxhdGl2ZVRvQmFzZSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChzY2hlbWF0eXBlID09IG51bGwpIHtcbiAgICAgICAgaWYgKCFzdHJpY3RRdWVyeSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBmaWx0ZXJQYXRoID0gZmlsdGVyUGF0aFJlbGF0aXZlVG9CYXNlID09IG51bGwgP1xuICAgICAgICAgIGJhc2VGaWx0ZXJQYXRoICsgJy4wJyA6XG4gICAgICAgICAgYmFzZUZpbHRlclBhdGggKyAnLjAnICsgZmlsdGVyUGF0aFJlbGF0aXZlVG9CYXNlO1xuICAgICAgICAvLyBGb3Igbm93LCB0cmVhdCBgc3RyaWN0UXVlcnkgPSB0cnVlYCBhbmQgYHN0cmljdFF1ZXJ5ID0gJ3Rocm93J2AgYXNcbiAgICAgICAgLy8gZXF1aXZhbGVudCBmb3IgY2FzdGluZyBhcnJheSBmaWx0ZXJzLiBgc3RyaWN0UXVlcnkgPSB0cnVlYCBkb2Vzbid0XG4gICAgICAgIC8vIHF1aXRlIHdvcmsgaW4gdGhpcyBjb250ZXh0IGJlY2F1c2Ugd2UgbmV2ZXIgd2FudCB0byBzaWxlbnRseSBzdHJpcCBvdXRcbiAgICAgICAgLy8gYXJyYXkgZmlsdGVycywgZXZlbiBpZiB0aGUgcGF0aCBpc24ndCBpbiB0aGUgc2NoZW1hLlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENvdWxkIG5vdCBmaW5kIHBhdGggXCIke2ZpbHRlclBhdGh9XCIgaW4gc2NoZW1hYCk7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIGZpbHRlcltrZXldID09PSAnb2JqZWN0Jykge1xuICAgICAgICBmaWx0ZXJba2V5XSA9IGNhc3RGaWx0ZXJQYXRoKHF1ZXJ5LCBzY2hlbWF0eXBlLCBmaWx0ZXJba2V5XSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmaWx0ZXJba2V5XSA9IHNjaGVtYXR5cGUuY2FzdEZvclF1ZXJ5KG51bGwsIGZpbHRlcltrZXldKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../server/node_modules/mongoose/lib/helpers/update/castArrayFilters.js\n");

/***/ }),

/***/ "../server/node_modules/mongoose/lib/helpers/update/decorateUpdateWithVersionKey.js":
/*!******************************************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/helpers/update/decorateUpdateWithVersionKey.js ***!
  \******************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst modifiedPaths = __webpack_require__(/*! ./modifiedPaths */ \"../server/node_modules/mongoose/lib/helpers/update/modifiedPaths.js\");\n\n/**\n * Decorate the update with a version key, if necessary\n * @api private\n */\n\nmodule.exports = function decorateUpdateWithVersionKey(update, options, versionKey) {\n  if (!versionKey || !(options && options.upsert || false)) {\n    return;\n  }\n\n  const updatedPaths = modifiedPaths(update);\n  if (!updatedPaths[versionKey]) {\n    if (options.overwrite) {\n      update[versionKey] = 0;\n    } else {\n      if (!update.$setOnInsert) {\n        update.$setOnInsert = {};\n      }\n      update.$setOnInsert[versionKey] = 0;\n    }\n  }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy91cGRhdGUvZGVjb3JhdGVVcGRhdGVXaXRoVmVyc2lvbktleS5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixzQkFBc0IsbUJBQU8sQ0FBQyw0RkFBaUI7O0FBRS9DO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2xpZW50Ly4uL3NlcnZlci9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvdXBkYXRlL2RlY29yYXRlVXBkYXRlV2l0aFZlcnNpb25LZXkuanM/N2UyZiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IG1vZGlmaWVkUGF0aHMgPSByZXF1aXJlKCcuL21vZGlmaWVkUGF0aHMnKTtcblxuLyoqXG4gKiBEZWNvcmF0ZSB0aGUgdXBkYXRlIHdpdGggYSB2ZXJzaW9uIGtleSwgaWYgbmVjZXNzYXJ5XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGRlY29yYXRlVXBkYXRlV2l0aFZlcnNpb25LZXkodXBkYXRlLCBvcHRpb25zLCB2ZXJzaW9uS2V5KSB7XG4gIGlmICghdmVyc2lvbktleSB8fCAhKG9wdGlvbnMgJiYgb3B0aW9ucy51cHNlcnQgfHwgZmFsc2UpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29uc3QgdXBkYXRlZFBhdGhzID0gbW9kaWZpZWRQYXRocyh1cGRhdGUpO1xuICBpZiAoIXVwZGF0ZWRQYXRoc1t2ZXJzaW9uS2V5XSkge1xuICAgIGlmIChvcHRpb25zLm92ZXJ3cml0ZSkge1xuICAgICAgdXBkYXRlW3ZlcnNpb25LZXldID0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKCF1cGRhdGUuJHNldE9uSW5zZXJ0KSB7XG4gICAgICAgIHVwZGF0ZS4kc2V0T25JbnNlcnQgPSB7fTtcbiAgICAgIH1cbiAgICAgIHVwZGF0ZS4kc2V0T25JbnNlcnRbdmVyc2lvbktleV0gPSAwO1xuICAgIH1cbiAgfVxufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../server/node_modules/mongoose/lib/helpers/update/decorateUpdateWithVersionKey.js\n");

/***/ }),

/***/ "../server/node_modules/mongoose/lib/helpers/update/modifiedPaths.js":
/*!***************************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/helpers/update/modifiedPaths.js ***!
  \***************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst _modifiedPaths = (__webpack_require__(/*! ../common */ \"../server/node_modules/mongoose/lib/helpers/common.js\").modifiedPaths);\n\n/**\n * Given an update document with potential update operators (`$set`, etc.)\n * returns an object whose keys are the directly modified paths.\n *\n * If there are any top-level keys that don't start with `$`, we assume those\n * will get wrapped in a `$set`. The Mongoose Query is responsible for wrapping\n * top-level keys in `$set`.\n *\n * @param {Object} update\n * @return {Object} modified\n */\n\nmodule.exports = function modifiedPaths(update) {\n  const keys = Object.keys(update);\n  const res = {};\n\n  const withoutDollarKeys = {};\n  for (const key of keys) {\n    if (key.startsWith('$')) {\n      _modifiedPaths(update[key], '', res);\n      continue;\n    }\n    withoutDollarKeys[key] = update[key];\n  }\n\n  _modifiedPaths(withoutDollarKeys, '', res);\n\n  return res;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy91cGRhdGUvbW9kaWZpZWRQYXRocy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYix1QkFBdUIsNkdBQWtDOztBQUV6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFlBQVksUUFBUTtBQUNwQjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2xpZW50Ly4uL3NlcnZlci9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvdXBkYXRlL21vZGlmaWVkUGF0aHMuanM/YzgxNiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IF9tb2RpZmllZFBhdGhzID0gcmVxdWlyZSgnLi4vY29tbW9uJykubW9kaWZpZWRQYXRocztcblxuLyoqXG4gKiBHaXZlbiBhbiB1cGRhdGUgZG9jdW1lbnQgd2l0aCBwb3RlbnRpYWwgdXBkYXRlIG9wZXJhdG9ycyAoYCRzZXRgLCBldGMuKVxuICogcmV0dXJucyBhbiBvYmplY3Qgd2hvc2Uga2V5cyBhcmUgdGhlIGRpcmVjdGx5IG1vZGlmaWVkIHBhdGhzLlxuICpcbiAqIElmIHRoZXJlIGFyZSBhbnkgdG9wLWxldmVsIGtleXMgdGhhdCBkb24ndCBzdGFydCB3aXRoIGAkYCwgd2UgYXNzdW1lIHRob3NlXG4gKiB3aWxsIGdldCB3cmFwcGVkIGluIGEgYCRzZXRgLiBUaGUgTW9uZ29vc2UgUXVlcnkgaXMgcmVzcG9uc2libGUgZm9yIHdyYXBwaW5nXG4gKiB0b3AtbGV2ZWwga2V5cyBpbiBgJHNldGAuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHVwZGF0ZVxuICogQHJldHVybiB7T2JqZWN0fSBtb2RpZmllZFxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gbW9kaWZpZWRQYXRocyh1cGRhdGUpIHtcbiAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHVwZGF0ZSk7XG4gIGNvbnN0IHJlcyA9IHt9O1xuXG4gIGNvbnN0IHdpdGhvdXREb2xsYXJLZXlzID0ge307XG4gIGZvciAoY29uc3Qga2V5IG9mIGtleXMpIHtcbiAgICBpZiAoa2V5LnN0YXJ0c1dpdGgoJyQnKSkge1xuICAgICAgX21vZGlmaWVkUGF0aHModXBkYXRlW2tleV0sICcnLCByZXMpO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHdpdGhvdXREb2xsYXJLZXlzW2tleV0gPSB1cGRhdGVba2V5XTtcbiAgfVxuXG4gIF9tb2RpZmllZFBhdGhzKHdpdGhvdXREb2xsYXJLZXlzLCAnJywgcmVzKTtcblxuICByZXR1cm4gcmVzO1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../server/node_modules/mongoose/lib/helpers/update/modifiedPaths.js\n");

/***/ }),

/***/ "../server/node_modules/mongoose/lib/helpers/update/moveImmutableProperties.js":
/*!*************************************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/helpers/update/moveImmutableProperties.js ***!
  \*************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst get = __webpack_require__(/*! ../get */ \"../server/node_modules/mongoose/lib/helpers/get.js\");\n\n/**\n * Given an update, move all $set on immutable properties to $setOnInsert.\n * This should only be called for upserts, because $setOnInsert bypasses the\n * strictness check for immutable properties.\n */\n\nmodule.exports = function moveImmutableProperties(schema, update, ctx) {\n  if (update == null) {\n    return;\n  }\n\n  const keys = Object.keys(update);\n  for (const key of keys) {\n    const isDollarKey = key.startsWith('$');\n\n    if (key === '$set') {\n      const updatedPaths = Object.keys(update[key]);\n      for (const path of updatedPaths) {\n        _walkUpdatePath(schema, update[key], path, update, ctx);\n      }\n    } else if (!isDollarKey) {\n      _walkUpdatePath(schema, update, key, update, ctx);\n    }\n\n  }\n};\n\nfunction _walkUpdatePath(schema, op, path, update, ctx) {\n  const schematype = schema.path(path);\n  if (schematype == null) {\n    return;\n  }\n\n  let immutable = get(schematype, 'options.immutable', null);\n  if (immutable == null) {\n    return;\n  }\n  if (typeof immutable === 'function') {\n    immutable = immutable.call(ctx, ctx);\n  }\n\n  if (!immutable) {\n    return;\n  }\n\n  update.$setOnInsert = update.$setOnInsert || {};\n  update.$setOnInsert[path] = op[path];\n  delete op[path];\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy91cGRhdGUvbW92ZUltbXV0YWJsZVByb3BlcnRpZXMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsWUFBWSxtQkFBTyxDQUFDLGtFQUFROztBQUU1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2NsaWVudC8uLi9zZXJ2ZXIvbm9kZV9tb2R1bGVzL21vbmdvb3NlL2xpYi9oZWxwZXJzL3VwZGF0ZS9tb3ZlSW1tdXRhYmxlUHJvcGVydGllcy5qcz8zZTI5Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3QgZ2V0ID0gcmVxdWlyZSgnLi4vZ2V0Jyk7XG5cbi8qKlxuICogR2l2ZW4gYW4gdXBkYXRlLCBtb3ZlIGFsbCAkc2V0IG9uIGltbXV0YWJsZSBwcm9wZXJ0aWVzIHRvICRzZXRPbkluc2VydC5cbiAqIFRoaXMgc2hvdWxkIG9ubHkgYmUgY2FsbGVkIGZvciB1cHNlcnRzLCBiZWNhdXNlICRzZXRPbkluc2VydCBieXBhc3NlcyB0aGVcbiAqIHN0cmljdG5lc3MgY2hlY2sgZm9yIGltbXV0YWJsZSBwcm9wZXJ0aWVzLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gbW92ZUltbXV0YWJsZVByb3BlcnRpZXMoc2NoZW1hLCB1cGRhdGUsIGN0eCkge1xuICBpZiAodXBkYXRlID09IG51bGwpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXModXBkYXRlKTtcbiAgZm9yIChjb25zdCBrZXkgb2Yga2V5cykge1xuICAgIGNvbnN0IGlzRG9sbGFyS2V5ID0ga2V5LnN0YXJ0c1dpdGgoJyQnKTtcblxuICAgIGlmIChrZXkgPT09ICckc2V0Jykge1xuICAgICAgY29uc3QgdXBkYXRlZFBhdGhzID0gT2JqZWN0LmtleXModXBkYXRlW2tleV0pO1xuICAgICAgZm9yIChjb25zdCBwYXRoIG9mIHVwZGF0ZWRQYXRocykge1xuICAgICAgICBfd2Fsa1VwZGF0ZVBhdGgoc2NoZW1hLCB1cGRhdGVba2V5XSwgcGF0aCwgdXBkYXRlLCBjdHgpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIWlzRG9sbGFyS2V5KSB7XG4gICAgICBfd2Fsa1VwZGF0ZVBhdGgoc2NoZW1hLCB1cGRhdGUsIGtleSwgdXBkYXRlLCBjdHgpO1xuICAgIH1cblxuICB9XG59O1xuXG5mdW5jdGlvbiBfd2Fsa1VwZGF0ZVBhdGgoc2NoZW1hLCBvcCwgcGF0aCwgdXBkYXRlLCBjdHgpIHtcbiAgY29uc3Qgc2NoZW1hdHlwZSA9IHNjaGVtYS5wYXRoKHBhdGgpO1xuICBpZiAoc2NoZW1hdHlwZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgbGV0IGltbXV0YWJsZSA9IGdldChzY2hlbWF0eXBlLCAnb3B0aW9ucy5pbW11dGFibGUnLCBudWxsKTtcbiAgaWYgKGltbXV0YWJsZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmICh0eXBlb2YgaW1tdXRhYmxlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgaW1tdXRhYmxlID0gaW1tdXRhYmxlLmNhbGwoY3R4LCBjdHgpO1xuICB9XG5cbiAgaWYgKCFpbW11dGFibGUpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB1cGRhdGUuJHNldE9uSW5zZXJ0ID0gdXBkYXRlLiRzZXRPbkluc2VydCB8fCB7fTtcbiAgdXBkYXRlLiRzZXRPbkluc2VydFtwYXRoXSA9IG9wW3BhdGhdO1xuICBkZWxldGUgb3BbcGF0aF07XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../server/node_modules/mongoose/lib/helpers/update/moveImmutableProperties.js\n");

/***/ }),

/***/ "../server/node_modules/mongoose/lib/helpers/update/removeUnusedArrayFilters.js":
/*!**************************************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/helpers/update/removeUnusedArrayFilters.js ***!
  \**************************************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/**\n * MongoDB throws an error if there's unused array filters. That is, if `options.arrayFilters` defines\n * a filter, but none of the `update` keys use it. This should be enough to filter out all unused array\n * filters.\n */\n\nmodule.exports = function removeUnusedArrayFilters(update, arrayFilters) {\n  const updateKeys = Object.keys(update).\n    map(key => Object.keys(update[key])).\n    reduce((cur, arr) => cur.concat(arr), []);\n  return arrayFilters.filter(obj => {\n    return _checkSingleFilterKey(obj, updateKeys);\n  });\n};\n\nfunction _checkSingleFilterKey(arrayFilter, updateKeys) {\n  const firstKey = Object.keys(arrayFilter)[0];\n\n  if (firstKey === '$and' || firstKey === '$or') {\n    if (!Array.isArray(arrayFilter[firstKey])) {\n      return false;\n    }\n    return arrayFilter[firstKey].find(filter => _checkSingleFilterKey(filter, updateKeys)) != null;\n  }\n\n  const firstDot = firstKey.indexOf('.');\n  const arrayFilterKey = firstDot === -1 ? firstKey : firstKey.slice(0, firstDot);\n\n  return updateKeys.find(key => key.includes('$[' + arrayFilterKey + ']')) != null;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy91cGRhdGUvcmVtb3ZlVW51c2VkQXJyYXlGaWx0ZXJzLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2NsaWVudC8uLi9zZXJ2ZXIvbm9kZV9tb2R1bGVzL21vbmdvb3NlL2xpYi9oZWxwZXJzL3VwZGF0ZS9yZW1vdmVVbnVzZWRBcnJheUZpbHRlcnMuanM/YzA4MyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogTW9uZ29EQiB0aHJvd3MgYW4gZXJyb3IgaWYgdGhlcmUncyB1bnVzZWQgYXJyYXkgZmlsdGVycy4gVGhhdCBpcywgaWYgYG9wdGlvbnMuYXJyYXlGaWx0ZXJzYCBkZWZpbmVzXG4gKiBhIGZpbHRlciwgYnV0IG5vbmUgb2YgdGhlIGB1cGRhdGVgIGtleXMgdXNlIGl0LiBUaGlzIHNob3VsZCBiZSBlbm91Z2ggdG8gZmlsdGVyIG91dCBhbGwgdW51c2VkIGFycmF5XG4gKiBmaWx0ZXJzLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gcmVtb3ZlVW51c2VkQXJyYXlGaWx0ZXJzKHVwZGF0ZSwgYXJyYXlGaWx0ZXJzKSB7XG4gIGNvbnN0IHVwZGF0ZUtleXMgPSBPYmplY3Qua2V5cyh1cGRhdGUpLlxuICAgIG1hcChrZXkgPT4gT2JqZWN0LmtleXModXBkYXRlW2tleV0pKS5cbiAgICByZWR1Y2UoKGN1ciwgYXJyKSA9PiBjdXIuY29uY2F0KGFyciksIFtdKTtcbiAgcmV0dXJuIGFycmF5RmlsdGVycy5maWx0ZXIob2JqID0+IHtcbiAgICByZXR1cm4gX2NoZWNrU2luZ2xlRmlsdGVyS2V5KG9iaiwgdXBkYXRlS2V5cyk7XG4gIH0pO1xufTtcblxuZnVuY3Rpb24gX2NoZWNrU2luZ2xlRmlsdGVyS2V5KGFycmF5RmlsdGVyLCB1cGRhdGVLZXlzKSB7XG4gIGNvbnN0IGZpcnN0S2V5ID0gT2JqZWN0LmtleXMoYXJyYXlGaWx0ZXIpWzBdO1xuXG4gIGlmIChmaXJzdEtleSA9PT0gJyRhbmQnIHx8IGZpcnN0S2V5ID09PSAnJG9yJykge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShhcnJheUZpbHRlcltmaXJzdEtleV0pKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBhcnJheUZpbHRlcltmaXJzdEtleV0uZmluZChmaWx0ZXIgPT4gX2NoZWNrU2luZ2xlRmlsdGVyS2V5KGZpbHRlciwgdXBkYXRlS2V5cykpICE9IG51bGw7XG4gIH1cblxuICBjb25zdCBmaXJzdERvdCA9IGZpcnN0S2V5LmluZGV4T2YoJy4nKTtcbiAgY29uc3QgYXJyYXlGaWx0ZXJLZXkgPSBmaXJzdERvdCA9PT0gLTEgPyBmaXJzdEtleSA6IGZpcnN0S2V5LnNsaWNlKDAsIGZpcnN0RG90KTtcblxuICByZXR1cm4gdXBkYXRlS2V5cy5maW5kKGtleSA9PiBrZXkuaW5jbHVkZXMoJyRbJyArIGFycmF5RmlsdGVyS2V5ICsgJ10nKSkgIT0gbnVsbDtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../server/node_modules/mongoose/lib/helpers/update/removeUnusedArrayFilters.js\n");

/***/ }),

/***/ "../server/node_modules/mongoose/lib/helpers/update/updatedPathsByArrayFilter.js":
/*!***************************************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/helpers/update/updatedPathsByArrayFilter.js ***!
  \***************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst modifiedPaths = __webpack_require__(/*! ./modifiedPaths */ \"../server/node_modules/mongoose/lib/helpers/update/modifiedPaths.js\");\n\nmodule.exports = function updatedPathsByArrayFilter(update) {\n  if (update == null) {\n    return {};\n  }\n  const updatedPaths = modifiedPaths(update);\n\n  return Object.keys(updatedPaths).reduce((cur, path) => {\n    const matches = path.match(/\\$\\[[^\\]]+\\]/g);\n    if (matches == null) {\n      return cur;\n    }\n    for (const match of matches) {\n      const firstMatch = path.indexOf(match);\n      if (firstMatch !== path.lastIndexOf(match)) {\n        throw new Error(`Path '${path}' contains the same array filter multiple times`);\n      }\n      cur[match.substring(2, match.length - 1)] = path.\n        substring(0, firstMatch - 1).\n        replace(/\\$\\[[^\\]]+\\]/g, '0');\n    }\n    return cur;\n  }, {});\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy91cGRhdGUvdXBkYXRlZFBhdGhzQnlBcnJheUZpbHRlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixzQkFBc0IsbUJBQU8sQ0FBQyw0RkFBaUI7O0FBRS9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxLQUFLO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsSUFBSTtBQUNQIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2xpZW50Ly4uL3NlcnZlci9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvdXBkYXRlL3VwZGF0ZWRQYXRoc0J5QXJyYXlGaWx0ZXIuanM/YmI4MyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IG1vZGlmaWVkUGF0aHMgPSByZXF1aXJlKCcuL21vZGlmaWVkUGF0aHMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiB1cGRhdGVkUGF0aHNCeUFycmF5RmlsdGVyKHVwZGF0ZSkge1xuICBpZiAodXBkYXRlID09IG51bGwpIHtcbiAgICByZXR1cm4ge307XG4gIH1cbiAgY29uc3QgdXBkYXRlZFBhdGhzID0gbW9kaWZpZWRQYXRocyh1cGRhdGUpO1xuXG4gIHJldHVybiBPYmplY3Qua2V5cyh1cGRhdGVkUGF0aHMpLnJlZHVjZSgoY3VyLCBwYXRoKSA9PiB7XG4gICAgY29uc3QgbWF0Y2hlcyA9IHBhdGgubWF0Y2goL1xcJFxcW1teXFxdXStcXF0vZyk7XG4gICAgaWYgKG1hdGNoZXMgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGN1cjtcbiAgICB9XG4gICAgZm9yIChjb25zdCBtYXRjaCBvZiBtYXRjaGVzKSB7XG4gICAgICBjb25zdCBmaXJzdE1hdGNoID0gcGF0aC5pbmRleE9mKG1hdGNoKTtcbiAgICAgIGlmIChmaXJzdE1hdGNoICE9PSBwYXRoLmxhc3RJbmRleE9mKG1hdGNoKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFBhdGggJyR7cGF0aH0nIGNvbnRhaW5zIHRoZSBzYW1lIGFycmF5IGZpbHRlciBtdWx0aXBsZSB0aW1lc2ApO1xuICAgICAgfVxuICAgICAgY3VyW21hdGNoLnN1YnN0cmluZygyLCBtYXRjaC5sZW5ndGggLSAxKV0gPSBwYXRoLlxuICAgICAgICBzdWJzdHJpbmcoMCwgZmlyc3RNYXRjaCAtIDEpLlxuICAgICAgICByZXBsYWNlKC9cXCRcXFtbXlxcXV0rXFxdL2csICcwJyk7XG4gICAgfVxuICAgIHJldHVybiBjdXI7XG4gIH0sIHt9KTtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../server/node_modules/mongoose/lib/helpers/update/updatedPathsByArrayFilter.js\n");

/***/ }),

/***/ "../server/node_modules/mongoose/lib/helpers/updateValidators.js":
/*!***********************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/helpers/updateValidators.js ***!
  \***********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\n/*!\n * Module dependencies.\n */\n\nconst ValidationError = __webpack_require__(/*! ../error/validation */ \"../server/node_modules/mongoose/lib/error/validation.js\");\nconst cleanPositionalOperators = __webpack_require__(/*! ./schema/cleanPositionalOperators */ \"../server/node_modules/mongoose/lib/helpers/schema/cleanPositionalOperators.js\");\nconst flatten = (__webpack_require__(/*! ./common */ \"../server/node_modules/mongoose/lib/helpers/common.js\").flatten);\nconst modifiedPaths = (__webpack_require__(/*! ./common */ \"../server/node_modules/mongoose/lib/helpers/common.js\").modifiedPaths);\n\n/**\n * Applies validators and defaults to update and findOneAndUpdate operations,\n * specifically passing a null doc as `this` to validators and defaults\n *\n * @param {Query} query\n * @param {Schema} schema\n * @param {Object} castedDoc\n * @param {Object} options\n * @method runValidatorsOnUpdate\n * @api private\n */\n\nmodule.exports = function(query, schema, castedDoc, options, callback) {\n  const keys = Object.keys(castedDoc || {});\n  let updatedKeys = {};\n  let updatedValues = {};\n  const isPull = {};\n  const arrayAtomicUpdates = {};\n  const numKeys = keys.length;\n  let hasDollarUpdate = false;\n  const modified = {};\n  let currentUpdate;\n  let key;\n  let i;\n\n  for (i = 0; i < numKeys; ++i) {\n    if (keys[i].startsWith('$')) {\n      hasDollarUpdate = true;\n      if (keys[i] === '$push' || keys[i] === '$addToSet') {\n        const _keys = Object.keys(castedDoc[keys[i]]);\n        for (let ii = 0; ii < _keys.length; ++ii) {\n          currentUpdate = castedDoc[keys[i]][_keys[ii]];\n          if (currentUpdate && currentUpdate.$each) {\n            arrayAtomicUpdates[_keys[ii]] = (arrayAtomicUpdates[_keys[ii]] || []).\n              concat(currentUpdate.$each);\n          } else {\n            arrayAtomicUpdates[_keys[ii]] = (arrayAtomicUpdates[_keys[ii]] || []).\n              concat([currentUpdate]);\n          }\n        }\n        continue;\n      }\n      modifiedPaths(castedDoc[keys[i]], '', modified);\n      const flat = flatten(castedDoc[keys[i]], null, null, schema);\n      const paths = Object.keys(flat);\n      const numPaths = paths.length;\n      for (let j = 0; j < numPaths; ++j) {\n        const updatedPath = cleanPositionalOperators(paths[j]);\n        key = keys[i];\n        // With `$pull` we might flatten `$in`. Skip stuff nested under `$in`\n        // for the rest of the logic, it will get handled later.\n        if (updatedPath.includes('$')) {\n          continue;\n        }\n        if (key === '$set' || key === '$setOnInsert' ||\n            key === '$pull' || key === '$pullAll') {\n          updatedValues[updatedPath] = flat[paths[j]];\n          isPull[updatedPath] = key === '$pull' || key === '$pullAll';\n        } else if (key === '$unset') {\n          updatedValues[updatedPath] = undefined;\n        }\n        updatedKeys[updatedPath] = true;\n      }\n    }\n  }\n\n  if (!hasDollarUpdate) {\n    modifiedPaths(castedDoc, '', modified);\n    updatedValues = flatten(castedDoc, null, null, schema);\n    updatedKeys = Object.keys(updatedValues);\n  }\n\n  const updates = Object.keys(updatedValues);\n  const numUpdates = updates.length;\n  const validatorsToExecute = [];\n  const validationErrors = [];\n\n  const alreadyValidated = [];\n\n  const context = query;\n  function iter(i, v) {\n    const schemaPath = schema._getSchema(updates[i]);\n    if (schemaPath == null) {\n      return;\n    }\n    if (schemaPath.instance === 'Mixed' && schemaPath.path !== updates[i]) {\n      return;\n    }\n\n    if (v && Array.isArray(v.$in)) {\n      v.$in.forEach((v, i) => {\n        validatorsToExecute.push(function(callback) {\n          schemaPath.doValidate(\n            v,\n            function(err) {\n              if (err) {\n                err.path = updates[i] + '.$in.' + i;\n                validationErrors.push(err);\n              }\n              callback(null);\n            },\n            context,\n            { updateValidator: true });\n        });\n      });\n    } else {\n      if (isPull[updates[i]] &&\n          schemaPath.$isMongooseArray) {\n        return;\n      }\n\n      if (schemaPath.$isMongooseDocumentArrayElement && v != null && v.$__ != null) {\n        alreadyValidated.push(updates[i]);\n        validatorsToExecute.push(function(callback) {\n          schemaPath.doValidate(v, function(err) {\n            if (err) {\n              if (err.errors) {\n                for (const key of Object.keys(err.errors)) {\n                  const _err = err.errors[key];\n                  _err.path = updates[i] + '.' + key;\n                  validationErrors.push(_err);\n                }\n              } else {\n                err.path = updates[i];\n                validationErrors.push(err);\n              }\n            }\n\n            return callback(null);\n          }, context, { updateValidator: true });\n        });\n      } else {\n        validatorsToExecute.push(function(callback) {\n          for (const path of alreadyValidated) {\n            if (updates[i].startsWith(path + '.')) {\n              return callback(null);\n            }\n          }\n\n          schemaPath.doValidate(v, function(err) {\n            if (schemaPath.schema != null &&\n                schemaPath.schema.options.storeSubdocValidationError === false &&\n                err instanceof ValidationError) {\n              return callback(null);\n            }\n\n            if (err) {\n              err.path = updates[i];\n              validationErrors.push(err);\n            }\n            callback(null);\n          }, context, { updateValidator: true });\n        });\n      }\n    }\n  }\n  for (i = 0; i < numUpdates; ++i) {\n    iter(i, updatedValues[updates[i]]);\n  }\n\n  const arrayUpdates = Object.keys(arrayAtomicUpdates);\n  for (const arrayUpdate of arrayUpdates) {\n    let schemaPath = schema._getSchema(arrayUpdate);\n    if (schemaPath && schemaPath.$isMongooseDocumentArray) {\n      validatorsToExecute.push(function(callback) {\n        schemaPath.doValidate(\n          arrayAtomicUpdates[arrayUpdate],\n          getValidationCallback(arrayUpdate, validationErrors, callback),\n          options && options.context === 'query' ? query : null);\n      });\n    } else {\n      schemaPath = schema._getSchema(arrayUpdate + '.0');\n      for (const atomicUpdate of arrayAtomicUpdates[arrayUpdate]) {\n        validatorsToExecute.push(function(callback) {\n          schemaPath.doValidate(\n            atomicUpdate,\n            getValidationCallback(arrayUpdate, validationErrors, callback),\n            options && options.context === 'query' ? query : null,\n            { updateValidator: true });\n        });\n      }\n    }\n  }\n\n  if (callback != null) {\n    let numValidators = validatorsToExecute.length;\n    if (numValidators === 0) {\n      return _done(callback);\n    }\n    for (const validator of validatorsToExecute) {\n      validator(function() {\n        if (--numValidators <= 0) {\n          _done(callback);\n        }\n      });\n    }\n\n    return;\n  }\n\n  return function(callback) {\n    let numValidators = validatorsToExecute.length;\n    if (numValidators === 0) {\n      return _done(callback);\n    }\n    for (const validator of validatorsToExecute) {\n      validator(function() {\n        if (--numValidators <= 0) {\n          _done(callback);\n        }\n      });\n    }\n  };\n\n  function _done(callback) {\n    if (validationErrors.length) {\n      const err = new ValidationError(null);\n\n      for (const validationError of validationErrors) {\n        err.addError(validationError.path, validationError);\n      }\n\n      return callback(err);\n    }\n    callback(null);\n  }\n\n  function getValidationCallback(arrayUpdate, validationErrors, callback) {\n    return function(err) {\n      if (err) {\n        err.path = arrayUpdate;\n        validationErrors.push(err);\n      }\n      callback(null);\n    };\n  }\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy91cGRhdGVWYWxpZGF0b3JzLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0E7QUFDQTs7QUFFQSx3QkFBd0IsbUJBQU8sQ0FBQyxvRkFBcUI7QUFDckQsaUNBQWlDLG1CQUFPLENBQUMseUhBQW1DO0FBQzVFLGdCQUFnQixzR0FBMkI7QUFDM0Msc0JBQXNCLDRHQUFpQzs7QUFFdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGNBQWMsYUFBYTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixtQkFBbUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsY0FBYztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsY0FBYyx1QkFBdUI7QUFDckMsU0FBUztBQUNULE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsYUFBYSx1QkFBdUI7QUFDL0MsU0FBUztBQUNULFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGFBQWEsdUJBQXVCO0FBQy9DLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxjQUFjLGdCQUFnQjtBQUM5QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLHVCQUF1QjtBQUNyQyxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2xpZW50Ly4uL3NlcnZlci9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvdXBkYXRlVmFsaWRhdG9ycy5qcz9hZjVmIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuLyohXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbmNvbnN0IFZhbGlkYXRpb25FcnJvciA9IHJlcXVpcmUoJy4uL2Vycm9yL3ZhbGlkYXRpb24nKTtcbmNvbnN0IGNsZWFuUG9zaXRpb25hbE9wZXJhdG9ycyA9IHJlcXVpcmUoJy4vc2NoZW1hL2NsZWFuUG9zaXRpb25hbE9wZXJhdG9ycycpO1xuY29uc3QgZmxhdHRlbiA9IHJlcXVpcmUoJy4vY29tbW9uJykuZmxhdHRlbjtcbmNvbnN0IG1vZGlmaWVkUGF0aHMgPSByZXF1aXJlKCcuL2NvbW1vbicpLm1vZGlmaWVkUGF0aHM7XG5cbi8qKlxuICogQXBwbGllcyB2YWxpZGF0b3JzIGFuZCBkZWZhdWx0cyB0byB1cGRhdGUgYW5kIGZpbmRPbmVBbmRVcGRhdGUgb3BlcmF0aW9ucyxcbiAqIHNwZWNpZmljYWxseSBwYXNzaW5nIGEgbnVsbCBkb2MgYXMgYHRoaXNgIHRvIHZhbGlkYXRvcnMgYW5kIGRlZmF1bHRzXG4gKlxuICogQHBhcmFtIHtRdWVyeX0gcXVlcnlcbiAqIEBwYXJhbSB7U2NoZW1hfSBzY2hlbWFcbiAqIEBwYXJhbSB7T2JqZWN0fSBjYXN0ZWREb2NcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAbWV0aG9kIHJ1blZhbGlkYXRvcnNPblVwZGF0ZVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihxdWVyeSwgc2NoZW1hLCBjYXN0ZWREb2MsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhjYXN0ZWREb2MgfHwge30pO1xuICBsZXQgdXBkYXRlZEtleXMgPSB7fTtcbiAgbGV0IHVwZGF0ZWRWYWx1ZXMgPSB7fTtcbiAgY29uc3QgaXNQdWxsID0ge307XG4gIGNvbnN0IGFycmF5QXRvbWljVXBkYXRlcyA9IHt9O1xuICBjb25zdCBudW1LZXlzID0ga2V5cy5sZW5ndGg7XG4gIGxldCBoYXNEb2xsYXJVcGRhdGUgPSBmYWxzZTtcbiAgY29uc3QgbW9kaWZpZWQgPSB7fTtcbiAgbGV0IGN1cnJlbnRVcGRhdGU7XG4gIGxldCBrZXk7XG4gIGxldCBpO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBudW1LZXlzOyArK2kpIHtcbiAgICBpZiAoa2V5c1tpXS5zdGFydHNXaXRoKCckJykpIHtcbiAgICAgIGhhc0RvbGxhclVwZGF0ZSA9IHRydWU7XG4gICAgICBpZiAoa2V5c1tpXSA9PT0gJyRwdXNoJyB8fCBrZXlzW2ldID09PSAnJGFkZFRvU2V0Jykge1xuICAgICAgICBjb25zdCBfa2V5cyA9IE9iamVjdC5rZXlzKGNhc3RlZERvY1trZXlzW2ldXSk7XG4gICAgICAgIGZvciAobGV0IGlpID0gMDsgaWkgPCBfa2V5cy5sZW5ndGg7ICsraWkpIHtcbiAgICAgICAgICBjdXJyZW50VXBkYXRlID0gY2FzdGVkRG9jW2tleXNbaV1dW19rZXlzW2lpXV07XG4gICAgICAgICAgaWYgKGN1cnJlbnRVcGRhdGUgJiYgY3VycmVudFVwZGF0ZS4kZWFjaCkge1xuICAgICAgICAgICAgYXJyYXlBdG9taWNVcGRhdGVzW19rZXlzW2lpXV0gPSAoYXJyYXlBdG9taWNVcGRhdGVzW19rZXlzW2lpXV0gfHwgW10pLlxuICAgICAgICAgICAgICBjb25jYXQoY3VycmVudFVwZGF0ZS4kZWFjaCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGFycmF5QXRvbWljVXBkYXRlc1tfa2V5c1tpaV1dID0gKGFycmF5QXRvbWljVXBkYXRlc1tfa2V5c1tpaV1dIHx8IFtdKS5cbiAgICAgICAgICAgICAgY29uY2F0KFtjdXJyZW50VXBkYXRlXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgbW9kaWZpZWRQYXRocyhjYXN0ZWREb2Nba2V5c1tpXV0sICcnLCBtb2RpZmllZCk7XG4gICAgICBjb25zdCBmbGF0ID0gZmxhdHRlbihjYXN0ZWREb2Nba2V5c1tpXV0sIG51bGwsIG51bGwsIHNjaGVtYSk7XG4gICAgICBjb25zdCBwYXRocyA9IE9iamVjdC5rZXlzKGZsYXQpO1xuICAgICAgY29uc3QgbnVtUGF0aHMgPSBwYXRocy5sZW5ndGg7XG4gICAgICBmb3IgKGxldCBqID0gMDsgaiA8IG51bVBhdGhzOyArK2opIHtcbiAgICAgICAgY29uc3QgdXBkYXRlZFBhdGggPSBjbGVhblBvc2l0aW9uYWxPcGVyYXRvcnMocGF0aHNbal0pO1xuICAgICAgICBrZXkgPSBrZXlzW2ldO1xuICAgICAgICAvLyBXaXRoIGAkcHVsbGAgd2UgbWlnaHQgZmxhdHRlbiBgJGluYC4gU2tpcCBzdHVmZiBuZXN0ZWQgdW5kZXIgYCRpbmBcbiAgICAgICAgLy8gZm9yIHRoZSByZXN0IG9mIHRoZSBsb2dpYywgaXQgd2lsbCBnZXQgaGFuZGxlZCBsYXRlci5cbiAgICAgICAgaWYgKHVwZGF0ZWRQYXRoLmluY2x1ZGVzKCckJykpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoa2V5ID09PSAnJHNldCcgfHwga2V5ID09PSAnJHNldE9uSW5zZXJ0JyB8fFxuICAgICAgICAgICAga2V5ID09PSAnJHB1bGwnIHx8IGtleSA9PT0gJyRwdWxsQWxsJykge1xuICAgICAgICAgIHVwZGF0ZWRWYWx1ZXNbdXBkYXRlZFBhdGhdID0gZmxhdFtwYXRoc1tqXV07XG4gICAgICAgICAgaXNQdWxsW3VwZGF0ZWRQYXRoXSA9IGtleSA9PT0gJyRwdWxsJyB8fCBrZXkgPT09ICckcHVsbEFsbCc7XG4gICAgICAgIH0gZWxzZSBpZiAoa2V5ID09PSAnJHVuc2V0Jykge1xuICAgICAgICAgIHVwZGF0ZWRWYWx1ZXNbdXBkYXRlZFBhdGhdID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHVwZGF0ZWRLZXlzW3VwZGF0ZWRQYXRoXSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKCFoYXNEb2xsYXJVcGRhdGUpIHtcbiAgICBtb2RpZmllZFBhdGhzKGNhc3RlZERvYywgJycsIG1vZGlmaWVkKTtcbiAgICB1cGRhdGVkVmFsdWVzID0gZmxhdHRlbihjYXN0ZWREb2MsIG51bGwsIG51bGwsIHNjaGVtYSk7XG4gICAgdXBkYXRlZEtleXMgPSBPYmplY3Qua2V5cyh1cGRhdGVkVmFsdWVzKTtcbiAgfVxuXG4gIGNvbnN0IHVwZGF0ZXMgPSBPYmplY3Qua2V5cyh1cGRhdGVkVmFsdWVzKTtcbiAgY29uc3QgbnVtVXBkYXRlcyA9IHVwZGF0ZXMubGVuZ3RoO1xuICBjb25zdCB2YWxpZGF0b3JzVG9FeGVjdXRlID0gW107XG4gIGNvbnN0IHZhbGlkYXRpb25FcnJvcnMgPSBbXTtcblxuICBjb25zdCBhbHJlYWR5VmFsaWRhdGVkID0gW107XG5cbiAgY29uc3QgY29udGV4dCA9IHF1ZXJ5O1xuICBmdW5jdGlvbiBpdGVyKGksIHYpIHtcbiAgICBjb25zdCBzY2hlbWFQYXRoID0gc2NoZW1hLl9nZXRTY2hlbWEodXBkYXRlc1tpXSk7XG4gICAgaWYgKHNjaGVtYVBhdGggPT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoc2NoZW1hUGF0aC5pbnN0YW5jZSA9PT0gJ01peGVkJyAmJiBzY2hlbWFQYXRoLnBhdGggIT09IHVwZGF0ZXNbaV0pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodiAmJiBBcnJheS5pc0FycmF5KHYuJGluKSkge1xuICAgICAgdi4kaW4uZm9yRWFjaCgodiwgaSkgPT4ge1xuICAgICAgICB2YWxpZGF0b3JzVG9FeGVjdXRlLnB1c2goZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgICAgICAgICBzY2hlbWFQYXRoLmRvVmFsaWRhdGUoXG4gICAgICAgICAgICB2LFxuICAgICAgICAgICAgZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICBlcnIucGF0aCA9IHVwZGF0ZXNbaV0gKyAnLiRpbi4nICsgaTtcbiAgICAgICAgICAgICAgICB2YWxpZGF0aW9uRXJyb3JzLnB1c2goZXJyKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjYWxsYmFjayhudWxsKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjb250ZXh0LFxuICAgICAgICAgICAgeyB1cGRhdGVWYWxpZGF0b3I6IHRydWUgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChpc1B1bGxbdXBkYXRlc1tpXV0gJiZcbiAgICAgICAgICBzY2hlbWFQYXRoLiRpc01vbmdvb3NlQXJyYXkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoc2NoZW1hUGF0aC4kaXNNb25nb29zZURvY3VtZW50QXJyYXlFbGVtZW50ICYmIHYgIT0gbnVsbCAmJiB2LiRfXyAhPSBudWxsKSB7XG4gICAgICAgIGFscmVhZHlWYWxpZGF0ZWQucHVzaCh1cGRhdGVzW2ldKTtcbiAgICAgICAgdmFsaWRhdG9yc1RvRXhlY3V0ZS5wdXNoKGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgICAgICAgc2NoZW1hUGF0aC5kb1ZhbGlkYXRlKHYsIGZ1bmN0aW9uKGVycikge1xuICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICBpZiAoZXJyLmVycm9ycykge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKGVyci5lcnJvcnMpKSB7XG4gICAgICAgICAgICAgICAgICBjb25zdCBfZXJyID0gZXJyLmVycm9yc1trZXldO1xuICAgICAgICAgICAgICAgICAgX2Vyci5wYXRoID0gdXBkYXRlc1tpXSArICcuJyArIGtleTtcbiAgICAgICAgICAgICAgICAgIHZhbGlkYXRpb25FcnJvcnMucHVzaChfZXJyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZXJyLnBhdGggPSB1cGRhdGVzW2ldO1xuICAgICAgICAgICAgICAgIHZhbGlkYXRpb25FcnJvcnMucHVzaChlcnIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhudWxsKTtcbiAgICAgICAgICB9LCBjb250ZXh0LCB7IHVwZGF0ZVZhbGlkYXRvcjogdHJ1ZSB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YWxpZGF0b3JzVG9FeGVjdXRlLnB1c2goZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgICAgICAgICBmb3IgKGNvbnN0IHBhdGggb2YgYWxyZWFkeVZhbGlkYXRlZCkge1xuICAgICAgICAgICAgaWYgKHVwZGF0ZXNbaV0uc3RhcnRzV2l0aChwYXRoICsgJy4nKSkge1xuICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgc2NoZW1hUGF0aC5kb1ZhbGlkYXRlKHYsIGZ1bmN0aW9uKGVycikge1xuICAgICAgICAgICAgaWYgKHNjaGVtYVBhdGguc2NoZW1hICE9IG51bGwgJiZcbiAgICAgICAgICAgICAgICBzY2hlbWFQYXRoLnNjaGVtYS5vcHRpb25zLnN0b3JlU3ViZG9jVmFsaWRhdGlvbkVycm9yID09PSBmYWxzZSAmJlxuICAgICAgICAgICAgICAgIGVyciBpbnN0YW5jZW9mIFZhbGlkYXRpb25FcnJvcikge1xuICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgZXJyLnBhdGggPSB1cGRhdGVzW2ldO1xuICAgICAgICAgICAgICB2YWxpZGF0aW9uRXJyb3JzLnB1c2goZXJyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhbGxiYWNrKG51bGwpO1xuICAgICAgICAgIH0sIGNvbnRleHQsIHsgdXBkYXRlVmFsaWRhdG9yOiB0cnVlIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZm9yIChpID0gMDsgaSA8IG51bVVwZGF0ZXM7ICsraSkge1xuICAgIGl0ZXIoaSwgdXBkYXRlZFZhbHVlc1t1cGRhdGVzW2ldXSk7XG4gIH1cblxuICBjb25zdCBhcnJheVVwZGF0ZXMgPSBPYmplY3Qua2V5cyhhcnJheUF0b21pY1VwZGF0ZXMpO1xuICBmb3IgKGNvbnN0IGFycmF5VXBkYXRlIG9mIGFycmF5VXBkYXRlcykge1xuICAgIGxldCBzY2hlbWFQYXRoID0gc2NoZW1hLl9nZXRTY2hlbWEoYXJyYXlVcGRhdGUpO1xuICAgIGlmIChzY2hlbWFQYXRoICYmIHNjaGVtYVBhdGguJGlzTW9uZ29vc2VEb2N1bWVudEFycmF5KSB7XG4gICAgICB2YWxpZGF0b3JzVG9FeGVjdXRlLnB1c2goZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgICAgICAgc2NoZW1hUGF0aC5kb1ZhbGlkYXRlKFxuICAgICAgICAgIGFycmF5QXRvbWljVXBkYXRlc1thcnJheVVwZGF0ZV0sXG4gICAgICAgICAgZ2V0VmFsaWRhdGlvbkNhbGxiYWNrKGFycmF5VXBkYXRlLCB2YWxpZGF0aW9uRXJyb3JzLCBjYWxsYmFjayksXG4gICAgICAgICAgb3B0aW9ucyAmJiBvcHRpb25zLmNvbnRleHQgPT09ICdxdWVyeScgPyBxdWVyeSA6IG51bGwpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNjaGVtYVBhdGggPSBzY2hlbWEuX2dldFNjaGVtYShhcnJheVVwZGF0ZSArICcuMCcpO1xuICAgICAgZm9yIChjb25zdCBhdG9taWNVcGRhdGUgb2YgYXJyYXlBdG9taWNVcGRhdGVzW2FycmF5VXBkYXRlXSkge1xuICAgICAgICB2YWxpZGF0b3JzVG9FeGVjdXRlLnB1c2goZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgICAgICAgICBzY2hlbWFQYXRoLmRvVmFsaWRhdGUoXG4gICAgICAgICAgICBhdG9taWNVcGRhdGUsXG4gICAgICAgICAgICBnZXRWYWxpZGF0aW9uQ2FsbGJhY2soYXJyYXlVcGRhdGUsIHZhbGlkYXRpb25FcnJvcnMsIGNhbGxiYWNrKSxcbiAgICAgICAgICAgIG9wdGlvbnMgJiYgb3B0aW9ucy5jb250ZXh0ID09PSAncXVlcnknID8gcXVlcnkgOiBudWxsLFxuICAgICAgICAgICAgeyB1cGRhdGVWYWxpZGF0b3I6IHRydWUgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChjYWxsYmFjayAhPSBudWxsKSB7XG4gICAgbGV0IG51bVZhbGlkYXRvcnMgPSB2YWxpZGF0b3JzVG9FeGVjdXRlLmxlbmd0aDtcbiAgICBpZiAobnVtVmFsaWRhdG9ycyA9PT0gMCkge1xuICAgICAgcmV0dXJuIF9kb25lKGNhbGxiYWNrKTtcbiAgICB9XG4gICAgZm9yIChjb25zdCB2YWxpZGF0b3Igb2YgdmFsaWRhdG9yc1RvRXhlY3V0ZSkge1xuICAgICAgdmFsaWRhdG9yKGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoLS1udW1WYWxpZGF0b3JzIDw9IDApIHtcbiAgICAgICAgICBfZG9uZShjYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybjtcbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbihjYWxsYmFjaykge1xuICAgIGxldCBudW1WYWxpZGF0b3JzID0gdmFsaWRhdG9yc1RvRXhlY3V0ZS5sZW5ndGg7XG4gICAgaWYgKG51bVZhbGlkYXRvcnMgPT09IDApIHtcbiAgICAgIHJldHVybiBfZG9uZShjYWxsYmFjayk7XG4gICAgfVxuICAgIGZvciAoY29uc3QgdmFsaWRhdG9yIG9mIHZhbGlkYXRvcnNUb0V4ZWN1dGUpIHtcbiAgICAgIHZhbGlkYXRvcihmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKC0tbnVtVmFsaWRhdG9ycyA8PSAwKSB7XG4gICAgICAgICAgX2RvbmUoY2FsbGJhY2spO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH07XG5cbiAgZnVuY3Rpb24gX2RvbmUoY2FsbGJhY2spIHtcbiAgICBpZiAodmFsaWRhdGlvbkVycm9ycy5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IGVyciA9IG5ldyBWYWxpZGF0aW9uRXJyb3IobnVsbCk7XG5cbiAgICAgIGZvciAoY29uc3QgdmFsaWRhdGlvbkVycm9yIG9mIHZhbGlkYXRpb25FcnJvcnMpIHtcbiAgICAgICAgZXJyLmFkZEVycm9yKHZhbGlkYXRpb25FcnJvci5wYXRoLCB2YWxpZGF0aW9uRXJyb3IpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICB9XG4gICAgY2FsbGJhY2sobnVsbCk7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRWYWxpZGF0aW9uQ2FsbGJhY2soYXJyYXlVcGRhdGUsIHZhbGlkYXRpb25FcnJvcnMsIGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGVycikge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICBlcnIucGF0aCA9IGFycmF5VXBkYXRlO1xuICAgICAgICB2YWxpZGF0aW9uRXJyb3JzLnB1c2goZXJyKTtcbiAgICAgIH1cbiAgICAgIGNhbGxiYWNrKG51bGwpO1xuICAgIH07XG4gIH1cbn07XG5cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../server/node_modules/mongoose/lib/helpers/updateValidators.js\n");

/***/ }),

/***/ "../server/node_modules/mongoose/lib/index.js":
/*!****************************************************!*\
  !*** ../server/node_modules/mongoose/lib/index.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\n/*!\n * Module dependencies.\n */\n\n(__webpack_require__(/*! ./driver */ \"../server/node_modules/mongoose/lib/driver.js\").set)(__webpack_require__(/*! ./drivers/node-mongodb-native */ \"../server/node_modules/mongoose/lib/drivers/node-mongodb-native/index.js\"));\n\nconst mongoose = __webpack_require__(/*! ./mongoose */ \"../server/node_modules/mongoose/lib/mongoose.js\");\n\nmongoose.Mongoose.prototype.mongo = __webpack_require__(/*! mongodb */ \"../server/node_modules/mongodb/lib/index.js\");\n\nmodule.exports = mongoose;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7QUFDQTtBQUNBOztBQUVBLDBGQUF1QixDQUFDLG1CQUFPLENBQUMsK0dBQStCOztBQUUvRCxpQkFBaUIsbUJBQU8sQ0FBQyxtRUFBWTs7QUFFckMsb0NBQW9DLG1CQUFPLENBQUMsNERBQVM7O0FBRXJEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2xpZW50Ly4uL3NlcnZlci9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2luZGV4LmpzPzc0ZjAiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG4vKiFcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxucmVxdWlyZSgnLi9kcml2ZXInKS5zZXQocmVxdWlyZSgnLi9kcml2ZXJzL25vZGUtbW9uZ29kYi1uYXRpdmUnKSk7XG5cbmNvbnN0IG1vbmdvb3NlID0gcmVxdWlyZSgnLi9tb25nb29zZScpO1xuXG5tb25nb29zZS5Nb25nb29zZS5wcm90b3R5cGUubW9uZ28gPSByZXF1aXJlKCdtb25nb2RiJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gbW9uZ29vc2U7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../server/node_modules/mongoose/lib/index.js\n");

/***/ }),

/***/ "../server/node_modules/mongoose/lib/internal.js":
/*!*******************************************************!*\
  !*** ../server/node_modules/mongoose/lib/internal.js ***!
  \*******************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("/*!\n * Dependencies\n */\n\n\n\nconst StateMachine = __webpack_require__(/*! ./stateMachine */ \"../server/node_modules/mongoose/lib/stateMachine.js\");\nconst ActiveRoster = StateMachine.ctor('require', 'modify', 'init', 'default', 'ignore');\n\nmodule.exports = exports = InternalCache;\n\nfunction InternalCache() {\n  this.activePaths = new ActiveRoster();\n}\n\nInternalCache.prototype.strictMode = true;\n\nInternalCache.prototype.fullPath = undefined;\nInternalCache.prototype.selected = undefined;\nInternalCache.prototype.shardval = undefined;\nInternalCache.prototype.saveError = undefined;\nInternalCache.prototype.validationError = undefined;\nInternalCache.prototype.adhocPaths = undefined;\nInternalCache.prototype.removing = undefined;\nInternalCache.prototype.inserting = undefined;\nInternalCache.prototype.saving = undefined;\nInternalCache.prototype.version = undefined;\nInternalCache.prototype._id = undefined;\nInternalCache.prototype.ownerDocument = undefined;\nInternalCache.prototype.populate = undefined; // what we want to populate in this doc\nInternalCache.prototype.populated = undefined;// the _ids that have been populated\nInternalCache.prototype.primitiveAtomics = undefined;\n\n/**\n * If `false`, this document was not the result of population.\n * If `true`, this document is a populated doc underneath another doc\n * If an object, this document is a populated doc and the `value` property of the\n * object contains the original depopulated value.\n */\nInternalCache.prototype.wasPopulated = false;\n\nInternalCache.prototype.scope = undefined;\n\nInternalCache.prototype.session = null;\nInternalCache.prototype.pathsToScopes = null;\nInternalCache.prototype.cachedRequired = null;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaW50ZXJuYWwuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBOztBQUVhOztBQUViLHFCQUFxQixtQkFBTyxDQUFDLDJFQUFnQjtBQUM3Qzs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDO0FBQzlDLDhDQUE4QztBQUM5Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbGllbnQvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaW50ZXJuYWwuanM/OGRjZSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIERlcGVuZGVuY2llc1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxuY29uc3QgU3RhdGVNYWNoaW5lID0gcmVxdWlyZSgnLi9zdGF0ZU1hY2hpbmUnKTtcbmNvbnN0IEFjdGl2ZVJvc3RlciA9IFN0YXRlTWFjaGluZS5jdG9yKCdyZXF1aXJlJywgJ21vZGlmeScsICdpbml0JywgJ2RlZmF1bHQnLCAnaWdub3JlJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IEludGVybmFsQ2FjaGU7XG5cbmZ1bmN0aW9uIEludGVybmFsQ2FjaGUoKSB7XG4gIHRoaXMuYWN0aXZlUGF0aHMgPSBuZXcgQWN0aXZlUm9zdGVyKCk7XG59XG5cbkludGVybmFsQ2FjaGUucHJvdG90eXBlLnN0cmljdE1vZGUgPSB0cnVlO1xuXG5JbnRlcm5hbENhY2hlLnByb3RvdHlwZS5mdWxsUGF0aCA9IHVuZGVmaW5lZDtcbkludGVybmFsQ2FjaGUucHJvdG90eXBlLnNlbGVjdGVkID0gdW5kZWZpbmVkO1xuSW50ZXJuYWxDYWNoZS5wcm90b3R5cGUuc2hhcmR2YWwgPSB1bmRlZmluZWQ7XG5JbnRlcm5hbENhY2hlLnByb3RvdHlwZS5zYXZlRXJyb3IgPSB1bmRlZmluZWQ7XG5JbnRlcm5hbENhY2hlLnByb3RvdHlwZS52YWxpZGF0aW9uRXJyb3IgPSB1bmRlZmluZWQ7XG5JbnRlcm5hbENhY2hlLnByb3RvdHlwZS5hZGhvY1BhdGhzID0gdW5kZWZpbmVkO1xuSW50ZXJuYWxDYWNoZS5wcm90b3R5cGUucmVtb3ZpbmcgPSB1bmRlZmluZWQ7XG5JbnRlcm5hbENhY2hlLnByb3RvdHlwZS5pbnNlcnRpbmcgPSB1bmRlZmluZWQ7XG5JbnRlcm5hbENhY2hlLnByb3RvdHlwZS5zYXZpbmcgPSB1bmRlZmluZWQ7XG5JbnRlcm5hbENhY2hlLnByb3RvdHlwZS52ZXJzaW9uID0gdW5kZWZpbmVkO1xuSW50ZXJuYWxDYWNoZS5wcm90b3R5cGUuX2lkID0gdW5kZWZpbmVkO1xuSW50ZXJuYWxDYWNoZS5wcm90b3R5cGUub3duZXJEb2N1bWVudCA9IHVuZGVmaW5lZDtcbkludGVybmFsQ2FjaGUucHJvdG90eXBlLnBvcHVsYXRlID0gdW5kZWZpbmVkOyAvLyB3aGF0IHdlIHdhbnQgdG8gcG9wdWxhdGUgaW4gdGhpcyBkb2NcbkludGVybmFsQ2FjaGUucHJvdG90eXBlLnBvcHVsYXRlZCA9IHVuZGVmaW5lZDsvLyB0aGUgX2lkcyB0aGF0IGhhdmUgYmVlbiBwb3B1bGF0ZWRcbkludGVybmFsQ2FjaGUucHJvdG90eXBlLnByaW1pdGl2ZUF0b21pY3MgPSB1bmRlZmluZWQ7XG5cbi8qKlxuICogSWYgYGZhbHNlYCwgdGhpcyBkb2N1bWVudCB3YXMgbm90IHRoZSByZXN1bHQgb2YgcG9wdWxhdGlvbi5cbiAqIElmIGB0cnVlYCwgdGhpcyBkb2N1bWVudCBpcyBhIHBvcHVsYXRlZCBkb2MgdW5kZXJuZWF0aCBhbm90aGVyIGRvY1xuICogSWYgYW4gb2JqZWN0LCB0aGlzIGRvY3VtZW50IGlzIGEgcG9wdWxhdGVkIGRvYyBhbmQgdGhlIGB2YWx1ZWAgcHJvcGVydHkgb2YgdGhlXG4gKiBvYmplY3QgY29udGFpbnMgdGhlIG9yaWdpbmFsIGRlcG9wdWxhdGVkIHZhbHVlLlxuICovXG5JbnRlcm5hbENhY2hlLnByb3RvdHlwZS53YXNQb3B1bGF0ZWQgPSBmYWxzZTtcblxuSW50ZXJuYWxDYWNoZS5wcm90b3R5cGUuc2NvcGUgPSB1bmRlZmluZWQ7XG5cbkludGVybmFsQ2FjaGUucHJvdG90eXBlLnNlc3Npb24gPSBudWxsO1xuSW50ZXJuYWxDYWNoZS5wcm90b3R5cGUucGF0aHNUb1Njb3BlcyA9IG51bGw7XG5JbnRlcm5hbENhY2hlLnByb3RvdHlwZS5jYWNoZWRSZXF1aXJlZCA9IG51bGw7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../server/node_modules/mongoose/lib/internal.js\n");

/***/ }),

/***/ "../server/node_modules/mongoose/lib/model.js":
/*!****************************************************!*\
  !*** ../server/node_modules/mongoose/lib/model.js ***!
  \****************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("\n\n/*!\n * Module dependencies.\n */\n\nconst Aggregate = __webpack_require__(/*! ./aggregate */ \"../server/node_modules/mongoose/lib/aggregate.js\");\nconst ChangeStream = __webpack_require__(/*! ./cursor/changeStream */ \"../server/node_modules/mongoose/lib/cursor/changeStream.js\");\nconst Document = __webpack_require__(/*! ./document */ \"../server/node_modules/mongoose/lib/document.js\");\nconst DocumentNotFoundError = __webpack_require__(/*! ./error/notFound */ \"../server/node_modules/mongoose/lib/error/notFound.js\");\nconst DivergentArrayError = __webpack_require__(/*! ./error/divergentArray */ \"../server/node_modules/mongoose/lib/error/divergentArray.js\");\nconst EventEmitter = (__webpack_require__(/*! events */ \"events\").EventEmitter);\nconst Kareem = __webpack_require__(/*! kareem */ \"../server/node_modules/kareem/index.js\");\nconst MongooseBuffer = __webpack_require__(/*! ./types/buffer */ \"../server/node_modules/mongoose/lib/types/buffer.js\");\nconst MongooseError = __webpack_require__(/*! ./error/index */ \"../server/node_modules/mongoose/lib/error/index.js\");\nconst ObjectParameterError = __webpack_require__(/*! ./error/objectParameter */ \"../server/node_modules/mongoose/lib/error/objectParameter.js\");\nconst OverwriteModelError = __webpack_require__(/*! ./error/overwriteModel */ \"../server/node_modules/mongoose/lib/error/overwriteModel.js\");\nconst Query = __webpack_require__(/*! ./query */ \"../server/node_modules/mongoose/lib/query.js\");\nconst SaveOptions = __webpack_require__(/*! ./options/saveOptions */ \"../server/node_modules/mongoose/lib/options/saveOptions.js\");\nconst Schema = __webpack_require__(/*! ./schema */ \"../server/node_modules/mongoose/lib/schema.js\");\nconst ValidationError = __webpack_require__(/*! ./error/validation */ \"../server/node_modules/mongoose/lib/error/validation.js\");\nconst VersionError = __webpack_require__(/*! ./error/version */ \"../server/node_modules/mongoose/lib/error/version.js\");\nconst ParallelSaveError = __webpack_require__(/*! ./error/parallelSave */ \"../server/node_modules/mongoose/lib/error/parallelSave.js\");\nconst applyDefaultsHelper = __webpack_require__(/*! ./helpers/document/applyDefaults */ \"../server/node_modules/mongoose/lib/helpers/document/applyDefaults.js\");\nconst applyDefaultsToPOJO = __webpack_require__(/*! ./helpers/model/applyDefaultsToPOJO */ \"../server/node_modules/mongoose/lib/helpers/model/applyDefaultsToPOJO.js\");\nconst applyHooks = __webpack_require__(/*! ./helpers/model/applyHooks */ \"../server/node_modules/mongoose/lib/helpers/model/applyHooks.js\");\nconst applyMethods = __webpack_require__(/*! ./helpers/model/applyMethods */ \"../server/node_modules/mongoose/lib/helpers/model/applyMethods.js\");\nconst applyProjection = __webpack_require__(/*! ./helpers/projection/applyProjection */ \"../server/node_modules/mongoose/lib/helpers/projection/applyProjection.js\");\nconst applySchemaCollation = __webpack_require__(/*! ./helpers/indexes/applySchemaCollation */ \"../server/node_modules/mongoose/lib/helpers/indexes/applySchemaCollation.js\");\nconst applyStaticHooks = __webpack_require__(/*! ./helpers/model/applyStaticHooks */ \"../server/node_modules/mongoose/lib/helpers/model/applyStaticHooks.js\");\nconst applyStatics = __webpack_require__(/*! ./helpers/model/applyStatics */ \"../server/node_modules/mongoose/lib/helpers/model/applyStatics.js\");\nconst applyWriteConcern = __webpack_require__(/*! ./helpers/schema/applyWriteConcern */ \"../server/node_modules/mongoose/lib/helpers/schema/applyWriteConcern.js\");\nconst assignVals = __webpack_require__(/*! ./helpers/populate/assignVals */ \"../server/node_modules/mongoose/lib/helpers/populate/assignVals.js\");\nconst castBulkWrite = __webpack_require__(/*! ./helpers/model/castBulkWrite */ \"../server/node_modules/mongoose/lib/helpers/model/castBulkWrite.js\");\nconst clone = __webpack_require__(/*! ./helpers/clone */ \"../server/node_modules/mongoose/lib/helpers/clone.js\");\nconst createPopulateQueryFilter = __webpack_require__(/*! ./helpers/populate/createPopulateQueryFilter */ \"../server/node_modules/mongoose/lib/helpers/populate/createPopulateQueryFilter.js\");\nconst decorateUpdateWithVersionKey = __webpack_require__(/*! ./helpers/update/decorateUpdateWithVersionKey */ \"../server/node_modules/mongoose/lib/helpers/update/decorateUpdateWithVersionKey.js\");\nconst getDefaultBulkwriteResult = __webpack_require__(/*! ./helpers/getDefaultBulkwriteResult */ \"../server/node_modules/mongoose/lib/helpers/getDefaultBulkwriteResult.js\");\nconst getSchemaDiscriminatorByValue = __webpack_require__(/*! ./helpers/discriminator/getSchemaDiscriminatorByValue */ \"../server/node_modules/mongoose/lib/helpers/discriminator/getSchemaDiscriminatorByValue.js\");\nconst discriminator = __webpack_require__(/*! ./helpers/model/discriminator */ \"../server/node_modules/mongoose/lib/helpers/model/discriminator.js\");\nconst firstKey = __webpack_require__(/*! ./helpers/firstKey */ \"../server/node_modules/mongoose/lib/helpers/firstKey.js\");\nconst each = __webpack_require__(/*! ./helpers/each */ \"../server/node_modules/mongoose/lib/helpers/each.js\");\nconst get = __webpack_require__(/*! ./helpers/get */ \"../server/node_modules/mongoose/lib/helpers/get.js\");\nconst getConstructorName = __webpack_require__(/*! ./helpers/getConstructorName */ \"../server/node_modules/mongoose/lib/helpers/getConstructorName.js\");\nconst getDiscriminatorByValue = __webpack_require__(/*! ./helpers/discriminator/getDiscriminatorByValue */ \"../server/node_modules/mongoose/lib/helpers/discriminator/getDiscriminatorByValue.js\");\nconst getModelsMapForPopulate = __webpack_require__(/*! ./helpers/populate/getModelsMapForPopulate */ \"../server/node_modules/mongoose/lib/helpers/populate/getModelsMapForPopulate.js\");\nconst immediate = __webpack_require__(/*! ./helpers/immediate */ \"../server/node_modules/mongoose/lib/helpers/immediate.js\");\nconst internalToObjectOptions = (__webpack_require__(/*! ./options */ \"../server/node_modules/mongoose/lib/options.js\").internalToObjectOptions);\nconst isDefaultIdIndex = __webpack_require__(/*! ./helpers/indexes/isDefaultIdIndex */ \"../server/node_modules/mongoose/lib/helpers/indexes/isDefaultIdIndex.js\");\nconst isIndexEqual = __webpack_require__(/*! ./helpers/indexes/isIndexEqual */ \"../server/node_modules/mongoose/lib/helpers/indexes/isIndexEqual.js\");\nconst {\n  getRelatedDBIndexes,\n  getRelatedSchemaIndexes\n} = __webpack_require__(/*! ./helpers/indexes/getRelatedIndexes */ \"../server/node_modules/mongoose/lib/helpers/indexes/getRelatedIndexes.js\");\nconst isPathExcluded = __webpack_require__(/*! ./helpers/projection/isPathExcluded */ \"../server/node_modules/mongoose/lib/helpers/projection/isPathExcluded.js\");\nconst decorateDiscriminatorIndexOptions = __webpack_require__(/*! ./helpers/indexes/decorateDiscriminatorIndexOptions */ \"../server/node_modules/mongoose/lib/helpers/indexes/decorateDiscriminatorIndexOptions.js\");\nconst isPathSelectedInclusive = __webpack_require__(/*! ./helpers/projection/isPathSelectedInclusive */ \"../server/node_modules/mongoose/lib/helpers/projection/isPathSelectedInclusive.js\");\nconst leanPopulateMap = __webpack_require__(/*! ./helpers/populate/leanPopulateMap */ \"../server/node_modules/mongoose/lib/helpers/populate/leanPopulateMap.js\");\nconst parallelLimit = __webpack_require__(/*! ./helpers/parallelLimit */ \"../server/node_modules/mongoose/lib/helpers/parallelLimit.js\");\nconst parentPaths = __webpack_require__(/*! ./helpers/path/parentPaths */ \"../server/node_modules/mongoose/lib/helpers/path/parentPaths.js\");\nconst prepareDiscriminatorPipeline = __webpack_require__(/*! ./helpers/aggregate/prepareDiscriminatorPipeline */ \"../server/node_modules/mongoose/lib/helpers/aggregate/prepareDiscriminatorPipeline.js\");\nconst pushNestedArrayPaths = __webpack_require__(/*! ./helpers/model/pushNestedArrayPaths */ \"../server/node_modules/mongoose/lib/helpers/model/pushNestedArrayPaths.js\");\nconst removeDeselectedForeignField = __webpack_require__(/*! ./helpers/populate/removeDeselectedForeignField */ \"../server/node_modules/mongoose/lib/helpers/populate/removeDeselectedForeignField.js\");\nconst setDottedPath = __webpack_require__(/*! ./helpers/path/setDottedPath */ \"../server/node_modules/mongoose/lib/helpers/path/setDottedPath.js\");\nconst STATES = __webpack_require__(/*! ./connectionState */ \"../server/node_modules/mongoose/lib/connectionState.js\");\nconst util = __webpack_require__(/*! util */ \"util\");\nconst utils = __webpack_require__(/*! ./utils */ \"../server/node_modules/mongoose/lib/utils.js\");\nconst MongooseBulkWriteError = __webpack_require__(/*! ./error/bulkWriteError */ \"../server/node_modules/mongoose/lib/error/bulkWriteError.js\");\nconst minimize = __webpack_require__(/*! ./helpers/minimize */ \"../server/node_modules/mongoose/lib/helpers/minimize.js\");\n\nconst VERSION_WHERE = 1;\nconst VERSION_INC = 2;\nconst VERSION_ALL = VERSION_WHERE | VERSION_INC;\n\nconst arrayAtomicsSymbol = (__webpack_require__(/*! ./helpers/symbols */ \"../server/node_modules/mongoose/lib/helpers/symbols.js\").arrayAtomicsSymbol);\nconst modelCollectionSymbol = Symbol('mongoose#Model#collection');\nconst modelDbSymbol = Symbol('mongoose#Model#db');\nconst modelSymbol = (__webpack_require__(/*! ./helpers/symbols */ \"../server/node_modules/mongoose/lib/helpers/symbols.js\").modelSymbol);\nconst subclassedSymbol = Symbol('mongoose#Model#subclassed');\n\nconst saveToObjectOptions = Object.assign({}, internalToObjectOptions, {\n  bson: true,\n  flattenObjectIds: false\n});\n\n/**\n * A Model is a class that's your primary tool for interacting with MongoDB.\n * An instance of a Model is called a [Document](https://mongoosejs.com/docs/api/document.html#Document).\n *\n * In Mongoose, the term \"Model\" refers to subclasses of the `mongoose.Model`\n * class. You should not use the `mongoose.Model` class directly. The\n * [`mongoose.model()`](https://mongoosejs.com/docs/api/mongoose.html#Mongoose.prototype.model()) and\n * [`connection.model()`](https://mongoosejs.com/docs/api/connection.html#Connection.prototype.model()) functions\n * create subclasses of `mongoose.Model` as shown below.\n *\n * #### Example:\n *\n *     // `UserModel` is a \"Model\", a subclass of `mongoose.Model`.\n *     const UserModel = mongoose.model('User', new Schema({ name: String }));\n *\n *     // You can use a Model to create new documents using `new`:\n *     const userDoc = new UserModel({ name: 'Foo' });\n *     await userDoc.save();\n *\n *     // You also use a model to create queries:\n *     const userFromDb = await UserModel.findOne({ name: 'Foo' });\n *\n * @param {Object} doc values for initial set\n * @param {Object} [fields] optional object containing the fields that were selected in the query which returned this document. You do **not** need to set this parameter to ensure Mongoose handles your [query projection](https://mongoosejs.com/docs/api/query.html#Query.prototype.select()).\n * @param {Boolean} [skipId=false] optional boolean. If true, mongoose doesn't add an `_id` field to the document.\n * @inherits Document https://mongoosejs.com/docs/api/document.html\n * @event `error`: If listening to this event, 'error' is emitted when a document was saved and an `error` occurred. If not listening, the event bubbles to the connection used to create this Model.\n * @event `index`: Emitted after `Model#ensureIndexes` completes. If an error occurred it is passed with the event.\n * @event `index-single-start`: Emitted when an individual index starts within `Model#ensureIndexes`. The fields and options being used to build the index are also passed with the event.\n * @event `index-single-done`: Emitted when an individual index finishes within `Model#ensureIndexes`. If an error occurred it is passed with the event. The fields, options, and index name are also passed.\n * @api public\n */\n\nfunction Model(doc, fields, skipId) {\n  if (fields instanceof Schema) {\n    throw new TypeError('2nd argument to `Model` constructor must be a POJO or string, ' +\n      '**not** a schema. Make sure you\\'re calling `mongoose.model()`, not ' +\n      '`mongoose.Model()`.');\n  }\n  if (typeof doc === 'string') {\n    throw new TypeError('First argument to `Model` constructor must be an object, ' +\n      '**not** a string. Make sure you\\'re calling `mongoose.model()`, not ' +\n      '`mongoose.Model()`.');\n  }\n  Document.call(this, doc, fields, skipId);\n}\n\n/**\n * Inherits from Document.\n *\n * All Model.prototype features are available on\n * top level (non-sub) documents.\n * @api private\n */\n\nObject.setPrototypeOf(Model.prototype, Document.prototype);\nModel.prototype.$isMongooseModelPrototype = true;\n\n/**\n * Connection the model uses.\n *\n * @api public\n * @property db\n * @memberOf Model\n * @instance\n */\n\nModel.prototype.db;\n\n/**\n * The collection instance this model uses.\n * A Mongoose collection is a thin wrapper around a [MongoDB Node.js driver collection]([MongoDB Node.js driver collection](https://mongodb.github.io/node-mongodb-native/Next/classes/Collection.html)).\n * Using `Model.collection` means you bypass Mongoose middleware, validation, and casting.\n *\n * This property is read-only. Modifying this property is a no-op.\n *\n * @api public\n * @property collection\n * @memberOf Model\n * @instance\n */\n\nModel.prototype.collection;\n\n/**\n * Internal collection the model uses.\n *\n * This property is read-only. Modifying this property is a no-op.\n *\n * @api private\n * @property collection\n * @memberOf Model\n * @instance\n */\n\n\nModel.prototype.$__collection;\n\n/**\n * The name of the model\n *\n * @api public\n * @property modelName\n * @memberOf Model\n * @instance\n */\n\nModel.prototype.modelName;\n\n/**\n * Additional properties to attach to the query when calling `save()` and\n * `isNew` is false.\n *\n * @api public\n * @property $where\n * @memberOf Model\n * @instance\n */\n\nModel.prototype.$where;\n\n/**\n * If this is a discriminator model, `baseModelName` is the name of\n * the base model.\n *\n * @api public\n * @property baseModelName\n * @memberOf Model\n * @instance\n */\n\nModel.prototype.baseModelName;\n\n/**\n * Event emitter that reports any errors that occurred. Useful for global error\n * handling.\n *\n * #### Example:\n *\n *     MyModel.events.on('error', err => console.log(err.message));\n *\n *     // Prints a 'CastError' because of the above handler\n *     await MyModel.findOne({ _id: 'Not a valid ObjectId' }).catch(noop);\n *\n * @api public\n * @property events\n * @fires error whenever any query or model function errors\n * @memberOf Model\n * @static\n */\n\nModel.events;\n\n/**\n * Compiled middleware for this model. Set in `applyHooks()`.\n *\n * @api private\n * @property _middleware\n * @memberOf Model\n * @static\n */\n\nModel._middleware;\n\n/*!\n * ignore\n */\n\nfunction _applyCustomWhere(doc, where) {\n  if (doc.$where == null) {\n    return;\n  }\n  for (const key of Object.keys(doc.$where)) {\n    where[key] = doc.$where[key];\n  }\n}\n\n/*!\n * ignore\n */\n\nModel.prototype.$__handleSave = function(options, callback) {\n  const saveOptions = {};\n\n  applyWriteConcern(this.$__schema, options);\n  if (typeof options.writeConcern !== 'undefined') {\n    saveOptions.writeConcern = {};\n    if ('w' in options.writeConcern) {\n      saveOptions.writeConcern.w = options.writeConcern.w;\n    }\n    if ('j' in options.writeConcern) {\n      saveOptions.writeConcern.j = options.writeConcern.j;\n    }\n    if ('wtimeout' in options.writeConcern) {\n      saveOptions.writeConcern.wtimeout = options.writeConcern.wtimeout;\n    }\n  } else {\n    if ('w' in options) {\n      saveOptions.w = options.w;\n    }\n    if ('j' in options) {\n      saveOptions.j = options.j;\n    }\n    if ('wtimeout' in options) {\n      saveOptions.wtimeout = options.wtimeout;\n    }\n  }\n  if ('checkKeys' in options) {\n    saveOptions.checkKeys = options.checkKeys;\n  }\n\n  const session = this.$session();\n  if (!saveOptions.hasOwnProperty('session') && session != null) {\n    saveOptions.session = session;\n  }\n\n  if (this.$isNew) {\n    // send entire doc\n    const obj = this.toObject(saveToObjectOptions);\n    if ((obj || {})._id === void 0) {\n      // documents must have an _id else mongoose won't know\n      // what to update later if more changes are made. the user\n      // wouldn't know what _id was generated by mongodb either\n      // nor would the ObjectId generated by mongodb necessarily\n      // match the schema definition.\n      immediate(function() {\n        callback(new MongooseError('document must have an _id before saving'));\n      });\n      return;\n    }\n\n    this.$__version(true, obj);\n    this[modelCollectionSymbol].insertOne(obj, saveOptions).then(\n      ret => callback(null, ret),\n      err => {\n        _setIsNew(this, true);\n\n        callback(err, null);\n      }\n    );\n\n    this.$__reset();\n    _setIsNew(this, false);\n    // Make it possible to retry the insert\n    this.$__.inserting = true;\n    return;\n  }\n\n  // Make sure we don't treat it as a new object on error,\n  // since it already exists\n  this.$__.inserting = false;\n  const delta = this.$__delta();\n  if (delta) {\n    if (delta instanceof MongooseError) {\n      callback(delta);\n      return;\n    }\n\n    const where = this.$__where(delta[0]);\n    if (where instanceof MongooseError) {\n      callback(where);\n      return;\n    }\n\n    _applyCustomWhere(this, where);\n\n    const update = delta[1];\n    if (this.$__schema.options.minimize) {\n      minimize(update);\n      // minimize might leave us with an empty object, which would\n      // lead to MongoDB throwing a \"Update document requires atomic operators\" error\n      if (Object.keys(update).length === 0) {\n        handleEmptyUpdate.call(this);\n        return;\n      }\n    }\n\n    this[modelCollectionSymbol].updateOne(where, update, saveOptions).then(\n      ret => {\n        ret.$where = where;\n        callback(null, ret);\n      },\n      err => {\n        this.$__undoReset();\n\n        callback(err);\n      }\n    );\n  } else {\n    handleEmptyUpdate.call(this);\n    return;\n  }\n\n  // store the modified paths before the document is reset\n  this.$__.modifiedPaths = this.modifiedPaths();\n  this.$__reset();\n\n  _setIsNew(this, false);\n\n  function handleEmptyUpdate() {\n    const optionsWithCustomValues = Object.assign({}, options, saveOptions);\n    const where = this.$__where();\n    const optimisticConcurrency = this.$__schema.options.optimisticConcurrency;\n    if (optimisticConcurrency && !Array.isArray(optimisticConcurrency)) {\n      const key = this.$__schema.options.versionKey;\n      const val = this.$__getValue(key);\n      if (val != null) {\n        where[key] = val;\n      }\n    }\n    this.constructor.collection.findOne(where, optionsWithCustomValues)\n      .then(documentExists => {\n        const matchedCount = !documentExists ? 0 : 1;\n        callback(null, { $where: where, matchedCount });\n      })\n      .catch(callback);\n  }\n};\n\n/*!\n * ignore\n */\n\nModel.prototype.$__save = function(options, callback) {\n  this.$__handleSave(options, (error, result) => {\n    if (error) {\n      const hooks = this.$__schema.s.hooks;\n      return hooks.execPost('save:error', this, [this], { error: error }, (error) => {\n        callback(error, this);\n      });\n    }\n    let numAffected = 0;\n    const writeConcern = options != null ?\n      options.writeConcern != null ?\n        options.writeConcern.w :\n        options.w :\n      0;\n    if (writeConcern !== 0) {\n      // Skip checking if write succeeded if writeConcern is set to\n      // unacknowledged writes, because otherwise `numAffected` will always be 0\n      if (result != null) {\n        if (Array.isArray(result)) {\n          numAffected = result.length;\n        } else if (result.matchedCount != null) {\n          numAffected = result.matchedCount;\n        } else {\n          numAffected = result;\n        }\n      }\n\n      const versionBump = this.$__.version;\n      // was this an update that required a version bump?\n      if (versionBump && !this.$__.inserting) {\n        const doIncrement = VERSION_INC === (VERSION_INC & this.$__.version);\n        this.$__.version = undefined;\n        const key = this.$__schema.options.versionKey;\n        const version = this.$__getValue(key) || 0;\n        if (numAffected <= 0) {\n          // the update failed. pass an error back\n          this.$__undoReset();\n          const err = this.$__.$versionError ||\n            new VersionError(this, version, this.$__.modifiedPaths);\n          return callback(err);\n        }\n\n        // increment version if was successful\n        if (doIncrement) {\n          this.$__setValue(key, version + 1);\n        }\n      }\n      if (result != null && numAffected <= 0) {\n        this.$__undoReset();\n        error = new DocumentNotFoundError(result.$where,\n          this.constructor.modelName, numAffected, result);\n        const hooks = this.$__schema.s.hooks;\n        return hooks.execPost('save:error', this, [this], { error: error }, (error) => {\n          callback(error, this);\n        });\n      }\n    }\n    this.$__.saving = undefined;\n    this.$__.savedState = {};\n    this.$emit('save', this, numAffected);\n    this.constructor.emit('save', this, numAffected);\n    callback(null, this);\n  });\n};\n\n/*!\n * ignore\n */\n\nfunction generateVersionError(doc, modifiedPaths) {\n  const key = doc.$__schema.options.versionKey;\n  if (!key) {\n    return null;\n  }\n  const version = doc.$__getValue(key) || 0;\n  return new VersionError(doc, version, modifiedPaths);\n}\n\n/**\n * Saves this document by inserting a new document into the database if [document.isNew](https://mongoosejs.com/docs/api/document.html#Document.prototype.isNew) is `true`,\n * or sends an [updateOne](https://mongoosejs.com/docs/api/document.html#Document.prototype.updateOne()) operation with just the modified paths if `isNew` is `false`.\n *\n * #### Example:\n *\n *     product.sold = Date.now();\n *     product = await product.save();\n *\n * If save is successful, the returned promise will fulfill with the document\n * saved.\n *\n * #### Example:\n *\n *     const newProduct = await product.save();\n *     newProduct === product; // true\n *\n * @param {Object} [options] options optional options\n * @param {Session} [options.session=null] the [session](https://www.mongodb.com/docs/manual/reference/server-sessions/) associated with this save operation. If not specified, defaults to the [document's associated session](https://mongoosejs.com/docs/api/document.html#Document.prototype.session()).\n * @param {Object} [options.safe] (DEPRECATED) overrides [schema's safe option](https://mongoosejs.com/docs/guide.html#safe). Use the `w` option instead.\n * @param {Boolean} [options.validateBeforeSave] set to false to save without validating.\n * @param {Boolean} [options.validateModifiedOnly=false] if `true`, Mongoose will only validate modified paths, as opposed to modified paths and `required` paths.\n * @param {Number|String} [options.w] set the [write concern](https://www.mongodb.com/docs/manual/reference/write-concern/#w-option). Overrides the [schema-level `writeConcern` option](https://mongoosejs.com/docs/guide.html#writeConcern)\n * @param {Boolean} [options.j] set to true for MongoDB to wait until this `save()` has been [journaled before resolving the returned promise](https://www.mongodb.com/docs/manual/reference/write-concern/#j-option). Overrides the [schema-level `writeConcern` option](https://mongoosejs.com/docs/guide.html#writeConcern)\n * @param {Number} [options.wtimeout] sets a [timeout for the write concern](https://www.mongodb.com/docs/manual/reference/write-concern/#wtimeout). Overrides the [schema-level `writeConcern` option](https://mongoosejs.com/docs/guide.html#writeConcern).\n * @param {Boolean} [options.checkKeys=true] the MongoDB driver prevents you from saving keys that start with '$' or contain '.' by default. Set this option to `false` to skip that check. See [restrictions on field names](https://docs.mongodb.com/manual/reference/limits/#mongodb-limit-Restrictions-on-Field-Names)\n * @param {Boolean} [options.timestamps=true] if `false` and [timestamps](https://mongoosejs.com/docs/guide.html#timestamps) are enabled, skip timestamps for this `save()`.\n * @throws {DocumentNotFoundError} if this [save updates an existing document](https://mongoosejs.com/docs/api/document.html#Document.prototype.isNew) but the document doesn't exist in the database. For example, you will get this error if the document is [deleted between when you retrieved the document and when you saved it](documents.html#updating).\n * @return {Promise}\n * @api public\n * @see middleware https://mongoosejs.com/docs/middleware.html\n */\n\nModel.prototype.save = async function save(options) {\n  if (typeof options === 'function' || typeof arguments[1] === 'function') {\n    throw new MongooseError('Model.prototype.save() no longer accepts a callback');\n  }\n\n  let parallelSave;\n  this.$op = 'save';\n\n  if (this.$__.saving) {\n    parallelSave = new ParallelSaveError(this);\n  } else {\n    this.$__.saving = new ParallelSaveError(this);\n  }\n\n  options = new SaveOptions(options);\n  if (options.hasOwnProperty('session')) {\n    this.$session(options.session);\n  }\n  if (this.$__.timestamps != null) {\n    options.timestamps = this.$__.timestamps;\n  }\n  this.$__.$versionError = generateVersionError(this, this.modifiedPaths());\n\n  if (parallelSave) {\n    this.$__handleReject(parallelSave);\n    throw parallelSave;\n  }\n\n  this.$__.saveOptions = options;\n\n  await new Promise((resolve, reject) => {\n    this.$__save(options, error => {\n      this.$__.saving = null;\n      this.$__.saveOptions = null;\n      this.$__.$versionError = null;\n      this.$op = null;\n      if (error != null) {\n        this.$__handleReject(error);\n        return reject(error);\n      }\n\n      resolve();\n    });\n  });\n\n  return this;\n};\n\nModel.prototype.$save = Model.prototype.save;\n\n/**\n * Determines whether versioning should be skipped for the given path\n *\n * @param {Document} self\n * @param {String} path\n * @return {Boolean} true if versioning should be skipped for the given path\n * @api private\n */\nfunction shouldSkipVersioning(self, path) {\n  const skipVersioning = self.$__schema.options.skipVersioning;\n  if (!skipVersioning) return false;\n\n  // Remove any array indexes from the path\n  path = path.replace(/\\.\\d+\\./, '.');\n\n  return skipVersioning[path];\n}\n\n/**\n * Apply the operation to the delta (update) clause as\n * well as track versioning for our where clause.\n *\n * @param {Document} self\n * @param {Object} where Unused\n * @param {Object} delta\n * @param {Object} data\n * @param {Mixed} val\n * @param {String} [op]\n * @api private\n */\n\nfunction operand(self, where, delta, data, val, op) {\n  // delta\n  op || (op = '$set');\n  if (!delta[op]) delta[op] = {};\n  delta[op][data.path] = val;\n  // disabled versioning?\n  if (self.$__schema.options.versionKey === false) return;\n\n  // path excluded from versioning?\n  if (shouldSkipVersioning(self, data.path)) return;\n\n  // already marked for versioning?\n  if (VERSION_ALL === (VERSION_ALL & self.$__.version)) return;\n\n  if (self.$__schema.options.optimisticConcurrency) {\n    return;\n  }\n\n  switch (op) {\n    case '$set':\n    case '$unset':\n    case '$pop':\n    case '$pull':\n    case '$pullAll':\n    case '$push':\n    case '$addToSet':\n    case '$inc':\n      break;\n    default:\n      // nothing to do\n      return;\n  }\n\n  // ensure updates sent with positional notation are\n  // editing the correct array element.\n  // only increment the version if an array position changes.\n  // modifying elements of an array is ok if position does not change.\n  if (op === '$push' || op === '$addToSet' || op === '$pullAll' || op === '$pull') {\n    if (/\\.\\d+\\.|\\.\\d+$/.test(data.path)) {\n      increment.call(self);\n    } else {\n      self.$__.version = VERSION_INC;\n    }\n  } else if (/^\\$p/.test(op)) {\n    // potentially changing array positions\n    increment.call(self);\n  } else if (Array.isArray(val)) {\n    // $set an array\n    increment.call(self);\n  } else if (/\\.\\d+\\.|\\.\\d+$/.test(data.path)) {\n    // now handling $set, $unset\n    // subpath of array\n    self.$__.version = VERSION_WHERE;\n  }\n}\n\n/**\n * Compiles an update and where clause for a `val` with _atomics.\n *\n * @param {Document} self\n * @param {Object} where\n * @param {Object} delta\n * @param {Object} data\n * @param {Array} value\n * @api private\n */\n\nfunction handleAtomics(self, where, delta, data, value) {\n  if (delta.$set && delta.$set[data.path]) {\n    // $set has precedence over other atomics\n    return;\n  }\n\n  if (typeof value.$__getAtomics === 'function') {\n    value.$__getAtomics().forEach(function(atomic) {\n      const op = atomic[0];\n      const val = atomic[1];\n      operand(self, where, delta, data, val, op);\n    });\n    return;\n  }\n\n  // legacy support for plugins\n\n  const atomics = value[arrayAtomicsSymbol];\n  const ops = Object.keys(atomics);\n  let i = ops.length;\n  let val;\n  let op;\n\n  if (i === 0) {\n    // $set\n\n    if (utils.isMongooseObject(value)) {\n      value = value.toObject({ depopulate: 1, _isNested: true });\n    } else if (value.valueOf) {\n      value = value.valueOf();\n    }\n\n    return operand(self, where, delta, data, value);\n  }\n\n  function iter(mem) {\n    return utils.isMongooseObject(mem)\n      ? mem.toObject({ depopulate: 1, _isNested: true })\n      : mem;\n  }\n\n  while (i--) {\n    op = ops[i];\n    val = atomics[op];\n\n    if (utils.isMongooseObject(val)) {\n      val = val.toObject({ depopulate: true, transform: false, _isNested: true });\n    } else if (Array.isArray(val)) {\n      val = val.map(iter);\n    } else if (val.valueOf) {\n      val = val.valueOf();\n    }\n\n    if (op === '$addToSet') {\n      val = { $each: val };\n    }\n\n    operand(self, where, delta, data, val, op);\n  }\n}\n\n/**\n * Produces a special query document of the modified properties used in updates.\n *\n * @api private\n * @method $__delta\n * @memberOf Model\n * @instance\n */\n\nModel.prototype.$__delta = function() {\n  const dirty = this.$__dirty();\n\n  const optimisticConcurrency = this.$__schema.options.optimisticConcurrency;\n  if (optimisticConcurrency) {\n    if (Array.isArray(optimisticConcurrency)) {\n      const optCon = new Set(optimisticConcurrency);\n      const modPaths = this.modifiedPaths();\n      if (modPaths.find(path => optCon.has(path))) {\n        this.$__.version = dirty.length ? VERSION_ALL : VERSION_WHERE;\n      }\n    } else {\n      this.$__.version = dirty.length ? VERSION_ALL : VERSION_WHERE;\n    }\n  }\n\n  if (!dirty.length && VERSION_ALL !== this.$__.version) {\n    return;\n  }\n  const where = {};\n  const delta = {};\n  const len = dirty.length;\n  const divergent = [];\n  let d = 0;\n\n  where._id = this._doc._id;\n  // If `_id` is an object, need to depopulate, but also need to be careful\n  // because `_id` can technically be null (see gh-6406)\n  if ((where && where._id && where._id.$__ || null) != null) {\n    where._id = where._id.toObject({ transform: false, depopulate: true });\n  }\n  for (; d < len; ++d) {\n    const data = dirty[d];\n    let value = data.value;\n    const match = checkDivergentArray(this, data.path, value);\n    if (match) {\n      divergent.push(match);\n      continue;\n    }\n\n    const pop = this.$populated(data.path, true);\n    if (!pop && this.$__.selected) {\n      // If any array was selected using an $elemMatch projection, we alter the path and where clause\n      // NOTE: MongoDB only supports projected $elemMatch on top level array.\n      const pathSplit = data.path.split('.');\n      const top = pathSplit[0];\n      if (this.$__.selected[top] && this.$__.selected[top].$elemMatch) {\n        // If the selected array entry was modified\n        if (pathSplit.length > 1 && pathSplit[1] == 0 && typeof where[top] === 'undefined') {\n          where[top] = this.$__.selected[top];\n          pathSplit[1] = '$';\n          data.path = pathSplit.join('.');\n        }\n        // if the selected array was modified in any other way throw an error\n        else {\n          divergent.push(data.path);\n          continue;\n        }\n      }\n    }\n\n    // If this path is set to default, and either this path or one of\n    // its parents is excluded, don't treat this path as dirty.\n    if (this.$isDefault(data.path) && this.$__.selected) {\n      if (data.path.indexOf('.') === -1 && isPathExcluded(this.$__.selected, data.path)) {\n        continue;\n      }\n\n      const pathsToCheck = parentPaths(data.path);\n      if (pathsToCheck.find(path => isPathExcluded(this.$__.isSelected, path))) {\n        continue;\n      }\n    }\n\n    if (divergent.length) continue;\n    if (value === undefined) {\n      operand(this, where, delta, data, 1, '$unset');\n    } else if (value === null) {\n      operand(this, where, delta, data, null);\n    } else if (utils.isMongooseArray(value) && value.$path() && value[arrayAtomicsSymbol]) {\n      // arrays and other custom types (support plugins etc)\n      handleAtomics(this, where, delta, data, value);\n    } else if (value[MongooseBuffer.pathSymbol] && Buffer.isBuffer(value)) {\n      // MongooseBuffer\n      value = value.toObject();\n      operand(this, where, delta, data, value);\n    } else {\n      if (this.$__.primitiveAtomics && this.$__.primitiveAtomics[data.path] != null) {\n        const val = this.$__.primitiveAtomics[data.path];\n        const op = firstKey(val);\n        operand(this, where, delta, data, val[op], op);\n      } else {\n        value = clone(value, {\n          depopulate: true,\n          transform: false,\n          virtuals: false,\n          getters: false,\n          omitUndefined: true,\n          _isNested: true\n        });\n        operand(this, where, delta, data, value);\n      }\n    }\n  }\n\n  if (divergent.length) {\n    return new DivergentArrayError(divergent);\n  }\n\n  if (this.$__.version) {\n    this.$__version(where, delta);\n  }\n\n  if (Object.keys(delta).length === 0) {\n    return [where, null];\n  }\n\n  return [where, delta];\n};\n\n/**\n * Determine if array was populated with some form of filter and is now\n * being updated in a manner which could overwrite data unintentionally.\n *\n * @see https://github.com/Automattic/mongoose/issues/1334\n * @param {Document} doc\n * @param {String} path\n * @param {Any} array\n * @return {String|undefined}\n * @api private\n */\n\nfunction checkDivergentArray(doc, path, array) {\n  // see if we populated this path\n  const pop = doc.$populated(path, true);\n\n  if (!pop && doc.$__.selected) {\n    // If any array was selected using an $elemMatch projection, we deny the update.\n    // NOTE: MongoDB only supports projected $elemMatch on top level array.\n    const top = path.split('.')[0];\n    if (doc.$__.selected[top + '.$']) {\n      return top;\n    }\n  }\n\n  if (!(pop && utils.isMongooseArray(array))) return;\n\n  // If the array was populated using options that prevented all\n  // documents from being returned (match, skip, limit) or they\n  // deselected the _id field, $pop and $set of the array are\n  // not safe operations. If _id was deselected, we do not know\n  // how to remove elements. $pop will pop off the _id from the end\n  // of the array in the db which is not guaranteed to be the\n  // same as the last element we have here. $set of the entire array\n  // would be similarly destructive as we never received all\n  // elements of the array and potentially would overwrite data.\n  const check = pop.options.match ||\n      pop.options.options && utils.object.hasOwnProperty(pop.options.options, 'limit') || // 0 is not permitted\n      pop.options.options && pop.options.options.skip || // 0 is permitted\n      pop.options.select && // deselected _id?\n      (pop.options.select._id === 0 ||\n      /\\s?-_id\\s?/.test(pop.options.select));\n\n  if (check) {\n    const atomics = array[arrayAtomicsSymbol];\n    if (Object.keys(atomics).length === 0 || atomics.$set || atomics.$pop) {\n      return path;\n    }\n  }\n}\n\n/**\n * Appends versioning to the where and update clauses.\n *\n * @api private\n * @method $__version\n * @memberOf Model\n * @instance\n */\n\nModel.prototype.$__version = function(where, delta) {\n  const key = this.$__schema.options.versionKey;\n  if (where === true) {\n    // this is an insert\n    if (key) {\n      setDottedPath(delta, key, 0);\n      this.$__setValue(key, 0);\n    }\n    return;\n  }\n\n  if (key === false) {\n    return;\n  }\n\n  // updates\n\n  // only apply versioning if our versionKey was selected. else\n  // there is no way to select the correct version. we could fail\n  // fast here and force them to include the versionKey but\n  // thats a bit intrusive. can we do this automatically?\n\n  if (!this.$__isSelected(key)) {\n    return;\n  }\n\n  // $push $addToSet don't need the where clause set\n  if (VERSION_WHERE === (VERSION_WHERE & this.$__.version)) {\n    const value = this.$__getValue(key);\n    if (value != null) where[key] = value;\n  }\n\n  if (VERSION_INC === (VERSION_INC & this.$__.version)) {\n    if (get(delta.$set, key, null) != null) {\n      // Version key is getting set, means we'll increment the doc's version\n      // after a successful save, so we should set the incremented version so\n      // future saves don't fail (gh-5779)\n      ++delta.$set[key];\n    } else {\n      delta.$inc = delta.$inc || {};\n      delta.$inc[key] = 1;\n    }\n  }\n};\n\n/*!\n * ignore\n */\n\nfunction increment() {\n  this.$__.version = VERSION_ALL;\n  return this;\n}\n\n/**\n * Signal that we desire an increment of this documents version.\n *\n * #### Example:\n *\n *     const doc = await Model.findById(id);\n *     doc.increment();\n *     await doc.save();\n *\n * @see versionKeys https://mongoosejs.com/docs/guide.html#versionKey\n * @memberOf Model\n * @method increment\n * @api public\n */\n\nModel.prototype.increment = increment;\n\n/**\n * Returns a query object\n *\n * @api private\n * @method $__where\n * @memberOf Model\n * @instance\n */\n\nModel.prototype.$__where = function _where(where) {\n  where || (where = {});\n\n  if (!where._id) {\n    where._id = this._doc._id;\n  }\n\n  if (this._doc._id === void 0) {\n    return new MongooseError('No _id found on document!');\n  }\n\n  return where;\n};\n\n/**\n * Delete this document from the db.\n *\n * #### Example:\n *\n *     await product.deleteOne();\n *     await Product.findById(product._id); // null\n *\n * @return {Query} Query\n * @api public\n */\n\nModel.prototype.deleteOne = function deleteOne(options) {\n  if (typeof options === 'function' ||\n      typeof arguments[1] === 'function') {\n    throw new MongooseError('Model.prototype.deleteOne() no longer accepts a callback');\n  }\n\n  if (!options) {\n    options = {};\n  }\n\n  if (options.hasOwnProperty('session')) {\n    this.$session(options.session);\n  }\n\n  const self = this;\n  const where = this.$__where();\n  if (where instanceof Error) {\n    throw where;\n  }\n  const query = self.constructor.deleteOne(where, options);\n\n  if (this.$session() != null) {\n    if (!('session' in query.options)) {\n      query.options.session = this.$session();\n    }\n  }\n\n  query.pre(function queryPreDeleteOne(cb) {\n    self.constructor._middleware.execPre('deleteOne', self, [self], cb);\n  });\n  query.pre(function callSubdocPreHooks(cb) {\n    each(self.$getAllSubdocs(), (subdoc, cb) => {\n      subdoc.constructor._middleware.execPre('deleteOne', subdoc, [subdoc], cb);\n    }, cb);\n  });\n  query.pre(function skipIfAlreadyDeleted(cb) {\n    if (self.$__.isDeleted) {\n      return cb(Kareem.skipWrappedFunction());\n    }\n    return cb();\n  });\n  query.post(function callSubdocPostHooks(cb) {\n    each(self.$getAllSubdocs(), (subdoc, cb) => {\n      subdoc.constructor._middleware.execPost('deleteOne', subdoc, [subdoc], {}, cb);\n    }, cb);\n  });\n  query.post(function queryPostDeleteOne(cb) {\n    self.constructor._middleware.execPost('deleteOne', self, [self], {}, cb);\n  });\n\n  return query;\n};\n\n/**\n * Returns the model instance used to create this document if no `name` specified.\n * If `name` specified, returns the model with the given `name`.\n *\n * #### Example:\n *\n *     const doc = new Tank({});\n *     doc.$model() === Tank; // true\n *     await doc.$model('User').findById(id);\n *\n * @param {String} [name] model name\n * @method $model\n * @api public\n * @return {Model}\n */\n\nModel.prototype.$model = function $model(name) {\n  if (arguments.length === 0) {\n    return this.constructor;\n  }\n  return this[modelDbSymbol].model(name);\n};\n\n/**\n * Returns the model instance used to create this document if no `name` specified.\n * If `name` specified, returns the model with the given `name`.\n *\n * #### Example:\n *\n *     const doc = new Tank({});\n *     doc.$model() === Tank; // true\n *     await doc.$model('User').findById(id);\n *\n * @param {String} [name] model name\n * @method model\n * @api public\n * @return {Model}\n */\n\nModel.prototype.model = Model.prototype.$model;\n\n/**\n * Returns a document with `_id` only if at least one document exists in the database that matches\n * the given `filter`, and `null` otherwise.\n *\n * Under the hood, `MyModel.exists({ answer: 42 })` is equivalent to\n * `MyModel.findOne({ answer: 42 }).select({ _id: 1 }).lean()`\n *\n * #### Example:\n *\n *     await Character.deleteMany({});\n *     await Character.create({ name: 'Jean-Luc Picard' });\n *\n *     await Character.exists({ name: /picard/i }); // { _id: ... }\n *     await Character.exists({ name: /riker/i }); // null\n *\n * This function triggers the following middleware.\n *\n * - `findOne()`\n *\n * @param {Object} filter\n * @param {Object} [options] optional see [`Query.prototype.setOptions()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.setOptions())\n * @return {Query}\n */\n\nModel.exists = function exists(filter, options) {\n  _checkContext(this, 'exists');\n  if (typeof arguments[2] === 'function') {\n    throw new MongooseError('Model.exists() no longer accepts a callback');\n  }\n\n  const query = this.findOne(filter).\n    select({ _id: 1 }).\n    lean().\n    setOptions(options);\n\n  return query;\n};\n\n/**\n * Adds a discriminator type.\n *\n * #### Example:\n *\n *     function BaseSchema() {\n *       Schema.apply(this, arguments);\n *\n *       this.add({\n *         name: String,\n *         createdAt: Date\n *       });\n *     }\n *     util.inherits(BaseSchema, Schema);\n *\n *     const PersonSchema = new BaseSchema();\n *     const BossSchema = new BaseSchema({ department: String });\n *\n *     const Person = mongoose.model('Person', PersonSchema);\n *     const Boss = Person.discriminator('Boss', BossSchema);\n *     new Boss().__t; // \"Boss\". `__t` is the default `discriminatorKey`\n *\n *     const employeeSchema = new Schema({ boss: ObjectId });\n *     const Employee = Person.discriminator('Employee', employeeSchema, 'staff');\n *     new Employee().__t; // \"staff\" because of 3rd argument above\n *\n * @param {String} name discriminator model name\n * @param {Schema} schema discriminator model schema\n * @param {Object|String} [options] If string, same as `options.value`.\n * @param {String} [options.value] the string stored in the `discriminatorKey` property. If not specified, Mongoose uses the `name` parameter.\n * @param {Boolean} [options.clone=true] By default, `discriminator()` clones the given `schema`. Set to `false` to skip cloning.\n * @param {Boolean} [options.overwriteModels=false] by default, Mongoose does not allow you to define a discriminator with the same name as another discriminator. Set this to allow overwriting discriminators with the same name.\n * @param {Boolean} [options.mergeHooks=true] By default, Mongoose merges the base schema's hooks with the discriminator schema's hooks. Set this option to `false` to make Mongoose use the discriminator schema's hooks instead.\n * @param {Boolean} [options.mergePlugins=true] By default, Mongoose merges the base schema's plugins with the discriminator schema's plugins. Set this option to `false` to make Mongoose use the discriminator schema's plugins instead.\n * @return {Model} The newly created discriminator model\n * @api public\n */\n\nModel.discriminator = function(name, schema, options) {\n  let model;\n  if (typeof name === 'function') {\n    model = name;\n    name = utils.getFunctionName(model);\n    if (!(model.prototype instanceof Model)) {\n      throw new MongooseError('The provided class ' + name + ' must extend Model');\n    }\n  }\n\n  options = options || {};\n  const value = utils.isPOJO(options) ? options.value : options;\n  const clone = typeof options.clone === 'boolean' ? options.clone : true;\n  const mergePlugins = typeof options.mergePlugins === 'boolean' ? options.mergePlugins : true;\n\n  _checkContext(this, 'discriminator');\n\n  if (utils.isObject(schema) && !schema.instanceOfSchema) {\n    schema = new Schema(schema);\n  }\n  if (schema instanceof Schema && clone) {\n    schema = schema.clone();\n  }\n\n  schema = discriminator(this, name, schema, value, mergePlugins, options.mergeHooks);\n  if (this.db.models[name] && !schema.options.overwriteModels) {\n    throw new OverwriteModelError(name);\n  }\n\n  schema.$isRootDiscriminator = true;\n  schema.$globalPluginsApplied = true;\n\n  model = this.db.model(model || name, schema, this.$__collection.name);\n  this.discriminators[name] = model;\n  const d = this.discriminators[name];\n  Object.setPrototypeOf(d.prototype, this.prototype);\n  Object.defineProperty(d, 'baseModelName', {\n    value: this.modelName,\n    configurable: true,\n    writable: false\n  });\n\n  // apply methods and statics\n  applyMethods(d, schema);\n  applyStatics(d, schema);\n\n  if (this[subclassedSymbol] != null) {\n    for (const submodel of this[subclassedSymbol]) {\n      submodel.discriminators = submodel.discriminators || {};\n      submodel.discriminators[name] =\n        model.__subclass(model.db, schema, submodel.collection.name);\n    }\n  }\n\n  return d;\n};\n\n/**\n * Make sure `this` is a model\n * @api private\n */\n\nfunction _checkContext(ctx, fnName) {\n  // Check context, because it is easy to mistakenly type\n  // `new Model.discriminator()` and get an incomprehensible error\n  if (ctx == null || ctx === global) {\n    throw new MongooseError('`Model.' + fnName + '()` cannot run without a ' +\n      'model as `this`. Make sure you are calling `MyModel.' + fnName + '()` ' +\n      'where `MyModel` is a Mongoose model.');\n  } else if (ctx[modelSymbol] == null) {\n    throw new MongooseError('`Model.' + fnName + '()` cannot run without a ' +\n      'model as `this`. Make sure you are not calling ' +\n      '`new Model.' + fnName + '()`');\n  }\n}\n\n// Model (class) features\n\n/*!\n * Give the constructor the ability to emit events.\n */\n\nfor (const i in EventEmitter.prototype) {\n  Model[i] = EventEmitter.prototype[i];\n}\n\n/**\n * This function is responsible for initializing the underlying connection in MongoDB based on schema options.\n * This function performs the following operations:\n *\n * - `createCollection()` unless [`autoCreate`](https://mongoosejs.com/docs/guide.html#autoCreate) option is turned off\n * - `ensureIndexes()` unless [`autoIndex`](https://mongoosejs.com/docs/guide.html#autoIndex) option is turned off\n * - `createSearchIndex()` on all schema search indexes if `autoSearchIndex` is enabled.\n *\n * Mongoose calls this function automatically when a model is a created using\n * [`mongoose.model()`](https://mongoosejs.com/docs/api/mongoose.html#Mongoose.prototype.model()) or\n * [`connection.model()`](https://mongoosejs.com/docs/api/connection.html#Connection.prototype.model()), so you\n * don't need to call `init()` to trigger index builds.\n *\n * However, you _may_ need to call `init()`  to get back a promise that will resolve when your indexes are finished.\n * Calling `await Model.init()` is helpful if you need to wait for indexes to build before continuing.\n * For example, if you want to wait for unique indexes to build before continuing with a test case.\n *\n * #### Example:\n *\n *     const eventSchema = new Schema({ thing: { type: 'string', unique: true } })\n *     // This calls `Event.init()` implicitly, so you don't need to call\n *     // `Event.init()` on your own.\n *     const Event = mongoose.model('Event', eventSchema);\n *\n *     await Event.init();\n *     console.log('Indexes are done building!');\n *\n * @api public\n * @returns {Promise}\n */\n\nModel.init = function init() {\n  _checkContext(this, 'init');\n  if (typeof arguments[0] === 'function') {\n    throw new MongooseError('Model.init() no longer accepts a callback');\n  }\n\n  this.schema.emit('init', this);\n\n  if (this.$init != null) {\n    return this.$init;\n  }\n\n  const conn = this.db;\n  const _ensureIndexes = async() => {\n    const autoIndex = utils.getOption(\n      'autoIndex',\n      this.schema.options,\n      conn.config,\n      conn.base.options\n    );\n    if (!autoIndex) {\n      return;\n    }\n    return await this.ensureIndexes({ _automatic: true });\n  };\n  const _createSearchIndexes = async() => {\n    const autoSearchIndex = utils.getOption(\n      'autoSearchIndex',\n      this.schema.options,\n      conn.config,\n      conn.base.options\n    );\n    if (!autoSearchIndex) {\n      return;\n    }\n\n    const results = [];\n    for (const searchIndex of this.schema._searchIndexes) {\n      results.push(await this.createSearchIndex(searchIndex));\n    }\n    return results;\n  };\n  const _createCollection = async() => {\n    if ((conn.readyState === STATES.connecting || conn.readyState === STATES.disconnected) && conn._shouldBufferCommands()) {\n      await new Promise(resolve => {\n        conn._queue.push({ fn: resolve });\n      });\n    }\n    const autoCreate = utils.getOption(\n      'autoCreate',\n      this.schema.options,\n      conn.config,\n      conn.base.options\n    );\n    if (!autoCreate) {\n      return;\n    }\n    return await this.createCollection();\n  };\n\n  this.$init = _createCollection().\n    then(() => _ensureIndexes()).\n    then(() => _createSearchIndexes());\n\n  const _catch = this.$init.catch;\n  const _this = this;\n  this.$init.catch = function() {\n    _this.$caught = true;\n    return _catch.apply(_this.$init, arguments);\n  };\n\n  return this.$init;\n};\n\n\n/**\n * Create the collection for this model. By default, if no indexes are specified,\n * mongoose will not create the collection for the model until any documents are\n * created. Use this method to create the collection explicitly.\n *\n * Note 1: You may need to call this before starting a transaction\n * See https://www.mongodb.com/docs/manual/core/transactions/#transactions-and-operations\n *\n * Note 2: You don't have to call this if your schema contains index or unique field.\n * In that case, just use `Model.init()`\n *\n * #### Example:\n *\n *     const userSchema = new Schema({ name: String })\n *     const User = mongoose.model('User', userSchema);\n *\n *     User.createCollection().then(function(collection) {\n *       console.log('Collection is created!');\n *     });\n *\n * @api public\n * @param {Object} [options] see [MongoDB driver docs](https://mongodb.github.io/node-mongodb-native/4.9/classes/Db.html#createCollection)\n * @returns {Promise}\n */\n\nModel.createCollection = async function createCollection(options) {\n  _checkContext(this, 'createCollection');\n  if (typeof arguments[0] === 'function' || typeof arguments[1] === 'function') {\n    throw new MongooseError('Model.createCollection() no longer accepts a callback');\n  }\n\n  const shouldSkip = await new Promise((resolve, reject) => {\n    this.hooks.execPre('createCollection', this, [options], (err) => {\n      if (err != null) {\n        if (err instanceof Kareem.skipWrappedFunction) {\n          return resolve(true);\n        }\n        return reject(err);\n      }\n      resolve();\n    });\n  });\n\n  const collectionOptions = this &&\n    this.schema &&\n    this.schema.options &&\n    this.schema.options.collectionOptions;\n  if (collectionOptions != null) {\n    options = Object.assign({}, collectionOptions, options);\n  }\n\n  const schemaCollation = this &&\n    this.schema &&\n    this.schema.options &&\n    this.schema.options.collation;\n  if (schemaCollation != null) {\n    options = Object.assign({ collation: schemaCollation }, options);\n  }\n  const capped = this &&\n    this.schema &&\n    this.schema.options &&\n    this.schema.options.capped;\n  if (capped != null) {\n    if (typeof capped === 'number') {\n      options = Object.assign({ capped: true, size: capped }, options);\n    } else if (typeof capped === 'object') {\n      options = Object.assign({ capped: true }, capped, options);\n    }\n  }\n  const timeseries = this &&\n    this.schema &&\n    this.schema.options &&\n    this.schema.options.timeseries;\n  if (timeseries != null) {\n    options = Object.assign({ timeseries }, options);\n    if (options.expireAfterSeconds != null) {\n      // do nothing\n    } else if (options.expires != null) {\n      utils.expires(options);\n    } else if (this.schema.options.expireAfterSeconds != null) {\n      options.expireAfterSeconds = this.schema.options.expireAfterSeconds;\n    } else if (this.schema.options.expires != null) {\n      options.expires = this.schema.options.expires;\n      utils.expires(options);\n    }\n  }\n\n  const clusteredIndex = this &&\n    this.schema &&\n    this.schema.options &&\n    this.schema.options.clusteredIndex;\n  if (clusteredIndex != null) {\n    options = Object.assign({ clusteredIndex: { ...clusteredIndex, unique: true } }, options);\n  }\n\n  try {\n    if (!shouldSkip) {\n      await this.db.createCollection(this.$__collection.collectionName, options);\n    }\n  } catch (err) {\n    if (err != null && (err.name !== 'MongoServerError' || err.code !== 48)) {\n      await new Promise((resolve, reject) => {\n        const _opts = { error: err };\n        this.hooks.execPost('createCollection', this, [null], _opts, (err) => {\n          if (err != null) {\n            return reject(err);\n          }\n          resolve();\n        });\n      });\n    }\n  }\n\n  await new Promise((resolve, reject) => {\n    this.hooks.execPost('createCollection', this, [this.$__collection], (err) => {\n      if (err != null) {\n        return reject(err);\n      }\n      resolve();\n    });\n  });\n\n  return this.$__collection;\n};\n\n/**\n * Makes the indexes in MongoDB match the indexes defined in this model's\n * schema. This function will drop any indexes that are not defined in\n * the model's schema except the `_id` index, and build any indexes that\n * are in your schema but not in MongoDB.\n *\n * See the [introductory blog post](https://thecodebarbarian.com/whats-new-in-mongoose-5-2-syncindexes)\n * for more information.\n *\n * #### Example:\n *\n *     const schema = new Schema({ name: { type: String, unique: true } });\n *     const Customer = mongoose.model('Customer', schema);\n *     await Customer.collection.createIndex({ age: 1 }); // Index is not in schema\n *     // Will drop the 'age' index and create an index on `name`\n *     await Customer.syncIndexes();\n *\n * You should be careful about running `syncIndexes()` on production applications under heavy load,\n * because index builds are expensive operations, and unexpected index drops can lead to degraded\n * performance. Before running `syncIndexes()`, you can use the [`diffIndexes()` function](#Model.diffIndexes())\n * to check what indexes `syncIndexes()` will drop and create.\n *\n * #### Example:\n *\n *     const { toDrop, toCreate } = await Model.diffIndexes();\n *     toDrop; // Array of strings containing names of indexes that `syncIndexes()` will drop\n *     toCreate; // Array of strings containing names of indexes that `syncIndexes()` will create\n *\n * @param {Object} [options] options to pass to `ensureIndexes()`\n * @param {Boolean} [options.background=null] if specified, overrides each index's `background` property\n * @return {Promise}\n * @api public\n */\n\nModel.syncIndexes = async function syncIndexes(options) {\n  _checkContext(this, 'syncIndexes');\n  if (typeof arguments[0] === 'function' || typeof arguments[1] === 'function') {\n    throw new MongooseError('Model.syncIndexes() no longer accepts a callback');\n  }\n\n  const model = this;\n\n  try {\n    await model.createCollection();\n  } catch (err) {\n    if (err != null && (err.name !== 'MongoServerError' || err.code !== 48)) {\n      throw err;\n    }\n  }\n\n  const diffIndexesResult = await model.diffIndexes();\n  const dropped = await model.cleanIndexes({ ...options, toDrop: diffIndexesResult.toDrop });\n  await model.createIndexes({ ...options, toCreate: diffIndexesResult.toCreate });\n\n  return dropped;\n};\n\n/**\n * Create an [Atlas search index](https://www.mongodb.com/docs/atlas/atlas-search/create-index/).\n * This function only works when connected to MongoDB Atlas.\n *\n * #### Example:\n *\n *     const schema = new Schema({ name: { type: String, unique: true } });\n *     const Customer = mongoose.model('Customer', schema);\n *     await Customer.createSearchIndex({ name: 'test', definition: { mappings: { dynamic: true } } });\n *\n * @param {Object} description index options, including `name` and `definition`\n * @param {String} description.name\n * @param {Object} description.definition\n * @return {Promise}\n * @api public\n */\n\nModel.createSearchIndex = async function createSearchIndex(description) {\n  _checkContext(this, 'createSearchIndex');\n\n  return await this.$__collection.createSearchIndex(description);\n};\n\n/**\n * Update an existing [Atlas search index](https://www.mongodb.com/docs/atlas/atlas-search/create-index/).\n * This function only works when connected to MongoDB Atlas.\n *\n * #### Example:\n *\n *     const schema = new Schema({ name: { type: String, unique: true } });\n *     const Customer = mongoose.model('Customer', schema);\n *     await Customer.updateSearchIndex('test', { mappings: { dynamic: true } });\n *\n * @param {String} name\n * @param {Object} definition\n * @return {Promise}\n * @api public\n */\n\nModel.updateSearchIndex = async function updateSearchIndex(name, definition) {\n  _checkContext(this, 'updateSearchIndex');\n\n  return await this.$__collection.updateSearchIndex(name, definition);\n};\n\n/**\n * Delete an existing [Atlas search index](https://www.mongodb.com/docs/atlas/atlas-search/create-index/) by name.\n * This function only works when connected to MongoDB Atlas.\n *\n * #### Example:\n *\n *     const schema = new Schema({ name: { type: String, unique: true } });\n *     const Customer = mongoose.model('Customer', schema);\n *     await Customer.dropSearchIndex('test');\n *\n * @param {String} name\n * @return {Promise}\n * @api public\n */\n\nModel.dropSearchIndex = async function dropSearchIndex(name) {\n  _checkContext(this, 'dropSearchIndex');\n\n  return await this.$__collection.dropSearchIndex(name);\n};\n\n/**\n * Does a dry-run of `Model.syncIndexes()`, returning the indexes that `syncIndexes()` would drop and create if you were to run `syncIndexes()`.\n *\n * #### Example:\n *\n *     const { toDrop, toCreate } = await Model.diffIndexes();\n *     toDrop; // Array of strings containing names of indexes that `syncIndexes()` will drop\n *     toCreate; // Array of strings containing names of indexes that `syncIndexes()` will create\n *\n * @param {Object} [options]\n * @return {Promise<Object>} contains the indexes that would be dropped in MongoDB and indexes that would be created in MongoDB as `{ toDrop: string[], toCreate: string[] }`.\n */\n\nModel.diffIndexes = async function diffIndexes() {\n  if (typeof arguments[0] === 'function' || typeof arguments[1] === 'function') {\n    throw new MongooseError('Model.syncIndexes() no longer accepts a callback');\n  }\n\n  const model = this;\n\n  let dbIndexes = await model.listIndexes().catch(err => {\n    if (err.codeName == 'NamespaceNotFound') {\n      return undefined;\n    }\n    throw err;\n  });\n  if (dbIndexes === undefined) {\n    dbIndexes = [];\n  }\n  dbIndexes = getRelatedDBIndexes(model, dbIndexes);\n\n  const schema = model.schema;\n  const schemaIndexes = getRelatedSchemaIndexes(model, schema.indexes());\n\n  const toDrop = getIndexesToDrop(schema, schemaIndexes, dbIndexes);\n  const toCreate = getIndexesToCreate(schema, schemaIndexes, dbIndexes, toDrop);\n\n  return { toDrop, toCreate };\n};\n\nfunction getIndexesToCreate(schema, schemaIndexes, dbIndexes, toDrop) {\n  const toCreate = [];\n\n  for (const [schemaIndexKeysObject, schemaIndexOptions] of schemaIndexes) {\n    let found = false;\n\n    const options = decorateDiscriminatorIndexOptions(schema, clone(schemaIndexOptions));\n\n    for (const index of dbIndexes) {\n      if (isDefaultIdIndex(index)) {\n        continue;\n      }\n      if (\n        isIndexEqual(schemaIndexKeysObject, options, index) &&\n        !toDrop.includes(index.name)\n      ) {\n        found = true;\n        break;\n      }\n    }\n\n    if (!found) {\n      toCreate.push(schemaIndexKeysObject);\n    }\n  }\n\n  return toCreate;\n}\n\nfunction getIndexesToDrop(schema, schemaIndexes, dbIndexes) {\n  const toDrop = [];\n\n  for (const dbIndex of dbIndexes) {\n    let found = false;\n    // Never try to drop `_id` index, MongoDB server doesn't allow it\n    if (isDefaultIdIndex(dbIndex)) {\n      continue;\n    }\n\n    for (const [schemaIndexKeysObject, schemaIndexOptions] of schemaIndexes) {\n      const options = decorateDiscriminatorIndexOptions(schema, clone(schemaIndexOptions));\n      applySchemaCollation(schemaIndexKeysObject, options, schema.options);\n\n      if (isIndexEqual(schemaIndexKeysObject, options, dbIndex)) {\n        found = true;\n        break;\n      }\n    }\n\n    if (!found) {\n      toDrop.push(dbIndex.name);\n    }\n  }\n\n  return toDrop;\n}\n/**\n * Deletes all indexes that aren't defined in this model's schema. Used by\n * `syncIndexes()`.\n *\n * The returned promise resolves to a list of the dropped indexes' names as an array\n *\n * @param {Function} [callback] optional callback\n * @return {Promise|undefined} Returns `undefined` if callback is specified, returns a promise if no callback.\n * @api public\n */\n\nModel.cleanIndexes = async function cleanIndexes(options) {\n  _checkContext(this, 'cleanIndexes');\n  if (typeof arguments[0] === 'function' || typeof arguments[1] === 'function') {\n    throw new MongooseError('Model.cleanIndexes() no longer accepts a callback');\n  }\n  const model = this;\n\n  const collection = model.$__collection;\n\n  if (Array.isArray(options && options.toDrop)) {\n    const res = await _dropIndexes(options.toDrop, collection);\n    return res;\n  }\n\n  const res = await model.diffIndexes();\n  return await _dropIndexes(res.toDrop, collection);\n};\n\nasync function _dropIndexes(toDrop, collection) {\n  if (toDrop.length === 0) {\n    return [];\n  }\n\n  await Promise.all(toDrop.map(indexName => collection.dropIndex(indexName)));\n  return toDrop;\n}\n\n/**\n * Lists the indexes currently defined in MongoDB. This may or may not be\n * the same as the indexes defined in your schema depending on whether you\n * use the [`autoIndex` option](https://mongoosejs.com/docs/guide.html#autoIndex) and if you\n * build indexes manually.\n *\n * @return {Promise}\n * @api public\n */\n\nModel.listIndexes = async function listIndexes() {\n  _checkContext(this, 'listIndexes');\n  if (typeof arguments[0] === 'function') {\n    throw new MongooseError('Model.listIndexes() no longer accepts a callback');\n  }\n\n  if (this.$__collection.buffer) {\n    await new Promise(resolve => {\n      this.$__collection.addQueue(resolve);\n    });\n  }\n\n  return this.$__collection.listIndexes().toArray();\n};\n\n/**\n * Sends `createIndex` commands to mongo for each index declared in the schema.\n * The `createIndex` commands are sent in series.\n *\n * #### Example:\n *\n *     await Event.ensureIndexes();\n *\n * After completion, an `index` event is emitted on this `Model` passing an error if one occurred.\n *\n * #### Example:\n *\n *     const eventSchema = new Schema({ thing: { type: 'string', unique: true } })\n *     const Event = mongoose.model('Event', eventSchema);\n *\n *     Event.on('index', function (err) {\n *       if (err) console.error(err); // error occurred during index creation\n *     });\n *\n * _NOTE: It is not recommended that you run this in production. Index creation may impact database performance depending on your load. Use with caution._\n *\n * @param {Object} [options] internal options\n * @return {Promise}\n * @api public\n */\n\nModel.ensureIndexes = async function ensureIndexes(options) {\n  _checkContext(this, 'ensureIndexes');\n  if (typeof arguments[0] === 'function' || typeof arguments[1] === 'function') {\n    throw new MongooseError('Model.ensureIndexes() no longer accepts a callback');\n  }\n\n  await new Promise((resolve, reject) => {\n    _ensureIndexes(this, options, (err) => {\n      if (err != null) {\n        return reject(err);\n      }\n      resolve();\n    });\n  });\n};\n\n/**\n * Similar to `ensureIndexes()`, except for it uses the [`createIndex`](https://mongodb.github.io/node-mongodb-native/4.9/classes/Db.html#createIndex)\n * function.\n *\n * @param {Object} [options] internal options\n * @return {Promise}\n * @api public\n */\n\nModel.createIndexes = async function createIndexes(options) {\n  _checkContext(this, 'createIndexes');\n\n  if (typeof arguments[0] === 'function' || typeof arguments[1] === 'function') {\n    throw new MongooseError('Model.createIndexes() no longer accepts a callback');\n  }\n\n  return this.ensureIndexes(options);\n};\n\n\n/*!\n * ignore\n */\n\nfunction _ensureIndexes(model, options, callback) {\n  const indexes = model.schema.indexes();\n  let indexError;\n\n  options = options || {};\n  const done = function(err) {\n    if (err && !model.$caught) {\n      model.emit('error', err);\n    }\n    model.emit('index', err || indexError);\n    callback && callback(err || indexError);\n  };\n\n  for (const index of indexes) {\n    if (isDefaultIdIndex(index)) {\n      utils.warn('mongoose: Cannot specify a custom index on `_id` for ' +\n        'model name \"' + model.modelName + '\", ' +\n        'MongoDB does not allow overwriting the default `_id` index. See ' +\n        'https://bit.ly/mongodb-id-index');\n    }\n  }\n\n  if (!indexes.length) {\n    immediate(function() {\n      done();\n    });\n    return;\n  }\n  // Indexes are created one-by-one to support how MongoDB < 2.4 deals\n  // with background indexes.\n\n  const indexSingleDone = function(err, fields, options, name) {\n    model.emit('index-single-done', err, fields, options, name);\n  };\n  const indexSingleStart = function(fields, options) {\n    model.emit('index-single-start', fields, options);\n  };\n\n  const baseSchema = model.schema._baseSchema;\n  const baseSchemaIndexes = baseSchema ? baseSchema.indexes() : [];\n\n  immediate(function() {\n    // If buffering is off, do this manually.\n    if (options._automatic && !model.collection.collection) {\n      model.collection.addQueue(create, []);\n    } else {\n      create();\n    }\n  });\n\n\n  function create() {\n    if (options._automatic) {\n      if (model.schema.options.autoIndex === false ||\n          (model.schema.options.autoIndex == null && model.db.config.autoIndex === false)) {\n        return done();\n      }\n    }\n\n    const index = indexes.shift();\n    if (!index) {\n      return done();\n    }\n    if (options._automatic && index[1]._autoIndex === false) {\n      return create();\n    }\n\n    if (baseSchemaIndexes.find(i => utils.deepEqual(i, index))) {\n      return create();\n    }\n\n    const indexFields = clone(index[0]);\n    const indexOptions = clone(index[1]);\n\n    delete indexOptions._autoIndex;\n    decorateDiscriminatorIndexOptions(model.schema, indexOptions);\n    applyWriteConcern(model.schema, indexOptions);\n    applySchemaCollation(indexFields, indexOptions, model.schema.options);\n\n    indexSingleStart(indexFields, options);\n\n    if ('background' in options) {\n      indexOptions.background = options.background;\n    }\n\n    if ('toCreate' in options) {\n      if (options.toCreate.length === 0) {\n        return done();\n      }\n    }\n\n    model.collection.createIndex(indexFields, indexOptions).then(\n      name => {\n        indexSingleDone(null, indexFields, indexOptions, name);\n        create();\n      },\n      err => {\n        if (!indexError) {\n          indexError = err;\n        }\n        if (!model.$caught) {\n          model.emit('error', err);\n        }\n\n        indexSingleDone(err, indexFields, indexOptions);\n        create();\n      }\n    );\n  }\n}\n\n/**\n * Schema the model uses.\n *\n * @property schema\n * @static\n * @api public\n * @memberOf Model\n */\n\nModel.schema;\n\n/**\n * Connection instance the model uses.\n *\n * @property db\n * @static\n * @api public\n * @memberOf Model\n */\n\nModel.db;\n\n/**\n * Collection the model uses.\n *\n * @property collection\n * @api public\n * @memberOf Model\n */\n\nModel.collection;\n\n/**\n * Internal collection the model uses.\n *\n * @property collection\n * @api private\n * @memberOf Model\n */\nModel.$__collection;\n\n/**\n * Base Mongoose instance the model uses.\n *\n * @property base\n * @api public\n * @memberOf Model\n */\n\nModel.base;\n\n/**\n * Registered discriminators for this model.\n *\n * @property discriminators\n * @api public\n * @memberOf Model\n */\n\nModel.discriminators;\n\n/**\n * Translate any aliases fields/conditions so the final query or document object is pure\n *\n * #### Example:\n *\n *     await Character.find(Character.translateAliases({\n *        '': 'Eddard Stark' // Alias for 'name'\n *     });\n *\n * By default, `translateAliases()` overwrites raw fields with aliased fields.\n * So if `n` is an alias for `name`, `{ n: 'alias', name: 'raw' }` will resolve to `{ name: 'alias' }`.\n * However, you can set the `errorOnDuplicates` option to throw an error if there are potentially conflicting paths.\n * The `translateAliases` option for queries uses `errorOnDuplicates`.\n *\n * #### Note:\n *\n * Only translate arguments of object type anything else is returned raw\n *\n * @param {Object} fields fields/conditions that may contain aliased keys\n * @param {Boolean} [errorOnDuplicates] if true, throw an error if there's both a key and an alias for that key in `fields`\n * @return {Object} the translated 'pure' fields/conditions\n */\nModel.translateAliases = function translateAliases(fields, errorOnDuplicates) {\n  _checkContext(this, 'translateAliases');\n\n  const translate = (key, value) => {\n    let alias;\n    const translated = [];\n    const fieldKeys = key.split('.');\n    let currentSchema = this.schema;\n    for (const i in fieldKeys) {\n      const name = fieldKeys[i];\n      if (currentSchema && currentSchema.aliases[name]) {\n        alias = currentSchema.aliases[name];\n        if (errorOnDuplicates && alias in fields) {\n          throw new MongooseError(`Provided object has both field \"${name}\" and its alias \"${alias}\"`);\n        }\n        // Alias found,\n        translated.push(alias);\n      } else {\n        alias = name;\n        // Alias not found, so treat as un-aliased key\n        translated.push(name);\n      }\n\n      // Check if aliased path is a schema\n      if (currentSchema && currentSchema.paths[alias]) {\n        currentSchema = currentSchema.paths[alias].schema;\n      }\n      else\n        currentSchema = null;\n    }\n\n    const translatedKey = translated.join('.');\n    if (fields instanceof Map)\n      fields.set(translatedKey, value);\n    else\n      fields[translatedKey] = value;\n\n    if (translatedKey !== key) {\n      // We'll be using the translated key instead\n      if (fields instanceof Map) {\n        // Delete from map\n        fields.delete(key);\n      } else {\n        // Delete from object\n        delete fields[key]; // We'll be using the translated key instead\n      }\n    }\n    return fields;\n  };\n\n  if (typeof fields === 'object') {\n    // Fields is an object (query conditions or document fields)\n    if (fields instanceof Map) {\n      // A Map was supplied\n      for (const field of new Map(fields)) {\n        fields = translate(field[0], field[1]);\n      }\n    } else {\n      // Infer a regular object was supplied\n      for (const key of Object.keys(fields)) {\n        fields = translate(key, fields[key]);\n        if (key[0] === '$') {\n          if (Array.isArray(fields[key])) {\n            for (const i in fields[key]) {\n              // Recursively translate nested queries\n              fields[key][i] = this.translateAliases(fields[key][i]);\n            }\n          } else {\n            this.translateAliases(fields[key]);\n          }\n        }\n      }\n    }\n\n    return fields;\n  } else {\n    // Don't know typeof fields\n    return fields;\n  }\n};\n\n/**\n * Deletes the first document that matches `conditions` from the collection.\n * It returns an object with the property `deletedCount` indicating how many documents were deleted.\n * Behaves like `remove()`, but deletes at most one document regardless of the\n * `single` option.\n *\n * #### Example:\n *\n *     await Character.deleteOne({ name: 'Eddard Stark' }); // returns {deletedCount: 1}\n *\n * #### Note:\n *\n * This function triggers `deleteOne` query hooks. Read the\n * [middleware docs](https://mongoosejs.com/docs/middleware.html#naming) to learn more.\n *\n * @param {Object} conditions\n * @param {Object} [options] optional see [`Query.prototype.setOptions()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.setOptions())\n * @param {Boolean} [options.translateAliases=null] If set to `true`, translates any schema-defined aliases in `filter`, `projection`, `update`, and `distinct`. Throws an error if there are any conflicts where both alias and raw property are defined on the same object.\n * @return {Query}\n * @api public\n */\n\nModel.deleteOne = function deleteOne(conditions, options) {\n  _checkContext(this, 'deleteOne');\n\n  if (typeof arguments[0] === 'function' || typeof arguments[1] === 'function' || typeof arguments[2] === 'function') {\n    throw new MongooseError('Model.prototype.deleteOne() no longer accepts a callback');\n  }\n\n  const mq = new this.Query({}, {}, this, this.$__collection);\n  mq.setOptions(options);\n\n  return mq.deleteOne(conditions);\n};\n\n/**\n * Deletes all of the documents that match `conditions` from the collection.\n * It returns an object with the property `deletedCount` containing the number of documents deleted.\n * Behaves like `remove()`, but deletes all documents that match `conditions`\n * regardless of the `single` option.\n *\n * #### Example:\n *\n *     await Character.deleteMany({ name: /Stark/, age: { $gte: 18 } }); // returns {deletedCount: x} where x is the number of documents deleted.\n *\n * #### Note:\n *\n * This function triggers `deleteMany` query hooks. Read the\n * [middleware docs](https://mongoosejs.com/docs/middleware.html#naming) to learn more.\n *\n * @param {Object} conditions\n * @param {Object} [options] optional see [`Query.prototype.setOptions()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.setOptions())\n * @param {Boolean} [options.translateAliases=null] If set to `true`, translates any schema-defined aliases in `filter`, `projection`, `update`, and `distinct`. Throws an error if there are any conflicts where both alias and raw property are defined on the same object.\n * @return {Query}\n * @api public\n */\n\nModel.deleteMany = function deleteMany(conditions, options) {\n  _checkContext(this, 'deleteMany');\n\n  if (typeof arguments[0] === 'function' || typeof arguments[1] === 'function' || typeof arguments[2] === 'function') {\n    throw new MongooseError('Model.deleteMany() no longer accepts a callback');\n  }\n\n  const mq = new this.Query({}, {}, this, this.$__collection);\n  mq.setOptions(options);\n\n  return mq.deleteMany(conditions);\n};\n\n/**\n * Finds documents.\n *\n * Mongoose casts the `filter` to match the model's schema before the command is sent.\n * See our [query casting tutorial](https://mongoosejs.com/docs/tutorials/query_casting.html) for\n * more information on how Mongoose casts `filter`.\n *\n * #### Example:\n *\n *     // find all documents\n *     await MyModel.find({});\n *\n *     // find all documents named john and at least 18\n *     await MyModel.find({ name: 'john', age: { $gte: 18 } }).exec();\n *\n *     // executes, name LIKE john and only selecting the \"name\" and \"friends\" fields\n *     await MyModel.find({ name: /john/i }, 'name friends').exec();\n *\n *     // passing options\n *     await MyModel.find({ name: /john/i }, null, { skip: 10 }).exec();\n *\n * @param {Object|ObjectId} filter\n * @param {Object|String|String[]} [projection] optional fields to return, see [`Query.prototype.select()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.select())\n * @param {Object} [options] optional see [`Query.prototype.setOptions()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.setOptions())\n * @param {Boolean} [options.translateAliases=null] If set to `true`, translates any schema-defined aliases in `filter`, `projection`, `update`, and `distinct`. Throws an error if there are any conflicts where both alias and raw property are defined on the same object.\n * @return {Query}\n * @see field selection https://mongoosejs.com/docs/api/query.html#Query.prototype.select()\n * @see query casting https://mongoosejs.com/docs/tutorials/query_casting.html\n * @api public\n */\n\nModel.find = function find(conditions, projection, options) {\n  _checkContext(this, 'find');\n  if (typeof arguments[0] === 'function' || typeof arguments[1] === 'function' || typeof arguments[2] === 'function' || typeof arguments[3] === 'function') {\n    throw new MongooseError('Model.find() no longer accepts a callback');\n  }\n\n  const mq = new this.Query({}, {}, this, this.$__collection);\n  mq.select(projection);\n  mq.setOptions(options);\n\n  return mq.find(conditions);\n};\n\n/**\n * Finds a single document by its _id field. `findById(id)` is almost*\n * equivalent to `findOne({ _id: id })`. If you want to query by a document's\n * `_id`, use `findById()` instead of `findOne()`.\n *\n * The `id` is cast based on the Schema before sending the command.\n *\n * This function triggers the following middleware.\n *\n * - `findOne()`\n *\n * \\* Except for how it treats `undefined`. If you use `findOne()`, you'll see\n * that `findOne(undefined)` and `findOne({ _id: undefined })` are equivalent\n * to `findOne({})` and return arbitrary documents. However, mongoose\n * translates `findById(undefined)` into `findOne({ _id: null })`.\n *\n * #### Example:\n *\n *     // Find the adventure with the given `id`, or `null` if not found\n *     await Adventure.findById(id).exec();\n *\n *     // select only the adventures name and length\n *     await Adventure.findById(id, 'name length').exec();\n *\n * @param {Any} id value of `_id` to query by\n * @param {Object|String|String[]} [projection] optional fields to return, see [`Query.prototype.select()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.select())\n * @param {Object} [options] optional see [`Query.prototype.setOptions()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.setOptions())\n * @return {Query}\n * @see field selection https://mongoosejs.com/docs/api/query.html#Query.prototype.select()\n * @see lean queries https://mongoosejs.com/docs/tutorials/lean.html\n * @see findById in Mongoose https://masteringjs.io/tutorials/mongoose/find-by-id\n * @api public\n */\n\nModel.findById = function findById(id, projection, options) {\n  _checkContext(this, 'findById');\n  if (typeof arguments[0] === 'function' || typeof arguments[1] === 'function' || typeof arguments[2] === 'function') {\n    throw new MongooseError('Model.findById() no longer accepts a callback');\n  }\n\n  if (typeof id === 'undefined') {\n    id = null;\n  }\n\n  return this.findOne({ _id: id }, projection, options);\n};\n\n/**\n * Finds one document.\n *\n * The `conditions` are cast to their respective SchemaTypes before the command is sent.\n *\n * *Note:* `conditions` is optional, and if `conditions` is null or undefined,\n * mongoose will send an empty `findOne` command to MongoDB, which will return\n * an arbitrary document. If you're querying by `_id`, use `findById()` instead.\n *\n * #### Example:\n *\n *     // Find one adventure whose `country` is 'Croatia', otherwise `null`\n *     await Adventure.findOne({ country: 'Croatia' }).exec();\n *\n *     // Model.findOne() no longer accepts a callback\n *\n *     // Select only the adventures name and length\n *     await Adventure.findOne({ country: 'Croatia' }, 'name length').exec();\n *\n * @param {Object} [conditions]\n * @param {Object|String|String[]} [projection] optional fields to return, see [`Query.prototype.select()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.select())\n * @param {Object} [options] optional see [`Query.prototype.setOptions()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.setOptions())\n * @param {Boolean} [options.translateAliases=null] If set to `true`, translates any schema-defined aliases in `filter`, `projection`, `update`, and `distinct`. Throws an error if there are any conflicts where both alias and raw property are defined on the same object.\n * @return {Query}\n * @see field selection https://mongoosejs.com/docs/api/query.html#Query.prototype.select()\n * @see lean queries https://mongoosejs.com/docs/tutorials/lean.html\n * @api public\n */\n\nModel.findOne = function findOne(conditions, projection, options) {\n  _checkContext(this, 'findOne');\n  if (typeof arguments[0] === 'function' || typeof arguments[1] === 'function' || typeof arguments[2] === 'function') {\n    throw new MongooseError('Model.findOne() no longer accepts a callback');\n  }\n\n  const mq = new this.Query({}, {}, this, this.$__collection);\n  mq.select(projection);\n  mq.setOptions(options);\n\n  return mq.findOne(conditions);\n};\n\n/**\n * Estimates the number of documents in the MongoDB collection. Faster than\n * using `countDocuments()` for large collections because\n * `estimatedDocumentCount()` uses collection metadata rather than scanning\n * the entire collection.\n *\n * #### Example:\n *\n *     const numAdventures = await Adventure.estimatedDocumentCount();\n *\n * @param {Object} [options]\n * @return {Query}\n * @api public\n */\n\nModel.estimatedDocumentCount = function estimatedDocumentCount(options) {\n  _checkContext(this, 'estimatedDocumentCount');\n\n  const mq = new this.Query({}, {}, this, this.$__collection);\n\n  return mq.estimatedDocumentCount(options);\n};\n\n/**\n * Counts number of documents matching `filter` in a database collection.\n *\n * #### Example:\n *\n *     Adventure.countDocuments({ type: 'jungle' }, function (err, count) {\n *       console.log('there are %d jungle adventures', count);\n *     });\n *\n * If you want to count all documents in a large collection,\n * use the [`estimatedDocumentCount()` function](https://mongoosejs.com/docs/api/model.html#Model.estimatedDocumentCount())\n * instead. If you call `countDocuments({})`, MongoDB will always execute\n * a full collection scan and **not** use any indexes.\n *\n * The `countDocuments()` function is similar to `count()`, but there are a\n * [few operators that `countDocuments()` does not support](https://mongodb.github.io/node-mongodb-native/4.9/classes/Collection.html#countDocuments).\n * Below are the operators that `count()` supports but `countDocuments()` does not,\n * and the suggested replacement:\n *\n * - `$where`: [`$expr`](https://www.mongodb.com/docs/manual/reference/operator/query/expr/)\n * - `$near`: [`$geoWithin`](https://www.mongodb.com/docs/manual/reference/operator/query/geoWithin/) with [`$center`](https://www.mongodb.com/docs/manual/reference/operator/query/center/#op._S_center)\n * - `$nearSphere`: [`$geoWithin`](https://www.mongodb.com/docs/manual/reference/operator/query/geoWithin/) with [`$centerSphere`](https://www.mongodb.com/docs/manual/reference/operator/query/centerSphere/#op._S_centerSphere)\n *\n * @param {Object} filter\n * @return {Query}\n * @api public\n */\n\nModel.countDocuments = function countDocuments(conditions, options) {\n  _checkContext(this, 'countDocuments');\n  if (typeof arguments[0] === 'function' || typeof arguments[1] === 'function' || typeof arguments[2] === 'function') {\n    throw new MongooseError('Model.countDocuments() no longer accepts a callback');\n  }\n\n  const mq = new this.Query({}, {}, this, this.$__collection);\n  if (options != null) {\n    mq.setOptions(options);\n  }\n\n  return mq.countDocuments(conditions);\n};\n\n\n/**\n * Creates a Query for a `distinct` operation.\n *\n * #### Example:\n *\n *     const query = Link.distinct('url');\n *     query.exec();\n *\n * @param {String} field\n * @param {Object} [conditions] optional\n * @return {Query}\n * @api public\n */\n\nModel.distinct = function distinct(field, conditions) {\n  _checkContext(this, 'distinct');\n  if (typeof arguments[0] === 'function' || typeof arguments[1] === 'function') {\n    throw new MongooseError('Model.distinct() no longer accepts a callback');\n  }\n\n  const mq = new this.Query({}, {}, this, this.$__collection);\n\n  return mq.distinct(field, conditions);\n};\n\n/**\n * Creates a Query, applies the passed conditions, and returns the Query.\n *\n * For example, instead of writing:\n *\n *     User.find({ age: { $gte: 21, $lte: 65 } });\n *\n * we can instead write:\n *\n *     User.where('age').gte(21).lte(65).exec();\n *\n * Since the Query class also supports `where` you can continue chaining\n *\n *     User\n *     .where('age').gte(21).lte(65)\n *     .where('name', /^b/i)\n *     ... etc\n *\n * @param {String} path\n * @param {Object} [val] optional value\n * @return {Query}\n * @api public\n */\n\nModel.where = function where(path, val) {\n  _checkContext(this, 'where');\n\n  void val; // eslint\n  const mq = new this.Query({}, {}, this, this.$__collection).find({});\n  return mq.where.apply(mq, arguments);\n};\n\n/**\n * Creates a `Query` and specifies a `$where` condition.\n *\n * Sometimes you need to query for things in mongodb using a JavaScript expression. You can do so via `find({ $where: javascript })`, or you can use the mongoose shortcut method $where via a Query chain or from your mongoose Model.\n *\n *     Blog.$where('this.username.indexOf(\"val\") !== -1').exec(function (err, docs) {});\n *\n * @param {String|Function} argument is a javascript string or anonymous function\n * @method $where\n * @memberOf Model\n * @return {Query}\n * @see Query.$where https://mongoosejs.com/docs/api/query.html#Query.prototype.$where\n * @api public\n */\n\nModel.$where = function $where() {\n  _checkContext(this, '$where');\n\n  const mq = new this.Query({}, {}, this, this.$__collection).find({});\n  return mq.$where.apply(mq, arguments);\n};\n\n/**\n * Issues a mongodb findOneAndUpdate command.\n *\n * Finds a matching document, updates it according to the `update` arg, passing any `options`, and returns the found document (if any) to the callback. The query executes if `callback` is passed else a Query object is returned.\n *\n * #### Example:\n *\n *     A.findOneAndUpdate(conditions, update, options)  // returns Query\n *     A.findOneAndUpdate(conditions, update)           // returns Query\n *     A.findOneAndUpdate()                             // returns Query\n *\n * #### Note:\n *\n * All top level update keys which are not `atomic` operation names are treated as set operations:\n *\n * #### Example:\n *\n *     const query = { name: 'borne' };\n *     Model.findOneAndUpdate(query, { name: 'jason bourne' }, options)\n *\n *     // is sent as\n *     Model.findOneAndUpdate(query, { $set: { name: 'jason bourne' }}, options)\n *\n * #### Note:\n *\n * `findOneAndX` and `findByIdAndX` functions support limited validation that\n * you can enable by setting the `runValidators` option.\n *\n * If you need full-fledged validation, use the traditional approach of first\n * retrieving the document.\n *\n *     const doc = await Model.findById(id);\n *     doc.name = 'jason bourne';\n *     await doc.save();\n *\n * @param {Object} [conditions]\n * @param {Object} [update]\n * @param {Object} [options] optional see [`Query.prototype.setOptions()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.setOptions())\n * @param {String} [options.returnDocument='before'] Has two possible values, `'before'` and `'after'`. By default, it will return the document before the update was applied.\n * @param {Object} [options.lean] if truthy, mongoose will return the document as a plain JavaScript object rather than a mongoose document. See [`Query.lean()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.lean()) and [the Mongoose lean tutorial](https://mongoosejs.com/docs/tutorials/lean.html).\n * @param {ClientSession} [options.session=null] The session associated with this query. See [transactions docs](https://mongoosejs.com/docs/transactions.html).\n * @param {Boolean|String} [options.strict] overwrites the schema's [strict mode option](https://mongoosejs.com/docs/guide.html#strict)\n * @param {Boolean} [options.timestamps=null] If set to `false` and [schema-level timestamps](https://mongoosejs.com/docs/guide.html#timestamps) are enabled, skip timestamps for this update. Note that this allows you to overwrite timestamps. Does nothing if schema-level timestamps are not set.\n * @param {Boolean} [options.upsert=false] if true, and no documents found, insert a new document\n * @param {Object|String|String[]} [options.projection=null] optional fields to return, see [`Query.prototype.select()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.select())\n * @param {Boolean} [options.new=false] if true, return the modified document rather than the original\n * @param {Object|String} [options.fields] Field selection. Equivalent to `.select(fields).findOneAndUpdate()`\n * @param {Number} [options.maxTimeMS] puts a time limit on the query - requires mongodb >= 2.6.0\n * @param {Object|String} [options.sort] if multiple docs are found by the conditions, sets the sort order to choose which doc to update.\n * @param {Boolean} [options.runValidators] if true, runs [update validators](https://mongoosejs.com/docs/validation.html#update-validators) on this command. Update validators validate the update operation against the model's schema\n * @param {Boolean} [options.setDefaultsOnInsert=true] If `setDefaultsOnInsert` and `upsert` are true, mongoose will apply the [defaults](https://mongoosejs.com/docs/defaults.html) specified in the model's schema if a new document is created\n * @param {Boolean} [options.includeResultMetadata] if true, returns the [raw result from the MongoDB driver](https://mongodb.github.io/node-mongodb-native/4.9/interfaces/ModifyResult.html)\n * @param {Boolean} [options.translateAliases=null] If set to `true`, translates any schema-defined aliases in `filter`, `projection`, `update`, and `distinct`. Throws an error if there are any conflicts where both alias and raw property are defined on the same object.\n * @return {Query}\n * @see Tutorial https://mongoosejs.com/docs/tutorials/findoneandupdate.html\n * @see mongodb https://www.mongodb.com/docs/manual/reference/command/findAndModify/\n * @api public\n */\n\nModel.findOneAndUpdate = function(conditions, update, options) {\n  _checkContext(this, 'findOneAndUpdate');\n  if (typeof arguments[0] === 'function' || typeof arguments[1] === 'function' || typeof arguments[2] === 'function' || typeof arguments[3] === 'function') {\n    throw new MongooseError('Model.findOneAndUpdate() no longer accepts a callback');\n  }\n\n  if (arguments.length === 1) {\n    update = conditions;\n    conditions = null;\n    options = null;\n  }\n\n  let fields;\n  if (options) {\n    fields = options.fields || options.projection;\n  }\n\n  update = clone(update, {\n    depopulate: true,\n    _isNested: true\n  });\n\n  decorateUpdateWithVersionKey(update, options, this.schema.options.versionKey);\n\n  const mq = new this.Query({}, {}, this, this.$__collection);\n  mq.select(fields);\n\n  return mq.findOneAndUpdate(conditions, update, options);\n};\n\n/**\n * Issues a mongodb findOneAndUpdate command by a document's _id field.\n * `findByIdAndUpdate(id, ...)` is equivalent to `findOneAndUpdate({ _id: id }, ...)`.\n *\n * Finds a matching document, updates it according to the `update` arg,\n * passing any `options`, and returns the found document (if any).\n *\n * This function triggers the following middleware.\n *\n * - `findOneAndUpdate()`\n *\n * #### Example:\n *\n *     A.findByIdAndUpdate(id, update, options)  // returns Query\n *     A.findByIdAndUpdate(id, update)           // returns Query\n *     A.findByIdAndUpdate()                     // returns Query\n *\n * #### Note:\n *\n * All top level update keys which are not `atomic` operation names are treated as set operations:\n *\n * #### Example:\n *\n *     Model.findByIdAndUpdate(id, { name: 'jason bourne' }, options)\n *\n *     // is sent as\n *     Model.findByIdAndUpdate(id, { $set: { name: 'jason bourne' }}, options)\n *\n * #### Note:\n *\n * `findOneAndX` and `findByIdAndX` functions support limited validation. You can\n * enable validation by setting the `runValidators` option.\n *\n * If you need full-fledged validation, use the traditional approach of first\n * retrieving the document.\n *\n *     const doc = await Model.findById(id)\n *     doc.name = 'jason bourne';\n *     await doc.save();\n *\n * @param {Object|Number|String} id value of `_id` to query by\n * @param {Object} [update]\n * @param {Object} [options] optional see [`Query.prototype.setOptions()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.setOptions())\n * @param {String} [options.returnDocument='before'] Has two possible values, `'before'` and `'after'`. By default, it will return the document before the update was applied.\n * @param {Object} [options.lean] if truthy, mongoose will return the document as a plain JavaScript object rather than a mongoose document. See [`Query.lean()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.lean()) and [the Mongoose lean tutorial](https://mongoosejs.com/docs/tutorials/lean.html).\n * @param {ClientSession} [options.session=null] The session associated with this query. See [transactions docs](https://mongoosejs.com/docs/transactions.html).\n * @param {Boolean|String} [options.strict] overwrites the schema's [strict mode option](https://mongoosejs.com/docs/guide.html#strict)\n * @param {Boolean} [options.timestamps=null] If set to `false` and [schema-level timestamps](https://mongoosejs.com/docs/guide.html#timestamps) are enabled, skip timestamps for this update. Note that this allows you to overwrite timestamps. Does nothing if schema-level timestamps are not set.\n * @param {Object|String} [options.sort] if multiple docs are found by the conditions, sets the sort order to choose which doc to update.\n * @param {Boolean} [options.runValidators] if true, runs [update validators](https://mongoosejs.com/docs/validation.html#update-validators) on this command. Update validators validate the update operation against the model's schema\n * @param {Boolean} [options.setDefaultsOnInsert=true] If `setDefaultsOnInsert` and `upsert` are true, mongoose will apply the [defaults](https://mongoosejs.com/docs/defaults.html) specified in the model's schema if a new document is created\n * @param {Boolean} [options.includeResultMetadata] if true, returns the full [ModifyResult from the MongoDB driver](https://mongodb.github.io/node-mongodb-native/4.9/interfaces/ModifyResult.html) rather than just the document\n * @param {Boolean} [options.upsert=false] if true, and no documents found, insert a new document\n * @param {Boolean} [options.new=false] if true, return the modified document rather than the original\n * @param {Object|String} [options.select] sets the document fields to return.\n * @param {Boolean} [options.translateAliases=null] If set to `true`, translates any schema-defined aliases in `filter`, `projection`, `update`, and `distinct`. Throws an error if there are any conflicts where both alias and raw property are defined on the same object.\n * @return {Query}\n * @see Model.findOneAndUpdate https://mongoosejs.com/docs/api/model.html#Model.findOneAndUpdate()\n * @see mongodb https://www.mongodb.com/docs/manual/reference/command/findAndModify/\n * @api public\n */\n\nModel.findByIdAndUpdate = function(id, update, options) {\n  _checkContext(this, 'findByIdAndUpdate');\n  if (typeof arguments[0] === 'function' || typeof arguments[1] === 'function' || typeof arguments[2] === 'function' || typeof arguments[3] === 'function') {\n    throw new MongooseError('Model.findByIdAndUpdate() no longer accepts a callback');\n  }\n\n  // if a model is passed in instead of an id\n  if (id instanceof Document) {\n    id = id._id;\n  }\n\n  return this.findOneAndUpdate.call(this, { _id: id }, update, options);\n};\n\n/**\n * Issue a MongoDB `findOneAndDelete()` command.\n *\n * Finds a matching document, removes it, and returns the found document (if any).\n *\n * This function triggers the following middleware.\n *\n * - `findOneAndDelete()`\n *\n * #### Example:\n *\n *     A.findOneAndDelete(conditions, options)  // return Query\n *     A.findOneAndDelete(conditions) // returns Query\n *     A.findOneAndDelete()           // returns Query\n *\n * `findOneAndX` and `findByIdAndX` functions support limited validation. You can\n * enable validation by setting the `runValidators` option.\n *\n * If you need full-fledged validation, use the traditional approach of first\n * retrieving the document.\n *\n *     const doc = await Model.findById(id)\n *     doc.name = 'jason bourne';\n *     await doc.save();\n *\n * @param {Object} conditions\n * @param {Object} [options] optional see [`Query.prototype.setOptions()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.setOptions())\n * @param {Boolean|String} [options.strict] overwrites the schema's [strict mode option](https://mongoosejs.com/docs/guide.html#strict)\n * @param {Object|String|String[]} [options.projection=null] optional fields to return, see [`Query.prototype.select()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.select())\n * @param {ClientSession} [options.session=null] The session associated with this query. See [transactions docs](https://mongoosejs.com/docs/transactions.html).\n * @param {Boolean} [options.includeResultMetadata] if true, returns the full [ModifyResult from the MongoDB driver](https://mongodb.github.io/node-mongodb-native/4.9/interfaces/ModifyResult.html) rather than just the document\n * @param {Object|String} [options.sort] if multiple docs are found by the conditions, sets the sort order to choose which doc to update.\n * @param {Object|String} [options.select] sets the document fields to return.\n * @param {Number} [options.maxTimeMS] puts a time limit on the query - requires mongodb >= 2.6.0\n * @param {Boolean} [options.translateAliases=null] If set to `true`, translates any schema-defined aliases in `filter`, `projection`, `update`, and `distinct`. Throws an error if there are any conflicts where both alias and raw property are defined on the same object.\n * @return {Query}\n * @api public\n */\n\nModel.findOneAndDelete = function(conditions, options) {\n  _checkContext(this, 'findOneAndDelete');\n\n  if (typeof arguments[0] === 'function' || typeof arguments[1] === 'function' || typeof arguments[2] === 'function') {\n    throw new MongooseError('Model.findOneAndDelete() no longer accepts a callback');\n  }\n\n  let fields;\n  if (options) {\n    fields = options.select;\n    options.select = undefined;\n  }\n\n  const mq = new this.Query({}, {}, this, this.$__collection);\n  mq.select(fields);\n\n  return mq.findOneAndDelete(conditions, options);\n};\n\n/**\n * Issue a MongoDB `findOneAndDelete()` command by a document's _id field.\n * In other words, `findByIdAndDelete(id)` is a shorthand for\n * `findOneAndDelete({ _id: id })`.\n *\n * This function triggers the following middleware.\n *\n * - `findOneAndDelete()`\n *\n * @param {Object|Number|String} id value of `_id` to query by\n * @param {Object} [options] optional see [`Query.prototype.setOptions()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.setOptions())\n * @param {Boolean|String} [options.strict] overwrites the schema's [strict mode option](https://mongoosejs.com/docs/guide.html#strict)\n * @param {Boolean} [options.translateAliases=null] If set to `true`, translates any schema-defined aliases in `filter`, `projection`, `update`, and `distinct`. Throws an error if there are any conflicts where both alias and raw property are defined on the same object.\n * @return {Query}\n * @see Model.findOneAndDelete https://mongoosejs.com/docs/api/model.html#Model.findOneAndDelete()\n * @see mongodb https://www.mongodb.com/docs/manual/reference/command/findAndModify/\n */\n\nModel.findByIdAndDelete = function(id, options) {\n  _checkContext(this, 'findByIdAndDelete');\n\n  if (typeof arguments[0] === 'function' || typeof arguments[1] === 'function' || typeof arguments[2] === 'function') {\n    throw new MongooseError('Model.findByIdAndDelete() no longer accepts a callback');\n  }\n\n  return this.findOneAndDelete({ _id: id }, options);\n};\n\n/**\n * Issue a MongoDB `findOneAndReplace()` command.\n *\n * Finds a matching document, replaces it with the provided doc, and returns the document.\n *\n * This function triggers the following query middleware.\n *\n * - `findOneAndReplace()`\n *\n * #### Example:\n *\n *     A.findOneAndReplace(filter, replacement, options)  // return Query\n *     A.findOneAndReplace(filter, replacement) // returns Query\n *     A.findOneAndReplace()                    // returns Query\n *\n * @param {Object} filter Replace the first document that matches this filter\n * @param {Object} [replacement] Replace with this document\n * @param {Object} [options] optional see [`Query.prototype.setOptions()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.setOptions())\n * @param {String} [options.returnDocument='before'] Has two possible values, `'before'` and `'after'`. By default, it will return the document before the update was applied.\n * @param {Object} [options.lean] if truthy, mongoose will return the document as a plain JavaScript object rather than a mongoose document. See [`Query.lean()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.lean()) and [the Mongoose lean tutorial](https://mongoosejs.com/docs/tutorials/lean.html).\n * @param {ClientSession} [options.session=null] The session associated with this query. See [transactions docs](https://mongoosejs.com/docs/transactions.html).\n * @param {Boolean|String} [options.strict] overwrites the schema's [strict mode option](https://mongoosejs.com/docs/guide.html#strict)\n * @param {Boolean} [options.timestamps=null] If set to `false` and [schema-level timestamps](https://mongoosejs.com/docs/guide.html#timestamps) are enabled, skip timestamps for this update. Note that this allows you to overwrite timestamps. Does nothing if schema-level timestamps are not set.\n * @param {Object|String|String[]} [options.projection=null] optional fields to return, see [`Query.prototype.select()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.select())\n * @param {Object|String} [options.sort] if multiple docs are found by the conditions, sets the sort order to choose which doc to update.\n * @param {Boolean} [options.includeResultMetadata] if true, returns the full [ModifyResult from the MongoDB driver](https://mongodb.github.io/node-mongodb-native/4.9/interfaces/ModifyResult.html) rather than just the document\n * @param {Object|String} [options.select] sets the document fields to return.\n * @param {Number} [options.maxTimeMS] puts a time limit on the query - requires mongodb >= 2.6.0\n * @param {Boolean} [options.translateAliases=null] If set to `true`, translates any schema-defined aliases in `filter`, `projection`, `update`, and `distinct`. Throws an error if there are any conflicts where both alias and raw property are defined on the same object.\n * @return {Query}\n * @api public\n */\n\nModel.findOneAndReplace = function(filter, replacement, options) {\n  _checkContext(this, 'findOneAndReplace');\n\n  if (typeof arguments[0] === 'function' || typeof arguments[1] === 'function' || typeof arguments[2] === 'function' || typeof arguments[3] === 'function') {\n    throw new MongooseError('Model.findOneAndReplace() no longer accepts a callback');\n  }\n\n  let fields;\n  if (options) {\n    fields = options.select;\n    options.select = undefined;\n  }\n\n  const mq = new this.Query({}, {}, this, this.$__collection);\n  mq.select(fields);\n\n  return mq.findOneAndReplace(filter, replacement, options);\n};\n\n/**\n * Shortcut for saving one or more documents to the database.\n * `MyModel.create(docs)` does `new MyModel(doc).save()` for every doc in\n * docs.\n *\n * This function triggers the following middleware.\n *\n * - `save()`\n *\n * #### Example:\n *\n *     // Insert one new `Character` document\n *     await Character.create({ name: 'Jean-Luc Picard' });\n *\n *     // Insert multiple new `Character` documents\n *     await Character.create([{ name: 'Will Riker' }, { name: 'Geordi LaForge' }]);\n *\n *     // Create a new character within a transaction. Note that you **must**\n *     // pass an array as the first parameter to `create()` if you want to\n *     // specify options.\n *     await Character.create([{ name: 'Jean-Luc Picard' }], { session });\n *\n * @param {Array|Object} docs Documents to insert, as a spread or array\n * @param {Object} [options] Options passed down to `save()`. To specify `options`, `docs` **must** be an array, not a spread. See [Model.save](https://mongoosejs.com/docs/api/model.html#Model.prototype.save()) for available options.\n * @param {Boolean} [options.ordered] saves the docs in series rather than parallel.\n * @param {Boolean} [options.aggregateErrors] Aggregate Errors instead of throwing the first one that occurs. Default: false\n * @return {Promise}\n * @api public\n */\n\nModel.create = async function create(doc, options) {\n  if (typeof options === 'function' ||\n      typeof arguments[2] === 'function') {\n    throw new MongooseError('Model.create() no longer accepts a callback');\n  }\n\n  _checkContext(this, 'create');\n\n  let args;\n  const discriminatorKey = this.schema.options.discriminatorKey;\n\n  if (Array.isArray(doc)) {\n    args = doc;\n    options = options != null && typeof options === 'object' ? options : {};\n  } else {\n    const last = arguments[arguments.length - 1];\n    options = {};\n    const hasCallback = typeof last === 'function' ||\n      typeof options === 'function' ||\n      typeof arguments[2] === 'function';\n    if (hasCallback) {\n      throw new MongooseError('Model.create() no longer accepts a callback');\n    } else {\n      args = [...arguments];\n      // For backwards compatibility with 6.x, because of gh-5061 Mongoose 6.x and\n      // older would treat a falsy last arg as a callback. We don't want to throw\n      // an error here, because it would look strange if `Test.create({}, void 0)`\n      // threw a callback error. But we also don't want to create an unnecessary document.\n      if (args.length > 1 && !last) {\n        args.pop();\n      }\n    }\n\n    if (args.length === 2 &&\n        args[0] != null &&\n        args[1] != null &&\n        args[0].session == null &&\n        last &&\n        getConstructorName(last.session) === 'ClientSession' &&\n        !this.schema.path('session')) {\n      // Probably means the user is running into the common mistake of trying\n      // to use a spread to specify options, see gh-7535\n      utils.warn('WARNING: to pass a `session` to `Model.create()` in ' +\n        'Mongoose, you **must** pass an array as the first argument. See: ' +\n        'https://mongoosejs.com/docs/api/model.html#Model.create()');\n    }\n  }\n\n  if (args.length === 0) {\n    return Array.isArray(doc) ? [] : null;\n  }\n  let res = [];\n  const immediateError = typeof options.aggregateErrors === 'boolean' ? !options.aggregateErrors : true;\n\n  delete options.aggregateErrors; // dont pass on the option to \"$save\"\n\n  if (options.ordered) {\n    for (let i = 0; i < args.length; i++) {\n      try {\n        const doc = args[i];\n        const Model = this.discriminators && doc[discriminatorKey] != null ?\n          this.discriminators[doc[discriminatorKey]] || getDiscriminatorByValue(this.discriminators, doc[discriminatorKey]) :\n          this;\n        if (Model == null) {\n          throw new MongooseError(`Discriminator \"${doc[discriminatorKey]}\" not ` +\n          `found for model \"${this.modelName}\"`);\n        }\n        let toSave = doc;\n        if (!(toSave instanceof Model)) {\n          toSave = new Model(toSave);\n        }\n\n        await toSave.$save(options);\n        res.push(toSave);\n      } catch (err) {\n        if (!immediateError) {\n          res.push(err);\n        } else {\n          throw err;\n        }\n      }\n    }\n    return res;\n  } else if (!immediateError) {\n    res = await Promise.allSettled(args.map(async doc => {\n      const Model = this.discriminators && doc[discriminatorKey] != null ?\n        this.discriminators[doc[discriminatorKey]] || getDiscriminatorByValue(this.discriminators, doc[discriminatorKey]) :\n        this;\n      if (Model == null) {\n        throw new MongooseError(`Discriminator \"${doc[discriminatorKey]}\" not ` +\n            `found for model \"${this.modelName}\"`);\n      }\n      let toSave = doc;\n\n      if (!(toSave instanceof Model)) {\n        toSave = new Model(toSave);\n      }\n\n      await toSave.$save(options);\n\n      return toSave;\n    }));\n    res = res.map(result => result.status === 'fulfilled' ? result.value : result.reason);\n  } else {\n    let firstError = null;\n    res = await Promise.all(args.map(async doc => {\n      const Model = this.discriminators && doc[discriminatorKey] != null ?\n        this.discriminators[doc[discriminatorKey]] || getDiscriminatorByValue(this.discriminators, doc[discriminatorKey]) :\n        this;\n      if (Model == null) {\n        throw new MongooseError(`Discriminator \"${doc[discriminatorKey]}\" not ` +\n            `found for model \"${this.modelName}\"`);\n      }\n      try {\n        let toSave = doc;\n\n        if (!(toSave instanceof Model)) {\n          toSave = new Model(toSave);\n        }\n\n        await toSave.$save(options);\n\n        return toSave;\n      } catch (err) {\n        if (!firstError) {\n          firstError = err;\n        }\n      }\n    }));\n    if (firstError) {\n      throw firstError;\n    }\n  }\n\n\n  if (!Array.isArray(doc) && args.length === 1) {\n    return res[0];\n  }\n\n  return res;\n};\n\n/**\n * _Requires a replica set running MongoDB >= 3.6.0._ Watches the\n * underlying collection for changes using\n * [MongoDB change streams](https://www.mongodb.com/docs/manual/changeStreams/).\n *\n * This function does **not** trigger any middleware. In particular, it\n * does **not** trigger aggregate middleware.\n *\n * The ChangeStream object is an event emitter that emits the following events:\n *\n * - 'change': A change occurred, see below example\n * - 'error': An unrecoverable error occurred. In particular, change streams currently error out if they lose connection to the replica set primary. Follow [this GitHub issue](https://github.com/Automattic/mongoose/issues/6799) for updates.\n * - 'end': Emitted if the underlying stream is closed\n * - 'close': Emitted if the underlying stream is closed\n *\n * #### Example:\n *\n *     const doc = await Person.create({ name: 'Ned Stark' });\n *     const changeStream = Person.watch().on('change', change => console.log(change));\n *     // Will print from the above `console.log()`:\n *     // { _id: { _data: ... },\n *     //   operationType: 'delete',\n *     //   ns: { db: 'mydb', coll: 'Person' },\n *     //   documentKey: { _id: 5a51b125c5500f5aa094c7bd } }\n *     await doc.remove();\n *\n * @param {Array} [pipeline]\n * @param {Object} [options] see the [mongodb driver options](https://mongodb.github.io/node-mongodb-native/4.9/classes/Collection.html#watch)\n * @param {Boolean} [options.hydrate=false] if true and `fullDocument: 'updateLookup'` is set, Mongoose will automatically hydrate `fullDocument` into a fully fledged Mongoose document\n * @return {ChangeStream} mongoose-specific change stream wrapper, inherits from EventEmitter\n * @api public\n */\n\nModel.watch = function(pipeline, options) {\n  _checkContext(this, 'watch');\n\n  const changeStreamThunk = cb => {\n    pipeline = pipeline || [];\n    prepareDiscriminatorPipeline(pipeline, this.schema, 'fullDocument');\n    if (this.$__collection.buffer) {\n      this.$__collection.addQueue(() => {\n        if (this.closed) {\n          return;\n        }\n        const driverChangeStream = this.$__collection.watch(pipeline, options);\n        cb(null, driverChangeStream);\n      });\n    } else {\n      const driverChangeStream = this.$__collection.watch(pipeline, options);\n      cb(null, driverChangeStream);\n    }\n  };\n\n  options = options || {};\n  options.model = this;\n\n  return new ChangeStream(changeStreamThunk, pipeline, options);\n};\n\n/**\n * _Requires MongoDB >= 3.6.0._ Starts a [MongoDB session](https://www.mongodb.com/docs/manual/release-notes/3.6/#client-sessions)\n * for benefits like causal consistency, [retryable writes](https://www.mongodb.com/docs/manual/core/retryable-writes/),\n * and [transactions](https://thecodebarbarian.com/a-node-js-perspective-on-mongodb-4-transactions.html).\n *\n * Calling `MyModel.startSession()` is equivalent to calling `MyModel.db.startSession()`.\n *\n * This function does not trigger any middleware.\n *\n * #### Example:\n *\n *     const session = await Person.startSession();\n *     let doc = await Person.findOne({ name: 'Ned Stark' }, null, { session });\n *     await doc.remove();\n *     // `doc` will always be null, even if reading from a replica set\n *     // secondary. Without causal consistency, it is possible to\n *     // get a doc back from the below query if the query reads from a\n *     // secondary that is experiencing replication lag.\n *     doc = await Person.findOne({ name: 'Ned Stark' }, null, { session, readPreference: 'secondary' });\n *\n * @param {Object} [options] see the [mongodb driver options](https://mongodb.github.io/node-mongodb-native/4.9/classes/MongoClient.html#startSession)\n * @param {Boolean} [options.causalConsistency=true] set to false to disable causal consistency\n * @return {Promise<ClientSession>} promise that resolves to a MongoDB driver `ClientSession`\n * @api public\n */\n\nModel.startSession = function() {\n  _checkContext(this, 'startSession');\n\n  return this.db.startSession.apply(this.db, arguments);\n};\n\n/**\n * Shortcut for validating an array of documents and inserting them into\n * MongoDB if they're all valid. This function is faster than `.create()`\n * because it only sends one operation to the server, rather than one for each\n * document.\n *\n * Mongoose always validates each document **before** sending `insertMany`\n * to MongoDB. So if one document has a validation error, no documents will\n * be saved, unless you set\n * [the `ordered` option to false](https://www.mongodb.com/docs/manual/reference/method/db.collection.insertMany/#error-handling).\n *\n * This function does **not** trigger save middleware.\n *\n * This function triggers the following middleware.\n *\n * - `insertMany()`\n *\n * #### Example:\n *\n *     await Movies.insertMany([\n *       { name: 'Star Wars' },\n *       { name: 'The Empire Strikes Back' }\n *     ]);\n *\n * @param {Array|Object|*} doc(s)\n * @param {Object} [options] see the [mongodb driver options](https://mongodb.github.io/node-mongodb-native/4.9/classes/Collection.html#insertMany)\n * @param {Boolean} [options.ordered=true] if true, will fail fast on the first error encountered. If false, will insert all the documents it can and report errors later. An `insertMany()` with `ordered = false` is called an \"unordered\" `insertMany()`.\n * @param {Boolean} [options.rawResult=false] if false, the returned promise resolves to the documents that passed mongoose document validation. If `true`, will return the [raw result from the MongoDB driver](https://mongodb.github.io/node-mongodb-native/4.9/interfaces/InsertManyResult.html) with a `mongoose` property that contains `validationErrors` and `results` if this is an unordered `insertMany`.\n * @param {Boolean} [options.lean=false] if `true`, skips hydrating and validating the documents. This option is useful if you need the extra performance, but Mongoose won't validate the documents before inserting.\n * @param {Number} [options.limit=null] this limits the number of documents being processed (validation/casting) by mongoose in parallel, this does **NOT** send the documents in batches to MongoDB. Use this option if you're processing a large number of documents and your app is running out of memory.\n * @param {String|Object|Array} [options.populate=null] populates the result documents. This option is a no-op if `rawResult` is set.\n * @param {Boolean} [options.throwOnValidationError=false] If true and `ordered: false`, throw an error if one of the operations failed validation, but all valid operations completed successfully.\n * @return {Promise} resolving to the raw result from the MongoDB driver if `options.rawResult` was `true`, or the documents that passed validation, otherwise\n * @api public\n */\n\nModel.insertMany = async function insertMany(arr, options) {\n  _checkContext(this, 'insertMany');\n  if (typeof options === 'function' ||\n    typeof arguments[2] === 'function') {\n    throw new MongooseError('Model.insertMany() no longer accepts a callback');\n  }\n\n  return new Promise((resolve, reject) => {\n    this.$__insertMany(arr, options, (err, res) => {\n      if (err != null) {\n        return reject(err);\n      }\n      resolve(res);\n    });\n  });\n};\n\n/**\n * ignore\n *\n * @param {Array} arr\n * @param {Object} options\n * @param {Function} callback\n * @api private\n * @memberOf Model\n * @method $__insertMany\n * @static\n */\n\nModel.$__insertMany = function(arr, options, callback) {\n  const _this = this;\n  if (typeof options === 'function') {\n    callback = options;\n    options = null;\n  }\n\n  callback = callback || utils.noop;\n  options = options || {};\n  const limit = options.limit || 1000;\n  const rawResult = !!options.rawResult;\n  const ordered = typeof options.ordered === 'boolean' ? options.ordered : true;\n  const throwOnValidationError = typeof options.throwOnValidationError === 'boolean' ? options.throwOnValidationError : false;\n  const lean = !!options.lean;\n\n  if (!Array.isArray(arr)) {\n    arr = [arr];\n  }\n\n  const validationErrors = [];\n  const validationErrorsToOriginalOrder = new Map();\n  const results = ordered ? null : new Array(arr.length);\n  const toExecute = arr.map((doc, index) =>\n    callback => {\n      if (!(doc instanceof _this)) {\n        if (doc != null && typeof doc !== 'object') {\n          return callback(new ObjectParameterError(doc, 'arr.' + index, 'insertMany'));\n        }\n        try {\n          doc = new _this(doc);\n        } catch (err) {\n          return callback(err);\n        }\n      }\n      if (options.session != null) {\n        doc.$session(options.session);\n      }\n      // If option `lean` is set to true bypass validation\n      if (lean) {\n        // we have to execute callback at the nextTick to be compatible\n        // with parallelLimit, as `results` variable has TDZ issue if we\n        // execute the callback synchronously\n        return immediate(() => callback(null, doc));\n      }\n      doc.$validate().then(\n        () => { callback(null, doc); },\n        error => {\n          if (ordered === false) {\n            validationErrors.push(error);\n            validationErrorsToOriginalOrder.set(error, index);\n            results[index] = error;\n            return callback(null, null);\n          }\n          callback(error);\n        }\n      );\n    });\n\n  parallelLimit(toExecute, limit, function(error, docs) {\n    if (error) {\n      callback(error, null);\n      return;\n    }\n\n    const originalDocIndex = new Map();\n    const validDocIndexToOriginalIndex = new Map();\n    for (let i = 0; i < docs.length; ++i) {\n      originalDocIndex.set(docs[i], i);\n    }\n\n    // We filter all failed pre-validations by removing nulls\n    const docAttributes = docs.filter(function(doc) {\n      return doc != null;\n    });\n    for (let i = 0; i < docAttributes.length; ++i) {\n      validDocIndexToOriginalIndex.set(i, originalDocIndex.get(docAttributes[i]));\n    }\n\n    // Make sure validation errors are in the same order as the\n    // original documents, so if both doc1 and doc2 both fail validation,\n    // `Model.insertMany([doc1, doc2])` will always have doc1's validation\n    // error before doc2's. Re: gh-12791.\n    if (validationErrors.length > 0) {\n      validationErrors.sort((err1, err2) => {\n        return validationErrorsToOriginalOrder.get(err1) - validationErrorsToOriginalOrder.get(err2);\n      });\n    }\n\n    // Quickly escape while there aren't any valid docAttributes\n    if (docAttributes.length === 0) {\n      if (rawResult) {\n        const res = {\n          acknowledged: true,\n          insertedCount: 0,\n          insertedIds: {},\n          mongoose: {\n            validationErrors: validationErrors\n          }\n        };\n        return callback(null, res);\n      }\n      callback(null, []);\n      return;\n    }\n    const docObjects = docAttributes.map(function(doc) {\n      if (doc.$__schema.options.versionKey) {\n        doc[doc.$__schema.options.versionKey] = 0;\n      }\n      const shouldSetTimestamps = (!options || options.timestamps !== false) && doc.initializeTimestamps && (!doc.$__ || doc.$__.timestamps !== false);\n      if (shouldSetTimestamps) {\n        return doc.initializeTimestamps().toObject(internalToObjectOptions);\n      }\n      return doc.toObject(internalToObjectOptions);\n    });\n\n    _this.$__collection.insertMany(docObjects, options).then(\n      res => {\n        for (const attribute of docAttributes) {\n          attribute.$__reset();\n          _setIsNew(attribute, false);\n        }\n\n        if (ordered === false && throwOnValidationError && validationErrors.length > 0) {\n          for (let i = 0; i < results.length; ++i) {\n            if (results[i] === void 0) {\n              results[i] = docs[i];\n            }\n          }\n          return callback(new MongooseBulkWriteError(\n            validationErrors,\n            results,\n            res,\n            'insertMany'\n          ));\n        }\n\n        if (rawResult) {\n          if (ordered === false) {\n            for (let i = 0; i < results.length; ++i) {\n              if (results[i] === void 0) {\n                results[i] = docs[i];\n              }\n            }\n\n            // Decorate with mongoose validation errors in case of unordered,\n            // because then still do `insertMany()`\n            res.mongoose = {\n              validationErrors: validationErrors,\n              results: results\n            };\n          }\n          return callback(null, res);\n        }\n\n        if (options.populate != null) {\n          return _this.populate(docAttributes, options.populate).then(\n            docs => { callback(null, docs); },\n            err => {\n              if (err != null) {\n                err.insertedDocs = docAttributes;\n              }\n              throw err;\n            }\n          );\n        }\n\n        callback(null, docAttributes);\n      },\n      error => {\n        // `writeErrors` is a property reported by the MongoDB driver,\n        // just not if there's only 1 error.\n        if (error.writeErrors == null &&\n            (error.result && error.result.result && error.result.result.writeErrors) != null) {\n          error.writeErrors = error.result.result.writeErrors;\n        }\n\n        // `insertedDocs` is a Mongoose-specific property\n        const hasWriteErrors = error && error.writeErrors;\n        const erroredIndexes = new Set((error && error.writeErrors || []).map(err => err.index));\n\n        if (error.writeErrors != null) {\n          for (let i = 0; i < error.writeErrors.length; ++i) {\n            const originalIndex = validDocIndexToOriginalIndex.get(error.writeErrors[i].index);\n            error.writeErrors[i] = {\n              ...error.writeErrors[i],\n              index: originalIndex\n            };\n            if (!ordered) {\n              results[originalIndex] = error.writeErrors[i];\n            }\n          }\n        }\n\n        if (!ordered) {\n          for (let i = 0; i < results.length; ++i) {\n            if (results[i] === void 0) {\n              results[i] = docs[i];\n            }\n          }\n\n          error.results = results;\n        }\n\n        let firstErroredIndex = -1;\n        error.insertedDocs = docAttributes.\n          filter((doc, i) => {\n            const isErrored = !hasWriteErrors || erroredIndexes.has(i);\n\n            if (ordered) {\n              if (firstErroredIndex > -1) {\n                return i < firstErroredIndex;\n              }\n\n              if (isErrored) {\n                firstErroredIndex = i;\n              }\n            }\n\n            return !isErrored;\n          }).\n          map(function setIsNewForInsertedDoc(doc) {\n            doc.$__reset();\n            _setIsNew(doc, false);\n            return doc;\n          });\n\n        if (rawResult && ordered === false) {\n          error.mongoose = {\n            validationErrors: validationErrors,\n            results: results\n          };\n        }\n\n        callback(error, null);\n      }\n    );\n  });\n};\n\n/*!\n * ignore\n */\n\nfunction _setIsNew(doc, val) {\n  doc.$isNew = val;\n  doc.$emit('isNew', val);\n  doc.constructor.emit('isNew', val);\n\n  const subdocs = doc.$getAllSubdocs();\n  for (const subdoc of subdocs) {\n    subdoc.$isNew = val;\n    subdoc.$emit('isNew', val);\n  }\n}\n\n/**\n * Sends multiple `insertOne`, `updateOne`, `updateMany`, `replaceOne`,\n * `deleteOne`, and/or `deleteMany` operations to the MongoDB server in one\n * command. This is faster than sending multiple independent operations (e.g.\n * if you use `create()`) because with `bulkWrite()` there is only one round\n * trip to MongoDB.\n *\n * Mongoose will perform casting on all operations you provide.\n *\n * This function does **not** trigger any middleware, neither `save()`, nor `update()`.\n * If you need to trigger\n * `save()` middleware for every document use [`create()`](https://mongoosejs.com/docs/api/model.html#Model.create()) instead.\n *\n * #### Example:\n *\n *     Character.bulkWrite([\n *       {\n *         insertOne: {\n *           document: {\n *             name: 'Eddard Stark',\n *             title: 'Warden of the North'\n *           }\n *         }\n *       },\n *       {\n *         updateOne: {\n *           filter: { name: 'Eddard Stark' },\n *           // If you were using the MongoDB driver directly, you'd need to do\n *           // `update: { $set: { title: ... } }` but mongoose adds $set for\n *           // you.\n *           update: { title: 'Hand of the King' }\n *         }\n *       },\n *       {\n *         deleteOne: {\n *           filter: { name: 'Eddard Stark' }\n *         }\n *       }\n *     ]).then(res => {\n *      // Prints \"1 1 1\"\n *      console.log(res.insertedCount, res.modifiedCount, res.deletedCount);\n *     });\n *\n * The [supported operations](https://www.mongodb.com/docs/manual/reference/method/db.collection.bulkWrite/#db.collection.bulkWrite) are:\n *\n * - `insertOne`\n * - `updateOne`\n * - `updateMany`\n * - `deleteOne`\n * - `deleteMany`\n * - `replaceOne`\n *\n * @param {Array} ops\n * @param {Object} [ops.insertOne.document] The document to insert\n * @param {Object} [ops.updateOne.filter] Update the first document that matches this filter\n * @param {Object} [ops.updateOne.update] An object containing [update operators](https://www.mongodb.com/docs/manual/reference/operator/update/)\n * @param {Boolean} [ops.updateOne.upsert=false] If true, insert a doc if none match\n * @param {Boolean} [ops.updateOne.timestamps=true] If false, do not apply [timestamps](https://mongoosejs.com/docs/guide.html#timestamps) to the operation\n * @param {Object} [ops.updateOne.collation] The [MongoDB collation](https://thecodebarbarian.com/a-nodejs-perspective-on-mongodb-34-collations) to use\n * @param {Array} [ops.updateOne.arrayFilters] The [array filters](https://thecodebarbarian.com/a-nodejs-perspective-on-mongodb-36-array-filters.html) used in `update`\n * @param {Object} [ops.updateMany.filter] Update all the documents that match this filter\n * @param {Object} [ops.updateMany.update] An object containing [update operators](https://www.mongodb.com/docs/manual/reference/operator/update/)\n * @param {Boolean} [ops.updateMany.upsert=false] If true, insert a doc if no documents match `filter`\n * @param {Boolean} [ops.updateMany.timestamps=true] If false, do not apply [timestamps](https://mongoosejs.com/docs/guide.html#timestamps) to the operation\n * @param {Object} [ops.updateMany.collation] The [MongoDB collation](https://thecodebarbarian.com/a-nodejs-perspective-on-mongodb-34-collations) to use\n * @param {Array} [ops.updateMany.arrayFilters] The [array filters](https://thecodebarbarian.com/a-nodejs-perspective-on-mongodb-36-array-filters.html) used in `update`\n * @param {Object} [ops.deleteOne.filter] Delete the first document that matches this filter\n * @param {Object} [ops.deleteMany.filter] Delete all documents that match this filter\n * @param {Object} [ops.replaceOne.filter] Replace the first document that matches this filter\n * @param {Object} [ops.replaceOne.replacement] The replacement document\n * @param {Boolean} [ops.replaceOne.upsert=false] If true, insert a doc if no documents match `filter`\n * @param {Object} [options]\n * @param {Boolean} [options.ordered=true] If true, execute writes in order and stop at the first error. If false, execute writes in parallel and continue until all writes have either succeeded or errored.\n * @param {ClientSession} [options.session=null] The session associated with this bulk write. See [transactions docs](https://mongoosejs.com/docs/transactions.html).\n * @param {String|number} [options.w=1] The [write concern](https://www.mongodb.com/docs/manual/reference/write-concern/). See [`Query#w()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.w()) for more information.\n * @param {number} [options.wtimeout=null] The [write concern timeout](https://www.mongodb.com/docs/manual/reference/write-concern/#wtimeout).\n * @param {Boolean} [options.j=true] If false, disable [journal acknowledgement](https://www.mongodb.com/docs/manual/reference/write-concern/#j-option)\n * @param {Boolean} [options.skipValidation=false] Set to true to skip Mongoose schema validation on bulk write operations. Mongoose currently runs validation on `insertOne` and `replaceOne` operations by default.\n * @param {Boolean} [options.bypassDocumentValidation=false] If true, disable [MongoDB server-side schema validation](https://www.mongodb.com/docs/manual/core/schema-validation/) for all writes in this bulk.\n * @param {Boolean} [options.throwOnValidationError=false] If true and `ordered: false`, throw an error if one of the operations failed validation, but all valid operations completed successfully.\n * @param {Boolean} [options.strict=null] Overwrites the [`strict` option](https://mongoosejs.com/docs/guide.html#strict) on schema. If false, allows filtering and writing fields not defined in the schema for all writes in this bulk.\n * @return {Promise} resolves to a [`BulkWriteOpResult`](https://mongodb.github.io/node-mongodb-native/4.9/classes/BulkWriteResult.html) if the operation succeeds\n * @api public\n */\n\nModel.bulkWrite = async function bulkWrite(ops, options) {\n  _checkContext(this, 'bulkWrite');\n\n  if (typeof options === 'function' ||\n      typeof arguments[2] === 'function') {\n    throw new MongooseError('Model.bulkWrite() no longer accepts a callback');\n  }\n  options = options || {};\n\n  const shouldSkip = await new Promise((resolve, reject) => {\n    this.hooks.execPre('bulkWrite', this, [ops, options], (err) => {\n      if (err != null) {\n        if (err instanceof Kareem.skipWrappedFunction) {\n          return resolve(err);\n        }\n        return reject(err);\n      }\n      resolve();\n    });\n  });\n\n  if (shouldSkip) {\n    return shouldSkip.args[0];\n  }\n\n  const ordered = options.ordered == null ? true : options.ordered;\n\n  if (ops.length === 0) {\n    return getDefaultBulkwriteResult();\n  }\n\n  const validations = ops.map(op => castBulkWrite(this, op, options));\n\n  let res = null;\n  if (ordered) {\n    await new Promise((resolve, reject) => {\n      each(validations, (fn, cb) => fn(cb), error => {\n        if (error) {\n          return reject(error);\n        }\n\n        resolve();\n      });\n    });\n\n    try {\n      res = await this.$__collection.bulkWrite(ops, options);\n    } catch (error) {\n      await new Promise((resolve, reject) => {\n        const _opts = { error: error };\n        this.hooks.execPost('bulkWrite', this, [null], _opts, (err) => {\n          if (err != null) {\n            return reject(err);\n          }\n          resolve();\n        });\n      });\n    }\n  } else {\n    let remaining = validations.length;\n    let validOps = [];\n    let validationErrors = [];\n    const results = [];\n    await new Promise((resolve) => {\n      for (let i = 0; i < validations.length; ++i) {\n        validations[i]((err) => {\n          if (err == null) {\n            validOps.push(i);\n          } else {\n            validationErrors.push({ index: i, error: err });\n            results[i] = err;\n          }\n          if (--remaining <= 0) {\n            resolve();\n          }\n        });\n      }\n    });\n\n    validationErrors = validationErrors.\n      sort((v1, v2) => v1.index - v2.index).\n      map(v => v.error);\n\n    const validOpIndexes = validOps;\n    validOps = validOps.sort().map(index => ops[index]);\n\n    if (validOps.length === 0) {\n      return getDefaultBulkwriteResult();\n    }\n\n    let error;\n    [res, error] = await this.$__collection.bulkWrite(validOps, options).\n      then(res => ([res, null])).\n      catch(err => ([null, err]));\n\n    if (error) {\n      if (validationErrors.length > 0) {\n        error.mongoose = error.mongoose || {};\n        error.mongoose.validationErrors = validationErrors;\n      }\n\n      await new Promise((resolve, reject) => {\n        const _opts = { error: error };\n        this.hooks.execPost('bulkWrite', this, [null], _opts, (err) => {\n          if (err != null) {\n            return reject(err);\n          }\n          resolve();\n        });\n      });\n    }\n\n    for (let i = 0; i < validOpIndexes.length; ++i) {\n      results[validOpIndexes[i]] = null;\n    }\n    if (validationErrors.length > 0) {\n      if (options.throwOnValidationError) {\n        throw new MongooseBulkWriteError(\n          validationErrors,\n          results,\n          res,\n          'bulkWrite'\n        );\n      } else {\n        res.mongoose = res.mongoose || {};\n        res.mongoose.validationErrors = validationErrors;\n        res.mongoose.results = results;\n      }\n    }\n  }\n\n  await new Promise((resolve, reject) => {\n    this.hooks.execPost('bulkWrite', this, [res], (err) => {\n      if (err != null) {\n        return reject(err);\n      }\n      resolve();\n    });\n  });\n\n  return res;\n};\n\n/**\n *  takes an array of documents, gets the changes and inserts/updates documents in the database\n *  according to whether or not the document is new, or whether it has changes or not.\n *\n * `bulkSave` uses `bulkWrite` under the hood, so it's mostly useful when dealing with many documents (10K+)\n *\n * @param {Array<Document>} documents\n * @param {Object} [options] options passed to the underlying `bulkWrite()`\n * @param {Boolean} [options.timestamps] defaults to `null`, when set to false, mongoose will not add/update timestamps to the documents.\n * @param {ClientSession} [options.session=null] The session associated with this bulk write. See [transactions docs](https://mongoosejs.com/docs/transactions.html).\n * @param {String|number} [options.w=1] The [write concern](https://www.mongodb.com/docs/manual/reference/write-concern/). See [`Query#w()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.w()) for more information.\n * @param {number} [options.wtimeout=null] The [write concern timeout](https://www.mongodb.com/docs/manual/reference/write-concern/#wtimeout).\n * @param {Boolean} [options.j=true] If false, disable [journal acknowledgement](https://www.mongodb.com/docs/manual/reference/write-concern/#j-option)\n *\n */\nModel.bulkSave = async function bulkSave(documents, options) {\n  options = options || {};\n\n  if (options.timestamps != null) {\n    for (const document of documents) {\n      document.$__.saveOptions = document.$__.saveOptions || {};\n      document.$__.saveOptions.timestamps = options.timestamps;\n    }\n  } else {\n    for (const document of documents) {\n      if (document.$__.timestamps != null) {\n        document.$__.saveOptions = document.$__.saveOptions || {};\n        document.$__.saveOptions.timestamps = document.$__.timestamps;\n      }\n    }\n  }\n\n  await Promise.all(documents.map(buildPreSavePromise));\n\n  const writeOperations = this.buildBulkWriteOperations(documents, { skipValidation: true, timestamps: options.timestamps });\n\n  const { bulkWriteResult, bulkWriteError } = await this.bulkWrite(writeOperations, options).then(\n    (res) => ({ bulkWriteResult: res, bulkWriteError: null }),\n    (err) => ({ bulkWriteResult: null, bulkWriteError: err })\n  );\n\n  await Promise.all(\n    documents.map(async(document) => {\n      const documentError = bulkWriteError && bulkWriteError.writeErrors.find(writeError => {\n        const writeErrorDocumentId = writeError.err.op._id || writeError.err.op.q._id;\n        return writeErrorDocumentId.toString() === document._id.toString();\n      });\n\n      if (documentError == null) {\n        await handleSuccessfulWrite(document);\n      }\n    })\n  );\n\n  if (bulkWriteError && bulkWriteError.writeErrors && bulkWriteError.writeErrors.length) {\n    throw bulkWriteError;\n  }\n\n  return bulkWriteResult;\n};\n\nfunction buildPreSavePromise(document) {\n  return new Promise((resolve, reject) => {\n    document.schema.s.hooks.execPre('save', document, (err) => {\n      if (err) {\n        reject(err);\n        return;\n      }\n      resolve();\n    });\n  });\n}\n\nfunction handleSuccessfulWrite(document) {\n  return new Promise((resolve, reject) => {\n    if (document.$isNew) {\n      _setIsNew(document, false);\n    }\n\n    document.$__reset();\n    document.schema.s.hooks.execPost('save', document, [document], {}, (err) => {\n      if (err) {\n        reject(err);\n        return;\n      }\n      resolve();\n    });\n\n  });\n}\n\n/**\n * Apply defaults to the given document or POJO.\n *\n * @param {Object|Document} obj object or document to apply defaults on\n * @returns {Object|Document}\n * @api public\n */\n\nModel.applyDefaults = function applyDefaults(doc) {\n  if (doc.$__ != null) {\n    applyDefaultsHelper(doc, doc.$__.fields, doc.$__.exclude);\n\n    for (const subdoc of doc.$getAllSubdocs()) {\n      applyDefaults(subdoc, subdoc.$__.fields, subdoc.$__.exclude);\n    }\n\n    return doc;\n  }\n\n  applyDefaultsToPOJO(doc, this.schema);\n\n  return doc;\n};\n\n/**\n * Cast the given POJO to the model's schema\n *\n * #### Example:\n *\n *     const Test = mongoose.model('Test', Schema({ num: Number }));\n *\n *     const obj = Test.castObject({ num: '42' });\n *     obj.num; // 42 as a number\n *\n *     Test.castObject({ num: 'not a number' }); // Throws a ValidationError\n *\n * @param {Object} obj object or document to cast\n * @param {Object} options options passed to castObject\n * @param {Boolean} options.ignoreCastErrors If set to `true` will not throw a ValidationError and only return values that were successfully cast.\n * @returns {Object} POJO casted to the model's schema\n * @throws {ValidationError} if casting failed for at least one path\n * @api public\n */\n\nModel.castObject = function castObject(obj, options) {\n  options = options || {};\n  const ret = {};\n\n  const schema = this.schema;\n  const paths = Object.keys(schema.paths);\n\n  for (const path of paths) {\n    const schemaType = schema.path(path);\n    if (!schemaType || !schemaType.$isMongooseArray) {\n      continue;\n    }\n\n    const val = get(obj, path);\n    pushNestedArrayPaths(paths, val, path);\n  }\n\n  let error = null;\n\n  for (const path of paths) {\n    const schemaType = schema.path(path);\n    if (schemaType == null) {\n      continue;\n    }\n\n    let val = get(obj, path, void 0);\n\n    if (val == null) {\n      continue;\n    }\n\n    const pieces = path.indexOf('.') === -1 ? [path] : path.split('.');\n    let cur = ret;\n    for (let i = 0; i < pieces.length - 1; ++i) {\n      if (cur[pieces[i]] == null) {\n        cur[pieces[i]] = isNaN(pieces[i + 1]) ? {} : [];\n      }\n      cur = cur[pieces[i]];\n    }\n\n    if (schemaType.$isMongooseDocumentArray) {\n      continue;\n    }\n    if (schemaType.$isSingleNested || schemaType.$isMongooseDocumentArrayElement) {\n      try {\n        val = Model.castObject.call(schemaType.caster, val);\n      } catch (err) {\n        if (!options.ignoreCastErrors) {\n          error = error || new ValidationError();\n          error.addError(path, err);\n        }\n        continue;\n      }\n\n      cur[pieces[pieces.length - 1]] = val;\n      continue;\n    }\n\n    try {\n      val = schemaType.cast(val);\n      cur[pieces[pieces.length - 1]] = val;\n    } catch (err) {\n      if (!options.ignoreCastErrors) {\n        error = error || new ValidationError();\n        error.addError(path, err);\n      }\n\n      continue;\n    }\n  }\n\n  if (error != null) {\n    throw error;\n  }\n\n  return ret;\n};\n\n/**\n * Build bulk write operations for `bulkSave()`.\n *\n * @param {Array<Document>} documents The array of documents to build write operations of\n * @param {Object} options\n * @param {Boolean} options.skipValidation defaults to `false`, when set to true, building the write operations will bypass validating the documents.\n * @param {Boolean} options.timestamps defaults to `null`, when set to false, mongoose will not add/update timestamps to the documents.\n * @return {Array<Promise>} Returns a array of all Promises the function executes to be awaited.\n * @api private\n */\n\nModel.buildBulkWriteOperations = function buildBulkWriteOperations(documents, options) {\n  if (!Array.isArray(documents)) {\n    throw new Error(`bulkSave expects an array of documents to be passed, received \\`${documents}\\` instead`);\n  }\n\n  setDefaultOptions();\n  const discriminatorKey = this.schema.options.discriminatorKey;\n\n  const writeOperations = documents.reduce((accumulator, document, i) => {\n    if (!options.skipValidation) {\n      if (!(document instanceof Document)) {\n        throw new Error(`documents.${i} was not a mongoose document, documents must be an array of mongoose documents (instanceof mongoose.Document).`);\n      }\n      const validationError = document.validateSync();\n      if (validationError) {\n        throw validationError;\n      }\n    }\n\n    const isANewDocument = document.isNew;\n    if (isANewDocument) {\n      const writeOperation = { insertOne: { document } };\n      utils.injectTimestampsOption(writeOperation.insertOne, options.timestamps);\n      accumulator.push(writeOperation);\n\n      return accumulator;\n    }\n\n    const delta = document.$__delta();\n    const isDocumentWithChanges = delta != null && !utils.isEmptyObject(delta[0]);\n\n    if (isDocumentWithChanges) {\n      const where = document.$__where(delta[0]);\n      const changes = delta[1];\n\n      _applyCustomWhere(document, where);\n\n      // Set the discriminator key, so bulk write casting knows which\n      // schema to use re: gh-13907\n      if (document[discriminatorKey] != null && !(discriminatorKey in where)) {\n        where[discriminatorKey] = document[discriminatorKey];\n      }\n\n      document.$__version(where, delta);\n      const writeOperation = { updateOne: { filter: where, update: changes } };\n      utils.injectTimestampsOption(writeOperation.updateOne, options.timestamps);\n      accumulator.push(writeOperation);\n\n      return accumulator;\n    }\n\n    return accumulator;\n  }, []);\n\n  return writeOperations;\n\n\n  function setDefaultOptions() {\n    options = options || {};\n    if (options.skipValidation == null) {\n      options.skipValidation = false;\n    }\n  }\n};\n\n\n/**\n * Shortcut for creating a new Document from existing raw data, pre-saved in the DB.\n * The document returned has no paths marked as modified initially.\n *\n * #### Example:\n *\n *     // hydrate previous data into a Mongoose document\n *     const mongooseCandy = Candy.hydrate({ _id: '54108337212ffb6d459f854c', type: 'jelly bean' });\n *\n * @param {Object} obj\n * @param {Object|String|String[]} [projection] optional projection containing which fields should be selected for this document\n * @param {Object} [options] optional options\n * @param {Boolean} [options.setters=false] if true, apply schema setters when hydrating\n * @param {Boolean} [options.hydratedPopulatedDocs=false] if true, populates the docs if passing pre-populated data\n * @return {Document} document instance\n * @api public\n */\n\nModel.hydrate = function(obj, projection, options) {\n  _checkContext(this, 'hydrate');\n\n  if (projection != null) {\n    if (obj != null && obj.$__ != null) {\n      obj = obj.toObject(internalToObjectOptions);\n    }\n    obj = applyProjection(obj, projection);\n  }\n  const document = (__webpack_require__(/*! ./queryHelpers */ \"../server/node_modules/mongoose/lib/queryHelpers.js\").createModel)(this, obj, projection);\n  document.$init(obj, options);\n  return document;\n};\n\n/**\n * Same as `updateOne()`, except MongoDB will update _all_ documents that match\n * `filter` (as opposed to just the first one) regardless of the value of\n * the `multi` option.\n *\n * **Note** updateMany will _not_ fire update middleware. Use `pre('updateMany')`\n * and `post('updateMany')` instead.\n *\n * #### Example:\n *\n *     const res = await Person.updateMany({ name: /Stark$/ }, { isDeleted: true });\n *     res.matchedCount; // Number of documents matched\n *     res.modifiedCount; // Number of documents modified\n *     res.acknowledged; // Boolean indicating everything went smoothly.\n *     res.upsertedId; // null or an id containing a document that had to be upserted.\n *     res.upsertedCount; // Number indicating how many documents had to be upserted. Will either be 0 or 1.\n *\n * This function triggers the following middleware.\n *\n * - `updateMany()`\n *\n * @param {Object} filter\n * @param {Object|Array} update\n * @param {Object} [options] optional see [`Query.prototype.setOptions()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.setOptions())\n * @param {Boolean|String} [options.strict] overwrites the schema's [strict mode option](https://mongoosejs.com/docs/guide.html#strict)\n * @param {Boolean} [options.upsert=false] if true, and no documents found, insert a new document\n * @param {Object} [options.writeConcern=null] sets the [write concern](https://www.mongodb.com/docs/manual/reference/write-concern/) for replica sets. Overrides the [schema-level write concern](https://mongoosejs.com/docs/guide.html#writeConcern)\n * @param {Boolean} [options.timestamps=null] If set to `false` and [schema-level timestamps](https://mongoosejs.com/docs/guide.html#timestamps) are enabled, skip timestamps for this update. Does nothing if schema-level timestamps are not set.\n * @param {Boolean} [options.translateAliases=null] If set to `true`, translates any schema-defined aliases in `filter`, `projection`, `update`, and `distinct`. Throws an error if there are any conflicts where both alias and raw property are defined on the same object.\n * @return {Query}\n * @see Query docs https://mongoosejs.com/docs/queries.html\n * @see MongoDB docs https://www.mongodb.com/docs/manual/reference/command/update/#update-command-output\n * @see UpdateResult https://mongodb.github.io/node-mongodb-native/4.9/interfaces/UpdateResult.html\n * @api public\n */\n\nModel.updateMany = function updateMany(conditions, doc, options) {\n  _checkContext(this, 'updateMany');\n\n  return _update(this, 'updateMany', conditions, doc, options);\n};\n\n/**\n * Update _only_ the first document that matches `filter`.\n *\n * - Use `replaceOne()` if you want to overwrite an entire document rather than using atomic operators like `$set`.\n *\n * #### Example:\n *\n *     const res = await Person.updateOne({ name: 'Jean-Luc Picard' }, { ship: 'USS Enterprise' });\n *     res.matchedCount; // Number of documents matched\n *     res.modifiedCount; // Number of documents modified\n *     res.acknowledged; // Boolean indicating everything went smoothly.\n *     res.upsertedId; // null or an id containing a document that had to be upserted.\n *     res.upsertedCount; // Number indicating how many documents had to be upserted. Will either be 0 or 1.\n *\n * This function triggers the following middleware.\n *\n * - `updateOne()`\n *\n * @param {Object} filter\n * @param {Object|Array} update\n * @param {Object} [options] optional see [`Query.prototype.setOptions()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.setOptions())\n * @param {Boolean|String} [options.strict] overwrites the schema's [strict mode option](https://mongoosejs.com/docs/guide.html#strict)\n * @param {Boolean} [options.upsert=false] if true, and no documents found, insert a new document\n * @param {Object} [options.writeConcern=null] sets the [write concern](https://www.mongodb.com/docs/manual/reference/write-concern/) for replica sets. Overrides the [schema-level write concern](https://mongoosejs.com/docs/guide.html#writeConcern)\n * @param {Boolean} [options.timestamps=null] If set to `false` and [schema-level timestamps](https://mongoosejs.com/docs/guide.html#timestamps) are enabled, skip timestamps for this update. Note that this allows you to overwrite timestamps. Does nothing if schema-level timestamps are not set.\n * @param {Boolean} [options.translateAliases=null] If set to `true`, translates any schema-defined aliases in `filter`, `projection`, `update`, and `distinct`. Throws an error if there are any conflicts where both alias and raw property are defined on the same object.\n * @return {Query}\n * @see Query docs https://mongoosejs.com/docs/queries.html\n * @see MongoDB docs https://www.mongodb.com/docs/manual/reference/command/update/#update-command-output\n * @see UpdateResult https://mongodb.github.io/node-mongodb-native/4.9/interfaces/UpdateResult.html\n * @api public\n */\n\nModel.updateOne = function updateOne(conditions, doc, options) {\n  _checkContext(this, 'updateOne');\n\n  return _update(this, 'updateOne', conditions, doc, options);\n};\n\n/**\n * Replace the existing document with the given document (no atomic operators like `$set`).\n *\n * #### Example:\n *\n *     const res = await Person.replaceOne({ _id: 24601 }, { name: 'Jean Valjean' });\n *     res.matchedCount; // Number of documents matched\n *     res.modifiedCount; // Number of documents modified\n *     res.acknowledged; // Boolean indicating everything went smoothly.\n *     res.upsertedId; // null or an id containing a document that had to be upserted.\n *     res.upsertedCount; // Number indicating how many documents had to be upserted. Will either be 0 or 1.\n *\n * This function triggers the following middleware.\n *\n * - `replaceOne()`\n *\n * @param {Object} filter\n * @param {Object} doc\n * @param {Object} [options] optional see [`Query.prototype.setOptions()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.setOptions())\n * @param {Boolean|String} [options.strict] overwrites the schema's [strict mode option](https://mongoosejs.com/docs/guide.html#strict)\n * @param {Boolean} [options.upsert=false] if true, and no documents found, insert a new document\n * @param {Object} [options.writeConcern=null] sets the [write concern](https://www.mongodb.com/docs/manual/reference/write-concern/) for replica sets. Overrides the [schema-level write concern](https://mongoosejs.com/docs/guide.html#writeConcern)\n * @param {Boolean} [options.timestamps=null] If set to `false` and [schema-level timestamps](https://mongoosejs.com/docs/guide.html#timestamps) are enabled, skip timestamps for this update. Does nothing if schema-level timestamps are not set.\n * @param {Boolean} [options.translateAliases=null] If set to `true`, translates any schema-defined aliases in `filter`, `projection`, `update`, and `distinct`. Throws an error if there are any conflicts where both alias and raw property are defined on the same object.\n * @return {Query}\n * @see Query docs https://mongoosejs.com/docs/queries.html\n * @see UpdateResult https://mongodb.github.io/node-mongodb-native/4.9/interfaces/UpdateResult.html\n * @return {Query}\n * @api public\n */\n\nModel.replaceOne = function replaceOne(conditions, doc, options) {\n  _checkContext(this, 'replaceOne');\n\n  const versionKey = this && this.schema && this.schema.options && this.schema.options.versionKey || null;\n  if (versionKey && !doc[versionKey]) {\n    doc[versionKey] = 0;\n  }\n\n  return _update(this, 'replaceOne', conditions, doc, options);\n};\n\n/**\n * Common code for `updateOne()`, `updateMany()`, `replaceOne()`, and `update()`\n * because they need to do the same thing\n * @api private\n */\n\nfunction _update(model, op, conditions, doc, options) {\n  const mq = new model.Query({}, {}, model, model.collection);\n\n  // gh-2406\n  // make local deep copy of conditions\n  if (conditions instanceof Document) {\n    conditions = conditions.toObject();\n  } else {\n    conditions = clone(conditions);\n  }\n  options = typeof options === 'function' ? options : clone(options);\n\n  const versionKey = model &&\n  model.schema &&\n  model.schema.options &&\n  model.schema.options.versionKey || null;\n  decorateUpdateWithVersionKey(doc, options, versionKey);\n\n  return mq[op](conditions, doc, options);\n}\n\n/**\n * Performs [aggregations](https://www.mongodb.com/docs/manual/aggregation/) on the models collection.\n *\n * If a `callback` is passed, the `aggregate` is executed and a `Promise` is returned. If a callback is not passed, the `aggregate` itself is returned.\n *\n * This function triggers the following middleware.\n *\n * - `aggregate()`\n *\n * #### Example:\n *\n *     // Find the max balance of all accounts\n *     const res = await Users.aggregate([\n *       { $group: { _id: null, maxBalance: { $max: '$balance' }}},\n *       { $project: { _id: 0, maxBalance: 1 }}\n *     ]);\n *\n *     console.log(res); // [ { maxBalance: 98000 } ]\n *\n *     // Or use the aggregation pipeline builder.\n *     const res = await Users.aggregate().\n *       group({ _id: null, maxBalance: { $max: '$balance' } }).\n *       project('-id maxBalance').\n *       exec();\n *     console.log(res); // [ { maxBalance: 98 } ]\n *\n * #### Note:\n *\n * - Mongoose does **not** cast aggregation pipelines to the model's schema because `$project` and `$group` operators allow redefining the \"shape\" of the documents at any stage of the pipeline, which may leave documents in an incompatible format. You can use the [mongoose-cast-aggregation plugin](https://github.com/AbdelrahmanHafez/mongoose-cast-aggregation) to enable minimal casting for aggregation pipelines.\n * - The documents returned are plain javascript objects, not mongoose documents (since any shape of document can be returned).\n *\n * #### More About Aggregations:\n *\n * - [Mongoose `Aggregate`](https://mongoosejs.com/docs/api/aggregate.html)\n * - [An Introduction to Mongoose Aggregate](https://masteringjs.io/tutorials/mongoose/aggregate)\n * - [MongoDB Aggregation docs](https://www.mongodb.com/docs/manual/applications/aggregation/)\n *\n * @see Aggregate https://mongoosejs.com/docs/api/aggregate.html#Aggregate()\n * @see MongoDB https://www.mongodb.com/docs/manual/applications/aggregation/\n * @param {Array} [pipeline] aggregation pipeline as an array of objects\n * @param {Object} [options] aggregation options\n * @return {Aggregate}\n * @api public\n */\n\nModel.aggregate = function aggregate(pipeline, options) {\n  _checkContext(this, 'aggregate');\n\n  if (typeof options === 'function' || typeof arguments[2] === 'function') {\n    throw new MongooseError('Model.aggregate() no longer accepts a callback');\n  }\n\n  const aggregate = new Aggregate(pipeline || []);\n  aggregate.model(this);\n  if (options != null) {\n    aggregate.option(options);\n  }\n\n  if (typeof callback === 'undefined') {\n    return aggregate;\n  }\n\n  return aggregate;\n};\n\n/**\n * Casts and validates the given object against this model's schema, passing the\n * given `context` to custom validators.\n *\n * #### Example:\n *\n *     const Model = mongoose.model('Test', Schema({\n *       name: { type: String, required: true },\n *       age: { type: Number, required: true }\n *     });\n *\n *     try {\n *       await Model.validate({ name: null }, ['name'])\n *     } catch (err) {\n *       err instanceof mongoose.Error.ValidationError; // true\n *       Object.keys(err.errors); // ['name']\n *     }\n *\n * @param {Object} obj\n * @param {Object|Array|String} pathsOrOptions\n * @param {Object} [context]\n * @return {Promise<Object>} casted and validated copy of `obj` if validation succeeded\n * @api public\n */\n\nModel.validate = async function validate(obj, pathsOrOptions, context) {\n  if ((arguments.length < 3) || (arguments.length === 3 && typeof arguments[2] === 'function')) {\n    // For convenience, if we're validating a document or an object, make `context` default to\n    // the model so users don't have to always pass `context`, re: gh-10132, gh-10346\n    context = obj;\n  }\n  if (typeof context === 'function' || typeof arguments[3] === 'function') {\n    throw new MongooseError('Model.validate() no longer accepts a callback');\n  }\n\n  let schema = this.schema;\n  const discriminatorKey = schema.options.discriminatorKey;\n  if (schema.discriminators != null && obj != null && obj[discriminatorKey] != null) {\n    schema = getSchemaDiscriminatorByValue(schema, obj[discriminatorKey]) || schema;\n  }\n  let paths = Object.keys(schema.paths);\n\n  if (pathsOrOptions != null) {\n    const _pathsToValidate = typeof pathsOrOptions === 'string' ? new Set(pathsOrOptions.split(' ')) : Array.isArray(pathsOrOptions) ? new Set(pathsOrOptions) : new Set(paths);\n    paths = paths.filter(p => {\n      if (pathsOrOptions.pathsToSkip) {\n        if (Array.isArray(pathsOrOptions.pathsToSkip)) {\n          if (pathsOrOptions.pathsToSkip.find(x => x == p)) {\n            return false;\n          }\n        } else if (typeof pathsOrOptions.pathsToSkip == 'string') {\n          if (pathsOrOptions.pathsToSkip.includes(p)) {\n            return false;\n          }\n        }\n      }\n      const pieces = p.split('.');\n      let cur = pieces[0];\n\n      for (const piece of pieces) {\n        if (_pathsToValidate.has(cur)) {\n          return true;\n        }\n        cur += '.' + piece;\n      }\n\n      return _pathsToValidate.has(p);\n    });\n  }\n\n  for (const path of paths) {\n    const schemaType = schema.path(path);\n    if (!schemaType || !schemaType.$isMongooseArray || schemaType.$isMongooseDocumentArray) {\n      continue;\n    }\n\n    const val = get(obj, path);\n    pushNestedArrayPaths(paths, val, path);\n  }\n\n  let error = null;\n  paths = new Set(paths);\n\n  try {\n    obj = this.castObject(obj);\n  } catch (err) {\n    error = err;\n    for (const key of Object.keys(error.errors || {})) {\n      paths.delete(key);\n    }\n  }\n\n  let remaining = paths.size;\n\n  return new Promise((resolve, reject) => {\n    for (const path of paths) {\n      const schemaType = schema.path(path);\n      if (schemaType == null) {\n        _checkDone();\n        continue;\n      }\n\n      const pieces = path.indexOf('.') === -1 ? [path] : path.split('.');\n      let cur = obj;\n      for (let i = 0; i < pieces.length - 1; ++i) {\n        cur = cur[pieces[i]];\n      }\n\n      const val = get(obj, path, void 0);\n\n      schemaType.doValidate(val, err => {\n        if (err) {\n          error = error || new ValidationError();\n          error.addError(path, err);\n        }\n        _checkDone();\n      }, context, { path: path });\n    }\n\n    function _checkDone() {\n      if (--remaining <= 0) {\n        if (error) {\n          reject(error);\n        } else {\n          resolve(obj);\n        }\n      }\n    }\n  });\n};\n\n/**\n * Populates document references.\n *\n * Changed in Mongoose 6: the model you call `populate()` on should be the\n * \"local field\" model, **not** the \"foreign field\" model.\n *\n * #### Available top-level options:\n *\n * - path: space delimited path(s) to populate\n * - select: optional fields to select\n * - match: optional query conditions to match\n * - model: optional name of the model to use for population\n * - options: optional query options like sort, limit, etc\n * - justOne: optional boolean, if true Mongoose will always set `path` to a document, or `null` if no document was found. If false, Mongoose will always set `path` to an array, which will be empty if no documents are found. Inferred from schema by default.\n * - strictPopulate: optional boolean, set to `false` to allow populating paths that aren't in the schema.\n *\n * #### Example:\n *\n *     const Dog = mongoose.model('Dog', new Schema({ name: String, breed: String }));\n *     const Person = mongoose.model('Person', new Schema({\n *       name: String,\n *       pet: { type: mongoose.ObjectId, ref: 'Dog' }\n *     }));\n *\n *     const pets = await Pet.create([\n *       { name: 'Daisy', breed: 'Beagle' },\n *       { name: 'Einstein', breed: 'Catalan Sheepdog' }\n *     ]);\n *\n *     // populate many plain objects\n *     const users = [\n *       { name: 'John Wick', dog: pets[0]._id },\n *       { name: 'Doc Brown', dog: pets[1]._id }\n *     ];\n *     await User.populate(users, { path: 'dog', select: 'name' });\n *     users[0].dog.name; // 'Daisy'\n *     users[0].dog.breed; // undefined because of `select`\n *\n * @param {Document|Array} docs Either a single document or array of documents to populate.\n * @param {Object|String} options Either the paths to populate or an object specifying all parameters\n * @param {string} [options.path=null] The path to populate.\n * @param {string|PopulateOptions} [options.populate=null] Recursively populate paths in the populated documents. See [deep populate docs](https://mongoosejs.com/docs/populate.html#deep-populate).\n * @param {boolean} [options.retainNullValues=false] By default, Mongoose removes null and undefined values from populated arrays. Use this option to make `populate()` retain `null` and `undefined` array entries.\n * @param {boolean} [options.getters=false] If true, Mongoose will call any getters defined on the `localField`. By default, Mongoose gets the raw value of `localField`. For example, you would need to set this option to `true` if you wanted to [add a `lowercase` getter to your `localField`](https://mongoosejs.com/docs/schematypes.html#schematype-options).\n * @param {boolean} [options.clone=false] When you do `BlogPost.find().populate('author')`, blog posts with the same author will share 1 copy of an `author` doc. Enable this option to make Mongoose clone populated docs before assigning them.\n * @param {Object|Function} [options.match=null] Add an additional filter to the populate query. Can be a filter object containing [MongoDB query syntax](https://www.mongodb.com/docs/manual/tutorial/query-documents/), or a function that returns a filter object.\n * @param {Boolean} [options.skipInvalidIds=false] By default, Mongoose throws a cast error if `localField` and `foreignField` schemas don't line up. If you enable this option, Mongoose will instead filter out any `localField` properties that cannot be casted to `foreignField`'s schema type.\n * @param {Number} [options.perDocumentLimit=null] For legacy reasons, `limit` with `populate()` may give incorrect results because it only executes a single query for every document being populated. If you set `perDocumentLimit`, Mongoose will ensure correct `limit` per document by executing a separate query for each document to `populate()`. For example, `.find().populate({ path: 'test', perDocumentLimit: 2 })` will execute 2 additional queries if `.find()` returns 2 documents.\n * @param {Boolean} [options.strictPopulate=true] Set to false to allow populating paths that aren't defined in the given model's schema.\n * @param {Object} [options.options=null] Additional options like `limit` and `lean`.\n * @param {Function} [options.transform=null] Function that Mongoose will call on every populated document that allows you to transform the populated document.\n * @param {Function} [callback(err,doc)] Optional callback, executed upon completion. Receives `err` and the `doc(s)`.\n * @return {Promise}\n * @api public\n */\n\nModel.populate = async function populate(docs, paths) {\n  _checkContext(this, 'populate');\n  if (typeof paths === 'function' || typeof arguments[2] === 'function') {\n    throw new MongooseError('Model.populate() no longer accepts a callback');\n  }\n  const _this = this;\n  // normalized paths\n  paths = utils.populate(paths);\n  // data that should persist across subPopulate calls\n  const cache = {};\n\n  return new Promise((resolve, reject) => {\n    _populate(_this, docs, paths, cache, (err, res) => {\n      if (err) {\n        return reject(err);\n      }\n      resolve(res);\n    });\n  });\n};\n\n/**\n * Populate helper\n *\n * @param {Model} model the model to use\n * @param {Document|Array} docs Either a single document or array of documents to populate.\n * @param {Object} paths\n * @param {never} cache Unused\n * @param {Function} [callback] Optional callback, executed upon completion. Receives `err` and the `doc(s)`.\n * @return {Function}\n * @api private\n */\n\nfunction _populate(model, docs, paths, cache, callback) {\n  let pending = paths.length;\n  if (paths.length === 0) {\n    return callback(null, docs);\n  }\n  // each path has its own query options and must be executed separately\n  for (const path of paths) {\n    populate(model, docs, path, next);\n  }\n\n  function next(err) {\n    if (err) {\n      return callback(err, null);\n    }\n    if (--pending) {\n      return;\n    }\n    callback(null, docs);\n  }\n}\n\n/*!\n * Populates `docs`\n */\nconst excludeIdReg = /\\s?-_id\\s?/;\nconst excludeIdRegGlobal = /\\s?-_id\\s?/g;\n\nfunction populate(model, docs, options, callback) {\n  const populateOptions = options;\n  if (options.strictPopulate == null) {\n    if (options._localModel != null && options._localModel.schema._userProvidedOptions.strictPopulate != null) {\n      populateOptions.strictPopulate = options._localModel.schema._userProvidedOptions.strictPopulate;\n    } else if (options._localModel != null && model.base.options.strictPopulate != null) {\n      populateOptions.strictPopulate = model.base.options.strictPopulate;\n    } else if (model.base.options.strictPopulate != null) {\n      populateOptions.strictPopulate = model.base.options.strictPopulate;\n    }\n  }\n\n  // normalize single / multiple docs passed\n  if (!Array.isArray(docs)) {\n    docs = [docs];\n  }\n  if (docs.length === 0 || docs.every(utils.isNullOrUndefined)) {\n    return callback();\n  }\n\n  const modelsMap = getModelsMapForPopulate(model, docs, populateOptions);\n\n  if (modelsMap instanceof MongooseError) {\n    return immediate(function() {\n      callback(modelsMap);\n    });\n  }\n  const len = modelsMap.length;\n  let vals = [];\n\n  function flatten(item) {\n    // no need to include undefined values in our query\n    return undefined !== item;\n  }\n\n  let _remaining = len;\n  let hasOne = false;\n  const params = [];\n  for (let i = 0; i < len; ++i) {\n    const mod = modelsMap[i];\n    let select = mod.options.select;\n    let ids = utils.array.flatten(mod.ids, flatten);\n    ids = utils.array.unique(ids);\n\n    const assignmentOpts = {};\n    assignmentOpts.sort = mod &&\n      mod.options &&\n      mod.options.options &&\n      mod.options.options.sort || void 0;\n    assignmentOpts.excludeId = excludeIdReg.test(select) || (select && select._id === 0);\n\n    // Lean transform may delete `_id`, which would cause assignment\n    // to fail. So delay running lean transform until _after_\n    // `_assign()`\n    if (mod.options &&\n        mod.options.options &&\n        mod.options.options.lean &&\n        mod.options.options.lean.transform) {\n      mod.options.options._leanTransform = mod.options.options.lean.transform;\n      mod.options.options.lean = true;\n    }\n\n    if (ids.length === 0 || ids.every(utils.isNullOrUndefined)) {\n      // Ensure that we set to 0 or empty array even\n      // if we don't actually execute a query to make sure there's a value\n      // and we know this path was populated for future sets. See gh-7731, gh-8230\n      --_remaining;\n      _assign(model, [], mod, assignmentOpts);\n      continue;\n    }\n\n    hasOne = true;\n    if (typeof populateOptions.foreignField === 'string') {\n      mod.foreignField.clear();\n      mod.foreignField.add(populateOptions.foreignField);\n    }\n    const match = createPopulateQueryFilter(ids, mod.match, mod.foreignField, mod.model, mod.options.skipInvalidIds);\n    if (assignmentOpts.excludeId) {\n      // override the exclusion from the query so we can use the _id\n      // for document matching during assignment. we'll delete the\n      // _id back off before returning the result.\n      if (typeof select === 'string') {\n        select = select.replace(excludeIdRegGlobal, ' ');\n      } else if (Array.isArray(select)) {\n        select = select.filter(field => field !== '-_id');\n      } else {\n        // preserve original select conditions by copying\n        select = { ...select };\n        delete select._id;\n      }\n    }\n\n    if (mod.options.options && mod.options.options.limit != null) {\n      assignmentOpts.originalLimit = mod.options.options.limit;\n    } else if (mod.options.limit != null) {\n      assignmentOpts.originalLimit = mod.options.limit;\n    }\n    params.push([mod, match, select, assignmentOpts, _next]);\n  }\n  if (!hasOne) {\n    // If models but no docs, skip further deep populate.\n    if (modelsMap.length !== 0) {\n      return callback();\n    }\n    // If no models to populate but we have a nested populate,\n    // keep trying, re: gh-8946\n    if (populateOptions.populate != null) {\n      const opts = utils.populate(populateOptions.populate).map(pop => Object.assign({}, pop, {\n        path: populateOptions.path + '.' + pop.path\n      }));\n      model.populate(docs, opts).then(res => { callback(null, res); }, err => { callback(err); });\n      return;\n    }\n    return callback();\n  }\n\n  for (const arr of params) {\n    _execPopulateQuery.apply(null, arr);\n  }\n  function _next(err, valsFromDb) {\n    if (err != null) {\n      return callback(err, null);\n    }\n    vals = vals.concat(valsFromDb);\n    if (--_remaining === 0) {\n      _done();\n    }\n  }\n\n  function _done() {\n    for (const arr of params) {\n      const mod = arr[0];\n      const assignmentOpts = arr[3];\n      for (const val of vals) {\n        mod.options._childDocs.push(val);\n      }\n      try {\n        _assign(model, vals, mod, assignmentOpts);\n      } catch (err) {\n        return callback(err);\n      }\n    }\n\n    for (const arr of params) {\n      removeDeselectedForeignField(arr[0].foreignField, arr[0].options, vals);\n    }\n    for (const arr of params) {\n      const mod = arr[0];\n      if (mod.options && mod.options.options && mod.options.options._leanTransform) {\n        for (const doc of vals) {\n          mod.options.options._leanTransform(doc);\n        }\n      }\n    }\n    callback();\n  }\n}\n\n/*!\n * ignore\n */\n\nfunction _execPopulateQuery(mod, match, select, assignmentOpts, callback) {\n  let subPopulate = clone(mod.options.populate);\n  const queryOptions = Object.assign({\n    skip: mod.options.skip,\n    limit: mod.options.limit,\n    perDocumentLimit: mod.options.perDocumentLimit\n  }, mod.options.options);\n\n  if (mod.count) {\n    delete queryOptions.skip;\n  }\n\n  if (queryOptions.perDocumentLimit != null) {\n    queryOptions.limit = queryOptions.perDocumentLimit;\n    delete queryOptions.perDocumentLimit;\n  } else if (queryOptions.limit != null) {\n    queryOptions.limit = queryOptions.limit * mod.ids.length;\n  }\n\n  const query = mod.model.find(match, select, queryOptions);\n  // If we're doing virtual populate and projection is inclusive and foreign\n  // field is not selected, automatically select it because mongoose needs it.\n  // If projection is exclusive and client explicitly unselected the foreign\n  // field, that's the client's fault.\n  for (const foreignField of mod.foreignField) {\n    if (foreignField !== '_id' &&\n        query.selectedInclusively() &&\n        !isPathSelectedInclusive(query._fields, foreignField)) {\n      query.select(foreignField);\n    }\n  }\n\n  // If using count, still need the `foreignField` so we can match counts\n  // to documents, otherwise we would need a separate `count()` for every doc.\n  if (mod.count) {\n    for (const foreignField of mod.foreignField) {\n      query.select(foreignField);\n    }\n  }\n\n  // If we need to sub-populate, call populate recursively\n  if (subPopulate) {\n    // If subpopulating on a discriminator, skip check for non-existent\n    // paths. Because the discriminator may not have the path defined.\n    if (mod.model.baseModelName != null) {\n      if (Array.isArray(subPopulate)) {\n        subPopulate.forEach(pop => { pop.strictPopulate = false; });\n      } else if (typeof subPopulate === 'string') {\n        subPopulate = { path: subPopulate, strictPopulate: false };\n      } else {\n        subPopulate.strictPopulate = false;\n      }\n    }\n    const basePath = mod.options._fullPath || mod.options.path;\n\n    if (Array.isArray(subPopulate)) {\n      for (const pop of subPopulate) {\n        pop._fullPath = basePath + '.' + pop.path;\n      }\n    } else if (typeof subPopulate === 'object') {\n      subPopulate._fullPath = basePath + '.' + subPopulate.path;\n    }\n\n    query.populate(subPopulate);\n  }\n\n  query.exec().then(\n    docs => {\n      for (const val of docs) {\n        leanPopulateMap.set(val, mod.model);\n      }\n      callback(null, docs);\n    },\n    err => {\n      callback(err);\n    }\n  );\n}\n\n/*!\n * ignore\n */\n\nfunction _assign(model, vals, mod, assignmentOpts) {\n  const options = mod.options;\n  const isVirtual = mod.isVirtual;\n  const justOne = mod.justOne;\n  let _val;\n  const lean = options &&\n    options.options &&\n    options.options.lean || false;\n  const len = vals.length;\n  const rawOrder = {};\n  const rawDocs = {};\n  let key;\n  let val;\n\n  // Clone because `assignRawDocsToIdStructure` will mutate the array\n  const allIds = clone(mod.allIds);\n  // optimization:\n  // record the document positions as returned by\n  // the query result.\n  for (let i = 0; i < len; i++) {\n    val = vals[i];\n    if (val == null) {\n      continue;\n    }\n    for (const foreignField of mod.foreignField) {\n      _val = utils.getValue(foreignField, val);\n      if (Array.isArray(_val)) {\n        _val = utils.array.unique(utils.array.flatten(_val));\n\n        for (let __val of _val) {\n          if (__val instanceof Document) {\n            __val = __val._id;\n          }\n          key = String(__val);\n          if (rawDocs[key]) {\n            if (Array.isArray(rawDocs[key])) {\n              rawDocs[key].push(val);\n              rawOrder[key].push(i);\n            } else {\n              rawDocs[key] = [rawDocs[key], val];\n              rawOrder[key] = [rawOrder[key], i];\n            }\n          } else {\n            if (isVirtual && !justOne) {\n              rawDocs[key] = [val];\n              rawOrder[key] = [i];\n            } else {\n              rawDocs[key] = val;\n              rawOrder[key] = i;\n            }\n          }\n        }\n      } else {\n        if (_val instanceof Document) {\n          _val = _val._id;\n        }\n        key = String(_val);\n        if (rawDocs[key]) {\n          if (Array.isArray(rawDocs[key])) {\n            rawDocs[key].push(val);\n            rawOrder[key].push(i);\n          } else if (isVirtual ||\n            rawDocs[key].constructor !== val.constructor ||\n            String(rawDocs[key]._id) !== String(val._id)) {\n            // May need to store multiple docs with the same id if there's multiple models\n            // if we have discriminators or a ref function. But avoid converting to an array\n            // if we have multiple queries on the same model because of `perDocumentLimit` re: gh-9906\n            rawDocs[key] = [rawDocs[key], val];\n            rawOrder[key] = [rawOrder[key], i];\n          }\n        } else {\n          rawDocs[key] = val;\n          rawOrder[key] = i;\n        }\n      }\n      // flag each as result of population\n      if (!lean) {\n        val.$__.wasPopulated = val.$__.wasPopulated || true;\n      }\n    }\n  }\n\n  assignVals({\n    originalModel: model,\n    // If virtual, make sure to not mutate original field\n    rawIds: mod.isVirtual ? allIds : mod.allIds,\n    allIds: allIds,\n    unpopulatedValues: mod.unpopulatedValues,\n    foreignField: mod.foreignField,\n    rawDocs: rawDocs,\n    rawOrder: rawOrder,\n    docs: mod.docs,\n    path: options.path,\n    options: assignmentOpts,\n    justOne: mod.justOne,\n    isVirtual: mod.isVirtual,\n    allOptions: mod,\n    populatedModel: mod.model,\n    lean: lean,\n    virtual: mod.virtual,\n    count: mod.count,\n    match: mod.match\n  });\n}\n\n/**\n * Compiler utility.\n *\n * @param {String|Function} name model name or class extending Model\n * @param {Schema} schema\n * @param {String} collectionName\n * @param {Connection} connection\n * @param {Mongoose} base mongoose instance\n * @api private\n */\n\nModel.compile = function compile(name, schema, collectionName, connection, base) {\n  const versioningEnabled = schema.options.versionKey !== false;\n\n  if (versioningEnabled && !schema.paths[schema.options.versionKey]) {\n    // add versioning to top level documents only\n    const o = {};\n    o[schema.options.versionKey] = Number;\n    schema.add(o);\n  }\n  let model;\n  if (typeof name === 'function' && name.prototype instanceof Model) {\n    model = name;\n    name = model.name;\n    schema.loadClass(model, false);\n    model.prototype.$isMongooseModelPrototype = true;\n  } else {\n    // generate new class\n    model = function model(doc, fields, skipId) {\n      model.hooks.execPreSync('createModel', doc);\n      if (!(this instanceof model)) {\n        return new model(doc, fields, skipId);\n      }\n      const discriminatorKey = model.schema.options.discriminatorKey;\n\n      if (model.discriminators == null || doc == null || doc[discriminatorKey] == null) {\n        Model.call(this, doc, fields, skipId);\n        return;\n      }\n\n      // If discriminator key is set, use the discriminator instead (gh-7586)\n      const Discriminator = model.discriminators[doc[discriminatorKey]] ||\n        getDiscriminatorByValue(model.discriminators, doc[discriminatorKey]);\n      if (Discriminator != null) {\n        return new Discriminator(doc, fields, skipId);\n      }\n\n      // Otherwise, just use the top-level model\n      Model.call(this, doc, fields, skipId);\n    };\n  }\n\n  model.hooks = schema.s.hooks.clone();\n  model.base = base;\n  model.modelName = name;\n\n  if (!(model.prototype instanceof Model)) {\n    Object.setPrototypeOf(model, Model);\n    Object.setPrototypeOf(model.prototype, Model.prototype);\n  }\n  model.model = function model(name) {\n    return this.db.model(name);\n  };\n\n  model.db = connection;\n  model.prototype.db = connection;\n  model.prototype[modelDbSymbol] = connection;\n  model.discriminators = model.prototype.discriminators = undefined;\n  model[modelSymbol] = true;\n  model.events = new EventEmitter();\n\n  schema._preCompile();\n\n  const _userProvidedOptions = schema._userProvidedOptions || {};\n\n  const collectionOptions = {\n    schemaUserProvidedOptions: _userProvidedOptions,\n    capped: schema.options.capped,\n    Promise: model.base.Promise,\n    modelName: name\n  };\n  if (schema.options.autoCreate !== void 0) {\n    collectionOptions.autoCreate = schema.options.autoCreate;\n  }\n\n  const collection = connection.collection(\n    collectionName,\n    collectionOptions\n  );\n\n  model.prototype.collection = collection;\n  model.prototype.$collection = collection;\n  model.prototype[modelCollectionSymbol] = collection;\n\n  model.prototype.$__setSchema(schema);\n\n  // apply methods and statics\n  applyMethods(model, schema);\n  applyStatics(model, schema);\n  applyHooks(model, schema);\n  applyStaticHooks(model, schema.s.hooks, schema.statics);\n\n  model.schema = model.prototype.$__schema;\n  model.collection = collection;\n  model.$__collection = collection;\n\n  // Create custom query constructor\n  model.Query = function() {\n    Query.apply(this, arguments);\n  };\n  Object.setPrototypeOf(model.Query.prototype, Query.prototype);\n  model.Query.base = Query.base;\n  model.Query.prototype.constructor = Query;\n  model._applyQueryMiddleware();\n  applyQueryMethods(model, schema.query);\n\n  return model;\n};\n\n/**\n * Register custom query methods for this model\n *\n * @param {Model} model\n * @param {Schema} schema\n * @api private\n */\n\nfunction applyQueryMethods(model, methods) {\n  for (const i in methods) {\n    model.Query.prototype[i] = methods[i];\n  }\n}\n\n/**\n * Subclass this model with `conn`, `schema`, and `collection` settings.\n *\n * @param {Connection} conn\n * @param {Schema} [schema]\n * @param {String} [collection]\n * @return {Model}\n * @api private\n * @memberOf Model\n * @static\n * @method __subclass\n */\n\nModel.__subclass = function subclass(conn, schema, collection) {\n  // subclass model using this connection and collection name\n  const _this = this;\n\n  const Model = function Model(doc, fields, skipId) {\n    if (!(this instanceof Model)) {\n      return new Model(doc, fields, skipId);\n    }\n    _this.call(this, doc, fields, skipId);\n  };\n\n  Object.setPrototypeOf(Model, _this);\n  Object.setPrototypeOf(Model.prototype, _this.prototype);\n  Model.db = conn;\n  Model.prototype.db = conn;\n  Model.prototype[modelDbSymbol] = conn;\n\n  _this[subclassedSymbol] = _this[subclassedSymbol] || [];\n  _this[subclassedSymbol].push(Model);\n  if (_this.discriminators != null) {\n    Model.discriminators = {};\n    for (const key of Object.keys(_this.discriminators)) {\n      Model.discriminators[key] = _this.discriminators[key].\n        __subclass(_this.db, _this.discriminators[key].schema, collection);\n    }\n  }\n\n  const s = schema && typeof schema !== 'string'\n    ? schema\n    : _this.prototype.$__schema;\n\n  const options = s.options || {};\n  const _userProvidedOptions = s._userProvidedOptions || {};\n\n  if (!collection) {\n    collection = _this.prototype.$__schema.get('collection') ||\n      utils.toCollectionName(_this.modelName, this.base.pluralize());\n  }\n\n  const collectionOptions = {\n    schemaUserProvidedOptions: _userProvidedOptions,\n    capped: s && options.capped\n  };\n\n  Model.prototype.collection = conn.collection(collection, collectionOptions);\n  Model.prototype.$collection = Model.prototype.collection;\n  Model.prototype[modelCollectionSymbol] = Model.prototype.collection;\n  Model.collection = Model.prototype.collection;\n  Model.$__collection = Model.collection;\n  // Errors handled internally, so ignore\n  Model.init().catch(() => {});\n  return Model;\n};\n\n/**\n * Apply changes made to this model's schema after this model was compiled.\n * By default, adding virtuals and other properties to a schema after the model is compiled does nothing.\n * Call this function to apply virtuals and properties that were added later.\n *\n * #### Example:\n *\n *     const schema = new mongoose.Schema({ field: String });\n *     const TestModel = mongoose.model('Test', schema);\n *     TestModel.schema.virtual('myVirtual').get(function() {\n *       return this.field + ' from myVirtual';\n *     });\n *     const doc = new TestModel({ field: 'Hello' });\n *     doc.myVirtual; // undefined\n *\n *     TestModel.recompileSchema();\n *     doc.myVirtual; // 'Hello from myVirtual'\n *\n * @return {undefined}\n * @api public\n * @memberOf Model\n * @static\n * @method recompileSchema\n */\n\nModel.recompileSchema = function recompileSchema() {\n  this.prototype.$__setSchema(this.schema);\n};\n\n/**\n * Helper for console.log. Given a model named 'MyModel', returns the string\n * `'Model { MyModel }'`.\n *\n * #### Example:\n *\n *     const MyModel = mongoose.model('Test', Schema({ name: String }));\n *     MyModel.inspect(); // 'Model { Test }'\n *     console.log(MyModel); // Prints 'Model { Test }'\n *\n * @api public\n */\n\nModel.inspect = function() {\n  return `Model { ${this.modelName} }`;\n};\n\nif (util.inspect.custom) {\n  // Avoid Node deprecation warning DEP0079\n  Model[util.inspect.custom] = Model.inspect;\n}\n\n/*!\n * Applies query middleware from this model's schema to this model's\n * Query constructor.\n */\n\nModel._applyQueryMiddleware = function _applyQueryMiddleware() {\n  const Query = this.Query;\n  const queryMiddleware = this.schema.s.hooks.filter(hook => {\n    const contexts = _getContexts(hook);\n    if (hook.name === 'validate') {\n      return !!contexts.query;\n    }\n    if (hook.name === 'deleteOne' || hook.name === 'updateOne') {\n      return !!contexts.query || Object.keys(contexts).length === 0;\n    }\n    if (hook.query != null || hook.document != null) {\n      return !!hook.query;\n    }\n    return true;\n  });\n\n  Query.prototype._queryMiddleware = queryMiddleware;\n};\n\nfunction _getContexts(hook) {\n  const ret = {};\n  if (hook.hasOwnProperty('query')) {\n    ret.query = hook.query;\n  }\n  if (hook.hasOwnProperty('document')) {\n    ret.document = hook.document;\n  }\n  return ret;\n}\n\n/*!\n * Module exports.\n */\n\nmodule.exports = exports = Model;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvbW9kZWwuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7QUFDQTtBQUNBOztBQUVBLGtCQUFrQixtQkFBTyxDQUFDLHFFQUFhO0FBQ3ZDLHFCQUFxQixtQkFBTyxDQUFDLHlGQUF1QjtBQUNwRCxpQkFBaUIsbUJBQU8sQ0FBQyxtRUFBWTtBQUNyQyw4QkFBOEIsbUJBQU8sQ0FBQywrRUFBa0I7QUFDeEQsNEJBQTRCLG1CQUFPLENBQUMsMkZBQXdCO0FBQzVELHFCQUFxQiwwREFBOEI7QUFDbkQsZUFBZSxtQkFBTyxDQUFDLHNEQUFRO0FBQy9CLHVCQUF1QixtQkFBTyxDQUFDLDJFQUFnQjtBQUMvQyxzQkFBc0IsbUJBQU8sQ0FBQyx5RUFBZTtBQUM3Qyw2QkFBNkIsbUJBQU8sQ0FBQyw2RkFBeUI7QUFDOUQsNEJBQTRCLG1CQUFPLENBQUMsMkZBQXdCO0FBQzVELGNBQWMsbUJBQU8sQ0FBQyw2REFBUztBQUMvQixvQkFBb0IsbUJBQU8sQ0FBQyx5RkFBdUI7QUFDbkQsZUFBZSxtQkFBTyxDQUFDLCtEQUFVO0FBQ2pDLHdCQUF3QixtQkFBTyxDQUFDLG1GQUFvQjtBQUNwRCxxQkFBcUIsbUJBQU8sQ0FBQyw2RUFBaUI7QUFDOUMsMEJBQTBCLG1CQUFPLENBQUMsdUZBQXNCO0FBQ3hELDRCQUE0QixtQkFBTyxDQUFDLCtHQUFrQztBQUN0RSw0QkFBNEIsbUJBQU8sQ0FBQyxxSEFBcUM7QUFDekUsbUJBQW1CLG1CQUFPLENBQUMsbUdBQTRCO0FBQ3ZELHFCQUFxQixtQkFBTyxDQUFDLHVHQUE4QjtBQUMzRCx3QkFBd0IsbUJBQU8sQ0FBQyx1SEFBc0M7QUFDdEUsNkJBQTZCLG1CQUFPLENBQUMsMkhBQXdDO0FBQzdFLHlCQUF5QixtQkFBTyxDQUFDLCtHQUFrQztBQUNuRSxxQkFBcUIsbUJBQU8sQ0FBQyx1R0FBOEI7QUFDM0QsMEJBQTBCLG1CQUFPLENBQUMsbUhBQW9DO0FBQ3RFLG1CQUFtQixtQkFB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QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsNkJBQTZCO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0Esb0RBQW9EO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qiw2QkFBNkI7QUFDdEQsT0FBTztB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esc0JBQXNCOztBQUV0QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0EsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSwr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QTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxHQUFHOzs7QUFHSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFD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Q0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGlCQUFpQjtBQUM1QixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsWUFBWTtBQUN2QixXQUFXLFVBQVU7QUFDckI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLFFBQVE7QUFDbkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsWUFBWTtBQUN2QixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsZUFBZTtBQUMzRDtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1IsbUNBQW1DLGdCQUFnQjtBQUNuRCxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCxjQUFjO0FBQ3JFLDBCQUEwQixZQUFZLE1BQU07QUFDNUMsNkJBQTZCLG1CQUFtQixNQUFNO0FBQ3REO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQixFQUFFLGlCQUFpQjtBQUNyQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL2NsaWVudC8uLi9zZXJ2ZXIvbm9kZV9tb2R1bGVzL21vbmdvb3NlL2xpYi9tb2RlbC5qcz8zMjVlIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuLyohXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbmNvbnN0IEFnZ3JlZ2F0ZSA9IHJlcXVpcmUoJy4vYWdncmVnYXRlJyk7XG5jb25zdCBDaGFuZ2VTdHJlYW0gPSByZXF1aXJlKCcuL2N1cnNvci9jaGFuZ2VTdHJlYW0nKTtcbmNvbnN0IERvY3VtZW50ID0gcmVxdWlyZSgnLi9kb2N1bWVudCcpO1xuY29uc3QgRG9jdW1lbnROb3RGb3VuZEVycm9yID0gcmVxdWlyZSgnLi9lcnJvci9ub3RGb3VuZCcpO1xuY29uc3QgRGl2ZXJnZW50QXJyYXlFcnJvciA9IHJlcXVpcmUoJy4vZXJyb3IvZGl2ZXJnZW50QXJyYXknKTtcbmNvbnN0IEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcbmNvbnN0IEthcmVlbSA9IHJlcXVpcmUoJ2thcmVlbScpO1xuY29uc3QgTW9uZ29vc2VCdWZmZXIgPSByZXF1aXJlKCcuL3R5cGVzL2J1ZmZlcicpO1xuY29uc3QgTW9uZ29vc2VFcnJvciA9IHJlcXVpcmUoJy4vZXJyb3IvaW5kZXgnKTtcbmNvbnN0IE9iamVjdFBhcmFtZXRlckVycm9yID0gcmVxdWlyZSgnLi9lcnJvci9vYmplY3RQYXJhbWV0ZXInKTtcbmNvbnN0IE92ZXJ3cml0ZU1vZGVsRXJyb3IgPSByZXF1aXJlKCcuL2Vycm9yL292ZXJ3cml0ZU1vZGVsJyk7XG5jb25zdCBRdWVyeSA9IHJlcXVpcmUoJy4vcXVlcnknKTtcbmNvbnN0IFNhdmVPcHRpb25zID0gcmVxdWlyZSgnLi9vcHRpb25zL3NhdmVPcHRpb25zJyk7XG5jb25zdCBTY2hlbWEgPSByZXF1aXJlKCcuL3NjaGVtYScpO1xuY29uc3QgVmFsaWRhdGlvbkVycm9yID0gcmVxdWlyZSgnLi9lcnJvci92YWxpZGF0aW9uJyk7XG5jb25zdCBWZXJzaW9uRXJyb3IgPSByZXF1aXJlKCcuL2Vycm9yL3ZlcnNpb24nKTtcbmNvbnN0IFBhcmFsbGVsU2F2ZUVycm9yID0gcmVxdWlyZSgnLi9lcnJvci9wYXJhbGxlbFNhdmUnKTtcbmNvbnN0IGFwcGx5RGVmYXVsdHNIZWxwZXIgPSByZXF1aXJlKCcuL2hlbHBlcnMvZG9jdW1lbnQvYXBwbHlEZWZhdWx0cycpO1xuY29uc3QgYXBwbHlEZWZhdWx0c1RvUE9KTyA9IHJlcXVpcmUoJy4vaGVscGVycy9tb2RlbC9hcHBseURlZmF1bHRzVG9QT0pPJyk7XG5jb25zdCBhcHBseUhvb2tzID0gcmVxdWlyZSgnLi9oZWxwZXJzL21vZGVsL2FwcGx5SG9va3MnKTtcbmNvbnN0IGFwcGx5TWV0aG9kcyA9IHJlcXVpcmUoJy4vaGVscGVycy9tb2RlbC9hcHBseU1ldGhvZHMnKTtcbmNvbnN0IGFwcGx5UHJvamVjdGlvbiA9IHJlcXVpcmUoJy4vaGVscGVycy9wcm9qZWN0aW9uL2FwcGx5UHJvamVjdGlvbicpO1xuY29uc3QgYXBwbHlTY2hlbWFDb2xsYXRpb24gPSByZXF1aXJlKCcuL2hlbHBlcnMvaW5kZXhlcy9hcHBseVNjaGVtYUNvbGxhdGlvbicpO1xuY29uc3QgYXBwbHlTdGF0aWNIb29rcyA9IHJlcXVpcmUoJy4vaGVscGVycy9tb2RlbC9hcHBseVN0YXRpY0hvb2tzJyk7XG5jb25zdCBhcHBseVN0YXRpY3MgPSByZXF1aXJlKCcuL2hlbHBlcnMvbW9kZWwvYXBwbHlTdGF0aWNzJyk7XG5jb25zdCBhcHBseVdyaXRlQ29uY2VybiA9IHJlcXVpcmUoJy4vaGVscGVycy9zY2hlbWEvYXBwbHlXcml0ZUNvbmNlcm4nKTtcbmNvbnN0IGFzc2lnblZhbHMgPSByZXF1aXJlKCcuL2hlbHBlcnMvcG9wdWxhdGUvYXNzaWduVmFscycpO1xuY29uc3QgY2FzdEJ1bGtXcml0ZSA9IHJlcXVpcmUoJy4vaGVscGVycy9tb2RlbC9jYXN0QnVsa1dyaXRlJyk7XG5jb25zdCBjbG9uZSA9IHJlcXVpcmUoJy4vaGVscGVycy9jbG9uZScpO1xuY29uc3QgY3JlYXRlUG9wdWxhdGVRdWVyeUZpbHRlciA9IHJlcXVpcmUoJy4vaGVscGVycy9wb3B1bGF0ZS9jcmVhdGVQb3B1bGF0ZVF1ZXJ5RmlsdGVyJyk7XG5jb25zdCBkZWNvcmF0ZVVwZGF0ZVdpdGhWZXJzaW9uS2V5ID0gcmVxdWlyZSgnLi9oZWxwZXJzL3VwZGF0ZS9kZWNvcmF0ZVVwZGF0ZVdpdGhWZXJzaW9uS2V5Jyk7XG5jb25zdCBnZXREZWZhdWx0QnVsa3dyaXRlUmVzdWx0ID0gcmVxdWlyZSgnLi9oZWxwZXJzL2dldERlZmF1bHRCdWxrd3JpdGVSZXN1bHQnKTtcbmNvbnN0IGdldFNjaGVtYURpc2NyaW1pbmF0b3JCeVZhbHVlID0gcmVxdWlyZSgnLi9oZWxwZXJzL2Rpc2NyaW1pbmF0b3IvZ2V0U2NoZW1hRGlzY3JpbWluYXRvckJ5VmFsdWUnKTtcbmNvbnN0IGRpc2NyaW1pbmF0b3IgPSByZXF1aXJlKCcuL2hlbHBlcnMvbW9kZWwvZGlzY3JpbWluYXRvcicpO1xuY29uc3QgZmlyc3RLZXkgPSByZXF1aXJlKCcuL2hlbHBlcnMvZmlyc3RLZXknKTtcbmNvbnN0IGVhY2ggPSByZXF1aXJlKCcuL2hlbHBlcnMvZWFjaCcpO1xuY29uc3QgZ2V0ID0gcmVxdWlyZSgnLi9oZWxwZXJzL2dldCcpO1xuY29uc3QgZ2V0Q29uc3RydWN0b3JOYW1lID0gcmVxdWlyZSgnLi9oZWxwZXJzL2dldENvbnN0cnVjdG9yTmFtZScpO1xuY29uc3QgZ2V0RGlzY3JpbWluYXRvckJ5VmFsdWUgPSByZXF1aXJlKCcuL2hlbHBlcnMvZGlzY3JpbWluYXRvci9nZXREaXNjcmltaW5hdG9yQnlWYWx1ZScpO1xuY29uc3QgZ2V0TW9kZWxzTWFwRm9yUG9wdWxhdGUgPSByZXF1aXJlKCcuL2hlbHBlcnMvcG9wdWxhdGUvZ2V0TW9kZWxzTWFwRm9yUG9wdWxhdGUnKTtcbmNvbnN0IGltbWVkaWF0ZSA9IHJlcXVpcmUoJy4vaGVscGVycy9pbW1lZGlhdGUnKTtcbmNvbnN0IGludGVybmFsVG9PYmplY3RPcHRpb25zID0gcmVxdWlyZSgnLi9vcHRpb25zJykuaW50ZXJuYWxUb09iamVjdE9wdGlvbnM7XG5jb25zdCBpc0RlZmF1bHRJZEluZGV4ID0gcmVxdWlyZSgnLi9oZWxwZXJzL2luZGV4ZXMvaXNEZWZhdWx0SWRJbmRleCcpO1xuY29uc3QgaXNJbmRleEVxdWFsID0gcmVxdWlyZSgnLi9oZWxwZXJzL2luZGV4ZXMvaXNJbmRleEVxdWFsJyk7XG5jb25zdCB7XG4gIGdldFJlbGF0ZWREQkluZGV4ZXMsXG4gIGdldFJlbGF0ZWRTY2hlbWFJbmRleGVzXG59ID0gcmVxdWlyZSgnLi9oZWxwZXJzL2luZGV4ZXMvZ2V0UmVsYXRlZEluZGV4ZXMnKTtcbmNvbnN0IGlzUGF0aEV4Y2x1ZGVkID0gcmVxdWlyZSgnLi9oZWxwZXJzL3Byb2plY3Rpb24vaXNQYXRoRXhjbHVkZWQnKTtcbmNvbnN0IGRlY29yYXRlRGlzY3JpbWluYXRvckluZGV4T3B0aW9ucyA9IHJlcXVpcmUoJy4vaGVscGVycy9pbmRleGVzL2RlY29yYXRlRGlzY3JpbWluYXRvckluZGV4T3B0aW9ucycpO1xuY29uc3QgaXNQYXRoU2VsZWN0ZWRJbmNsdXNpdmUgPSByZXF1aXJlKCcuL2hlbHBlcnMvcHJvamVjdGlvbi9pc1BhdGhTZWxlY3RlZEluY2x1c2l2ZScpO1xuY29uc3QgbGVhblBvcHVsYXRlTWFwID0gcmVxdWlyZSgnLi9oZWxwZXJzL3BvcHVsYXRlL2xlYW5Qb3B1bGF0ZU1hcCcpO1xuY29uc3QgcGFyYWxsZWxMaW1pdCA9IHJlcXVpcmUoJy4vaGVscGVycy9wYXJhbGxlbExpbWl0Jyk7XG5jb25zdCBwYXJlbnRQYXRocyA9IHJlcXVpcmUoJy4vaGVscGVycy9wYXRoL3BhcmVudFBhdGhzJyk7XG5jb25zdCBwcmVwYXJlRGlzY3JpbWluYXRvclBpcGVsaW5lID0gcmVxdWlyZSgnLi9oZWxwZXJzL2FnZ3JlZ2F0ZS9wcmVwYXJlRGlzY3JpbWluYXRvclBpcGVsaW5lJyk7XG5jb25zdCBwdXNoTmVzdGVkQXJyYXlQYXRocyA9IHJlcXVpcmUoJy4vaGVscGVycy9tb2RlbC9wdXNoTmVzdGVkQXJyYXlQYXRocycpO1xuY29uc3QgcmVtb3ZlRGVzZWxlY3RlZEZvcmVpZ25GaWVsZCA9IHJlcXVpcmUoJy4vaGVscGVycy9wb3B1bGF0ZS9yZW1vdmVEZXNlbGVjdGVkRm9yZWlnbkZpZWxkJyk7XG5jb25zdCBzZXREb3R0ZWRQYXRoID0gcmVxdWlyZSgnLi9oZWxwZXJzL3BhdGgvc2V0RG90dGVkUGF0aCcpO1xuY29uc3QgU1RBVEVTID0gcmVxdWlyZSgnLi9jb25uZWN0aW9uU3RhdGUnKTtcbmNvbnN0IHV0aWwgPSByZXF1aXJlKCd1dGlsJyk7XG5jb25zdCB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcbmNvbnN0IE1vbmdvb3NlQnVsa1dyaXRlRXJyb3IgPSByZXF1aXJlKCcuL2Vycm9yL2J1bGtXcml0ZUVycm9yJyk7XG5jb25zdCBtaW5pbWl6ZSA9IHJlcXVpcmUoJy4vaGVscGVycy9taW5pbWl6ZScpO1xuXG5jb25zdCBWRVJTSU9OX1dIRVJFID0gMTtcbmNvbnN0IFZFUlNJT05fSU5DID0gMjtcbmNvbnN0IFZFUlNJT05fQUxMID0gVkVSU0lPTl9XSEVSRSB8IFZFUlNJT05fSU5DO1xuXG5jb25zdCBhcnJheUF0b21pY3NTeW1ib2wgPSByZXF1aXJlKCcuL2hlbHBlcnMvc3ltYm9scycpLmFycmF5QXRvbWljc1N5bWJvbDtcbmNvbnN0IG1vZGVsQ29sbGVjdGlvblN5bWJvbCA9IFN5bWJvbCgnbW9uZ29vc2UjTW9kZWwjY29sbGVjdGlvbicpO1xuY29uc3QgbW9kZWxEYlN5bWJvbCA9IFN5bWJvbCgnbW9uZ29vc2UjTW9kZWwjZGInKTtcbmNvbnN0IG1vZGVsU3ltYm9sID0gcmVxdWlyZSgnLi9oZWxwZXJzL3N5bWJvbHMnKS5tb2RlbFN5bWJvbDtcbmNvbnN0IHN1YmNsYXNzZWRTeW1ib2wgPSBTeW1ib2woJ21vbmdvb3NlI01vZGVsI3N1YmNsYXNzZWQnKTtcblxuY29uc3Qgc2F2ZVRvT2JqZWN0T3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIGludGVybmFsVG9PYmplY3RPcHRpb25zLCB7XG4gIGJzb246IHRydWUsXG4gIGZsYXR0ZW5PYmplY3RJZHM6IGZhbHNlXG59KTtcblxuLyoqXG4gKiBBIE1vZGVsIGlzIGEgY2xhc3MgdGhhdCdzIHlvdXIgcHJpbWFyeSB0b29sIGZvciBpbnRlcmFjdGluZyB3aXRoIE1vbmdvREIuXG4gKiBBbiBpbnN0YW5jZSBvZiBhIE1vZGVsIGlzIGNhbGxlZCBhIFtEb2N1bWVudF0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2FwaS9kb2N1bWVudC5odG1sI0RvY3VtZW50KS5cbiAqXG4gKiBJbiBNb25nb29zZSwgdGhlIHRlcm0gXCJNb2RlbFwiIHJlZmVycyB0byBzdWJjbGFzc2VzIG9mIHRoZSBgbW9uZ29vc2UuTW9kZWxgXG4gKiBjbGFzcy4gWW91IHNob3VsZCBub3QgdXNlIHRoZSBgbW9uZ29vc2UuTW9kZWxgIGNsYXNzIGRpcmVjdGx5LiBUaGVcbiAqIFtgbW9uZ29vc2UubW9kZWwoKWBdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvbW9uZ29vc2UuaHRtbCNNb25nb29zZS5wcm90b3R5cGUubW9kZWwoKSkgYW5kXG4gKiBbYGNvbm5lY3Rpb24ubW9kZWwoKWBdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvY29ubmVjdGlvbi5odG1sI0Nvbm5lY3Rpb24ucHJvdG90eXBlLm1vZGVsKCkpIGZ1bmN0aW9uc1xuICogY3JlYXRlIHN1YmNsYXNzZXMgb2YgYG1vbmdvb3NlLk1vZGVsYCBhcyBzaG93biBiZWxvdy5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIC8vIGBVc2VyTW9kZWxgIGlzIGEgXCJNb2RlbFwiLCBhIHN1YmNsYXNzIG9mIGBtb25nb29zZS5Nb2RlbGAuXG4gKiAgICAgY29uc3QgVXNlck1vZGVsID0gbW9uZ29vc2UubW9kZWwoJ1VzZXInLCBuZXcgU2NoZW1hKHsgbmFtZTogU3RyaW5nIH0pKTtcbiAqXG4gKiAgICAgLy8gWW91IGNhbiB1c2UgYSBNb2RlbCB0byBjcmVhdGUgbmV3IGRvY3VtZW50cyB1c2luZyBgbmV3YDpcbiAqICAgICBjb25zdCB1c2VyRG9jID0gbmV3IFVzZXJNb2RlbCh7IG5hbWU6ICdGb28nIH0pO1xuICogICAgIGF3YWl0IHVzZXJEb2Muc2F2ZSgpO1xuICpcbiAqICAgICAvLyBZb3UgYWxzbyB1c2UgYSBtb2RlbCB0byBjcmVhdGUgcXVlcmllczpcbiAqICAgICBjb25zdCB1c2VyRnJvbURiID0gYXdhaXQgVXNlck1vZGVsLmZpbmRPbmUoeyBuYW1lOiAnRm9vJyB9KTtcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gZG9jIHZhbHVlcyBmb3IgaW5pdGlhbCBzZXRcbiAqIEBwYXJhbSB7T2JqZWN0fSBbZmllbGRzXSBvcHRpb25hbCBvYmplY3QgY29udGFpbmluZyB0aGUgZmllbGRzIHRoYXQgd2VyZSBzZWxlY3RlZCBpbiB0aGUgcXVlcnkgd2hpY2ggcmV0dXJuZWQgdGhpcyBkb2N1bWVudC4gWW91IGRvICoqbm90KiogbmVlZCB0byBzZXQgdGhpcyBwYXJhbWV0ZXIgdG8gZW5zdXJlIE1vbmdvb3NlIGhhbmRsZXMgeW91ciBbcXVlcnkgcHJvamVjdGlvbl0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2FwaS9xdWVyeS5odG1sI1F1ZXJ5LnByb3RvdHlwZS5zZWxlY3QoKSkuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtza2lwSWQ9ZmFsc2VdIG9wdGlvbmFsIGJvb2xlYW4uIElmIHRydWUsIG1vbmdvb3NlIGRvZXNuJ3QgYWRkIGFuIGBfaWRgIGZpZWxkIHRvIHRoZSBkb2N1bWVudC5cbiAqIEBpbmhlcml0cyBEb2N1bWVudCBodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvYXBpL2RvY3VtZW50Lmh0bWxcbiAqIEBldmVudCBgZXJyb3JgOiBJZiBsaXN0ZW5pbmcgdG8gdGhpcyBldmVudCwgJ2Vycm9yJyBpcyBlbWl0dGVkIHdoZW4gYSBkb2N1bWVudCB3YXMgc2F2ZWQgYW5kIGFuIGBlcnJvcmAgb2NjdXJyZWQuIElmIG5vdCBsaXN0ZW5pbmcsIHRoZSBldmVudCBidWJibGVzIHRvIHRoZSBjb25uZWN0aW9uIHVzZWQgdG8gY3JlYXRlIHRoaXMgTW9kZWwuXG4gKiBAZXZlbnQgYGluZGV4YDogRW1pdHRlZCBhZnRlciBgTW9kZWwjZW5zdXJlSW5kZXhlc2AgY29tcGxldGVzLiBJZiBhbiBlcnJvciBvY2N1cnJlZCBpdCBpcyBwYXNzZWQgd2l0aCB0aGUgZXZlbnQuXG4gKiBAZXZlbnQgYGluZGV4LXNpbmdsZS1zdGFydGA6IEVtaXR0ZWQgd2hlbiBhbiBpbmRpdmlkdWFsIGluZGV4IHN0YXJ0cyB3aXRoaW4gYE1vZGVsI2Vuc3VyZUluZGV4ZXNgLiBUaGUgZmllbGRzIGFuZCBvcHRpb25zIGJlaW5nIHVzZWQgdG8gYnVpbGQgdGhlIGluZGV4IGFyZSBhbHNvIHBhc3NlZCB3aXRoIHRoZSBldmVudC5cbiAqIEBldmVudCBgaW5kZXgtc2luZ2xlLWRvbmVgOiBFbWl0dGVkIHdoZW4gYW4gaW5kaXZpZHVhbCBpbmRleCBmaW5pc2hlcyB3aXRoaW4gYE1vZGVsI2Vuc3VyZUluZGV4ZXNgLiBJZiBhbiBlcnJvciBvY2N1cnJlZCBpdCBpcyBwYXNzZWQgd2l0aCB0aGUgZXZlbnQuIFRoZSBmaWVsZHMsIG9wdGlvbnMsIGFuZCBpbmRleCBuYW1lIGFyZSBhbHNvIHBhc3NlZC5cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gTW9kZWwoZG9jLCBmaWVsZHMsIHNraXBJZCkge1xuICBpZiAoZmllbGRzIGluc3RhbmNlb2YgU2NoZW1hKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignMm5kIGFyZ3VtZW50IHRvIGBNb2RlbGAgY29uc3RydWN0b3IgbXVzdCBiZSBhIFBPSk8gb3Igc3RyaW5nLCAnICtcbiAgICAgICcqKm5vdCoqIGEgc2NoZW1hLiBNYWtlIHN1cmUgeW91XFwncmUgY2FsbGluZyBgbW9uZ29vc2UubW9kZWwoKWAsIG5vdCAnICtcbiAgICAgICdgbW9uZ29vc2UuTW9kZWwoKWAuJyk7XG4gIH1cbiAgaWYgKHR5cGVvZiBkb2MgPT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRmlyc3QgYXJndW1lbnQgdG8gYE1vZGVsYCBjb25zdHJ1Y3RvciBtdXN0IGJlIGFuIG9iamVjdCwgJyArXG4gICAgICAnKipub3QqKiBhIHN0cmluZy4gTWFrZSBzdXJlIHlvdVxcJ3JlIGNhbGxpbmcgYG1vbmdvb3NlLm1vZGVsKClgLCBub3QgJyArXG4gICAgICAnYG1vbmdvb3NlLk1vZGVsKClgLicpO1xuICB9XG4gIERvY3VtZW50LmNhbGwodGhpcywgZG9jLCBmaWVsZHMsIHNraXBJZCk7XG59XG5cbi8qKlxuICogSW5oZXJpdHMgZnJvbSBEb2N1bWVudC5cbiAqXG4gKiBBbGwgTW9kZWwucHJvdG90eXBlIGZlYXR1cmVzIGFyZSBhdmFpbGFibGUgb25cbiAqIHRvcCBsZXZlbCAobm9uLXN1YikgZG9jdW1lbnRzLlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuT2JqZWN0LnNldFByb3RvdHlwZU9mKE1vZGVsLnByb3RvdHlwZSwgRG9jdW1lbnQucHJvdG90eXBlKTtcbk1vZGVsLnByb3RvdHlwZS4kaXNNb25nb29zZU1vZGVsUHJvdG90eXBlID0gdHJ1ZTtcblxuLyoqXG4gKiBDb25uZWN0aW9uIHRoZSBtb2RlbCB1c2VzLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKiBAcHJvcGVydHkgZGJcbiAqIEBtZW1iZXJPZiBNb2RlbFxuICogQGluc3RhbmNlXG4gKi9cblxuTW9kZWwucHJvdG90eXBlLmRiO1xuXG4vKipcbiAqIFRoZSBjb2xsZWN0aW9uIGluc3RhbmNlIHRoaXMgbW9kZWwgdXNlcy5cbiAqIEEgTW9uZ29vc2UgY29sbGVjdGlvbiBpcyBhIHRoaW4gd3JhcHBlciBhcm91bmQgYSBbTW9uZ29EQiBOb2RlLmpzIGRyaXZlciBjb2xsZWN0aW9uXShbTW9uZ29EQiBOb2RlLmpzIGRyaXZlciBjb2xsZWN0aW9uXShodHRwczovL21vbmdvZGIuZ2l0aHViLmlvL25vZGUtbW9uZ29kYi1uYXRpdmUvTmV4dC9jbGFzc2VzL0NvbGxlY3Rpb24uaHRtbCkpLlxuICogVXNpbmcgYE1vZGVsLmNvbGxlY3Rpb25gIG1lYW5zIHlvdSBieXBhc3MgTW9uZ29vc2UgbWlkZGxld2FyZSwgdmFsaWRhdGlvbiwgYW5kIGNhc3RpbmcuXG4gKlxuICogVGhpcyBwcm9wZXJ0eSBpcyByZWFkLW9ubHkuIE1vZGlmeWluZyB0aGlzIHByb3BlcnR5IGlzIGEgbm8tb3AuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqIEBwcm9wZXJ0eSBjb2xsZWN0aW9uXG4gKiBAbWVtYmVyT2YgTW9kZWxcbiAqIEBpbnN0YW5jZVxuICovXG5cbk1vZGVsLnByb3RvdHlwZS5jb2xsZWN0aW9uO1xuXG4vKipcbiAqIEludGVybmFsIGNvbGxlY3Rpb24gdGhlIG1vZGVsIHVzZXMuXG4gKlxuICogVGhpcyBwcm9wZXJ0eSBpcyByZWFkLW9ubHkuIE1vZGlmeWluZyB0aGlzIHByb3BlcnR5IGlzIGEgbm8tb3AuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKiBAcHJvcGVydHkgY29sbGVjdGlvblxuICogQG1lbWJlck9mIE1vZGVsXG4gKiBAaW5zdGFuY2VcbiAqL1xuXG5cbk1vZGVsLnByb3RvdHlwZS4kX19jb2xsZWN0aW9uO1xuXG4vKipcbiAqIFRoZSBuYW1lIG9mIHRoZSBtb2RlbFxuICpcbiAqIEBhcGkgcHVibGljXG4gKiBAcHJvcGVydHkgbW9kZWxOYW1lXG4gKiBAbWVtYmVyT2YgTW9kZWxcbiAqIEBpbnN0YW5jZVxuICovXG5cbk1vZGVsLnByb3RvdHlwZS5tb2RlbE5hbWU7XG5cbi8qKlxuICogQWRkaXRpb25hbCBwcm9wZXJ0aWVzIHRvIGF0dGFjaCB0byB0aGUgcXVlcnkgd2hlbiBjYWxsaW5nIGBzYXZlKClgIGFuZFxuICogYGlzTmV3YCBpcyBmYWxzZS5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICogQHByb3BlcnR5ICR3aGVyZVxuICogQG1lbWJlck9mIE1vZGVsXG4gKiBAaW5zdGFuY2VcbiAqL1xuXG5Nb2RlbC5wcm90b3R5cGUuJHdoZXJlO1xuXG4vKipcbiAqIElmIHRoaXMgaXMgYSBkaXNjcmltaW5hdG9yIG1vZGVsLCBgYmFzZU1vZGVsTmFtZWAgaXMgdGhlIG5hbWUgb2ZcbiAqIHRoZSBiYXNlIG1vZGVsLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKiBAcHJvcGVydHkgYmFzZU1vZGVsTmFtZVxuICogQG1lbWJlck9mIE1vZGVsXG4gKiBAaW5zdGFuY2VcbiAqL1xuXG5Nb2RlbC5wcm90b3R5cGUuYmFzZU1vZGVsTmFtZTtcblxuLyoqXG4gKiBFdmVudCBlbWl0dGVyIHRoYXQgcmVwb3J0cyBhbnkgZXJyb3JzIHRoYXQgb2NjdXJyZWQuIFVzZWZ1bCBmb3IgZ2xvYmFsIGVycm9yXG4gKiBoYW5kbGluZy5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIE15TW9kZWwuZXZlbnRzLm9uKCdlcnJvcicsIGVyciA9PiBjb25zb2xlLmxvZyhlcnIubWVzc2FnZSkpO1xuICpcbiAqICAgICAvLyBQcmludHMgYSAnQ2FzdEVycm9yJyBiZWNhdXNlIG9mIHRoZSBhYm92ZSBoYW5kbGVyXG4gKiAgICAgYXdhaXQgTXlNb2RlbC5maW5kT25lKHsgX2lkOiAnTm90IGEgdmFsaWQgT2JqZWN0SWQnIH0pLmNhdGNoKG5vb3ApO1xuICpcbiAqIEBhcGkgcHVibGljXG4gKiBAcHJvcGVydHkgZXZlbnRzXG4gKiBAZmlyZXMgZXJyb3Igd2hlbmV2ZXIgYW55IHF1ZXJ5IG9yIG1vZGVsIGZ1bmN0aW9uIGVycm9yc1xuICogQG1lbWJlck9mIE1vZGVsXG4gKiBAc3RhdGljXG4gKi9cblxuTW9kZWwuZXZlbnRzO1xuXG4vKipcbiAqIENvbXBpbGVkIG1pZGRsZXdhcmUgZm9yIHRoaXMgbW9kZWwuIFNldCBpbiBgYXBwbHlIb29rcygpYC5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqIEBwcm9wZXJ0eSBfbWlkZGxld2FyZVxuICogQG1lbWJlck9mIE1vZGVsXG4gKiBAc3RhdGljXG4gKi9cblxuTW9kZWwuX21pZGRsZXdhcmU7XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxuZnVuY3Rpb24gX2FwcGx5Q3VzdG9tV2hlcmUoZG9jLCB3aGVyZSkge1xuICBpZiAoZG9jLiR3aGVyZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKGRvYy4kd2hlcmUpKSB7XG4gICAgd2hlcmVba2V5XSA9IGRvYy4kd2hlcmVba2V5XTtcbiAgfVxufVxuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cbk1vZGVsLnByb3RvdHlwZS4kX19oYW5kbGVTYXZlID0gZnVuY3Rpb24ob3B0aW9ucywgY2FsbGJhY2spIHtcbiAgY29uc3Qgc2F2ZU9wdGlvbnMgPSB7fTtcblxuICBhcHBseVdyaXRlQ29uY2Vybih0aGlzLiRfX3NjaGVtYSwgb3B0aW9ucyk7XG4gIGlmICh0eXBlb2Ygb3B0aW9ucy53cml0ZUNvbmNlcm4gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgc2F2ZU9wdGlvbnMud3JpdGVDb25jZXJuID0ge307XG4gICAgaWYgKCd3JyBpbiBvcHRpb25zLndyaXRlQ29uY2Vybikge1xuICAgICAgc2F2ZU9wdGlvbnMud3JpdGVDb25jZXJuLncgPSBvcHRpb25zLndyaXRlQ29uY2Vybi53O1xuICAgIH1cbiAgICBpZiAoJ2onIGluIG9wdGlvbnMud3JpdGVDb25jZXJuKSB7XG4gICAgICBzYXZlT3B0aW9ucy53cml0ZUNvbmNlcm4uaiA9IG9wdGlvbnMud3JpdGVDb25jZXJuLmo7XG4gICAgfVxuICAgIGlmICgnd3RpbWVvdXQnIGluIG9wdGlvbnMud3JpdGVDb25jZXJuKSB7XG4gICAgICBzYXZlT3B0aW9ucy53cml0ZUNvbmNlcm4ud3RpbWVvdXQgPSBvcHRpb25zLndyaXRlQ29uY2Vybi53dGltZW91dDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKCd3JyBpbiBvcHRpb25zKSB7XG4gICAgICBzYXZlT3B0aW9ucy53ID0gb3B0aW9ucy53O1xuICAgIH1cbiAgICBpZiAoJ2onIGluIG9wdGlvbnMpIHtcbiAgICAgIHNhdmVPcHRpb25zLmogPSBvcHRpb25zLmo7XG4gICAgfVxuICAgIGlmICgnd3RpbWVvdXQnIGluIG9wdGlvbnMpIHtcbiAgICAgIHNhdmVPcHRpb25zLnd0aW1lb3V0ID0gb3B0aW9ucy53dGltZW91dDtcbiAgICB9XG4gIH1cbiAgaWYgKCdjaGVja0tleXMnIGluIG9wdGlvbnMpIHtcbiAgICBzYXZlT3B0aW9ucy5jaGVja0tleXMgPSBvcHRpb25zLmNoZWNrS2V5cztcbiAgfVxuXG4gIGNvbnN0IHNlc3Npb24gPSB0aGlzLiRzZXNzaW9uKCk7XG4gIGlmICghc2F2ZU9wdGlvbnMuaGFzT3duUHJvcGVydHkoJ3Nlc3Npb24nKSAmJiBzZXNzaW9uICE9IG51bGwpIHtcbiAgICBzYXZlT3B0aW9ucy5zZXNzaW9uID0gc2Vzc2lvbjtcbiAgfVxuXG4gIGlmICh0aGlzLiRpc05ldykge1xuICAgIC8vIHNlbmQgZW50aXJlIGRvY1xuICAgIGNvbnN0IG9iaiA9IHRoaXMudG9PYmplY3Qoc2F2ZVRvT2JqZWN0T3B0aW9ucyk7XG4gICAgaWYgKChvYmogfHwge30pLl9pZCA9PT0gdm9pZCAwKSB7XG4gICAgICAvLyBkb2N1bWVudHMgbXVzdCBoYXZlIGFuIF9pZCBlbHNlIG1vbmdvb3NlIHdvbid0IGtub3dcbiAgICAgIC8vIHdoYXQgdG8gdXBkYXRlIGxhdGVyIGlmIG1vcmUgY2hhbmdlcyBhcmUgbWFkZS4gdGhlIHVzZXJcbiAgICAgIC8vIHdvdWxkbid0IGtub3cgd2hhdCBfaWQgd2FzIGdlbmVyYXRlZCBieSBtb25nb2RiIGVpdGhlclxuICAgICAgLy8gbm9yIHdvdWxkIHRoZSBPYmplY3RJZCBnZW5lcmF0ZWQgYnkgbW9uZ29kYiBuZWNlc3NhcmlseVxuICAgICAgLy8gbWF0Y2ggdGhlIHNjaGVtYSBkZWZpbml0aW9uLlxuICAgICAgaW1tZWRpYXRlKGZ1bmN0aW9uKCkge1xuICAgICAgICBjYWxsYmFjayhuZXcgTW9uZ29vc2VFcnJvcignZG9jdW1lbnQgbXVzdCBoYXZlIGFuIF9pZCBiZWZvcmUgc2F2aW5nJykpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy4kX192ZXJzaW9uKHRydWUsIG9iaik7XG4gICAgdGhpc1ttb2RlbENvbGxlY3Rpb25TeW1ib2xdLmluc2VydE9uZShvYmosIHNhdmVPcHRpb25zKS50aGVuKFxuICAgICAgcmV0ID0+IGNhbGxiYWNrKG51bGwsIHJldCksXG4gICAgICBlcnIgPT4ge1xuICAgICAgICBfc2V0SXNOZXcodGhpcywgdHJ1ZSk7XG5cbiAgICAgICAgY2FsbGJhY2soZXJyLCBudWxsKTtcbiAgICAgIH1cbiAgICApO1xuXG4gICAgdGhpcy4kX19yZXNldCgpO1xuICAgIF9zZXRJc05ldyh0aGlzLCBmYWxzZSk7XG4gICAgLy8gTWFrZSBpdCBwb3NzaWJsZSB0byByZXRyeSB0aGUgaW5zZXJ0XG4gICAgdGhpcy4kX18uaW5zZXJ0aW5nID0gdHJ1ZTtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBNYWtlIHN1cmUgd2UgZG9uJ3QgdHJlYXQgaXQgYXMgYSBuZXcgb2JqZWN0IG9uIGVycm9yLFxuICAvLyBzaW5jZSBpdCBhbHJlYWR5IGV4aXN0c1xuICB0aGlzLiRfXy5pbnNlcnRpbmcgPSBmYWxzZTtcbiAgY29uc3QgZGVsdGEgPSB0aGlzLiRfX2RlbHRhKCk7XG4gIGlmIChkZWx0YSkge1xuICAgIGlmIChkZWx0YSBpbnN0YW5jZW9mIE1vbmdvb3NlRXJyb3IpIHtcbiAgICAgIGNhbGxiYWNrKGRlbHRhKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCB3aGVyZSA9IHRoaXMuJF9fd2hlcmUoZGVsdGFbMF0pO1xuICAgIGlmICh3aGVyZSBpbnN0YW5jZW9mIE1vbmdvb3NlRXJyb3IpIHtcbiAgICAgIGNhbGxiYWNrKHdoZXJlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBfYXBwbHlDdXN0b21XaGVyZSh0aGlzLCB3aGVyZSk7XG5cbiAgICBjb25zdCB1cGRhdGUgPSBkZWx0YVsxXTtcbiAgICBpZiAodGhpcy4kX19zY2hlbWEub3B0aW9ucy5taW5pbWl6ZSkge1xuICAgICAgbWluaW1pemUodXBkYXRlKTtcbiAgICAgIC8vIG1pbmltaXplIG1pZ2h0IGxlYXZlIHVzIHdpdGggYW4gZW1wdHkgb2JqZWN0LCB3aGljaCB3b3VsZFxuICAgICAgLy8gbGVhZCB0byBNb25nb0RCIHRocm93aW5nIGEgXCJVcGRhdGUgZG9jdW1lbnQgcmVxdWlyZXMgYXRvbWljIG9wZXJhdG9yc1wiIGVycm9yXG4gICAgICBpZiAoT2JqZWN0LmtleXModXBkYXRlKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgaGFuZGxlRW1wdHlVcGRhdGUuY2FsbCh0aGlzKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXNbbW9kZWxDb2xsZWN0aW9uU3ltYm9sXS51cGRhdGVPbmUod2hlcmUsIHVwZGF0ZSwgc2F2ZU9wdGlvbnMpLnRoZW4oXG4gICAgICByZXQgPT4ge1xuICAgICAgICByZXQuJHdoZXJlID0gd2hlcmU7XG4gICAgICAgIGNhbGxiYWNrKG51bGwsIHJldCk7XG4gICAgICB9LFxuICAgICAgZXJyID0+IHtcbiAgICAgICAgdGhpcy4kX191bmRvUmVzZXQoKTtcblxuICAgICAgICBjYWxsYmFjayhlcnIpO1xuICAgICAgfVxuICAgICk7XG4gIH0gZWxzZSB7XG4gICAgaGFuZGxlRW1wdHlVcGRhdGUuY2FsbCh0aGlzKTtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBzdG9yZSB0aGUgbW9kaWZpZWQgcGF0aHMgYmVmb3JlIHRoZSBkb2N1bWVudCBpcyByZXNldFxuICB0aGlzLiRfXy5tb2RpZmllZFBhdGhzID0gdGhpcy5tb2RpZmllZFBhdGhzKCk7XG4gIHRoaXMuJF9fcmVzZXQoKTtcblxuICBfc2V0SXNOZXcodGhpcywgZmFsc2UpO1xuXG4gIGZ1bmN0aW9uIGhhbmRsZUVtcHR5VXBkYXRlKCkge1xuICAgIGNvbnN0IG9wdGlvbnNXaXRoQ3VzdG9tVmFsdWVzID0gT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucywgc2F2ZU9wdGlvbnMpO1xuICAgIGNvbnN0IHdoZXJlID0gdGhpcy4kX193aGVyZSgpO1xuICAgIGNvbnN0IG9wdGltaXN0aWNDb25jdXJyZW5jeSA9IHRoaXMuJF9fc2NoZW1hLm9wdGlvbnMub3B0aW1pc3RpY0NvbmN1cnJlbmN5O1xuICAgIGlmIChvcHRpbWlzdGljQ29uY3VycmVuY3kgJiYgIUFycmF5LmlzQXJyYXkob3B0aW1pc3RpY0NvbmN1cnJlbmN5KSkge1xuICAgICAgY29uc3Qga2V5ID0gdGhpcy4kX19zY2hlbWEub3B0aW9ucy52ZXJzaW9uS2V5O1xuICAgICAgY29uc3QgdmFsID0gdGhpcy4kX19nZXRWYWx1ZShrZXkpO1xuICAgICAgaWYgKHZhbCAhPSBudWxsKSB7XG4gICAgICAgIHdoZXJlW2tleV0gPSB2YWw7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuY29uc3RydWN0b3IuY29sbGVjdGlvbi5maW5kT25lKHdoZXJlLCBvcHRpb25zV2l0aEN1c3RvbVZhbHVlcylcbiAgICAgIC50aGVuKGRvY3VtZW50RXhpc3RzID0+IHtcbiAgICAgICAgY29uc3QgbWF0Y2hlZENvdW50ID0gIWRvY3VtZW50RXhpc3RzID8gMCA6IDE7XG4gICAgICAgIGNhbGxiYWNrKG51bGwsIHsgJHdoZXJlOiB3aGVyZSwgbWF0Y2hlZENvdW50IH0pO1xuICAgICAgfSlcbiAgICAgIC5jYXRjaChjYWxsYmFjayk7XG4gIH1cbn07XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxuTW9kZWwucHJvdG90eXBlLiRfX3NhdmUgPSBmdW5jdGlvbihvcHRpb25zLCBjYWxsYmFjaykge1xuICB0aGlzLiRfX2hhbmRsZVNhdmUob3B0aW9ucywgKGVycm9yLCByZXN1bHQpID0+IHtcbiAgICBpZiAoZXJyb3IpIHtcbiAgICAgIGNvbnN0IGhvb2tzID0gdGhpcy4kX19zY2hlbWEucy5ob29rcztcbiAgICAgIHJldHVybiBob29rcy5leGVjUG9zdCgnc2F2ZTplcnJvcicsIHRoaXMsIFt0aGlzXSwgeyBlcnJvcjogZXJyb3IgfSwgKGVycm9yKSA9PiB7XG4gICAgICAgIGNhbGxiYWNrKGVycm9yLCB0aGlzKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBsZXQgbnVtQWZmZWN0ZWQgPSAwO1xuICAgIGNvbnN0IHdyaXRlQ29uY2VybiA9IG9wdGlvbnMgIT0gbnVsbCA/XG4gICAgICBvcHRpb25zLndyaXRlQ29uY2VybiAhPSBudWxsID9cbiAgICAgICAgb3B0aW9ucy53cml0ZUNvbmNlcm4udyA6XG4gICAgICAgIG9wdGlvbnMudyA6XG4gICAgICAwO1xuICAgIGlmICh3cml0ZUNvbmNlcm4gIT09IDApIHtcbiAgICAgIC8vIFNraXAgY2hlY2tpbmcgaWYgd3JpdGUgc3VjY2VlZGVkIGlmIHdyaXRlQ29uY2VybiBpcyBzZXQgdG9cbiAgICAgIC8vIHVuYWNrbm93bGVkZ2VkIHdyaXRlcywgYmVjYXVzZSBvdGhlcndpc2UgYG51bUFmZmVjdGVkYCB3aWxsIGFsd2F5cyBiZSAwXG4gICAgICBpZiAocmVzdWx0ICE9IG51bGwpIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocmVzdWx0KSkge1xuICAgICAgICAgIG51bUFmZmVjdGVkID0gcmVzdWx0Lmxlbmd0aDtcbiAgICAgICAgfSBlbHNlIGlmIChyZXN1bHQubWF0Y2hlZENvdW50ICE9IG51bGwpIHtcbiAgICAgICAgICBudW1BZmZlY3RlZCA9IHJlc3VsdC5tYXRjaGVkQ291bnQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbnVtQWZmZWN0ZWQgPSByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY29uc3QgdmVyc2lvbkJ1bXAgPSB0aGlzLiRfXy52ZXJzaW9uO1xuICAgICAgLy8gd2FzIHRoaXMgYW4gdXBkYXRlIHRoYXQgcmVxdWlyZWQgYSB2ZXJzaW9uIGJ1bXA/XG4gICAgICBpZiAodmVyc2lvbkJ1bXAgJiYgIXRoaXMuJF9fLmluc2VydGluZykge1xuICAgICAgICBjb25zdCBkb0luY3JlbWVudCA9IFZFUlNJT05fSU5DID09PSAoVkVSU0lPTl9JTkMgJiB0aGlzLiRfXy52ZXJzaW9uKTtcbiAgICAgICAgdGhpcy4kX18udmVyc2lvbiA9IHVuZGVmaW5lZDtcbiAgICAgICAgY29uc3Qga2V5ID0gdGhpcy4kX19zY2hlbWEub3B0aW9ucy52ZXJzaW9uS2V5O1xuICAgICAgICBjb25zdCB2ZXJzaW9uID0gdGhpcy4kX19nZXRWYWx1ZShrZXkpIHx8IDA7XG4gICAgICAgIGlmIChudW1BZmZlY3RlZCA8PSAwKSB7XG4gICAgICAgICAgLy8gdGhlIHVwZGF0ZSBmYWlsZWQuIHBhc3MgYW4gZXJyb3IgYmFja1xuICAgICAgICAgIHRoaXMuJF9fdW5kb1Jlc2V0KCk7XG4gICAgICAgICAgY29uc3QgZXJyID0gdGhpcy4kX18uJHZlcnNpb25FcnJvciB8fFxuICAgICAgICAgICAgbmV3IFZlcnNpb25FcnJvcih0aGlzLCB2ZXJzaW9uLCB0aGlzLiRfXy5tb2RpZmllZFBhdGhzKTtcbiAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGluY3JlbWVudCB2ZXJzaW9uIGlmIHdhcyBzdWNjZXNzZnVsXG4gICAgICAgIGlmIChkb0luY3JlbWVudCkge1xuICAgICAgICAgIHRoaXMuJF9fc2V0VmFsdWUoa2V5LCB2ZXJzaW9uICsgMSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChyZXN1bHQgIT0gbnVsbCAmJiBudW1BZmZlY3RlZCA8PSAwKSB7XG4gICAgICAgIHRoaXMuJF9fdW5kb1Jlc2V0KCk7XG4gICAgICAgIGVycm9yID0gbmV3IERvY3VtZW50Tm90Rm91bmRFcnJvcihyZXN1bHQuJHdoZXJlLFxuICAgICAgICAgIHRoaXMuY29uc3RydWN0b3IubW9kZWxOYW1lLCBudW1BZmZlY3RlZCwgcmVzdWx0KTtcbiAgICAgICAgY29uc3QgaG9va3MgPSB0aGlzLiRfX3NjaGVtYS5zLmhvb2tzO1xuICAgICAgICByZXR1cm4gaG9va3MuZXhlY1Bvc3QoJ3NhdmU6ZXJyb3InLCB0aGlzLCBbdGhpc10sIHsgZXJyb3I6IGVycm9yIH0sIChlcnJvcikgPT4ge1xuICAgICAgICAgIGNhbGxiYWNrKGVycm9yLCB0aGlzKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuJF9fLnNhdmluZyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLiRfXy5zYXZlZFN0YXRlID0ge307XG4gICAgdGhpcy4kZW1pdCgnc2F2ZScsIHRoaXMsIG51bUFmZmVjdGVkKTtcbiAgICB0aGlzLmNvbnN0cnVjdG9yLmVtaXQoJ3NhdmUnLCB0aGlzLCBudW1BZmZlY3RlZCk7XG4gICAgY2FsbGJhY2sobnVsbCwgdGhpcyk7XG4gIH0pO1xufTtcblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5mdW5jdGlvbiBnZW5lcmF0ZVZlcnNpb25FcnJvcihkb2MsIG1vZGlmaWVkUGF0aHMpIHtcbiAgY29uc3Qga2V5ID0gZG9jLiRfX3NjaGVtYS5vcHRpb25zLnZlcnNpb25LZXk7XG4gIGlmICgha2V5KSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgY29uc3QgdmVyc2lvbiA9IGRvYy4kX19nZXRWYWx1ZShrZXkpIHx8IDA7XG4gIHJldHVybiBuZXcgVmVyc2lvbkVycm9yKGRvYywgdmVyc2lvbiwgbW9kaWZpZWRQYXRocyk7XG59XG5cbi8qKlxuICogU2F2ZXMgdGhpcyBkb2N1bWVudCBieSBpbnNlcnRpbmcgYSBuZXcgZG9jdW1lbnQgaW50byB0aGUgZGF0YWJhc2UgaWYgW2RvY3VtZW50LmlzTmV3XShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvYXBpL2RvY3VtZW50Lmh0bWwjRG9jdW1lbnQucHJvdG90eXBlLmlzTmV3KSBpcyBgdHJ1ZWAsXG4gKiBvciBzZW5kcyBhbiBbdXBkYXRlT25lXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvYXBpL2RvY3VtZW50Lmh0bWwjRG9jdW1lbnQucHJvdG90eXBlLnVwZGF0ZU9uZSgpKSBvcGVyYXRpb24gd2l0aCBqdXN0IHRoZSBtb2RpZmllZCBwYXRocyBpZiBgaXNOZXdgIGlzIGBmYWxzZWAuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBwcm9kdWN0LnNvbGQgPSBEYXRlLm5vdygpO1xuICogICAgIHByb2R1Y3QgPSBhd2FpdCBwcm9kdWN0LnNhdmUoKTtcbiAqXG4gKiBJZiBzYXZlIGlzIHN1Y2Nlc3NmdWwsIHRoZSByZXR1cm5lZCBwcm9taXNlIHdpbGwgZnVsZmlsbCB3aXRoIHRoZSBkb2N1bWVudFxuICogc2F2ZWQuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBjb25zdCBuZXdQcm9kdWN0ID0gYXdhaXQgcHJvZHVjdC5zYXZlKCk7XG4gKiAgICAgbmV3UHJvZHVjdCA9PT0gcHJvZHVjdDsgLy8gdHJ1ZVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gb3B0aW9ucyBvcHRpb25hbCBvcHRpb25zXG4gKiBAcGFyYW0ge1Nlc3Npb259IFtvcHRpb25zLnNlc3Npb249bnVsbF0gdGhlIFtzZXNzaW9uXShodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9yZWZlcmVuY2Uvc2VydmVyLXNlc3Npb25zLykgYXNzb2NpYXRlZCB3aXRoIHRoaXMgc2F2ZSBvcGVyYXRpb24uIElmIG5vdCBzcGVjaWZpZWQsIGRlZmF1bHRzIHRvIHRoZSBbZG9jdW1lbnQncyBhc3NvY2lhdGVkIHNlc3Npb25dKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvZG9jdW1lbnQuaHRtbCNEb2N1bWVudC5wcm90b3R5cGUuc2Vzc2lvbigpKS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy5zYWZlXSAoREVQUkVDQVRFRCkgb3ZlcnJpZGVzIFtzY2hlbWEncyBzYWZlIG9wdGlvbl0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2d1aWRlLmh0bWwjc2FmZSkuIFVzZSB0aGUgYHdgIG9wdGlvbiBpbnN0ZWFkLlxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy52YWxpZGF0ZUJlZm9yZVNhdmVdIHNldCB0byBmYWxzZSB0byBzYXZlIHdpdGhvdXQgdmFsaWRhdGluZy5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMudmFsaWRhdGVNb2RpZmllZE9ubHk9ZmFsc2VdIGlmIGB0cnVlYCwgTW9uZ29vc2Ugd2lsbCBvbmx5IHZhbGlkYXRlIG1vZGlmaWVkIHBhdGhzLCBhcyBvcHBvc2VkIHRvIG1vZGlmaWVkIHBhdGhzIGFuZCBgcmVxdWlyZWRgIHBhdGhzLlxuICogQHBhcmFtIHtOdW1iZXJ8U3RyaW5nfSBbb3B0aW9ucy53XSBzZXQgdGhlIFt3cml0ZSBjb25jZXJuXShodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9yZWZlcmVuY2Uvd3JpdGUtY29uY2Vybi8jdy1vcHRpb24pLiBPdmVycmlkZXMgdGhlIFtzY2hlbWEtbGV2ZWwgYHdyaXRlQ29uY2VybmAgb3B0aW9uXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvZ3VpZGUuaHRtbCN3cml0ZUNvbmNlcm4pXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmpdIHNldCB0byB0cnVlIGZvciBNb25nb0RCIHRvIHdhaXQgdW50aWwgdGhpcyBgc2F2ZSgpYCBoYXMgYmVlbiBbam91cm5hbGVkIGJlZm9yZSByZXNvbHZpbmcgdGhlIHJldHVybmVkIHByb21pc2VdKGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvbWFudWFsL3JlZmVyZW5jZS93cml0ZS1jb25jZXJuLyNqLW9wdGlvbikuIE92ZXJyaWRlcyB0aGUgW3NjaGVtYS1sZXZlbCBgd3JpdGVDb25jZXJuYCBvcHRpb25dKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9ndWlkZS5odG1sI3dyaXRlQ29uY2VybilcbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy53dGltZW91dF0gc2V0cyBhIFt0aW1lb3V0IGZvciB0aGUgd3JpdGUgY29uY2Vybl0oaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvcmVmZXJlbmNlL3dyaXRlLWNvbmNlcm4vI3d0aW1lb3V0KS4gT3ZlcnJpZGVzIHRoZSBbc2NoZW1hLWxldmVsIGB3cml0ZUNvbmNlcm5gIG9wdGlvbl0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2d1aWRlLmh0bWwjd3JpdGVDb25jZXJuKS5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuY2hlY2tLZXlzPXRydWVdIHRoZSBNb25nb0RCIGRyaXZlciBwcmV2ZW50cyB5b3UgZnJvbSBzYXZpbmcga2V5cyB0aGF0IHN0YXJ0IHdpdGggJyQnIG9yIGNvbnRhaW4gJy4nIGJ5IGRlZmF1bHQuIFNldCB0aGlzIG9wdGlvbiB0byBgZmFsc2VgIHRvIHNraXAgdGhhdCBjaGVjay4gU2VlIFtyZXN0cmljdGlvbnMgb24gZmllbGQgbmFtZXNdKGh0dHBzOi8vZG9jcy5tb25nb2RiLmNvbS9tYW51YWwvcmVmZXJlbmNlL2xpbWl0cy8jbW9uZ29kYi1saW1pdC1SZXN0cmljdGlvbnMtb24tRmllbGQtTmFtZXMpXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnRpbWVzdGFtcHM9dHJ1ZV0gaWYgYGZhbHNlYCBhbmQgW3RpbWVzdGFtcHNdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9ndWlkZS5odG1sI3RpbWVzdGFtcHMpIGFyZSBlbmFibGVkLCBza2lwIHRpbWVzdGFtcHMgZm9yIHRoaXMgYHNhdmUoKWAuXG4gKiBAdGhyb3dzIHtEb2N1bWVudE5vdEZvdW5kRXJyb3J9IGlmIHRoaXMgW3NhdmUgdXBkYXRlcyBhbiBleGlzdGluZyBkb2N1bWVudF0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2FwaS9kb2N1bWVudC5odG1sI0RvY3VtZW50LnByb3RvdHlwZS5pc05ldykgYnV0IHRoZSBkb2N1bWVudCBkb2Vzbid0IGV4aXN0IGluIHRoZSBkYXRhYmFzZS4gRm9yIGV4YW1wbGUsIHlvdSB3aWxsIGdldCB0aGlzIGVycm9yIGlmIHRoZSBkb2N1bWVudCBpcyBbZGVsZXRlZCBiZXR3ZWVuIHdoZW4geW91IHJldHJpZXZlZCB0aGUgZG9jdW1lbnQgYW5kIHdoZW4geW91IHNhdmVkIGl0XShkb2N1bWVudHMuaHRtbCN1cGRhdGluZykuXG4gKiBAcmV0dXJuIHtQcm9taXNlfVxuICogQGFwaSBwdWJsaWNcbiAqIEBzZWUgbWlkZGxld2FyZSBodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvbWlkZGxld2FyZS5odG1sXG4gKi9cblxuTW9kZWwucHJvdG90eXBlLnNhdmUgPSBhc3luYyBmdW5jdGlvbiBzYXZlKG9wdGlvbnMpIHtcbiAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBhcmd1bWVudHNbMV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgTW9uZ29vc2VFcnJvcignTW9kZWwucHJvdG90eXBlLnNhdmUoKSBubyBsb25nZXIgYWNjZXB0cyBhIGNhbGxiYWNrJyk7XG4gIH1cblxuICBsZXQgcGFyYWxsZWxTYXZlO1xuICB0aGlzLiRvcCA9ICdzYXZlJztcblxuICBpZiAodGhpcy4kX18uc2F2aW5nKSB7XG4gICAgcGFyYWxsZWxTYXZlID0gbmV3IFBhcmFsbGVsU2F2ZUVycm9yKHRoaXMpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuJF9fLnNhdmluZyA9IG5ldyBQYXJhbGxlbFNhdmVFcnJvcih0aGlzKTtcbiAgfVxuXG4gIG9wdGlvbnMgPSBuZXcgU2F2ZU9wdGlvbnMob3B0aW9ucyk7XG4gIGlmIChvcHRpb25zLmhhc093blByb3BlcnR5KCdzZXNzaW9uJykpIHtcbiAgICB0aGlzLiRzZXNzaW9uKG9wdGlvbnMuc2Vzc2lvbik7XG4gIH1cbiAgaWYgKHRoaXMuJF9fLnRpbWVzdGFtcHMgIT0gbnVsbCkge1xuICAgIG9wdGlvbnMudGltZXN0YW1wcyA9IHRoaXMuJF9fLnRpbWVzdGFtcHM7XG4gIH1cbiAgdGhpcy4kX18uJHZlcnNpb25FcnJvciA9IGdlbmVyYXRlVmVyc2lvbkVycm9yKHRoaXMsIHRoaXMubW9kaWZpZWRQYXRocygpKTtcblxuICBpZiAocGFyYWxsZWxTYXZlKSB7XG4gICAgdGhpcy4kX19oYW5kbGVSZWplY3QocGFyYWxsZWxTYXZlKTtcbiAgICB0aHJvdyBwYXJhbGxlbFNhdmU7XG4gIH1cblxuICB0aGlzLiRfXy5zYXZlT3B0aW9ucyA9IG9wdGlvbnM7XG5cbiAgYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIHRoaXMuJF9fc2F2ZShvcHRpb25zLCBlcnJvciA9PiB7XG4gICAgICB0aGlzLiRfXy5zYXZpbmcgPSBudWxsO1xuICAgICAgdGhpcy4kX18uc2F2ZU9wdGlvbnMgPSBudWxsO1xuICAgICAgdGhpcy4kX18uJHZlcnNpb25FcnJvciA9IG51bGw7XG4gICAgICB0aGlzLiRvcCA9IG51bGw7XG4gICAgICBpZiAoZXJyb3IgIT0gbnVsbCkge1xuICAgICAgICB0aGlzLiRfX2hhbmRsZVJlamVjdChlcnJvcik7XG4gICAgICAgIHJldHVybiByZWplY3QoZXJyb3IpO1xuICAgICAgfVxuXG4gICAgICByZXNvbHZlKCk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuTW9kZWwucHJvdG90eXBlLiRzYXZlID0gTW9kZWwucHJvdG90eXBlLnNhdmU7XG5cbi8qKlxuICogRGV0ZXJtaW5lcyB3aGV0aGVyIHZlcnNpb25pbmcgc2hvdWxkIGJlIHNraXBwZWQgZm9yIHRoZSBnaXZlbiBwYXRoXG4gKlxuICogQHBhcmFtIHtEb2N1bWVudH0gc2VsZlxuICogQHBhcmFtIHtTdHJpbmd9IHBhdGhcbiAqIEByZXR1cm4ge0Jvb2xlYW59IHRydWUgaWYgdmVyc2lvbmluZyBzaG91bGQgYmUgc2tpcHBlZCBmb3IgdGhlIGdpdmVuIHBhdGhcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBzaG91bGRTa2lwVmVyc2lvbmluZyhzZWxmLCBwYXRoKSB7XG4gIGNvbnN0IHNraXBWZXJzaW9uaW5nID0gc2VsZi4kX19zY2hlbWEub3B0aW9ucy5za2lwVmVyc2lvbmluZztcbiAgaWYgKCFza2lwVmVyc2lvbmluZykgcmV0dXJuIGZhbHNlO1xuXG4gIC8vIFJlbW92ZSBhbnkgYXJyYXkgaW5kZXhlcyBmcm9tIHRoZSBwYXRoXG4gIHBhdGggPSBwYXRoLnJlcGxhY2UoL1xcLlxcZCtcXC4vLCAnLicpO1xuXG4gIHJldHVybiBza2lwVmVyc2lvbmluZ1twYXRoXTtcbn1cblxuLyoqXG4gKiBBcHBseSB0aGUgb3BlcmF0aW9uIHRvIHRoZSBkZWx0YSAodXBkYXRlKSBjbGF1c2UgYXNcbiAqIHdlbGwgYXMgdHJhY2sgdmVyc2lvbmluZyBmb3Igb3VyIHdoZXJlIGNsYXVzZS5cbiAqXG4gKiBAcGFyYW0ge0RvY3VtZW50fSBzZWxmXG4gKiBAcGFyYW0ge09iamVjdH0gd2hlcmUgVW51c2VkXG4gKiBAcGFyYW0ge09iamVjdH0gZGVsdGFcbiAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gKiBAcGFyYW0ge01peGVkfSB2YWxcbiAqIEBwYXJhbSB7U3RyaW5nfSBbb3BdXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBvcGVyYW5kKHNlbGYsIHdoZXJlLCBkZWx0YSwgZGF0YSwgdmFsLCBvcCkge1xuICAvLyBkZWx0YVxuICBvcCB8fCAob3AgPSAnJHNldCcpO1xuICBpZiAoIWRlbHRhW29wXSkgZGVsdGFbb3BdID0ge307XG4gIGRlbHRhW29wXVtkYXRhLnBhdGhdID0gdmFsO1xuICAvLyBkaXNhYmxlZCB2ZXJzaW9uaW5nP1xuICBpZiAoc2VsZi4kX19zY2hlbWEub3B0aW9ucy52ZXJzaW9uS2V5ID09PSBmYWxzZSkgcmV0dXJuO1xuXG4gIC8vIHBhdGggZXhjbHVkZWQgZnJvbSB2ZXJzaW9uaW5nP1xuICBpZiAoc2hvdWxkU2tpcFZlcnNpb25pbmcoc2VsZiwgZGF0YS5wYXRoKSkgcmV0dXJuO1xuXG4gIC8vIGFscmVhZHkgbWFya2VkIGZvciB2ZXJzaW9uaW5nP1xuICBpZiAoVkVSU0lPTl9BTEwgPT09IChWRVJTSU9OX0FMTCAmIHNlbGYuJF9fLnZlcnNpb24pKSByZXR1cm47XG5cbiAgaWYgKHNlbGYuJF9fc2NoZW1hLm9wdGlvbnMub3B0aW1pc3RpY0NvbmN1cnJlbmN5KSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgc3dpdGNoIChvcCkge1xuICAgIGNhc2UgJyRzZXQnOlxuICAgIGNhc2UgJyR1bnNldCc6XG4gICAgY2FzZSAnJHBvcCc6XG4gICAgY2FzZSAnJHB1bGwnOlxuICAgIGNhc2UgJyRwdWxsQWxsJzpcbiAgICBjYXNlICckcHVzaCc6XG4gICAgY2FzZSAnJGFkZFRvU2V0JzpcbiAgICBjYXNlICckaW5jJzpcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICAvLyBub3RoaW5nIHRvIGRvXG4gICAgICByZXR1cm47XG4gIH1cblxuICAvLyBlbnN1cmUgdXBkYXRlcyBzZW50IHdpdGggcG9zaXRpb25hbCBub3RhdGlvbiBhcmVcbiAgLy8gZWRpdGluZyB0aGUgY29ycmVjdCBhcnJheSBlbGVtZW50LlxuICAvLyBvbmx5IGluY3JlbWVudCB0aGUgdmVyc2lvbiBpZiBhbiBhcnJheSBwb3NpdGlvbiBjaGFuZ2VzLlxuICAvLyBtb2RpZnlpbmcgZWxlbWVudHMgb2YgYW4gYXJyYXkgaXMgb2sgaWYgcG9zaXRpb24gZG9lcyBub3QgY2hhbmdlLlxuICBpZiAob3AgPT09ICckcHVzaCcgfHwgb3AgPT09ICckYWRkVG9TZXQnIHx8IG9wID09PSAnJHB1bGxBbGwnIHx8IG9wID09PSAnJHB1bGwnKSB7XG4gICAgaWYgKC9cXC5cXGQrXFwufFxcLlxcZCskLy50ZXN0KGRhdGEucGF0aCkpIHtcbiAgICAgIGluY3JlbWVudC5jYWxsKHNlbGYpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzZWxmLiRfXy52ZXJzaW9uID0gVkVSU0lPTl9JTkM7XG4gICAgfVxuICB9IGVsc2UgaWYgKC9eXFwkcC8udGVzdChvcCkpIHtcbiAgICAvLyBwb3RlbnRpYWxseSBjaGFuZ2luZyBhcnJheSBwb3NpdGlvbnNcbiAgICBpbmNyZW1lbnQuY2FsbChzZWxmKTtcbiAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHZhbCkpIHtcbiAgICAvLyAkc2V0IGFuIGFycmF5XG4gICAgaW5jcmVtZW50LmNhbGwoc2VsZik7XG4gIH0gZWxzZSBpZiAoL1xcLlxcZCtcXC58XFwuXFxkKyQvLnRlc3QoZGF0YS5wYXRoKSkge1xuICAgIC8vIG5vdyBoYW5kbGluZyAkc2V0LCAkdW5zZXRcbiAgICAvLyBzdWJwYXRoIG9mIGFycmF5XG4gICAgc2VsZi4kX18udmVyc2lvbiA9IFZFUlNJT05fV0hFUkU7XG4gIH1cbn1cblxuLyoqXG4gKiBDb21waWxlcyBhbiB1cGRhdGUgYW5kIHdoZXJlIGNsYXVzZSBmb3IgYSBgdmFsYCB3aXRoIF9hdG9taWNzLlxuICpcbiAqIEBwYXJhbSB7RG9jdW1lbnR9IHNlbGZcbiAqIEBwYXJhbSB7T2JqZWN0fSB3aGVyZVxuICogQHBhcmFtIHtPYmplY3R9IGRlbHRhXG4gKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICogQHBhcmFtIHtBcnJheX0gdmFsdWVcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGhhbmRsZUF0b21pY3Moc2VsZiwgd2hlcmUsIGRlbHRhLCBkYXRhLCB2YWx1ZSkge1xuICBpZiAoZGVsdGEuJHNldCAmJiBkZWx0YS4kc2V0W2RhdGEucGF0aF0pIHtcbiAgICAvLyAkc2V0IGhhcyBwcmVjZWRlbmNlIG92ZXIgb3RoZXIgYXRvbWljc1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmICh0eXBlb2YgdmFsdWUuJF9fZ2V0QXRvbWljcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHZhbHVlLiRfX2dldEF0b21pY3MoKS5mb3JFYWNoKGZ1bmN0aW9uKGF0b21pYykge1xuICAgICAgY29uc3Qgb3AgPSBhdG9taWNbMF07XG4gICAgICBjb25zdCB2YWwgPSBhdG9taWNbMV07XG4gICAgICBvcGVyYW5kKHNlbGYsIHdoZXJlLCBkZWx0YSwgZGF0YSwgdmFsLCBvcCk7XG4gICAgfSk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gbGVnYWN5IHN1cHBvcnQgZm9yIHBsdWdpbnNcblxuICBjb25zdCBhdG9taWNzID0gdmFsdWVbYXJyYXlBdG9taWNzU3ltYm9sXTtcbiAgY29uc3Qgb3BzID0gT2JqZWN0LmtleXMoYXRvbWljcyk7XG4gIGxldCBpID0gb3BzLmxlbmd0aDtcbiAgbGV0IHZhbDtcbiAgbGV0IG9wO1xuXG4gIGlmIChpID09PSAwKSB7XG4gICAgLy8gJHNldFxuXG4gICAgaWYgKHV0aWxzLmlzTW9uZ29vc2VPYmplY3QodmFsdWUpKSB7XG4gICAgICB2YWx1ZSA9IHZhbHVlLnRvT2JqZWN0KHsgZGVwb3B1bGF0ZTogMSwgX2lzTmVzdGVkOiB0cnVlIH0pO1xuICAgIH0gZWxzZSBpZiAodmFsdWUudmFsdWVPZikge1xuICAgICAgdmFsdWUgPSB2YWx1ZS52YWx1ZU9mKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG9wZXJhbmQoc2VsZiwgd2hlcmUsIGRlbHRhLCBkYXRhLCB2YWx1ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBpdGVyKG1lbSkge1xuICAgIHJldHVybiB1dGlscy5pc01vbmdvb3NlT2JqZWN0KG1lbSlcbiAgICAgID8gbWVtLnRvT2JqZWN0KHsgZGVwb3B1bGF0ZTogMSwgX2lzTmVzdGVkOiB0cnVlIH0pXG4gICAgICA6IG1lbTtcbiAgfVxuXG4gIHdoaWxlIChpLS0pIHtcbiAgICBvcCA9IG9wc1tpXTtcbiAgICB2YWwgPSBhdG9taWNzW29wXTtcblxuICAgIGlmICh1dGlscy5pc01vbmdvb3NlT2JqZWN0KHZhbCkpIHtcbiAgICAgIHZhbCA9IHZhbC50b09iamVjdCh7IGRlcG9wdWxhdGU6IHRydWUsIHRyYW5zZm9ybTogZmFsc2UsIF9pc05lc3RlZDogdHJ1ZSB9KTtcbiAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodmFsKSkge1xuICAgICAgdmFsID0gdmFsLm1hcChpdGVyKTtcbiAgICB9IGVsc2UgaWYgKHZhbC52YWx1ZU9mKSB7XG4gICAgICB2YWwgPSB2YWwudmFsdWVPZigpO1xuICAgIH1cblxuICAgIGlmIChvcCA9PT0gJyRhZGRUb1NldCcpIHtcbiAgICAgIHZhbCA9IHsgJGVhY2g6IHZhbCB9O1xuICAgIH1cblxuICAgIG9wZXJhbmQoc2VsZiwgd2hlcmUsIGRlbHRhLCBkYXRhLCB2YWwsIG9wKTtcbiAgfVxufVxuXG4vKipcbiAqIFByb2R1Y2VzIGEgc3BlY2lhbCBxdWVyeSBkb2N1bWVudCBvZiB0aGUgbW9kaWZpZWQgcHJvcGVydGllcyB1c2VkIGluIHVwZGF0ZXMuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKiBAbWV0aG9kICRfX2RlbHRhXG4gKiBAbWVtYmVyT2YgTW9kZWxcbiAqIEBpbnN0YW5jZVxuICovXG5cbk1vZGVsLnByb3RvdHlwZS4kX19kZWx0YSA9IGZ1bmN0aW9uKCkge1xuICBjb25zdCBkaXJ0eSA9IHRoaXMuJF9fZGlydHkoKTtcblxuICBjb25zdCBvcHRpbWlzdGljQ29uY3VycmVuY3kgPSB0aGlzLiRfX3NjaGVtYS5vcHRpb25zLm9wdGltaXN0aWNDb25jdXJyZW5jeTtcbiAgaWYgKG9wdGltaXN0aWNDb25jdXJyZW5jeSkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KG9wdGltaXN0aWNDb25jdXJyZW5jeSkpIHtcbiAgICAgIGNvbnN0IG9wdENvbiA9IG5ldyBTZXQob3B0aW1pc3RpY0NvbmN1cnJlbmN5KTtcbiAgICAgIGNvbnN0IG1vZFBhdGhzID0gdGhpcy5tb2RpZmllZFBhdGhzKCk7XG4gICAgICBpZiAobW9kUGF0aHMuZmluZChwYXRoID0+IG9wdENvbi5oYXMocGF0aCkpKSB7XG4gICAgICAgIHRoaXMuJF9fLnZlcnNpb24gPSBkaXJ0eS5sZW5ndGggPyBWRVJTSU9OX0FMTCA6IFZFUlNJT05fV0hFUkU7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuJF9fLnZlcnNpb24gPSBkaXJ0eS5sZW5ndGggPyBWRVJTSU9OX0FMTCA6IFZFUlNJT05fV0hFUkU7XG4gICAgfVxuICB9XG5cbiAgaWYgKCFkaXJ0eS5sZW5ndGggJiYgVkVSU0lPTl9BTEwgIT09IHRoaXMuJF9fLnZlcnNpb24pIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3Qgd2hlcmUgPSB7fTtcbiAgY29uc3QgZGVsdGEgPSB7fTtcbiAgY29uc3QgbGVuID0gZGlydHkubGVuZ3RoO1xuICBjb25zdCBkaXZlcmdlbnQgPSBbXTtcbiAgbGV0IGQgPSAwO1xuXG4gIHdoZXJlLl9pZCA9IHRoaXMuX2RvYy5faWQ7XG4gIC8vIElmIGBfaWRgIGlzIGFuIG9iamVjdCwgbmVlZCB0byBkZXBvcHVsYXRlLCBidXQgYWxzbyBuZWVkIHRvIGJlIGNhcmVmdWxcbiAgLy8gYmVjYXVzZSBgX2lkYCBjYW4gdGVjaG5pY2FsbHkgYmUgbnVsbCAoc2VlIGdoLTY0MDYpXG4gIGlmICgod2hlcmUgJiYgd2hlcmUuX2lkICYmIHdoZXJlLl9pZC4kX18gfHwgbnVsbCkgIT0gbnVsbCkge1xuICAgIHdoZXJlLl9pZCA9IHdoZXJlLl9pZC50b09iamVjdCh7IHRyYW5zZm9ybTogZmFsc2UsIGRlcG9wdWxhdGU6IHRydWUgfSk7XG4gIH1cbiAgZm9yICg7IGQgPCBsZW47ICsrZCkge1xuICAgIGNvbnN0IGRhdGEgPSBkaXJ0eVtkXTtcbiAgICBsZXQgdmFsdWUgPSBkYXRhLnZhbHVlO1xuICAgIGNvbnN0IG1hdGNoID0gY2hlY2tEaXZlcmdlbnRBcnJheSh0aGlzLCBkYXRhLnBhdGgsIHZhbHVlKTtcbiAgICBpZiAobWF0Y2gpIHtcbiAgICAgIGRpdmVyZ2VudC5wdXNoKG1hdGNoKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGNvbnN0IHBvcCA9IHRoaXMuJHBvcHVsYXRlZChkYXRhLnBhdGgsIHRydWUpO1xuICAgIGlmICghcG9wICYmIHRoaXMuJF9fLnNlbGVjdGVkKSB7XG4gICAgICAvLyBJZiBhbnkgYXJyYXkgd2FzIHNlbGVjdGVkIHVzaW5nIGFuICRlbGVtTWF0Y2ggcHJvamVjdGlvbiwgd2UgYWx0ZXIgdGhlIHBhdGggYW5kIHdoZXJlIGNsYXVzZVxuICAgICAgLy8gTk9URTogTW9uZ29EQiBvbmx5IHN1cHBvcnRzIHByb2plY3RlZCAkZWxlbU1hdGNoIG9uIHRvcCBsZXZlbCBhcnJheS5cbiAgICAgIGNvbnN0IHBhdGhTcGxpdCA9IGRhdGEucGF0aC5zcGxpdCgnLicpO1xuICAgICAgY29uc3QgdG9wID0gcGF0aFNwbGl0WzBdO1xuICAgICAgaWYgKHRoaXMuJF9fLnNlbGVjdGVkW3RvcF0gJiYgdGhpcy4kX18uc2VsZWN0ZWRbdG9wXS4kZWxlbU1hdGNoKSB7XG4gICAgICAgIC8vIElmIHRoZSBzZWxlY3RlZCBhcnJheSBlbnRyeSB3YXMgbW9kaWZpZWRcbiAgICAgICAgaWYgKHBhdGhTcGxpdC5sZW5ndGggPiAxICYmIHBhdGhTcGxpdFsxXSA9PSAwICYmIHR5cGVvZiB3aGVyZVt0b3BdID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIHdoZXJlW3RvcF0gPSB0aGlzLiRfXy5zZWxlY3RlZFt0b3BdO1xuICAgICAgICAgIHBhdGhTcGxpdFsxXSA9ICckJztcbiAgICAgICAgICBkYXRhLnBhdGggPSBwYXRoU3BsaXQuam9pbignLicpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGlmIHRoZSBzZWxlY3RlZCBhcnJheSB3YXMgbW9kaWZpZWQgaW4gYW55IG90aGVyIHdheSB0aHJvdyBhbiBlcnJvclxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBkaXZlcmdlbnQucHVzaChkYXRhLnBhdGgpO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gSWYgdGhpcyBwYXRoIGlzIHNldCB0byBkZWZhdWx0LCBhbmQgZWl0aGVyIHRoaXMgcGF0aCBvciBvbmUgb2ZcbiAgICAvLyBpdHMgcGFyZW50cyBpcyBleGNsdWRlZCwgZG9uJ3QgdHJlYXQgdGhpcyBwYXRoIGFzIGRpcnR5LlxuICAgIGlmICh0aGlzLiRpc0RlZmF1bHQoZGF0YS5wYXRoKSAmJiB0aGlzLiRfXy5zZWxlY3RlZCkge1xuICAgICAgaWYgKGRhdGEucGF0aC5pbmRleE9mKCcuJykgPT09IC0xICYmIGlzUGF0aEV4Y2x1ZGVkKHRoaXMuJF9fLnNlbGVjdGVkLCBkYXRhLnBhdGgpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBwYXRoc1RvQ2hlY2sgPSBwYXJlbnRQYXRocyhkYXRhLnBhdGgpO1xuICAgICAgaWYgKHBhdGhzVG9DaGVjay5maW5kKHBhdGggPT4gaXNQYXRoRXhjbHVkZWQodGhpcy4kX18uaXNTZWxlY3RlZCwgcGF0aCkpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChkaXZlcmdlbnQubGVuZ3RoKSBjb250aW51ZTtcbiAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgb3BlcmFuZCh0aGlzLCB3aGVyZSwgZGVsdGEsIGRhdGEsIDEsICckdW5zZXQnKTtcbiAgICB9IGVsc2UgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgICBvcGVyYW5kKHRoaXMsIHdoZXJlLCBkZWx0YSwgZGF0YSwgbnVsbCk7XG4gICAgfSBlbHNlIGlmICh1dGlscy5pc01vbmdvb3NlQXJyYXkodmFsdWUpICYmIHZhbHVlLiRwYXRoKCkgJiYgdmFsdWVbYXJyYXlBdG9taWNzU3ltYm9sXSkge1xuICAgICAgLy8gYXJyYXlzIGFuZCBvdGhlciBjdXN0b20gdHlwZXMgKHN1cHBvcnQgcGx1Z2lucyBldGMpXG4gICAgICBoYW5kbGVBdG9taWNzKHRoaXMsIHdoZXJlLCBkZWx0YSwgZGF0YSwgdmFsdWUpO1xuICAgIH0gZWxzZSBpZiAodmFsdWVbTW9uZ29vc2VCdWZmZXIucGF0aFN5bWJvbF0gJiYgQnVmZmVyLmlzQnVmZmVyKHZhbHVlKSkge1xuICAgICAgLy8gTW9uZ29vc2VCdWZmZXJcbiAgICAgIHZhbHVlID0gdmFsdWUudG9PYmplY3QoKTtcbiAgICAgIG9wZXJhbmQodGhpcywgd2hlcmUsIGRlbHRhLCBkYXRhLCB2YWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh0aGlzLiRfXy5wcmltaXRpdmVBdG9taWNzICYmIHRoaXMuJF9fLnByaW1pdGl2ZUF0b21pY3NbZGF0YS5wYXRoXSAhPSBudWxsKSB7XG4gICAgICAgIGNvbnN0IHZhbCA9IHRoaXMuJF9fLnByaW1pdGl2ZUF0b21pY3NbZGF0YS5wYXRoXTtcbiAgICAgICAgY29uc3Qgb3AgPSBmaXJzdEtleSh2YWwpO1xuICAgICAgICBvcGVyYW5kKHRoaXMsIHdoZXJlLCBkZWx0YSwgZGF0YSwgdmFsW29wXSwgb3ApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFsdWUgPSBjbG9uZSh2YWx1ZSwge1xuICAgICAgICAgIGRlcG9wdWxhdGU6IHRydWUsXG4gICAgICAgICAgdHJhbnNmb3JtOiBmYWxzZSxcbiAgICAgICAgICB2aXJ0dWFsczogZmFsc2UsXG4gICAgICAgICAgZ2V0dGVyczogZmFsc2UsXG4gICAgICAgICAgb21pdFVuZGVmaW5lZDogdHJ1ZSxcbiAgICAgICAgICBfaXNOZXN0ZWQ6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIG9wZXJhbmQodGhpcywgd2hlcmUsIGRlbHRhLCBkYXRhLCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKGRpdmVyZ2VudC5sZW5ndGgpIHtcbiAgICByZXR1cm4gbmV3IERpdmVyZ2VudEFycmF5RXJyb3IoZGl2ZXJnZW50KTtcbiAgfVxuXG4gIGlmICh0aGlzLiRfXy52ZXJzaW9uKSB7XG4gICAgdGhpcy4kX192ZXJzaW9uKHdoZXJlLCBkZWx0YSk7XG4gIH1cblxuICBpZiAoT2JqZWN0LmtleXMoZGVsdGEpLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBbd2hlcmUsIG51bGxdO1xuICB9XG5cbiAgcmV0dXJuIFt3aGVyZSwgZGVsdGFdO1xufTtcblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYXJyYXkgd2FzIHBvcHVsYXRlZCB3aXRoIHNvbWUgZm9ybSBvZiBmaWx0ZXIgYW5kIGlzIG5vd1xuICogYmVpbmcgdXBkYXRlZCBpbiBhIG1hbm5lciB3aGljaCBjb3VsZCBvdmVyd3JpdGUgZGF0YSB1bmludGVudGlvbmFsbHkuXG4gKlxuICogQHNlZSBodHRwczovL2dpdGh1Yi5jb20vQXV0b21hdHRpYy9tb25nb29zZS9pc3N1ZXMvMTMzNFxuICogQHBhcmFtIHtEb2N1bWVudH0gZG9jXG4gKiBAcGFyYW0ge1N0cmluZ30gcGF0aFxuICogQHBhcmFtIHtBbnl9IGFycmF5XG4gKiBAcmV0dXJuIHtTdHJpbmd8dW5kZWZpbmVkfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gY2hlY2tEaXZlcmdlbnRBcnJheShkb2MsIHBhdGgsIGFycmF5KSB7XG4gIC8vIHNlZSBpZiB3ZSBwb3B1bGF0ZWQgdGhpcyBwYXRoXG4gIGNvbnN0IHBvcCA9IGRvYy4kcG9wdWxhdGVkKHBhdGgsIHRydWUpO1xuXG4gIGlmICghcG9wICYmIGRvYy4kX18uc2VsZWN0ZWQpIHtcbiAgICAvLyBJZiBhbnkgYXJyYXkgd2FzIHNlbGVjdGVkIHVzaW5nIGFuICRlbGVtTWF0Y2ggcHJvamVjdGlvbiwgd2UgZGVueSB0aGUgdXBkYXRlLlxuICAgIC8vIE5PVEU6IE1vbmdvREIgb25seSBzdXBwb3J0cyBwcm9qZWN0ZWQgJGVsZW1NYXRjaCBvbiB0b3AgbGV2ZWwgYXJyYXkuXG4gICAgY29uc3QgdG9wID0gcGF0aC5zcGxpdCgnLicpWzBdO1xuICAgIGlmIChkb2MuJF9fLnNlbGVjdGVkW3RvcCArICcuJCddKSB7XG4gICAgICByZXR1cm4gdG9wO1xuICAgIH1cbiAgfVxuXG4gIGlmICghKHBvcCAmJiB1dGlscy5pc01vbmdvb3NlQXJyYXkoYXJyYXkpKSkgcmV0dXJuO1xuXG4gIC8vIElmIHRoZSBhcnJheSB3YXMgcG9wdWxhdGVkIHVzaW5nIG9wdGlvbnMgdGhhdCBwcmV2ZW50ZWQgYWxsXG4gIC8vIGRvY3VtZW50cyBmcm9tIGJlaW5nIHJldHVybmVkIChtYXRjaCwgc2tpcCwgbGltaXQpIG9yIHRoZXlcbiAgLy8gZGVzZWxlY3RlZCB0aGUgX2lkIGZpZWxkLCAkcG9wIGFuZCAkc2V0IG9mIHRoZSBhcnJheSBhcmVcbiAgLy8gbm90IHNhZmUgb3BlcmF0aW9ucy4gSWYgX2lkIHdhcyBkZXNlbGVjdGVkLCB3ZSBkbyBub3Qga25vd1xuICAvLyBob3cgdG8gcmVtb3ZlIGVsZW1lbnRzLiAkcG9wIHdpbGwgcG9wIG9mZiB0aGUgX2lkIGZyb20gdGhlIGVuZFxuICAvLyBvZiB0aGUgYXJyYXkgaW4gdGhlIGRiIHdoaWNoIGlzIG5vdCBndWFyYW50ZWVkIHRvIGJlIHRoZVxuICAvLyBzYW1lIGFzIHRoZSBsYXN0IGVsZW1lbnQgd2UgaGF2ZSBoZXJlLiAkc2V0IG9mIHRoZSBlbnRpcmUgYXJyYXlcbiAgLy8gd291bGQgYmUgc2ltaWxhcmx5IGRlc3RydWN0aXZlIGFzIHdlIG5ldmVyIHJlY2VpdmVkIGFsbFxuICAvLyBlbGVtZW50cyBvZiB0aGUgYXJyYXkgYW5kIHBvdGVudGlhbGx5IHdvdWxkIG92ZXJ3cml0ZSBkYXRhLlxuICBjb25zdCBjaGVjayA9IHBvcC5vcHRpb25zLm1hdGNoIHx8XG4gICAgICBwb3Aub3B0aW9ucy5vcHRpb25zICYmIHV0aWxzLm9iamVjdC5oYXNPd25Qcm9wZXJ0eShwb3Aub3B0aW9ucy5vcHRpb25zLCAnbGltaXQnKSB8fCAvLyAwIGlzIG5vdCBwZXJtaXR0ZWRcbiAgICAgIHBvcC5vcHRpb25zLm9wdGlvbnMgJiYgcG9wLm9wdGlvbnMub3B0aW9ucy5za2lwIHx8IC8vIDAgaXMgcGVybWl0dGVkXG4gICAgICBwb3Aub3B0aW9ucy5zZWxlY3QgJiYgLy8gZGVzZWxlY3RlZCBfaWQ/XG4gICAgICAocG9wLm9wdGlvbnMuc2VsZWN0Ll9pZCA9PT0gMCB8fFxuICAgICAgL1xccz8tX2lkXFxzPy8udGVzdChwb3Aub3B0aW9ucy5zZWxlY3QpKTtcblxuICBpZiAoY2hlY2spIHtcbiAgICBjb25zdCBhdG9taWNzID0gYXJyYXlbYXJyYXlBdG9taWNzU3ltYm9sXTtcbiAgICBpZiAoT2JqZWN0LmtleXMoYXRvbWljcykubGVuZ3RoID09PSAwIHx8IGF0b21pY3MuJHNldCB8fCBhdG9taWNzLiRwb3ApIHtcbiAgICAgIHJldHVybiBwYXRoO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEFwcGVuZHMgdmVyc2lvbmluZyB0byB0aGUgd2hlcmUgYW5kIHVwZGF0ZSBjbGF1c2VzLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICogQG1ldGhvZCAkX192ZXJzaW9uXG4gKiBAbWVtYmVyT2YgTW9kZWxcbiAqIEBpbnN0YW5jZVxuICovXG5cbk1vZGVsLnByb3RvdHlwZS4kX192ZXJzaW9uID0gZnVuY3Rpb24od2hlcmUsIGRlbHRhKSB7XG4gIGNvbnN0IGtleSA9IHRoaXMuJF9fc2NoZW1hLm9wdGlvbnMudmVyc2lvbktleTtcbiAgaWYgKHdoZXJlID09PSB0cnVlKSB7XG4gICAgLy8gdGhpcyBpcyBhbiBpbnNlcnRcbiAgICBpZiAoa2V5KSB7XG4gICAgICBzZXREb3R0ZWRQYXRoKGRlbHRhLCBrZXksIDApO1xuICAgICAgdGhpcy4kX19zZXRWYWx1ZShrZXksIDApO1xuICAgIH1cbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoa2V5ID09PSBmYWxzZSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIHVwZGF0ZXNcblxuICAvLyBvbmx5IGFwcGx5IHZlcnNpb25pbmcgaWYgb3VyIHZlcnNpb25LZXkgd2FzIHNlbGVjdGVkLiBlbHNlXG4gIC8vIHRoZXJlIGlzIG5vIHdheSB0byBzZWxlY3QgdGhlIGNvcnJlY3QgdmVyc2lvbi4gd2UgY291bGQgZmFpbFxuICAvLyBmYXN0IGhlcmUgYW5kIGZvcmNlIHRoZW0gdG8gaW5jbHVkZSB0aGUgdmVyc2lvbktleSBidXRcbiAgLy8gdGhhdHMgYSBiaXQgaW50cnVzaXZlLiBjYW4gd2UgZG8gdGhpcyBhdXRvbWF0aWNhbGx5P1xuXG4gIGlmICghdGhpcy4kX19pc1NlbGVjdGVkKGtleSkpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyAkcHVzaCAkYWRkVG9TZXQgZG9uJ3QgbmVlZCB0aGUgd2hlcmUgY2xhdXNlIHNldFxuICBpZiAoVkVSU0lPTl9XSEVSRSA9PT0gKFZFUlNJT05fV0hFUkUgJiB0aGlzLiRfXy52ZXJzaW9uKSkge1xuICAgIGNvbnN0IHZhbHVlID0gdGhpcy4kX19nZXRWYWx1ZShrZXkpO1xuICAgIGlmICh2YWx1ZSAhPSBudWxsKSB3aGVyZVtrZXldID0gdmFsdWU7XG4gIH1cblxuICBpZiAoVkVSU0lPTl9JTkMgPT09IChWRVJTSU9OX0lOQyAmIHRoaXMuJF9fLnZlcnNpb24pKSB7XG4gICAgaWYgKGdldChkZWx0YS4kc2V0LCBrZXksIG51bGwpICE9IG51bGwpIHtcbiAgICAgIC8vIFZlcnNpb24ga2V5IGlzIGdldHRpbmcgc2V0LCBtZWFucyB3ZSdsbCBpbmNyZW1lbnQgdGhlIGRvYydzIHZlcnNpb25cbiAgICAgIC8vIGFmdGVyIGEgc3VjY2Vzc2Z1bCBzYXZlLCBzbyB3ZSBzaG91bGQgc2V0IHRoZSBpbmNyZW1lbnRlZCB2ZXJzaW9uIHNvXG4gICAgICAvLyBmdXR1cmUgc2F2ZXMgZG9uJ3QgZmFpbCAoZ2gtNTc3OSlcbiAgICAgICsrZGVsdGEuJHNldFtrZXldO1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWx0YS4kaW5jID0gZGVsdGEuJGluYyB8fCB7fTtcbiAgICAgIGRlbHRhLiRpbmNba2V5XSA9IDE7XG4gICAgfVxuICB9XG59O1xuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cbmZ1bmN0aW9uIGluY3JlbWVudCgpIHtcbiAgdGhpcy4kX18udmVyc2lvbiA9IFZFUlNJT05fQUxMO1xuICByZXR1cm4gdGhpcztcbn1cblxuLyoqXG4gKiBTaWduYWwgdGhhdCB3ZSBkZXNpcmUgYW4gaW5jcmVtZW50IG9mIHRoaXMgZG9jdW1lbnRzIHZlcnNpb24uXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBjb25zdCBkb2MgPSBhd2FpdCBNb2RlbC5maW5kQnlJZChpZCk7XG4gKiAgICAgZG9jLmluY3JlbWVudCgpO1xuICogICAgIGF3YWl0IGRvYy5zYXZlKCk7XG4gKlxuICogQHNlZSB2ZXJzaW9uS2V5cyBodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvZ3VpZGUuaHRtbCN2ZXJzaW9uS2V5XG4gKiBAbWVtYmVyT2YgTW9kZWxcbiAqIEBtZXRob2QgaW5jcmVtZW50XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk1vZGVsLnByb3RvdHlwZS5pbmNyZW1lbnQgPSBpbmNyZW1lbnQ7XG5cbi8qKlxuICogUmV0dXJucyBhIHF1ZXJ5IG9iamVjdFxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICogQG1ldGhvZCAkX193aGVyZVxuICogQG1lbWJlck9mIE1vZGVsXG4gKiBAaW5zdGFuY2VcbiAqL1xuXG5Nb2RlbC5wcm90b3R5cGUuJF9fd2hlcmUgPSBmdW5jdGlvbiBfd2hlcmUod2hlcmUpIHtcbiAgd2hlcmUgfHwgKHdoZXJlID0ge30pO1xuXG4gIGlmICghd2hlcmUuX2lkKSB7XG4gICAgd2hlcmUuX2lkID0gdGhpcy5fZG9jLl9pZDtcbiAgfVxuXG4gIGlmICh0aGlzLl9kb2MuX2lkID09PSB2b2lkIDApIHtcbiAgICByZXR1cm4gbmV3IE1vbmdvb3NlRXJyb3IoJ05vIF9pZCBmb3VuZCBvbiBkb2N1bWVudCEnKTtcbiAgfVxuXG4gIHJldHVybiB3aGVyZTtcbn07XG5cbi8qKlxuICogRGVsZXRlIHRoaXMgZG9jdW1lbnQgZnJvbSB0aGUgZGIuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBhd2FpdCBwcm9kdWN0LmRlbGV0ZU9uZSgpO1xuICogICAgIGF3YWl0IFByb2R1Y3QuZmluZEJ5SWQocHJvZHVjdC5faWQpOyAvLyBudWxsXG4gKlxuICogQHJldHVybiB7UXVlcnl9IFF1ZXJ5XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk1vZGVsLnByb3RvdHlwZS5kZWxldGVPbmUgPSBmdW5jdGlvbiBkZWxldGVPbmUob3B0aW9ucykge1xuICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicgfHxcbiAgICAgIHR5cGVvZiBhcmd1bWVudHNbMV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgTW9uZ29vc2VFcnJvcignTW9kZWwucHJvdG90eXBlLmRlbGV0ZU9uZSgpIG5vIGxvbmdlciBhY2NlcHRzIGEgY2FsbGJhY2snKTtcbiAgfVxuXG4gIGlmICghb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuXG4gIGlmIChvcHRpb25zLmhhc093blByb3BlcnR5KCdzZXNzaW9uJykpIHtcbiAgICB0aGlzLiRzZXNzaW9uKG9wdGlvbnMuc2Vzc2lvbik7XG4gIH1cblxuICBjb25zdCBzZWxmID0gdGhpcztcbiAgY29uc3Qgd2hlcmUgPSB0aGlzLiRfX3doZXJlKCk7XG4gIGlmICh3aGVyZSBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgdGhyb3cgd2hlcmU7XG4gIH1cbiAgY29uc3QgcXVlcnkgPSBzZWxmLmNvbnN0cnVjdG9yLmRlbGV0ZU9uZSh3aGVyZSwgb3B0aW9ucyk7XG5cbiAgaWYgKHRoaXMuJHNlc3Npb24oKSAhPSBudWxsKSB7XG4gICAgaWYgKCEoJ3Nlc3Npb24nIGluIHF1ZXJ5Lm9wdGlvbnMpKSB7XG4gICAgICBxdWVyeS5vcHRpb25zLnNlc3Npb24gPSB0aGlzLiRzZXNzaW9uKCk7XG4gICAgfVxuICB9XG5cbiAgcXVlcnkucHJlKGZ1bmN0aW9uIHF1ZXJ5UHJlRGVsZXRlT25lKGNiKSB7XG4gICAgc2VsZi5jb25zdHJ1Y3Rvci5fbWlkZGxld2FyZS5leGVjUHJlKCdkZWxldGVPbmUnLCBzZWxmLCBbc2VsZl0sIGNiKTtcbiAgfSk7XG4gIHF1ZXJ5LnByZShmdW5jdGlvbiBjYWxsU3ViZG9jUHJlSG9va3MoY2IpIHtcbiAgICBlYWNoKHNlbGYuJGdldEFsbFN1YmRvY3MoKSwgKHN1YmRvYywgY2IpID0+IHtcbiAgICAgIHN1YmRvYy5jb25zdHJ1Y3Rvci5fbWlkZGxld2FyZS5leGVjUHJlKCdkZWxldGVPbmUnLCBzdWJkb2MsIFtzdWJkb2NdLCBjYik7XG4gICAgfSwgY2IpO1xuICB9KTtcbiAgcXVlcnkucHJlKGZ1bmN0aW9uIHNraXBJZkFscmVhZHlEZWxldGVkKGNiKSB7XG4gICAgaWYgKHNlbGYuJF9fLmlzRGVsZXRlZCkge1xuICAgICAgcmV0dXJuIGNiKEthcmVlbS5za2lwV3JhcHBlZEZ1bmN0aW9uKCkpO1xuICAgIH1cbiAgICByZXR1cm4gY2IoKTtcbiAgfSk7XG4gIHF1ZXJ5LnBvc3QoZnVuY3Rpb24gY2FsbFN1YmRvY1Bvc3RIb29rcyhjYikge1xuICAgIGVhY2goc2VsZi4kZ2V0QWxsU3ViZG9jcygpLCAoc3ViZG9jLCBjYikgPT4ge1xuICAgICAgc3ViZG9jLmNvbnN0cnVjdG9yLl9taWRkbGV3YXJlLmV4ZWNQb3N0KCdkZWxldGVPbmUnLCBzdWJkb2MsIFtzdWJkb2NdLCB7fSwgY2IpO1xuICAgIH0sIGNiKTtcbiAgfSk7XG4gIHF1ZXJ5LnBvc3QoZnVuY3Rpb24gcXVlcnlQb3N0RGVsZXRlT25lKGNiKSB7XG4gICAgc2VsZi5jb25zdHJ1Y3Rvci5fbWlkZGxld2FyZS5leGVjUG9zdCgnZGVsZXRlT25lJywgc2VsZiwgW3NlbGZdLCB7fSwgY2IpO1xuICB9KTtcblxuICByZXR1cm4gcXVlcnk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIG1vZGVsIGluc3RhbmNlIHVzZWQgdG8gY3JlYXRlIHRoaXMgZG9jdW1lbnQgaWYgbm8gYG5hbWVgIHNwZWNpZmllZC5cbiAqIElmIGBuYW1lYCBzcGVjaWZpZWQsIHJldHVybnMgdGhlIG1vZGVsIHdpdGggdGhlIGdpdmVuIGBuYW1lYC5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IGRvYyA9IG5ldyBUYW5rKHt9KTtcbiAqICAgICBkb2MuJG1vZGVsKCkgPT09IFRhbms7IC8vIHRydWVcbiAqICAgICBhd2FpdCBkb2MuJG1vZGVsKCdVc2VyJykuZmluZEJ5SWQoaWQpO1xuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBbbmFtZV0gbW9kZWwgbmFtZVxuICogQG1ldGhvZCAkbW9kZWxcbiAqIEBhcGkgcHVibGljXG4gKiBAcmV0dXJuIHtNb2RlbH1cbiAqL1xuXG5Nb2RlbC5wcm90b3R5cGUuJG1vZGVsID0gZnVuY3Rpb24gJG1vZGVsKG5hbWUpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3RvcjtcbiAgfVxuICByZXR1cm4gdGhpc1ttb2RlbERiU3ltYm9sXS5tb2RlbChuYW1lKTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgbW9kZWwgaW5zdGFuY2UgdXNlZCB0byBjcmVhdGUgdGhpcyBkb2N1bWVudCBpZiBubyBgbmFtZWAgc3BlY2lmaWVkLlxuICogSWYgYG5hbWVgIHNwZWNpZmllZCwgcmV0dXJucyB0aGUgbW9kZWwgd2l0aCB0aGUgZ2l2ZW4gYG5hbWVgLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgY29uc3QgZG9jID0gbmV3IFRhbmsoe30pO1xuICogICAgIGRvYy4kbW9kZWwoKSA9PT0gVGFuazsgLy8gdHJ1ZVxuICogICAgIGF3YWl0IGRvYy4kbW9kZWwoJ1VzZXInKS5maW5kQnlJZChpZCk7XG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IFtuYW1lXSBtb2RlbCBuYW1lXG4gKiBAbWV0aG9kIG1vZGVsXG4gKiBAYXBpIHB1YmxpY1xuICogQHJldHVybiB7TW9kZWx9XG4gKi9cblxuTW9kZWwucHJvdG90eXBlLm1vZGVsID0gTW9kZWwucHJvdG90eXBlLiRtb2RlbDtcblxuLyoqXG4gKiBSZXR1cm5zIGEgZG9jdW1lbnQgd2l0aCBgX2lkYCBvbmx5IGlmIGF0IGxlYXN0IG9uZSBkb2N1bWVudCBleGlzdHMgaW4gdGhlIGRhdGFiYXNlIHRoYXQgbWF0Y2hlc1xuICogdGhlIGdpdmVuIGBmaWx0ZXJgLCBhbmQgYG51bGxgIG90aGVyd2lzZS5cbiAqXG4gKiBVbmRlciB0aGUgaG9vZCwgYE15TW9kZWwuZXhpc3RzKHsgYW5zd2VyOiA0MiB9KWAgaXMgZXF1aXZhbGVudCB0b1xuICogYE15TW9kZWwuZmluZE9uZSh7IGFuc3dlcjogNDIgfSkuc2VsZWN0KHsgX2lkOiAxIH0pLmxlYW4oKWBcbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGF3YWl0IENoYXJhY3Rlci5kZWxldGVNYW55KHt9KTtcbiAqICAgICBhd2FpdCBDaGFyYWN0ZXIuY3JlYXRlKHsgbmFtZTogJ0plYW4tTHVjIFBpY2FyZCcgfSk7XG4gKlxuICogICAgIGF3YWl0IENoYXJhY3Rlci5leGlzdHMoeyBuYW1lOiAvcGljYXJkL2kgfSk7IC8vIHsgX2lkOiAuLi4gfVxuICogICAgIGF3YWl0IENoYXJhY3Rlci5leGlzdHMoeyBuYW1lOiAvcmlrZXIvaSB9KTsgLy8gbnVsbFxuICpcbiAqIFRoaXMgZnVuY3Rpb24gdHJpZ2dlcnMgdGhlIGZvbGxvd2luZyBtaWRkbGV3YXJlLlxuICpcbiAqIC0gYGZpbmRPbmUoKWBcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gZmlsdGVyXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIG9wdGlvbmFsIHNlZSBbYFF1ZXJ5LnByb3RvdHlwZS5zZXRPcHRpb25zKClgXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvYXBpL3F1ZXJ5Lmh0bWwjUXVlcnkucHJvdG90eXBlLnNldE9wdGlvbnMoKSlcbiAqIEByZXR1cm4ge1F1ZXJ5fVxuICovXG5cbk1vZGVsLmV4aXN0cyA9IGZ1bmN0aW9uIGV4aXN0cyhmaWx0ZXIsIG9wdGlvbnMpIHtcbiAgX2NoZWNrQ29udGV4dCh0aGlzLCAnZXhpc3RzJyk7XG4gIGlmICh0eXBlb2YgYXJndW1lbnRzWzJdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IE1vbmdvb3NlRXJyb3IoJ01vZGVsLmV4aXN0cygpIG5vIGxvbmdlciBhY2NlcHRzIGEgY2FsbGJhY2snKTtcbiAgfVxuXG4gIGNvbnN0IHF1ZXJ5ID0gdGhpcy5maW5kT25lKGZpbHRlcikuXG4gICAgc2VsZWN0KHsgX2lkOiAxIH0pLlxuICAgIGxlYW4oKS5cbiAgICBzZXRPcHRpb25zKG9wdGlvbnMpO1xuXG4gIHJldHVybiBxdWVyeTtcbn07XG5cbi8qKlxuICogQWRkcyBhIGRpc2NyaW1pbmF0b3IgdHlwZS5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGZ1bmN0aW9uIEJhc2VTY2hlbWEoKSB7XG4gKiAgICAgICBTY2hlbWEuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAqXG4gKiAgICAgICB0aGlzLmFkZCh7XG4gKiAgICAgICAgIG5hbWU6IFN0cmluZyxcbiAqICAgICAgICAgY3JlYXRlZEF0OiBEYXRlXG4gKiAgICAgICB9KTtcbiAqICAgICB9XG4gKiAgICAgdXRpbC5pbmhlcml0cyhCYXNlU2NoZW1hLCBTY2hlbWEpO1xuICpcbiAqICAgICBjb25zdCBQZXJzb25TY2hlbWEgPSBuZXcgQmFzZVNjaGVtYSgpO1xuICogICAgIGNvbnN0IEJvc3NTY2hlbWEgPSBuZXcgQmFzZVNjaGVtYSh7IGRlcGFydG1lbnQ6IFN0cmluZyB9KTtcbiAqXG4gKiAgICAgY29uc3QgUGVyc29uID0gbW9uZ29vc2UubW9kZWwoJ1BlcnNvbicsIFBlcnNvblNjaGVtYSk7XG4gKiAgICAgY29uc3QgQm9zcyA9IFBlcnNvbi5kaXNjcmltaW5hdG9yKCdCb3NzJywgQm9zc1NjaGVtYSk7XG4gKiAgICAgbmV3IEJvc3MoKS5fX3Q7IC8vIFwiQm9zc1wiLiBgX190YCBpcyB0aGUgZGVmYXVsdCBgZGlzY3JpbWluYXRvcktleWBcbiAqXG4gKiAgICAgY29uc3QgZW1wbG95ZWVTY2hlbWEgPSBuZXcgU2NoZW1hKHsgYm9zczogT2JqZWN0SWQgfSk7XG4gKiAgICAgY29uc3QgRW1wbG95ZWUgPSBQZXJzb24uZGlzY3JpbWluYXRvcignRW1wbG95ZWUnLCBlbXBsb3llZVNjaGVtYSwgJ3N0YWZmJyk7XG4gKiAgICAgbmV3IEVtcGxveWVlKCkuX190OyAvLyBcInN0YWZmXCIgYmVjYXVzZSBvZiAzcmQgYXJndW1lbnQgYWJvdmVcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBkaXNjcmltaW5hdG9yIG1vZGVsIG5hbWVcbiAqIEBwYXJhbSB7U2NoZW1hfSBzY2hlbWEgZGlzY3JpbWluYXRvciBtb2RlbCBzY2hlbWFcbiAqIEBwYXJhbSB7T2JqZWN0fFN0cmluZ30gW29wdGlvbnNdIElmIHN0cmluZywgc2FtZSBhcyBgb3B0aW9ucy52YWx1ZWAuXG4gKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMudmFsdWVdIHRoZSBzdHJpbmcgc3RvcmVkIGluIHRoZSBgZGlzY3JpbWluYXRvcktleWAgcHJvcGVydHkuIElmIG5vdCBzcGVjaWZpZWQsIE1vbmdvb3NlIHVzZXMgdGhlIGBuYW1lYCBwYXJhbWV0ZXIuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmNsb25lPXRydWVdIEJ5IGRlZmF1bHQsIGBkaXNjcmltaW5hdG9yKClgIGNsb25lcyB0aGUgZ2l2ZW4gYHNjaGVtYWAuIFNldCB0byBgZmFsc2VgIHRvIHNraXAgY2xvbmluZy5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMub3ZlcndyaXRlTW9kZWxzPWZhbHNlXSBieSBkZWZhdWx0LCBNb25nb29zZSBkb2VzIG5vdCBhbGxvdyB5b3UgdG8gZGVmaW5lIGEgZGlzY3JpbWluYXRvciB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgYW5vdGhlciBkaXNjcmltaW5hdG9yLiBTZXQgdGhpcyB0byBhbGxvdyBvdmVyd3JpdGluZyBkaXNjcmltaW5hdG9ycyB3aXRoIHRoZSBzYW1lIG5hbWUuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLm1lcmdlSG9va3M9dHJ1ZV0gQnkgZGVmYXVsdCwgTW9uZ29vc2UgbWVyZ2VzIHRoZSBiYXNlIHNjaGVtYSdzIGhvb2tzIHdpdGggdGhlIGRpc2NyaW1pbmF0b3Igc2NoZW1hJ3MgaG9va3MuIFNldCB0aGlzIG9wdGlvbiB0byBgZmFsc2VgIHRvIG1ha2UgTW9uZ29vc2UgdXNlIHRoZSBkaXNjcmltaW5hdG9yIHNjaGVtYSdzIGhvb2tzIGluc3RlYWQuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLm1lcmdlUGx1Z2lucz10cnVlXSBCeSBkZWZhdWx0LCBNb25nb29zZSBtZXJnZXMgdGhlIGJhc2Ugc2NoZW1hJ3MgcGx1Z2lucyB3aXRoIHRoZSBkaXNjcmltaW5hdG9yIHNjaGVtYSdzIHBsdWdpbnMuIFNldCB0aGlzIG9wdGlvbiB0byBgZmFsc2VgIHRvIG1ha2UgTW9uZ29vc2UgdXNlIHRoZSBkaXNjcmltaW5hdG9yIHNjaGVtYSdzIHBsdWdpbnMgaW5zdGVhZC5cbiAqIEByZXR1cm4ge01vZGVsfSBUaGUgbmV3bHkgY3JlYXRlZCBkaXNjcmltaW5hdG9yIG1vZGVsXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk1vZGVsLmRpc2NyaW1pbmF0b3IgPSBmdW5jdGlvbihuYW1lLCBzY2hlbWEsIG9wdGlvbnMpIHtcbiAgbGV0IG1vZGVsO1xuICBpZiAodHlwZW9mIG5hbWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICBtb2RlbCA9IG5hbWU7XG4gICAgbmFtZSA9IHV0aWxzLmdldEZ1bmN0aW9uTmFtZShtb2RlbCk7XG4gICAgaWYgKCEobW9kZWwucHJvdG90eXBlIGluc3RhbmNlb2YgTW9kZWwpKSB7XG4gICAgICB0aHJvdyBuZXcgTW9uZ29vc2VFcnJvcignVGhlIHByb3ZpZGVkIGNsYXNzICcgKyBuYW1lICsgJyBtdXN0IGV4dGVuZCBNb2RlbCcpO1xuICAgIH1cbiAgfVxuXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBjb25zdCB2YWx1ZSA9IHV0aWxzLmlzUE9KTyhvcHRpb25zKSA/IG9wdGlvbnMudmFsdWUgOiBvcHRpb25zO1xuICBjb25zdCBjbG9uZSA9IHR5cGVvZiBvcHRpb25zLmNsb25lID09PSAnYm9vbGVhbicgPyBvcHRpb25zLmNsb25lIDogdHJ1ZTtcbiAgY29uc3QgbWVyZ2VQbHVnaW5zID0gdHlwZW9mIG9wdGlvbnMubWVyZ2VQbHVnaW5zID09PSAnYm9vbGVhbicgPyBvcHRpb25zLm1lcmdlUGx1Z2lucyA6IHRydWU7XG5cbiAgX2NoZWNrQ29udGV4dCh0aGlzLCAnZGlzY3JpbWluYXRvcicpO1xuXG4gIGlmICh1dGlscy5pc09iamVjdChzY2hlbWEpICYmICFzY2hlbWEuaW5zdGFuY2VPZlNjaGVtYSkge1xuICAgIHNjaGVtYSA9IG5ldyBTY2hlbWEoc2NoZW1hKTtcbiAgfVxuICBpZiAoc2NoZW1hIGluc3RhbmNlb2YgU2NoZW1hICYmIGNsb25lKSB7XG4gICAgc2NoZW1hID0gc2NoZW1hLmNsb25lKCk7XG4gIH1cblxuICBzY2hlbWEgPSBkaXNjcmltaW5hdG9yKHRoaXMsIG5hbWUsIHNjaGVtYSwgdmFsdWUsIG1lcmdlUGx1Z2lucywgb3B0aW9ucy5tZXJnZUhvb2tzKTtcbiAgaWYgKHRoaXMuZGIubW9kZWxzW25hbWVdICYmICFzY2hlbWEub3B0aW9ucy5vdmVyd3JpdGVNb2RlbHMpIHtcbiAgICB0aHJvdyBuZXcgT3ZlcndyaXRlTW9kZWxFcnJvcihuYW1lKTtcbiAgfVxuXG4gIHNjaGVtYS4kaXNSb290RGlzY3JpbWluYXRvciA9IHRydWU7XG4gIHNjaGVtYS4kZ2xvYmFsUGx1Z2luc0FwcGxpZWQgPSB0cnVlO1xuXG4gIG1vZGVsID0gdGhpcy5kYi5tb2RlbChtb2RlbCB8fCBuYW1lLCBzY2hlbWEsIHRoaXMuJF9fY29sbGVjdGlvbi5uYW1lKTtcbiAgdGhpcy5kaXNjcmltaW5hdG9yc1tuYW1lXSA9IG1vZGVsO1xuICBjb25zdCBkID0gdGhpcy5kaXNjcmltaW5hdG9yc1tuYW1lXTtcbiAgT2JqZWN0LnNldFByb3RvdHlwZU9mKGQucHJvdG90eXBlLCB0aGlzLnByb3RvdHlwZSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShkLCAnYmFzZU1vZGVsTmFtZScsIHtcbiAgICB2YWx1ZTogdGhpcy5tb2RlbE5hbWUsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIHdyaXRhYmxlOiBmYWxzZVxuICB9KTtcblxuICAvLyBhcHBseSBtZXRob2RzIGFuZCBzdGF0aWNzXG4gIGFwcGx5TWV0aG9kcyhkLCBzY2hlbWEpO1xuICBhcHBseVN0YXRpY3MoZCwgc2NoZW1hKTtcblxuICBpZiAodGhpc1tzdWJjbGFzc2VkU3ltYm9sXSAhPSBudWxsKSB7XG4gICAgZm9yIChjb25zdCBzdWJtb2RlbCBvZiB0aGlzW3N1YmNsYXNzZWRTeW1ib2xdKSB7XG4gICAgICBzdWJtb2RlbC5kaXNjcmltaW5hdG9ycyA9IHN1Ym1vZGVsLmRpc2NyaW1pbmF0b3JzIHx8IHt9O1xuICAgICAgc3VibW9kZWwuZGlzY3JpbWluYXRvcnNbbmFtZV0gPVxuICAgICAgICBtb2RlbC5fX3N1YmNsYXNzKG1vZGVsLmRiLCBzY2hlbWEsIHN1Ym1vZGVsLmNvbGxlY3Rpb24ubmFtZSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGQ7XG59O1xuXG4vKipcbiAqIE1ha2Ugc3VyZSBgdGhpc2AgaXMgYSBtb2RlbFxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gX2NoZWNrQ29udGV4dChjdHgsIGZuTmFtZSkge1xuICAvLyBDaGVjayBjb250ZXh0LCBiZWNhdXNlIGl0IGlzIGVhc3kgdG8gbWlzdGFrZW5seSB0eXBlXG4gIC8vIGBuZXcgTW9kZWwuZGlzY3JpbWluYXRvcigpYCBhbmQgZ2V0IGFuIGluY29tcHJlaGVuc2libGUgZXJyb3JcbiAgaWYgKGN0eCA9PSBudWxsIHx8IGN0eCA9PT0gZ2xvYmFsKSB7XG4gICAgdGhyb3cgbmV3IE1vbmdvb3NlRXJyb3IoJ2BNb2RlbC4nICsgZm5OYW1lICsgJygpYCBjYW5ub3QgcnVuIHdpdGhvdXQgYSAnICtcbiAgICAgICdtb2RlbCBhcyBgdGhpc2AuIE1ha2Ugc3VyZSB5b3UgYXJlIGNhbGxpbmcgYE15TW9kZWwuJyArIGZuTmFtZSArICcoKWAgJyArXG4gICAgICAnd2hlcmUgYE15TW9kZWxgIGlzIGEgTW9uZ29vc2UgbW9kZWwuJyk7XG4gIH0gZWxzZSBpZiAoY3R4W21vZGVsU3ltYm9sXSA9PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IE1vbmdvb3NlRXJyb3IoJ2BNb2RlbC4nICsgZm5OYW1lICsgJygpYCBjYW5ub3QgcnVuIHdpdGhvdXQgYSAnICtcbiAgICAgICdtb2RlbCBhcyBgdGhpc2AuIE1ha2Ugc3VyZSB5b3UgYXJlIG5vdCBjYWxsaW5nICcgK1xuICAgICAgJ2BuZXcgTW9kZWwuJyArIGZuTmFtZSArICcoKWAnKTtcbiAgfVxufVxuXG4vLyBNb2RlbCAoY2xhc3MpIGZlYXR1cmVzXG5cbi8qIVxuICogR2l2ZSB0aGUgY29uc3RydWN0b3IgdGhlIGFiaWxpdHkgdG8gZW1pdCBldmVudHMuXG4gKi9cblxuZm9yIChjb25zdCBpIGluIEV2ZW50RW1pdHRlci5wcm90b3R5cGUpIHtcbiAgTW9kZWxbaV0gPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlW2ldO1xufVxuXG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gaXMgcmVzcG9uc2libGUgZm9yIGluaXRpYWxpemluZyB0aGUgdW5kZXJseWluZyBjb25uZWN0aW9uIGluIE1vbmdvREIgYmFzZWQgb24gc2NoZW1hIG9wdGlvbnMuXG4gKiBUaGlzIGZ1bmN0aW9uIHBlcmZvcm1zIHRoZSBmb2xsb3dpbmcgb3BlcmF0aW9uczpcbiAqXG4gKiAtIGBjcmVhdGVDb2xsZWN0aW9uKClgIHVubGVzcyBbYGF1dG9DcmVhdGVgXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvZ3VpZGUuaHRtbCNhdXRvQ3JlYXRlKSBvcHRpb24gaXMgdHVybmVkIG9mZlxuICogLSBgZW5zdXJlSW5kZXhlcygpYCB1bmxlc3MgW2BhdXRvSW5kZXhgXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvZ3VpZGUuaHRtbCNhdXRvSW5kZXgpIG9wdGlvbiBpcyB0dXJuZWQgb2ZmXG4gKiAtIGBjcmVhdGVTZWFyY2hJbmRleCgpYCBvbiBhbGwgc2NoZW1hIHNlYXJjaCBpbmRleGVzIGlmIGBhdXRvU2VhcmNoSW5kZXhgIGlzIGVuYWJsZWQuXG4gKlxuICogTW9uZ29vc2UgY2FsbHMgdGhpcyBmdW5jdGlvbiBhdXRvbWF0aWNhbGx5IHdoZW4gYSBtb2RlbCBpcyBhIGNyZWF0ZWQgdXNpbmdcbiAqIFtgbW9uZ29vc2UubW9kZWwoKWBdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvbW9uZ29vc2UuaHRtbCNNb25nb29zZS5wcm90b3R5cGUubW9kZWwoKSkgb3JcbiAqIFtgY29ubmVjdGlvbi5tb2RlbCgpYF0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2FwaS9jb25uZWN0aW9uLmh0bWwjQ29ubmVjdGlvbi5wcm90b3R5cGUubW9kZWwoKSksIHNvIHlvdVxuICogZG9uJ3QgbmVlZCB0byBjYWxsIGBpbml0KClgIHRvIHRyaWdnZXIgaW5kZXggYnVpbGRzLlxuICpcbiAqIEhvd2V2ZXIsIHlvdSBfbWF5XyBuZWVkIHRvIGNhbGwgYGluaXQoKWAgIHRvIGdldCBiYWNrIGEgcHJvbWlzZSB0aGF0IHdpbGwgcmVzb2x2ZSB3aGVuIHlvdXIgaW5kZXhlcyBhcmUgZmluaXNoZWQuXG4gKiBDYWxsaW5nIGBhd2FpdCBNb2RlbC5pbml0KClgIGlzIGhlbHBmdWwgaWYgeW91IG5lZWQgdG8gd2FpdCBmb3IgaW5kZXhlcyB0byBidWlsZCBiZWZvcmUgY29udGludWluZy5cbiAqIEZvciBleGFtcGxlLCBpZiB5b3Ugd2FudCB0byB3YWl0IGZvciB1bmlxdWUgaW5kZXhlcyB0byBidWlsZCBiZWZvcmUgY29udGludWluZyB3aXRoIGEgdGVzdCBjYXNlLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgY29uc3QgZXZlbnRTY2hlbWEgPSBuZXcgU2NoZW1hKHsgdGhpbmc6IHsgdHlwZTogJ3N0cmluZycsIHVuaXF1ZTogdHJ1ZSB9IH0pXG4gKiAgICAgLy8gVGhpcyBjYWxscyBgRXZlbnQuaW5pdCgpYCBpbXBsaWNpdGx5LCBzbyB5b3UgZG9uJ3QgbmVlZCB0byBjYWxsXG4gKiAgICAgLy8gYEV2ZW50LmluaXQoKWAgb24geW91ciBvd24uXG4gKiAgICAgY29uc3QgRXZlbnQgPSBtb25nb29zZS5tb2RlbCgnRXZlbnQnLCBldmVudFNjaGVtYSk7XG4gKlxuICogICAgIGF3YWl0IEV2ZW50LmluaXQoKTtcbiAqICAgICBjb25zb2xlLmxvZygnSW5kZXhlcyBhcmUgZG9uZSBidWlsZGluZyEnKTtcbiAqXG4gKiBAYXBpIHB1YmxpY1xuICogQHJldHVybnMge1Byb21pc2V9XG4gKi9cblxuTW9kZWwuaW5pdCA9IGZ1bmN0aW9uIGluaXQoKSB7XG4gIF9jaGVja0NvbnRleHQodGhpcywgJ2luaXQnKTtcbiAgaWYgKHR5cGVvZiBhcmd1bWVudHNbMF0gPT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgTW9uZ29vc2VFcnJvcignTW9kZWwuaW5pdCgpIG5vIGxvbmdlciBhY2NlcHRzIGEgY2FsbGJhY2snKTtcbiAgfVxuXG4gIHRoaXMuc2NoZW1hLmVtaXQoJ2luaXQnLCB0aGlzKTtcblxuICBpZiAodGhpcy4kaW5pdCAhPSBudWxsKSB7XG4gICAgcmV0dXJuIHRoaXMuJGluaXQ7XG4gIH1cblxuICBjb25zdCBjb25uID0gdGhpcy5kYjtcbiAgY29uc3QgX2Vuc3VyZUluZGV4ZXMgPSBhc3luYygpID0+IHtcbiAgICBjb25zdCBhdXRvSW5kZXggPSB1dGlscy5nZXRPcHRpb24oXG4gICAgICAnYXV0b0luZGV4JyxcbiAgICAgIHRoaXMuc2NoZW1hLm9wdGlvbnMsXG4gICAgICBjb25uLmNvbmZpZyxcbiAgICAgIGNvbm4uYmFzZS5vcHRpb25zXG4gICAgKTtcbiAgICBpZiAoIWF1dG9JbmRleCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICByZXR1cm4gYXdhaXQgdGhpcy5lbnN1cmVJbmRleGVzKHsgX2F1dG9tYXRpYzogdHJ1ZSB9KTtcbiAgfTtcbiAgY29uc3QgX2NyZWF0ZVNlYXJjaEluZGV4ZXMgPSBhc3luYygpID0+IHtcbiAgICBjb25zdCBhdXRvU2VhcmNoSW5kZXggPSB1dGlscy5nZXRPcHRpb24oXG4gICAgICAnYXV0b1NlYXJjaEluZGV4JyxcbiAgICAgIHRoaXMuc2NoZW1hLm9wdGlvbnMsXG4gICAgICBjb25uLmNvbmZpZyxcbiAgICAgIGNvbm4uYmFzZS5vcHRpb25zXG4gICAgKTtcbiAgICBpZiAoIWF1dG9TZWFyY2hJbmRleCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHJlc3VsdHMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IHNlYXJjaEluZGV4IG9mIHRoaXMuc2NoZW1hLl9zZWFyY2hJbmRleGVzKSB7XG4gICAgICByZXN1bHRzLnB1c2goYXdhaXQgdGhpcy5jcmVhdGVTZWFyY2hJbmRleChzZWFyY2hJbmRleCkpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0cztcbiAgfTtcbiAgY29uc3QgX2NyZWF0ZUNvbGxlY3Rpb24gPSBhc3luYygpID0+IHtcbiAgICBpZiAoKGNvbm4ucmVhZHlTdGF0ZSA9PT0gU1RBVEVTLmNvbm5lY3RpbmcgfHwgY29ubi5yZWFkeVN0YXRlID09PSBTVEFURVMuZGlzY29ubmVjdGVkKSAmJiBjb25uLl9zaG91bGRCdWZmZXJDb21tYW5kcygpKSB7XG4gICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgICAgY29ubi5fcXVldWUucHVzaCh7IGZuOiByZXNvbHZlIH0pO1xuICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnN0IGF1dG9DcmVhdGUgPSB1dGlscy5nZXRPcHRpb24oXG4gICAgICAnYXV0b0NyZWF0ZScsXG4gICAgICB0aGlzLnNjaGVtYS5vcHRpb25zLFxuICAgICAgY29ubi5jb25maWcsXG4gICAgICBjb25uLmJhc2Uub3B0aW9uc1xuICAgICk7XG4gICAgaWYgKCFhdXRvQ3JlYXRlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHJldHVybiBhd2FpdCB0aGlzLmNyZWF0ZUNvbGxlY3Rpb24oKTtcbiAgfTtcblxuICB0aGlzLiRpbml0ID0gX2NyZWF0ZUNvbGxlY3Rpb24oKS5cbiAgICB0aGVuKCgpID0+IF9lbnN1cmVJbmRleGVzKCkpLlxuICAgIHRoZW4oKCkgPT4gX2NyZWF0ZVNlYXJjaEluZGV4ZXMoKSk7XG5cbiAgY29uc3QgX2NhdGNoID0gdGhpcy4kaW5pdC5jYXRjaDtcbiAgY29uc3QgX3RoaXMgPSB0aGlzO1xuICB0aGlzLiRpbml0LmNhdGNoID0gZnVuY3Rpb24oKSB7XG4gICAgX3RoaXMuJGNhdWdodCA9IHRydWU7XG4gICAgcmV0dXJuIF9jYXRjaC5hcHBseShfdGhpcy4kaW5pdCwgYXJndW1lbnRzKTtcbiAgfTtcblxuICByZXR1cm4gdGhpcy4kaW5pdDtcbn07XG5cblxuLyoqXG4gKiBDcmVhdGUgdGhlIGNvbGxlY3Rpb24gZm9yIHRoaXMgbW9kZWwuIEJ5IGRlZmF1bHQsIGlmIG5vIGluZGV4ZXMgYXJlIHNwZWNpZmllZCxcbiAqIG1vbmdvb3NlIHdpbGwgbm90IGNyZWF0ZSB0aGUgY29sbGVjdGlvbiBmb3IgdGhlIG1vZGVsIHVudGlsIGFueSBkb2N1bWVudHMgYXJlXG4gKiBjcmVhdGVkLiBVc2UgdGhpcyBtZXRob2QgdG8gY3JlYXRlIHRoZSBjb2xsZWN0aW9uIGV4cGxpY2l0bHkuXG4gKlxuICogTm90ZSAxOiBZb3UgbWF5IG5lZWQgdG8gY2FsbCB0aGlzIGJlZm9yZSBzdGFydGluZyBhIHRyYW5zYWN0aW9uXG4gKiBTZWUgaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvY29yZS90cmFuc2FjdGlvbnMvI3RyYW5zYWN0aW9ucy1hbmQtb3BlcmF0aW9uc1xuICpcbiAqIE5vdGUgMjogWW91IGRvbid0IGhhdmUgdG8gY2FsbCB0aGlzIGlmIHlvdXIgc2NoZW1hIGNvbnRhaW5zIGluZGV4IG9yIHVuaXF1ZSBmaWVsZC5cbiAqIEluIHRoYXQgY2FzZSwganVzdCB1c2UgYE1vZGVsLmluaXQoKWBcbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IHVzZXJTY2hlbWEgPSBuZXcgU2NoZW1hKHsgbmFtZTogU3RyaW5nIH0pXG4gKiAgICAgY29uc3QgVXNlciA9IG1vbmdvb3NlLm1vZGVsKCdVc2VyJywgdXNlclNjaGVtYSk7XG4gKlxuICogICAgIFVzZXIuY3JlYXRlQ29sbGVjdGlvbigpLnRoZW4oZnVuY3Rpb24oY29sbGVjdGlvbikge1xuICogICAgICAgY29uc29sZS5sb2coJ0NvbGxlY3Rpb24gaXMgY3JlYXRlZCEnKTtcbiAqICAgICB9KTtcbiAqXG4gKiBAYXBpIHB1YmxpY1xuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBzZWUgW01vbmdvREIgZHJpdmVyIGRvY3NdKGh0dHBzOi8vbW9uZ29kYi5naXRodWIuaW8vbm9kZS1tb25nb2RiLW5hdGl2ZS80LjkvY2xhc3Nlcy9EYi5odG1sI2NyZWF0ZUNvbGxlY3Rpb24pXG4gKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAqL1xuXG5Nb2RlbC5jcmVhdGVDb2xsZWN0aW9uID0gYXN5bmMgZnVuY3Rpb24gY3JlYXRlQ29sbGVjdGlvbihvcHRpb25zKSB7XG4gIF9jaGVja0NvbnRleHQodGhpcywgJ2NyZWF0ZUNvbGxlY3Rpb24nKTtcbiAgaWYgKHR5cGVvZiBhcmd1bWVudHNbMF0gPT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIGFyZ3VtZW50c1sxXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBNb25nb29zZUVycm9yKCdNb2RlbC5jcmVhdGVDb2xsZWN0aW9uKCkgbm8gbG9uZ2VyIGFjY2VwdHMgYSBjYWxsYmFjaycpO1xuICB9XG5cbiAgY29uc3Qgc2hvdWxkU2tpcCA9IGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICB0aGlzLmhvb2tzLmV4ZWNQcmUoJ2NyZWF0ZUNvbGxlY3Rpb24nLCB0aGlzLCBbb3B0aW9uc10sIChlcnIpID0+IHtcbiAgICAgIGlmIChlcnIgIT0gbnVsbCkge1xuICAgICAgICBpZiAoZXJyIGluc3RhbmNlb2YgS2FyZWVtLnNraXBXcmFwcGVkRnVuY3Rpb24pIHtcbiAgICAgICAgICByZXR1cm4gcmVzb2x2ZSh0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVqZWN0KGVycik7XG4gICAgICB9XG4gICAgICByZXNvbHZlKCk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGNvbnN0IGNvbGxlY3Rpb25PcHRpb25zID0gdGhpcyAmJlxuICAgIHRoaXMuc2NoZW1hICYmXG4gICAgdGhpcy5zY2hlbWEub3B0aW9ucyAmJlxuICAgIHRoaXMuc2NoZW1hLm9wdGlvbnMuY29sbGVjdGlvbk9wdGlvbnM7XG4gIGlmIChjb2xsZWN0aW9uT3B0aW9ucyAhPSBudWxsKSB7XG4gICAgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIGNvbGxlY3Rpb25PcHRpb25zLCBvcHRpb25zKTtcbiAgfVxuXG4gIGNvbnN0IHNjaGVtYUNvbGxhdGlvbiA9IHRoaXMgJiZcbiAgICB0aGlzLnNjaGVtYSAmJlxuICAgIHRoaXMuc2NoZW1hLm9wdGlvbnMgJiZcbiAgICB0aGlzLnNjaGVtYS5vcHRpb25zLmNvbGxhdGlvbjtcbiAgaWYgKHNjaGVtYUNvbGxhdGlvbiAhPSBudWxsKSB7XG4gICAgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oeyBjb2xsYXRpb246IHNjaGVtYUNvbGxhdGlvbiB9LCBvcHRpb25zKTtcbiAgfVxuICBjb25zdCBjYXBwZWQgPSB0aGlzICYmXG4gICAgdGhpcy5zY2hlbWEgJiZcbiAgICB0aGlzLnNjaGVtYS5vcHRpb25zICYmXG4gICAgdGhpcy5zY2hlbWEub3B0aW9ucy5jYXBwZWQ7XG4gIGlmIChjYXBwZWQgIT0gbnVsbCkge1xuICAgIGlmICh0eXBlb2YgY2FwcGVkID09PSAnbnVtYmVyJykge1xuICAgICAgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oeyBjYXBwZWQ6IHRydWUsIHNpemU6IGNhcHBlZCB9LCBvcHRpb25zKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBjYXBwZWQgPT09ICdvYmplY3QnKSB7XG4gICAgICBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7IGNhcHBlZDogdHJ1ZSB9LCBjYXBwZWQsIG9wdGlvbnMpO1xuICAgIH1cbiAgfVxuICBjb25zdCB0aW1lc2VyaWVzID0gdGhpcyAmJlxuICAgIHRoaXMuc2NoZW1hICYmXG4gICAgdGhpcy5zY2hlbWEub3B0aW9ucyAmJlxuICAgIHRoaXMuc2NoZW1hLm9wdGlvbnMudGltZXNlcmllcztcbiAgaWYgKHRpbWVzZXJpZXMgIT0gbnVsbCkge1xuICAgIG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHsgdGltZXNlcmllcyB9LCBvcHRpb25zKTtcbiAgICBpZiAob3B0aW9ucy5leHBpcmVBZnRlclNlY29uZHMgIT0gbnVsbCkge1xuICAgICAgLy8gZG8gbm90aGluZ1xuICAgIH0gZWxzZSBpZiAob3B0aW9ucy5leHBpcmVzICE9IG51bGwpIHtcbiAgICAgIHV0aWxzLmV4cGlyZXMob3B0aW9ucyk7XG4gICAgfSBlbHNlIGlmICh0aGlzLnNjaGVtYS5vcHRpb25zLmV4cGlyZUFmdGVyU2Vjb25kcyAhPSBudWxsKSB7XG4gICAgICBvcHRpb25zLmV4cGlyZUFmdGVyU2Vjb25kcyA9IHRoaXMuc2NoZW1hLm9wdGlvbnMuZXhwaXJlQWZ0ZXJTZWNvbmRzO1xuICAgIH0gZWxzZSBpZiAodGhpcy5zY2hlbWEub3B0aW9ucy5leHBpcmVzICE9IG51bGwpIHtcbiAgICAgIG9wdGlvbnMuZXhwaXJlcyA9IHRoaXMuc2NoZW1hLm9wdGlvbnMuZXhwaXJlcztcbiAgICAgIHV0aWxzLmV4cGlyZXMob3B0aW9ucyk7XG4gICAgfVxuICB9XG5cbiAgY29uc3QgY2x1c3RlcmVkSW5kZXggPSB0aGlzICYmXG4gICAgdGhpcy5zY2hlbWEgJiZcbiAgICB0aGlzLnNjaGVtYS5vcHRpb25zICYmXG4gICAgdGhpcy5zY2hlbWEub3B0aW9ucy5jbHVzdGVyZWRJbmRleDtcbiAgaWYgKGNsdXN0ZXJlZEluZGV4ICE9IG51bGwpIHtcbiAgICBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7IGNsdXN0ZXJlZEluZGV4OiB7IC4uLmNsdXN0ZXJlZEluZGV4LCB1bmlxdWU6IHRydWUgfSB9LCBvcHRpb25zKTtcbiAgfVxuXG4gIHRyeSB7XG4gICAgaWYgKCFzaG91bGRTa2lwKSB7XG4gICAgICBhd2FpdCB0aGlzLmRiLmNyZWF0ZUNvbGxlY3Rpb24odGhpcy4kX19jb2xsZWN0aW9uLmNvbGxlY3Rpb25OYW1lLCBvcHRpb25zKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGlmIChlcnIgIT0gbnVsbCAmJiAoZXJyLm5hbWUgIT09ICdNb25nb1NlcnZlckVycm9yJyB8fCBlcnIuY29kZSAhPT0gNDgpKSB7XG4gICAgICBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIGNvbnN0IF9vcHRzID0geyBlcnJvcjogZXJyIH07XG4gICAgICAgIHRoaXMuaG9va3MuZXhlY1Bvc3QoJ2NyZWF0ZUNvbGxlY3Rpb24nLCB0aGlzLCBbbnVsbF0sIF9vcHRzLCAoZXJyKSA9PiB7XG4gICAgICAgICAgaWYgKGVyciAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVqZWN0KGVycik7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgdGhpcy5ob29rcy5leGVjUG9zdCgnY3JlYXRlQ29sbGVjdGlvbicsIHRoaXMsIFt0aGlzLiRfX2NvbGxlY3Rpb25dLCAoZXJyKSA9PiB7XG4gICAgICBpZiAoZXJyICE9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHJlamVjdChlcnIpO1xuICAgICAgfVxuICAgICAgcmVzb2x2ZSgpO1xuICAgIH0pO1xuICB9KTtcblxuICByZXR1cm4gdGhpcy4kX19jb2xsZWN0aW9uO1xufTtcblxuLyoqXG4gKiBNYWtlcyB0aGUgaW5kZXhlcyBpbiBNb25nb0RCIG1hdGNoIHRoZSBpbmRleGVzIGRlZmluZWQgaW4gdGhpcyBtb2RlbCdzXG4gKiBzY2hlbWEuIFRoaXMgZnVuY3Rpb24gd2lsbCBkcm9wIGFueSBpbmRleGVzIHRoYXQgYXJlIG5vdCBkZWZpbmVkIGluXG4gKiB0aGUgbW9kZWwncyBzY2hlbWEgZXhjZXB0IHRoZSBgX2lkYCBpbmRleCwgYW5kIGJ1aWxkIGFueSBpbmRleGVzIHRoYXRcbiAqIGFyZSBpbiB5b3VyIHNjaGVtYSBidXQgbm90IGluIE1vbmdvREIuXG4gKlxuICogU2VlIHRoZSBbaW50cm9kdWN0b3J5IGJsb2cgcG9zdF0oaHR0cHM6Ly90aGVjb2RlYmFyYmFyaWFuLmNvbS93aGF0cy1uZXctaW4tbW9uZ29vc2UtNS0yLXN5bmNpbmRleGVzKVxuICogZm9yIG1vcmUgaW5mb3JtYXRpb24uXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBjb25zdCBzY2hlbWEgPSBuZXcgU2NoZW1hKHsgbmFtZTogeyB0eXBlOiBTdHJpbmcsIHVuaXF1ZTogdHJ1ZSB9IH0pO1xuICogICAgIGNvbnN0IEN1c3RvbWVyID0gbW9uZ29vc2UubW9kZWwoJ0N1c3RvbWVyJywgc2NoZW1hKTtcbiAqICAgICBhd2FpdCBDdXN0b21lci5jb2xsZWN0aW9uLmNyZWF0ZUluZGV4KHsgYWdlOiAxIH0pOyAvLyBJbmRleCBpcyBub3QgaW4gc2NoZW1hXG4gKiAgICAgLy8gV2lsbCBkcm9wIHRoZSAnYWdlJyBpbmRleCBhbmQgY3JlYXRlIGFuIGluZGV4IG9uIGBuYW1lYFxuICogICAgIGF3YWl0IEN1c3RvbWVyLnN5bmNJbmRleGVzKCk7XG4gKlxuICogWW91IHNob3VsZCBiZSBjYXJlZnVsIGFib3V0IHJ1bm5pbmcgYHN5bmNJbmRleGVzKClgIG9uIHByb2R1Y3Rpb24gYXBwbGljYXRpb25zIHVuZGVyIGhlYXZ5IGxvYWQsXG4gKiBiZWNhdXNlIGluZGV4IGJ1aWxkcyBhcmUgZXhwZW5zaXZlIG9wZXJhdGlvbnMsIGFuZCB1bmV4cGVjdGVkIGluZGV4IGRyb3BzIGNhbiBsZWFkIHRvIGRlZ3JhZGVkXG4gKiBwZXJmb3JtYW5jZS4gQmVmb3JlIHJ1bm5pbmcgYHN5bmNJbmRleGVzKClgLCB5b3UgY2FuIHVzZSB0aGUgW2BkaWZmSW5kZXhlcygpYCBmdW5jdGlvbl0oI01vZGVsLmRpZmZJbmRleGVzKCkpXG4gKiB0byBjaGVjayB3aGF0IGluZGV4ZXMgYHN5bmNJbmRleGVzKClgIHdpbGwgZHJvcCBhbmQgY3JlYXRlLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgY29uc3QgeyB0b0Ryb3AsIHRvQ3JlYXRlIH0gPSBhd2FpdCBNb2RlbC5kaWZmSW5kZXhlcygpO1xuICogICAgIHRvRHJvcDsgLy8gQXJyYXkgb2Ygc3RyaW5ncyBjb250YWluaW5nIG5hbWVzIG9mIGluZGV4ZXMgdGhhdCBgc3luY0luZGV4ZXMoKWAgd2lsbCBkcm9wXG4gKiAgICAgdG9DcmVhdGU7IC8vIEFycmF5IG9mIHN0cmluZ3MgY29udGFpbmluZyBuYW1lcyBvZiBpbmRleGVzIHRoYXQgYHN5bmNJbmRleGVzKClgIHdpbGwgY3JlYXRlXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBvcHRpb25zIHRvIHBhc3MgdG8gYGVuc3VyZUluZGV4ZXMoKWBcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuYmFja2dyb3VuZD1udWxsXSBpZiBzcGVjaWZpZWQsIG92ZXJyaWRlcyBlYWNoIGluZGV4J3MgYGJhY2tncm91bmRgIHByb3BlcnR5XG4gKiBAcmV0dXJuIHtQcm9taXNlfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Nb2RlbC5zeW5jSW5kZXhlcyA9IGFzeW5jIGZ1bmN0aW9uIHN5bmNJbmRleGVzKG9wdGlvbnMpIHtcbiAgX2NoZWNrQ29udGV4dCh0aGlzLCAnc3luY0luZGV4ZXMnKTtcbiAgaWYgKHR5cGVvZiBhcmd1bWVudHNbMF0gPT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIGFyZ3VtZW50c1sxXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBNb25nb29zZUVycm9yKCdNb2RlbC5zeW5jSW5kZXhlcygpIG5vIGxvbmdlciBhY2NlcHRzIGEgY2FsbGJhY2snKTtcbiAgfVxuXG4gIGNvbnN0IG1vZGVsID0gdGhpcztcblxuICB0cnkge1xuICAgIGF3YWl0IG1vZGVsLmNyZWF0ZUNvbGxlY3Rpb24oKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgaWYgKGVyciAhPSBudWxsICYmIChlcnIubmFtZSAhPT0gJ01vbmdvU2VydmVyRXJyb3InIHx8IGVyci5jb2RlICE9PSA0OCkpIHtcbiAgICAgIHRocm93IGVycjtcbiAgICB9XG4gIH1cblxuICBjb25zdCBkaWZmSW5kZXhlc1Jlc3VsdCA9IGF3YWl0IG1vZGVsLmRpZmZJbmRleGVzKCk7XG4gIGNvbnN0IGRyb3BwZWQgPSBhd2FpdCBtb2RlbC5jbGVhbkluZGV4ZXMoeyAuLi5vcHRpb25zLCB0b0Ryb3A6IGRpZmZJbmRleGVzUmVzdWx0LnRvRHJvcCB9KTtcbiAgYXdhaXQgbW9kZWwuY3JlYXRlSW5kZXhlcyh7IC4uLm9wdGlvbnMsIHRvQ3JlYXRlOiBkaWZmSW5kZXhlc1Jlc3VsdC50b0NyZWF0ZSB9KTtcblxuICByZXR1cm4gZHJvcHBlZDtcbn07XG5cbi8qKlxuICogQ3JlYXRlIGFuIFtBdGxhcyBzZWFyY2ggaW5kZXhdKGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvYXRsYXMvYXRsYXMtc2VhcmNoL2NyZWF0ZS1pbmRleC8pLlxuICogVGhpcyBmdW5jdGlvbiBvbmx5IHdvcmtzIHdoZW4gY29ubmVjdGVkIHRvIE1vbmdvREIgQXRsYXMuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBjb25zdCBzY2hlbWEgPSBuZXcgU2NoZW1hKHsgbmFtZTogeyB0eXBlOiBTdHJpbmcsIHVuaXF1ZTogdHJ1ZSB9IH0pO1xuICogICAgIGNvbnN0IEN1c3RvbWVyID0gbW9uZ29vc2UubW9kZWwoJ0N1c3RvbWVyJywgc2NoZW1hKTtcbiAqICAgICBhd2FpdCBDdXN0b21lci5jcmVhdGVTZWFyY2hJbmRleCh7IG5hbWU6ICd0ZXN0JywgZGVmaW5pdGlvbjogeyBtYXBwaW5nczogeyBkeW5hbWljOiB0cnVlIH0gfSB9KTtcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gZGVzY3JpcHRpb24gaW5kZXggb3B0aW9ucywgaW5jbHVkaW5nIGBuYW1lYCBhbmQgYGRlZmluaXRpb25gXG4gKiBAcGFyYW0ge1N0cmluZ30gZGVzY3JpcHRpb24ubmFtZVxuICogQHBhcmFtIHtPYmplY3R9IGRlc2NyaXB0aW9uLmRlZmluaXRpb25cbiAqIEByZXR1cm4ge1Byb21pc2V9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk1vZGVsLmNyZWF0ZVNlYXJjaEluZGV4ID0gYXN5bmMgZnVuY3Rpb24gY3JlYXRlU2VhcmNoSW5kZXgoZGVzY3JpcHRpb24pIHtcbiAgX2NoZWNrQ29udGV4dCh0aGlzLCAnY3JlYXRlU2VhcmNoSW5kZXgnKTtcblxuICByZXR1cm4gYXdhaXQgdGhpcy4kX19jb2xsZWN0aW9uLmNyZWF0ZVNlYXJjaEluZGV4KGRlc2NyaXB0aW9uKTtcbn07XG5cbi8qKlxuICogVXBkYXRlIGFuIGV4aXN0aW5nIFtBdGxhcyBzZWFyY2ggaW5kZXhdKGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvYXRsYXMvYXRsYXMtc2VhcmNoL2NyZWF0ZS1pbmRleC8pLlxuICogVGhpcyBmdW5jdGlvbiBvbmx5IHdvcmtzIHdoZW4gY29ubmVjdGVkIHRvIE1vbmdvREIgQXRsYXMuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBjb25zdCBzY2hlbWEgPSBuZXcgU2NoZW1hKHsgbmFtZTogeyB0eXBlOiBTdHJpbmcsIHVuaXF1ZTogdHJ1ZSB9IH0pO1xuICogICAgIGNvbnN0IEN1c3RvbWVyID0gbW9uZ29vc2UubW9kZWwoJ0N1c3RvbWVyJywgc2NoZW1hKTtcbiAqICAgICBhd2FpdCBDdXN0b21lci51cGRhdGVTZWFyY2hJbmRleCgndGVzdCcsIHsgbWFwcGluZ3M6IHsgZHluYW1pYzogdHJ1ZSB9IH0pO1xuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gKiBAcGFyYW0ge09iamVjdH0gZGVmaW5pdGlvblxuICogQHJldHVybiB7UHJvbWlzZX1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuTW9kZWwudXBkYXRlU2VhcmNoSW5kZXggPSBhc3luYyBmdW5jdGlvbiB1cGRhdGVTZWFyY2hJbmRleChuYW1lLCBkZWZpbml0aW9uKSB7XG4gIF9jaGVja0NvbnRleHQodGhpcywgJ3VwZGF0ZVNlYXJjaEluZGV4Jyk7XG5cbiAgcmV0dXJuIGF3YWl0IHRoaXMuJF9fY29sbGVjdGlvbi51cGRhdGVTZWFyY2hJbmRleChuYW1lLCBkZWZpbml0aW9uKTtcbn07XG5cbi8qKlxuICogRGVsZXRlIGFuIGV4aXN0aW5nIFtBdGxhcyBzZWFyY2ggaW5kZXhdKGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvYXRsYXMvYXRsYXMtc2VhcmNoL2NyZWF0ZS1pbmRleC8pIGJ5IG5hbWUuXG4gKiBUaGlzIGZ1bmN0aW9uIG9ubHkgd29ya3Mgd2hlbiBjb25uZWN0ZWQgdG8gTW9uZ29EQiBBdGxhcy5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IHNjaGVtYSA9IG5ldyBTY2hlbWEoeyBuYW1lOiB7IHR5cGU6IFN0cmluZywgdW5pcXVlOiB0cnVlIH0gfSk7XG4gKiAgICAgY29uc3QgQ3VzdG9tZXIgPSBtb25nb29zZS5tb2RlbCgnQ3VzdG9tZXInLCBzY2hlbWEpO1xuICogICAgIGF3YWl0IEN1c3RvbWVyLmRyb3BTZWFyY2hJbmRleCgndGVzdCcpO1xuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gKiBAcmV0dXJuIHtQcm9taXNlfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Nb2RlbC5kcm9wU2VhcmNoSW5kZXggPSBhc3luYyBmdW5jdGlvbiBkcm9wU2VhcmNoSW5kZXgobmFtZSkge1xuICBfY2hlY2tDb250ZXh0KHRoaXMsICdkcm9wU2VhcmNoSW5kZXgnKTtcblxuICByZXR1cm4gYXdhaXQgdGhpcy4kX19jb2xsZWN0aW9uLmRyb3BTZWFyY2hJbmRleChuYW1lKTtcbn07XG5cbi8qKlxuICogRG9lcyBhIGRyeS1ydW4gb2YgYE1vZGVsLnN5bmNJbmRleGVzKClgLCByZXR1cm5pbmcgdGhlIGluZGV4ZXMgdGhhdCBgc3luY0luZGV4ZXMoKWAgd291bGQgZHJvcCBhbmQgY3JlYXRlIGlmIHlvdSB3ZXJlIHRvIHJ1biBgc3luY0luZGV4ZXMoKWAuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBjb25zdCB7IHRvRHJvcCwgdG9DcmVhdGUgfSA9IGF3YWl0IE1vZGVsLmRpZmZJbmRleGVzKCk7XG4gKiAgICAgdG9Ecm9wOyAvLyBBcnJheSBvZiBzdHJpbmdzIGNvbnRhaW5pbmcgbmFtZXMgb2YgaW5kZXhlcyB0aGF0IGBzeW5jSW5kZXhlcygpYCB3aWxsIGRyb3BcbiAqICAgICB0b0NyZWF0ZTsgLy8gQXJyYXkgb2Ygc3RyaW5ncyBjb250YWluaW5nIG5hbWVzIG9mIGluZGV4ZXMgdGhhdCBgc3luY0luZGV4ZXMoKWAgd2lsbCBjcmVhdGVcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiBAcmV0dXJuIHtQcm9taXNlPE9iamVjdD59IGNvbnRhaW5zIHRoZSBpbmRleGVzIHRoYXQgd291bGQgYmUgZHJvcHBlZCBpbiBNb25nb0RCIGFuZCBpbmRleGVzIHRoYXQgd291bGQgYmUgY3JlYXRlZCBpbiBNb25nb0RCIGFzIGB7IHRvRHJvcDogc3RyaW5nW10sIHRvQ3JlYXRlOiBzdHJpbmdbXSB9YC5cbiAqL1xuXG5Nb2RlbC5kaWZmSW5kZXhlcyA9IGFzeW5jIGZ1bmN0aW9uIGRpZmZJbmRleGVzKCkge1xuICBpZiAodHlwZW9mIGFyZ3VtZW50c1swXSA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgYXJndW1lbnRzWzFdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IE1vbmdvb3NlRXJyb3IoJ01vZGVsLnN5bmNJbmRleGVzKCkgbm8gbG9uZ2VyIGFjY2VwdHMgYSBjYWxsYmFjaycpO1xuICB9XG5cbiAgY29uc3QgbW9kZWwgPSB0aGlzO1xuXG4gIGxldCBkYkluZGV4ZXMgPSBhd2FpdCBtb2RlbC5saXN0SW5kZXhlcygpLmNhdGNoKGVyciA9PiB7XG4gICAgaWYgKGVyci5jb2RlTmFtZSA9PSAnTmFtZXNwYWNlTm90Rm91bmQnKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICB0aHJvdyBlcnI7XG4gIH0pO1xuICBpZiAoZGJJbmRleGVzID09PSB1bmRlZmluZWQpIHtcbiAgICBkYkluZGV4ZXMgPSBbXTtcbiAgfVxuICBkYkluZGV4ZXMgPSBnZXRSZWxhdGVkREJJbmRleGVzKG1vZGVsLCBkYkluZGV4ZXMpO1xuXG4gIGNvbnN0IHNjaGVtYSA9IG1vZGVsLnNjaGVtYTtcbiAgY29uc3Qgc2NoZW1hSW5kZXhlcyA9IGdldFJlbGF0ZWRTY2hlbWFJbmRleGVzKG1vZGVsLCBzY2hlbWEuaW5kZXhlcygpKTtcblxuICBjb25zdCB0b0Ryb3AgPSBnZXRJbmRleGVzVG9Ecm9wKHNjaGVtYSwgc2NoZW1hSW5kZXhlcywgZGJJbmRleGVzKTtcbiAgY29uc3QgdG9DcmVhdGUgPSBnZXRJbmRleGVzVG9DcmVhdGUoc2NoZW1hLCBzY2hlbWFJbmRleGVzLCBkYkluZGV4ZXMsIHRvRHJvcCk7XG5cbiAgcmV0dXJuIHsgdG9Ecm9wLCB0b0NyZWF0ZSB9O1xufTtcblxuZnVuY3Rpb24gZ2V0SW5kZXhlc1RvQ3JlYXRlKHNjaGVtYSwgc2NoZW1hSW5kZXhlcywgZGJJbmRleGVzLCB0b0Ryb3ApIHtcbiAgY29uc3QgdG9DcmVhdGUgPSBbXTtcblxuICBmb3IgKGNvbnN0IFtzY2hlbWFJbmRleEtleXNPYmplY3QsIHNjaGVtYUluZGV4T3B0aW9uc10gb2Ygc2NoZW1hSW5kZXhlcykge1xuICAgIGxldCBmb3VuZCA9IGZhbHNlO1xuXG4gICAgY29uc3Qgb3B0aW9ucyA9IGRlY29yYXRlRGlzY3JpbWluYXRvckluZGV4T3B0aW9ucyhzY2hlbWEsIGNsb25lKHNjaGVtYUluZGV4T3B0aW9ucykpO1xuXG4gICAgZm9yIChjb25zdCBpbmRleCBvZiBkYkluZGV4ZXMpIHtcbiAgICAgIGlmIChpc0RlZmF1bHRJZEluZGV4KGluZGV4KSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmIChcbiAgICAgICAgaXNJbmRleEVxdWFsKHNjaGVtYUluZGV4S2V5c09iamVjdCwgb3B0aW9ucywgaW5kZXgpICYmXG4gICAgICAgICF0b0Ryb3AuaW5jbHVkZXMoaW5kZXgubmFtZSlcbiAgICAgICkge1xuICAgICAgICBmb3VuZCA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghZm91bmQpIHtcbiAgICAgIHRvQ3JlYXRlLnB1c2goc2NoZW1hSW5kZXhLZXlzT2JqZWN0KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdG9DcmVhdGU7XG59XG5cbmZ1bmN0aW9uIGdldEluZGV4ZXNUb0Ryb3Aoc2NoZW1hLCBzY2hlbWFJbmRleGVzLCBkYkluZGV4ZXMpIHtcbiAgY29uc3QgdG9Ecm9wID0gW107XG5cbiAgZm9yIChjb25zdCBkYkluZGV4IG9mIGRiSW5kZXhlcykge1xuICAgIGxldCBmb3VuZCA9IGZhbHNlO1xuICAgIC8vIE5ldmVyIHRyeSB0byBkcm9wIGBfaWRgIGluZGV4LCBNb25nb0RCIHNlcnZlciBkb2Vzbid0IGFsbG93IGl0XG4gICAgaWYgKGlzRGVmYXVsdElkSW5kZXgoZGJJbmRleCkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGZvciAoY29uc3QgW3NjaGVtYUluZGV4S2V5c09iamVjdCwgc2NoZW1hSW5kZXhPcHRpb25zXSBvZiBzY2hlbWFJbmRleGVzKSB7XG4gICAgICBjb25zdCBvcHRpb25zID0gZGVjb3JhdGVEaXNjcmltaW5hdG9ySW5kZXhPcHRpb25zKHNjaGVtYSwgY2xvbmUoc2NoZW1hSW5kZXhPcHRpb25zKSk7XG4gICAgICBhcHBseVNjaGVtYUNvbGxhdGlvbihzY2hlbWFJbmRleEtleXNPYmplY3QsIG9wdGlvbnMsIHNjaGVtYS5vcHRpb25zKTtcblxuICAgICAgaWYgKGlzSW5kZXhFcXVhbChzY2hlbWFJbmRleEtleXNPYmplY3QsIG9wdGlvbnMsIGRiSW5kZXgpKSB7XG4gICAgICAgIGZvdW5kID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFmb3VuZCkge1xuICAgICAgdG9Ecm9wLnB1c2goZGJJbmRleC5uYW1lKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdG9Ecm9wO1xufVxuLyoqXG4gKiBEZWxldGVzIGFsbCBpbmRleGVzIHRoYXQgYXJlbid0IGRlZmluZWQgaW4gdGhpcyBtb2RlbCdzIHNjaGVtYS4gVXNlZCBieVxuICogYHN5bmNJbmRleGVzKClgLlxuICpcbiAqIFRoZSByZXR1cm5lZCBwcm9taXNlIHJlc29sdmVzIHRvIGEgbGlzdCBvZiB0aGUgZHJvcHBlZCBpbmRleGVzJyBuYW1lcyBhcyBhbiBhcnJheVxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gb3B0aW9uYWwgY2FsbGJhY2tcbiAqIEByZXR1cm4ge1Byb21pc2V8dW5kZWZpbmVkfSBSZXR1cm5zIGB1bmRlZmluZWRgIGlmIGNhbGxiYWNrIGlzIHNwZWNpZmllZCwgcmV0dXJucyBhIHByb21pc2UgaWYgbm8gY2FsbGJhY2suXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk1vZGVsLmNsZWFuSW5kZXhlcyA9IGFzeW5jIGZ1bmN0aW9uIGNsZWFuSW5kZXhlcyhvcHRpb25zKSB7XG4gIF9jaGVja0NvbnRleHQodGhpcywgJ2NsZWFuSW5kZXhlcycpO1xuICBpZiAodHlwZW9mIGFyZ3VtZW50c1swXSA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgYXJndW1lbnRzWzFdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IE1vbmdvb3NlRXJyb3IoJ01vZGVsLmNsZWFuSW5kZXhlcygpIG5vIGxvbmdlciBhY2NlcHRzIGEgY2FsbGJhY2snKTtcbiAgfVxuICBjb25zdCBtb2RlbCA9IHRoaXM7XG5cbiAgY29uc3QgY29sbGVjdGlvbiA9IG1vZGVsLiRfX2NvbGxlY3Rpb247XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkob3B0aW9ucyAmJiBvcHRpb25zLnRvRHJvcCkpIHtcbiAgICBjb25zdCByZXMgPSBhd2FpdCBfZHJvcEluZGV4ZXMob3B0aW9ucy50b0Ryb3AsIGNvbGxlY3Rpb24pO1xuICAgIHJldHVybiByZXM7XG4gIH1cblxuICBjb25zdCByZXMgPSBhd2FpdCBtb2RlbC5kaWZmSW5kZXhlcygpO1xuICByZXR1cm4gYXdhaXQgX2Ryb3BJbmRleGVzKHJlcy50b0Ryb3AsIGNvbGxlY3Rpb24pO1xufTtcblxuYXN5bmMgZnVuY3Rpb24gX2Ryb3BJbmRleGVzKHRvRHJvcCwgY29sbGVjdGlvbikge1xuICBpZiAodG9Ecm9wLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuXG4gIGF3YWl0IFByb21pc2UuYWxsKHRvRHJvcC5tYXAoaW5kZXhOYW1lID0+IGNvbGxlY3Rpb24uZHJvcEluZGV4KGluZGV4TmFtZSkpKTtcbiAgcmV0dXJuIHRvRHJvcDtcbn1cblxuLyoqXG4gKiBMaXN0cyB0aGUgaW5kZXhlcyBjdXJyZW50bHkgZGVmaW5lZCBpbiBNb25nb0RCLiBUaGlzIG1heSBvciBtYXkgbm90IGJlXG4gKiB0aGUgc2FtZSBhcyB0aGUgaW5kZXhlcyBkZWZpbmVkIGluIHlvdXIgc2NoZW1hIGRlcGVuZGluZyBvbiB3aGV0aGVyIHlvdVxuICogdXNlIHRoZSBbYGF1dG9JbmRleGAgb3B0aW9uXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvZ3VpZGUuaHRtbCNhdXRvSW5kZXgpIGFuZCBpZiB5b3VcbiAqIGJ1aWxkIGluZGV4ZXMgbWFudWFsbHkuXG4gKlxuICogQHJldHVybiB7UHJvbWlzZX1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuTW9kZWwubGlzdEluZGV4ZXMgPSBhc3luYyBmdW5jdGlvbiBsaXN0SW5kZXhlcygpIHtcbiAgX2NoZWNrQ29udGV4dCh0aGlzLCAnbGlzdEluZGV4ZXMnKTtcbiAgaWYgKHR5cGVvZiBhcmd1bWVudHNbMF0gPT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgTW9uZ29vc2VFcnJvcignTW9kZWwubGlzdEluZGV4ZXMoKSBubyBsb25nZXIgYWNjZXB0cyBhIGNhbGxiYWNrJyk7XG4gIH1cblxuICBpZiAodGhpcy4kX19jb2xsZWN0aW9uLmJ1ZmZlcikge1xuICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgdGhpcy4kX19jb2xsZWN0aW9uLmFkZFF1ZXVlKHJlc29sdmUpO1xuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIHRoaXMuJF9fY29sbGVjdGlvbi5saXN0SW5kZXhlcygpLnRvQXJyYXkoKTtcbn07XG5cbi8qKlxuICogU2VuZHMgYGNyZWF0ZUluZGV4YCBjb21tYW5kcyB0byBtb25nbyBmb3IgZWFjaCBpbmRleCBkZWNsYXJlZCBpbiB0aGUgc2NoZW1hLlxuICogVGhlIGBjcmVhdGVJbmRleGAgY29tbWFuZHMgYXJlIHNlbnQgaW4gc2VyaWVzLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgYXdhaXQgRXZlbnQuZW5zdXJlSW5kZXhlcygpO1xuICpcbiAqIEFmdGVyIGNvbXBsZXRpb24sIGFuIGBpbmRleGAgZXZlbnQgaXMgZW1pdHRlZCBvbiB0aGlzIGBNb2RlbGAgcGFzc2luZyBhbiBlcnJvciBpZiBvbmUgb2NjdXJyZWQuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBjb25zdCBldmVudFNjaGVtYSA9IG5ldyBTY2hlbWEoeyB0aGluZzogeyB0eXBlOiAnc3RyaW5nJywgdW5pcXVlOiB0cnVlIH0gfSlcbiAqICAgICBjb25zdCBFdmVudCA9IG1vbmdvb3NlLm1vZGVsKCdFdmVudCcsIGV2ZW50U2NoZW1hKTtcbiAqXG4gKiAgICAgRXZlbnQub24oJ2luZGV4JywgZnVuY3Rpb24gKGVycikge1xuICogICAgICAgaWYgKGVycikgY29uc29sZS5lcnJvcihlcnIpOyAvLyBlcnJvciBvY2N1cnJlZCBkdXJpbmcgaW5kZXggY3JlYXRpb25cbiAqICAgICB9KTtcbiAqXG4gKiBfTk9URTogSXQgaXMgbm90IHJlY29tbWVuZGVkIHRoYXQgeW91IHJ1biB0aGlzIGluIHByb2R1Y3Rpb24uIEluZGV4IGNyZWF0aW9uIG1heSBpbXBhY3QgZGF0YWJhc2UgcGVyZm9ybWFuY2UgZGVwZW5kaW5nIG9uIHlvdXIgbG9hZC4gVXNlIHdpdGggY2F1dGlvbi5fXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBpbnRlcm5hbCBvcHRpb25zXG4gKiBAcmV0dXJuIHtQcm9taXNlfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Nb2RlbC5lbnN1cmVJbmRleGVzID0gYXN5bmMgZnVuY3Rpb24gZW5zdXJlSW5kZXhlcyhvcHRpb25zKSB7XG4gIF9jaGVja0NvbnRleHQodGhpcywgJ2Vuc3VyZUluZGV4ZXMnKTtcbiAgaWYgKHR5cGVvZiBhcmd1bWVudHNbMF0gPT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIGFyZ3VtZW50c1sxXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBNb25nb29zZUVycm9yKCdNb2RlbC5lbnN1cmVJbmRleGVzKCkgbm8gbG9uZ2VyIGFjY2VwdHMgYSBjYWxsYmFjaycpO1xuICB9XG5cbiAgYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIF9lbnN1cmVJbmRleGVzKHRoaXMsIG9wdGlvbnMsIChlcnIpID0+IHtcbiAgICAgIGlmIChlcnIgIT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gcmVqZWN0KGVycik7XG4gICAgICB9XG4gICAgICByZXNvbHZlKCk7XG4gICAgfSk7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBTaW1pbGFyIHRvIGBlbnN1cmVJbmRleGVzKClgLCBleGNlcHQgZm9yIGl0IHVzZXMgdGhlIFtgY3JlYXRlSW5kZXhgXShodHRwczovL21vbmdvZGIuZ2l0aHViLmlvL25vZGUtbW9uZ29kYi1uYXRpdmUvNC45L2NsYXNzZXMvRGIuaHRtbCNjcmVhdGVJbmRleClcbiAqIGZ1bmN0aW9uLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gaW50ZXJuYWwgb3B0aW9uc1xuICogQHJldHVybiB7UHJvbWlzZX1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuTW9kZWwuY3JlYXRlSW5kZXhlcyA9IGFzeW5jIGZ1bmN0aW9uIGNyZWF0ZUluZGV4ZXMob3B0aW9ucykge1xuICBfY2hlY2tDb250ZXh0KHRoaXMsICdjcmVhdGVJbmRleGVzJyk7XG5cbiAgaWYgKHR5cGVvZiBhcmd1bWVudHNbMF0gPT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIGFyZ3VtZW50c1sxXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBNb25nb29zZUVycm9yKCdNb2RlbC5jcmVhdGVJbmRleGVzKCkgbm8gbG9uZ2VyIGFjY2VwdHMgYSBjYWxsYmFjaycpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXMuZW5zdXJlSW5kZXhlcyhvcHRpb25zKTtcbn07XG5cblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5mdW5jdGlvbiBfZW5zdXJlSW5kZXhlcyhtb2RlbCwgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgY29uc3QgaW5kZXhlcyA9IG1vZGVsLnNjaGVtYS5pbmRleGVzKCk7XG4gIGxldCBpbmRleEVycm9yO1xuXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBjb25zdCBkb25lID0gZnVuY3Rpb24oZXJyKSB7XG4gICAgaWYgKGVyciAmJiAhbW9kZWwuJGNhdWdodCkge1xuICAgICAgbW9kZWwuZW1pdCgnZXJyb3InLCBlcnIpO1xuICAgIH1cbiAgICBtb2RlbC5lbWl0KCdpbmRleCcsIGVyciB8fCBpbmRleEVycm9yKTtcbiAgICBjYWxsYmFjayAmJiBjYWxsYmFjayhlcnIgfHwgaW5kZXhFcnJvcik7XG4gIH07XG5cbiAgZm9yIChjb25zdCBpbmRleCBvZiBpbmRleGVzKSB7XG4gICAgaWYgKGlzRGVmYXVsdElkSW5kZXgoaW5kZXgpKSB7XG4gICAgICB1dGlscy53YXJuKCdtb25nb29zZTogQ2Fubm90IHNwZWNpZnkgYSBjdXN0b20gaW5kZXggb24gYF9pZGAgZm9yICcgK1xuICAgICAgICAnbW9kZWwgbmFtZSBcIicgKyBtb2RlbC5tb2RlbE5hbWUgKyAnXCIsICcgK1xuICAgICAgICAnTW9uZ29EQiBkb2VzIG5vdCBhbGxvdyBvdmVyd3JpdGluZyB0aGUgZGVmYXVsdCBgX2lkYCBpbmRleC4gU2VlICcgK1xuICAgICAgICAnaHR0cHM6Ly9iaXQubHkvbW9uZ29kYi1pZC1pbmRleCcpO1xuICAgIH1cbiAgfVxuXG4gIGlmICghaW5kZXhlcy5sZW5ndGgpIHtcbiAgICBpbW1lZGlhdGUoZnVuY3Rpb24oKSB7XG4gICAgICBkb25lKCk7XG4gICAgfSk7XG4gICAgcmV0dXJuO1xuICB9XG4gIC8vIEluZGV4ZXMgYXJlIGNyZWF0ZWQgb25lLWJ5LW9uZSB0byBzdXBwb3J0IGhvdyBNb25nb0RCIDwgMi40IGRlYWxzXG4gIC8vIHdpdGggYmFja2dyb3VuZCBpbmRleGVzLlxuXG4gIGNvbnN0IGluZGV4U2luZ2xlRG9uZSA9IGZ1bmN0aW9uKGVyciwgZmllbGRzLCBvcHRpb25zLCBuYW1lKSB7XG4gICAgbW9kZWwuZW1pdCgnaW5kZXgtc2luZ2xlLWRvbmUnLCBlcnIsIGZpZWxkcywgb3B0aW9ucywgbmFtZSk7XG4gIH07XG4gIGNvbnN0IGluZGV4U2luZ2xlU3RhcnQgPSBmdW5jdGlvbihmaWVsZHMsIG9wdGlvbnMpIHtcbiAgICBtb2RlbC5lbWl0KCdpbmRleC1zaW5nbGUtc3RhcnQnLCBmaWVsZHMsIG9wdGlvbnMpO1xuICB9O1xuXG4gIGNvbnN0IGJhc2VTY2hlbWEgPSBtb2RlbC5zY2hlbWEuX2Jhc2VTY2hlbWE7XG4gIGNvbnN0IGJhc2VTY2hlbWFJbmRleGVzID0gYmFzZVNjaGVtYSA/IGJhc2VTY2hlbWEuaW5kZXhlcygpIDogW107XG5cbiAgaW1tZWRpYXRlKGZ1bmN0aW9uKCkge1xuICAgIC8vIElmIGJ1ZmZlcmluZyBpcyBvZmYsIGRvIHRoaXMgbWFudWFsbHkuXG4gICAgaWYgKG9wdGlvbnMuX2F1dG9tYXRpYyAmJiAhbW9kZWwuY29sbGVjdGlvbi5jb2xsZWN0aW9uKSB7XG4gICAgICBtb2RlbC5jb2xsZWN0aW9uLmFkZFF1ZXVlKGNyZWF0ZSwgW10pO1xuICAgIH0gZWxzZSB7XG4gICAgICBjcmVhdGUoKTtcbiAgICB9XG4gIH0pO1xuXG5cbiAgZnVuY3Rpb24gY3JlYXRlKCkge1xuICAgIGlmIChvcHRpb25zLl9hdXRvbWF0aWMpIHtcbiAgICAgIGlmIChtb2RlbC5zY2hlbWEub3B0aW9ucy5hdXRvSW5kZXggPT09IGZhbHNlIHx8XG4gICAgICAgICAgKG1vZGVsLnNjaGVtYS5vcHRpb25zLmF1dG9JbmRleCA9PSBudWxsICYmIG1vZGVsLmRiLmNvbmZpZy5hdXRvSW5kZXggPT09IGZhbHNlKSkge1xuICAgICAgICByZXR1cm4gZG9uZSgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IGluZGV4ID0gaW5kZXhlcy5zaGlmdCgpO1xuICAgIGlmICghaW5kZXgpIHtcbiAgICAgIHJldHVybiBkb25lKCk7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLl9hdXRvbWF0aWMgJiYgaW5kZXhbMV0uX2F1dG9JbmRleCA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybiBjcmVhdGUoKTtcbiAgICB9XG5cbiAgICBpZiAoYmFzZVNjaGVtYUluZGV4ZXMuZmluZChpID0+IHV0aWxzLmRlZXBFcXVhbChpLCBpbmRleCkpKSB7XG4gICAgICByZXR1cm4gY3JlYXRlKCk7XG4gICAgfVxuXG4gICAgY29uc3QgaW5kZXhGaWVsZHMgPSBjbG9uZShpbmRleFswXSk7XG4gICAgY29uc3QgaW5kZXhPcHRpb25zID0gY2xvbmUoaW5kZXhbMV0pO1xuXG4gICAgZGVsZXRlIGluZGV4T3B0aW9ucy5fYXV0b0luZGV4O1xuICAgIGRlY29yYXRlRGlzY3JpbWluYXRvckluZGV4T3B0aW9ucyhtb2RlbC5zY2hlbWEsIGluZGV4T3B0aW9ucyk7XG4gICAgYXBwbHlXcml0ZUNvbmNlcm4obW9kZWwuc2NoZW1hLCBpbmRleE9wdGlvbnMpO1xuICAgIGFwcGx5U2NoZW1hQ29sbGF0aW9uKGluZGV4RmllbGRzLCBpbmRleE9wdGlvbnMsIG1vZGVsLnNjaGVtYS5vcHRpb25zKTtcblxuICAgIGluZGV4U2luZ2xlU3RhcnQoaW5kZXhGaWVsZHMsIG9wdGlvbnMpO1xuXG4gICAgaWYgKCdiYWNrZ3JvdW5kJyBpbiBvcHRpb25zKSB7XG4gICAgICBpbmRleE9wdGlvbnMuYmFja2dyb3VuZCA9IG9wdGlvbnMuYmFja2dyb3VuZDtcbiAgICB9XG5cbiAgICBpZiAoJ3RvQ3JlYXRlJyBpbiBvcHRpb25zKSB7XG4gICAgICBpZiAob3B0aW9ucy50b0NyZWF0ZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIGRvbmUoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBtb2RlbC5jb2xsZWN0aW9uLmNyZWF0ZUluZGV4KGluZGV4RmllbGRzLCBpbmRleE9wdGlvbnMpLnRoZW4oXG4gICAgICBuYW1lID0+IHtcbiAgICAgICAgaW5kZXhTaW5nbGVEb25lKG51bGwsIGluZGV4RmllbGRzLCBpbmRleE9wdGlvbnMsIG5hbWUpO1xuICAgICAgICBjcmVhdGUoKTtcbiAgICAgIH0sXG4gICAgICBlcnIgPT4ge1xuICAgICAgICBpZiAoIWluZGV4RXJyb3IpIHtcbiAgICAgICAgICBpbmRleEVycm9yID0gZXJyO1xuICAgICAgICB9XG4gICAgICAgIGlmICghbW9kZWwuJGNhdWdodCkge1xuICAgICAgICAgIG1vZGVsLmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGluZGV4U2luZ2xlRG9uZShlcnIsIGluZGV4RmllbGRzLCBpbmRleE9wdGlvbnMpO1xuICAgICAgICBjcmVhdGUoKTtcbiAgICAgIH1cbiAgICApO1xuICB9XG59XG5cbi8qKlxuICogU2NoZW1hIHRoZSBtb2RlbCB1c2VzLlxuICpcbiAqIEBwcm9wZXJ0eSBzY2hlbWFcbiAqIEBzdGF0aWNcbiAqIEBhcGkgcHVibGljXG4gKiBAbWVtYmVyT2YgTW9kZWxcbiAqL1xuXG5Nb2RlbC5zY2hlbWE7XG5cbi8qKlxuICogQ29ubmVjdGlvbiBpbnN0YW5jZSB0aGUgbW9kZWwgdXNlcy5cbiAqXG4gKiBAcHJvcGVydHkgZGJcbiAqIEBzdGF0aWNcbiAqIEBhcGkgcHVibGljXG4gKiBAbWVtYmVyT2YgTW9kZWxcbiAqL1xuXG5Nb2RlbC5kYjtcblxuLyoqXG4gKiBDb2xsZWN0aW9uIHRoZSBtb2RlbCB1c2VzLlxuICpcbiAqIEBwcm9wZXJ0eSBjb2xsZWN0aW9uXG4gKiBAYXBpIHB1YmxpY1xuICogQG1lbWJlck9mIE1vZGVsXG4gKi9cblxuTW9kZWwuY29sbGVjdGlvbjtcblxuLyoqXG4gKiBJbnRlcm5hbCBjb2xsZWN0aW9uIHRoZSBtb2RlbCB1c2VzLlxuICpcbiAqIEBwcm9wZXJ0eSBjb2xsZWN0aW9uXG4gKiBAYXBpIHByaXZhdGVcbiAqIEBtZW1iZXJPZiBNb2RlbFxuICovXG5Nb2RlbC4kX19jb2xsZWN0aW9uO1xuXG4vKipcbiAqIEJhc2UgTW9uZ29vc2UgaW5zdGFuY2UgdGhlIG1vZGVsIHVzZXMuXG4gKlxuICogQHByb3BlcnR5IGJhc2VcbiAqIEBhcGkgcHVibGljXG4gKiBAbWVtYmVyT2YgTW9kZWxcbiAqL1xuXG5Nb2RlbC5iYXNlO1xuXG4vKipcbiAqIFJlZ2lzdGVyZWQgZGlzY3JpbWluYXRvcnMgZm9yIHRoaXMgbW9kZWwuXG4gKlxuICogQHByb3BlcnR5IGRpc2NyaW1pbmF0b3JzXG4gKiBAYXBpIHB1YmxpY1xuICogQG1lbWJlck9mIE1vZGVsXG4gKi9cblxuTW9kZWwuZGlzY3JpbWluYXRvcnM7XG5cbi8qKlxuICogVHJhbnNsYXRlIGFueSBhbGlhc2VzIGZpZWxkcy9jb25kaXRpb25zIHNvIHRoZSBmaW5hbCBxdWVyeSBvciBkb2N1bWVudCBvYmplY3QgaXMgcHVyZVxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgYXdhaXQgQ2hhcmFjdGVyLmZpbmQoQ2hhcmFjdGVyLnRyYW5zbGF0ZUFsaWFzZXMoe1xuICogICAgICAgICflkI0nOiAnRWRkYXJkIFN0YXJrJyAvLyBBbGlhcyBmb3IgJ25hbWUnXG4gKiAgICAgfSk7XG4gKlxuICogQnkgZGVmYXVsdCwgYHRyYW5zbGF0ZUFsaWFzZXMoKWAgb3ZlcndyaXRlcyByYXcgZmllbGRzIHdpdGggYWxpYXNlZCBmaWVsZHMuXG4gKiBTbyBpZiBgbmAgaXMgYW4gYWxpYXMgZm9yIGBuYW1lYCwgYHsgbjogJ2FsaWFzJywgbmFtZTogJ3JhdycgfWAgd2lsbCByZXNvbHZlIHRvIGB7IG5hbWU6ICdhbGlhcycgfWAuXG4gKiBIb3dldmVyLCB5b3UgY2FuIHNldCB0aGUgYGVycm9yT25EdXBsaWNhdGVzYCBvcHRpb24gdG8gdGhyb3cgYW4gZXJyb3IgaWYgdGhlcmUgYXJlIHBvdGVudGlhbGx5IGNvbmZsaWN0aW5nIHBhdGhzLlxuICogVGhlIGB0cmFuc2xhdGVBbGlhc2VzYCBvcHRpb24gZm9yIHF1ZXJpZXMgdXNlcyBgZXJyb3JPbkR1cGxpY2F0ZXNgLlxuICpcbiAqICMjIyMgTm90ZTpcbiAqXG4gKiBPbmx5IHRyYW5zbGF0ZSBhcmd1bWVudHMgb2Ygb2JqZWN0IHR5cGUgYW55dGhpbmcgZWxzZSBpcyByZXR1cm5lZCByYXdcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gZmllbGRzIGZpZWxkcy9jb25kaXRpb25zIHRoYXQgbWF5IGNvbnRhaW4gYWxpYXNlZCBrZXlzXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtlcnJvck9uRHVwbGljYXRlc10gaWYgdHJ1ZSwgdGhyb3cgYW4gZXJyb3IgaWYgdGhlcmUncyBib3RoIGEga2V5IGFuZCBhbiBhbGlhcyBmb3IgdGhhdCBrZXkgaW4gYGZpZWxkc2BcbiAqIEByZXR1cm4ge09iamVjdH0gdGhlIHRyYW5zbGF0ZWQgJ3B1cmUnIGZpZWxkcy9jb25kaXRpb25zXG4gKi9cbk1vZGVsLnRyYW5zbGF0ZUFsaWFzZXMgPSBmdW5jdGlvbiB0cmFuc2xhdGVBbGlhc2VzKGZpZWxkcywgZXJyb3JPbkR1cGxpY2F0ZXMpIHtcbiAgX2NoZWNrQ29udGV4dCh0aGlzLCAndHJhbnNsYXRlQWxpYXNlcycpO1xuXG4gIGNvbnN0IHRyYW5zbGF0ZSA9IChrZXksIHZhbHVlKSA9PiB7XG4gICAgbGV0IGFsaWFzO1xuICAgIGNvbnN0IHRyYW5zbGF0ZWQgPSBbXTtcbiAgICBjb25zdCBmaWVsZEtleXMgPSBrZXkuc3BsaXQoJy4nKTtcbiAgICBsZXQgY3VycmVudFNjaGVtYSA9IHRoaXMuc2NoZW1hO1xuICAgIGZvciAoY29uc3QgaSBpbiBmaWVsZEtleXMpIHtcbiAgICAgIGNvbnN0IG5hbWUgPSBmaWVsZEtleXNbaV07XG4gICAgICBpZiAoY3VycmVudFNjaGVtYSAmJiBjdXJyZW50U2NoZW1hLmFsaWFzZXNbbmFtZV0pIHtcbiAgICAgICAgYWxpYXMgPSBjdXJyZW50U2NoZW1hLmFsaWFzZXNbbmFtZV07XG4gICAgICAgIGlmIChlcnJvck9uRHVwbGljYXRlcyAmJiBhbGlhcyBpbiBmaWVsZHMpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgTW9uZ29vc2VFcnJvcihgUHJvdmlkZWQgb2JqZWN0IGhhcyBib3RoIGZpZWxkIFwiJHtuYW1lfVwiIGFuZCBpdHMgYWxpYXMgXCIke2FsaWFzfVwiYCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQWxpYXMgZm91bmQsXG4gICAgICAgIHRyYW5zbGF0ZWQucHVzaChhbGlhcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhbGlhcyA9IG5hbWU7XG4gICAgICAgIC8vIEFsaWFzIG5vdCBmb3VuZCwgc28gdHJlYXQgYXMgdW4tYWxpYXNlZCBrZXlcbiAgICAgICAgdHJhbnNsYXRlZC5wdXNoKG5hbWUpO1xuICAgICAgfVxuXG4gICAgICAvLyBDaGVjayBpZiBhbGlhc2VkIHBhdGggaXMgYSBzY2hlbWFcbiAgICAgIGlmIChjdXJyZW50U2NoZW1hICYmIGN1cnJlbnRTY2hlbWEucGF0aHNbYWxpYXNdKSB7XG4gICAgICAgIGN1cnJlbnRTY2hlbWEgPSBjdXJyZW50U2NoZW1hLnBhdGhzW2FsaWFzXS5zY2hlbWE7XG4gICAgICB9XG4gICAgICBlbHNlXG4gICAgICAgIGN1cnJlbnRTY2hlbWEgPSBudWxsO1xuICAgIH1cblxuICAgIGNvbnN0IHRyYW5zbGF0ZWRLZXkgPSB0cmFuc2xhdGVkLmpvaW4oJy4nKTtcbiAgICBpZiAoZmllbGRzIGluc3RhbmNlb2YgTWFwKVxuICAgICAgZmllbGRzLnNldCh0cmFuc2xhdGVkS2V5LCB2YWx1ZSk7XG4gICAgZWxzZVxuICAgICAgZmllbGRzW3RyYW5zbGF0ZWRLZXldID0gdmFsdWU7XG5cbiAgICBpZiAodHJhbnNsYXRlZEtleSAhPT0ga2V5KSB7XG4gICAgICAvLyBXZSdsbCBiZSB1c2luZyB0aGUgdHJhbnNsYXRlZCBrZXkgaW5zdGVhZFxuICAgICAgaWYgKGZpZWxkcyBpbnN0YW5jZW9mIE1hcCkge1xuICAgICAgICAvLyBEZWxldGUgZnJvbSBtYXBcbiAgICAgICAgZmllbGRzLmRlbGV0ZShrZXkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gRGVsZXRlIGZyb20gb2JqZWN0XG4gICAgICAgIGRlbGV0ZSBmaWVsZHNba2V5XTsgLy8gV2UnbGwgYmUgdXNpbmcgdGhlIHRyYW5zbGF0ZWQga2V5IGluc3RlYWRcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZpZWxkcztcbiAgfTtcblxuICBpZiAodHlwZW9mIGZpZWxkcyA9PT0gJ29iamVjdCcpIHtcbiAgICAvLyBGaWVsZHMgaXMgYW4gb2JqZWN0IChxdWVyeSBjb25kaXRpb25zIG9yIGRvY3VtZW50IGZpZWxkcylcbiAgICBpZiAoZmllbGRzIGluc3RhbmNlb2YgTWFwKSB7XG4gICAgICAvLyBBIE1hcCB3YXMgc3VwcGxpZWRcbiAgICAgIGZvciAoY29uc3QgZmllbGQgb2YgbmV3IE1hcChmaWVsZHMpKSB7XG4gICAgICAgIGZpZWxkcyA9IHRyYW5zbGF0ZShmaWVsZFswXSwgZmllbGRbMV0pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBJbmZlciBhIHJlZ3VsYXIgb2JqZWN0IHdhcyBzdXBwbGllZFxuICAgICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMoZmllbGRzKSkge1xuICAgICAgICBmaWVsZHMgPSB0cmFuc2xhdGUoa2V5LCBmaWVsZHNba2V5XSk7XG4gICAgICAgIGlmIChrZXlbMF0gPT09ICckJykge1xuICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGZpZWxkc1trZXldKSkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBpIGluIGZpZWxkc1trZXldKSB7XG4gICAgICAgICAgICAgIC8vIFJlY3Vyc2l2ZWx5IHRyYW5zbGF0ZSBuZXN0ZWQgcXVlcmllc1xuICAgICAgICAgICAgICBmaWVsZHNba2V5XVtpXSA9IHRoaXMudHJhbnNsYXRlQWxpYXNlcyhmaWVsZHNba2V5XVtpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMudHJhbnNsYXRlQWxpYXNlcyhmaWVsZHNba2V5XSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZpZWxkcztcbiAgfSBlbHNlIHtcbiAgICAvLyBEb24ndCBrbm93IHR5cGVvZiBmaWVsZHNcbiAgICByZXR1cm4gZmllbGRzO1xuICB9XG59O1xuXG4vKipcbiAqIERlbGV0ZXMgdGhlIGZpcnN0IGRvY3VtZW50IHRoYXQgbWF0Y2hlcyBgY29uZGl0aW9uc2AgZnJvbSB0aGUgY29sbGVjdGlvbi5cbiAqIEl0IHJldHVybnMgYW4gb2JqZWN0IHdpdGggdGhlIHByb3BlcnR5IGBkZWxldGVkQ291bnRgIGluZGljYXRpbmcgaG93IG1hbnkgZG9jdW1lbnRzIHdlcmUgZGVsZXRlZC5cbiAqIEJlaGF2ZXMgbGlrZSBgcmVtb3ZlKClgLCBidXQgZGVsZXRlcyBhdCBtb3N0IG9uZSBkb2N1bWVudCByZWdhcmRsZXNzIG9mIHRoZVxuICogYHNpbmdsZWAgb3B0aW9uLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgYXdhaXQgQ2hhcmFjdGVyLmRlbGV0ZU9uZSh7IG5hbWU6ICdFZGRhcmQgU3RhcmsnIH0pOyAvLyByZXR1cm5zIHtkZWxldGVkQ291bnQ6IDF9XG4gKlxuICogIyMjIyBOb3RlOlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gdHJpZ2dlcnMgYGRlbGV0ZU9uZWAgcXVlcnkgaG9va3MuIFJlYWQgdGhlXG4gKiBbbWlkZGxld2FyZSBkb2NzXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvbWlkZGxld2FyZS5odG1sI25hbWluZykgdG8gbGVhcm4gbW9yZS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gY29uZGl0aW9uc1xuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBvcHRpb25hbCBzZWUgW2BRdWVyeS5wcm90b3R5cGUuc2V0T3B0aW9ucygpYF0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2FwaS9xdWVyeS5odG1sI1F1ZXJ5LnByb3RvdHlwZS5zZXRPcHRpb25zKCkpXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnRyYW5zbGF0ZUFsaWFzZXM9bnVsbF0gSWYgc2V0IHRvIGB0cnVlYCwgdHJhbnNsYXRlcyBhbnkgc2NoZW1hLWRlZmluZWQgYWxpYXNlcyBpbiBgZmlsdGVyYCwgYHByb2plY3Rpb25gLCBgdXBkYXRlYCwgYW5kIGBkaXN0aW5jdGAuIFRocm93cyBhbiBlcnJvciBpZiB0aGVyZSBhcmUgYW55IGNvbmZsaWN0cyB3aGVyZSBib3RoIGFsaWFzIGFuZCByYXcgcHJvcGVydHkgYXJlIGRlZmluZWQgb24gdGhlIHNhbWUgb2JqZWN0LlxuICogQHJldHVybiB7UXVlcnl9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk1vZGVsLmRlbGV0ZU9uZSA9IGZ1bmN0aW9uIGRlbGV0ZU9uZShjb25kaXRpb25zLCBvcHRpb25zKSB7XG4gIF9jaGVja0NvbnRleHQodGhpcywgJ2RlbGV0ZU9uZScpO1xuXG4gIGlmICh0eXBlb2YgYXJndW1lbnRzWzBdID09PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBhcmd1bWVudHNbMV0gPT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIGFyZ3VtZW50c1syXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBNb25nb29zZUVycm9yKCdNb2RlbC5wcm90b3R5cGUuZGVsZXRlT25lKCkgbm8gbG9uZ2VyIGFjY2VwdHMgYSBjYWxsYmFjaycpO1xuICB9XG5cbiAgY29uc3QgbXEgPSBuZXcgdGhpcy5RdWVyeSh7fSwge30sIHRoaXMsIHRoaXMuJF9fY29sbGVjdGlvbik7XG4gIG1xLnNldE9wdGlvbnMob3B0aW9ucyk7XG5cbiAgcmV0dXJuIG1xLmRlbGV0ZU9uZShjb25kaXRpb25zKTtcbn07XG5cbi8qKlxuICogRGVsZXRlcyBhbGwgb2YgdGhlIGRvY3VtZW50cyB0aGF0IG1hdGNoIGBjb25kaXRpb25zYCBmcm9tIHRoZSBjb2xsZWN0aW9uLlxuICogSXQgcmV0dXJucyBhbiBvYmplY3Qgd2l0aCB0aGUgcHJvcGVydHkgYGRlbGV0ZWRDb3VudGAgY29udGFpbmluZyB0aGUgbnVtYmVyIG9mIGRvY3VtZW50cyBkZWxldGVkLlxuICogQmVoYXZlcyBsaWtlIGByZW1vdmUoKWAsIGJ1dCBkZWxldGVzIGFsbCBkb2N1bWVudHMgdGhhdCBtYXRjaCBgY29uZGl0aW9uc2BcbiAqIHJlZ2FyZGxlc3Mgb2YgdGhlIGBzaW5nbGVgIG9wdGlvbi5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGF3YWl0IENoYXJhY3Rlci5kZWxldGVNYW55KHsgbmFtZTogL1N0YXJrLywgYWdlOiB7ICRndGU6IDE4IH0gfSk7IC8vIHJldHVybnMge2RlbGV0ZWRDb3VudDogeH0gd2hlcmUgeCBpcyB0aGUgbnVtYmVyIG9mIGRvY3VtZW50cyBkZWxldGVkLlxuICpcbiAqICMjIyMgTm90ZTpcbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIHRyaWdnZXJzIGBkZWxldGVNYW55YCBxdWVyeSBob29rcy4gUmVhZCB0aGVcbiAqIFttaWRkbGV3YXJlIGRvY3NdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9taWRkbGV3YXJlLmh0bWwjbmFtaW5nKSB0byBsZWFybiBtb3JlLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb25kaXRpb25zXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIG9wdGlvbmFsIHNlZSBbYFF1ZXJ5LnByb3RvdHlwZS5zZXRPcHRpb25zKClgXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvYXBpL3F1ZXJ5Lmh0bWwjUXVlcnkucHJvdG90eXBlLnNldE9wdGlvbnMoKSlcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMudHJhbnNsYXRlQWxpYXNlcz1udWxsXSBJZiBzZXQgdG8gYHRydWVgLCB0cmFuc2xhdGVzIGFueSBzY2hlbWEtZGVmaW5lZCBhbGlhc2VzIGluIGBmaWx0ZXJgLCBgcHJvamVjdGlvbmAsIGB1cGRhdGVgLCBhbmQgYGRpc3RpbmN0YC4gVGhyb3dzIGFuIGVycm9yIGlmIHRoZXJlIGFyZSBhbnkgY29uZmxpY3RzIHdoZXJlIGJvdGggYWxpYXMgYW5kIHJhdyBwcm9wZXJ0eSBhcmUgZGVmaW5lZCBvbiB0aGUgc2FtZSBvYmplY3QuXG4gKiBAcmV0dXJuIHtRdWVyeX1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuTW9kZWwuZGVsZXRlTWFueSA9IGZ1bmN0aW9uIGRlbGV0ZU1hbnkoY29uZGl0aW9ucywgb3B0aW9ucykge1xuICBfY2hlY2tDb250ZXh0KHRoaXMsICdkZWxldGVNYW55Jyk7XG5cbiAgaWYgKHR5cGVvZiBhcmd1bWVudHNbMF0gPT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIGFyZ3VtZW50c1sxXSA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgYXJndW1lbnRzWzJdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IE1vbmdvb3NlRXJyb3IoJ01vZGVsLmRlbGV0ZU1hbnkoKSBubyBsb25nZXIgYWNjZXB0cyBhIGNhbGxiYWNrJyk7XG4gIH1cblxuICBjb25zdCBtcSA9IG5ldyB0aGlzLlF1ZXJ5KHt9LCB7fSwgdGhpcywgdGhpcy4kX19jb2xsZWN0aW9uKTtcbiAgbXEuc2V0T3B0aW9ucyhvcHRpb25zKTtcblxuICByZXR1cm4gbXEuZGVsZXRlTWFueShjb25kaXRpb25zKTtcbn07XG5cbi8qKlxuICogRmluZHMgZG9jdW1lbnRzLlxuICpcbiAqIE1vbmdvb3NlIGNhc3RzIHRoZSBgZmlsdGVyYCB0byBtYXRjaCB0aGUgbW9kZWwncyBzY2hlbWEgYmVmb3JlIHRoZSBjb21tYW5kIGlzIHNlbnQuXG4gKiBTZWUgb3VyIFtxdWVyeSBjYXN0aW5nIHR1dG9yaWFsXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvdHV0b3JpYWxzL3F1ZXJ5X2Nhc3RpbmcuaHRtbCkgZm9yXG4gKiBtb3JlIGluZm9ybWF0aW9uIG9uIGhvdyBNb25nb29zZSBjYXN0cyBgZmlsdGVyYC5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIC8vIGZpbmQgYWxsIGRvY3VtZW50c1xuICogICAgIGF3YWl0IE15TW9kZWwuZmluZCh7fSk7XG4gKlxuICogICAgIC8vIGZpbmQgYWxsIGRvY3VtZW50cyBuYW1lZCBqb2huIGFuZCBhdCBsZWFzdCAxOFxuICogICAgIGF3YWl0IE15TW9kZWwuZmluZCh7IG5hbWU6ICdqb2huJywgYWdlOiB7ICRndGU6IDE4IH0gfSkuZXhlYygpO1xuICpcbiAqICAgICAvLyBleGVjdXRlcywgbmFtZSBMSUtFIGpvaG4gYW5kIG9ubHkgc2VsZWN0aW5nIHRoZSBcIm5hbWVcIiBhbmQgXCJmcmllbmRzXCIgZmllbGRzXG4gKiAgICAgYXdhaXQgTXlNb2RlbC5maW5kKHsgbmFtZTogL2pvaG4vaSB9LCAnbmFtZSBmcmllbmRzJykuZXhlYygpO1xuICpcbiAqICAgICAvLyBwYXNzaW5nIG9wdGlvbnNcbiAqICAgICBhd2FpdCBNeU1vZGVsLmZpbmQoeyBuYW1lOiAvam9obi9pIH0sIG51bGwsIHsgc2tpcDogMTAgfSkuZXhlYygpO1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fE9iamVjdElkfSBmaWx0ZXJcbiAqIEBwYXJhbSB7T2JqZWN0fFN0cmluZ3xTdHJpbmdbXX0gW3Byb2plY3Rpb25dIG9wdGlvbmFsIGZpZWxkcyB0byByZXR1cm4sIHNlZSBbYFF1ZXJ5LnByb3RvdHlwZS5zZWxlY3QoKWBdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvcXVlcnkuaHRtbCNRdWVyeS5wcm90b3R5cGUuc2VsZWN0KCkpXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIG9wdGlvbmFsIHNlZSBbYFF1ZXJ5LnByb3RvdHlwZS5zZXRPcHRpb25zKClgXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvYXBpL3F1ZXJ5Lmh0bWwjUXVlcnkucHJvdG90eXBlLnNldE9wdGlvbnMoKSlcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMudHJhbnNsYXRlQWxpYXNlcz1udWxsXSBJZiBzZXQgdG8gYHRydWVgLCB0cmFuc2xhdGVzIGFueSBzY2hlbWEtZGVmaW5lZCBhbGlhc2VzIGluIGBmaWx0ZXJgLCBgcHJvamVjdGlvbmAsIGB1cGRhdGVgLCBhbmQgYGRpc3RpbmN0YC4gVGhyb3dzIGFuIGVycm9yIGlmIHRoZXJlIGFyZSBhbnkgY29uZmxpY3RzIHdoZXJlIGJvdGggYWxpYXMgYW5kIHJhdyBwcm9wZXJ0eSBhcmUgZGVmaW5lZCBvbiB0aGUgc2FtZSBvYmplY3QuXG4gKiBAcmV0dXJuIHtRdWVyeX1cbiAqIEBzZWUgZmllbGQgc2VsZWN0aW9uIGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvcXVlcnkuaHRtbCNRdWVyeS5wcm90b3R5cGUuc2VsZWN0KClcbiAqIEBzZWUgcXVlcnkgY2FzdGluZyBodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvdHV0b3JpYWxzL3F1ZXJ5X2Nhc3RpbmcuaHRtbFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Nb2RlbC5maW5kID0gZnVuY3Rpb24gZmluZChjb25kaXRpb25zLCBwcm9qZWN0aW9uLCBvcHRpb25zKSB7XG4gIF9jaGVja0NvbnRleHQodGhpcywgJ2ZpbmQnKTtcbiAgaWYgKHR5cGVvZiBhcmd1bWVudHNbMF0gPT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIGFyZ3VtZW50c1sxXSA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgYXJndW1lbnRzWzJdID09PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBhcmd1bWVudHNbM10gPT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgTW9uZ29vc2VFcnJvcignTW9kZWwuZmluZCgpIG5vIGxvbmdlciBhY2NlcHRzIGEgY2FsbGJhY2snKTtcbiAgfVxuXG4gIGNvbnN0IG1xID0gbmV3IHRoaXMuUXVlcnkoe30sIHt9LCB0aGlzLCB0aGlzLiRfX2NvbGxlY3Rpb24pO1xuICBtcS5zZWxlY3QocHJvamVjdGlvbik7XG4gIG1xLnNldE9wdGlvbnMob3B0aW9ucyk7XG5cbiAgcmV0dXJuIG1xLmZpbmQoY29uZGl0aW9ucyk7XG59O1xuXG4vKipcbiAqIEZpbmRzIGEgc2luZ2xlIGRvY3VtZW50IGJ5IGl0cyBfaWQgZmllbGQuIGBmaW5kQnlJZChpZClgIGlzIGFsbW9zdCpcbiAqIGVxdWl2YWxlbnQgdG8gYGZpbmRPbmUoeyBfaWQ6IGlkIH0pYC4gSWYgeW91IHdhbnQgdG8gcXVlcnkgYnkgYSBkb2N1bWVudCdzXG4gKiBgX2lkYCwgdXNlIGBmaW5kQnlJZCgpYCBpbnN0ZWFkIG9mIGBmaW5kT25lKClgLlxuICpcbiAqIFRoZSBgaWRgIGlzIGNhc3QgYmFzZWQgb24gdGhlIFNjaGVtYSBiZWZvcmUgc2VuZGluZyB0aGUgY29tbWFuZC5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIHRyaWdnZXJzIHRoZSBmb2xsb3dpbmcgbWlkZGxld2FyZS5cbiAqXG4gKiAtIGBmaW5kT25lKClgXG4gKlxuICogXFwqIEV4Y2VwdCBmb3IgaG93IGl0IHRyZWF0cyBgdW5kZWZpbmVkYC4gSWYgeW91IHVzZSBgZmluZE9uZSgpYCwgeW91J2xsIHNlZVxuICogdGhhdCBgZmluZE9uZSh1bmRlZmluZWQpYCBhbmQgYGZpbmRPbmUoeyBfaWQ6IHVuZGVmaW5lZCB9KWAgYXJlIGVxdWl2YWxlbnRcbiAqIHRvIGBmaW5kT25lKHt9KWAgYW5kIHJldHVybiBhcmJpdHJhcnkgZG9jdW1lbnRzLiBIb3dldmVyLCBtb25nb29zZVxuICogdHJhbnNsYXRlcyBgZmluZEJ5SWQodW5kZWZpbmVkKWAgaW50byBgZmluZE9uZSh7IF9pZDogbnVsbCB9KWAuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICAvLyBGaW5kIHRoZSBhZHZlbnR1cmUgd2l0aCB0aGUgZ2l2ZW4gYGlkYCwgb3IgYG51bGxgIGlmIG5vdCBmb3VuZFxuICogICAgIGF3YWl0IEFkdmVudHVyZS5maW5kQnlJZChpZCkuZXhlYygpO1xuICpcbiAqICAgICAvLyBzZWxlY3Qgb25seSB0aGUgYWR2ZW50dXJlcyBuYW1lIGFuZCBsZW5ndGhcbiAqICAgICBhd2FpdCBBZHZlbnR1cmUuZmluZEJ5SWQoaWQsICduYW1lIGxlbmd0aCcpLmV4ZWMoKTtcbiAqXG4gKiBAcGFyYW0ge0FueX0gaWQgdmFsdWUgb2YgYF9pZGAgdG8gcXVlcnkgYnlcbiAqIEBwYXJhbSB7T2JqZWN0fFN0cmluZ3xTdHJpbmdbXX0gW3Byb2plY3Rpb25dIG9wdGlvbmFsIGZpZWxkcyB0byByZXR1cm4sIHNlZSBbYFF1ZXJ5LnByb3RvdHlwZS5zZWxlY3QoKWBdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvcXVlcnkuaHRtbCNRdWVyeS5wcm90b3R5cGUuc2VsZWN0KCkpXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIG9wdGlvbmFsIHNlZSBbYFF1ZXJ5LnByb3RvdHlwZS5zZXRPcHRpb25zKClgXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvYXBpL3F1ZXJ5Lmh0bWwjUXVlcnkucHJvdG90eXBlLnNldE9wdGlvbnMoKSlcbiAqIEByZXR1cm4ge1F1ZXJ5fVxuICogQHNlZSBmaWVsZCBzZWxlY3Rpb24gaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2FwaS9xdWVyeS5odG1sI1F1ZXJ5LnByb3RvdHlwZS5zZWxlY3QoKVxuICogQHNlZSBsZWFuIHF1ZXJpZXMgaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL3R1dG9yaWFscy9sZWFuLmh0bWxcbiAqIEBzZWUgZmluZEJ5SWQgaW4gTW9uZ29vc2UgaHR0cHM6Ly9tYXN0ZXJpbmdqcy5pby90dXRvcmlhbHMvbW9uZ29vc2UvZmluZC1ieS1pZFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Nb2RlbC5maW5kQnlJZCA9IGZ1bmN0aW9uIGZpbmRCeUlkKGlkLCBwcm9qZWN0aW9uLCBvcHRpb25zKSB7XG4gIF9jaGVja0NvbnRleHQodGhpcywgJ2ZpbmRCeUlkJyk7XG4gIGlmICh0eXBlb2YgYXJndW1lbnRzWzBdID09PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBhcmd1bWVudHNbMV0gPT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIGFyZ3VtZW50c1syXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBNb25nb29zZUVycm9yKCdNb2RlbC5maW5kQnlJZCgpIG5vIGxvbmdlciBhY2NlcHRzIGEgY2FsbGJhY2snKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgaWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgaWQgPSBudWxsO1xuICB9XG5cbiAgcmV0dXJuIHRoaXMuZmluZE9uZSh7IF9pZDogaWQgfSwgcHJvamVjdGlvbiwgb3B0aW9ucyk7XG59O1xuXG4vKipcbiAqIEZpbmRzIG9uZSBkb2N1bWVudC5cbiAqXG4gKiBUaGUgYGNvbmRpdGlvbnNgIGFyZSBjYXN0IHRvIHRoZWlyIHJlc3BlY3RpdmUgU2NoZW1hVHlwZXMgYmVmb3JlIHRoZSBjb21tYW5kIGlzIHNlbnQuXG4gKlxuICogKk5vdGU6KiBgY29uZGl0aW9uc2AgaXMgb3B0aW9uYWwsIGFuZCBpZiBgY29uZGl0aW9uc2AgaXMgbnVsbCBvciB1bmRlZmluZWQsXG4gKiBtb25nb29zZSB3aWxsIHNlbmQgYW4gZW1wdHkgYGZpbmRPbmVgIGNvbW1hbmQgdG8gTW9uZ29EQiwgd2hpY2ggd2lsbCByZXR1cm5cbiAqIGFuIGFyYml0cmFyeSBkb2N1bWVudC4gSWYgeW91J3JlIHF1ZXJ5aW5nIGJ5IGBfaWRgLCB1c2UgYGZpbmRCeUlkKClgIGluc3RlYWQuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICAvLyBGaW5kIG9uZSBhZHZlbnR1cmUgd2hvc2UgYGNvdW50cnlgIGlzICdDcm9hdGlhJywgb3RoZXJ3aXNlIGBudWxsYFxuICogICAgIGF3YWl0IEFkdmVudHVyZS5maW5kT25lKHsgY291bnRyeTogJ0Nyb2F0aWEnIH0pLmV4ZWMoKTtcbiAqXG4gKiAgICAgLy8gTW9kZWwuZmluZE9uZSgpIG5vIGxvbmdlciBhY2NlcHRzIGEgY2FsbGJhY2tcbiAqXG4gKiAgICAgLy8gU2VsZWN0IG9ubHkgdGhlIGFkdmVudHVyZXMgbmFtZSBhbmQgbGVuZ3RoXG4gKiAgICAgYXdhaXQgQWR2ZW50dXJlLmZpbmRPbmUoeyBjb3VudHJ5OiAnQ3JvYXRpYScgfSwgJ25hbWUgbGVuZ3RoJykuZXhlYygpO1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZGl0aW9uc11cbiAqIEBwYXJhbSB7T2JqZWN0fFN0cmluZ3xTdHJpbmdbXX0gW3Byb2plY3Rpb25dIG9wdGlvbmFsIGZpZWxkcyB0byByZXR1cm4sIHNlZSBbYFF1ZXJ5LnByb3RvdHlwZS5zZWxlY3QoKWBdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvcXVlcnkuaHRtbCNRdWVyeS5wcm90b3R5cGUuc2VsZWN0KCkpXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIG9wdGlvbmFsIHNlZSBbYFF1ZXJ5LnByb3RvdHlwZS5zZXRPcHRpb25zKClgXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvYXBpL3F1ZXJ5Lmh0bWwjUXVlcnkucHJvdG90eXBlLnNldE9wdGlvbnMoKSlcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMudHJhbnNsYXRlQWxpYXNlcz1udWxsXSBJZiBzZXQgdG8gYHRydWVgLCB0cmFuc2xhdGVzIGFueSBzY2hlbWEtZGVmaW5lZCBhbGlhc2VzIGluIGBmaWx0ZXJgLCBgcHJvamVjdGlvbmAsIGB1cGRhdGVgLCBhbmQgYGRpc3RpbmN0YC4gVGhyb3dzIGFuIGVycm9yIGlmIHRoZXJlIGFyZSBhbnkgY29uZmxpY3RzIHdoZXJlIGJvdGggYWxpYXMgYW5kIHJhdyBwcm9wZXJ0eSBhcmUgZGVmaW5lZCBvbiB0aGUgc2FtZSBvYmplY3QuXG4gKiBAcmV0dXJuIHtRdWVyeX1cbiAqIEBzZWUgZmllbGQgc2VsZWN0aW9uIGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvcXVlcnkuaHRtbCNRdWVyeS5wcm90b3R5cGUuc2VsZWN0KClcbiAqIEBzZWUgbGVhbiBxdWVyaWVzIGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy90dXRvcmlhbHMvbGVhbi5odG1sXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk1vZGVsLmZpbmRPbmUgPSBmdW5jdGlvbiBmaW5kT25lKGNvbmRpdGlvbnMsIHByb2plY3Rpb24sIG9wdGlvbnMpIHtcbiAgX2NoZWNrQ29udGV4dCh0aGlzLCAnZmluZE9uZScpO1xuICBpZiAodHlwZW9mIGFyZ3VtZW50c1swXSA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgYXJndW1lbnRzWzFdID09PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBhcmd1bWVudHNbMl0gPT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgTW9uZ29vc2VFcnJvcignTW9kZWwuZmluZE9uZSgpIG5vIGxvbmdlciBhY2NlcHRzIGEgY2FsbGJhY2snKTtcbiAgfVxuXG4gIGNvbnN0IG1xID0gbmV3IHRoaXMuUXVlcnkoe30sIHt9LCB0aGlzLCB0aGlzLiRfX2NvbGxlY3Rpb24pO1xuICBtcS5zZWxlY3QocHJvamVjdGlvbik7XG4gIG1xLnNldE9wdGlvbnMob3B0aW9ucyk7XG5cbiAgcmV0dXJuIG1xLmZpbmRPbmUoY29uZGl0aW9ucyk7XG59O1xuXG4vKipcbiAqIEVzdGltYXRlcyB0aGUgbnVtYmVyIG9mIGRvY3VtZW50cyBpbiB0aGUgTW9uZ29EQiBjb2xsZWN0aW9uLiBGYXN0ZXIgdGhhblxuICogdXNpbmcgYGNvdW50RG9jdW1lbnRzKClgIGZvciBsYXJnZSBjb2xsZWN0aW9ucyBiZWNhdXNlXG4gKiBgZXN0aW1hdGVkRG9jdW1lbnRDb3VudCgpYCB1c2VzIGNvbGxlY3Rpb24gbWV0YWRhdGEgcmF0aGVyIHRoYW4gc2Nhbm5pbmdcbiAqIHRoZSBlbnRpcmUgY29sbGVjdGlvbi5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IG51bUFkdmVudHVyZXMgPSBhd2FpdCBBZHZlbnR1cmUuZXN0aW1hdGVkRG9jdW1lbnRDb3VudCgpO1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEByZXR1cm4ge1F1ZXJ5fVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Nb2RlbC5lc3RpbWF0ZWREb2N1bWVudENvdW50ID0gZnVuY3Rpb24gZXN0aW1hdGVkRG9jdW1lbnRDb3VudChvcHRpb25zKSB7XG4gIF9jaGVja0NvbnRleHQodGhpcywgJ2VzdGltYXRlZERvY3VtZW50Q291bnQnKTtcblxuICBjb25zdCBtcSA9IG5ldyB0aGlzLlF1ZXJ5KHt9LCB7fSwgdGhpcywgdGhpcy4kX19jb2xsZWN0aW9uKTtcblxuICByZXR1cm4gbXEuZXN0aW1hdGVkRG9jdW1lbnRDb3VudChvcHRpb25zKTtcbn07XG5cbi8qKlxuICogQ291bnRzIG51bWJlciBvZiBkb2N1bWVudHMgbWF0Y2hpbmcgYGZpbHRlcmAgaW4gYSBkYXRhYmFzZSBjb2xsZWN0aW9uLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgQWR2ZW50dXJlLmNvdW50RG9jdW1lbnRzKHsgdHlwZTogJ2p1bmdsZScgfSwgZnVuY3Rpb24gKGVyciwgY291bnQpIHtcbiAqICAgICAgIGNvbnNvbGUubG9nKCd0aGVyZSBhcmUgJWQganVuZ2xlIGFkdmVudHVyZXMnLCBjb3VudCk7XG4gKiAgICAgfSk7XG4gKlxuICogSWYgeW91IHdhbnQgdG8gY291bnQgYWxsIGRvY3VtZW50cyBpbiBhIGxhcmdlIGNvbGxlY3Rpb24sXG4gKiB1c2UgdGhlIFtgZXN0aW1hdGVkRG9jdW1lbnRDb3VudCgpYCBmdW5jdGlvbl0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2FwaS9tb2RlbC5odG1sI01vZGVsLmVzdGltYXRlZERvY3VtZW50Q291bnQoKSlcbiAqIGluc3RlYWQuIElmIHlvdSBjYWxsIGBjb3VudERvY3VtZW50cyh7fSlgLCBNb25nb0RCIHdpbGwgYWx3YXlzIGV4ZWN1dGVcbiAqIGEgZnVsbCBjb2xsZWN0aW9uIHNjYW4gYW5kICoqbm90KiogdXNlIGFueSBpbmRleGVzLlxuICpcbiAqIFRoZSBgY291bnREb2N1bWVudHMoKWAgZnVuY3Rpb24gaXMgc2ltaWxhciB0byBgY291bnQoKWAsIGJ1dCB0aGVyZSBhcmUgYVxuICogW2ZldyBvcGVyYXRvcnMgdGhhdCBgY291bnREb2N1bWVudHMoKWAgZG9lcyBub3Qgc3VwcG9ydF0oaHR0cHM6Ly9tb25nb2RiLmdpdGh1Yi5pby9ub2RlLW1vbmdvZGItbmF0aXZlLzQuOS9jbGFzc2VzL0NvbGxlY3Rpb24uaHRtbCNjb3VudERvY3VtZW50cykuXG4gKiBCZWxvdyBhcmUgdGhlIG9wZXJhdG9ycyB0aGF0IGBjb3VudCgpYCBzdXBwb3J0cyBidXQgYGNvdW50RG9jdW1lbnRzKClgIGRvZXMgbm90LFxuICogYW5kIHRoZSBzdWdnZXN0ZWQgcmVwbGFjZW1lbnQ6XG4gKlxuICogLSBgJHdoZXJlYDogW2AkZXhwcmBdKGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvbWFudWFsL3JlZmVyZW5jZS9vcGVyYXRvci9xdWVyeS9leHByLylcbiAqIC0gYCRuZWFyYDogW2AkZ2VvV2l0aGluYF0oaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvcmVmZXJlbmNlL29wZXJhdG9yL3F1ZXJ5L2dlb1dpdGhpbi8pIHdpdGggW2AkY2VudGVyYF0oaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvcmVmZXJlbmNlL29wZXJhdG9yL3F1ZXJ5L2NlbnRlci8jb3AuX1NfY2VudGVyKVxuICogLSBgJG5lYXJTcGhlcmVgOiBbYCRnZW9XaXRoaW5gXShodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9yZWZlcmVuY2Uvb3BlcmF0b3IvcXVlcnkvZ2VvV2l0aGluLykgd2l0aCBbYCRjZW50ZXJTcGhlcmVgXShodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9yZWZlcmVuY2Uvb3BlcmF0b3IvcXVlcnkvY2VudGVyU3BoZXJlLyNvcC5fU19jZW50ZXJTcGhlcmUpXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGZpbHRlclxuICogQHJldHVybiB7UXVlcnl9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk1vZGVsLmNvdW50RG9jdW1lbnRzID0gZnVuY3Rpb24gY291bnREb2N1bWVudHMoY29uZGl0aW9ucywgb3B0aW9ucykge1xuICBfY2hlY2tDb250ZXh0KHRoaXMsICdjb3VudERvY3VtZW50cycpO1xuICBpZiAodHlwZW9mIGFyZ3VtZW50c1swXSA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgYXJndW1lbnRzWzFdID09PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBhcmd1bWVudHNbMl0gPT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgTW9uZ29vc2VFcnJvcignTW9kZWwuY291bnREb2N1bWVudHMoKSBubyBsb25nZXIgYWNjZXB0cyBhIGNhbGxiYWNrJyk7XG4gIH1cblxuICBjb25zdCBtcSA9IG5ldyB0aGlzLlF1ZXJ5KHt9LCB7fSwgdGhpcywgdGhpcy4kX19jb2xsZWN0aW9uKTtcbiAgaWYgKG9wdGlvbnMgIT0gbnVsbCkge1xuICAgIG1xLnNldE9wdGlvbnMob3B0aW9ucyk7XG4gIH1cblxuICByZXR1cm4gbXEuY291bnREb2N1bWVudHMoY29uZGl0aW9ucyk7XG59O1xuXG5cbi8qKlxuICogQ3JlYXRlcyBhIFF1ZXJ5IGZvciBhIGBkaXN0aW5jdGAgb3BlcmF0aW9uLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgY29uc3QgcXVlcnkgPSBMaW5rLmRpc3RpbmN0KCd1cmwnKTtcbiAqICAgICBxdWVyeS5leGVjKCk7XG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGZpZWxkXG4gKiBAcGFyYW0ge09iamVjdH0gW2NvbmRpdGlvbnNdIG9wdGlvbmFsXG4gKiBAcmV0dXJuIHtRdWVyeX1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuTW9kZWwuZGlzdGluY3QgPSBmdW5jdGlvbiBkaXN0aW5jdChmaWVsZCwgY29uZGl0aW9ucykge1xuICBfY2hlY2tDb250ZXh0KHRoaXMsICdkaXN0aW5jdCcpO1xuICBpZiAodHlwZW9mIGFyZ3VtZW50c1swXSA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgYXJndW1lbnRzWzFdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IE1vbmdvb3NlRXJyb3IoJ01vZGVsLmRpc3RpbmN0KCkgbm8gbG9uZ2VyIGFjY2VwdHMgYSBjYWxsYmFjaycpO1xuICB9XG5cbiAgY29uc3QgbXEgPSBuZXcgdGhpcy5RdWVyeSh7fSwge30sIHRoaXMsIHRoaXMuJF9fY29sbGVjdGlvbik7XG5cbiAgcmV0dXJuIG1xLmRpc3RpbmN0KGZpZWxkLCBjb25kaXRpb25zKTtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIFF1ZXJ5LCBhcHBsaWVzIHRoZSBwYXNzZWQgY29uZGl0aW9ucywgYW5kIHJldHVybnMgdGhlIFF1ZXJ5LlxuICpcbiAqIEZvciBleGFtcGxlLCBpbnN0ZWFkIG9mIHdyaXRpbmc6XG4gKlxuICogICAgIFVzZXIuZmluZCh7IGFnZTogeyAkZ3RlOiAyMSwgJGx0ZTogNjUgfSB9KTtcbiAqXG4gKiB3ZSBjYW4gaW5zdGVhZCB3cml0ZTpcbiAqXG4gKiAgICAgVXNlci53aGVyZSgnYWdlJykuZ3RlKDIxKS5sdGUoNjUpLmV4ZWMoKTtcbiAqXG4gKiBTaW5jZSB0aGUgUXVlcnkgY2xhc3MgYWxzbyBzdXBwb3J0cyBgd2hlcmVgIHlvdSBjYW4gY29udGludWUgY2hhaW5pbmdcbiAqXG4gKiAgICAgVXNlclxuICogICAgIC53aGVyZSgnYWdlJykuZ3RlKDIxKS5sdGUoNjUpXG4gKiAgICAgLndoZXJlKCduYW1lJywgL15iL2kpXG4gKiAgICAgLi4uIGV0Y1xuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoXG4gKiBAcGFyYW0ge09iamVjdH0gW3ZhbF0gb3B0aW9uYWwgdmFsdWVcbiAqIEByZXR1cm4ge1F1ZXJ5fVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Nb2RlbC53aGVyZSA9IGZ1bmN0aW9uIHdoZXJlKHBhdGgsIHZhbCkge1xuICBfY2hlY2tDb250ZXh0KHRoaXMsICd3aGVyZScpO1xuXG4gIHZvaWQgdmFsOyAvLyBlc2xpbnRcbiAgY29uc3QgbXEgPSBuZXcgdGhpcy5RdWVyeSh7fSwge30sIHRoaXMsIHRoaXMuJF9fY29sbGVjdGlvbikuZmluZCh7fSk7XG4gIHJldHVybiBtcS53aGVyZS5hcHBseShtcSwgYXJndW1lbnRzKTtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIGBRdWVyeWAgYW5kIHNwZWNpZmllcyBhIGAkd2hlcmVgIGNvbmRpdGlvbi5cbiAqXG4gKiBTb21ldGltZXMgeW91IG5lZWQgdG8gcXVlcnkgZm9yIHRoaW5ncyBpbiBtb25nb2RiIHVzaW5nIGEgSmF2YVNjcmlwdCBleHByZXNzaW9uLiBZb3UgY2FuIGRvIHNvIHZpYSBgZmluZCh7ICR3aGVyZTogamF2YXNjcmlwdCB9KWAsIG9yIHlvdSBjYW4gdXNlIHRoZSBtb25nb29zZSBzaG9ydGN1dCBtZXRob2QgJHdoZXJlIHZpYSBhIFF1ZXJ5IGNoYWluIG9yIGZyb20geW91ciBtb25nb29zZSBNb2RlbC5cbiAqXG4gKiAgICAgQmxvZy4kd2hlcmUoJ3RoaXMudXNlcm5hbWUuaW5kZXhPZihcInZhbFwiKSAhPT0gLTEnKS5leGVjKGZ1bmN0aW9uIChlcnIsIGRvY3MpIHt9KTtcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ3xGdW5jdGlvbn0gYXJndW1lbnQgaXMgYSBqYXZhc2NyaXB0IHN0cmluZyBvciBhbm9ueW1vdXMgZnVuY3Rpb25cbiAqIEBtZXRob2QgJHdoZXJlXG4gKiBAbWVtYmVyT2YgTW9kZWxcbiAqIEByZXR1cm4ge1F1ZXJ5fVxuICogQHNlZSBRdWVyeS4kd2hlcmUgaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2FwaS9xdWVyeS5odG1sI1F1ZXJ5LnByb3RvdHlwZS4kd2hlcmVcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuTW9kZWwuJHdoZXJlID0gZnVuY3Rpb24gJHdoZXJlKCkge1xuICBfY2hlY2tDb250ZXh0KHRoaXMsICckd2hlcmUnKTtcblxuICBjb25zdCBtcSA9IG5ldyB0aGlzLlF1ZXJ5KHt9LCB7fSwgdGhpcywgdGhpcy4kX19jb2xsZWN0aW9uKS5maW5kKHt9KTtcbiAgcmV0dXJuIG1xLiR3aGVyZS5hcHBseShtcSwgYXJndW1lbnRzKTtcbn07XG5cbi8qKlxuICogSXNzdWVzIGEgbW9uZ29kYiBmaW5kT25lQW5kVXBkYXRlIGNvbW1hbmQuXG4gKlxuICogRmluZHMgYSBtYXRjaGluZyBkb2N1bWVudCwgdXBkYXRlcyBpdCBhY2NvcmRpbmcgdG8gdGhlIGB1cGRhdGVgIGFyZywgcGFzc2luZyBhbnkgYG9wdGlvbnNgLCBhbmQgcmV0dXJucyB0aGUgZm91bmQgZG9jdW1lbnQgKGlmIGFueSkgdG8gdGhlIGNhbGxiYWNrLiBUaGUgcXVlcnkgZXhlY3V0ZXMgaWYgYGNhbGxiYWNrYCBpcyBwYXNzZWQgZWxzZSBhIFF1ZXJ5IG9iamVjdCBpcyByZXR1cm5lZC5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIEEuZmluZE9uZUFuZFVwZGF0ZShjb25kaXRpb25zLCB1cGRhdGUsIG9wdGlvbnMpICAvLyByZXR1cm5zIFF1ZXJ5XG4gKiAgICAgQS5maW5kT25lQW5kVXBkYXRlKGNvbmRpdGlvbnMsIHVwZGF0ZSkgICAgICAgICAgIC8vIHJldHVybnMgUXVlcnlcbiAqICAgICBBLmZpbmRPbmVBbmRVcGRhdGUoKSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmV0dXJucyBRdWVyeVxuICpcbiAqICMjIyMgTm90ZTpcbiAqXG4gKiBBbGwgdG9wIGxldmVsIHVwZGF0ZSBrZXlzIHdoaWNoIGFyZSBub3QgYGF0b21pY2Agb3BlcmF0aW9uIG5hbWVzIGFyZSB0cmVhdGVkIGFzIHNldCBvcGVyYXRpb25zOlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgY29uc3QgcXVlcnkgPSB7IG5hbWU6ICdib3JuZScgfTtcbiAqICAgICBNb2RlbC5maW5kT25lQW5kVXBkYXRlKHF1ZXJ5LCB7IG5hbWU6ICdqYXNvbiBib3VybmUnIH0sIG9wdGlvbnMpXG4gKlxuICogICAgIC8vIGlzIHNlbnQgYXNcbiAqICAgICBNb2RlbC5maW5kT25lQW5kVXBkYXRlKHF1ZXJ5LCB7ICRzZXQ6IHsgbmFtZTogJ2phc29uIGJvdXJuZScgfX0sIG9wdGlvbnMpXG4gKlxuICogIyMjIyBOb3RlOlxuICpcbiAqIGBmaW5kT25lQW5kWGAgYW5kIGBmaW5kQnlJZEFuZFhgIGZ1bmN0aW9ucyBzdXBwb3J0IGxpbWl0ZWQgdmFsaWRhdGlvbiB0aGF0XG4gKiB5b3UgY2FuIGVuYWJsZSBieSBzZXR0aW5nIHRoZSBgcnVuVmFsaWRhdG9yc2Agb3B0aW9uLlxuICpcbiAqIElmIHlvdSBuZWVkIGZ1bGwtZmxlZGdlZCB2YWxpZGF0aW9uLCB1c2UgdGhlIHRyYWRpdGlvbmFsIGFwcHJvYWNoIG9mIGZpcnN0XG4gKiByZXRyaWV2aW5nIHRoZSBkb2N1bWVudC5cbiAqXG4gKiAgICAgY29uc3QgZG9jID0gYXdhaXQgTW9kZWwuZmluZEJ5SWQoaWQpO1xuICogICAgIGRvYy5uYW1lID0gJ2phc29uIGJvdXJuZSc7XG4gKiAgICAgYXdhaXQgZG9jLnNhdmUoKTtcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gW2NvbmRpdGlvbnNdXG4gKiBAcGFyYW0ge09iamVjdH0gW3VwZGF0ZV1cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gb3B0aW9uYWwgc2VlIFtgUXVlcnkucHJvdG90eXBlLnNldE9wdGlvbnMoKWBdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvcXVlcnkuaHRtbCNRdWVyeS5wcm90b3R5cGUuc2V0T3B0aW9ucygpKVxuICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLnJldHVybkRvY3VtZW50PSdiZWZvcmUnXSBIYXMgdHdvIHBvc3NpYmxlIHZhbHVlcywgYCdiZWZvcmUnYCBhbmQgYCdhZnRlcidgLiBCeSBkZWZhdWx0LCBpdCB3aWxsIHJldHVybiB0aGUgZG9jdW1lbnQgYmVmb3JlIHRoZSB1cGRhdGUgd2FzIGFwcGxpZWQuXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMubGVhbl0gaWYgdHJ1dGh5LCBtb25nb29zZSB3aWxsIHJldHVybiB0aGUgZG9jdW1lbnQgYXMgYSBwbGFpbiBKYXZhU2NyaXB0IG9iamVjdCByYXRoZXIgdGhhbiBhIG1vbmdvb3NlIGRvY3VtZW50LiBTZWUgW2BRdWVyeS5sZWFuKClgXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvYXBpL3F1ZXJ5Lmh0bWwjUXVlcnkucHJvdG90eXBlLmxlYW4oKSkgYW5kIFt0aGUgTW9uZ29vc2UgbGVhbiB0dXRvcmlhbF0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL3R1dG9yaWFscy9sZWFuLmh0bWwpLlxuICogQHBhcmFtIHtDbGllbnRTZXNzaW9ufSBbb3B0aW9ucy5zZXNzaW9uPW51bGxdIFRoZSBzZXNzaW9uIGFzc29jaWF0ZWQgd2l0aCB0aGlzIHF1ZXJ5LiBTZWUgW3RyYW5zYWN0aW9ucyBkb2NzXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvdHJhbnNhY3Rpb25zLmh0bWwpLlxuICogQHBhcmFtIHtCb29sZWFufFN0cmluZ30gW29wdGlvbnMuc3RyaWN0XSBvdmVyd3JpdGVzIHRoZSBzY2hlbWEncyBbc3RyaWN0IG1vZGUgb3B0aW9uXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvZ3VpZGUuaHRtbCNzdHJpY3QpXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnRpbWVzdGFtcHM9bnVsbF0gSWYgc2V0IHRvIGBmYWxzZWAgYW5kIFtzY2hlbWEtbGV2ZWwgdGltZXN0YW1wc10oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2d1aWRlLmh0bWwjdGltZXN0YW1wcykgYXJlIGVuYWJsZWQsIHNraXAgdGltZXN0YW1wcyBmb3IgdGhpcyB1cGRhdGUuIE5vdGUgdGhhdCB0aGlzIGFsbG93cyB5b3UgdG8gb3ZlcndyaXRlIHRpbWVzdGFtcHMuIERvZXMgbm90aGluZyBpZiBzY2hlbWEtbGV2ZWwgdGltZXN0YW1wcyBhcmUgbm90IHNldC5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMudXBzZXJ0PWZhbHNlXSBpZiB0cnVlLCBhbmQgbm8gZG9jdW1lbnRzIGZvdW5kLCBpbnNlcnQgYSBuZXcgZG9jdW1lbnRcbiAqIEBwYXJhbSB7T2JqZWN0fFN0cmluZ3xTdHJpbmdbXX0gW29wdGlvbnMucHJvamVjdGlvbj1udWxsXSBvcHRpb25hbCBmaWVsZHMgdG8gcmV0dXJuLCBzZWUgW2BRdWVyeS5wcm90b3R5cGUuc2VsZWN0KClgXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvYXBpL3F1ZXJ5Lmh0bWwjUXVlcnkucHJvdG90eXBlLnNlbGVjdCgpKVxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5uZXc9ZmFsc2VdIGlmIHRydWUsIHJldHVybiB0aGUgbW9kaWZpZWQgZG9jdW1lbnQgcmF0aGVyIHRoYW4gdGhlIG9yaWdpbmFsXG4gKiBAcGFyYW0ge09iamVjdHxTdHJpbmd9IFtvcHRpb25zLmZpZWxkc10gRmllbGQgc2VsZWN0aW9uLiBFcXVpdmFsZW50IHRvIGAuc2VsZWN0KGZpZWxkcykuZmluZE9uZUFuZFVwZGF0ZSgpYFxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLm1heFRpbWVNU10gcHV0cyBhIHRpbWUgbGltaXQgb24gdGhlIHF1ZXJ5IC0gcmVxdWlyZXMgbW9uZ29kYiA+PSAyLjYuMFxuICogQHBhcmFtIHtPYmplY3R8U3RyaW5nfSBbb3B0aW9ucy5zb3J0XSBpZiBtdWx0aXBsZSBkb2NzIGFyZSBmb3VuZCBieSB0aGUgY29uZGl0aW9ucywgc2V0cyB0aGUgc29ydCBvcmRlciB0byBjaG9vc2Ugd2hpY2ggZG9jIHRvIHVwZGF0ZS5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMucnVuVmFsaWRhdG9yc10gaWYgdHJ1ZSwgcnVucyBbdXBkYXRlIHZhbGlkYXRvcnNdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy92YWxpZGF0aW9uLmh0bWwjdXBkYXRlLXZhbGlkYXRvcnMpIG9uIHRoaXMgY29tbWFuZC4gVXBkYXRlIHZhbGlkYXRvcnMgdmFsaWRhdGUgdGhlIHVwZGF0ZSBvcGVyYXRpb24gYWdhaW5zdCB0aGUgbW9kZWwncyBzY2hlbWFcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuc2V0RGVmYXVsdHNPbkluc2VydD10cnVlXSBJZiBgc2V0RGVmYXVsdHNPbkluc2VydGAgYW5kIGB1cHNlcnRgIGFyZSB0cnVlLCBtb25nb29zZSB3aWxsIGFwcGx5IHRoZSBbZGVmYXVsdHNdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9kZWZhdWx0cy5odG1sKSBzcGVjaWZpZWQgaW4gdGhlIG1vZGVsJ3Mgc2NoZW1hIGlmIGEgbmV3IGRvY3VtZW50IGlzIGNyZWF0ZWRcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuaW5jbHVkZVJlc3VsdE1ldGFkYXRhXSBpZiB0cnVlLCByZXR1cm5zIHRoZSBbcmF3IHJlc3VsdCBmcm9tIHRoZSBNb25nb0RCIGRyaXZlcl0oaHR0cHM6Ly9tb25nb2RiLmdpdGh1Yi5pby9ub2RlLW1vbmdvZGItbmF0aXZlLzQuOS9pbnRlcmZhY2VzL01vZGlmeVJlc3VsdC5odG1sKVxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy50cmFuc2xhdGVBbGlhc2VzPW51bGxdIElmIHNldCB0byBgdHJ1ZWAsIHRyYW5zbGF0ZXMgYW55IHNjaGVtYS1kZWZpbmVkIGFsaWFzZXMgaW4gYGZpbHRlcmAsIGBwcm9qZWN0aW9uYCwgYHVwZGF0ZWAsIGFuZCBgZGlzdGluY3RgLiBUaHJvd3MgYW4gZXJyb3IgaWYgdGhlcmUgYXJlIGFueSBjb25mbGljdHMgd2hlcmUgYm90aCBhbGlhcyBhbmQgcmF3IHByb3BlcnR5IGFyZSBkZWZpbmVkIG9uIHRoZSBzYW1lIG9iamVjdC5cbiAqIEByZXR1cm4ge1F1ZXJ5fVxuICogQHNlZSBUdXRvcmlhbCBodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvdHV0b3JpYWxzL2ZpbmRvbmVhbmR1cGRhdGUuaHRtbFxuICogQHNlZSBtb25nb2RiIGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvbWFudWFsL3JlZmVyZW5jZS9jb21tYW5kL2ZpbmRBbmRNb2RpZnkvXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk1vZGVsLmZpbmRPbmVBbmRVcGRhdGUgPSBmdW5jdGlvbihjb25kaXRpb25zLCB1cGRhdGUsIG9wdGlvbnMpIHtcbiAgX2NoZWNrQ29udGV4dCh0aGlzLCAnZmluZE9uZUFuZFVwZGF0ZScpO1xuICBpZiAodHlwZW9mIGFyZ3VtZW50c1swXSA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgYXJndW1lbnRzWzFdID09PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBhcmd1bWVudHNbMl0gPT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIGFyZ3VtZW50c1szXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBNb25nb29zZUVycm9yKCdNb2RlbC5maW5kT25lQW5kVXBkYXRlKCkgbm8gbG9uZ2VyIGFjY2VwdHMgYSBjYWxsYmFjaycpO1xuICB9XG5cbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICB1cGRhdGUgPSBjb25kaXRpb25zO1xuICAgIGNvbmRpdGlvbnMgPSBudWxsO1xuICAgIG9wdGlvbnMgPSBudWxsO1xuICB9XG5cbiAgbGV0IGZpZWxkcztcbiAgaWYgKG9wdGlvbnMpIHtcbiAgICBmaWVsZHMgPSBvcHRpb25zLmZpZWxkcyB8fCBvcHRpb25zLnByb2plY3Rpb247XG4gIH1cblxuICB1cGRhdGUgPSBjbG9uZSh1cGRhdGUsIHtcbiAgICBkZXBvcHVsYXRlOiB0cnVlLFxuICAgIF9pc05lc3RlZDogdHJ1ZVxuICB9KTtcblxuICBkZWNvcmF0ZVVwZGF0ZVdpdGhWZXJzaW9uS2V5KHVwZGF0ZSwgb3B0aW9ucywgdGhpcy5zY2hlbWEub3B0aW9ucy52ZXJzaW9uS2V5KTtcblxuICBjb25zdCBtcSA9IG5ldyB0aGlzLlF1ZXJ5KHt9LCB7fSwgdGhpcywgdGhpcy4kX19jb2xsZWN0aW9uKTtcbiAgbXEuc2VsZWN0KGZpZWxkcyk7XG5cbiAgcmV0dXJuIG1xLmZpbmRPbmVBbmRVcGRhdGUoY29uZGl0aW9ucywgdXBkYXRlLCBvcHRpb25zKTtcbn07XG5cbi8qKlxuICogSXNzdWVzIGEgbW9uZ29kYiBmaW5kT25lQW5kVXBkYXRlIGNvbW1hbmQgYnkgYSBkb2N1bWVudCdzIF9pZCBmaWVsZC5cbiAqIGBmaW5kQnlJZEFuZFVwZGF0ZShpZCwgLi4uKWAgaXMgZXF1aXZhbGVudCB0byBgZmluZE9uZUFuZFVwZGF0ZSh7IF9pZDogaWQgfSwgLi4uKWAuXG4gKlxuICogRmluZHMgYSBtYXRjaGluZyBkb2N1bWVudCwgdXBkYXRlcyBpdCBhY2NvcmRpbmcgdG8gdGhlIGB1cGRhdGVgIGFyZyxcbiAqIHBhc3NpbmcgYW55IGBvcHRpb25zYCwgYW5kIHJldHVybnMgdGhlIGZvdW5kIGRvY3VtZW50IChpZiBhbnkpLlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gdHJpZ2dlcnMgdGhlIGZvbGxvd2luZyBtaWRkbGV3YXJlLlxuICpcbiAqIC0gYGZpbmRPbmVBbmRVcGRhdGUoKWBcbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIEEuZmluZEJ5SWRBbmRVcGRhdGUoaWQsIHVwZGF0ZSwgb3B0aW9ucykgIC8vIHJldHVybnMgUXVlcnlcbiAqICAgICBBLmZpbmRCeUlkQW5kVXBkYXRlKGlkLCB1cGRhdGUpICAgICAgICAgICAvLyByZXR1cm5zIFF1ZXJ5XG4gKiAgICAgQS5maW5kQnlJZEFuZFVwZGF0ZSgpICAgICAgICAgICAgICAgICAgICAgLy8gcmV0dXJucyBRdWVyeVxuICpcbiAqICMjIyMgTm90ZTpcbiAqXG4gKiBBbGwgdG9wIGxldmVsIHVwZGF0ZSBrZXlzIHdoaWNoIGFyZSBub3QgYGF0b21pY2Agb3BlcmF0aW9uIG5hbWVzIGFyZSB0cmVhdGVkIGFzIHNldCBvcGVyYXRpb25zOlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgTW9kZWwuZmluZEJ5SWRBbmRVcGRhdGUoaWQsIHsgbmFtZTogJ2phc29uIGJvdXJuZScgfSwgb3B0aW9ucylcbiAqXG4gKiAgICAgLy8gaXMgc2VudCBhc1xuICogICAgIE1vZGVsLmZpbmRCeUlkQW5kVXBkYXRlKGlkLCB7ICRzZXQ6IHsgbmFtZTogJ2phc29uIGJvdXJuZScgfX0sIG9wdGlvbnMpXG4gKlxuICogIyMjIyBOb3RlOlxuICpcbiAqIGBmaW5kT25lQW5kWGAgYW5kIGBmaW5kQnlJZEFuZFhgIGZ1bmN0aW9ucyBzdXBwb3J0IGxpbWl0ZWQgdmFsaWRhdGlvbi4gWW91IGNhblxuICogZW5hYmxlIHZhbGlkYXRpb24gYnkgc2V0dGluZyB0aGUgYHJ1blZhbGlkYXRvcnNgIG9wdGlvbi5cbiAqXG4gKiBJZiB5b3UgbmVlZCBmdWxsLWZsZWRnZWQgdmFsaWRhdGlvbiwgdXNlIHRoZSB0cmFkaXRpb25hbCBhcHByb2FjaCBvZiBmaXJzdFxuICogcmV0cmlldmluZyB0aGUgZG9jdW1lbnQuXG4gKlxuICogICAgIGNvbnN0IGRvYyA9IGF3YWl0IE1vZGVsLmZpbmRCeUlkKGlkKVxuICogICAgIGRvYy5uYW1lID0gJ2phc29uIGJvdXJuZSc7XG4gKiAgICAgYXdhaXQgZG9jLnNhdmUoKTtcbiAqXG4gKiBAcGFyYW0ge09iamVjdHxOdW1iZXJ8U3RyaW5nfSBpZCB2YWx1ZSBvZiBgX2lkYCB0byBxdWVyeSBieVxuICogQHBhcmFtIHtPYmplY3R9IFt1cGRhdGVdXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIG9wdGlvbmFsIHNlZSBbYFF1ZXJ5LnByb3RvdHlwZS5zZXRPcHRpb25zKClgXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvYXBpL3F1ZXJ5Lmh0bWwjUXVlcnkucHJvdG90eXBlLnNldE9wdGlvbnMoKSlcbiAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5yZXR1cm5Eb2N1bWVudD0nYmVmb3JlJ10gSGFzIHR3byBwb3NzaWJsZSB2YWx1ZXMsIGAnYmVmb3JlJ2AgYW5kIGAnYWZ0ZXInYC4gQnkgZGVmYXVsdCwgaXQgd2lsbCByZXR1cm4gdGhlIGRvY3VtZW50IGJlZm9yZSB0aGUgdXBkYXRlIHdhcyBhcHBsaWVkLlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLmxlYW5dIGlmIHRydXRoeSwgbW9uZ29vc2Ugd2lsbCByZXR1cm4gdGhlIGRvY3VtZW50IGFzIGEgcGxhaW4gSmF2YVNjcmlwdCBvYmplY3QgcmF0aGVyIHRoYW4gYSBtb25nb29zZSBkb2N1bWVudC4gU2VlIFtgUXVlcnkubGVhbigpYF0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2FwaS9xdWVyeS5odG1sI1F1ZXJ5LnByb3RvdHlwZS5sZWFuKCkpIGFuZCBbdGhlIE1vbmdvb3NlIGxlYW4gdHV0b3JpYWxdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy90dXRvcmlhbHMvbGVhbi5odG1sKS5cbiAqIEBwYXJhbSB7Q2xpZW50U2Vzc2lvbn0gW29wdGlvbnMuc2Vzc2lvbj1udWxsXSBUaGUgc2Vzc2lvbiBhc3NvY2lhdGVkIHdpdGggdGhpcyBxdWVyeS4gU2VlIFt0cmFuc2FjdGlvbnMgZG9jc10oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL3RyYW5zYWN0aW9ucy5odG1sKS5cbiAqIEBwYXJhbSB7Qm9vbGVhbnxTdHJpbmd9IFtvcHRpb25zLnN0cmljdF0gb3ZlcndyaXRlcyB0aGUgc2NoZW1hJ3MgW3N0cmljdCBtb2RlIG9wdGlvbl0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2d1aWRlLmh0bWwjc3RyaWN0KVxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy50aW1lc3RhbXBzPW51bGxdIElmIHNldCB0byBgZmFsc2VgIGFuZCBbc2NoZW1hLWxldmVsIHRpbWVzdGFtcHNdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9ndWlkZS5odG1sI3RpbWVzdGFtcHMpIGFyZSBlbmFibGVkLCBza2lwIHRpbWVzdGFtcHMgZm9yIHRoaXMgdXBkYXRlLiBOb3RlIHRoYXQgdGhpcyBhbGxvd3MgeW91IHRvIG92ZXJ3cml0ZSB0aW1lc3RhbXBzLiBEb2VzIG5vdGhpbmcgaWYgc2NoZW1hLWxldmVsIHRpbWVzdGFtcHMgYXJlIG5vdCBzZXQuXG4gKiBAcGFyYW0ge09iamVjdHxTdHJpbmd9IFtvcHRpb25zLnNvcnRdIGlmIG11bHRpcGxlIGRvY3MgYXJlIGZvdW5kIGJ5IHRoZSBjb25kaXRpb25zLCBzZXRzIHRoZSBzb3J0IG9yZGVyIHRvIGNob29zZSB3aGljaCBkb2MgdG8gdXBkYXRlLlxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5ydW5WYWxpZGF0b3JzXSBpZiB0cnVlLCBydW5zIFt1cGRhdGUgdmFsaWRhdG9yc10oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL3ZhbGlkYXRpb24uaHRtbCN1cGRhdGUtdmFsaWRhdG9ycykgb24gdGhpcyBjb21tYW5kLiBVcGRhdGUgdmFsaWRhdG9ycyB2YWxpZGF0ZSB0aGUgdXBkYXRlIG9wZXJhdGlvbiBhZ2FpbnN0IHRoZSBtb2RlbCdzIHNjaGVtYVxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5zZXREZWZhdWx0c09uSW5zZXJ0PXRydWVdIElmIGBzZXREZWZhdWx0c09uSW5zZXJ0YCBhbmQgYHVwc2VydGAgYXJlIHRydWUsIG1vbmdvb3NlIHdpbGwgYXBwbHkgdGhlIFtkZWZhdWx0c10oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2RlZmF1bHRzLmh0bWwpIHNwZWNpZmllZCBpbiB0aGUgbW9kZWwncyBzY2hlbWEgaWYgYSBuZXcgZG9jdW1lbnQgaXMgY3JlYXRlZFxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5pbmNsdWRlUmVzdWx0TWV0YWRhdGFdIGlmIHRydWUsIHJldHVybnMgdGhlIGZ1bGwgW01vZGlmeVJlc3VsdCBmcm9tIHRoZSBNb25nb0RCIGRyaXZlcl0oaHR0cHM6Ly9tb25nb2RiLmdpdGh1Yi5pby9ub2RlLW1vbmdvZGItbmF0aXZlLzQuOS9pbnRlcmZhY2VzL01vZGlmeVJlc3VsdC5odG1sKSByYXRoZXIgdGhhbiBqdXN0IHRoZSBkb2N1bWVudFxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy51cHNlcnQ9ZmFsc2VdIGlmIHRydWUsIGFuZCBubyBkb2N1bWVudHMgZm91bmQsIGluc2VydCBhIG5ldyBkb2N1bWVudFxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5uZXc9ZmFsc2VdIGlmIHRydWUsIHJldHVybiB0aGUgbW9kaWZpZWQgZG9jdW1lbnQgcmF0aGVyIHRoYW4gdGhlIG9yaWdpbmFsXG4gKiBAcGFyYW0ge09iamVjdHxTdHJpbmd9IFtvcHRpb25zLnNlbGVjdF0gc2V0cyB0aGUgZG9jdW1lbnQgZmllbGRzIHRvIHJldHVybi5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMudHJhbnNsYXRlQWxpYXNlcz1udWxsXSBJZiBzZXQgdG8gYHRydWVgLCB0cmFuc2xhdGVzIGFueSBzY2hlbWEtZGVmaW5lZCBhbGlhc2VzIGluIGBmaWx0ZXJgLCBgcHJvamVjdGlvbmAsIGB1cGRhdGVgLCBhbmQgYGRpc3RpbmN0YC4gVGhyb3dzIGFuIGVycm9yIGlmIHRoZXJlIGFyZSBhbnkgY29uZmxpY3RzIHdoZXJlIGJvdGggYWxpYXMgYW5kIHJhdyBwcm9wZXJ0eSBhcmUgZGVmaW5lZCBvbiB0aGUgc2FtZSBvYmplY3QuXG4gKiBAcmV0dXJuIHtRdWVyeX1cbiAqIEBzZWUgTW9kZWwuZmluZE9uZUFuZFVwZGF0ZSBodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvYXBpL21vZGVsLmh0bWwjTW9kZWwuZmluZE9uZUFuZFVwZGF0ZSgpXG4gKiBAc2VlIG1vbmdvZGIgaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvcmVmZXJlbmNlL2NvbW1hbmQvZmluZEFuZE1vZGlmeS9cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuTW9kZWwuZmluZEJ5SWRBbmRVcGRhdGUgPSBmdW5jdGlvbihpZCwgdXBkYXRlLCBvcHRpb25zKSB7XG4gIF9jaGVja0NvbnRleHQodGhpcywgJ2ZpbmRCeUlkQW5kVXBkYXRlJyk7XG4gIGlmICh0eXBlb2YgYXJndW1lbnRzWzBdID09PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBhcmd1bWVudHNbMV0gPT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIGFyZ3VtZW50c1syXSA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgYXJndW1lbnRzWzNdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IE1vbmdvb3NlRXJyb3IoJ01vZGVsLmZpbmRCeUlkQW5kVXBkYXRlKCkgbm8gbG9uZ2VyIGFjY2VwdHMgYSBjYWxsYmFjaycpO1xuICB9XG5cbiAgLy8gaWYgYSBtb2RlbCBpcyBwYXNzZWQgaW4gaW5zdGVhZCBvZiBhbiBpZFxuICBpZiAoaWQgaW5zdGFuY2VvZiBEb2N1bWVudCkge1xuICAgIGlkID0gaWQuX2lkO1xuICB9XG5cbiAgcmV0dXJuIHRoaXMuZmluZE9uZUFuZFVwZGF0ZS5jYWxsKHRoaXMsIHsgX2lkOiBpZCB9LCB1cGRhdGUsIG9wdGlvbnMpO1xufTtcblxuLyoqXG4gKiBJc3N1ZSBhIE1vbmdvREIgYGZpbmRPbmVBbmREZWxldGUoKWAgY29tbWFuZC5cbiAqXG4gKiBGaW5kcyBhIG1hdGNoaW5nIGRvY3VtZW50LCByZW1vdmVzIGl0LCBhbmQgcmV0dXJucyB0aGUgZm91bmQgZG9jdW1lbnQgKGlmIGFueSkuXG4gKlxuICogVGhpcyBmdW5jdGlvbiB0cmlnZ2VycyB0aGUgZm9sbG93aW5nIG1pZGRsZXdhcmUuXG4gKlxuICogLSBgZmluZE9uZUFuZERlbGV0ZSgpYFxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgQS5maW5kT25lQW5kRGVsZXRlKGNvbmRpdGlvbnMsIG9wdGlvbnMpICAvLyByZXR1cm4gUXVlcnlcbiAqICAgICBBLmZpbmRPbmVBbmREZWxldGUoY29uZGl0aW9ucykgLy8gcmV0dXJucyBRdWVyeVxuICogICAgIEEuZmluZE9uZUFuZERlbGV0ZSgpICAgICAgICAgICAvLyByZXR1cm5zIFF1ZXJ5XG4gKlxuICogYGZpbmRPbmVBbmRYYCBhbmQgYGZpbmRCeUlkQW5kWGAgZnVuY3Rpb25zIHN1cHBvcnQgbGltaXRlZCB2YWxpZGF0aW9uLiBZb3UgY2FuXG4gKiBlbmFibGUgdmFsaWRhdGlvbiBieSBzZXR0aW5nIHRoZSBgcnVuVmFsaWRhdG9yc2Agb3B0aW9uLlxuICpcbiAqIElmIHlvdSBuZWVkIGZ1bGwtZmxlZGdlZCB2YWxpZGF0aW9uLCB1c2UgdGhlIHRyYWRpdGlvbmFsIGFwcHJvYWNoIG9mIGZpcnN0XG4gKiByZXRyaWV2aW5nIHRoZSBkb2N1bWVudC5cbiAqXG4gKiAgICAgY29uc3QgZG9jID0gYXdhaXQgTW9kZWwuZmluZEJ5SWQoaWQpXG4gKiAgICAgZG9jLm5hbWUgPSAnamFzb24gYm91cm5lJztcbiAqICAgICBhd2FpdCBkb2Muc2F2ZSgpO1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb25kaXRpb25zXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIG9wdGlvbmFsIHNlZSBbYFF1ZXJ5LnByb3RvdHlwZS5zZXRPcHRpb25zKClgXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvYXBpL3F1ZXJ5Lmh0bWwjUXVlcnkucHJvdG90eXBlLnNldE9wdGlvbnMoKSlcbiAqIEBwYXJhbSB7Qm9vbGVhbnxTdHJpbmd9IFtvcHRpb25zLnN0cmljdF0gb3ZlcndyaXRlcyB0aGUgc2NoZW1hJ3MgW3N0cmljdCBtb2RlIG9wdGlvbl0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2d1aWRlLmh0bWwjc3RyaWN0KVxuICogQHBhcmFtIHtPYmplY3R8U3RyaW5nfFN0cmluZ1tdfSBbb3B0aW9ucy5wcm9qZWN0aW9uPW51bGxdIG9wdGlvbmFsIGZpZWxkcyB0byByZXR1cm4sIHNlZSBbYFF1ZXJ5LnByb3RvdHlwZS5zZWxlY3QoKWBdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvcXVlcnkuaHRtbCNRdWVyeS5wcm90b3R5cGUuc2VsZWN0KCkpXG4gKiBAcGFyYW0ge0NsaWVudFNlc3Npb259IFtvcHRpb25zLnNlc3Npb249bnVsbF0gVGhlIHNlc3Npb24gYXNzb2NpYXRlZCB3aXRoIHRoaXMgcXVlcnkuIFNlZSBbdHJhbnNhY3Rpb25zIGRvY3NdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy90cmFuc2FjdGlvbnMuaHRtbCkuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmluY2x1ZGVSZXN1bHRNZXRhZGF0YV0gaWYgdHJ1ZSwgcmV0dXJucyB0aGUgZnVsbCBbTW9kaWZ5UmVzdWx0IGZyb20gdGhlIE1vbmdvREIgZHJpdmVyXShodHRwczovL21vbmdvZGIuZ2l0aHViLmlvL25vZGUtbW9uZ29kYi1uYXRpdmUvNC45L2ludGVyZmFjZXMvTW9kaWZ5UmVzdWx0Lmh0bWwpIHJhdGhlciB0aGFuIGp1c3QgdGhlIGRvY3VtZW50XG4gKiBAcGFyYW0ge09iamVjdHxTdHJpbmd9IFtvcHRpb25zLnNvcnRdIGlmIG11bHRpcGxlIGRvY3MgYXJlIGZvdW5kIGJ5IHRoZSBjb25kaXRpb25zLCBzZXRzIHRoZSBzb3J0IG9yZGVyIHRvIGNob29zZSB3aGljaCBkb2MgdG8gdXBkYXRlLlxuICogQHBhcmFtIHtPYmplY3R8U3RyaW5nfSBbb3B0aW9ucy5zZWxlY3RdIHNldHMgdGhlIGRvY3VtZW50IGZpZWxkcyB0byByZXR1cm4uXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMubWF4VGltZU1TXSBwdXRzIGEgdGltZSBsaW1pdCBvbiB0aGUgcXVlcnkgLSByZXF1aXJlcyBtb25nb2RiID49IDIuNi4wXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnRyYW5zbGF0ZUFsaWFzZXM9bnVsbF0gSWYgc2V0IHRvIGB0cnVlYCwgdHJhbnNsYXRlcyBhbnkgc2NoZW1hLWRlZmluZWQgYWxpYXNlcyBpbiBgZmlsdGVyYCwgYHByb2plY3Rpb25gLCBgdXBkYXRlYCwgYW5kIGBkaXN0aW5jdGAuIFRocm93cyBhbiBlcnJvciBpZiB0aGVyZSBhcmUgYW55IGNvbmZsaWN0cyB3aGVyZSBib3RoIGFsaWFzIGFuZCByYXcgcHJvcGVydHkgYXJlIGRlZmluZWQgb24gdGhlIHNhbWUgb2JqZWN0LlxuICogQHJldHVybiB7UXVlcnl9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk1vZGVsLmZpbmRPbmVBbmREZWxldGUgPSBmdW5jdGlvbihjb25kaXRpb25zLCBvcHRpb25zKSB7XG4gIF9jaGVja0NvbnRleHQodGhpcywgJ2ZpbmRPbmVBbmREZWxldGUnKTtcblxuICBpZiAodHlwZW9mIGFyZ3VtZW50c1swXSA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgYXJndW1lbnRzWzFdID09PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBhcmd1bWVudHNbMl0gPT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgTW9uZ29vc2VFcnJvcignTW9kZWwuZmluZE9uZUFuZERlbGV0ZSgpIG5vIGxvbmdlciBhY2NlcHRzIGEgY2FsbGJhY2snKTtcbiAgfVxuXG4gIGxldCBmaWVsZHM7XG4gIGlmIChvcHRpb25zKSB7XG4gICAgZmllbGRzID0gb3B0aW9ucy5zZWxlY3Q7XG4gICAgb3B0aW9ucy5zZWxlY3QgPSB1bmRlZmluZWQ7XG4gIH1cblxuICBjb25zdCBtcSA9IG5ldyB0aGlzLlF1ZXJ5KHt9LCB7fSwgdGhpcywgdGhpcy4kX19jb2xsZWN0aW9uKTtcbiAgbXEuc2VsZWN0KGZpZWxkcyk7XG5cbiAgcmV0dXJuIG1xLmZpbmRPbmVBbmREZWxldGUoY29uZGl0aW9ucywgb3B0aW9ucyk7XG59O1xuXG4vKipcbiAqIElzc3VlIGEgTW9uZ29EQiBgZmluZE9uZUFuZERlbGV0ZSgpYCBjb21tYW5kIGJ5IGEgZG9jdW1lbnQncyBfaWQgZmllbGQuXG4gKiBJbiBvdGhlciB3b3JkcywgYGZpbmRCeUlkQW5kRGVsZXRlKGlkKWAgaXMgYSBzaG9ydGhhbmQgZm9yXG4gKiBgZmluZE9uZUFuZERlbGV0ZSh7IF9pZDogaWQgfSlgLlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gdHJpZ2dlcnMgdGhlIGZvbGxvd2luZyBtaWRkbGV3YXJlLlxuICpcbiAqIC0gYGZpbmRPbmVBbmREZWxldGUoKWBcbiAqXG4gKiBAcGFyYW0ge09iamVjdHxOdW1iZXJ8U3RyaW5nfSBpZCB2YWx1ZSBvZiBgX2lkYCB0byBxdWVyeSBieVxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBvcHRpb25hbCBzZWUgW2BRdWVyeS5wcm90b3R5cGUuc2V0T3B0aW9ucygpYF0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2FwaS9xdWVyeS5odG1sI1F1ZXJ5LnByb3RvdHlwZS5zZXRPcHRpb25zKCkpXG4gKiBAcGFyYW0ge0Jvb2xlYW58U3RyaW5nfSBbb3B0aW9ucy5zdHJpY3RdIG92ZXJ3cml0ZXMgdGhlIHNjaGVtYSdzIFtzdHJpY3QgbW9kZSBvcHRpb25dKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9ndWlkZS5odG1sI3N0cmljdClcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMudHJhbnNsYXRlQWxpYXNlcz1udWxsXSBJZiBzZXQgdG8gYHRydWVgLCB0cmFuc2xhdGVzIGFueSBzY2hlbWEtZGVmaW5lZCBhbGlhc2VzIGluIGBmaWx0ZXJgLCBgcHJvamVjdGlvbmAsIGB1cGRhdGVgLCBhbmQgYGRpc3RpbmN0YC4gVGhyb3dzIGFuIGVycm9yIGlmIHRoZXJlIGFyZSBhbnkgY29uZmxpY3RzIHdoZXJlIGJvdGggYWxpYXMgYW5kIHJhdyBwcm9wZXJ0eSBhcmUgZGVmaW5lZCBvbiB0aGUgc2FtZSBvYmplY3QuXG4gKiBAcmV0dXJuIHtRdWVyeX1cbiAqIEBzZWUgTW9kZWwuZmluZE9uZUFuZERlbGV0ZSBodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvYXBpL21vZGVsLmh0bWwjTW9kZWwuZmluZE9uZUFuZERlbGV0ZSgpXG4gKiBAc2VlIG1vbmdvZGIgaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvcmVmZXJlbmNlL2NvbW1hbmQvZmluZEFuZE1vZGlmeS9cbiAqL1xuXG5Nb2RlbC5maW5kQnlJZEFuZERlbGV0ZSA9IGZ1bmN0aW9uKGlkLCBvcHRpb25zKSB7XG4gIF9jaGVja0NvbnRleHQodGhpcywgJ2ZpbmRCeUlkQW5kRGVsZXRlJyk7XG5cbiAgaWYgKHR5cGVvZiBhcmd1bWVudHNbMF0gPT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIGFyZ3VtZW50c1sxXSA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgYXJndW1lbnRzWzJdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IE1vbmdvb3NlRXJyb3IoJ01vZGVsLmZpbmRCeUlkQW5kRGVsZXRlKCkgbm8gbG9uZ2VyIGFjY2VwdHMgYSBjYWxsYmFjaycpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXMuZmluZE9uZUFuZERlbGV0ZSh7IF9pZDogaWQgfSwgb3B0aW9ucyk7XG59O1xuXG4vKipcbiAqIElzc3VlIGEgTW9uZ29EQiBgZmluZE9uZUFuZFJlcGxhY2UoKWAgY29tbWFuZC5cbiAqXG4gKiBGaW5kcyBhIG1hdGNoaW5nIGRvY3VtZW50LCByZXBsYWNlcyBpdCB3aXRoIHRoZSBwcm92aWRlZCBkb2MsIGFuZCByZXR1cm5zIHRoZSBkb2N1bWVudC5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIHRyaWdnZXJzIHRoZSBmb2xsb3dpbmcgcXVlcnkgbWlkZGxld2FyZS5cbiAqXG4gKiAtIGBmaW5kT25lQW5kUmVwbGFjZSgpYFxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgQS5maW5kT25lQW5kUmVwbGFjZShmaWx0ZXIsIHJlcGxhY2VtZW50LCBvcHRpb25zKSAgLy8gcmV0dXJuIFF1ZXJ5XG4gKiAgICAgQS5maW5kT25lQW5kUmVwbGFjZShmaWx0ZXIsIHJlcGxhY2VtZW50KSAvLyByZXR1cm5zIFF1ZXJ5XG4gKiAgICAgQS5maW5kT25lQW5kUmVwbGFjZSgpICAgICAgICAgICAgICAgICAgICAvLyByZXR1cm5zIFF1ZXJ5XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGZpbHRlciBSZXBsYWNlIHRoZSBmaXJzdCBkb2N1bWVudCB0aGF0IG1hdGNoZXMgdGhpcyBmaWx0ZXJcbiAqIEBwYXJhbSB7T2JqZWN0fSBbcmVwbGFjZW1lbnRdIFJlcGxhY2Ugd2l0aCB0aGlzIGRvY3VtZW50XG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIG9wdGlvbmFsIHNlZSBbYFF1ZXJ5LnByb3RvdHlwZS5zZXRPcHRpb25zKClgXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvYXBpL3F1ZXJ5Lmh0bWwjUXVlcnkucHJvdG90eXBlLnNldE9wdGlvbnMoKSlcbiAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5yZXR1cm5Eb2N1bWVudD0nYmVmb3JlJ10gSGFzIHR3byBwb3NzaWJsZSB2YWx1ZXMsIGAnYmVmb3JlJ2AgYW5kIGAnYWZ0ZXInYC4gQnkgZGVmYXVsdCwgaXQgd2lsbCByZXR1cm4gdGhlIGRvY3VtZW50IGJlZm9yZSB0aGUgdXBkYXRlIHdhcyBhcHBsaWVkLlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLmxlYW5dIGlmIHRydXRoeSwgbW9uZ29vc2Ugd2lsbCByZXR1cm4gdGhlIGRvY3VtZW50IGFzIGEgcGxhaW4gSmF2YVNjcmlwdCBvYmplY3QgcmF0aGVyIHRoYW4gYSBtb25nb29zZSBkb2N1bWVudC4gU2VlIFtgUXVlcnkubGVhbigpYF0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2FwaS9xdWVyeS5odG1sI1F1ZXJ5LnByb3RvdHlwZS5sZWFuKCkpIGFuZCBbdGhlIE1vbmdvb3NlIGxlYW4gdHV0b3JpYWxdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy90dXRvcmlhbHMvbGVhbi5odG1sKS5cbiAqIEBwYXJhbSB7Q2xpZW50U2Vzc2lvbn0gW29wdGlvbnMuc2Vzc2lvbj1udWxsXSBUaGUgc2Vzc2lvbiBhc3NvY2lhdGVkIHdpdGggdGhpcyBxdWVyeS4gU2VlIFt0cmFuc2FjdGlvbnMgZG9jc10oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL3RyYW5zYWN0aW9ucy5odG1sKS5cbiAqIEBwYXJhbSB7Qm9vbGVhbnxTdHJpbmd9IFtvcHRpb25zLnN0cmljdF0gb3ZlcndyaXRlcyB0aGUgc2NoZW1hJ3MgW3N0cmljdCBtb2RlIG9wdGlvbl0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2d1aWRlLmh0bWwjc3RyaWN0KVxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy50aW1lc3RhbXBzPW51bGxdIElmIHNldCB0byBgZmFsc2VgIGFuZCBbc2NoZW1hLWxldmVsIHRpbWVzdGFtcHNdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9ndWlkZS5odG1sI3RpbWVzdGFtcHMpIGFyZSBlbmFibGVkLCBza2lwIHRpbWVzdGFtcHMgZm9yIHRoaXMgdXBkYXRlLiBOb3RlIHRoYXQgdGhpcyBhbGxvd3MgeW91IHRvIG92ZXJ3cml0ZSB0aW1lc3RhbXBzLiBEb2VzIG5vdGhpbmcgaWYgc2NoZW1hLWxldmVsIHRpbWVzdGFtcHMgYXJlIG5vdCBzZXQuXG4gKiBAcGFyYW0ge09iamVjdHxTdHJpbmd8U3RyaW5nW119IFtvcHRpb25zLnByb2plY3Rpb249bnVsbF0gb3B0aW9uYWwgZmllbGRzIHRvIHJldHVybiwgc2VlIFtgUXVlcnkucHJvdG90eXBlLnNlbGVjdCgpYF0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2FwaS9xdWVyeS5odG1sI1F1ZXJ5LnByb3RvdHlwZS5zZWxlY3QoKSlcbiAqIEBwYXJhbSB7T2JqZWN0fFN0cmluZ30gW29wdGlvbnMuc29ydF0gaWYgbXVsdGlwbGUgZG9jcyBhcmUgZm91bmQgYnkgdGhlIGNvbmRpdGlvbnMsIHNldHMgdGhlIHNvcnQgb3JkZXIgdG8gY2hvb3NlIHdoaWNoIGRvYyB0byB1cGRhdGUuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmluY2x1ZGVSZXN1bHRNZXRhZGF0YV0gaWYgdHJ1ZSwgcmV0dXJucyB0aGUgZnVsbCBbTW9kaWZ5UmVzdWx0IGZyb20gdGhlIE1vbmdvREIgZHJpdmVyXShodHRwczovL21vbmdvZGIuZ2l0aHViLmlvL25vZGUtbW9uZ29kYi1uYXRpdmUvNC45L2ludGVyZmFjZXMvTW9kaWZ5UmVzdWx0Lmh0bWwpIHJhdGhlciB0aGFuIGp1c3QgdGhlIGRvY3VtZW50XG4gKiBAcGFyYW0ge09iamVjdHxTdHJpbmd9IFtvcHRpb25zLnNlbGVjdF0gc2V0cyB0aGUgZG9jdW1lbnQgZmllbGRzIHRvIHJldHVybi5cbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5tYXhUaW1lTVNdIHB1dHMgYSB0aW1lIGxpbWl0IG9uIHRoZSBxdWVyeSAtIHJlcXVpcmVzIG1vbmdvZGIgPj0gMi42LjBcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMudHJhbnNsYXRlQWxpYXNlcz1udWxsXSBJZiBzZXQgdG8gYHRydWVgLCB0cmFuc2xhdGVzIGFueSBzY2hlbWEtZGVmaW5lZCBhbGlhc2VzIGluIGBmaWx0ZXJgLCBgcHJvamVjdGlvbmAsIGB1cGRhdGVgLCBhbmQgYGRpc3RpbmN0YC4gVGhyb3dzIGFuIGVycm9yIGlmIHRoZXJlIGFyZSBhbnkgY29uZmxpY3RzIHdoZXJlIGJvdGggYWxpYXMgYW5kIHJhdyBwcm9wZXJ0eSBhcmUgZGVmaW5lZCBvbiB0aGUgc2FtZSBvYmplY3QuXG4gKiBAcmV0dXJuIHtRdWVyeX1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuTW9kZWwuZmluZE9uZUFuZFJlcGxhY2UgPSBmdW5jdGlvbihmaWx0ZXIsIHJlcGxhY2VtZW50LCBvcHRpb25zKSB7XG4gIF9jaGVja0NvbnRleHQodGhpcywgJ2ZpbmRPbmVBbmRSZXBsYWNlJyk7XG5cbiAgaWYgKHR5cGVvZiBhcmd1bWVudHNbMF0gPT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIGFyZ3VtZW50c1sxXSA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgYXJndW1lbnRzWzJdID09PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBhcmd1bWVudHNbM10gPT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgTW9uZ29vc2VFcnJvcignTW9kZWwuZmluZE9uZUFuZFJlcGxhY2UoKSBubyBsb25nZXIgYWNjZXB0cyBhIGNhbGxiYWNrJyk7XG4gIH1cblxuICBsZXQgZmllbGRzO1xuICBpZiAob3B0aW9ucykge1xuICAgIGZpZWxkcyA9IG9wdGlvbnMuc2VsZWN0O1xuICAgIG9wdGlvbnMuc2VsZWN0ID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgY29uc3QgbXEgPSBuZXcgdGhpcy5RdWVyeSh7fSwge30sIHRoaXMsIHRoaXMuJF9fY29sbGVjdGlvbik7XG4gIG1xLnNlbGVjdChmaWVsZHMpO1xuXG4gIHJldHVybiBtcS5maW5kT25lQW5kUmVwbGFjZShmaWx0ZXIsIHJlcGxhY2VtZW50LCBvcHRpb25zKTtcbn07XG5cbi8qKlxuICogU2hvcnRjdXQgZm9yIHNhdmluZyBvbmUgb3IgbW9yZSBkb2N1bWVudHMgdG8gdGhlIGRhdGFiYXNlLlxuICogYE15TW9kZWwuY3JlYXRlKGRvY3MpYCBkb2VzIGBuZXcgTXlNb2RlbChkb2MpLnNhdmUoKWAgZm9yIGV2ZXJ5IGRvYyBpblxuICogZG9jcy5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIHRyaWdnZXJzIHRoZSBmb2xsb3dpbmcgbWlkZGxld2FyZS5cbiAqXG4gKiAtIGBzYXZlKClgXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICAvLyBJbnNlcnQgb25lIG5ldyBgQ2hhcmFjdGVyYCBkb2N1bWVudFxuICogICAgIGF3YWl0IENoYXJhY3Rlci5jcmVhdGUoeyBuYW1lOiAnSmVhbi1MdWMgUGljYXJkJyB9KTtcbiAqXG4gKiAgICAgLy8gSW5zZXJ0IG11bHRpcGxlIG5ldyBgQ2hhcmFjdGVyYCBkb2N1bWVudHNcbiAqICAgICBhd2FpdCBDaGFyYWN0ZXIuY3JlYXRlKFt7IG5hbWU6ICdXaWxsIFJpa2VyJyB9LCB7IG5hbWU6ICdHZW9yZGkgTGFGb3JnZScgfV0pO1xuICpcbiAqICAgICAvLyBDcmVhdGUgYSBuZXcgY2hhcmFjdGVyIHdpdGhpbiBhIHRyYW5zYWN0aW9uLiBOb3RlIHRoYXQgeW91ICoqbXVzdCoqXG4gKiAgICAgLy8gcGFzcyBhbiBhcnJheSBhcyB0aGUgZmlyc3QgcGFyYW1ldGVyIHRvIGBjcmVhdGUoKWAgaWYgeW91IHdhbnQgdG9cbiAqICAgICAvLyBzcGVjaWZ5IG9wdGlvbnMuXG4gKiAgICAgYXdhaXQgQ2hhcmFjdGVyLmNyZWF0ZShbeyBuYW1lOiAnSmVhbi1MdWMgUGljYXJkJyB9XSwgeyBzZXNzaW9uIH0pO1xuICpcbiAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBkb2NzIERvY3VtZW50cyB0byBpbnNlcnQsIGFzIGEgc3ByZWFkIG9yIGFycmF5XG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgcGFzc2VkIGRvd24gdG8gYHNhdmUoKWAuIFRvIHNwZWNpZnkgYG9wdGlvbnNgLCBgZG9jc2AgKiptdXN0KiogYmUgYW4gYXJyYXksIG5vdCBhIHNwcmVhZC4gU2VlIFtNb2RlbC5zYXZlXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvYXBpL21vZGVsLmh0bWwjTW9kZWwucHJvdG90eXBlLnNhdmUoKSkgZm9yIGF2YWlsYWJsZSBvcHRpb25zLlxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5vcmRlcmVkXSBzYXZlcyB0aGUgZG9jcyBpbiBzZXJpZXMgcmF0aGVyIHRoYW4gcGFyYWxsZWwuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmFnZ3JlZ2F0ZUVycm9yc10gQWdncmVnYXRlIEVycm9ycyBpbnN0ZWFkIG9mIHRocm93aW5nIHRoZSBmaXJzdCBvbmUgdGhhdCBvY2N1cnMuIERlZmF1bHQ6IGZhbHNlXG4gKiBAcmV0dXJuIHtQcm9taXNlfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Nb2RlbC5jcmVhdGUgPSBhc3luYyBmdW5jdGlvbiBjcmVhdGUoZG9jLCBvcHRpb25zKSB7XG4gIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJyB8fFxuICAgICAgdHlwZW9mIGFyZ3VtZW50c1syXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBNb25nb29zZUVycm9yKCdNb2RlbC5jcmVhdGUoKSBubyBsb25nZXIgYWNjZXB0cyBhIGNhbGxiYWNrJyk7XG4gIH1cblxuICBfY2hlY2tDb250ZXh0KHRoaXMsICdjcmVhdGUnKTtcblxuICBsZXQgYXJncztcbiAgY29uc3QgZGlzY3JpbWluYXRvcktleSA9IHRoaXMuc2NoZW1hLm9wdGlvbnMuZGlzY3JpbWluYXRvcktleTtcblxuICBpZiAoQXJyYXkuaXNBcnJheShkb2MpKSB7XG4gICAgYXJncyA9IGRvYztcbiAgICBvcHRpb25zID0gb3B0aW9ucyAhPSBudWxsICYmIHR5cGVvZiBvcHRpb25zID09PSAnb2JqZWN0JyA/IG9wdGlvbnMgOiB7fTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBsYXN0ID0gYXJndW1lbnRzW2FyZ3VtZW50cy5sZW5ndGggLSAxXTtcbiAgICBvcHRpb25zID0ge307XG4gICAgY29uc3QgaGFzQ2FsbGJhY2sgPSB0eXBlb2YgbGFzdCA9PT0gJ2Z1bmN0aW9uJyB8fFxuICAgICAgdHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicgfHxcbiAgICAgIHR5cGVvZiBhcmd1bWVudHNbMl0gPT09ICdmdW5jdGlvbic7XG4gICAgaWYgKGhhc0NhbGxiYWNrKSB7XG4gICAgICB0aHJvdyBuZXcgTW9uZ29vc2VFcnJvcignTW9kZWwuY3JlYXRlKCkgbm8gbG9uZ2VyIGFjY2VwdHMgYSBjYWxsYmFjaycpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhcmdzID0gWy4uLmFyZ3VtZW50c107XG4gICAgICAvLyBGb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkgd2l0aCA2LngsIGJlY2F1c2Ugb2YgZ2gtNTA2MSBNb25nb29zZSA2LnggYW5kXG4gICAgICAvLyBvbGRlciB3b3VsZCB0cmVhdCBhIGZhbHN5IGxhc3QgYXJnIGFzIGEgY2FsbGJhY2suIFdlIGRvbid0IHdhbnQgdG8gdGhyb3dcbiAgICAgIC8vIGFuIGVycm9yIGhlcmUsIGJlY2F1c2UgaXQgd291bGQgbG9vayBzdHJhbmdlIGlmIGBUZXN0LmNyZWF0ZSh7fSwgdm9pZCAwKWBcbiAgICAgIC8vIHRocmV3IGEgY2FsbGJhY2sgZXJyb3IuIEJ1dCB3ZSBhbHNvIGRvbid0IHdhbnQgdG8gY3JlYXRlIGFuIHVubmVjZXNzYXJ5IGRvY3VtZW50LlxuICAgICAgaWYgKGFyZ3MubGVuZ3RoID4gMSAmJiAhbGFzdCkge1xuICAgICAgICBhcmdzLnBvcCgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChhcmdzLmxlbmd0aCA9PT0gMiAmJlxuICAgICAgICBhcmdzWzBdICE9IG51bGwgJiZcbiAgICAgICAgYXJnc1sxXSAhPSBudWxsICYmXG4gICAgICAgIGFyZ3NbMF0uc2Vzc2lvbiA9PSBudWxsICYmXG4gICAgICAgIGxhc3QgJiZcbiAgICAgICAgZ2V0Q29uc3RydWN0b3JOYW1lKGxhc3Quc2Vzc2lvbikgPT09ICdDbGllbnRTZXNzaW9uJyAmJlxuICAgICAgICAhdGhpcy5zY2hlbWEucGF0aCgnc2Vzc2lvbicpKSB7XG4gICAgICAvLyBQcm9iYWJseSBtZWFucyB0aGUgdXNlciBpcyBydW5uaW5nIGludG8gdGhlIGNvbW1vbiBtaXN0YWtlIG9mIHRyeWluZ1xuICAgICAgLy8gdG8gdXNlIGEgc3ByZWFkIHRvIHNwZWNpZnkgb3B0aW9ucywgc2VlIGdoLTc1MzVcbiAgICAgIHV0aWxzLndhcm4oJ1dBUk5JTkc6IHRvIHBhc3MgYSBgc2Vzc2lvbmAgdG8gYE1vZGVsLmNyZWF0ZSgpYCBpbiAnICtcbiAgICAgICAgJ01vbmdvb3NlLCB5b3UgKiptdXN0KiogcGFzcyBhbiBhcnJheSBhcyB0aGUgZmlyc3QgYXJndW1lbnQuIFNlZTogJyArXG4gICAgICAgICdodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvYXBpL21vZGVsLmh0bWwjTW9kZWwuY3JlYXRlKCknKTtcbiAgICB9XG4gIH1cblxuICBpZiAoYXJncy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheShkb2MpID8gW10gOiBudWxsO1xuICB9XG4gIGxldCByZXMgPSBbXTtcbiAgY29uc3QgaW1tZWRpYXRlRXJyb3IgPSB0eXBlb2Ygb3B0aW9ucy5hZ2dyZWdhdGVFcnJvcnMgPT09ICdib29sZWFuJyA/ICFvcHRpb25zLmFnZ3JlZ2F0ZUVycm9ycyA6IHRydWU7XG5cbiAgZGVsZXRlIG9wdGlvbnMuYWdncmVnYXRlRXJyb3JzOyAvLyBkb250IHBhc3Mgb24gdGhlIG9wdGlvbiB0byBcIiRzYXZlXCJcblxuICBpZiAob3B0aW9ucy5vcmRlcmVkKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBkb2MgPSBhcmdzW2ldO1xuICAgICAgICBjb25zdCBNb2RlbCA9IHRoaXMuZGlzY3JpbWluYXRvcnMgJiYgZG9jW2Rpc2NyaW1pbmF0b3JLZXldICE9IG51bGwgP1xuICAgICAgICAgIHRoaXMuZGlzY3JpbWluYXRvcnNbZG9jW2Rpc2NyaW1pbmF0b3JLZXldXSB8fCBnZXREaXNjcmltaW5hdG9yQnlWYWx1ZSh0aGlzLmRpc2NyaW1pbmF0b3JzLCBkb2NbZGlzY3JpbWluYXRvcktleV0pIDpcbiAgICAgICAgICB0aGlzO1xuICAgICAgICBpZiAoTW9kZWwgPT0gbnVsbCkge1xuICAgICAgICAgIHRocm93IG5ldyBNb25nb29zZUVycm9yKGBEaXNjcmltaW5hdG9yIFwiJHtkb2NbZGlzY3JpbWluYXRvcktleV19XCIgbm90IGAgK1xuICAgICAgICAgIGBmb3VuZCBmb3IgbW9kZWwgXCIke3RoaXMubW9kZWxOYW1lfVwiYCk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHRvU2F2ZSA9IGRvYztcbiAgICAgICAgaWYgKCEodG9TYXZlIGluc3RhbmNlb2YgTW9kZWwpKSB7XG4gICAgICAgICAgdG9TYXZlID0gbmV3IE1vZGVsKHRvU2F2ZSk7XG4gICAgICAgIH1cblxuICAgICAgICBhd2FpdCB0b1NhdmUuJHNhdmUob3B0aW9ucyk7XG4gICAgICAgIHJlcy5wdXNoKHRvU2F2ZSk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgaWYgKCFpbW1lZGlhdGVFcnJvcikge1xuICAgICAgICAgIHJlcy5wdXNoKGVycik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXM7XG4gIH0gZWxzZSBpZiAoIWltbWVkaWF0ZUVycm9yKSB7XG4gICAgcmVzID0gYXdhaXQgUHJvbWlzZS5hbGxTZXR0bGVkKGFyZ3MubWFwKGFzeW5jIGRvYyA9PiB7XG4gICAgICBjb25zdCBNb2RlbCA9IHRoaXMuZGlzY3JpbWluYXRvcnMgJiYgZG9jW2Rpc2NyaW1pbmF0b3JLZXldICE9IG51bGwgP1xuICAgICAgICB0aGlzLmRpc2NyaW1pbmF0b3JzW2RvY1tkaXNjcmltaW5hdG9yS2V5XV0gfHwgZ2V0RGlzY3JpbWluYXRvckJ5VmFsdWUodGhpcy5kaXNjcmltaW5hdG9ycywgZG9jW2Rpc2NyaW1pbmF0b3JLZXldKSA6XG4gICAgICAgIHRoaXM7XG4gICAgICBpZiAoTW9kZWwgPT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgTW9uZ29vc2VFcnJvcihgRGlzY3JpbWluYXRvciBcIiR7ZG9jW2Rpc2NyaW1pbmF0b3JLZXldfVwiIG5vdCBgICtcbiAgICAgICAgICAgIGBmb3VuZCBmb3IgbW9kZWwgXCIke3RoaXMubW9kZWxOYW1lfVwiYCk7XG4gICAgICB9XG4gICAgICBsZXQgdG9TYXZlID0gZG9jO1xuXG4gICAgICBpZiAoISh0b1NhdmUgaW5zdGFuY2VvZiBNb2RlbCkpIHtcbiAgICAgICAgdG9TYXZlID0gbmV3IE1vZGVsKHRvU2F2ZSk7XG4gICAgICB9XG5cbiAgICAgIGF3YWl0IHRvU2F2ZS4kc2F2ZShvcHRpb25zKTtcblxuICAgICAgcmV0dXJuIHRvU2F2ZTtcbiAgICB9KSk7XG4gICAgcmVzID0gcmVzLm1hcChyZXN1bHQgPT4gcmVzdWx0LnN0YXR1cyA9PT0gJ2Z1bGZpbGxlZCcgPyByZXN1bHQudmFsdWUgOiByZXN1bHQucmVhc29uKTtcbiAgfSBlbHNlIHtcbiAgICBsZXQgZmlyc3RFcnJvciA9IG51bGw7XG4gICAgcmVzID0gYXdhaXQgUHJvbWlzZS5hbGwoYXJncy5tYXAoYXN5bmMgZG9jID0+IHtcbiAgICAgIGNvbnN0IE1vZGVsID0gdGhpcy5kaXNjcmltaW5hdG9ycyAmJiBkb2NbZGlzY3JpbWluYXRvcktleV0gIT0gbnVsbCA/XG4gICAgICAgIHRoaXMuZGlzY3JpbWluYXRvcnNbZG9jW2Rpc2NyaW1pbmF0b3JLZXldXSB8fCBnZXREaXNjcmltaW5hdG9yQnlWYWx1ZSh0aGlzLmRpc2NyaW1pbmF0b3JzLCBkb2NbZGlzY3JpbWluYXRvcktleV0pIDpcbiAgICAgICAgdGhpcztcbiAgICAgIGlmIChNb2RlbCA9PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBNb25nb29zZUVycm9yKGBEaXNjcmltaW5hdG9yIFwiJHtkb2NbZGlzY3JpbWluYXRvcktleV19XCIgbm90IGAgK1xuICAgICAgICAgICAgYGZvdW5kIGZvciBtb2RlbCBcIiR7dGhpcy5tb2RlbE5hbWV9XCJgKTtcbiAgICAgIH1cbiAgICAgIHRyeSB7XG4gICAgICAgIGxldCB0b1NhdmUgPSBkb2M7XG5cbiAgICAgICAgaWYgKCEodG9TYXZlIGluc3RhbmNlb2YgTW9kZWwpKSB7XG4gICAgICAgICAgdG9TYXZlID0gbmV3IE1vZGVsKHRvU2F2ZSk7XG4gICAgICAgIH1cblxuICAgICAgICBhd2FpdCB0b1NhdmUuJHNhdmUob3B0aW9ucyk7XG5cbiAgICAgICAgcmV0dXJuIHRvU2F2ZTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBpZiAoIWZpcnN0RXJyb3IpIHtcbiAgICAgICAgICBmaXJzdEVycm9yID0gZXJyO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSkpO1xuICAgIGlmIChmaXJzdEVycm9yKSB7XG4gICAgICB0aHJvdyBmaXJzdEVycm9yO1xuICAgIH1cbiAgfVxuXG5cbiAgaWYgKCFBcnJheS5pc0FycmF5KGRvYykgJiYgYXJncy5sZW5ndGggPT09IDEpIHtcbiAgICByZXR1cm4gcmVzWzBdO1xuICB9XG5cbiAgcmV0dXJuIHJlcztcbn07XG5cbi8qKlxuICogX1JlcXVpcmVzIGEgcmVwbGljYSBzZXQgcnVubmluZyBNb25nb0RCID49IDMuNi4wLl8gV2F0Y2hlcyB0aGVcbiAqIHVuZGVybHlpbmcgY29sbGVjdGlvbiBmb3IgY2hhbmdlcyB1c2luZ1xuICogW01vbmdvREIgY2hhbmdlIHN0cmVhbXNdKGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvbWFudWFsL2NoYW5nZVN0cmVhbXMvKS5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIGRvZXMgKipub3QqKiB0cmlnZ2VyIGFueSBtaWRkbGV3YXJlLiBJbiBwYXJ0aWN1bGFyLCBpdFxuICogZG9lcyAqKm5vdCoqIHRyaWdnZXIgYWdncmVnYXRlIG1pZGRsZXdhcmUuXG4gKlxuICogVGhlIENoYW5nZVN0cmVhbSBvYmplY3QgaXMgYW4gZXZlbnQgZW1pdHRlciB0aGF0IGVtaXRzIHRoZSBmb2xsb3dpbmcgZXZlbnRzOlxuICpcbiAqIC0gJ2NoYW5nZSc6IEEgY2hhbmdlIG9jY3VycmVkLCBzZWUgYmVsb3cgZXhhbXBsZVxuICogLSAnZXJyb3InOiBBbiB1bnJlY292ZXJhYmxlIGVycm9yIG9jY3VycmVkLiBJbiBwYXJ0aWN1bGFyLCBjaGFuZ2Ugc3RyZWFtcyBjdXJyZW50bHkgZXJyb3Igb3V0IGlmIHRoZXkgbG9zZSBjb25uZWN0aW9uIHRvIHRoZSByZXBsaWNhIHNldCBwcmltYXJ5LiBGb2xsb3cgW3RoaXMgR2l0SHViIGlzc3VlXShodHRwczovL2dpdGh1Yi5jb20vQXV0b21hdHRpYy9tb25nb29zZS9pc3N1ZXMvNjc5OSkgZm9yIHVwZGF0ZXMuXG4gKiAtICdlbmQnOiBFbWl0dGVkIGlmIHRoZSB1bmRlcmx5aW5nIHN0cmVhbSBpcyBjbG9zZWRcbiAqIC0gJ2Nsb3NlJzogRW1pdHRlZCBpZiB0aGUgdW5kZXJseWluZyBzdHJlYW0gaXMgY2xvc2VkXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBjb25zdCBkb2MgPSBhd2FpdCBQZXJzb24uY3JlYXRlKHsgbmFtZTogJ05lZCBTdGFyaycgfSk7XG4gKiAgICAgY29uc3QgY2hhbmdlU3RyZWFtID0gUGVyc29uLndhdGNoKCkub24oJ2NoYW5nZScsIGNoYW5nZSA9PiBjb25zb2xlLmxvZyhjaGFuZ2UpKTtcbiAqICAgICAvLyBXaWxsIHByaW50IGZyb20gdGhlIGFib3ZlIGBjb25zb2xlLmxvZygpYDpcbiAqICAgICAvLyB7IF9pZDogeyBfZGF0YTogLi4uIH0sXG4gKiAgICAgLy8gICBvcGVyYXRpb25UeXBlOiAnZGVsZXRlJyxcbiAqICAgICAvLyAgIG5zOiB7IGRiOiAnbXlkYicsIGNvbGw6ICdQZXJzb24nIH0sXG4gKiAgICAgLy8gICBkb2N1bWVudEtleTogeyBfaWQ6IDVhNTFiMTI1YzU1MDBmNWFhMDk0YzdiZCB9IH1cbiAqICAgICBhd2FpdCBkb2MucmVtb3ZlKCk7XG4gKlxuICogQHBhcmFtIHtBcnJheX0gW3BpcGVsaW5lXVxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBzZWUgdGhlIFttb25nb2RiIGRyaXZlciBvcHRpb25zXShodHRwczovL21vbmdvZGIuZ2l0aHViLmlvL25vZGUtbW9uZ29kYi1uYXRpdmUvNC45L2NsYXNzZXMvQ29sbGVjdGlvbi5odG1sI3dhdGNoKVxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5oeWRyYXRlPWZhbHNlXSBpZiB0cnVlIGFuZCBgZnVsbERvY3VtZW50OiAndXBkYXRlTG9va3VwJ2AgaXMgc2V0LCBNb25nb29zZSB3aWxsIGF1dG9tYXRpY2FsbHkgaHlkcmF0ZSBgZnVsbERvY3VtZW50YCBpbnRvIGEgZnVsbHkgZmxlZGdlZCBNb25nb29zZSBkb2N1bWVudFxuICogQHJldHVybiB7Q2hhbmdlU3RyZWFtfSBtb25nb29zZS1zcGVjaWZpYyBjaGFuZ2Ugc3RyZWFtIHdyYXBwZXIsIGluaGVyaXRzIGZyb20gRXZlbnRFbWl0dGVyXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk1vZGVsLndhdGNoID0gZnVuY3Rpb24ocGlwZWxpbmUsIG9wdGlvbnMpIHtcbiAgX2NoZWNrQ29udGV4dCh0aGlzLCAnd2F0Y2gnKTtcblxuICBjb25zdCBjaGFuZ2VTdHJlYW1UaHVuayA9IGNiID0+IHtcbiAgICBwaXBlbGluZSA9IHBpcGVsaW5lIHx8IFtdO1xuICAgIHByZXBhcmVEaXNjcmltaW5hdG9yUGlwZWxpbmUocGlwZWxpbmUsIHRoaXMuc2NoZW1hLCAnZnVsbERvY3VtZW50Jyk7XG4gICAgaWYgKHRoaXMuJF9fY29sbGVjdGlvbi5idWZmZXIpIHtcbiAgICAgIHRoaXMuJF9fY29sbGVjdGlvbi5hZGRRdWV1ZSgoKSA9PiB7XG4gICAgICAgIGlmICh0aGlzLmNsb3NlZCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkcml2ZXJDaGFuZ2VTdHJlYW0gPSB0aGlzLiRfX2NvbGxlY3Rpb24ud2F0Y2gocGlwZWxpbmUsIG9wdGlvbnMpO1xuICAgICAgICBjYihudWxsLCBkcml2ZXJDaGFuZ2VTdHJlYW0pO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGRyaXZlckNoYW5nZVN0cmVhbSA9IHRoaXMuJF9fY29sbGVjdGlvbi53YXRjaChwaXBlbGluZSwgb3B0aW9ucyk7XG4gICAgICBjYihudWxsLCBkcml2ZXJDaGFuZ2VTdHJlYW0pO1xuICAgIH1cbiAgfTtcblxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgb3B0aW9ucy5tb2RlbCA9IHRoaXM7XG5cbiAgcmV0dXJuIG5ldyBDaGFuZ2VTdHJlYW0oY2hhbmdlU3RyZWFtVGh1bmssIHBpcGVsaW5lLCBvcHRpb25zKTtcbn07XG5cbi8qKlxuICogX1JlcXVpcmVzIE1vbmdvREIgPj0gMy42LjAuXyBTdGFydHMgYSBbTW9uZ29EQiBzZXNzaW9uXShodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9yZWxlYXNlLW5vdGVzLzMuNi8jY2xpZW50LXNlc3Npb25zKVxuICogZm9yIGJlbmVmaXRzIGxpa2UgY2F1c2FsIGNvbnNpc3RlbmN5LCBbcmV0cnlhYmxlIHdyaXRlc10oaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvY29yZS9yZXRyeWFibGUtd3JpdGVzLyksXG4gKiBhbmQgW3RyYW5zYWN0aW9uc10oaHR0cHM6Ly90aGVjb2RlYmFyYmFyaWFuLmNvbS9hLW5vZGUtanMtcGVyc3BlY3RpdmUtb24tbW9uZ29kYi00LXRyYW5zYWN0aW9ucy5odG1sKS5cbiAqXG4gKiBDYWxsaW5nIGBNeU1vZGVsLnN0YXJ0U2Vzc2lvbigpYCBpcyBlcXVpdmFsZW50IHRvIGNhbGxpbmcgYE15TW9kZWwuZGIuc3RhcnRTZXNzaW9uKClgLlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gZG9lcyBub3QgdHJpZ2dlciBhbnkgbWlkZGxld2FyZS5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IHNlc3Npb24gPSBhd2FpdCBQZXJzb24uc3RhcnRTZXNzaW9uKCk7XG4gKiAgICAgbGV0IGRvYyA9IGF3YWl0IFBlcnNvbi5maW5kT25lKHsgbmFtZTogJ05lZCBTdGFyaycgfSwgbnVsbCwgeyBzZXNzaW9uIH0pO1xuICogICAgIGF3YWl0IGRvYy5yZW1vdmUoKTtcbiAqICAgICAvLyBgZG9jYCB3aWxsIGFsd2F5cyBiZSBudWxsLCBldmVuIGlmIHJlYWRpbmcgZnJvbSBhIHJlcGxpY2Egc2V0XG4gKiAgICAgLy8gc2Vjb25kYXJ5LiBXaXRob3V0IGNhdXNhbCBjb25zaXN0ZW5jeSwgaXQgaXMgcG9zc2libGUgdG9cbiAqICAgICAvLyBnZXQgYSBkb2MgYmFjayBmcm9tIHRoZSBiZWxvdyBxdWVyeSBpZiB0aGUgcXVlcnkgcmVhZHMgZnJvbSBhXG4gKiAgICAgLy8gc2Vjb25kYXJ5IHRoYXQgaXMgZXhwZXJpZW5jaW5nIHJlcGxpY2F0aW9uIGxhZy5cbiAqICAgICBkb2MgPSBhd2FpdCBQZXJzb24uZmluZE9uZSh7IG5hbWU6ICdOZWQgU3RhcmsnIH0sIG51bGwsIHsgc2Vzc2lvbiwgcmVhZFByZWZlcmVuY2U6ICdzZWNvbmRhcnknIH0pO1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gc2VlIHRoZSBbbW9uZ29kYiBkcml2ZXIgb3B0aW9uc10oaHR0cHM6Ly9tb25nb2RiLmdpdGh1Yi5pby9ub2RlLW1vbmdvZGItbmF0aXZlLzQuOS9jbGFzc2VzL01vbmdvQ2xpZW50Lmh0bWwjc3RhcnRTZXNzaW9uKVxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5jYXVzYWxDb25zaXN0ZW5jeT10cnVlXSBzZXQgdG8gZmFsc2UgdG8gZGlzYWJsZSBjYXVzYWwgY29uc2lzdGVuY3lcbiAqIEByZXR1cm4ge1Byb21pc2U8Q2xpZW50U2Vzc2lvbj59IHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIE1vbmdvREIgZHJpdmVyIGBDbGllbnRTZXNzaW9uYFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Nb2RlbC5zdGFydFNlc3Npb24gPSBmdW5jdGlvbigpIHtcbiAgX2NoZWNrQ29udGV4dCh0aGlzLCAnc3RhcnRTZXNzaW9uJyk7XG5cbiAgcmV0dXJuIHRoaXMuZGIuc3RhcnRTZXNzaW9uLmFwcGx5KHRoaXMuZGIsIGFyZ3VtZW50cyk7XG59O1xuXG4vKipcbiAqIFNob3J0Y3V0IGZvciB2YWxpZGF0aW5nIGFuIGFycmF5IG9mIGRvY3VtZW50cyBhbmQgaW5zZXJ0aW5nIHRoZW0gaW50b1xuICogTW9uZ29EQiBpZiB0aGV5J3JlIGFsbCB2YWxpZC4gVGhpcyBmdW5jdGlvbiBpcyBmYXN0ZXIgdGhhbiBgLmNyZWF0ZSgpYFxuICogYmVjYXVzZSBpdCBvbmx5IHNlbmRzIG9uZSBvcGVyYXRpb24gdG8gdGhlIHNlcnZlciwgcmF0aGVyIHRoYW4gb25lIGZvciBlYWNoXG4gKiBkb2N1bWVudC5cbiAqXG4gKiBNb25nb29zZSBhbHdheXMgdmFsaWRhdGVzIGVhY2ggZG9jdW1lbnQgKipiZWZvcmUqKiBzZW5kaW5nIGBpbnNlcnRNYW55YFxuICogdG8gTW9uZ29EQi4gU28gaWYgb25lIGRvY3VtZW50IGhhcyBhIHZhbGlkYXRpb24gZXJyb3IsIG5vIGRvY3VtZW50cyB3aWxsXG4gKiBiZSBzYXZlZCwgdW5sZXNzIHlvdSBzZXRcbiAqIFt0aGUgYG9yZGVyZWRgIG9wdGlvbiB0byBmYWxzZV0oaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvcmVmZXJlbmNlL21ldGhvZC9kYi5jb2xsZWN0aW9uLmluc2VydE1hbnkvI2Vycm9yLWhhbmRsaW5nKS5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIGRvZXMgKipub3QqKiB0cmlnZ2VyIHNhdmUgbWlkZGxld2FyZS5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIHRyaWdnZXJzIHRoZSBmb2xsb3dpbmcgbWlkZGxld2FyZS5cbiAqXG4gKiAtIGBpbnNlcnRNYW55KClgXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBhd2FpdCBNb3ZpZXMuaW5zZXJ0TWFueShbXG4gKiAgICAgICB7IG5hbWU6ICdTdGFyIFdhcnMnIH0sXG4gKiAgICAgICB7IG5hbWU6ICdUaGUgRW1waXJlIFN0cmlrZXMgQmFjaycgfVxuICogICAgIF0pO1xuICpcbiAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fCp9IGRvYyhzKVxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBzZWUgdGhlIFttb25nb2RiIGRyaXZlciBvcHRpb25zXShodHRwczovL21vbmdvZGIuZ2l0aHViLmlvL25vZGUtbW9uZ29kYi1uYXRpdmUvNC45L2NsYXNzZXMvQ29sbGVjdGlvbi5odG1sI2luc2VydE1hbnkpXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLm9yZGVyZWQ9dHJ1ZV0gaWYgdHJ1ZSwgd2lsbCBmYWlsIGZhc3Qgb24gdGhlIGZpcnN0IGVycm9yIGVuY291bnRlcmVkLiBJZiBmYWxzZSwgd2lsbCBpbnNlcnQgYWxsIHRoZSBkb2N1bWVudHMgaXQgY2FuIGFuZCByZXBvcnQgZXJyb3JzIGxhdGVyLiBBbiBgaW5zZXJ0TWFueSgpYCB3aXRoIGBvcmRlcmVkID0gZmFsc2VgIGlzIGNhbGxlZCBhbiBcInVub3JkZXJlZFwiIGBpbnNlcnRNYW55KClgLlxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5yYXdSZXN1bHQ9ZmFsc2VdIGlmIGZhbHNlLCB0aGUgcmV0dXJuZWQgcHJvbWlzZSByZXNvbHZlcyB0byB0aGUgZG9jdW1lbnRzIHRoYXQgcGFzc2VkIG1vbmdvb3NlIGRvY3VtZW50IHZhbGlkYXRpb24uIElmIGB0cnVlYCwgd2lsbCByZXR1cm4gdGhlIFtyYXcgcmVzdWx0IGZyb20gdGhlIE1vbmdvREIgZHJpdmVyXShodHRwczovL21vbmdvZGIuZ2l0aHViLmlvL25vZGUtbW9uZ29kYi1uYXRpdmUvNC45L2ludGVyZmFjZXMvSW5zZXJ0TWFueVJlc3VsdC5odG1sKSB3aXRoIGEgYG1vbmdvb3NlYCBwcm9wZXJ0eSB0aGF0IGNvbnRhaW5zIGB2YWxpZGF0aW9uRXJyb3JzYCBhbmQgYHJlc3VsdHNgIGlmIHRoaXMgaXMgYW4gdW5vcmRlcmVkIGBpbnNlcnRNYW55YC5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMubGVhbj1mYWxzZV0gaWYgYHRydWVgLCBza2lwcyBoeWRyYXRpbmcgYW5kIHZhbGlkYXRpbmcgdGhlIGRvY3VtZW50cy4gVGhpcyBvcHRpb24gaXMgdXNlZnVsIGlmIHlvdSBuZWVkIHRoZSBleHRyYSBwZXJmb3JtYW5jZSwgYnV0IE1vbmdvb3NlIHdvbid0IHZhbGlkYXRlIHRoZSBkb2N1bWVudHMgYmVmb3JlIGluc2VydGluZy5cbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5saW1pdD1udWxsXSB0aGlzIGxpbWl0cyB0aGUgbnVtYmVyIG9mIGRvY3VtZW50cyBiZWluZyBwcm9jZXNzZWQgKHZhbGlkYXRpb24vY2FzdGluZykgYnkgbW9uZ29vc2UgaW4gcGFyYWxsZWwsIHRoaXMgZG9lcyAqKk5PVCoqIHNlbmQgdGhlIGRvY3VtZW50cyBpbiBiYXRjaGVzIHRvIE1vbmdvREIuIFVzZSB0aGlzIG9wdGlvbiBpZiB5b3UncmUgcHJvY2Vzc2luZyBhIGxhcmdlIG51bWJlciBvZiBkb2N1bWVudHMgYW5kIHlvdXIgYXBwIGlzIHJ1bm5pbmcgb3V0IG9mIG1lbW9yeS5cbiAqIEBwYXJhbSB7U3RyaW5nfE9iamVjdHxBcnJheX0gW29wdGlvbnMucG9wdWxhdGU9bnVsbF0gcG9wdWxhdGVzIHRoZSByZXN1bHQgZG9jdW1lbnRzLiBUaGlzIG9wdGlvbiBpcyBhIG5vLW9wIGlmIGByYXdSZXN1bHRgIGlzIHNldC5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMudGhyb3dPblZhbGlkYXRpb25FcnJvcj1mYWxzZV0gSWYgdHJ1ZSBhbmQgYG9yZGVyZWQ6IGZhbHNlYCwgdGhyb3cgYW4gZXJyb3IgaWYgb25lIG9mIHRoZSBvcGVyYXRpb25zIGZhaWxlZCB2YWxpZGF0aW9uLCBidXQgYWxsIHZhbGlkIG9wZXJhdGlvbnMgY29tcGxldGVkIHN1Y2Nlc3NmdWxseS5cbiAqIEByZXR1cm4ge1Byb21pc2V9IHJlc29sdmluZyB0byB0aGUgcmF3IHJlc3VsdCBmcm9tIHRoZSBNb25nb0RCIGRyaXZlciBpZiBgb3B0aW9ucy5yYXdSZXN1bHRgIHdhcyBgdHJ1ZWAsIG9yIHRoZSBkb2N1bWVudHMgdGhhdCBwYXNzZWQgdmFsaWRhdGlvbiwgb3RoZXJ3aXNlXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk1vZGVsLmluc2VydE1hbnkgPSBhc3luYyBmdW5jdGlvbiBpbnNlcnRNYW55KGFyciwgb3B0aW9ucykge1xuICBfY2hlY2tDb250ZXh0KHRoaXMsICdpbnNlcnRNYW55Jyk7XG4gIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJyB8fFxuICAgIHR5cGVvZiBhcmd1bWVudHNbMl0gPT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgTW9uZ29vc2VFcnJvcignTW9kZWwuaW5zZXJ0TWFueSgpIG5vIGxvbmdlciBhY2NlcHRzIGEgY2FsbGJhY2snKTtcbiAgfVxuXG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgdGhpcy4kX19pbnNlcnRNYW55KGFyciwgb3B0aW9ucywgKGVyciwgcmVzKSA9PiB7XG4gICAgICBpZiAoZXJyICE9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHJlamVjdChlcnIpO1xuICAgICAgfVxuICAgICAgcmVzb2x2ZShyZXMpO1xuICAgIH0pO1xuICB9KTtcbn07XG5cbi8qKlxuICogaWdub3JlXG4gKlxuICogQHBhcmFtIHtBcnJheX0gYXJyXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAqIEBhcGkgcHJpdmF0ZVxuICogQG1lbWJlck9mIE1vZGVsXG4gKiBAbWV0aG9kICRfX2luc2VydE1hbnlcbiAqIEBzdGF0aWNcbiAqL1xuXG5Nb2RlbC4kX19pbnNlcnRNYW55ID0gZnVuY3Rpb24oYXJyLCBvcHRpb25zLCBjYWxsYmFjaykge1xuICBjb25zdCBfdGhpcyA9IHRoaXM7XG4gIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNhbGxiYWNrID0gb3B0aW9ucztcbiAgICBvcHRpb25zID0gbnVsbDtcbiAgfVxuXG4gIGNhbGxiYWNrID0gY2FsbGJhY2sgfHwgdXRpbHMubm9vcDtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIGNvbnN0IGxpbWl0ID0gb3B0aW9ucy5saW1pdCB8fCAxMDAwO1xuICBjb25zdCByYXdSZXN1bHQgPSAhIW9wdGlvbnMucmF3UmVzdWx0O1xuICBjb25zdCBvcmRlcmVkID0gdHlwZW9mIG9wdGlvbnMub3JkZXJlZCA9PT0gJ2Jvb2xlYW4nID8gb3B0aW9ucy5vcmRlcmVkIDogdHJ1ZTtcbiAgY29uc3QgdGhyb3dPblZhbGlkYXRpb25FcnJvciA9IHR5cGVvZiBvcHRpb25zLnRocm93T25WYWxpZGF0aW9uRXJyb3IgPT09ICdib29sZWFuJyA/IG9wdGlvbnMudGhyb3dPblZhbGlkYXRpb25FcnJvciA6IGZhbHNlO1xuICBjb25zdCBsZWFuID0gISFvcHRpb25zLmxlYW47XG5cbiAgaWYgKCFBcnJheS5pc0FycmF5KGFycikpIHtcbiAgICBhcnIgPSBbYXJyXTtcbiAgfVxuXG4gIGNvbnN0IHZhbGlkYXRpb25FcnJvcnMgPSBbXTtcbiAgY29uc3QgdmFsaWRhdGlvbkVycm9yc1RvT3JpZ2luYWxPcmRlciA9IG5ldyBNYXAoKTtcbiAgY29uc3QgcmVzdWx0cyA9IG9yZGVyZWQgPyBudWxsIDogbmV3IEFycmF5KGFyci5sZW5ndGgpO1xuICBjb25zdCB0b0V4ZWN1dGUgPSBhcnIubWFwKChkb2MsIGluZGV4KSA9PlxuICAgIGNhbGxiYWNrID0+IHtcbiAgICAgIGlmICghKGRvYyBpbnN0YW5jZW9mIF90aGlzKSkge1xuICAgICAgICBpZiAoZG9jICE9IG51bGwgJiYgdHlwZW9mIGRvYyAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICByZXR1cm4gY2FsbGJhY2sobmV3IE9iamVjdFBhcmFtZXRlckVycm9yKGRvYywgJ2Fyci4nICsgaW5kZXgsICdpbnNlcnRNYW55JykpO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZG9jID0gbmV3IF90aGlzKGRvYyk7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAob3B0aW9ucy5zZXNzaW9uICE9IG51bGwpIHtcbiAgICAgICAgZG9jLiRzZXNzaW9uKG9wdGlvbnMuc2Vzc2lvbik7XG4gICAgICB9XG4gICAgICAvLyBJZiBvcHRpb24gYGxlYW5gIGlzIHNldCB0byB0cnVlIGJ5cGFzcyB2YWxpZGF0aW9uXG4gICAgICBpZiAobGVhbikge1xuICAgICAgICAvLyB3ZSBoYXZlIHRvIGV4ZWN1dGUgY2FsbGJhY2sgYXQgdGhlIG5leHRUaWNrIHRvIGJlIGNvbXBhdGlibGVcbiAgICAgICAgLy8gd2l0aCBwYXJhbGxlbExpbWl0LCBhcyBgcmVzdWx0c2AgdmFyaWFibGUgaGFzIFREWiBpc3N1ZSBpZiB3ZVxuICAgICAgICAvLyBleGVjdXRlIHRoZSBjYWxsYmFjayBzeW5jaHJvbm91c2x5XG4gICAgICAgIHJldHVybiBpbW1lZGlhdGUoKCkgPT4gY2FsbGJhY2sobnVsbCwgZG9jKSk7XG4gICAgICB9XG4gICAgICBkb2MuJHZhbGlkYXRlKCkudGhlbihcbiAgICAgICAgKCkgPT4geyBjYWxsYmFjayhudWxsLCBkb2MpOyB9LFxuICAgICAgICBlcnJvciA9PiB7XG4gICAgICAgICAgaWYgKG9yZGVyZWQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICB2YWxpZGF0aW9uRXJyb3JzLnB1c2goZXJyb3IpO1xuICAgICAgICAgICAgdmFsaWRhdGlvbkVycm9yc1RvT3JpZ2luYWxPcmRlci5zZXQoZXJyb3IsIGluZGV4KTtcbiAgICAgICAgICAgIHJlc3VsdHNbaW5kZXhdID0gZXJyb3I7XG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCwgbnVsbCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhbGxiYWNrKGVycm9yKTtcbiAgICAgICAgfVxuICAgICAgKTtcbiAgICB9KTtcblxuICBwYXJhbGxlbExpbWl0KHRvRXhlY3V0ZSwgbGltaXQsIGZ1bmN0aW9uKGVycm9yLCBkb2NzKSB7XG4gICAgaWYgKGVycm9yKSB7XG4gICAgICBjYWxsYmFjayhlcnJvciwgbnVsbCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3Qgb3JpZ2luYWxEb2NJbmRleCA9IG5ldyBNYXAoKTtcbiAgICBjb25zdCB2YWxpZERvY0luZGV4VG9PcmlnaW5hbEluZGV4ID0gbmV3IE1hcCgpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZG9jcy5sZW5ndGg7ICsraSkge1xuICAgICAgb3JpZ2luYWxEb2NJbmRleC5zZXQoZG9jc1tpXSwgaSk7XG4gICAgfVxuXG4gICAgLy8gV2UgZmlsdGVyIGFsbCBmYWlsZWQgcHJlLXZhbGlkYXRpb25zIGJ5IHJlbW92aW5nIG51bGxzXG4gICAgY29uc3QgZG9jQXR0cmlidXRlcyA9IGRvY3MuZmlsdGVyKGZ1bmN0aW9uKGRvYykge1xuICAgICAgcmV0dXJuIGRvYyAhPSBudWxsO1xuICAgIH0pO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZG9jQXR0cmlidXRlcy5sZW5ndGg7ICsraSkge1xuICAgICAgdmFsaWREb2NJbmRleFRvT3JpZ2luYWxJbmRleC5zZXQoaSwgb3JpZ2luYWxEb2NJbmRleC5nZXQoZG9jQXR0cmlidXRlc1tpXSkpO1xuICAgIH1cblxuICAgIC8vIE1ha2Ugc3VyZSB2YWxpZGF0aW9uIGVycm9ycyBhcmUgaW4gdGhlIHNhbWUgb3JkZXIgYXMgdGhlXG4gICAgLy8gb3JpZ2luYWwgZG9jdW1lbnRzLCBzbyBpZiBib3RoIGRvYzEgYW5kIGRvYzIgYm90aCBmYWlsIHZhbGlkYXRpb24sXG4gICAgLy8gYE1vZGVsLmluc2VydE1hbnkoW2RvYzEsIGRvYzJdKWAgd2lsbCBhbHdheXMgaGF2ZSBkb2MxJ3MgdmFsaWRhdGlvblxuICAgIC8vIGVycm9yIGJlZm9yZSBkb2MyJ3MuIFJlOiBnaC0xMjc5MS5cbiAgICBpZiAodmFsaWRhdGlvbkVycm9ycy5sZW5ndGggPiAwKSB7XG4gICAgICB2YWxpZGF0aW9uRXJyb3JzLnNvcnQoKGVycjEsIGVycjIpID0+IHtcbiAgICAgICAgcmV0dXJuIHZhbGlkYXRpb25FcnJvcnNUb09yaWdpbmFsT3JkZXIuZ2V0KGVycjEpIC0gdmFsaWRhdGlvbkVycm9yc1RvT3JpZ2luYWxPcmRlci5nZXQoZXJyMik7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBRdWlja2x5IGVzY2FwZSB3aGlsZSB0aGVyZSBhcmVuJ3QgYW55IHZhbGlkIGRvY0F0dHJpYnV0ZXNcbiAgICBpZiAoZG9jQXR0cmlidXRlcy5sZW5ndGggPT09IDApIHtcbiAgICAgIGlmIChyYXdSZXN1bHQpIHtcbiAgICAgICAgY29uc3QgcmVzID0ge1xuICAgICAgICAgIGFja25vd2xlZGdlZDogdHJ1ZSxcbiAgICAgICAgICBpbnNlcnRlZENvdW50OiAwLFxuICAgICAgICAgIGluc2VydGVkSWRzOiB7fSxcbiAgICAgICAgICBtb25nb29zZToge1xuICAgICAgICAgICAgdmFsaWRhdGlvbkVycm9yczogdmFsaWRhdGlvbkVycm9yc1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsIHJlcyk7XG4gICAgICB9XG4gICAgICBjYWxsYmFjayhudWxsLCBbXSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGRvY09iamVjdHMgPSBkb2NBdHRyaWJ1dGVzLm1hcChmdW5jdGlvbihkb2MpIHtcbiAgICAgIGlmIChkb2MuJF9fc2NoZW1hLm9wdGlvbnMudmVyc2lvbktleSkge1xuICAgICAgICBkb2NbZG9jLiRfX3NjaGVtYS5vcHRpb25zLnZlcnNpb25LZXldID0gMDtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHNob3VsZFNldFRpbWVzdGFtcHMgPSAoIW9wdGlvbnMgfHwgb3B0aW9ucy50aW1lc3RhbXBzICE9PSBmYWxzZSkgJiYgZG9jLmluaXRpYWxpemVUaW1lc3RhbXBzICYmICghZG9jLiRfXyB8fCBkb2MuJF9fLnRpbWVzdGFtcHMgIT09IGZhbHNlKTtcbiAgICAgIGlmIChzaG91bGRTZXRUaW1lc3RhbXBzKSB7XG4gICAgICAgIHJldHVybiBkb2MuaW5pdGlhbGl6ZVRpbWVzdGFtcHMoKS50b09iamVjdChpbnRlcm5hbFRvT2JqZWN0T3B0aW9ucyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZG9jLnRvT2JqZWN0KGludGVybmFsVG9PYmplY3RPcHRpb25zKTtcbiAgICB9KTtcblxuICAgIF90aGlzLiRfX2NvbGxlY3Rpb24uaW5zZXJ0TWFueShkb2NPYmplY3RzLCBvcHRpb25zKS50aGVuKFxuICAgICAgcmVzID0+IHtcbiAgICAgICAgZm9yIChjb25zdCBhdHRyaWJ1dGUgb2YgZG9jQXR0cmlidXRlcykge1xuICAgICAgICAgIGF0dHJpYnV0ZS4kX19yZXNldCgpO1xuICAgICAgICAgIF9zZXRJc05ldyhhdHRyaWJ1dGUsIGZhbHNlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvcmRlcmVkID09PSBmYWxzZSAmJiB0aHJvd09uVmFsaWRhdGlvbkVycm9yICYmIHZhbGlkYXRpb25FcnJvcnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVzdWx0cy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgaWYgKHJlc3VsdHNbaV0gPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICByZXN1bHRzW2ldID0gZG9jc1tpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG5ldyBNb25nb29zZUJ1bGtXcml0ZUVycm9yKFxuICAgICAgICAgICAgdmFsaWRhdGlvbkVycm9ycyxcbiAgICAgICAgICAgIHJlc3VsdHMsXG4gICAgICAgICAgICByZXMsXG4gICAgICAgICAgICAnaW5zZXJ0TWFueSdcbiAgICAgICAgICApKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChyYXdSZXN1bHQpIHtcbiAgICAgICAgICBpZiAob3JkZXJlZCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVzdWx0cy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICBpZiAocmVzdWx0c1tpXSA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0c1tpXSA9IGRvY3NbaV07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gRGVjb3JhdGUgd2l0aCBtb25nb29zZSB2YWxpZGF0aW9uIGVycm9ycyBpbiBjYXNlIG9mIHVub3JkZXJlZCxcbiAgICAgICAgICAgIC8vIGJlY2F1c2UgdGhlbiBzdGlsbCBkbyBgaW5zZXJ0TWFueSgpYFxuICAgICAgICAgICAgcmVzLm1vbmdvb3NlID0ge1xuICAgICAgICAgICAgICB2YWxpZGF0aW9uRXJyb3JzOiB2YWxpZGF0aW9uRXJyb3JzLFxuICAgICAgICAgICAgICByZXN1bHRzOiByZXN1bHRzXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCwgcmVzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvcHRpb25zLnBvcHVsYXRlICE9IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gX3RoaXMucG9wdWxhdGUoZG9jQXR0cmlidXRlcywgb3B0aW9ucy5wb3B1bGF0ZSkudGhlbihcbiAgICAgICAgICAgIGRvY3MgPT4geyBjYWxsYmFjayhudWxsLCBkb2NzKTsgfSxcbiAgICAgICAgICAgIGVyciA9PiB7XG4gICAgICAgICAgICAgIGlmIChlcnIgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGVyci5pbnNlcnRlZERvY3MgPSBkb2NBdHRyaWJ1dGVzO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgY2FsbGJhY2sobnVsbCwgZG9jQXR0cmlidXRlcyk7XG4gICAgICB9LFxuICAgICAgZXJyb3IgPT4ge1xuICAgICAgICAvLyBgd3JpdGVFcnJvcnNgIGlzIGEgcHJvcGVydHkgcmVwb3J0ZWQgYnkgdGhlIE1vbmdvREIgZHJpdmVyLFxuICAgICAgICAvLyBqdXN0IG5vdCBpZiB0aGVyZSdzIG9ubHkgMSBlcnJvci5cbiAgICAgICAgaWYgKGVycm9yLndyaXRlRXJyb3JzID09IG51bGwgJiZcbiAgICAgICAgICAgIChlcnJvci5yZXN1bHQgJiYgZXJyb3IucmVzdWx0LnJlc3VsdCAmJiBlcnJvci5yZXN1bHQucmVzdWx0LndyaXRlRXJyb3JzKSAhPSBudWxsKSB7XG4gICAgICAgICAgZXJyb3Iud3JpdGVFcnJvcnMgPSBlcnJvci5yZXN1bHQucmVzdWx0LndyaXRlRXJyb3JzO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gYGluc2VydGVkRG9jc2AgaXMgYSBNb25nb29zZS1zcGVjaWZpYyBwcm9wZXJ0eVxuICAgICAgICBjb25zdCBoYXNXcml0ZUVycm9ycyA9IGVycm9yICYmIGVycm9yLndyaXRlRXJyb3JzO1xuICAgICAgICBjb25zdCBlcnJvcmVkSW5kZXhlcyA9IG5ldyBTZXQoKGVycm9yICYmIGVycm9yLndyaXRlRXJyb3JzIHx8IFtdKS5tYXAoZXJyID0+IGVyci5pbmRleCkpO1xuXG4gICAgICAgIGlmIChlcnJvci53cml0ZUVycm9ycyAhPSBudWxsKSB7XG4gICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBlcnJvci53cml0ZUVycm9ycy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgY29uc3Qgb3JpZ2luYWxJbmRleCA9IHZhbGlkRG9jSW5kZXhUb09yaWdpbmFsSW5kZXguZ2V0KGVycm9yLndyaXRlRXJyb3JzW2ldLmluZGV4KTtcbiAgICAgICAgICAgIGVycm9yLndyaXRlRXJyb3JzW2ldID0ge1xuICAgICAgICAgICAgICAuLi5lcnJvci53cml0ZUVycm9yc1tpXSxcbiAgICAgICAgICAgICAgaW5kZXg6IG9yaWdpbmFsSW5kZXhcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAoIW9yZGVyZWQpIHtcbiAgICAgICAgICAgICAgcmVzdWx0c1tvcmlnaW5hbEluZGV4XSA9IGVycm9yLndyaXRlRXJyb3JzW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghb3JkZXJlZCkge1xuICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVzdWx0cy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgaWYgKHJlc3VsdHNbaV0gPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICByZXN1bHRzW2ldID0gZG9jc1tpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBlcnJvci5yZXN1bHRzID0gcmVzdWx0cztcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBmaXJzdEVycm9yZWRJbmRleCA9IC0xO1xuICAgICAgICBlcnJvci5pbnNlcnRlZERvY3MgPSBkb2NBdHRyaWJ1dGVzLlxuICAgICAgICAgIGZpbHRlcigoZG9jLCBpKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBpc0Vycm9yZWQgPSAhaGFzV3JpdGVFcnJvcnMgfHwgZXJyb3JlZEluZGV4ZXMuaGFzKGkpO1xuXG4gICAgICAgICAgICBpZiAob3JkZXJlZCkge1xuICAgICAgICAgICAgICBpZiAoZmlyc3RFcnJvcmVkSW5kZXggPiAtMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpIDwgZmlyc3RFcnJvcmVkSW5kZXg7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAoaXNFcnJvcmVkKSB7XG4gICAgICAgICAgICAgICAgZmlyc3RFcnJvcmVkSW5kZXggPSBpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiAhaXNFcnJvcmVkO1xuICAgICAgICAgIH0pLlxuICAgICAgICAgIG1hcChmdW5jdGlvbiBzZXRJc05ld0Zvckluc2VydGVkRG9jKGRvYykge1xuICAgICAgICAgICAgZG9jLiRfX3Jlc2V0KCk7XG4gICAgICAgICAgICBfc2V0SXNOZXcoZG9jLCBmYWxzZSk7XG4gICAgICAgICAgICByZXR1cm4gZG9jO1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChyYXdSZXN1bHQgJiYgb3JkZXJlZCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICBlcnJvci5tb25nb29zZSA9IHtcbiAgICAgICAgICAgIHZhbGlkYXRpb25FcnJvcnM6IHZhbGlkYXRpb25FcnJvcnMsXG4gICAgICAgICAgICByZXN1bHRzOiByZXN1bHRzXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNhbGxiYWNrKGVycm9yLCBudWxsKTtcbiAgICAgIH1cbiAgICApO1xuICB9KTtcbn07XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxuZnVuY3Rpb24gX3NldElzTmV3KGRvYywgdmFsKSB7XG4gIGRvYy4kaXNOZXcgPSB2YWw7XG4gIGRvYy4kZW1pdCgnaXNOZXcnLCB2YWwpO1xuICBkb2MuY29uc3RydWN0b3IuZW1pdCgnaXNOZXcnLCB2YWwpO1xuXG4gIGNvbnN0IHN1YmRvY3MgPSBkb2MuJGdldEFsbFN1YmRvY3MoKTtcbiAgZm9yIChjb25zdCBzdWJkb2Mgb2Ygc3ViZG9jcykge1xuICAgIHN1YmRvYy4kaXNOZXcgPSB2YWw7XG4gICAgc3ViZG9jLiRlbWl0KCdpc05ldycsIHZhbCk7XG4gIH1cbn1cblxuLyoqXG4gKiBTZW5kcyBtdWx0aXBsZSBgaW5zZXJ0T25lYCwgYHVwZGF0ZU9uZWAsIGB1cGRhdGVNYW55YCwgYHJlcGxhY2VPbmVgLFxuICogYGRlbGV0ZU9uZWAsIGFuZC9vciBgZGVsZXRlTWFueWAgb3BlcmF0aW9ucyB0byB0aGUgTW9uZ29EQiBzZXJ2ZXIgaW4gb25lXG4gKiBjb21tYW5kLiBUaGlzIGlzIGZhc3RlciB0aGFuIHNlbmRpbmcgbXVsdGlwbGUgaW5kZXBlbmRlbnQgb3BlcmF0aW9ucyAoZS5nLlxuICogaWYgeW91IHVzZSBgY3JlYXRlKClgKSBiZWNhdXNlIHdpdGggYGJ1bGtXcml0ZSgpYCB0aGVyZSBpcyBvbmx5IG9uZSByb3VuZFxuICogdHJpcCB0byBNb25nb0RCLlxuICpcbiAqIE1vbmdvb3NlIHdpbGwgcGVyZm9ybSBjYXN0aW5nIG9uIGFsbCBvcGVyYXRpb25zIHlvdSBwcm92aWRlLlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gZG9lcyAqKm5vdCoqIHRyaWdnZXIgYW55IG1pZGRsZXdhcmUsIG5laXRoZXIgYHNhdmUoKWAsIG5vciBgdXBkYXRlKClgLlxuICogSWYgeW91IG5lZWQgdG8gdHJpZ2dlclxuICogYHNhdmUoKWAgbWlkZGxld2FyZSBmb3IgZXZlcnkgZG9jdW1lbnQgdXNlIFtgY3JlYXRlKClgXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvYXBpL21vZGVsLmh0bWwjTW9kZWwuY3JlYXRlKCkpIGluc3RlYWQuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBDaGFyYWN0ZXIuYnVsa1dyaXRlKFtcbiAqICAgICAgIHtcbiAqICAgICAgICAgaW5zZXJ0T25lOiB7XG4gKiAgICAgICAgICAgZG9jdW1lbnQ6IHtcbiAqICAgICAgICAgICAgIG5hbWU6ICdFZGRhcmQgU3RhcmsnLFxuICogICAgICAgICAgICAgdGl0bGU6ICdXYXJkZW4gb2YgdGhlIE5vcnRoJ1xuICogICAgICAgICAgIH1cbiAqICAgICAgICAgfVxuICogICAgICAgfSxcbiAqICAgICAgIHtcbiAqICAgICAgICAgdXBkYXRlT25lOiB7XG4gKiAgICAgICAgICAgZmlsdGVyOiB7IG5hbWU6ICdFZGRhcmQgU3RhcmsnIH0sXG4gKiAgICAgICAgICAgLy8gSWYgeW91IHdlcmUgdXNpbmcgdGhlIE1vbmdvREIgZHJpdmVyIGRpcmVjdGx5LCB5b3UnZCBuZWVkIHRvIGRvXG4gKiAgICAgICAgICAgLy8gYHVwZGF0ZTogeyAkc2V0OiB7IHRpdGxlOiAuLi4gfSB9YCBidXQgbW9uZ29vc2UgYWRkcyAkc2V0IGZvclxuICogICAgICAgICAgIC8vIHlvdS5cbiAqICAgICAgICAgICB1cGRhdGU6IHsgdGl0bGU6ICdIYW5kIG9mIHRoZSBLaW5nJyB9XG4gKiAgICAgICAgIH1cbiAqICAgICAgIH0sXG4gKiAgICAgICB7XG4gKiAgICAgICAgIGRlbGV0ZU9uZToge1xuICogICAgICAgICAgIGZpbHRlcjogeyBuYW1lOiAnRWRkYXJkIFN0YXJrJyB9XG4gKiAgICAgICAgIH1cbiAqICAgICAgIH1cbiAqICAgICBdKS50aGVuKHJlcyA9PiB7XG4gKiAgICAgIC8vIFByaW50cyBcIjEgMSAxXCJcbiAqICAgICAgY29uc29sZS5sb2cocmVzLmluc2VydGVkQ291bnQsIHJlcy5tb2RpZmllZENvdW50LCByZXMuZGVsZXRlZENvdW50KTtcbiAqICAgICB9KTtcbiAqXG4gKiBUaGUgW3N1cHBvcnRlZCBvcGVyYXRpb25zXShodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9yZWZlcmVuY2UvbWV0aG9kL2RiLmNvbGxlY3Rpb24uYnVsa1dyaXRlLyNkYi5jb2xsZWN0aW9uLmJ1bGtXcml0ZSkgYXJlOlxuICpcbiAqIC0gYGluc2VydE9uZWBcbiAqIC0gYHVwZGF0ZU9uZWBcbiAqIC0gYHVwZGF0ZU1hbnlgXG4gKiAtIGBkZWxldGVPbmVgXG4gKiAtIGBkZWxldGVNYW55YFxuICogLSBgcmVwbGFjZU9uZWBcbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBvcHNcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3BzLmluc2VydE9uZS5kb2N1bWVudF0gVGhlIGRvY3VtZW50IHRvIGluc2VydFxuICogQHBhcmFtIHtPYmplY3R9IFtvcHMudXBkYXRlT25lLmZpbHRlcl0gVXBkYXRlIHRoZSBmaXJzdCBkb2N1bWVudCB0aGF0IG1hdGNoZXMgdGhpcyBmaWx0ZXJcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3BzLnVwZGF0ZU9uZS51cGRhdGVdIEFuIG9iamVjdCBjb250YWluaW5nIFt1cGRhdGUgb3BlcmF0b3JzXShodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9yZWZlcmVuY2Uvb3BlcmF0b3IvdXBkYXRlLylcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wcy51cGRhdGVPbmUudXBzZXJ0PWZhbHNlXSBJZiB0cnVlLCBpbnNlcnQgYSBkb2MgaWYgbm9uZSBtYXRjaFxuICogQHBhcmFtIHtCb29sZWFufSBbb3BzLnVwZGF0ZU9uZS50aW1lc3RhbXBzPXRydWVdIElmIGZhbHNlLCBkbyBub3QgYXBwbHkgW3RpbWVzdGFtcHNdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9ndWlkZS5odG1sI3RpbWVzdGFtcHMpIHRvIHRoZSBvcGVyYXRpb25cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3BzLnVwZGF0ZU9uZS5jb2xsYXRpb25dIFRoZSBbTW9uZ29EQiBjb2xsYXRpb25dKGh0dHBzOi8vdGhlY29kZWJhcmJhcmlhbi5jb20vYS1ub2RlanMtcGVyc3BlY3RpdmUtb24tbW9uZ29kYi0zNC1jb2xsYXRpb25zKSB0byB1c2VcbiAqIEBwYXJhbSB7QXJyYXl9IFtvcHMudXBkYXRlT25lLmFycmF5RmlsdGVyc10gVGhlIFthcnJheSBmaWx0ZXJzXShodHRwczovL3RoZWNvZGViYXJiYXJpYW4uY29tL2Etbm9kZWpzLXBlcnNwZWN0aXZlLW9uLW1vbmdvZGItMzYtYXJyYXktZmlsdGVycy5odG1sKSB1c2VkIGluIGB1cGRhdGVgXG4gKiBAcGFyYW0ge09iamVjdH0gW29wcy51cGRhdGVNYW55LmZpbHRlcl0gVXBkYXRlIGFsbCB0aGUgZG9jdW1lbnRzIHRoYXQgbWF0Y2ggdGhpcyBmaWx0ZXJcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3BzLnVwZGF0ZU1hbnkudXBkYXRlXSBBbiBvYmplY3QgY29udGFpbmluZyBbdXBkYXRlIG9wZXJhdG9yc10oaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvcmVmZXJlbmNlL29wZXJhdG9yL3VwZGF0ZS8pXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHMudXBkYXRlTWFueS51cHNlcnQ9ZmFsc2VdIElmIHRydWUsIGluc2VydCBhIGRvYyBpZiBubyBkb2N1bWVudHMgbWF0Y2ggYGZpbHRlcmBcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wcy51cGRhdGVNYW55LnRpbWVzdGFtcHM9dHJ1ZV0gSWYgZmFsc2UsIGRvIG5vdCBhcHBseSBbdGltZXN0YW1wc10oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2d1aWRlLmh0bWwjdGltZXN0YW1wcykgdG8gdGhlIG9wZXJhdGlvblxuICogQHBhcmFtIHtPYmplY3R9IFtvcHMudXBkYXRlTWFueS5jb2xsYXRpb25dIFRoZSBbTW9uZ29EQiBjb2xsYXRpb25dKGh0dHBzOi8vdGhlY29kZWJhcmJhcmlhbi5jb20vYS1ub2RlanMtcGVyc3BlY3RpdmUtb24tbW9uZ29kYi0zNC1jb2xsYXRpb25zKSB0byB1c2VcbiAqIEBwYXJhbSB7QXJyYXl9IFtvcHMudXBkYXRlTWFueS5hcnJheUZpbHRlcnNdIFRoZSBbYXJyYXkgZmlsdGVyc10oaHR0cHM6Ly90aGVjb2RlYmFyYmFyaWFuLmNvbS9hLW5vZGVqcy1wZXJzcGVjdGl2ZS1vbi1tb25nb2RiLTM2LWFycmF5LWZpbHRlcnMuaHRtbCkgdXNlZCBpbiBgdXBkYXRlYFxuICogQHBhcmFtIHtPYmplY3R9IFtvcHMuZGVsZXRlT25lLmZpbHRlcl0gRGVsZXRlIHRoZSBmaXJzdCBkb2N1bWVudCB0aGF0IG1hdGNoZXMgdGhpcyBmaWx0ZXJcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3BzLmRlbGV0ZU1hbnkuZmlsdGVyXSBEZWxldGUgYWxsIGRvY3VtZW50cyB0aGF0IG1hdGNoIHRoaXMgZmlsdGVyXG4gKiBAcGFyYW0ge09iamVjdH0gW29wcy5yZXBsYWNlT25lLmZpbHRlcl0gUmVwbGFjZSB0aGUgZmlyc3QgZG9jdW1lbnQgdGhhdCBtYXRjaGVzIHRoaXMgZmlsdGVyXG4gKiBAcGFyYW0ge09iamVjdH0gW29wcy5yZXBsYWNlT25lLnJlcGxhY2VtZW50XSBUaGUgcmVwbGFjZW1lbnQgZG9jdW1lbnRcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wcy5yZXBsYWNlT25lLnVwc2VydD1mYWxzZV0gSWYgdHJ1ZSwgaW5zZXJ0IGEgZG9jIGlmIG5vIGRvY3VtZW50cyBtYXRjaCBgZmlsdGVyYFxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5vcmRlcmVkPXRydWVdIElmIHRydWUsIGV4ZWN1dGUgd3JpdGVzIGluIG9yZGVyIGFuZCBzdG9wIGF0IHRoZSBmaXJzdCBlcnJvci4gSWYgZmFsc2UsIGV4ZWN1dGUgd3JpdGVzIGluIHBhcmFsbGVsIGFuZCBjb250aW51ZSB1bnRpbCBhbGwgd3JpdGVzIGhhdmUgZWl0aGVyIHN1Y2NlZWRlZCBvciBlcnJvcmVkLlxuICogQHBhcmFtIHtDbGllbnRTZXNzaW9ufSBbb3B0aW9ucy5zZXNzaW9uPW51bGxdIFRoZSBzZXNzaW9uIGFzc29jaWF0ZWQgd2l0aCB0aGlzIGJ1bGsgd3JpdGUuIFNlZSBbdHJhbnNhY3Rpb25zIGRvY3NdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy90cmFuc2FjdGlvbnMuaHRtbCkuXG4gKiBAcGFyYW0ge1N0cmluZ3xudW1iZXJ9IFtvcHRpb25zLnc9MV0gVGhlIFt3cml0ZSBjb25jZXJuXShodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9yZWZlcmVuY2Uvd3JpdGUtY29uY2Vybi8pLiBTZWUgW2BRdWVyeSN3KClgXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvYXBpL3F1ZXJ5Lmh0bWwjUXVlcnkucHJvdG90eXBlLncoKSkgZm9yIG1vcmUgaW5mb3JtYXRpb24uXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMud3RpbWVvdXQ9bnVsbF0gVGhlIFt3cml0ZSBjb25jZXJuIHRpbWVvdXRdKGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvbWFudWFsL3JlZmVyZW5jZS93cml0ZS1jb25jZXJuLyN3dGltZW91dCkuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmo9dHJ1ZV0gSWYgZmFsc2UsIGRpc2FibGUgW2pvdXJuYWwgYWNrbm93bGVkZ2VtZW50XShodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9yZWZlcmVuY2Uvd3JpdGUtY29uY2Vybi8jai1vcHRpb24pXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnNraXBWYWxpZGF0aW9uPWZhbHNlXSBTZXQgdG8gdHJ1ZSB0byBza2lwIE1vbmdvb3NlIHNjaGVtYSB2YWxpZGF0aW9uIG9uIGJ1bGsgd3JpdGUgb3BlcmF0aW9ucy4gTW9uZ29vc2UgY3VycmVudGx5IHJ1bnMgdmFsaWRhdGlvbiBvbiBgaW5zZXJ0T25lYCBhbmQgYHJlcGxhY2VPbmVgIG9wZXJhdGlvbnMgYnkgZGVmYXVsdC5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuYnlwYXNzRG9jdW1lbnRWYWxpZGF0aW9uPWZhbHNlXSBJZiB0cnVlLCBkaXNhYmxlIFtNb25nb0RCIHNlcnZlci1zaWRlIHNjaGVtYSB2YWxpZGF0aW9uXShodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9jb3JlL3NjaGVtYS12YWxpZGF0aW9uLykgZm9yIGFsbCB3cml0ZXMgaW4gdGhpcyBidWxrLlxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy50aHJvd09uVmFsaWRhdGlvbkVycm9yPWZhbHNlXSBJZiB0cnVlIGFuZCBgb3JkZXJlZDogZmFsc2VgLCB0aHJvdyBhbiBlcnJvciBpZiBvbmUgb2YgdGhlIG9wZXJhdGlvbnMgZmFpbGVkIHZhbGlkYXRpb24sIGJ1dCBhbGwgdmFsaWQgb3BlcmF0aW9ucyBjb21wbGV0ZWQgc3VjY2Vzc2Z1bGx5LlxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5zdHJpY3Q9bnVsbF0gT3ZlcndyaXRlcyB0aGUgW2BzdHJpY3RgIG9wdGlvbl0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2d1aWRlLmh0bWwjc3RyaWN0KSBvbiBzY2hlbWEuIElmIGZhbHNlLCBhbGxvd3MgZmlsdGVyaW5nIGFuZCB3cml0aW5nIGZpZWxkcyBub3QgZGVmaW5lZCBpbiB0aGUgc2NoZW1hIGZvciBhbGwgd3JpdGVzIGluIHRoaXMgYnVsay5cbiAqIEByZXR1cm4ge1Byb21pc2V9IHJlc29sdmVzIHRvIGEgW2BCdWxrV3JpdGVPcFJlc3VsdGBdKGh0dHBzOi8vbW9uZ29kYi5naXRodWIuaW8vbm9kZS1tb25nb2RiLW5hdGl2ZS80LjkvY2xhc3Nlcy9CdWxrV3JpdGVSZXN1bHQuaHRtbCkgaWYgdGhlIG9wZXJhdGlvbiBzdWNjZWVkc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Nb2RlbC5idWxrV3JpdGUgPSBhc3luYyBmdW5jdGlvbiBidWxrV3JpdGUob3BzLCBvcHRpb25zKSB7XG4gIF9jaGVja0NvbnRleHQodGhpcywgJ2J1bGtXcml0ZScpO1xuXG4gIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJyB8fFxuICAgICAgdHlwZW9mIGFyZ3VtZW50c1syXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBNb25nb29zZUVycm9yKCdNb2RlbC5idWxrV3JpdGUoKSBubyBsb25nZXIgYWNjZXB0cyBhIGNhbGxiYWNrJyk7XG4gIH1cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgY29uc3Qgc2hvdWxkU2tpcCA9IGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICB0aGlzLmhvb2tzLmV4ZWNQcmUoJ2J1bGtXcml0ZScsIHRoaXMsIFtvcHMsIG9wdGlvbnNdLCAoZXJyKSA9PiB7XG4gICAgICBpZiAoZXJyICE9IG51bGwpIHtcbiAgICAgICAgaWYgKGVyciBpbnN0YW5jZW9mIEthcmVlbS5za2lwV3JhcHBlZEZ1bmN0aW9uKSB7XG4gICAgICAgICAgcmV0dXJuIHJlc29sdmUoZXJyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVqZWN0KGVycik7XG4gICAgICB9XG4gICAgICByZXNvbHZlKCk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGlmIChzaG91bGRTa2lwKSB7XG4gICAgcmV0dXJuIHNob3VsZFNraXAuYXJnc1swXTtcbiAgfVxuXG4gIGNvbnN0IG9yZGVyZWQgPSBvcHRpb25zLm9yZGVyZWQgPT0gbnVsbCA/IHRydWUgOiBvcHRpb25zLm9yZGVyZWQ7XG5cbiAgaWYgKG9wcy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gZ2V0RGVmYXVsdEJ1bGt3cml0ZVJlc3VsdCgpO1xuICB9XG5cbiAgY29uc3QgdmFsaWRhdGlvbnMgPSBvcHMubWFwKG9wID0+IGNhc3RCdWxrV3JpdGUodGhpcywgb3AsIG9wdGlvbnMpKTtcblxuICBsZXQgcmVzID0gbnVsbDtcbiAgaWYgKG9yZGVyZWQpIHtcbiAgICBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBlYWNoKHZhbGlkYXRpb25zLCAoZm4sIGNiKSA9PiBmbihjYiksIGVycm9yID0+IHtcbiAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgcmV0dXJuIHJlamVjdChlcnJvcik7XG4gICAgICAgIH1cblxuICAgICAgICByZXNvbHZlKCk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIHRyeSB7XG4gICAgICByZXMgPSBhd2FpdCB0aGlzLiRfX2NvbGxlY3Rpb24uYnVsa1dyaXRlKG9wcywgb3B0aW9ucyk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgY29uc3QgX29wdHMgPSB7IGVycm9yOiBlcnJvciB9O1xuICAgICAgICB0aGlzLmhvb2tzLmV4ZWNQb3N0KCdidWxrV3JpdGUnLCB0aGlzLCBbbnVsbF0sIF9vcHRzLCAoZXJyKSA9PiB7XG4gICAgICAgICAgaWYgKGVyciAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVqZWN0KGVycik7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgbGV0IHJlbWFpbmluZyA9IHZhbGlkYXRpb25zLmxlbmd0aDtcbiAgICBsZXQgdmFsaWRPcHMgPSBbXTtcbiAgICBsZXQgdmFsaWRhdGlvbkVycm9ycyA9IFtdO1xuICAgIGNvbnN0IHJlc3VsdHMgPSBbXTtcbiAgICBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWxpZGF0aW9ucy5sZW5ndGg7ICsraSkge1xuICAgICAgICB2YWxpZGF0aW9uc1tpXSgoZXJyKSA9PiB7XG4gICAgICAgICAgaWYgKGVyciA9PSBudWxsKSB7XG4gICAgICAgICAgICB2YWxpZE9wcy5wdXNoKGkpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YWxpZGF0aW9uRXJyb3JzLnB1c2goeyBpbmRleDogaSwgZXJyb3I6IGVyciB9KTtcbiAgICAgICAgICAgIHJlc3VsdHNbaV0gPSBlcnI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICgtLXJlbWFpbmluZyA8PSAwKSB7XG4gICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHZhbGlkYXRpb25FcnJvcnMgPSB2YWxpZGF0aW9uRXJyb3JzLlxuICAgICAgc29ydCgodjEsIHYyKSA9PiB2MS5pbmRleCAtIHYyLmluZGV4KS5cbiAgICAgIG1hcCh2ID0+IHYuZXJyb3IpO1xuXG4gICAgY29uc3QgdmFsaWRPcEluZGV4ZXMgPSB2YWxpZE9wcztcbiAgICB2YWxpZE9wcyA9IHZhbGlkT3BzLnNvcnQoKS5tYXAoaW5kZXggPT4gb3BzW2luZGV4XSk7XG5cbiAgICBpZiAodmFsaWRPcHMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gZ2V0RGVmYXVsdEJ1bGt3cml0ZVJlc3VsdCgpO1xuICAgIH1cblxuICAgIGxldCBlcnJvcjtcbiAgICBbcmVzLCBlcnJvcl0gPSBhd2FpdCB0aGlzLiRfX2NvbGxlY3Rpb24uYnVsa1dyaXRlKHZhbGlkT3BzLCBvcHRpb25zKS5cbiAgICAgIHRoZW4ocmVzID0+IChbcmVzLCBudWxsXSkpLlxuICAgICAgY2F0Y2goZXJyID0+IChbbnVsbCwgZXJyXSkpO1xuXG4gICAgaWYgKGVycm9yKSB7XG4gICAgICBpZiAodmFsaWRhdGlvbkVycm9ycy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGVycm9yLm1vbmdvb3NlID0gZXJyb3IubW9uZ29vc2UgfHwge307XG4gICAgICAgIGVycm9yLm1vbmdvb3NlLnZhbGlkYXRpb25FcnJvcnMgPSB2YWxpZGF0aW9uRXJyb3JzO1xuICAgICAgfVxuXG4gICAgICBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIGNvbnN0IF9vcHRzID0geyBlcnJvcjogZXJyb3IgfTtcbiAgICAgICAgdGhpcy5ob29rcy5leGVjUG9zdCgnYnVsa1dyaXRlJywgdGhpcywgW251bGxdLCBfb3B0cywgKGVycikgPT4ge1xuICAgICAgICAgIGlmIChlcnIgIT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlamVjdChlcnIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWxpZE9wSW5kZXhlcy5sZW5ndGg7ICsraSkge1xuICAgICAgcmVzdWx0c1t2YWxpZE9wSW5kZXhlc1tpXV0gPSBudWxsO1xuICAgIH1cbiAgICBpZiAodmFsaWRhdGlvbkVycm9ycy5sZW5ndGggPiAwKSB7XG4gICAgICBpZiAob3B0aW9ucy50aHJvd09uVmFsaWRhdGlvbkVycm9yKSB7XG4gICAgICAgIHRocm93IG5ldyBNb25nb29zZUJ1bGtXcml0ZUVycm9yKFxuICAgICAgICAgIHZhbGlkYXRpb25FcnJvcnMsXG4gICAgICAgICAgcmVzdWx0cyxcbiAgICAgICAgICByZXMsXG4gICAgICAgICAgJ2J1bGtXcml0ZSdcbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlcy5tb25nb29zZSA9IHJlcy5tb25nb29zZSB8fCB7fTtcbiAgICAgICAgcmVzLm1vbmdvb3NlLnZhbGlkYXRpb25FcnJvcnMgPSB2YWxpZGF0aW9uRXJyb3JzO1xuICAgICAgICByZXMubW9uZ29vc2UucmVzdWx0cyA9IHJlc3VsdHM7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIHRoaXMuaG9va3MuZXhlY1Bvc3QoJ2J1bGtXcml0ZScsIHRoaXMsIFtyZXNdLCAoZXJyKSA9PiB7XG4gICAgICBpZiAoZXJyICE9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHJlamVjdChlcnIpO1xuICAgICAgfVxuICAgICAgcmVzb2x2ZSgpO1xuICAgIH0pO1xuICB9KTtcblxuICByZXR1cm4gcmVzO1xufTtcblxuLyoqXG4gKiAgdGFrZXMgYW4gYXJyYXkgb2YgZG9jdW1lbnRzLCBnZXRzIHRoZSBjaGFuZ2VzIGFuZCBpbnNlcnRzL3VwZGF0ZXMgZG9jdW1lbnRzIGluIHRoZSBkYXRhYmFzZVxuICogIGFjY29yZGluZyB0byB3aGV0aGVyIG9yIG5vdCB0aGUgZG9jdW1lbnQgaXMgbmV3LCBvciB3aGV0aGVyIGl0IGhhcyBjaGFuZ2VzIG9yIG5vdC5cbiAqXG4gKiBgYnVsa1NhdmVgIHVzZXMgYGJ1bGtXcml0ZWAgdW5kZXIgdGhlIGhvb2QsIHNvIGl0J3MgbW9zdGx5IHVzZWZ1bCB3aGVuIGRlYWxpbmcgd2l0aCBtYW55IGRvY3VtZW50cyAoMTBLKylcbiAqXG4gKiBAcGFyYW0ge0FycmF5PERvY3VtZW50Pn0gZG9jdW1lbnRzXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIG9wdGlvbnMgcGFzc2VkIHRvIHRoZSB1bmRlcmx5aW5nIGBidWxrV3JpdGUoKWBcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMudGltZXN0YW1wc10gZGVmYXVsdHMgdG8gYG51bGxgLCB3aGVuIHNldCB0byBmYWxzZSwgbW9uZ29vc2Ugd2lsbCBub3QgYWRkL3VwZGF0ZSB0aW1lc3RhbXBzIHRvIHRoZSBkb2N1bWVudHMuXG4gKiBAcGFyYW0ge0NsaWVudFNlc3Npb259IFtvcHRpb25zLnNlc3Npb249bnVsbF0gVGhlIHNlc3Npb24gYXNzb2NpYXRlZCB3aXRoIHRoaXMgYnVsayB3cml0ZS4gU2VlIFt0cmFuc2FjdGlvbnMgZG9jc10oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL3RyYW5zYWN0aW9ucy5odG1sKS5cbiAqIEBwYXJhbSB7U3RyaW5nfG51bWJlcn0gW29wdGlvbnMudz0xXSBUaGUgW3dyaXRlIGNvbmNlcm5dKGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvbWFudWFsL3JlZmVyZW5jZS93cml0ZS1jb25jZXJuLykuIFNlZSBbYFF1ZXJ5I3coKWBdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvcXVlcnkuaHRtbCNRdWVyeS5wcm90b3R5cGUudygpKSBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy53dGltZW91dD1udWxsXSBUaGUgW3dyaXRlIGNvbmNlcm4gdGltZW91dF0oaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvcmVmZXJlbmNlL3dyaXRlLWNvbmNlcm4vI3d0aW1lb3V0KS5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuaj10cnVlXSBJZiBmYWxzZSwgZGlzYWJsZSBbam91cm5hbCBhY2tub3dsZWRnZW1lbnRdKGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvbWFudWFsL3JlZmVyZW5jZS93cml0ZS1jb25jZXJuLyNqLW9wdGlvbilcbiAqXG4gKi9cbk1vZGVsLmJ1bGtTYXZlID0gYXN5bmMgZnVuY3Rpb24gYnVsa1NhdmUoZG9jdW1lbnRzLCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIGlmIChvcHRpb25zLnRpbWVzdGFtcHMgIT0gbnVsbCkge1xuICAgIGZvciAoY29uc3QgZG9jdW1lbnQgb2YgZG9jdW1lbnRzKSB7XG4gICAgICBkb2N1bWVudC4kX18uc2F2ZU9wdGlvbnMgPSBkb2N1bWVudC4kX18uc2F2ZU9wdGlvbnMgfHwge307XG4gICAgICBkb2N1bWVudC4kX18uc2F2ZU9wdGlvbnMudGltZXN0YW1wcyA9IG9wdGlvbnMudGltZXN0YW1wcztcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgZm9yIChjb25zdCBkb2N1bWVudCBvZiBkb2N1bWVudHMpIHtcbiAgICAgIGlmIChkb2N1bWVudC4kX18udGltZXN0YW1wcyAhPSBudWxsKSB7XG4gICAgICAgIGRvY3VtZW50LiRfXy5zYXZlT3B0aW9ucyA9IGRvY3VtZW50LiRfXy5zYXZlT3B0aW9ucyB8fCB7fTtcbiAgICAgICAgZG9jdW1lbnQuJF9fLnNhdmVPcHRpb25zLnRpbWVzdGFtcHMgPSBkb2N1bWVudC4kX18udGltZXN0YW1wcztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBhd2FpdCBQcm9taXNlLmFsbChkb2N1bWVudHMubWFwKGJ1aWxkUHJlU2F2ZVByb21pc2UpKTtcblxuICBjb25zdCB3cml0ZU9wZXJhdGlvbnMgPSB0aGlzLmJ1aWxkQnVsa1dyaXRlT3BlcmF0aW9ucyhkb2N1bWVudHMsIHsgc2tpcFZhbGlkYXRpb246IHRydWUsIHRpbWVzdGFtcHM6IG9wdGlvbnMudGltZXN0YW1wcyB9KTtcblxuICBjb25zdCB7IGJ1bGtXcml0ZVJlc3VsdCwgYnVsa1dyaXRlRXJyb3IgfSA9IGF3YWl0IHRoaXMuYnVsa1dyaXRlKHdyaXRlT3BlcmF0aW9ucywgb3B0aW9ucykudGhlbihcbiAgICAocmVzKSA9PiAoeyBidWxrV3JpdGVSZXN1bHQ6IHJlcywgYnVsa1dyaXRlRXJyb3I6IG51bGwgfSksXG4gICAgKGVycikgPT4gKHsgYnVsa1dyaXRlUmVzdWx0OiBudWxsLCBidWxrV3JpdGVFcnJvcjogZXJyIH0pXG4gICk7XG5cbiAgYXdhaXQgUHJvbWlzZS5hbGwoXG4gICAgZG9jdW1lbnRzLm1hcChhc3luYyhkb2N1bWVudCkgPT4ge1xuICAgICAgY29uc3QgZG9jdW1lbnRFcnJvciA9IGJ1bGtXcml0ZUVycm9yICYmIGJ1bGtXcml0ZUVycm9yLndyaXRlRXJyb3JzLmZpbmQod3JpdGVFcnJvciA9PiB7XG4gICAgICAgIGNvbnN0IHdyaXRlRXJyb3JEb2N1bWVudElkID0gd3JpdGVFcnJvci5lcnIub3AuX2lkIHx8IHdyaXRlRXJyb3IuZXJyLm9wLnEuX2lkO1xuICAgICAgICByZXR1cm4gd3JpdGVFcnJvckRvY3VtZW50SWQudG9TdHJpbmcoKSA9PT0gZG9jdW1lbnQuX2lkLnRvU3RyaW5nKCk7XG4gICAgICB9KTtcblxuICAgICAgaWYgKGRvY3VtZW50RXJyb3IgPT0gbnVsbCkge1xuICAgICAgICBhd2FpdCBoYW5kbGVTdWNjZXNzZnVsV3JpdGUoZG9jdW1lbnQpO1xuICAgICAgfVxuICAgIH0pXG4gICk7XG5cbiAgaWYgKGJ1bGtXcml0ZUVycm9yICYmIGJ1bGtXcml0ZUVycm9yLndyaXRlRXJyb3JzICYmIGJ1bGtXcml0ZUVycm9yLndyaXRlRXJyb3JzLmxlbmd0aCkge1xuICAgIHRocm93IGJ1bGtXcml0ZUVycm9yO1xuICB9XG5cbiAgcmV0dXJuIGJ1bGtXcml0ZVJlc3VsdDtcbn07XG5cbmZ1bmN0aW9uIGJ1aWxkUHJlU2F2ZVByb21pc2UoZG9jdW1lbnQpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBkb2N1bWVudC5zY2hlbWEucy5ob29rcy5leGVjUHJlKCdzYXZlJywgZG9jdW1lbnQsIChlcnIpID0+IHtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHJlc29sdmUoKTtcbiAgICB9KTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGhhbmRsZVN1Y2Nlc3NmdWxXcml0ZShkb2N1bWVudCkge1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIGlmIChkb2N1bWVudC4kaXNOZXcpIHtcbiAgICAgIF9zZXRJc05ldyhkb2N1bWVudCwgZmFsc2UpO1xuICAgIH1cblxuICAgIGRvY3VtZW50LiRfX3Jlc2V0KCk7XG4gICAgZG9jdW1lbnQuc2NoZW1hLnMuaG9va3MuZXhlY1Bvc3QoJ3NhdmUnLCBkb2N1bWVudCwgW2RvY3VtZW50XSwge30sIChlcnIpID0+IHtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHJlc29sdmUoKTtcbiAgICB9KTtcblxuICB9KTtcbn1cblxuLyoqXG4gKiBBcHBseSBkZWZhdWx0cyB0byB0aGUgZ2l2ZW4gZG9jdW1lbnQgb3IgUE9KTy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdHxEb2N1bWVudH0gb2JqIG9iamVjdCBvciBkb2N1bWVudCB0byBhcHBseSBkZWZhdWx0cyBvblxuICogQHJldHVybnMge09iamVjdHxEb2N1bWVudH1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuTW9kZWwuYXBwbHlEZWZhdWx0cyA9IGZ1bmN0aW9uIGFwcGx5RGVmYXVsdHMoZG9jKSB7XG4gIGlmIChkb2MuJF9fICE9IG51bGwpIHtcbiAgICBhcHBseURlZmF1bHRzSGVscGVyKGRvYywgZG9jLiRfXy5maWVsZHMsIGRvYy4kX18uZXhjbHVkZSk7XG5cbiAgICBmb3IgKGNvbnN0IHN1YmRvYyBvZiBkb2MuJGdldEFsbFN1YmRvY3MoKSkge1xuICAgICAgYXBwbHlEZWZhdWx0cyhzdWJkb2MsIHN1YmRvYy4kX18uZmllbGRzLCBzdWJkb2MuJF9fLmV4Y2x1ZGUpO1xuICAgIH1cblxuICAgIHJldHVybiBkb2M7XG4gIH1cblxuICBhcHBseURlZmF1bHRzVG9QT0pPKGRvYywgdGhpcy5zY2hlbWEpO1xuXG4gIHJldHVybiBkb2M7XG59O1xuXG4vKipcbiAqIENhc3QgdGhlIGdpdmVuIFBPSk8gdG8gdGhlIG1vZGVsJ3Mgc2NoZW1hXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBjb25zdCBUZXN0ID0gbW9uZ29vc2UubW9kZWwoJ1Rlc3QnLCBTY2hlbWEoeyBudW06IE51bWJlciB9KSk7XG4gKlxuICogICAgIGNvbnN0IG9iaiA9IFRlc3QuY2FzdE9iamVjdCh7IG51bTogJzQyJyB9KTtcbiAqICAgICBvYmoubnVtOyAvLyA0MiBhcyBhIG51bWJlclxuICpcbiAqICAgICBUZXN0LmNhc3RPYmplY3QoeyBudW06ICdub3QgYSBudW1iZXInIH0pOyAvLyBUaHJvd3MgYSBWYWxpZGF0aW9uRXJyb3JcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqIG9iamVjdCBvciBkb2N1bWVudCB0byBjYXN0XG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBvcHRpb25zIHBhc3NlZCB0byBjYXN0T2JqZWN0XG4gKiBAcGFyYW0ge0Jvb2xlYW59IG9wdGlvbnMuaWdub3JlQ2FzdEVycm9ycyBJZiBzZXQgdG8gYHRydWVgIHdpbGwgbm90IHRocm93IGEgVmFsaWRhdGlvbkVycm9yIGFuZCBvbmx5IHJldHVybiB2YWx1ZXMgdGhhdCB3ZXJlIHN1Y2Nlc3NmdWxseSBjYXN0LlxuICogQHJldHVybnMge09iamVjdH0gUE9KTyBjYXN0ZWQgdG8gdGhlIG1vZGVsJ3Mgc2NoZW1hXG4gKiBAdGhyb3dzIHtWYWxpZGF0aW9uRXJyb3J9IGlmIGNhc3RpbmcgZmFpbGVkIGZvciBhdCBsZWFzdCBvbmUgcGF0aFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Nb2RlbC5jYXN0T2JqZWN0ID0gZnVuY3Rpb24gY2FzdE9iamVjdChvYmosIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIGNvbnN0IHJldCA9IHt9O1xuXG4gIGNvbnN0IHNjaGVtYSA9IHRoaXMuc2NoZW1hO1xuICBjb25zdCBwYXRocyA9IE9iamVjdC5rZXlzKHNjaGVtYS5wYXRocyk7XG5cbiAgZm9yIChjb25zdCBwYXRoIG9mIHBhdGhzKSB7XG4gICAgY29uc3Qgc2NoZW1hVHlwZSA9IHNjaGVtYS5wYXRoKHBhdGgpO1xuICAgIGlmICghc2NoZW1hVHlwZSB8fCAhc2NoZW1hVHlwZS4kaXNNb25nb29zZUFycmF5KSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBjb25zdCB2YWwgPSBnZXQob2JqLCBwYXRoKTtcbiAgICBwdXNoTmVzdGVkQXJyYXlQYXRocyhwYXRocywgdmFsLCBwYXRoKTtcbiAgfVxuXG4gIGxldCBlcnJvciA9IG51bGw7XG5cbiAgZm9yIChjb25zdCBwYXRoIG9mIHBhdGhzKSB7XG4gICAgY29uc3Qgc2NoZW1hVHlwZSA9IHNjaGVtYS5wYXRoKHBhdGgpO1xuICAgIGlmIChzY2hlbWFUeXBlID09IG51bGwpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGxldCB2YWwgPSBnZXQob2JqLCBwYXRoLCB2b2lkIDApO1xuXG4gICAgaWYgKHZhbCA9PSBudWxsKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBjb25zdCBwaWVjZXMgPSBwYXRoLmluZGV4T2YoJy4nKSA9PT0gLTEgPyBbcGF0aF0gOiBwYXRoLnNwbGl0KCcuJyk7XG4gICAgbGV0IGN1ciA9IHJldDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBpZWNlcy5sZW5ndGggLSAxOyArK2kpIHtcbiAgICAgIGlmIChjdXJbcGllY2VzW2ldXSA9PSBudWxsKSB7XG4gICAgICAgIGN1cltwaWVjZXNbaV1dID0gaXNOYU4ocGllY2VzW2kgKyAxXSkgPyB7fSA6IFtdO1xuICAgICAgfVxuICAgICAgY3VyID0gY3VyW3BpZWNlc1tpXV07XG4gICAgfVxuXG4gICAgaWYgKHNjaGVtYVR5cGUuJGlzTW9uZ29vc2VEb2N1bWVudEFycmF5KSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKHNjaGVtYVR5cGUuJGlzU2luZ2xlTmVzdGVkIHx8IHNjaGVtYVR5cGUuJGlzTW9uZ29vc2VEb2N1bWVudEFycmF5RWxlbWVudCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmFsID0gTW9kZWwuY2FzdE9iamVjdC5jYWxsKHNjaGVtYVR5cGUuY2FzdGVyLCB2YWwpO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGlmICghb3B0aW9ucy5pZ25vcmVDYXN0RXJyb3JzKSB7XG4gICAgICAgICAgZXJyb3IgPSBlcnJvciB8fCBuZXcgVmFsaWRhdGlvbkVycm9yKCk7XG4gICAgICAgICAgZXJyb3IuYWRkRXJyb3IocGF0aCwgZXJyKTtcbiAgICAgICAgfVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgY3VyW3BpZWNlc1twaWVjZXMubGVuZ3RoIC0gMV1dID0gdmFsO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIHZhbCA9IHNjaGVtYVR5cGUuY2FzdCh2YWwpO1xuICAgICAgY3VyW3BpZWNlc1twaWVjZXMubGVuZ3RoIC0gMV1dID0gdmFsO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgaWYgKCFvcHRpb25zLmlnbm9yZUNhc3RFcnJvcnMpIHtcbiAgICAgICAgZXJyb3IgPSBlcnJvciB8fCBuZXcgVmFsaWRhdGlvbkVycm9yKCk7XG4gICAgICAgIGVycm9yLmFkZEVycm9yKHBhdGgsIGVycik7XG4gICAgICB9XG5cbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgfVxuXG4gIGlmIChlcnJvciAhPSBudWxsKSB7XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cblxuICByZXR1cm4gcmV0O1xufTtcblxuLyoqXG4gKiBCdWlsZCBidWxrIHdyaXRlIG9wZXJhdGlvbnMgZm9yIGBidWxrU2F2ZSgpYC5cbiAqXG4gKiBAcGFyYW0ge0FycmF5PERvY3VtZW50Pn0gZG9jdW1lbnRzIFRoZSBhcnJheSBvZiBkb2N1bWVudHMgdG8gYnVpbGQgd3JpdGUgb3BlcmF0aW9ucyBvZlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gb3B0aW9ucy5za2lwVmFsaWRhdGlvbiBkZWZhdWx0cyB0byBgZmFsc2VgLCB3aGVuIHNldCB0byB0cnVlLCBidWlsZGluZyB0aGUgd3JpdGUgb3BlcmF0aW9ucyB3aWxsIGJ5cGFzcyB2YWxpZGF0aW5nIHRoZSBkb2N1bWVudHMuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IG9wdGlvbnMudGltZXN0YW1wcyBkZWZhdWx0cyB0byBgbnVsbGAsIHdoZW4gc2V0IHRvIGZhbHNlLCBtb25nb29zZSB3aWxsIG5vdCBhZGQvdXBkYXRlIHRpbWVzdGFtcHMgdG8gdGhlIGRvY3VtZW50cy5cbiAqIEByZXR1cm4ge0FycmF5PFByb21pc2U+fSBSZXR1cm5zIGEgYXJyYXkgb2YgYWxsIFByb21pc2VzIHRoZSBmdW5jdGlvbiBleGVjdXRlcyB0byBiZSBhd2FpdGVkLlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuTW9kZWwuYnVpbGRCdWxrV3JpdGVPcGVyYXRpb25zID0gZnVuY3Rpb24gYnVpbGRCdWxrV3JpdGVPcGVyYXRpb25zKGRvY3VtZW50cywgb3B0aW9ucykge1xuICBpZiAoIUFycmF5LmlzQXJyYXkoZG9jdW1lbnRzKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgYnVsa1NhdmUgZXhwZWN0cyBhbiBhcnJheSBvZiBkb2N1bWVudHMgdG8gYmUgcGFzc2VkLCByZWNlaXZlZCBcXGAke2RvY3VtZW50c31cXGAgaW5zdGVhZGApO1xuICB9XG5cbiAgc2V0RGVmYXVsdE9wdGlvbnMoKTtcbiAgY29uc3QgZGlzY3JpbWluYXRvcktleSA9IHRoaXMuc2NoZW1hLm9wdGlvbnMuZGlzY3JpbWluYXRvcktleTtcblxuICBjb25zdCB3cml0ZU9wZXJhdGlvbnMgPSBkb2N1bWVudHMucmVkdWNlKChhY2N1bXVsYXRvciwgZG9jdW1lbnQsIGkpID0+IHtcbiAgICBpZiAoIW9wdGlvbnMuc2tpcFZhbGlkYXRpb24pIHtcbiAgICAgIGlmICghKGRvY3VtZW50IGluc3RhbmNlb2YgRG9jdW1lbnQpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgZG9jdW1lbnRzLiR7aX0gd2FzIG5vdCBhIG1vbmdvb3NlIGRvY3VtZW50LCBkb2N1bWVudHMgbXVzdCBiZSBhbiBhcnJheSBvZiBtb25nb29zZSBkb2N1bWVudHMgKGluc3RhbmNlb2YgbW9uZ29vc2UuRG9jdW1lbnQpLmApO1xuICAgICAgfVxuICAgICAgY29uc3QgdmFsaWRhdGlvbkVycm9yID0gZG9jdW1lbnQudmFsaWRhdGVTeW5jKCk7XG4gICAgICBpZiAodmFsaWRhdGlvbkVycm9yKSB7XG4gICAgICAgIHRocm93IHZhbGlkYXRpb25FcnJvcjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBpc0FOZXdEb2N1bWVudCA9IGRvY3VtZW50LmlzTmV3O1xuICAgIGlmIChpc0FOZXdEb2N1bWVudCkge1xuICAgICAgY29uc3Qgd3JpdGVPcGVyYXRpb24gPSB7IGluc2VydE9uZTogeyBkb2N1bWVudCB9IH07XG4gICAgICB1dGlscy5pbmplY3RUaW1lc3RhbXBzT3B0aW9uKHdyaXRlT3BlcmF0aW9uLmluc2VydE9uZSwgb3B0aW9ucy50aW1lc3RhbXBzKTtcbiAgICAgIGFjY3VtdWxhdG9yLnB1c2god3JpdGVPcGVyYXRpb24pO1xuXG4gICAgICByZXR1cm4gYWNjdW11bGF0b3I7XG4gICAgfVxuXG4gICAgY29uc3QgZGVsdGEgPSBkb2N1bWVudC4kX19kZWx0YSgpO1xuICAgIGNvbnN0IGlzRG9jdW1lbnRXaXRoQ2hhbmdlcyA9IGRlbHRhICE9IG51bGwgJiYgIXV0aWxzLmlzRW1wdHlPYmplY3QoZGVsdGFbMF0pO1xuXG4gICAgaWYgKGlzRG9jdW1lbnRXaXRoQ2hhbmdlcykge1xuICAgICAgY29uc3Qgd2hlcmUgPSBkb2N1bWVudC4kX193aGVyZShkZWx0YVswXSk7XG4gICAgICBjb25zdCBjaGFuZ2VzID0gZGVsdGFbMV07XG5cbiAgICAgIF9hcHBseUN1c3RvbVdoZXJlKGRvY3VtZW50LCB3aGVyZSk7XG5cbiAgICAgIC8vIFNldCB0aGUgZGlzY3JpbWluYXRvciBrZXksIHNvIGJ1bGsgd3JpdGUgY2FzdGluZyBrbm93cyB3aGljaFxuICAgICAgLy8gc2NoZW1hIHRvIHVzZSByZTogZ2gtMTM5MDdcbiAgICAgIGlmIChkb2N1bWVudFtkaXNjcmltaW5hdG9yS2V5XSAhPSBudWxsICYmICEoZGlzY3JpbWluYXRvcktleSBpbiB3aGVyZSkpIHtcbiAgICAgICAgd2hlcmVbZGlzY3JpbWluYXRvcktleV0gPSBkb2N1bWVudFtkaXNjcmltaW5hdG9yS2V5XTtcbiAgICAgIH1cblxuICAgICAgZG9jdW1lbnQuJF9fdmVyc2lvbih3aGVyZSwgZGVsdGEpO1xuICAgICAgY29uc3Qgd3JpdGVPcGVyYXRpb24gPSB7IHVwZGF0ZU9uZTogeyBmaWx0ZXI6IHdoZXJlLCB1cGRhdGU6IGNoYW5nZXMgfSB9O1xuICAgICAgdXRpbHMuaW5qZWN0VGltZXN0YW1wc09wdGlvbih3cml0ZU9wZXJhdGlvbi51cGRhdGVPbmUsIG9wdGlvbnMudGltZXN0YW1wcyk7XG4gICAgICBhY2N1bXVsYXRvci5wdXNoKHdyaXRlT3BlcmF0aW9uKTtcblxuICAgICAgcmV0dXJuIGFjY3VtdWxhdG9yO1xuICAgIH1cblxuICAgIHJldHVybiBhY2N1bXVsYXRvcjtcbiAgfSwgW10pO1xuXG4gIHJldHVybiB3cml0ZU9wZXJhdGlvbnM7XG5cblxuICBmdW5jdGlvbiBzZXREZWZhdWx0T3B0aW9ucygpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBpZiAob3B0aW9ucy5za2lwVmFsaWRhdGlvbiA9PSBudWxsKSB7XG4gICAgICBvcHRpb25zLnNraXBWYWxpZGF0aW9uID0gZmFsc2U7XG4gICAgfVxuICB9XG59O1xuXG5cbi8qKlxuICogU2hvcnRjdXQgZm9yIGNyZWF0aW5nIGEgbmV3IERvY3VtZW50IGZyb20gZXhpc3RpbmcgcmF3IGRhdGEsIHByZS1zYXZlZCBpbiB0aGUgREIuXG4gKiBUaGUgZG9jdW1lbnQgcmV0dXJuZWQgaGFzIG5vIHBhdGhzIG1hcmtlZCBhcyBtb2RpZmllZCBpbml0aWFsbHkuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICAvLyBoeWRyYXRlIHByZXZpb3VzIGRhdGEgaW50byBhIE1vbmdvb3NlIGRvY3VtZW50XG4gKiAgICAgY29uc3QgbW9uZ29vc2VDYW5keSA9IENhbmR5Lmh5ZHJhdGUoeyBfaWQ6ICc1NDEwODMzNzIxMmZmYjZkNDU5Zjg1NGMnLCB0eXBlOiAnamVsbHkgYmVhbicgfSk7XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9ialxuICogQHBhcmFtIHtPYmplY3R8U3RyaW5nfFN0cmluZ1tdfSBbcHJvamVjdGlvbl0gb3B0aW9uYWwgcHJvamVjdGlvbiBjb250YWluaW5nIHdoaWNoIGZpZWxkcyBzaG91bGQgYmUgc2VsZWN0ZWQgZm9yIHRoaXMgZG9jdW1lbnRcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gb3B0aW9uYWwgb3B0aW9uc1xuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5zZXR0ZXJzPWZhbHNlXSBpZiB0cnVlLCBhcHBseSBzY2hlbWEgc2V0dGVycyB3aGVuIGh5ZHJhdGluZ1xuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5oeWRyYXRlZFBvcHVsYXRlZERvY3M9ZmFsc2VdIGlmIHRydWUsIHBvcHVsYXRlcyB0aGUgZG9jcyBpZiBwYXNzaW5nIHByZS1wb3B1bGF0ZWQgZGF0YVxuICogQHJldHVybiB7RG9jdW1lbnR9IGRvY3VtZW50IGluc3RhbmNlXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk1vZGVsLmh5ZHJhdGUgPSBmdW5jdGlvbihvYmosIHByb2plY3Rpb24sIG9wdGlvbnMpIHtcbiAgX2NoZWNrQ29udGV4dCh0aGlzLCAnaHlkcmF0ZScpO1xuXG4gIGlmIChwcm9qZWN0aW9uICE9IG51bGwpIHtcbiAgICBpZiAob2JqICE9IG51bGwgJiYgb2JqLiRfXyAhPSBudWxsKSB7XG4gICAgICBvYmogPSBvYmoudG9PYmplY3QoaW50ZXJuYWxUb09iamVjdE9wdGlvbnMpO1xuICAgIH1cbiAgICBvYmogPSBhcHBseVByb2plY3Rpb24ob2JqLCBwcm9qZWN0aW9uKTtcbiAgfVxuICBjb25zdCBkb2N1bWVudCA9IHJlcXVpcmUoJy4vcXVlcnlIZWxwZXJzJykuY3JlYXRlTW9kZWwodGhpcywgb2JqLCBwcm9qZWN0aW9uKTtcbiAgZG9jdW1lbnQuJGluaXQob2JqLCBvcHRpb25zKTtcbiAgcmV0dXJuIGRvY3VtZW50O1xufTtcblxuLyoqXG4gKiBTYW1lIGFzIGB1cGRhdGVPbmUoKWAsIGV4Y2VwdCBNb25nb0RCIHdpbGwgdXBkYXRlIF9hbGxfIGRvY3VtZW50cyB0aGF0IG1hdGNoXG4gKiBgZmlsdGVyYCAoYXMgb3Bwb3NlZCB0byBqdXN0IHRoZSBmaXJzdCBvbmUpIHJlZ2FyZGxlc3Mgb2YgdGhlIHZhbHVlIG9mXG4gKiB0aGUgYG11bHRpYCBvcHRpb24uXG4gKlxuICogKipOb3RlKiogdXBkYXRlTWFueSB3aWxsIF9ub3RfIGZpcmUgdXBkYXRlIG1pZGRsZXdhcmUuIFVzZSBgcHJlKCd1cGRhdGVNYW55JylgXG4gKiBhbmQgYHBvc3QoJ3VwZGF0ZU1hbnknKWAgaW5zdGVhZC5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IHJlcyA9IGF3YWl0IFBlcnNvbi51cGRhdGVNYW55KHsgbmFtZTogL1N0YXJrJC8gfSwgeyBpc0RlbGV0ZWQ6IHRydWUgfSk7XG4gKiAgICAgcmVzLm1hdGNoZWRDb3VudDsgLy8gTnVtYmVyIG9mIGRvY3VtZW50cyBtYXRjaGVkXG4gKiAgICAgcmVzLm1vZGlmaWVkQ291bnQ7IC8vIE51bWJlciBvZiBkb2N1bWVudHMgbW9kaWZpZWRcbiAqICAgICByZXMuYWNrbm93bGVkZ2VkOyAvLyBCb29sZWFuIGluZGljYXRpbmcgZXZlcnl0aGluZyB3ZW50IHNtb290aGx5LlxuICogICAgIHJlcy51cHNlcnRlZElkOyAvLyBudWxsIG9yIGFuIGlkIGNvbnRhaW5pbmcgYSBkb2N1bWVudCB0aGF0IGhhZCB0byBiZSB1cHNlcnRlZC5cbiAqICAgICByZXMudXBzZXJ0ZWRDb3VudDsgLy8gTnVtYmVyIGluZGljYXRpbmcgaG93IG1hbnkgZG9jdW1lbnRzIGhhZCB0byBiZSB1cHNlcnRlZC4gV2lsbCBlaXRoZXIgYmUgMCBvciAxLlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gdHJpZ2dlcnMgdGhlIGZvbGxvd2luZyBtaWRkbGV3YXJlLlxuICpcbiAqIC0gYHVwZGF0ZU1hbnkoKWBcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gZmlsdGVyXG4gKiBAcGFyYW0ge09iamVjdHxBcnJheX0gdXBkYXRlXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIG9wdGlvbmFsIHNlZSBbYFF1ZXJ5LnByb3RvdHlwZS5zZXRPcHRpb25zKClgXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvYXBpL3F1ZXJ5Lmh0bWwjUXVlcnkucHJvdG90eXBlLnNldE9wdGlvbnMoKSlcbiAqIEBwYXJhbSB7Qm9vbGVhbnxTdHJpbmd9IFtvcHRpb25zLnN0cmljdF0gb3ZlcndyaXRlcyB0aGUgc2NoZW1hJ3MgW3N0cmljdCBtb2RlIG9wdGlvbl0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2d1aWRlLmh0bWwjc3RyaWN0KVxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy51cHNlcnQ9ZmFsc2VdIGlmIHRydWUsIGFuZCBubyBkb2N1bWVudHMgZm91bmQsIGluc2VydCBhIG5ldyBkb2N1bWVudFxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLndyaXRlQ29uY2Vybj1udWxsXSBzZXRzIHRoZSBbd3JpdGUgY29uY2Vybl0oaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvcmVmZXJlbmNlL3dyaXRlLWNvbmNlcm4vKSBmb3IgcmVwbGljYSBzZXRzLiBPdmVycmlkZXMgdGhlIFtzY2hlbWEtbGV2ZWwgd3JpdGUgY29uY2Vybl0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2d1aWRlLmh0bWwjd3JpdGVDb25jZXJuKVxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy50aW1lc3RhbXBzPW51bGxdIElmIHNldCB0byBgZmFsc2VgIGFuZCBbc2NoZW1hLWxldmVsIHRpbWVzdGFtcHNdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9ndWlkZS5odG1sI3RpbWVzdGFtcHMpIGFyZSBlbmFibGVkLCBza2lwIHRpbWVzdGFtcHMgZm9yIHRoaXMgdXBkYXRlLiBEb2VzIG5vdGhpbmcgaWYgc2NoZW1hLWxldmVsIHRpbWVzdGFtcHMgYXJlIG5vdCBzZXQuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnRyYW5zbGF0ZUFsaWFzZXM9bnVsbF0gSWYgc2V0IHRvIGB0cnVlYCwgdHJhbnNsYXRlcyBhbnkgc2NoZW1hLWRlZmluZWQgYWxpYXNlcyBpbiBgZmlsdGVyYCwgYHByb2plY3Rpb25gLCBgdXBkYXRlYCwgYW5kIGBkaXN0aW5jdGAuIFRocm93cyBhbiBlcnJvciBpZiB0aGVyZSBhcmUgYW55IGNvbmZsaWN0cyB3aGVyZSBib3RoIGFsaWFzIGFuZCByYXcgcHJvcGVydHkgYXJlIGRlZmluZWQgb24gdGhlIHNhbWUgb2JqZWN0LlxuICogQHJldHVybiB7UXVlcnl9XG4gKiBAc2VlIFF1ZXJ5IGRvY3MgaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL3F1ZXJpZXMuaHRtbFxuICogQHNlZSBNb25nb0RCIGRvY3MgaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvcmVmZXJlbmNlL2NvbW1hbmQvdXBkYXRlLyN1cGRhdGUtY29tbWFuZC1vdXRwdXRcbiAqIEBzZWUgVXBkYXRlUmVzdWx0IGh0dHBzOi8vbW9uZ29kYi5naXRodWIuaW8vbm9kZS1tb25nb2RiLW5hdGl2ZS80LjkvaW50ZXJmYWNlcy9VcGRhdGVSZXN1bHQuaHRtbFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Nb2RlbC51cGRhdGVNYW55ID0gZnVuY3Rpb24gdXBkYXRlTWFueShjb25kaXRpb25zLCBkb2MsIG9wdGlvbnMpIHtcbiAgX2NoZWNrQ29udGV4dCh0aGlzLCAndXBkYXRlTWFueScpO1xuXG4gIHJldHVybiBfdXBkYXRlKHRoaXMsICd1cGRhdGVNYW55JywgY29uZGl0aW9ucywgZG9jLCBvcHRpb25zKTtcbn07XG5cbi8qKlxuICogVXBkYXRlIF9vbmx5XyB0aGUgZmlyc3QgZG9jdW1lbnQgdGhhdCBtYXRjaGVzIGBmaWx0ZXJgLlxuICpcbiAqIC0gVXNlIGByZXBsYWNlT25lKClgIGlmIHlvdSB3YW50IHRvIG92ZXJ3cml0ZSBhbiBlbnRpcmUgZG9jdW1lbnQgcmF0aGVyIHRoYW4gdXNpbmcgYXRvbWljIG9wZXJhdG9ycyBsaWtlIGAkc2V0YC5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IHJlcyA9IGF3YWl0IFBlcnNvbi51cGRhdGVPbmUoeyBuYW1lOiAnSmVhbi1MdWMgUGljYXJkJyB9LCB7IHNoaXA6ICdVU1MgRW50ZXJwcmlzZScgfSk7XG4gKiAgICAgcmVzLm1hdGNoZWRDb3VudDsgLy8gTnVtYmVyIG9mIGRvY3VtZW50cyBtYXRjaGVkXG4gKiAgICAgcmVzLm1vZGlmaWVkQ291bnQ7IC8vIE51bWJlciBvZiBkb2N1bWVudHMgbW9kaWZpZWRcbiAqICAgICByZXMuYWNrbm93bGVkZ2VkOyAvLyBCb29sZWFuIGluZGljYXRpbmcgZXZlcnl0aGluZyB3ZW50IHNtb290aGx5LlxuICogICAgIHJlcy51cHNlcnRlZElkOyAvLyBudWxsIG9yIGFuIGlkIGNvbnRhaW5pbmcgYSBkb2N1bWVudCB0aGF0IGhhZCB0byBiZSB1cHNlcnRlZC5cbiAqICAgICByZXMudXBzZXJ0ZWRDb3VudDsgLy8gTnVtYmVyIGluZGljYXRpbmcgaG93IG1hbnkgZG9jdW1lbnRzIGhhZCB0byBiZSB1cHNlcnRlZC4gV2lsbCBlaXRoZXIgYmUgMCBvciAxLlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gdHJpZ2dlcnMgdGhlIGZvbGxvd2luZyBtaWRkbGV3YXJlLlxuICpcbiAqIC0gYHVwZGF0ZU9uZSgpYFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBmaWx0ZXJcbiAqIEBwYXJhbSB7T2JqZWN0fEFycmF5fSB1cGRhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gb3B0aW9uYWwgc2VlIFtgUXVlcnkucHJvdG90eXBlLnNldE9wdGlvbnMoKWBdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvcXVlcnkuaHRtbCNRdWVyeS5wcm90b3R5cGUuc2V0T3B0aW9ucygpKVxuICogQHBhcmFtIHtCb29sZWFufFN0cmluZ30gW29wdGlvbnMuc3RyaWN0XSBvdmVyd3JpdGVzIHRoZSBzY2hlbWEncyBbc3RyaWN0IG1vZGUgb3B0aW9uXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvZ3VpZGUuaHRtbCNzdHJpY3QpXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnVwc2VydD1mYWxzZV0gaWYgdHJ1ZSwgYW5kIG5vIGRvY3VtZW50cyBmb3VuZCwgaW5zZXJ0IGEgbmV3IGRvY3VtZW50XG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMud3JpdGVDb25jZXJuPW51bGxdIHNldHMgdGhlIFt3cml0ZSBjb25jZXJuXShodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9yZWZlcmVuY2Uvd3JpdGUtY29uY2Vybi8pIGZvciByZXBsaWNhIHNldHMuIE92ZXJyaWRlcyB0aGUgW3NjaGVtYS1sZXZlbCB3cml0ZSBjb25jZXJuXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvZ3VpZGUuaHRtbCN3cml0ZUNvbmNlcm4pXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnRpbWVzdGFtcHM9bnVsbF0gSWYgc2V0IHRvIGBmYWxzZWAgYW5kIFtzY2hlbWEtbGV2ZWwgdGltZXN0YW1wc10oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2d1aWRlLmh0bWwjdGltZXN0YW1wcykgYXJlIGVuYWJsZWQsIHNraXAgdGltZXN0YW1wcyBmb3IgdGhpcyB1cGRhdGUuIE5vdGUgdGhhdCB0aGlzIGFsbG93cyB5b3UgdG8gb3ZlcndyaXRlIHRpbWVzdGFtcHMuIERvZXMgbm90aGluZyBpZiBzY2hlbWEtbGV2ZWwgdGltZXN0YW1wcyBhcmUgbm90IHNldC5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMudHJhbnNsYXRlQWxpYXNlcz1udWxsXSBJZiBzZXQgdG8gYHRydWVgLCB0cmFuc2xhdGVzIGFueSBzY2hlbWEtZGVmaW5lZCBhbGlhc2VzIGluIGBmaWx0ZXJgLCBgcHJvamVjdGlvbmAsIGB1cGRhdGVgLCBhbmQgYGRpc3RpbmN0YC4gVGhyb3dzIGFuIGVycm9yIGlmIHRoZXJlIGFyZSBhbnkgY29uZmxpY3RzIHdoZXJlIGJvdGggYWxpYXMgYW5kIHJhdyBwcm9wZXJ0eSBhcmUgZGVmaW5lZCBvbiB0aGUgc2FtZSBvYmplY3QuXG4gKiBAcmV0dXJuIHtRdWVyeX1cbiAqIEBzZWUgUXVlcnkgZG9jcyBodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvcXVlcmllcy5odG1sXG4gKiBAc2VlIE1vbmdvREIgZG9jcyBodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9yZWZlcmVuY2UvY29tbWFuZC91cGRhdGUvI3VwZGF0ZS1jb21tYW5kLW91dHB1dFxuICogQHNlZSBVcGRhdGVSZXN1bHQgaHR0cHM6Ly9tb25nb2RiLmdpdGh1Yi5pby9ub2RlLW1vbmdvZGItbmF0aXZlLzQuOS9pbnRlcmZhY2VzL1VwZGF0ZVJlc3VsdC5odG1sXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk1vZGVsLnVwZGF0ZU9uZSA9IGZ1bmN0aW9uIHVwZGF0ZU9uZShjb25kaXRpb25zLCBkb2MsIG9wdGlvbnMpIHtcbiAgX2NoZWNrQ29udGV4dCh0aGlzLCAndXBkYXRlT25lJyk7XG5cbiAgcmV0dXJuIF91cGRhdGUodGhpcywgJ3VwZGF0ZU9uZScsIGNvbmRpdGlvbnMsIGRvYywgb3B0aW9ucyk7XG59O1xuXG4vKipcbiAqIFJlcGxhY2UgdGhlIGV4aXN0aW5nIGRvY3VtZW50IHdpdGggdGhlIGdpdmVuIGRvY3VtZW50IChubyBhdG9taWMgb3BlcmF0b3JzIGxpa2UgYCRzZXRgKS5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IHJlcyA9IGF3YWl0IFBlcnNvbi5yZXBsYWNlT25lKHsgX2lkOiAyNDYwMSB9LCB7IG5hbWU6ICdKZWFuIFZhbGplYW4nIH0pO1xuICogICAgIHJlcy5tYXRjaGVkQ291bnQ7IC8vIE51bWJlciBvZiBkb2N1bWVudHMgbWF0Y2hlZFxuICogICAgIHJlcy5tb2RpZmllZENvdW50OyAvLyBOdW1iZXIgb2YgZG9jdW1lbnRzIG1vZGlmaWVkXG4gKiAgICAgcmVzLmFja25vd2xlZGdlZDsgLy8gQm9vbGVhbiBpbmRpY2F0aW5nIGV2ZXJ5dGhpbmcgd2VudCBzbW9vdGhseS5cbiAqICAgICByZXMudXBzZXJ0ZWRJZDsgLy8gbnVsbCBvciBhbiBpZCBjb250YWluaW5nIGEgZG9jdW1lbnQgdGhhdCBoYWQgdG8gYmUgdXBzZXJ0ZWQuXG4gKiAgICAgcmVzLnVwc2VydGVkQ291bnQ7IC8vIE51bWJlciBpbmRpY2F0aW5nIGhvdyBtYW55IGRvY3VtZW50cyBoYWQgdG8gYmUgdXBzZXJ0ZWQuIFdpbGwgZWl0aGVyIGJlIDAgb3IgMS5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIHRyaWdnZXJzIHRoZSBmb2xsb3dpbmcgbWlkZGxld2FyZS5cbiAqXG4gKiAtIGByZXBsYWNlT25lKClgXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGZpbHRlclxuICogQHBhcmFtIHtPYmplY3R9IGRvY1xuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBvcHRpb25hbCBzZWUgW2BRdWVyeS5wcm90b3R5cGUuc2V0T3B0aW9ucygpYF0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2FwaS9xdWVyeS5odG1sI1F1ZXJ5LnByb3RvdHlwZS5zZXRPcHRpb25zKCkpXG4gKiBAcGFyYW0ge0Jvb2xlYW58U3RyaW5nfSBbb3B0aW9ucy5zdHJpY3RdIG92ZXJ3cml0ZXMgdGhlIHNjaGVtYSdzIFtzdHJpY3QgbW9kZSBvcHRpb25dKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9ndWlkZS5odG1sI3N0cmljdClcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMudXBzZXJ0PWZhbHNlXSBpZiB0cnVlLCBhbmQgbm8gZG9jdW1lbnRzIGZvdW5kLCBpbnNlcnQgYSBuZXcgZG9jdW1lbnRcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy53cml0ZUNvbmNlcm49bnVsbF0gc2V0cyB0aGUgW3dyaXRlIGNvbmNlcm5dKGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvbWFudWFsL3JlZmVyZW5jZS93cml0ZS1jb25jZXJuLykgZm9yIHJlcGxpY2Egc2V0cy4gT3ZlcnJpZGVzIHRoZSBbc2NoZW1hLWxldmVsIHdyaXRlIGNvbmNlcm5dKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9ndWlkZS5odG1sI3dyaXRlQ29uY2VybilcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMudGltZXN0YW1wcz1udWxsXSBJZiBzZXQgdG8gYGZhbHNlYCBhbmQgW3NjaGVtYS1sZXZlbCB0aW1lc3RhbXBzXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvZ3VpZGUuaHRtbCN0aW1lc3RhbXBzKSBhcmUgZW5hYmxlZCwgc2tpcCB0aW1lc3RhbXBzIGZvciB0aGlzIHVwZGF0ZS4gRG9lcyBub3RoaW5nIGlmIHNjaGVtYS1sZXZlbCB0aW1lc3RhbXBzIGFyZSBub3Qgc2V0LlxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy50cmFuc2xhdGVBbGlhc2VzPW51bGxdIElmIHNldCB0byBgdHJ1ZWAsIHRyYW5zbGF0ZXMgYW55IHNjaGVtYS1kZWZpbmVkIGFsaWFzZXMgaW4gYGZpbHRlcmAsIGBwcm9qZWN0aW9uYCwgYHVwZGF0ZWAsIGFuZCBgZGlzdGluY3RgLiBUaHJvd3MgYW4gZXJyb3IgaWYgdGhlcmUgYXJlIGFueSBjb25mbGljdHMgd2hlcmUgYm90aCBhbGlhcyBhbmQgcmF3IHByb3BlcnR5IGFyZSBkZWZpbmVkIG9uIHRoZSBzYW1lIG9iamVjdC5cbiAqIEByZXR1cm4ge1F1ZXJ5fVxuICogQHNlZSBRdWVyeSBkb2NzIGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9xdWVyaWVzLmh0bWxcbiAqIEBzZWUgVXBkYXRlUmVzdWx0IGh0dHBzOi8vbW9uZ29kYi5naXRodWIuaW8vbm9kZS1tb25nb2RiLW5hdGl2ZS80LjkvaW50ZXJmYWNlcy9VcGRhdGVSZXN1bHQuaHRtbFxuICogQHJldHVybiB7UXVlcnl9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk1vZGVsLnJlcGxhY2VPbmUgPSBmdW5jdGlvbiByZXBsYWNlT25lKGNvbmRpdGlvbnMsIGRvYywgb3B0aW9ucykge1xuICBfY2hlY2tDb250ZXh0KHRoaXMsICdyZXBsYWNlT25lJyk7XG5cbiAgY29uc3QgdmVyc2lvbktleSA9IHRoaXMgJiYgdGhpcy5zY2hlbWEgJiYgdGhpcy5zY2hlbWEub3B0aW9ucyAmJiB0aGlzLnNjaGVtYS5vcHRpb25zLnZlcnNpb25LZXkgfHwgbnVsbDtcbiAgaWYgKHZlcnNpb25LZXkgJiYgIWRvY1t2ZXJzaW9uS2V5XSkge1xuICAgIGRvY1t2ZXJzaW9uS2V5XSA9IDA7XG4gIH1cblxuICByZXR1cm4gX3VwZGF0ZSh0aGlzLCAncmVwbGFjZU9uZScsIGNvbmRpdGlvbnMsIGRvYywgb3B0aW9ucyk7XG59O1xuXG4vKipcbiAqIENvbW1vbiBjb2RlIGZvciBgdXBkYXRlT25lKClgLCBgdXBkYXRlTWFueSgpYCwgYHJlcGxhY2VPbmUoKWAsIGFuZCBgdXBkYXRlKClgXG4gKiBiZWNhdXNlIHRoZXkgbmVlZCB0byBkbyB0aGUgc2FtZSB0aGluZ1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gX3VwZGF0ZShtb2RlbCwgb3AsIGNvbmRpdGlvbnMsIGRvYywgb3B0aW9ucykge1xuICBjb25zdCBtcSA9IG5ldyBtb2RlbC5RdWVyeSh7fSwge30sIG1vZGVsLCBtb2RlbC5jb2xsZWN0aW9uKTtcblxuICAvLyBnaC0yNDA2XG4gIC8vIG1ha2UgbG9jYWwgZGVlcCBjb3B5IG9mIGNvbmRpdGlvbnNcbiAgaWYgKGNvbmRpdGlvbnMgaW5zdGFuY2VvZiBEb2N1bWVudCkge1xuICAgIGNvbmRpdGlvbnMgPSBjb25kaXRpb25zLnRvT2JqZWN0KCk7XG4gIH0gZWxzZSB7XG4gICAgY29uZGl0aW9ucyA9IGNsb25lKGNvbmRpdGlvbnMpO1xuICB9XG4gIG9wdGlvbnMgPSB0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJyA/IG9wdGlvbnMgOiBjbG9uZShvcHRpb25zKTtcblxuICBjb25zdCB2ZXJzaW9uS2V5ID0gbW9kZWwgJiZcbiAgbW9kZWwuc2NoZW1hICYmXG4gIG1vZGVsLnNjaGVtYS5vcHRpb25zICYmXG4gIG1vZGVsLnNjaGVtYS5vcHRpb25zLnZlcnNpb25LZXkgfHwgbnVsbDtcbiAgZGVjb3JhdGVVcGRhdGVXaXRoVmVyc2lvbktleShkb2MsIG9wdGlvbnMsIHZlcnNpb25LZXkpO1xuXG4gIHJldHVybiBtcVtvcF0oY29uZGl0aW9ucywgZG9jLCBvcHRpb25zKTtcbn1cblxuLyoqXG4gKiBQZXJmb3JtcyBbYWdncmVnYXRpb25zXShodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9hZ2dyZWdhdGlvbi8pIG9uIHRoZSBtb2RlbHMgY29sbGVjdGlvbi5cbiAqXG4gKiBJZiBhIGBjYWxsYmFja2AgaXMgcGFzc2VkLCB0aGUgYGFnZ3JlZ2F0ZWAgaXMgZXhlY3V0ZWQgYW5kIGEgYFByb21pc2VgIGlzIHJldHVybmVkLiBJZiBhIGNhbGxiYWNrIGlzIG5vdCBwYXNzZWQsIHRoZSBgYWdncmVnYXRlYCBpdHNlbGYgaXMgcmV0dXJuZWQuXG4gKlxuICogVGhpcyBmdW5jdGlvbiB0cmlnZ2VycyB0aGUgZm9sbG93aW5nIG1pZGRsZXdhcmUuXG4gKlxuICogLSBgYWdncmVnYXRlKClgXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICAvLyBGaW5kIHRoZSBtYXggYmFsYW5jZSBvZiBhbGwgYWNjb3VudHNcbiAqICAgICBjb25zdCByZXMgPSBhd2FpdCBVc2Vycy5hZ2dyZWdhdGUoW1xuICogICAgICAgeyAkZ3JvdXA6IHsgX2lkOiBudWxsLCBtYXhCYWxhbmNlOiB7ICRtYXg6ICckYmFsYW5jZScgfX19LFxuICogICAgICAgeyAkcHJvamVjdDogeyBfaWQ6IDAsIG1heEJhbGFuY2U6IDEgfX1cbiAqICAgICBdKTtcbiAqXG4gKiAgICAgY29uc29sZS5sb2cocmVzKTsgLy8gWyB7IG1heEJhbGFuY2U6IDk4MDAwIH0gXVxuICpcbiAqICAgICAvLyBPciB1c2UgdGhlIGFnZ3JlZ2F0aW9uIHBpcGVsaW5lIGJ1aWxkZXIuXG4gKiAgICAgY29uc3QgcmVzID0gYXdhaXQgVXNlcnMuYWdncmVnYXRlKCkuXG4gKiAgICAgICBncm91cCh7IF9pZDogbnVsbCwgbWF4QmFsYW5jZTogeyAkbWF4OiAnJGJhbGFuY2UnIH0gfSkuXG4gKiAgICAgICBwcm9qZWN0KCctaWQgbWF4QmFsYW5jZScpLlxuICogICAgICAgZXhlYygpO1xuICogICAgIGNvbnNvbGUubG9nKHJlcyk7IC8vIFsgeyBtYXhCYWxhbmNlOiA5OCB9IF1cbiAqXG4gKiAjIyMjIE5vdGU6XG4gKlxuICogLSBNb25nb29zZSBkb2VzICoqbm90KiogY2FzdCBhZ2dyZWdhdGlvbiBwaXBlbGluZXMgdG8gdGhlIG1vZGVsJ3Mgc2NoZW1hIGJlY2F1c2UgYCRwcm9qZWN0YCBhbmQgYCRncm91cGAgb3BlcmF0b3JzIGFsbG93IHJlZGVmaW5pbmcgdGhlIFwic2hhcGVcIiBvZiB0aGUgZG9jdW1lbnRzIGF0IGFueSBzdGFnZSBvZiB0aGUgcGlwZWxpbmUsIHdoaWNoIG1heSBsZWF2ZSBkb2N1bWVudHMgaW4gYW4gaW5jb21wYXRpYmxlIGZvcm1hdC4gWW91IGNhbiB1c2UgdGhlIFttb25nb29zZS1jYXN0LWFnZ3JlZ2F0aW9uIHBsdWdpbl0oaHR0cHM6Ly9naXRodWIuY29tL0FiZGVscmFobWFuSGFmZXovbW9uZ29vc2UtY2FzdC1hZ2dyZWdhdGlvbikgdG8gZW5hYmxlIG1pbmltYWwgY2FzdGluZyBmb3IgYWdncmVnYXRpb24gcGlwZWxpbmVzLlxuICogLSBUaGUgZG9jdW1lbnRzIHJldHVybmVkIGFyZSBwbGFpbiBqYXZhc2NyaXB0IG9iamVjdHMsIG5vdCBtb25nb29zZSBkb2N1bWVudHMgKHNpbmNlIGFueSBzaGFwZSBvZiBkb2N1bWVudCBjYW4gYmUgcmV0dXJuZWQpLlxuICpcbiAqICMjIyMgTW9yZSBBYm91dCBBZ2dyZWdhdGlvbnM6XG4gKlxuICogLSBbTW9uZ29vc2UgYEFnZ3JlZ2F0ZWBdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvYWdncmVnYXRlLmh0bWwpXG4gKiAtIFtBbiBJbnRyb2R1Y3Rpb24gdG8gTW9uZ29vc2UgQWdncmVnYXRlXShodHRwczovL21hc3RlcmluZ2pzLmlvL3R1dG9yaWFscy9tb25nb29zZS9hZ2dyZWdhdGUpXG4gKiAtIFtNb25nb0RCIEFnZ3JlZ2F0aW9uIGRvY3NdKGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvbWFudWFsL2FwcGxpY2F0aW9ucy9hZ2dyZWdhdGlvbi8pXG4gKlxuICogQHNlZSBBZ2dyZWdhdGUgaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2FwaS9hZ2dyZWdhdGUuaHRtbCNBZ2dyZWdhdGUoKVxuICogQHNlZSBNb25nb0RCIGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvbWFudWFsL2FwcGxpY2F0aW9ucy9hZ2dyZWdhdGlvbi9cbiAqIEBwYXJhbSB7QXJyYXl9IFtwaXBlbGluZV0gYWdncmVnYXRpb24gcGlwZWxpbmUgYXMgYW4gYXJyYXkgb2Ygb2JqZWN0c1xuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBhZ2dyZWdhdGlvbiBvcHRpb25zXG4gKiBAcmV0dXJuIHtBZ2dyZWdhdGV9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk1vZGVsLmFnZ3JlZ2F0ZSA9IGZ1bmN0aW9uIGFnZ3JlZ2F0ZShwaXBlbGluZSwgb3B0aW9ucykge1xuICBfY2hlY2tDb250ZXh0KHRoaXMsICdhZ2dyZWdhdGUnKTtcblxuICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIGFyZ3VtZW50c1syXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBNb25nb29zZUVycm9yKCdNb2RlbC5hZ2dyZWdhdGUoKSBubyBsb25nZXIgYWNjZXB0cyBhIGNhbGxiYWNrJyk7XG4gIH1cblxuICBjb25zdCBhZ2dyZWdhdGUgPSBuZXcgQWdncmVnYXRlKHBpcGVsaW5lIHx8IFtdKTtcbiAgYWdncmVnYXRlLm1vZGVsKHRoaXMpO1xuICBpZiAob3B0aW9ucyAhPSBudWxsKSB7XG4gICAgYWdncmVnYXRlLm9wdGlvbihvcHRpb25zKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgY2FsbGJhY2sgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIGFnZ3JlZ2F0ZTtcbiAgfVxuXG4gIHJldHVybiBhZ2dyZWdhdGU7XG59O1xuXG4vKipcbiAqIENhc3RzIGFuZCB2YWxpZGF0ZXMgdGhlIGdpdmVuIG9iamVjdCBhZ2FpbnN0IHRoaXMgbW9kZWwncyBzY2hlbWEsIHBhc3NpbmcgdGhlXG4gKiBnaXZlbiBgY29udGV4dGAgdG8gY3VzdG9tIHZhbGlkYXRvcnMuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBjb25zdCBNb2RlbCA9IG1vbmdvb3NlLm1vZGVsKCdUZXN0JywgU2NoZW1hKHtcbiAqICAgICAgIG5hbWU6IHsgdHlwZTogU3RyaW5nLCByZXF1aXJlZDogdHJ1ZSB9LFxuICogICAgICAgYWdlOiB7IHR5cGU6IE51bWJlciwgcmVxdWlyZWQ6IHRydWUgfVxuICogICAgIH0pO1xuICpcbiAqICAgICB0cnkge1xuICogICAgICAgYXdhaXQgTW9kZWwudmFsaWRhdGUoeyBuYW1lOiBudWxsIH0sIFsnbmFtZSddKVxuICogICAgIH0gY2F0Y2ggKGVycikge1xuICogICAgICAgZXJyIGluc3RhbmNlb2YgbW9uZ29vc2UuRXJyb3IuVmFsaWRhdGlvbkVycm9yOyAvLyB0cnVlXG4gKiAgICAgICBPYmplY3Qua2V5cyhlcnIuZXJyb3JzKTsgLy8gWyduYW1lJ11cbiAqICAgICB9XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9ialxuICogQHBhcmFtIHtPYmplY3R8QXJyYXl8U3RyaW5nfSBwYXRoc09yT3B0aW9uc1xuICogQHBhcmFtIHtPYmplY3R9IFtjb250ZXh0XVxuICogQHJldHVybiB7UHJvbWlzZTxPYmplY3Q+fSBjYXN0ZWQgYW5kIHZhbGlkYXRlZCBjb3B5IG9mIGBvYmpgIGlmIHZhbGlkYXRpb24gc3VjY2VlZGVkXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk1vZGVsLnZhbGlkYXRlID0gYXN5bmMgZnVuY3Rpb24gdmFsaWRhdGUob2JqLCBwYXRoc09yT3B0aW9ucywgY29udGV4dCkge1xuICBpZiAoKGFyZ3VtZW50cy5sZW5ndGggPCAzKSB8fCAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMyAmJiB0eXBlb2YgYXJndW1lbnRzWzJdID09PSAnZnVuY3Rpb24nKSkge1xuICAgIC8vIEZvciBjb252ZW5pZW5jZSwgaWYgd2UncmUgdmFsaWRhdGluZyBhIGRvY3VtZW50IG9yIGFuIG9iamVjdCwgbWFrZSBgY29udGV4dGAgZGVmYXVsdCB0b1xuICAgIC8vIHRoZSBtb2RlbCBzbyB1c2VycyBkb24ndCBoYXZlIHRvIGFsd2F5cyBwYXNzIGBjb250ZXh0YCwgcmU6IGdoLTEwMTMyLCBnaC0xMDM0NlxuICAgIGNvbnRleHQgPSBvYmo7XG4gIH1cbiAgaWYgKHR5cGVvZiBjb250ZXh0ID09PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBhcmd1bWVudHNbM10gPT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgTW9uZ29vc2VFcnJvcignTW9kZWwudmFsaWRhdGUoKSBubyBsb25nZXIgYWNjZXB0cyBhIGNhbGxiYWNrJyk7XG4gIH1cblxuICBsZXQgc2NoZW1hID0gdGhpcy5zY2hlbWE7XG4gIGNvbnN0IGRpc2NyaW1pbmF0b3JLZXkgPSBzY2hlbWEub3B0aW9ucy5kaXNjcmltaW5hdG9yS2V5O1xuICBpZiAoc2NoZW1hLmRpc2NyaW1pbmF0b3JzICE9IG51bGwgJiYgb2JqICE9IG51bGwgJiYgb2JqW2Rpc2NyaW1pbmF0b3JLZXldICE9IG51bGwpIHtcbiAgICBzY2hlbWEgPSBnZXRTY2hlbWFEaXNjcmltaW5hdG9yQnlWYWx1ZShzY2hlbWEsIG9ialtkaXNjcmltaW5hdG9yS2V5XSkgfHwgc2NoZW1hO1xuICB9XG4gIGxldCBwYXRocyA9IE9iamVjdC5rZXlzKHNjaGVtYS5wYXRocyk7XG5cbiAgaWYgKHBhdGhzT3JPcHRpb25zICE9IG51bGwpIHtcbiAgICBjb25zdCBfcGF0aHNUb1ZhbGlkYXRlID0gdHlwZW9mIHBhdGhzT3JPcHRpb25zID09PSAnc3RyaW5nJyA/IG5ldyBTZXQocGF0aHNPck9wdGlvbnMuc3BsaXQoJyAnKSkgOiBBcnJheS5pc0FycmF5KHBhdGhzT3JPcHRpb25zKSA/IG5ldyBTZXQocGF0aHNPck9wdGlvbnMpIDogbmV3IFNldChwYXRocyk7XG4gICAgcGF0aHMgPSBwYXRocy5maWx0ZXIocCA9PiB7XG4gICAgICBpZiAocGF0aHNPck9wdGlvbnMucGF0aHNUb1NraXApIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocGF0aHNPck9wdGlvbnMucGF0aHNUb1NraXApKSB7XG4gICAgICAgICAgaWYgKHBhdGhzT3JPcHRpb25zLnBhdGhzVG9Ta2lwLmZpbmQoeCA9PiB4ID09IHApKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBwYXRoc09yT3B0aW9ucy5wYXRoc1RvU2tpcCA9PSAnc3RyaW5nJykge1xuICAgICAgICAgIGlmIChwYXRoc09yT3B0aW9ucy5wYXRoc1RvU2tpcC5pbmNsdWRlcyhwKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc3QgcGllY2VzID0gcC5zcGxpdCgnLicpO1xuICAgICAgbGV0IGN1ciA9IHBpZWNlc1swXTtcblxuICAgICAgZm9yIChjb25zdCBwaWVjZSBvZiBwaWVjZXMpIHtcbiAgICAgICAgaWYgKF9wYXRoc1RvVmFsaWRhdGUuaGFzKGN1cikpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBjdXIgKz0gJy4nICsgcGllY2U7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBfcGF0aHNUb1ZhbGlkYXRlLmhhcyhwKTtcbiAgICB9KTtcbiAgfVxuXG4gIGZvciAoY29uc3QgcGF0aCBvZiBwYXRocykge1xuICAgIGNvbnN0IHNjaGVtYVR5cGUgPSBzY2hlbWEucGF0aChwYXRoKTtcbiAgICBpZiAoIXNjaGVtYVR5cGUgfHwgIXNjaGVtYVR5cGUuJGlzTW9uZ29vc2VBcnJheSB8fCBzY2hlbWFUeXBlLiRpc01vbmdvb3NlRG9jdW1lbnRBcnJheSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgY29uc3QgdmFsID0gZ2V0KG9iaiwgcGF0aCk7XG4gICAgcHVzaE5lc3RlZEFycmF5UGF0aHMocGF0aHMsIHZhbCwgcGF0aCk7XG4gIH1cblxuICBsZXQgZXJyb3IgPSBudWxsO1xuICBwYXRocyA9IG5ldyBTZXQocGF0aHMpO1xuXG4gIHRyeSB7XG4gICAgb2JqID0gdGhpcy5jYXN0T2JqZWN0KG9iaik7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGVycm9yID0gZXJyO1xuICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKGVycm9yLmVycm9ycyB8fCB7fSkpIHtcbiAgICAgIHBhdGhzLmRlbGV0ZShrZXkpO1xuICAgIH1cbiAgfVxuXG4gIGxldCByZW1haW5pbmcgPSBwYXRocy5zaXplO1xuXG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgZm9yIChjb25zdCBwYXRoIG9mIHBhdGhzKSB7XG4gICAgICBjb25zdCBzY2hlbWFUeXBlID0gc2NoZW1hLnBhdGgocGF0aCk7XG4gICAgICBpZiAoc2NoZW1hVHlwZSA9PSBudWxsKSB7XG4gICAgICAgIF9jaGVja0RvbmUoKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHBpZWNlcyA9IHBhdGguaW5kZXhPZignLicpID09PSAtMSA/IFtwYXRoXSA6IHBhdGguc3BsaXQoJy4nKTtcbiAgICAgIGxldCBjdXIgPSBvYmo7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBpZWNlcy5sZW5ndGggLSAxOyArK2kpIHtcbiAgICAgICAgY3VyID0gY3VyW3BpZWNlc1tpXV07XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHZhbCA9IGdldChvYmosIHBhdGgsIHZvaWQgMCk7XG5cbiAgICAgIHNjaGVtYVR5cGUuZG9WYWxpZGF0ZSh2YWwsIGVyciA9PiB7XG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICBlcnJvciA9IGVycm9yIHx8IG5ldyBWYWxpZGF0aW9uRXJyb3IoKTtcbiAgICAgICAgICBlcnJvci5hZGRFcnJvcihwYXRoLCBlcnIpO1xuICAgICAgICB9XG4gICAgICAgIF9jaGVja0RvbmUoKTtcbiAgICAgIH0sIGNvbnRleHQsIHsgcGF0aDogcGF0aCB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfY2hlY2tEb25lKCkge1xuICAgICAgaWYgKC0tcmVtYWluaW5nIDw9IDApIHtcbiAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXNvbHZlKG9iaik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0pO1xufTtcblxuLyoqXG4gKiBQb3B1bGF0ZXMgZG9jdW1lbnQgcmVmZXJlbmNlcy5cbiAqXG4gKiBDaGFuZ2VkIGluIE1vbmdvb3NlIDY6IHRoZSBtb2RlbCB5b3UgY2FsbCBgcG9wdWxhdGUoKWAgb24gc2hvdWxkIGJlIHRoZVxuICogXCJsb2NhbCBmaWVsZFwiIG1vZGVsLCAqKm5vdCoqIHRoZSBcImZvcmVpZ24gZmllbGRcIiBtb2RlbC5cbiAqXG4gKiAjIyMjIEF2YWlsYWJsZSB0b3AtbGV2ZWwgb3B0aW9uczpcbiAqXG4gKiAtIHBhdGg6IHNwYWNlIGRlbGltaXRlZCBwYXRoKHMpIHRvIHBvcHVsYXRlXG4gKiAtIHNlbGVjdDogb3B0aW9uYWwgZmllbGRzIHRvIHNlbGVjdFxuICogLSBtYXRjaDogb3B0aW9uYWwgcXVlcnkgY29uZGl0aW9ucyB0byBtYXRjaFxuICogLSBtb2RlbDogb3B0aW9uYWwgbmFtZSBvZiB0aGUgbW9kZWwgdG8gdXNlIGZvciBwb3B1bGF0aW9uXG4gKiAtIG9wdGlvbnM6IG9wdGlvbmFsIHF1ZXJ5IG9wdGlvbnMgbGlrZSBzb3J0LCBsaW1pdCwgZXRjXG4gKiAtIGp1c3RPbmU6IG9wdGlvbmFsIGJvb2xlYW4sIGlmIHRydWUgTW9uZ29vc2Ugd2lsbCBhbHdheXMgc2V0IGBwYXRoYCB0byBhIGRvY3VtZW50LCBvciBgbnVsbGAgaWYgbm8gZG9jdW1lbnQgd2FzIGZvdW5kLiBJZiBmYWxzZSwgTW9uZ29vc2Ugd2lsbCBhbHdheXMgc2V0IGBwYXRoYCB0byBhbiBhcnJheSwgd2hpY2ggd2lsbCBiZSBlbXB0eSBpZiBubyBkb2N1bWVudHMgYXJlIGZvdW5kLiBJbmZlcnJlZCBmcm9tIHNjaGVtYSBieSBkZWZhdWx0LlxuICogLSBzdHJpY3RQb3B1bGF0ZTogb3B0aW9uYWwgYm9vbGVhbiwgc2V0IHRvIGBmYWxzZWAgdG8gYWxsb3cgcG9wdWxhdGluZyBwYXRocyB0aGF0IGFyZW4ndCBpbiB0aGUgc2NoZW1hLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgY29uc3QgRG9nID0gbW9uZ29vc2UubW9kZWwoJ0RvZycsIG5ldyBTY2hlbWEoeyBuYW1lOiBTdHJpbmcsIGJyZWVkOiBTdHJpbmcgfSkpO1xuICogICAgIGNvbnN0IFBlcnNvbiA9IG1vbmdvb3NlLm1vZGVsKCdQZXJzb24nLCBuZXcgU2NoZW1hKHtcbiAqICAgICAgIG5hbWU6IFN0cmluZyxcbiAqICAgICAgIHBldDogeyB0eXBlOiBtb25nb29zZS5PYmplY3RJZCwgcmVmOiAnRG9nJyB9XG4gKiAgICAgfSkpO1xuICpcbiAqICAgICBjb25zdCBwZXRzID0gYXdhaXQgUGV0LmNyZWF0ZShbXG4gKiAgICAgICB7IG5hbWU6ICdEYWlzeScsIGJyZWVkOiAnQmVhZ2xlJyB9LFxuICogICAgICAgeyBuYW1lOiAnRWluc3RlaW4nLCBicmVlZDogJ0NhdGFsYW4gU2hlZXBkb2cnIH1cbiAqICAgICBdKTtcbiAqXG4gKiAgICAgLy8gcG9wdWxhdGUgbWFueSBwbGFpbiBvYmplY3RzXG4gKiAgICAgY29uc3QgdXNlcnMgPSBbXG4gKiAgICAgICB7IG5hbWU6ICdKb2huIFdpY2snLCBkb2c6IHBldHNbMF0uX2lkIH0sXG4gKiAgICAgICB7IG5hbWU6ICdEb2MgQnJvd24nLCBkb2c6IHBldHNbMV0uX2lkIH1cbiAqICAgICBdO1xuICogICAgIGF3YWl0IFVzZXIucG9wdWxhdGUodXNlcnMsIHsgcGF0aDogJ2RvZycsIHNlbGVjdDogJ25hbWUnIH0pO1xuICogICAgIHVzZXJzWzBdLmRvZy5uYW1lOyAvLyAnRGFpc3knXG4gKiAgICAgdXNlcnNbMF0uZG9nLmJyZWVkOyAvLyB1bmRlZmluZWQgYmVjYXVzZSBvZiBgc2VsZWN0YFxuICpcbiAqIEBwYXJhbSB7RG9jdW1lbnR8QXJyYXl9IGRvY3MgRWl0aGVyIGEgc2luZ2xlIGRvY3VtZW50IG9yIGFycmF5IG9mIGRvY3VtZW50cyB0byBwb3B1bGF0ZS5cbiAqIEBwYXJhbSB7T2JqZWN0fFN0cmluZ30gb3B0aW9ucyBFaXRoZXIgdGhlIHBhdGhzIHRvIHBvcHVsYXRlIG9yIGFuIG9iamVjdCBzcGVjaWZ5aW5nIGFsbCBwYXJhbWV0ZXJzXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMucGF0aD1udWxsXSBUaGUgcGF0aCB0byBwb3B1bGF0ZS5cbiAqIEBwYXJhbSB7c3RyaW5nfFBvcHVsYXRlT3B0aW9uc30gW29wdGlvbnMucG9wdWxhdGU9bnVsbF0gUmVjdXJzaXZlbHkgcG9wdWxhdGUgcGF0aHMgaW4gdGhlIHBvcHVsYXRlZCBkb2N1bWVudHMuIFNlZSBbZGVlcCBwb3B1bGF0ZSBkb2NzXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvcG9wdWxhdGUuaHRtbCNkZWVwLXBvcHVsYXRlKS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMucmV0YWluTnVsbFZhbHVlcz1mYWxzZV0gQnkgZGVmYXVsdCwgTW9uZ29vc2UgcmVtb3ZlcyBudWxsIGFuZCB1bmRlZmluZWQgdmFsdWVzIGZyb20gcG9wdWxhdGVkIGFycmF5cy4gVXNlIHRoaXMgb3B0aW9uIHRvIG1ha2UgYHBvcHVsYXRlKClgIHJldGFpbiBgbnVsbGAgYW5kIGB1bmRlZmluZWRgIGFycmF5IGVudHJpZXMuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmdldHRlcnM9ZmFsc2VdIElmIHRydWUsIE1vbmdvb3NlIHdpbGwgY2FsbCBhbnkgZ2V0dGVycyBkZWZpbmVkIG9uIHRoZSBgbG9jYWxGaWVsZGAuIEJ5IGRlZmF1bHQsIE1vbmdvb3NlIGdldHMgdGhlIHJhdyB2YWx1ZSBvZiBgbG9jYWxGaWVsZGAuIEZvciBleGFtcGxlLCB5b3Ugd291bGQgbmVlZCB0byBzZXQgdGhpcyBvcHRpb24gdG8gYHRydWVgIGlmIHlvdSB3YW50ZWQgdG8gW2FkZCBhIGBsb3dlcmNhc2VgIGdldHRlciB0byB5b3VyIGBsb2NhbEZpZWxkYF0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL3NjaGVtYXR5cGVzLmh0bWwjc2NoZW1hdHlwZS1vcHRpb25zKS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuY2xvbmU9ZmFsc2VdIFdoZW4geW91IGRvIGBCbG9nUG9zdC5maW5kKCkucG9wdWxhdGUoJ2F1dGhvcicpYCwgYmxvZyBwb3N0cyB3aXRoIHRoZSBzYW1lIGF1dGhvciB3aWxsIHNoYXJlIDEgY29weSBvZiBhbiBgYXV0aG9yYCBkb2MuIEVuYWJsZSB0aGlzIG9wdGlvbiB0byBtYWtlIE1vbmdvb3NlIGNsb25lIHBvcHVsYXRlZCBkb2NzIGJlZm9yZSBhc3NpZ25pbmcgdGhlbS5cbiAqIEBwYXJhbSB7T2JqZWN0fEZ1bmN0aW9ufSBbb3B0aW9ucy5tYXRjaD1udWxsXSBBZGQgYW4gYWRkaXRpb25hbCBmaWx0ZXIgdG8gdGhlIHBvcHVsYXRlIHF1ZXJ5LiBDYW4gYmUgYSBmaWx0ZXIgb2JqZWN0IGNvbnRhaW5pbmcgW01vbmdvREIgcXVlcnkgc3ludGF4XShodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC90dXRvcmlhbC9xdWVyeS1kb2N1bWVudHMvKSwgb3IgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgYSBmaWx0ZXIgb2JqZWN0LlxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5za2lwSW52YWxpZElkcz1mYWxzZV0gQnkgZGVmYXVsdCwgTW9uZ29vc2UgdGhyb3dzIGEgY2FzdCBlcnJvciBpZiBgbG9jYWxGaWVsZGAgYW5kIGBmb3JlaWduRmllbGRgIHNjaGVtYXMgZG9uJ3QgbGluZSB1cC4gSWYgeW91IGVuYWJsZSB0aGlzIG9wdGlvbiwgTW9uZ29vc2Ugd2lsbCBpbnN0ZWFkIGZpbHRlciBvdXQgYW55IGBsb2NhbEZpZWxkYCBwcm9wZXJ0aWVzIHRoYXQgY2Fubm90IGJlIGNhc3RlZCB0byBgZm9yZWlnbkZpZWxkYCdzIHNjaGVtYSB0eXBlLlxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnBlckRvY3VtZW50TGltaXQ9bnVsbF0gRm9yIGxlZ2FjeSByZWFzb25zLCBgbGltaXRgIHdpdGggYHBvcHVsYXRlKClgIG1heSBnaXZlIGluY29ycmVjdCByZXN1bHRzIGJlY2F1c2UgaXQgb25seSBleGVjdXRlcyBhIHNpbmdsZSBxdWVyeSBmb3IgZXZlcnkgZG9jdW1lbnQgYmVpbmcgcG9wdWxhdGVkLiBJZiB5b3Ugc2V0IGBwZXJEb2N1bWVudExpbWl0YCwgTW9uZ29vc2Ugd2lsbCBlbnN1cmUgY29ycmVjdCBgbGltaXRgIHBlciBkb2N1bWVudCBieSBleGVjdXRpbmcgYSBzZXBhcmF0ZSBxdWVyeSBmb3IgZWFjaCBkb2N1bWVudCB0byBgcG9wdWxhdGUoKWAuIEZvciBleGFtcGxlLCBgLmZpbmQoKS5wb3B1bGF0ZSh7IHBhdGg6ICd0ZXN0JywgcGVyRG9jdW1lbnRMaW1pdDogMiB9KWAgd2lsbCBleGVjdXRlIDIgYWRkaXRpb25hbCBxdWVyaWVzIGlmIGAuZmluZCgpYCByZXR1cm5zIDIgZG9jdW1lbnRzLlxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5zdHJpY3RQb3B1bGF0ZT10cnVlXSBTZXQgdG8gZmFsc2UgdG8gYWxsb3cgcG9wdWxhdGluZyBwYXRocyB0aGF0IGFyZW4ndCBkZWZpbmVkIGluIHRoZSBnaXZlbiBtb2RlbCdzIHNjaGVtYS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy5vcHRpb25zPW51bGxdIEFkZGl0aW9uYWwgb3B0aW9ucyBsaWtlIGBsaW1pdGAgYW5kIGBsZWFuYC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLnRyYW5zZm9ybT1udWxsXSBGdW5jdGlvbiB0aGF0IE1vbmdvb3NlIHdpbGwgY2FsbCBvbiBldmVyeSBwb3B1bGF0ZWQgZG9jdW1lbnQgdGhhdCBhbGxvd3MgeW91IHRvIHRyYW5zZm9ybSB0aGUgcG9wdWxhdGVkIGRvY3VtZW50LlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrKGVycixkb2MpXSBPcHRpb25hbCBjYWxsYmFjaywgZXhlY3V0ZWQgdXBvbiBjb21wbGV0aW9uLiBSZWNlaXZlcyBgZXJyYCBhbmQgdGhlIGBkb2MocylgLlxuICogQHJldHVybiB7UHJvbWlzZX1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuTW9kZWwucG9wdWxhdGUgPSBhc3luYyBmdW5jdGlvbiBwb3B1bGF0ZShkb2NzLCBwYXRocykge1xuICBfY2hlY2tDb250ZXh0KHRoaXMsICdwb3B1bGF0ZScpO1xuICBpZiAodHlwZW9mIHBhdGhzID09PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBhcmd1bWVudHNbMl0gPT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgTW9uZ29vc2VFcnJvcignTW9kZWwucG9wdWxhdGUoKSBubyBsb25nZXIgYWNjZXB0cyBhIGNhbGxiYWNrJyk7XG4gIH1cbiAgY29uc3QgX3RoaXMgPSB0aGlzO1xuICAvLyBub3JtYWxpemVkIHBhdGhzXG4gIHBhdGhzID0gdXRpbHMucG9wdWxhdGUocGF0aHMpO1xuICAvLyBkYXRhIHRoYXQgc2hvdWxkIHBlcnNpc3QgYWNyb3NzIHN1YlBvcHVsYXRlIGNhbGxzXG4gIGNvbnN0IGNhY2hlID0ge307XG5cbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBfcG9wdWxhdGUoX3RoaXMsIGRvY3MsIHBhdGhzLCBjYWNoZSwgKGVyciwgcmVzKSA9PiB7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIHJldHVybiByZWplY3QoZXJyKTtcbiAgICAgIH1cbiAgICAgIHJlc29sdmUocmVzKTtcbiAgICB9KTtcbiAgfSk7XG59O1xuXG4vKipcbiAqIFBvcHVsYXRlIGhlbHBlclxuICpcbiAqIEBwYXJhbSB7TW9kZWx9IG1vZGVsIHRoZSBtb2RlbCB0byB1c2VcbiAqIEBwYXJhbSB7RG9jdW1lbnR8QXJyYXl9IGRvY3MgRWl0aGVyIGEgc2luZ2xlIGRvY3VtZW50IG9yIGFycmF5IG9mIGRvY3VtZW50cyB0byBwb3B1bGF0ZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBwYXRoc1xuICogQHBhcmFtIHtuZXZlcn0gY2FjaGUgVW51c2VkXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIE9wdGlvbmFsIGNhbGxiYWNrLCBleGVjdXRlZCB1cG9uIGNvbXBsZXRpb24uIFJlY2VpdmVzIGBlcnJgIGFuZCB0aGUgYGRvYyhzKWAuXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIF9wb3B1bGF0ZShtb2RlbCwgZG9jcywgcGF0aHMsIGNhY2hlLCBjYWxsYmFjaykge1xuICBsZXQgcGVuZGluZyA9IHBhdGhzLmxlbmd0aDtcbiAgaWYgKHBhdGhzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBjYWxsYmFjayhudWxsLCBkb2NzKTtcbiAgfVxuICAvLyBlYWNoIHBhdGggaGFzIGl0cyBvd24gcXVlcnkgb3B0aW9ucyBhbmQgbXVzdCBiZSBleGVjdXRlZCBzZXBhcmF0ZWx5XG4gIGZvciAoY29uc3QgcGF0aCBvZiBwYXRocykge1xuICAgIHBvcHVsYXRlKG1vZGVsLCBkb2NzLCBwYXRoLCBuZXh0KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG5leHQoZXJyKSB7XG4gICAgaWYgKGVycikge1xuICAgICAgcmV0dXJuIGNhbGxiYWNrKGVyciwgbnVsbCk7XG4gICAgfVxuICAgIGlmICgtLXBlbmRpbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY2FsbGJhY2sobnVsbCwgZG9jcyk7XG4gIH1cbn1cblxuLyohXG4gKiBQb3B1bGF0ZXMgYGRvY3NgXG4gKi9cbmNvbnN0IGV4Y2x1ZGVJZFJlZyA9IC9cXHM/LV9pZFxccz8vO1xuY29uc3QgZXhjbHVkZUlkUmVnR2xvYmFsID0gL1xccz8tX2lkXFxzPy9nO1xuXG5mdW5jdGlvbiBwb3B1bGF0ZShtb2RlbCwgZG9jcywgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgY29uc3QgcG9wdWxhdGVPcHRpb25zID0gb3B0aW9ucztcbiAgaWYgKG9wdGlvbnMuc3RyaWN0UG9wdWxhdGUgPT0gbnVsbCkge1xuICAgIGlmIChvcHRpb25zLl9sb2NhbE1vZGVsICE9IG51bGwgJiYgb3B0aW9ucy5fbG9jYWxNb2RlbC5zY2hlbWEuX3VzZXJQcm92aWRlZE9wdGlvbnMuc3RyaWN0UG9wdWxhdGUgIT0gbnVsbCkge1xuICAgICAgcG9wdWxhdGVPcHRpb25zLnN0cmljdFBvcHVsYXRlID0gb3B0aW9ucy5fbG9jYWxNb2RlbC5zY2hlbWEuX3VzZXJQcm92aWRlZE9wdGlvbnMuc3RyaWN0UG9wdWxhdGU7XG4gICAgfSBlbHNlIGlmIChvcHRpb25zLl9sb2NhbE1vZGVsICE9IG51bGwgJiYgbW9kZWwuYmFzZS5vcHRpb25zLnN0cmljdFBvcHVsYXRlICE9IG51bGwpIHtcbiAgICAgIHBvcHVsYXRlT3B0aW9ucy5zdHJpY3RQb3B1bGF0ZSA9IG1vZGVsLmJhc2Uub3B0aW9ucy5zdHJpY3RQb3B1bGF0ZTtcbiAgICB9IGVsc2UgaWYgKG1vZGVsLmJhc2Uub3B0aW9ucy5zdHJpY3RQb3B1bGF0ZSAhPSBudWxsKSB7XG4gICAgICBwb3B1bGF0ZU9wdGlvbnMuc3RyaWN0UG9wdWxhdGUgPSBtb2RlbC5iYXNlLm9wdGlvbnMuc3RyaWN0UG9wdWxhdGU7XG4gICAgfVxuICB9XG5cbiAgLy8gbm9ybWFsaXplIHNpbmdsZSAvIG11bHRpcGxlIGRvY3MgcGFzc2VkXG4gIGlmICghQXJyYXkuaXNBcnJheShkb2NzKSkge1xuICAgIGRvY3MgPSBbZG9jc107XG4gIH1cbiAgaWYgKGRvY3MubGVuZ3RoID09PSAwIHx8IGRvY3MuZXZlcnkodXRpbHMuaXNOdWxsT3JVbmRlZmluZWQpKSB7XG4gICAgcmV0dXJuIGNhbGxiYWNrKCk7XG4gIH1cblxuICBjb25zdCBtb2RlbHNNYXAgPSBnZXRNb2RlbHNNYXBGb3JQb3B1bGF0ZShtb2RlbCwgZG9jcywgcG9wdWxhdGVPcHRpb25zKTtcblxuICBpZiAobW9kZWxzTWFwIGluc3RhbmNlb2YgTW9uZ29vc2VFcnJvcikge1xuICAgIHJldHVybiBpbW1lZGlhdGUoZnVuY3Rpb24oKSB7XG4gICAgICBjYWxsYmFjayhtb2RlbHNNYXApO1xuICAgIH0pO1xuICB9XG4gIGNvbnN0IGxlbiA9IG1vZGVsc01hcC5sZW5ndGg7XG4gIGxldCB2YWxzID0gW107XG5cbiAgZnVuY3Rpb24gZmxhdHRlbihpdGVtKSB7XG4gICAgLy8gbm8gbmVlZCB0byBpbmNsdWRlIHVuZGVmaW5lZCB2YWx1ZXMgaW4gb3VyIHF1ZXJ5XG4gICAgcmV0dXJuIHVuZGVmaW5lZCAhPT0gaXRlbTtcbiAgfVxuXG4gIGxldCBfcmVtYWluaW5nID0gbGVuO1xuICBsZXQgaGFzT25lID0gZmFsc2U7XG4gIGNvbnN0IHBhcmFtcyA9IFtdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgY29uc3QgbW9kID0gbW9kZWxzTWFwW2ldO1xuICAgIGxldCBzZWxlY3QgPSBtb2Qub3B0aW9ucy5zZWxlY3Q7XG4gICAgbGV0IGlkcyA9IHV0aWxzLmFycmF5LmZsYXR0ZW4obW9kLmlkcywgZmxhdHRlbik7XG4gICAgaWRzID0gdXRpbHMuYXJyYXkudW5pcXVlKGlkcyk7XG5cbiAgICBjb25zdCBhc3NpZ25tZW50T3B0cyA9IHt9O1xuICAgIGFzc2lnbm1lbnRPcHRzLnNvcnQgPSBtb2QgJiZcbiAgICAgIG1vZC5vcHRpb25zICYmXG4gICAgICBtb2Qub3B0aW9ucy5vcHRpb25zICYmXG4gICAgICBtb2Qub3B0aW9ucy5vcHRpb25zLnNvcnQgfHwgdm9pZCAwO1xuICAgIGFzc2lnbm1lbnRPcHRzLmV4Y2x1ZGVJZCA9IGV4Y2x1ZGVJZFJlZy50ZXN0KHNlbGVjdCkgfHwgKHNlbGVjdCAmJiBzZWxlY3QuX2lkID09PSAwKTtcblxuICAgIC8vIExlYW4gdHJhbnNmb3JtIG1heSBkZWxldGUgYF9pZGAsIHdoaWNoIHdvdWxkIGNhdXNlIGFzc2lnbm1lbnRcbiAgICAvLyB0byBmYWlsLiBTbyBkZWxheSBydW5uaW5nIGxlYW4gdHJhbnNmb3JtIHVudGlsIF9hZnRlcl9cbiAgICAvLyBgX2Fzc2lnbigpYFxuICAgIGlmIChtb2Qub3B0aW9ucyAmJlxuICAgICAgICBtb2Qub3B0aW9ucy5vcHRpb25zICYmXG4gICAgICAgIG1vZC5vcHRpb25zLm9wdGlvbnMubGVhbiAmJlxuICAgICAgICBtb2Qub3B0aW9ucy5vcHRpb25zLmxlYW4udHJhbnNmb3JtKSB7XG4gICAgICBtb2Qub3B0aW9ucy5vcHRpb25zLl9sZWFuVHJhbnNmb3JtID0gbW9kLm9wdGlvbnMub3B0aW9ucy5sZWFuLnRyYW5zZm9ybTtcbiAgICAgIG1vZC5vcHRpb25zLm9wdGlvbnMubGVhbiA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKGlkcy5sZW5ndGggPT09IDAgfHwgaWRzLmV2ZXJ5KHV0aWxzLmlzTnVsbE9yVW5kZWZpbmVkKSkge1xuICAgICAgLy8gRW5zdXJlIHRoYXQgd2Ugc2V0IHRvIDAgb3IgZW1wdHkgYXJyYXkgZXZlblxuICAgICAgLy8gaWYgd2UgZG9uJ3QgYWN0dWFsbHkgZXhlY3V0ZSBhIHF1ZXJ5IHRvIG1ha2Ugc3VyZSB0aGVyZSdzIGEgdmFsdWVcbiAgICAgIC8vIGFuZCB3ZSBrbm93IHRoaXMgcGF0aCB3YXMgcG9wdWxhdGVkIGZvciBmdXR1cmUgc2V0cy4gU2VlIGdoLTc3MzEsIGdoLTgyMzBcbiAgICAgIC0tX3JlbWFpbmluZztcbiAgICAgIF9hc3NpZ24obW9kZWwsIFtdLCBtb2QsIGFzc2lnbm1lbnRPcHRzKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGhhc09uZSA9IHRydWU7XG4gICAgaWYgKHR5cGVvZiBwb3B1bGF0ZU9wdGlvbnMuZm9yZWlnbkZpZWxkID09PSAnc3RyaW5nJykge1xuICAgICAgbW9kLmZvcmVpZ25GaWVsZC5jbGVhcigpO1xuICAgICAgbW9kLmZvcmVpZ25GaWVsZC5hZGQocG9wdWxhdGVPcHRpb25zLmZvcmVpZ25GaWVsZCk7XG4gICAgfVxuICAgIGNvbnN0IG1hdGNoID0gY3JlYXRlUG9wdWxhdGVRdWVyeUZpbHRlcihpZHMsIG1vZC5tYXRjaCwgbW9kLmZvcmVpZ25GaWVsZCwgbW9kLm1vZGVsLCBtb2Qub3B0aW9ucy5za2lwSW52YWxpZElkcyk7XG4gICAgaWYgKGFzc2lnbm1lbnRPcHRzLmV4Y2x1ZGVJZCkge1xuICAgICAgLy8gb3ZlcnJpZGUgdGhlIGV4Y2x1c2lvbiBmcm9tIHRoZSBxdWVyeSBzbyB3ZSBjYW4gdXNlIHRoZSBfaWRcbiAgICAgIC8vIGZvciBkb2N1bWVudCBtYXRjaGluZyBkdXJpbmcgYXNzaWdubWVudC4gd2UnbGwgZGVsZXRlIHRoZVxuICAgICAgLy8gX2lkIGJhY2sgb2ZmIGJlZm9yZSByZXR1cm5pbmcgdGhlIHJlc3VsdC5cbiAgICAgIGlmICh0eXBlb2Ygc2VsZWN0ID09PSAnc3RyaW5nJykge1xuICAgICAgICBzZWxlY3QgPSBzZWxlY3QucmVwbGFjZShleGNsdWRlSWRSZWdHbG9iYWwsICcgJyk7XG4gICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoc2VsZWN0KSkge1xuICAgICAgICBzZWxlY3QgPSBzZWxlY3QuZmlsdGVyKGZpZWxkID0+IGZpZWxkICE9PSAnLV9pZCcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gcHJlc2VydmUgb3JpZ2luYWwgc2VsZWN0IGNvbmRpdGlvbnMgYnkgY29weWluZ1xuICAgICAgICBzZWxlY3QgPSB7IC4uLnNlbGVjdCB9O1xuICAgICAgICBkZWxldGUgc2VsZWN0Ll9pZDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAobW9kLm9wdGlvbnMub3B0aW9ucyAmJiBtb2Qub3B0aW9ucy5vcHRpb25zLmxpbWl0ICE9IG51bGwpIHtcbiAgICAgIGFzc2lnbm1lbnRPcHRzLm9yaWdpbmFsTGltaXQgPSBtb2Qub3B0aW9ucy5vcHRpb25zLmxpbWl0O1xuICAgIH0gZWxzZSBpZiAobW9kLm9wdGlvbnMubGltaXQgIT0gbnVsbCkge1xuICAgICAgYXNzaWdubWVudE9wdHMub3JpZ2luYWxMaW1pdCA9IG1vZC5vcHRpb25zLmxpbWl0O1xuICAgIH1cbiAgICBwYXJhbXMucHVzaChbbW9kLCBtYXRjaCwgc2VsZWN0LCBhc3NpZ25tZW50T3B0cywgX25leHRdKTtcbiAgfVxuICBpZiAoIWhhc09uZSkge1xuICAgIC8vIElmIG1vZGVscyBidXQgbm8gZG9jcywgc2tpcCBmdXJ0aGVyIGRlZXAgcG9wdWxhdGUuXG4gICAgaWYgKG1vZGVsc01hcC5sZW5ndGggIT09IDApIHtcbiAgICAgIHJldHVybiBjYWxsYmFjaygpO1xuICAgIH1cbiAgICAvLyBJZiBubyBtb2RlbHMgdG8gcG9wdWxhdGUgYnV0IHdlIGhhdmUgYSBuZXN0ZWQgcG9wdWxhdGUsXG4gICAgLy8ga2VlcCB0cnlpbmcsIHJlOiBnaC04OTQ2XG4gICAgaWYgKHBvcHVsYXRlT3B0aW9ucy5wb3B1bGF0ZSAhPSBudWxsKSB7XG4gICAgICBjb25zdCBvcHRzID0gdXRpbHMucG9wdWxhdGUocG9wdWxhdGVPcHRpb25zLnBvcHVsYXRlKS5tYXAocG9wID0+IE9iamVjdC5hc3NpZ24oe30sIHBvcCwge1xuICAgICAgICBwYXRoOiBwb3B1bGF0ZU9wdGlvbnMucGF0aCArICcuJyArIHBvcC5wYXRoXG4gICAgICB9KSk7XG4gICAgICBtb2RlbC5wb3B1bGF0ZShkb2NzLCBvcHRzKS50aGVuKHJlcyA9PiB7IGNhbGxiYWNrKG51bGwsIHJlcyk7IH0sIGVyciA9PiB7IGNhbGxiYWNrKGVycik7IH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICByZXR1cm4gY2FsbGJhY2soKTtcbiAgfVxuXG4gIGZvciAoY29uc3QgYXJyIG9mIHBhcmFtcykge1xuICAgIF9leGVjUG9wdWxhdGVRdWVyeS5hcHBseShudWxsLCBhcnIpO1xuICB9XG4gIGZ1bmN0aW9uIF9uZXh0KGVyciwgdmFsc0Zyb21EYikge1xuICAgIGlmIChlcnIgIT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGNhbGxiYWNrKGVyciwgbnVsbCk7XG4gICAgfVxuICAgIHZhbHMgPSB2YWxzLmNvbmNhdCh2YWxzRnJvbURiKTtcbiAgICBpZiAoLS1fcmVtYWluaW5nID09PSAwKSB7XG4gICAgICBfZG9uZSgpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIF9kb25lKCkge1xuICAgIGZvciAoY29uc3QgYXJyIG9mIHBhcmFtcykge1xuICAgICAgY29uc3QgbW9kID0gYXJyWzBdO1xuICAgICAgY29uc3QgYXNzaWdubWVudE9wdHMgPSBhcnJbM107XG4gICAgICBmb3IgKGNvbnN0IHZhbCBvZiB2YWxzKSB7XG4gICAgICAgIG1vZC5vcHRpb25zLl9jaGlsZERvY3MucHVzaCh2YWwpO1xuICAgICAgfVxuICAgICAgdHJ5IHtcbiAgICAgICAgX2Fzc2lnbihtb2RlbCwgdmFscywgbW9kLCBhc3NpZ25tZW50T3B0cyk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZm9yIChjb25zdCBhcnIgb2YgcGFyYW1zKSB7XG4gICAgICByZW1vdmVEZXNlbGVjdGVkRm9yZWlnbkZpZWxkKGFyclswXS5mb3JlaWduRmllbGQsIGFyclswXS5vcHRpb25zLCB2YWxzKTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBhcnIgb2YgcGFyYW1zKSB7XG4gICAgICBjb25zdCBtb2QgPSBhcnJbMF07XG4gICAgICBpZiAobW9kLm9wdGlvbnMgJiYgbW9kLm9wdGlvbnMub3B0aW9ucyAmJiBtb2Qub3B0aW9ucy5vcHRpb25zLl9sZWFuVHJhbnNmb3JtKSB7XG4gICAgICAgIGZvciAoY29uc3QgZG9jIG9mIHZhbHMpIHtcbiAgICAgICAgICBtb2Qub3B0aW9ucy5vcHRpb25zLl9sZWFuVHJhbnNmb3JtKGRvYyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgY2FsbGJhY2soKTtcbiAgfVxufVxuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cbmZ1bmN0aW9uIF9leGVjUG9wdWxhdGVRdWVyeShtb2QsIG1hdGNoLCBzZWxlY3QsIGFzc2lnbm1lbnRPcHRzLCBjYWxsYmFjaykge1xuICBsZXQgc3ViUG9wdWxhdGUgPSBjbG9uZShtb2Qub3B0aW9ucy5wb3B1bGF0ZSk7XG4gIGNvbnN0IHF1ZXJ5T3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe1xuICAgIHNraXA6IG1vZC5vcHRpb25zLnNraXAsXG4gICAgbGltaXQ6IG1vZC5vcHRpb25zLmxpbWl0LFxuICAgIHBlckRvY3VtZW50TGltaXQ6IG1vZC5vcHRpb25zLnBlckRvY3VtZW50TGltaXRcbiAgfSwgbW9kLm9wdGlvbnMub3B0aW9ucyk7XG5cbiAgaWYgKG1vZC5jb3VudCkge1xuICAgIGRlbGV0ZSBxdWVyeU9wdGlvbnMuc2tpcDtcbiAgfVxuXG4gIGlmIChxdWVyeU9wdGlvbnMucGVyRG9jdW1lbnRMaW1pdCAhPSBudWxsKSB7XG4gICAgcXVlcnlPcHRpb25zLmxpbWl0ID0gcXVlcnlPcHRpb25zLnBlckRvY3VtZW50TGltaXQ7XG4gICAgZGVsZXRlIHF1ZXJ5T3B0aW9ucy5wZXJEb2N1bWVudExpbWl0O1xuICB9IGVsc2UgaWYgKHF1ZXJ5T3B0aW9ucy5saW1pdCAhPSBudWxsKSB7XG4gICAgcXVlcnlPcHRpb25zLmxpbWl0ID0gcXVlcnlPcHRpb25zLmxpbWl0ICogbW9kLmlkcy5sZW5ndGg7XG4gIH1cblxuICBjb25zdCBxdWVyeSA9IG1vZC5tb2RlbC5maW5kKG1hdGNoLCBzZWxlY3QsIHF1ZXJ5T3B0aW9ucyk7XG4gIC8vIElmIHdlJ3JlIGRvaW5nIHZpcnR1YWwgcG9wdWxhdGUgYW5kIHByb2plY3Rpb24gaXMgaW5jbHVzaXZlIGFuZCBmb3JlaWduXG4gIC8vIGZpZWxkIGlzIG5vdCBzZWxlY3RlZCwgYXV0b21hdGljYWxseSBzZWxlY3QgaXQgYmVjYXVzZSBtb25nb29zZSBuZWVkcyBpdC5cbiAgLy8gSWYgcHJvamVjdGlvbiBpcyBleGNsdXNpdmUgYW5kIGNsaWVudCBleHBsaWNpdGx5IHVuc2VsZWN0ZWQgdGhlIGZvcmVpZ25cbiAgLy8gZmllbGQsIHRoYXQncyB0aGUgY2xpZW50J3MgZmF1bHQuXG4gIGZvciAoY29uc3QgZm9yZWlnbkZpZWxkIG9mIG1vZC5mb3JlaWduRmllbGQpIHtcbiAgICBpZiAoZm9yZWlnbkZpZWxkICE9PSAnX2lkJyAmJlxuICAgICAgICBxdWVyeS5zZWxlY3RlZEluY2x1c2l2ZWx5KCkgJiZcbiAgICAgICAgIWlzUGF0aFNlbGVjdGVkSW5jbHVzaXZlKHF1ZXJ5Ll9maWVsZHMsIGZvcmVpZ25GaWVsZCkpIHtcbiAgICAgIHF1ZXJ5LnNlbGVjdChmb3JlaWduRmllbGQpO1xuICAgIH1cbiAgfVxuXG4gIC8vIElmIHVzaW5nIGNvdW50LCBzdGlsbCBuZWVkIHRoZSBgZm9yZWlnbkZpZWxkYCBzbyB3ZSBjYW4gbWF0Y2ggY291bnRzXG4gIC8vIHRvIGRvY3VtZW50cywgb3RoZXJ3aXNlIHdlIHdvdWxkIG5lZWQgYSBzZXBhcmF0ZSBgY291bnQoKWAgZm9yIGV2ZXJ5IGRvYy5cbiAgaWYgKG1vZC5jb3VudCkge1xuICAgIGZvciAoY29uc3QgZm9yZWlnbkZpZWxkIG9mIG1vZC5mb3JlaWduRmllbGQpIHtcbiAgICAgIHF1ZXJ5LnNlbGVjdChmb3JlaWduRmllbGQpO1xuICAgIH1cbiAgfVxuXG4gIC8vIElmIHdlIG5lZWQgdG8gc3ViLXBvcHVsYXRlLCBjYWxsIHBvcHVsYXRlIHJlY3Vyc2l2ZWx5XG4gIGlmIChzdWJQb3B1bGF0ZSkge1xuICAgIC8vIElmIHN1YnBvcHVsYXRpbmcgb24gYSBkaXNjcmltaW5hdG9yLCBza2lwIGNoZWNrIGZvciBub24tZXhpc3RlbnRcbiAgICAvLyBwYXRocy4gQmVjYXVzZSB0aGUgZGlzY3JpbWluYXRvciBtYXkgbm90IGhhdmUgdGhlIHBhdGggZGVmaW5lZC5cbiAgICBpZiAobW9kLm1vZGVsLmJhc2VNb2RlbE5hbWUgIT0gbnVsbCkge1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoc3ViUG9wdWxhdGUpKSB7XG4gICAgICAgIHN1YlBvcHVsYXRlLmZvckVhY2gocG9wID0+IHsgcG9wLnN0cmljdFBvcHVsYXRlID0gZmFsc2U7IH0pO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2Ygc3ViUG9wdWxhdGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHN1YlBvcHVsYXRlID0geyBwYXRoOiBzdWJQb3B1bGF0ZSwgc3RyaWN0UG9wdWxhdGU6IGZhbHNlIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdWJQb3B1bGF0ZS5zdHJpY3RQb3B1bGF0ZSA9IGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBiYXNlUGF0aCA9IG1vZC5vcHRpb25zLl9mdWxsUGF0aCB8fCBtb2Qub3B0aW9ucy5wYXRoO1xuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoc3ViUG9wdWxhdGUpKSB7XG4gICAgICBmb3IgKGNvbnN0IHBvcCBvZiBzdWJQb3B1bGF0ZSkge1xuICAgICAgICBwb3AuX2Z1bGxQYXRoID0gYmFzZVBhdGggKyAnLicgKyBwb3AucGF0aDtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBzdWJQb3B1bGF0ZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIHN1YlBvcHVsYXRlLl9mdWxsUGF0aCA9IGJhc2VQYXRoICsgJy4nICsgc3ViUG9wdWxhdGUucGF0aDtcbiAgICB9XG5cbiAgICBxdWVyeS5wb3B1bGF0ZShzdWJQb3B1bGF0ZSk7XG4gIH1cblxuICBxdWVyeS5leGVjKCkudGhlbihcbiAgICBkb2NzID0+IHtcbiAgICAgIGZvciAoY29uc3QgdmFsIG9mIGRvY3MpIHtcbiAgICAgICAgbGVhblBvcHVsYXRlTWFwLnNldCh2YWwsIG1vZC5tb2RlbCk7XG4gICAgICB9XG4gICAgICBjYWxsYmFjayhudWxsLCBkb2NzKTtcbiAgICB9LFxuICAgIGVyciA9PiB7XG4gICAgICBjYWxsYmFjayhlcnIpO1xuICAgIH1cbiAgKTtcbn1cblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5mdW5jdGlvbiBfYXNzaWduKG1vZGVsLCB2YWxzLCBtb2QsIGFzc2lnbm1lbnRPcHRzKSB7XG4gIGNvbnN0IG9wdGlvbnMgPSBtb2Qub3B0aW9ucztcbiAgY29uc3QgaXNWaXJ0dWFsID0gbW9kLmlzVmlydHVhbDtcbiAgY29uc3QganVzdE9uZSA9IG1vZC5qdXN0T25lO1xuICBsZXQgX3ZhbDtcbiAgY29uc3QgbGVhbiA9IG9wdGlvbnMgJiZcbiAgICBvcHRpb25zLm9wdGlvbnMgJiZcbiAgICBvcHRpb25zLm9wdGlvbnMubGVhbiB8fCBmYWxzZTtcbiAgY29uc3QgbGVuID0gdmFscy5sZW5ndGg7XG4gIGNvbnN0IHJhd09yZGVyID0ge307XG4gIGNvbnN0IHJhd0RvY3MgPSB7fTtcbiAgbGV0IGtleTtcbiAgbGV0IHZhbDtcblxuICAvLyBDbG9uZSBiZWNhdXNlIGBhc3NpZ25SYXdEb2NzVG9JZFN0cnVjdHVyZWAgd2lsbCBtdXRhdGUgdGhlIGFycmF5XG4gIGNvbnN0IGFsbElkcyA9IGNsb25lKG1vZC5hbGxJZHMpO1xuICAvLyBvcHRpbWl6YXRpb246XG4gIC8vIHJlY29yZCB0aGUgZG9jdW1lbnQgcG9zaXRpb25zIGFzIHJldHVybmVkIGJ5XG4gIC8vIHRoZSBxdWVyeSByZXN1bHQuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICB2YWwgPSB2YWxzW2ldO1xuICAgIGlmICh2YWwgPT0gbnVsbCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGZvciAoY29uc3QgZm9yZWlnbkZpZWxkIG9mIG1vZC5mb3JlaWduRmllbGQpIHtcbiAgICAgIF92YWwgPSB1dGlscy5nZXRWYWx1ZShmb3JlaWduRmllbGQsIHZhbCk7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShfdmFsKSkge1xuICAgICAgICBfdmFsID0gdXRpbHMuYXJyYXkudW5pcXVlKHV0aWxzLmFycmF5LmZsYXR0ZW4oX3ZhbCkpO1xuXG4gICAgICAgIGZvciAobGV0IF9fdmFsIG9mIF92YWwpIHtcbiAgICAgICAgICBpZiAoX192YWwgaW5zdGFuY2VvZiBEb2N1bWVudCkge1xuICAgICAgICAgICAgX192YWwgPSBfX3ZhbC5faWQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGtleSA9IFN0cmluZyhfX3ZhbCk7XG4gICAgICAgICAgaWYgKHJhd0RvY3Nba2V5XSkge1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocmF3RG9jc1trZXldKSkge1xuICAgICAgICAgICAgICByYXdEb2NzW2tleV0ucHVzaCh2YWwpO1xuICAgICAgICAgICAgICByYXdPcmRlcltrZXldLnB1c2goaSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByYXdEb2NzW2tleV0gPSBbcmF3RG9jc1trZXldLCB2YWxdO1xuICAgICAgICAgICAgICByYXdPcmRlcltrZXldID0gW3Jhd09yZGVyW2tleV0sIGldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoaXNWaXJ0dWFsICYmICFqdXN0T25lKSB7XG4gICAgICAgICAgICAgIHJhd0RvY3Nba2V5XSA9IFt2YWxdO1xuICAgICAgICAgICAgICByYXdPcmRlcltrZXldID0gW2ldO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmF3RG9jc1trZXldID0gdmFsO1xuICAgICAgICAgICAgICByYXdPcmRlcltrZXldID0gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChfdmFsIGluc3RhbmNlb2YgRG9jdW1lbnQpIHtcbiAgICAgICAgICBfdmFsID0gX3ZhbC5faWQ7XG4gICAgICAgIH1cbiAgICAgICAga2V5ID0gU3RyaW5nKF92YWwpO1xuICAgICAgICBpZiAocmF3RG9jc1trZXldKSB7XG4gICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocmF3RG9jc1trZXldKSkge1xuICAgICAgICAgICAgcmF3RG9jc1trZXldLnB1c2godmFsKTtcbiAgICAgICAgICAgIHJhd09yZGVyW2tleV0ucHVzaChpKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGlzVmlydHVhbCB8fFxuICAgICAgICAgICAgcmF3RG9jc1trZXldLmNvbnN0cnVjdG9yICE9PSB2YWwuY29uc3RydWN0b3IgfHxcbiAgICAgICAgICAgIFN0cmluZyhyYXdEb2NzW2tleV0uX2lkKSAhPT0gU3RyaW5nKHZhbC5faWQpKSB7XG4gICAgICAgICAgICAvLyBNYXkgbmVlZCB0byBzdG9yZSBtdWx0aXBsZSBkb2NzIHdpdGggdGhlIHNhbWUgaWQgaWYgdGhlcmUncyBtdWx0aXBsZSBtb2RlbHNcbiAgICAgICAgICAgIC8vIGlmIHdlIGhhdmUgZGlzY3JpbWluYXRvcnMgb3IgYSByZWYgZnVuY3Rpb24uIEJ1dCBhdm9pZCBjb252ZXJ0aW5nIHRvIGFuIGFycmF5XG4gICAgICAgICAgICAvLyBpZiB3ZSBoYXZlIG11bHRpcGxlIHF1ZXJpZXMgb24gdGhlIHNhbWUgbW9kZWwgYmVjYXVzZSBvZiBgcGVyRG9jdW1lbnRMaW1pdGAgcmU6IGdoLTk5MDZcbiAgICAgICAgICAgIHJhd0RvY3Nba2V5XSA9IFtyYXdEb2NzW2tleV0sIHZhbF07XG4gICAgICAgICAgICByYXdPcmRlcltrZXldID0gW3Jhd09yZGVyW2tleV0sIGldO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByYXdEb2NzW2tleV0gPSB2YWw7XG4gICAgICAgICAgcmF3T3JkZXJba2V5XSA9IGk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIGZsYWcgZWFjaCBhcyByZXN1bHQgb2YgcG9wdWxhdGlvblxuICAgICAgaWYgKCFsZWFuKSB7XG4gICAgICAgIHZhbC4kX18ud2FzUG9wdWxhdGVkID0gdmFsLiRfXy53YXNQb3B1bGF0ZWQgfHwgdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBhc3NpZ25WYWxzKHtcbiAgICBvcmlnaW5hbE1vZGVsOiBtb2RlbCxcbiAgICAvLyBJZiB2aXJ0dWFsLCBtYWtlIHN1cmUgdG8gbm90IG11dGF0ZSBvcmlnaW5hbCBmaWVsZFxuICAgIHJhd0lkczogbW9kLmlzVmlydHVhbCA/IGFsbElkcyA6IG1vZC5hbGxJZHMsXG4gICAgYWxsSWRzOiBhbGxJZHMsXG4gICAgdW5wb3B1bGF0ZWRWYWx1ZXM6IG1vZC51bnBvcHVsYXRlZFZhbHVlcyxcbiAgICBmb3JlaWduRmllbGQ6IG1vZC5mb3JlaWduRmllbGQsXG4gICAgcmF3RG9jczogcmF3RG9jcyxcbiAgICByYXdPcmRlcjogcmF3T3JkZXIsXG4gICAgZG9jczogbW9kLmRvY3MsXG4gICAgcGF0aDogb3B0aW9ucy5wYXRoLFxuICAgIG9wdGlvbnM6IGFzc2lnbm1lbnRPcHRzLFxuICAgIGp1c3RPbmU6IG1vZC5qdXN0T25lLFxuICAgIGlzVmlydHVhbDogbW9kLmlzVmlydHVhbCxcbiAgICBhbGxPcHRpb25zOiBtb2QsXG4gICAgcG9wdWxhdGVkTW9kZWw6IG1vZC5tb2RlbCxcbiAgICBsZWFuOiBsZWFuLFxuICAgIHZpcnR1YWw6IG1vZC52aXJ0dWFsLFxuICAgIGNvdW50OiBtb2QuY291bnQsXG4gICAgbWF0Y2g6IG1vZC5tYXRjaFxuICB9KTtcbn1cblxuLyoqXG4gKiBDb21waWxlciB1dGlsaXR5LlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfEZ1bmN0aW9ufSBuYW1lIG1vZGVsIG5hbWUgb3IgY2xhc3MgZXh0ZW5kaW5nIE1vZGVsXG4gKiBAcGFyYW0ge1NjaGVtYX0gc2NoZW1hXG4gKiBAcGFyYW0ge1N0cmluZ30gY29sbGVjdGlvbk5hbWVcbiAqIEBwYXJhbSB7Q29ubmVjdGlvbn0gY29ubmVjdGlvblxuICogQHBhcmFtIHtNb25nb29zZX0gYmFzZSBtb25nb29zZSBpbnN0YW5jZVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuTW9kZWwuY29tcGlsZSA9IGZ1bmN0aW9uIGNvbXBpbGUobmFtZSwgc2NoZW1hLCBjb2xsZWN0aW9uTmFtZSwgY29ubmVjdGlvbiwgYmFzZSkge1xuICBjb25zdCB2ZXJzaW9uaW5nRW5hYmxlZCA9IHNjaGVtYS5vcHRpb25zLnZlcnNpb25LZXkgIT09IGZhbHNlO1xuXG4gIGlmICh2ZXJzaW9uaW5nRW5hYmxlZCAmJiAhc2NoZW1hLnBhdGhzW3NjaGVtYS5vcHRpb25zLnZlcnNpb25LZXldKSB7XG4gICAgLy8gYWRkIHZlcnNpb25pbmcgdG8gdG9wIGxldmVsIGRvY3VtZW50cyBvbmx5XG4gICAgY29uc3QgbyA9IHt9O1xuICAgIG9bc2NoZW1hLm9wdGlvbnMudmVyc2lvbktleV0gPSBOdW1iZXI7XG4gICAgc2NoZW1hLmFkZChvKTtcbiAgfVxuICBsZXQgbW9kZWw7XG4gIGlmICh0eXBlb2YgbmFtZSA9PT0gJ2Z1bmN0aW9uJyAmJiBuYW1lLnByb3RvdHlwZSBpbnN0YW5jZW9mIE1vZGVsKSB7XG4gICAgbW9kZWwgPSBuYW1lO1xuICAgIG5hbWUgPSBtb2RlbC5uYW1lO1xuICAgIHNjaGVtYS5sb2FkQ2xhc3MobW9kZWwsIGZhbHNlKTtcbiAgICBtb2RlbC5wcm90b3R5cGUuJGlzTW9uZ29vc2VNb2RlbFByb3RvdHlwZSA9IHRydWU7XG4gIH0gZWxzZSB7XG4gICAgLy8gZ2VuZXJhdGUgbmV3IGNsYXNzXG4gICAgbW9kZWwgPSBmdW5jdGlvbiBtb2RlbChkb2MsIGZpZWxkcywgc2tpcElkKSB7XG4gICAgICBtb2RlbC5ob29rcy5leGVjUHJlU3luYygnY3JlYXRlTW9kZWwnLCBkb2MpO1xuICAgICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIG1vZGVsKSkge1xuICAgICAgICByZXR1cm4gbmV3IG1vZGVsKGRvYywgZmllbGRzLCBza2lwSWQpO1xuICAgICAgfVxuICAgICAgY29uc3QgZGlzY3JpbWluYXRvcktleSA9IG1vZGVsLnNjaGVtYS5vcHRpb25zLmRpc2NyaW1pbmF0b3JLZXk7XG5cbiAgICAgIGlmIChtb2RlbC5kaXNjcmltaW5hdG9ycyA9PSBudWxsIHx8IGRvYyA9PSBudWxsIHx8IGRvY1tkaXNjcmltaW5hdG9yS2V5XSA9PSBudWxsKSB7XG4gICAgICAgIE1vZGVsLmNhbGwodGhpcywgZG9jLCBmaWVsZHMsIHNraXBJZCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gSWYgZGlzY3JpbWluYXRvciBrZXkgaXMgc2V0LCB1c2UgdGhlIGRpc2NyaW1pbmF0b3IgaW5zdGVhZCAoZ2gtNzU4NilcbiAgICAgIGNvbnN0IERpc2NyaW1pbmF0b3IgPSBtb2RlbC5kaXNjcmltaW5hdG9yc1tkb2NbZGlzY3JpbWluYXRvcktleV1dIHx8XG4gICAgICAgIGdldERpc2NyaW1pbmF0b3JCeVZhbHVlKG1vZGVsLmRpc2NyaW1pbmF0b3JzLCBkb2NbZGlzY3JpbWluYXRvcktleV0pO1xuICAgICAgaWYgKERpc2NyaW1pbmF0b3IgIT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbmV3IERpc2NyaW1pbmF0b3IoZG9jLCBmaWVsZHMsIHNraXBJZCk7XG4gICAgICB9XG5cbiAgICAgIC8vIE90aGVyd2lzZSwganVzdCB1c2UgdGhlIHRvcC1sZXZlbCBtb2RlbFxuICAgICAgTW9kZWwuY2FsbCh0aGlzLCBkb2MsIGZpZWxkcywgc2tpcElkKTtcbiAgICB9O1xuICB9XG5cbiAgbW9kZWwuaG9va3MgPSBzY2hlbWEucy5ob29rcy5jbG9uZSgpO1xuICBtb2RlbC5iYXNlID0gYmFzZTtcbiAgbW9kZWwubW9kZWxOYW1lID0gbmFtZTtcblxuICBpZiAoIShtb2RlbC5wcm90b3R5cGUgaW5zdGFuY2VvZiBNb2RlbCkpIHtcbiAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YobW9kZWwsIE1vZGVsKTtcbiAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YobW9kZWwucHJvdG90eXBlLCBNb2RlbC5wcm90b3R5cGUpO1xuICB9XG4gIG1vZGVsLm1vZGVsID0gZnVuY3Rpb24gbW9kZWwobmFtZSkge1xuICAgIHJldHVybiB0aGlzLmRiLm1vZGVsKG5hbWUpO1xuICB9O1xuXG4gIG1vZGVsLmRiID0gY29ubmVjdGlvbjtcbiAgbW9kZWwucHJvdG90eXBlLmRiID0gY29ubmVjdGlvbjtcbiAgbW9kZWwucHJvdG90eXBlW21vZGVsRGJTeW1ib2xdID0gY29ubmVjdGlvbjtcbiAgbW9kZWwuZGlzY3JpbWluYXRvcnMgPSBtb2RlbC5wcm90b3R5cGUuZGlzY3JpbWluYXRvcnMgPSB1bmRlZmluZWQ7XG4gIG1vZGVsW21vZGVsU3ltYm9sXSA9IHRydWU7XG4gIG1vZGVsLmV2ZW50cyA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcblxuICBzY2hlbWEuX3ByZUNvbXBpbGUoKTtcblxuICBjb25zdCBfdXNlclByb3ZpZGVkT3B0aW9ucyA9IHNjaGVtYS5fdXNlclByb3ZpZGVkT3B0aW9ucyB8fCB7fTtcblxuICBjb25zdCBjb2xsZWN0aW9uT3B0aW9ucyA9IHtcbiAgICBzY2hlbWFVc2VyUHJvdmlkZWRPcHRpb25zOiBfdXNlclByb3ZpZGVkT3B0aW9ucyxcbiAgICBjYXBwZWQ6IHNjaGVtYS5vcHRpb25zLmNhcHBlZCxcbiAgICBQcm9taXNlOiBtb2RlbC5iYXNlLlByb21pc2UsXG4gICAgbW9kZWxOYW1lOiBuYW1lXG4gIH07XG4gIGlmIChzY2hlbWEub3B0aW9ucy5hdXRvQ3JlYXRlICE9PSB2b2lkIDApIHtcbiAgICBjb2xsZWN0aW9uT3B0aW9ucy5hdXRvQ3JlYXRlID0gc2NoZW1hLm9wdGlvbnMuYXV0b0NyZWF0ZTtcbiAgfVxuXG4gIGNvbnN0IGNvbGxlY3Rpb24gPSBjb25uZWN0aW9uLmNvbGxlY3Rpb24oXG4gICAgY29sbGVjdGlvbk5hbWUsXG4gICAgY29sbGVjdGlvbk9wdGlvbnNcbiAgKTtcblxuICBtb2RlbC5wcm90b3R5cGUuY29sbGVjdGlvbiA9IGNvbGxlY3Rpb247XG4gIG1vZGVsLnByb3RvdHlwZS4kY29sbGVjdGlvbiA9IGNvbGxlY3Rpb247XG4gIG1vZGVsLnByb3RvdHlwZVttb2RlbENvbGxlY3Rpb25TeW1ib2xdID0gY29sbGVjdGlvbjtcblxuICBtb2RlbC5wcm90b3R5cGUuJF9fc2V0U2NoZW1hKHNjaGVtYSk7XG5cbiAgLy8gYXBwbHkgbWV0aG9kcyBhbmQgc3RhdGljc1xuICBhcHBseU1ldGhvZHMobW9kZWwsIHNjaGVtYSk7XG4gIGFwcGx5U3RhdGljcyhtb2RlbCwgc2NoZW1hKTtcbiAgYXBwbHlIb29rcyhtb2RlbCwgc2NoZW1hKTtcbiAgYXBwbHlTdGF0aWNIb29rcyhtb2RlbCwgc2NoZW1hLnMuaG9va3MsIHNjaGVtYS5zdGF0aWNzKTtcblxuICBtb2RlbC5zY2hlbWEgPSBtb2RlbC5wcm90b3R5cGUuJF9fc2NoZW1hO1xuICBtb2RlbC5jb2xsZWN0aW9uID0gY29sbGVjdGlvbjtcbiAgbW9kZWwuJF9fY29sbGVjdGlvbiA9IGNvbGxlY3Rpb247XG5cbiAgLy8gQ3JlYXRlIGN1c3RvbSBxdWVyeSBjb25zdHJ1Y3RvclxuICBtb2RlbC5RdWVyeSA9IGZ1bmN0aW9uKCkge1xuICAgIFF1ZXJ5LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH07XG4gIE9iamVjdC5zZXRQcm90b3R5cGVPZihtb2RlbC5RdWVyeS5wcm90b3R5cGUsIFF1ZXJ5LnByb3RvdHlwZSk7XG4gIG1vZGVsLlF1ZXJ5LmJhc2UgPSBRdWVyeS5iYXNlO1xuICBtb2RlbC5RdWVyeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBRdWVyeTtcbiAgbW9kZWwuX2FwcGx5UXVlcnlNaWRkbGV3YXJlKCk7XG4gIGFwcGx5UXVlcnlNZXRob2RzKG1vZGVsLCBzY2hlbWEucXVlcnkpO1xuXG4gIHJldHVybiBtb2RlbDtcbn07XG5cbi8qKlxuICogUmVnaXN0ZXIgY3VzdG9tIHF1ZXJ5IG1ldGhvZHMgZm9yIHRoaXMgbW9kZWxcbiAqXG4gKiBAcGFyYW0ge01vZGVsfSBtb2RlbFxuICogQHBhcmFtIHtTY2hlbWF9IHNjaGVtYVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gYXBwbHlRdWVyeU1ldGhvZHMobW9kZWwsIG1ldGhvZHMpIHtcbiAgZm9yIChjb25zdCBpIGluIG1ldGhvZHMpIHtcbiAgICBtb2RlbC5RdWVyeS5wcm90b3R5cGVbaV0gPSBtZXRob2RzW2ldO1xuICB9XG59XG5cbi8qKlxuICogU3ViY2xhc3MgdGhpcyBtb2RlbCB3aXRoIGBjb25uYCwgYHNjaGVtYWAsIGFuZCBgY29sbGVjdGlvbmAgc2V0dGluZ3MuXG4gKlxuICogQHBhcmFtIHtDb25uZWN0aW9ufSBjb25uXG4gKiBAcGFyYW0ge1NjaGVtYX0gW3NjaGVtYV1cbiAqIEBwYXJhbSB7U3RyaW5nfSBbY29sbGVjdGlvbl1cbiAqIEByZXR1cm4ge01vZGVsfVxuICogQGFwaSBwcml2YXRlXG4gKiBAbWVtYmVyT2YgTW9kZWxcbiAqIEBzdGF0aWNcbiAqIEBtZXRob2QgX19zdWJjbGFzc1xuICovXG5cbk1vZGVsLl9fc3ViY2xhc3MgPSBmdW5jdGlvbiBzdWJjbGFzcyhjb25uLCBzY2hlbWEsIGNvbGxlY3Rpb24pIHtcbiAgLy8gc3ViY2xhc3MgbW9kZWwgdXNpbmcgdGhpcyBjb25uZWN0aW9uIGFuZCBjb2xsZWN0aW9uIG5hbWVcbiAgY29uc3QgX3RoaXMgPSB0aGlzO1xuXG4gIGNvbnN0IE1vZGVsID0gZnVuY3Rpb24gTW9kZWwoZG9jLCBmaWVsZHMsIHNraXBJZCkge1xuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBNb2RlbCkpIHtcbiAgICAgIHJldHVybiBuZXcgTW9kZWwoZG9jLCBmaWVsZHMsIHNraXBJZCk7XG4gICAgfVxuICAgIF90aGlzLmNhbGwodGhpcywgZG9jLCBmaWVsZHMsIHNraXBJZCk7XG4gIH07XG5cbiAgT2JqZWN0LnNldFByb3RvdHlwZU9mKE1vZGVsLCBfdGhpcyk7XG4gIE9iamVjdC5zZXRQcm90b3R5cGVPZihNb2RlbC5wcm90b3R5cGUsIF90aGlzLnByb3RvdHlwZSk7XG4gIE1vZGVsLmRiID0gY29ubjtcbiAgTW9kZWwucHJvdG90eXBlLmRiID0gY29ubjtcbiAgTW9kZWwucHJvdG90eXBlW21vZGVsRGJTeW1ib2xdID0gY29ubjtcblxuICBfdGhpc1tzdWJjbGFzc2VkU3ltYm9sXSA9IF90aGlzW3N1YmNsYXNzZWRTeW1ib2xdIHx8IFtdO1xuICBfdGhpc1tzdWJjbGFzc2VkU3ltYm9sXS5wdXNoKE1vZGVsKTtcbiAgaWYgKF90aGlzLmRpc2NyaW1pbmF0b3JzICE9IG51bGwpIHtcbiAgICBNb2RlbC5kaXNjcmltaW5hdG9ycyA9IHt9O1xuICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKF90aGlzLmRpc2NyaW1pbmF0b3JzKSkge1xuICAgICAgTW9kZWwuZGlzY3JpbWluYXRvcnNba2V5XSA9IF90aGlzLmRpc2NyaW1pbmF0b3JzW2tleV0uXG4gICAgICAgIF9fc3ViY2xhc3MoX3RoaXMuZGIsIF90aGlzLmRpc2NyaW1pbmF0b3JzW2tleV0uc2NoZW1hLCBjb2xsZWN0aW9uKTtcbiAgICB9XG4gIH1cblxuICBjb25zdCBzID0gc2NoZW1hICYmIHR5cGVvZiBzY2hlbWEgIT09ICdzdHJpbmcnXG4gICAgPyBzY2hlbWFcbiAgICA6IF90aGlzLnByb3RvdHlwZS4kX19zY2hlbWE7XG5cbiAgY29uc3Qgb3B0aW9ucyA9IHMub3B0aW9ucyB8fCB7fTtcbiAgY29uc3QgX3VzZXJQcm92aWRlZE9wdGlvbnMgPSBzLl91c2VyUHJvdmlkZWRPcHRpb25zIHx8IHt9O1xuXG4gIGlmICghY29sbGVjdGlvbikge1xuICAgIGNvbGxlY3Rpb24gPSBfdGhpcy5wcm90b3R5cGUuJF9fc2NoZW1hLmdldCgnY29sbGVjdGlvbicpIHx8XG4gICAgICB1dGlscy50b0NvbGxlY3Rpb25OYW1lKF90aGlzLm1vZGVsTmFtZSwgdGhpcy5iYXNlLnBsdXJhbGl6ZSgpKTtcbiAgfVxuXG4gIGNvbnN0IGNvbGxlY3Rpb25PcHRpb25zID0ge1xuICAgIHNjaGVtYVVzZXJQcm92aWRlZE9wdGlvbnM6IF91c2VyUHJvdmlkZWRPcHRpb25zLFxuICAgIGNhcHBlZDogcyAmJiBvcHRpb25zLmNhcHBlZFxuICB9O1xuXG4gIE1vZGVsLnByb3RvdHlwZS5jb2xsZWN0aW9uID0gY29ubi5jb2xsZWN0aW9uKGNvbGxlY3Rpb24sIGNvbGxlY3Rpb25PcHRpb25zKTtcbiAgTW9kZWwucHJvdG90eXBlLiRjb2xsZWN0aW9uID0gTW9kZWwucHJvdG90eXBlLmNvbGxlY3Rpb247XG4gIE1vZGVsLnByb3RvdHlwZVttb2RlbENvbGxlY3Rpb25TeW1ib2xdID0gTW9kZWwucHJvdG90eXBlLmNvbGxlY3Rpb247XG4gIE1vZGVsLmNvbGxlY3Rpb24gPSBNb2RlbC5wcm90b3R5cGUuY29sbGVjdGlvbjtcbiAgTW9kZWwuJF9fY29sbGVjdGlvbiA9IE1vZGVsLmNvbGxlY3Rpb247XG4gIC8vIEVycm9ycyBoYW5kbGVkIGludGVybmFsbHksIHNvIGlnbm9yZVxuICBNb2RlbC5pbml0KCkuY2F0Y2goKCkgPT4ge30pO1xuICByZXR1cm4gTW9kZWw7XG59O1xuXG4vKipcbiAqIEFwcGx5IGNoYW5nZXMgbWFkZSB0byB0aGlzIG1vZGVsJ3Mgc2NoZW1hIGFmdGVyIHRoaXMgbW9kZWwgd2FzIGNvbXBpbGVkLlxuICogQnkgZGVmYXVsdCwgYWRkaW5nIHZpcnR1YWxzIGFuZCBvdGhlciBwcm9wZXJ0aWVzIHRvIGEgc2NoZW1hIGFmdGVyIHRoZSBtb2RlbCBpcyBjb21waWxlZCBkb2VzIG5vdGhpbmcuXG4gKiBDYWxsIHRoaXMgZnVuY3Rpb24gdG8gYXBwbHkgdmlydHVhbHMgYW5kIHByb3BlcnRpZXMgdGhhdCB3ZXJlIGFkZGVkIGxhdGVyLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgY29uc3Qgc2NoZW1hID0gbmV3IG1vbmdvb3NlLlNjaGVtYSh7IGZpZWxkOiBTdHJpbmcgfSk7XG4gKiAgICAgY29uc3QgVGVzdE1vZGVsID0gbW9uZ29vc2UubW9kZWwoJ1Rlc3QnLCBzY2hlbWEpO1xuICogICAgIFRlc3RNb2RlbC5zY2hlbWEudmlydHVhbCgnbXlWaXJ0dWFsJykuZ2V0KGZ1bmN0aW9uKCkge1xuICogICAgICAgcmV0dXJuIHRoaXMuZmllbGQgKyAnIGZyb20gbXlWaXJ0dWFsJztcbiAqICAgICB9KTtcbiAqICAgICBjb25zdCBkb2MgPSBuZXcgVGVzdE1vZGVsKHsgZmllbGQ6ICdIZWxsbycgfSk7XG4gKiAgICAgZG9jLm15VmlydHVhbDsgLy8gdW5kZWZpbmVkXG4gKlxuICogICAgIFRlc3RNb2RlbC5yZWNvbXBpbGVTY2hlbWEoKTtcbiAqICAgICBkb2MubXlWaXJ0dWFsOyAvLyAnSGVsbG8gZnJvbSBteVZpcnR1YWwnXG4gKlxuICogQHJldHVybiB7dW5kZWZpbmVkfVxuICogQGFwaSBwdWJsaWNcbiAqIEBtZW1iZXJPZiBNb2RlbFxuICogQHN0YXRpY1xuICogQG1ldGhvZCByZWNvbXBpbGVTY2hlbWFcbiAqL1xuXG5Nb2RlbC5yZWNvbXBpbGVTY2hlbWEgPSBmdW5jdGlvbiByZWNvbXBpbGVTY2hlbWEoKSB7XG4gIHRoaXMucHJvdG90eXBlLiRfX3NldFNjaGVtYSh0aGlzLnNjaGVtYSk7XG59O1xuXG4vKipcbiAqIEhlbHBlciBmb3IgY29uc29sZS5sb2cuIEdpdmVuIGEgbW9kZWwgbmFtZWQgJ015TW9kZWwnLCByZXR1cm5zIHRoZSBzdHJpbmdcbiAqIGAnTW9kZWwgeyBNeU1vZGVsIH0nYC5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IE15TW9kZWwgPSBtb25nb29zZS5tb2RlbCgnVGVzdCcsIFNjaGVtYSh7IG5hbWU6IFN0cmluZyB9KSk7XG4gKiAgICAgTXlNb2RlbC5pbnNwZWN0KCk7IC8vICdNb2RlbCB7IFRlc3QgfSdcbiAqICAgICBjb25zb2xlLmxvZyhNeU1vZGVsKTsgLy8gUHJpbnRzICdNb2RlbCB7IFRlc3QgfSdcbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk1vZGVsLmluc3BlY3QgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIGBNb2RlbCB7ICR7dGhpcy5tb2RlbE5hbWV9IH1gO1xufTtcblxuaWYgKHV0aWwuaW5zcGVjdC5jdXN0b20pIHtcbiAgLy8gQXZvaWQgTm9kZSBkZXByZWNhdGlvbiB3YXJuaW5nIERFUDAwNzlcbiAgTW9kZWxbdXRpbC5pbnNwZWN0LmN1c3RvbV0gPSBNb2RlbC5pbnNwZWN0O1xufVxuXG4vKiFcbiAqIEFwcGxpZXMgcXVlcnkgbWlkZGxld2FyZSBmcm9tIHRoaXMgbW9kZWwncyBzY2hlbWEgdG8gdGhpcyBtb2RlbCdzXG4gKiBRdWVyeSBjb25zdHJ1Y3Rvci5cbiAqL1xuXG5Nb2RlbC5fYXBwbHlRdWVyeU1pZGRsZXdhcmUgPSBmdW5jdGlvbiBfYXBwbHlRdWVyeU1pZGRsZXdhcmUoKSB7XG4gIGNvbnN0IFF1ZXJ5ID0gdGhpcy5RdWVyeTtcbiAgY29uc3QgcXVlcnlNaWRkbGV3YXJlID0gdGhpcy5zY2hlbWEucy5ob29rcy5maWx0ZXIoaG9vayA9PiB7XG4gICAgY29uc3QgY29udGV4dHMgPSBfZ2V0Q29udGV4dHMoaG9vayk7XG4gICAgaWYgKGhvb2submFtZSA9PT0gJ3ZhbGlkYXRlJykge1xuICAgICAgcmV0dXJuICEhY29udGV4dHMucXVlcnk7XG4gICAgfVxuICAgIGlmIChob29rLm5hbWUgPT09ICdkZWxldGVPbmUnIHx8IGhvb2submFtZSA9PT0gJ3VwZGF0ZU9uZScpIHtcbiAgICAgIHJldHVybiAhIWNvbnRleHRzLnF1ZXJ5IHx8IE9iamVjdC5rZXlzKGNvbnRleHRzKS5sZW5ndGggPT09IDA7XG4gICAgfVxuICAgIGlmIChob29rLnF1ZXJ5ICE9IG51bGwgfHwgaG9vay5kb2N1bWVudCAhPSBudWxsKSB7XG4gICAgICByZXR1cm4gISFob29rLnF1ZXJ5O1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSk7XG5cbiAgUXVlcnkucHJvdG90eXBlLl9xdWVyeU1pZGRsZXdhcmUgPSBxdWVyeU1pZGRsZXdhcmU7XG59O1xuXG5mdW5jdGlvbiBfZ2V0Q29udGV4dHMoaG9vaykge1xuICBjb25zdCByZXQgPSB7fTtcbiAgaWYgKGhvb2suaGFzT3duUHJvcGVydHkoJ3F1ZXJ5JykpIHtcbiAgICByZXQucXVlcnkgPSBob29rLnF1ZXJ5O1xuICB9XG4gIGlmIChob29rLmhhc093blByb3BlcnR5KCdkb2N1bWVudCcpKSB7XG4gICAgcmV0LmRvY3VtZW50ID0gaG9vay5kb2N1bWVudDtcbiAgfVxuICByZXR1cm4gcmV0O1xufVxuXG4vKiFcbiAqIE1vZHVsZSBleHBvcnRzLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IE1vZGVsO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../server/node_modules/mongoose/lib/model.js\n");

/***/ }),

/***/ "../server/node_modules/mongoose/lib/mongoose.js":
/*!*******************************************************!*\
  !*** ../server/node_modules/mongoose/lib/mongoose.js ***!
  \*******************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("\n\n/*!\n * Module dependencies.\n */\n\nconst Document = __webpack_require__(/*! ./document */ \"../server/node_modules/mongoose/lib/document.js\");\nconst EventEmitter = (__webpack_require__(/*! events */ \"events\").EventEmitter);\nconst Kareem = __webpack_require__(/*! kareem */ \"../server/node_modules/kareem/index.js\");\nconst Schema = __webpack_require__(/*! ./schema */ \"../server/node_modules/mongoose/lib/schema.js\");\nconst SchemaType = __webpack_require__(/*! ./schemaType */ \"../server/node_modules/mongoose/lib/schemaType.js\");\nconst SchemaTypes = __webpack_require__(/*! ./schema/index */ \"../server/node_modules/mongoose/lib/schema/index.js\");\nconst VirtualType = __webpack_require__(/*! ./virtualType */ \"../server/node_modules/mongoose/lib/virtualType.js\");\nconst STATES = __webpack_require__(/*! ./connectionState */ \"../server/node_modules/mongoose/lib/connectionState.js\");\nconst VALID_OPTIONS = __webpack_require__(/*! ./validOptions */ \"../server/node_modules/mongoose/lib/validOptions.js\");\nconst Types = __webpack_require__(/*! ./types */ \"../server/node_modules/mongoose/lib/types/index.js\");\nconst Query = __webpack_require__(/*! ./query */ \"../server/node_modules/mongoose/lib/query.js\");\nconst Model = __webpack_require__(/*! ./model */ \"../server/node_modules/mongoose/lib/model.js\");\nconst applyPlugins = __webpack_require__(/*! ./helpers/schema/applyPlugins */ \"../server/node_modules/mongoose/lib/helpers/schema/applyPlugins.js\");\nconst builtinPlugins = __webpack_require__(/*! ./plugins */ \"../server/node_modules/mongoose/lib/plugins/index.js\");\nconst driver = __webpack_require__(/*! ./driver */ \"../server/node_modules/mongoose/lib/driver.js\");\nconst legacyPluralize = __webpack_require__(/*! ./helpers/pluralize */ \"../server/node_modules/mongoose/lib/helpers/pluralize.js\");\nconst utils = __webpack_require__(/*! ./utils */ \"../server/node_modules/mongoose/lib/utils.js\");\nconst pkg = __webpack_require__(/*! ../package.json */ \"../server/node_modules/mongoose/package.json\");\nconst cast = __webpack_require__(/*! ./cast */ \"../server/node_modules/mongoose/lib/cast.js\");\n\nconst Aggregate = __webpack_require__(/*! ./aggregate */ \"../server/node_modules/mongoose/lib/aggregate.js\");\nconst trusted = (__webpack_require__(/*! ./helpers/query/trusted */ \"../server/node_modules/mongoose/lib/helpers/query/trusted.js\").trusted);\nconst sanitizeFilter = __webpack_require__(/*! ./helpers/query/sanitizeFilter */ \"../server/node_modules/mongoose/lib/helpers/query/sanitizeFilter.js\");\nconst isBsonType = __webpack_require__(/*! ./helpers/isBsonType */ \"../server/node_modules/mongoose/lib/helpers/isBsonType.js\");\nconst MongooseError = __webpack_require__(/*! ./error/mongooseError */ \"../server/node_modules/mongoose/lib/error/mongooseError.js\");\nconst SetOptionError = __webpack_require__(/*! ./error/setOptionError */ \"../server/node_modules/mongoose/lib/error/setOptionError.js\");\nconst applyEmbeddedDiscriminators = __webpack_require__(/*! ./helpers/discriminator/applyEmbeddedDiscriminators */ \"../server/node_modules/mongoose/lib/helpers/discriminator/applyEmbeddedDiscriminators.js\");\n\nconst defaultMongooseSymbol = Symbol.for('mongoose:default');\n\n__webpack_require__(/*! ./helpers/printJestWarning */ \"../server/node_modules/mongoose/lib/helpers/printJestWarning.js\");\n\nconst objectIdHexRegexp = /^[0-9A-Fa-f]{24}$/;\n\n/**\n * Mongoose constructor.\n *\n * The exports object of the `mongoose` module is an instance of this class.\n * Most apps will only use this one instance.\n *\n * #### Example:\n *\n *     const mongoose = require('mongoose');\n *     mongoose instanceof mongoose.Mongoose; // true\n *\n *     // Create a new Mongoose instance with its own `connect()`, `set()`, `model()`, etc.\n *     const m = new mongoose.Mongoose();\n *\n * @api public\n * @param {Object} options see [`Mongoose#set()` docs](https://mongoosejs.com/docs/api/mongoose.html#Mongoose.prototype.set())\n */\nfunction Mongoose(options) {\n  this.connections = [];\n  this.nextConnectionId = 0;\n  this.models = {};\n  this.events = new EventEmitter();\n  this.__driver = driver.get();\n  // default global options\n  this.options = Object.assign({\n    pluralization: true,\n    autoIndex: true,\n    autoCreate: true,\n    autoSearchIndex: false\n  }, options);\n  const createInitialConnection = utils.getOption('createInitialConnection', this.options);\n  if (createInitialConnection == null || createInitialConnection) {\n    const conn = this.createConnection(); // default connection\n    conn.models = this.models;\n  }\n\n  if (this.options.pluralization) {\n    this._pluralize = legacyPluralize;\n  }\n\n  // If a user creates their own Mongoose instance, give them a separate copy\n  // of the `Schema` constructor so they get separate custom types. (gh-6933)\n  if (!options || !options[defaultMongooseSymbol]) {\n    const _this = this;\n    this.Schema = function() {\n      this.base = _this;\n      return Schema.apply(this, arguments);\n    };\n    this.Schema.prototype = Object.create(Schema.prototype);\n\n    Object.assign(this.Schema, Schema);\n    this.Schema.base = this;\n    this.Schema.Types = Object.assign({}, Schema.Types);\n  } else {\n    // Hack to work around babel's strange behavior with\n    // `import mongoose, { Schema } from 'mongoose'`. Because `Schema` is not\n    // an own property of a Mongoose global, Schema will be undefined. See gh-5648\n    for (const key of ['Schema', 'model']) {\n      this[key] = Mongoose.prototype[key];\n    }\n  }\n  this.Schema.prototype.base = this;\n\n  Object.defineProperty(this, 'plugins', {\n    configurable: false,\n    enumerable: true,\n    writable: false,\n    value: Object.values(builtinPlugins).map(plugin => ([plugin, { deduplicate: true }]))\n  });\n}\n\nMongoose.prototype.cast = cast;\n/**\n * Expose connection states for user-land\n *\n * @memberOf Mongoose\n * @property STATES\n * @api public\n */\nMongoose.prototype.STATES = STATES;\n\n/**\n * Expose connection states for user-land\n *\n * @memberOf Mongoose\n * @property ConnectionStates\n * @api public\n */\nMongoose.prototype.ConnectionStates = STATES;\n\n/**\n * Object with `get()` and `set()` containing the underlying driver this Mongoose instance\n * uses to communicate with the database. A driver is a Mongoose-specific interface that defines functions\n * like `find()`.\n *\n * @deprecated\n * @memberOf Mongoose\n * @property driver\n * @api public\n */\n\nMongoose.prototype.driver = driver;\n\n/**\n * Overwrites the current driver used by this Mongoose instance. A driver is a\n * Mongoose-specific interface that defines functions like `find()`.\n *\n * @memberOf Mongoose\n * @method setDriver\n * @api public\n */\n\nMongoose.prototype.setDriver = function setDriver(driver) {\n  const _mongoose = this instanceof Mongoose ? this : mongoose;\n\n  if (_mongoose.__driver === driver) {\n    return _mongoose;\n  }\n\n  const openConnection = _mongoose.connections && _mongoose.connections.find(conn => conn.readyState !== STATES.disconnected);\n  if (openConnection) {\n    const msg = 'Cannot modify Mongoose driver if a connection is already open. ' +\n      'Call `mongoose.disconnect()` before modifying the driver';\n    throw new MongooseError(msg);\n  }\n  _mongoose.__driver = driver;\n\n  const Connection = driver.Connection;\n  _mongoose.connections = [new Connection(_mongoose)];\n  _mongoose.connections[0].models = _mongoose.models;\n\n  return _mongoose;\n};\n\n/**\n * Sets mongoose options\n *\n * `key` can be used a object to set multiple options at once.\n * If a error gets thrown for one option, other options will still be evaluated.\n *\n * #### Example:\n *\n *     mongoose.set('test', value) // sets the 'test' option to `value`\n *\n *     mongoose.set('debug', true) // enable logging collection methods + arguments to the console/file\n *\n *     mongoose.set('debug', function(collectionName, methodName, ...methodArgs) {}); // use custom function to log collection methods + arguments\n *\n *     mongoose.set({ debug: true, autoIndex: false }); // set multiple options at once\n *\n * Currently supported options are:\n * - `allowDiskUse`: Set to `true` to set `allowDiskUse` to true to all aggregation operations by default.\n * - `applyPluginsToChildSchemas`: `true` by default. Set to false to skip applying global plugins to child schemas\n * - `applyPluginsToDiscriminators`: `false` by default. Set to true to apply global plugins to discriminator schemas. This typically isn't necessary because plugins are applied to the base schema and discriminators copy all middleware, methods, statics, and properties from the base schema.\n * - `autoCreate`: Set to `true` to make Mongoose call [`Model.createCollection()`](https://mongoosejs.com/docs/api/model.html#Model.createCollection()) automatically when you create a model with `mongoose.model()` or `conn.model()`. This is useful for testing transactions, change streams, and other features that require the collection to exist.\n * - `autoIndex`: `true` by default. Set to false to disable automatic index creation for all models associated with this Mongoose instance.\n * - `bufferCommands`: enable/disable mongoose's buffering mechanism for all connections and models\n * - `bufferTimeoutMS`: If bufferCommands is on, this option sets the maximum amount of time Mongoose buffering will wait before throwing an error. If not specified, Mongoose will use 10000 (10 seconds).\n * - `cloneSchemas`: `false` by default. Set to `true` to `clone()` all schemas before compiling into a model.\n * - `debug`: If `true`, prints the operations mongoose sends to MongoDB to the console. If a writable stream is passed, it will log to that stream, without colorization. If a callback function is passed, it will receive the collection name, the method name, then all arguments passed to the method. For example, if you wanted to replicate the default logging, you could output from the callback `Mongoose: ${collectionName}.${methodName}(${methodArgs.join(', ')})`.\n * - `id`: If `true`, adds a `id` virtual to all schemas unless overwritten on a per-schema basis.\n * - `timestamps.createdAt.immutable`: `true` by default. If `false`, it will change the `createdAt` field to be [`immutable: false`](https://mongoosejs.com/docs/api/schematype.html#SchemaType.prototype.immutable) which means you can update the `createdAt`\n * - `maxTimeMS`: If set, attaches [maxTimeMS](https://www.mongodb.com/docs/manual/reference/operator/meta/maxTimeMS/) to every query\n * - `objectIdGetter`: `true` by default. Mongoose adds a getter to MongoDB ObjectId's called `_id` that returns `this` for convenience with populate. Set this to false to remove the getter.\n * - `overwriteModels`: Set to `true` to default to overwriting models with the same name when calling `mongoose.model()`, as opposed to throwing an `OverwriteModelError`.\n * - `returnOriginal`: If `false`, changes the default `returnOriginal` option to `findOneAndUpdate()`, `findByIdAndUpdate`, and `findOneAndReplace()` to false. This is equivalent to setting the `new` option to `true` for `findOneAndX()` calls by default. Read our [`findOneAndUpdate()` tutorial](https://mongoosejs.com/docs/tutorials/findoneandupdate.html) for more information.\n * - `runValidators`: `false` by default. Set to true to enable [update validators](https://mongoosejs.com/docs/validation.html#update-validators) for all validators by default.\n * - `sanitizeFilter`: `false` by default. Set to true to enable the [sanitization of the query filters](https://mongoosejs.com/docs/api/mongoose.html#Mongoose.prototype.sanitizeFilter()) against query selector injection attacks by wrapping any nested objects that have a property whose name starts with `$` in a `$eq`.\n * - `selectPopulatedPaths`: `true` by default. Set to false to opt out of Mongoose adding all fields that you `populate()` to your `select()`. The schema-level option `selectPopulatedPaths` overwrites this one.\n * - `strict`: `true` by default, may be `false`, `true`, or `'throw'`. Sets the default strict mode for schemas.\n * - `strictQuery`: `false` by default. May be `false`, `true`, or `'throw'`. Sets the default [strictQuery](https://mongoosejs.com/docs/guide.html#strictQuery) mode for schemas.\n * - `toJSON`: `{ transform: true, flattenDecimals: true }` by default. Overwrites default objects to [`toJSON()`](https://mongoosejs.com/docs/api/document.html#Document.prototype.toJSON()), for determining how Mongoose documents get serialized by `JSON.stringify()`\n * - `toObject`: `{ transform: true, flattenDecimals: true }` by default. Overwrites default objects to [`toObject()`](https://mongoosejs.com/docs/api/document.html#Document.prototype.toObject())\n *\n * @param {String|Object} key The name of the option or a object of multiple key-value pairs\n * @param {String|Function|Boolean} value The value of the option, unused if \"key\" is a object\n * @returns {Mongoose} The used Mongoose instnace\n * @api public\n */\n\nMongoose.prototype.set = function(key, value) {\n  const _mongoose = this instanceof Mongoose ? this : mongoose;\n\n  if (arguments.length === 1 && typeof key !== 'object') {\n    if (VALID_OPTIONS.indexOf(key) === -1) {\n      const error = new SetOptionError();\n      error.addError(key, new SetOptionError.SetOptionInnerError(key));\n      throw error;\n    }\n\n    return _mongoose.options[key];\n  }\n\n  let options = {};\n\n  if (arguments.length === 2) {\n    options = { [key]: value };\n  }\n\n  if (arguments.length === 1 && typeof key === 'object') {\n    options = key;\n  }\n\n  // array for errors to collect all errors for all key-value pairs, like \".validate\"\n  let error = undefined;\n\n  for (const [optionKey, optionValue] of Object.entries(options)) {\n    if (VALID_OPTIONS.indexOf(optionKey) === -1) {\n      if (!error) {\n        error = new SetOptionError();\n      }\n      error.addError(optionKey, new SetOptionError.SetOptionInnerError(optionKey));\n      continue;\n    }\n\n    _mongoose.options[optionKey] = optionValue;\n\n    if (optionKey === 'objectIdGetter') {\n      if (optionValue) {\n        Object.defineProperty(mongoose.Types.ObjectId.prototype, '_id', {\n          enumerable: false,\n          configurable: true,\n          get: function() {\n            return this;\n          }\n        });\n      } else {\n        delete mongoose.Types.ObjectId.prototype._id;\n      }\n    }\n  }\n\n  if (error) {\n    throw error;\n  }\n\n  return _mongoose;\n};\n\n/**\n * Gets mongoose options\n *\n * #### Example:\n *\n *     mongoose.get('test') // returns the 'test' value\n *\n * @param {String} key\n * @method get\n * @api public\n */\n\nMongoose.prototype.get = Mongoose.prototype.set;\n\n/**\n * Creates a Connection instance.\n *\n * Each `connection` instance maps to a single database. This method is helpful when managing multiple db connections.\n *\n *\n * _Options passed take precedence over options included in connection strings._\n *\n * #### Example:\n *\n *     // with mongodb:// URI\n *     db = mongoose.createConnection('mongodb://user:pass@127.0.0.1:port/database');\n *\n *     // and options\n *     const opts = { db: { native_parser: true }}\n *     db = mongoose.createConnection('mongodb://user:pass@127.0.0.1:port/database', opts);\n *\n *     // replica sets\n *     db = mongoose.createConnection('mongodb://user:pass@127.0.0.1:port,anotherhost:port,yetanother:port/database');\n *\n *     // and options\n *     const opts = { replset: { strategy: 'ping', rs_name: 'testSet' }}\n *     db = mongoose.createConnection('mongodb://user:pass@127.0.0.1:port,anotherhost:port,yetanother:port/database', opts);\n *\n *     // initialize now, connect later\n *     db = mongoose.createConnection();\n *     db.openUri('127.0.0.1', 'database', port, [opts]);\n *\n * @param {String} uri mongodb URI to connect to\n * @param {Object} [options] passed down to the [MongoDB driver's `connect()` function](https://mongodb.github.io/node-mongodb-native/4.9/interfaces/MongoClientOptions.html), except for 4 mongoose-specific options explained below.\n * @param {Boolean} [options.bufferCommands=true] Mongoose specific option. Set to false to [disable buffering](https://mongoosejs.com/docs/faq.html#callback_never_executes) on all models associated with this connection.\n * @param {String} [options.dbName] The name of the database you want to use. If not provided, Mongoose uses the database name from connection string.\n * @param {String} [options.user] username for authentication, equivalent to `options.auth.user`. Maintained for backwards compatibility.\n * @param {String} [options.pass] password for authentication, equivalent to `options.auth.password`. Maintained for backwards compatibility.\n * @param {Boolean} [options.autoIndex=true] Mongoose-specific option. Set to false to disable automatic index creation for all models associated with this connection.\n * @param {Class} [options.promiseLibrary] Sets the [underlying driver's promise library](https://mongodb.github.io/node-mongodb-native/4.9/interfaces/MongoClientOptions.html#promiseLibrary).\n * @param {Number} [options.maxPoolSize=5] The maximum number of sockets the MongoDB driver will keep open for this connection. Keep in mind that MongoDB only allows one operation per socket at a time, so you may want to increase this if you find you have a few slow queries that are blocking faster queries from proceeding. See [Slow Trains in MongoDB and Node.js](https://thecodebarbarian.com/slow-trains-in-mongodb-and-nodejs).\n * @param {Number} [options.minPoolSize=1] The minimum number of sockets the MongoDB driver will keep open for this connection. Keep in mind that MongoDB only allows one operation per socket at a time, so you may want to increase this if you find you have a few slow queries that are blocking faster queries from proceeding. See [Slow Trains in MongoDB and Node.js](https://thecodebarbarian.com/slow-trains-in-mongodb-and-nodejs).\n * @param {Number} [options.socketTimeoutMS=0] How long the MongoDB driver will wait before killing a socket due to inactivity _after initial connection_. Defaults to 0, which means Node.js will not time out the socket due to inactivity. A socket may be inactive because of either no activity or a long-running operation. This option is passed to [Node.js `socket#setTimeout()` function](https://nodejs.org/api/net.html#net_socket_settimeout_timeout_callback) after the MongoDB driver successfully completes.\n * @param {Number} [options.family=0] Passed transparently to [Node.js' `dns.lookup()`](https://nodejs.org/api/dns.html#dns_dns_lookup_hostname_options_callback) function. May be either `0`, `4`, or `6`. `4` means use IPv4 only, `6` means use IPv6 only, `0` means try both.\n * @return {Connection} the created Connection object. Connections are not thenable, so you can't do `await mongoose.createConnection()`. To await use `mongoose.createConnection(uri).asPromise()` instead.\n * @api public\n */\n\nMongoose.prototype.createConnection = function(uri, options) {\n  const _mongoose = this instanceof Mongoose ? this : mongoose;\n\n  const Connection = _mongoose.__driver.Connection;\n  const conn = new Connection(_mongoose);\n  _mongoose.connections.push(conn);\n  _mongoose.nextConnectionId++;\n  _mongoose.events.emit('createConnection', conn);\n\n  if (arguments.length > 0) {\n    conn.openUri(uri, { ...options, _fireAndForget: true });\n  }\n\n  return conn;\n};\n\n/**\n * Opens the default mongoose connection.\n *\n * #### Example:\n *\n *     mongoose.connect('mongodb://user:pass@127.0.0.1:port/database');\n *\n *     // replica sets\n *     const uri = 'mongodb://user:pass@127.0.0.1:port,anotherhost:port,yetanother:port/mydatabase';\n *     mongoose.connect(uri);\n *\n *     // with options\n *     mongoose.connect(uri, options);\n *\n *     // optional callback that gets fired when initial connection completed\n *     const uri = 'mongodb://nonexistent.domain:27000';\n *     mongoose.connect(uri, function(error) {\n *       // if error is truthy, the initial connection failed.\n *     })\n *\n * @param {String} uri mongodb URI to connect to\n * @param {Object} [options] passed down to the [MongoDB driver's `connect()` function](https://mongodb.github.io/node-mongodb-native/4.9/interfaces/MongoClientOptions.html), except for 4 mongoose-specific options explained below.\n * @param {Boolean} [options.bufferCommands=true] Mongoose specific option. Set to false to [disable buffering](https://mongoosejs.com/docs/faq.html#callback_never_executes) on all models associated with this connection.\n * @param {Number} [options.bufferTimeoutMS=10000] Mongoose specific option. If `bufferCommands` is true, Mongoose will throw an error after `bufferTimeoutMS` if the operation is still buffered.\n * @param {String} [options.dbName] The name of the database we want to use. If not provided, use database name from connection string.\n * @param {String} [options.user] username for authentication, equivalent to `options.auth.user`. Maintained for backwards compatibility.\n * @param {String} [options.pass] password for authentication, equivalent to `options.auth.password`. Maintained for backwards compatibility.\n * @param {Number} [options.maxPoolSize=100] The maximum number of sockets the MongoDB driver will keep open for this connection. Keep in mind that MongoDB only allows one operation per socket at a time, so you may want to increase this if you find you have a few slow queries that are blocking faster queries from proceeding. See [Slow Trains in MongoDB and Node.js](https://thecodebarbarian.com/slow-trains-in-mongodb-and-nodejs).\n * @param {Number} [options.minPoolSize=0] The minimum number of sockets the MongoDB driver will keep open for this connection.\n * @param {Number} [options.serverSelectionTimeoutMS] If `useUnifiedTopology = true`, the MongoDB driver will try to find a server to send any given operation to, and keep retrying for `serverSelectionTimeoutMS` milliseconds before erroring out. If not set, the MongoDB driver defaults to using `30000` (30 seconds).\n * @param {Number} [options.heartbeatFrequencyMS] If `useUnifiedTopology = true`, the MongoDB driver sends a heartbeat every `heartbeatFrequencyMS` to check on the status of the connection. A heartbeat is subject to `serverSelectionTimeoutMS`, so the MongoDB driver will retry failed heartbeats for up to 30 seconds by default. Mongoose only emits a `'disconnected'` event after a heartbeat has failed, so you may want to decrease this setting to reduce the time between when your server goes down and when Mongoose emits `'disconnected'`. We recommend you do **not** set this setting below 1000, too many heartbeats can lead to performance degradation.\n * @param {Boolean} [options.autoIndex=true] Mongoose-specific option. Set to false to disable automatic index creation for all models associated with this connection.\n * @param {Class} [options.promiseLibrary] Sets the [underlying driver's promise library](https://mongodb.github.io/node-mongodb-native/4.9/interfaces/MongoClientOptions.html#promiseLibrary).\n * @param {Number} [options.socketTimeoutMS=0] How long the MongoDB driver will wait before killing a socket due to inactivity _after initial connection_. A socket may be inactive because of either no activity or a long-running operation. `socketTimeoutMS` defaults to 0, which means Node.js will not time out the socket due to inactivity. This option is passed to [Node.js `socket#setTimeout()` function](https://nodejs.org/api/net.html#net_socket_settimeout_timeout_callback) after the MongoDB driver successfully completes.\n * @param {Number} [options.family=0] Passed transparently to [Node.js' `dns.lookup()`](https://nodejs.org/api/dns.html#dns_dns_lookup_hostname_options_callback) function. May be either `0`, `4`, or `6`. `4` means use IPv4 only, `6` means use IPv6 only, `0` means try both.\n * @param {Boolean} [options.autoCreate=false] Set to `true` to make Mongoose automatically call `createCollection()` on every model created on this connection.\n * @param {Function} [callback]\n * @see Mongoose#createConnection https://mongoosejs.com/docs/api/mongoose.html#Mongoose.prototype.createConnection()\n * @api public\n * @return {Promise} resolves to `this` if connection succeeded\n */\n\nMongoose.prototype.connect = async function connect(uri, options) {\n  if (typeof options === 'function' || (arguments.length >= 3 && typeof arguments[2] === 'function')) {\n    throw new MongooseError('Mongoose.prototype.connect() no longer accepts a callback');\n  }\n\n  const _mongoose = this instanceof Mongoose ? this : mongoose;\n  const conn = _mongoose.connection;\n\n  return conn.openUri(uri, options).then(() => _mongoose);\n};\n\n/**\n * Runs `.close()` on all connections in parallel.\n *\n * @return {Promise} resolves when all connections are closed, or rejects with the first error that occurred.\n * @api public\n */\n\nMongoose.prototype.disconnect = async function disconnect() {\n  if (arguments.length >= 1 && typeof arguments[0] === 'function') {\n    throw new MongooseError('Mongoose.prototype.disconnect() no longer accepts a callback');\n  }\n\n  const _mongoose = this instanceof Mongoose ? this : mongoose;\n\n  const remaining = _mongoose.connections.length;\n  if (remaining <= 0) {\n    return;\n  }\n  await Promise.all(_mongoose.connections.map(conn => conn.close()));\n};\n\n/**\n * _Requires MongoDB >= 3.6.0._ Starts a [MongoDB session](https://www.mongodb.com/docs/manual/release-notes/3.6/#client-sessions)\n * for benefits like causal consistency, [retryable writes](https://www.mongodb.com/docs/manual/core/retryable-writes/),\n * and [transactions](https://thecodebarbarian.com/a-node-js-perspective-on-mongodb-4-transactions.html).\n *\n * Calling `mongoose.startSession()` is equivalent to calling `mongoose.connection.startSession()`.\n * Sessions are scoped to a connection, so calling `mongoose.startSession()`\n * starts a session on the [default mongoose connection](https://mongoosejs.com/docs/api/mongoose.html#Mongoose.prototype.connection).\n *\n * @param {Object} [options] see the [mongodb driver options](https://mongodb.github.io/node-mongodb-native/4.9/classes/MongoClient.html#startSession)\n * @param {Boolean} [options.causalConsistency=true] set to false to disable causal consistency\n * @param {Function} [callback]\n * @return {Promise<ClientSession>} promise that resolves to a MongoDB driver `ClientSession`\n * @api public\n */\n\nMongoose.prototype.startSession = function() {\n  const _mongoose = this instanceof Mongoose ? this : mongoose;\n\n  return _mongoose.connection.startSession.apply(_mongoose.connection, arguments);\n};\n\n/**\n * Getter/setter around function for pluralizing collection names.\n *\n * @param {Function|null} [fn] overwrites the function used to pluralize collection names\n * @return {Function|null} the current function used to pluralize collection names, defaults to the legacy function from `mongoose-legacy-pluralize`.\n * @api public\n */\n\nMongoose.prototype.pluralize = function(fn) {\n  const _mongoose = this instanceof Mongoose ? this : mongoose;\n\n  if (arguments.length > 0) {\n    _mongoose._pluralize = fn;\n  }\n  return _mongoose._pluralize;\n};\n\n/**\n * Defines a model or retrieves it.\n *\n * Models defined on the `mongoose` instance are available to all connection\n * created by the same `mongoose` instance.\n *\n * If you call `mongoose.model()` with twice the same name but a different schema,\n * you will get an `OverwriteModelError`. If you call `mongoose.model()` with\n * the same name and same schema, you'll get the same schema back.\n *\n * #### Example:\n *\n *     const mongoose = require('mongoose');\n *\n *     // define an Actor model with this mongoose instance\n *     const schema = new Schema({ name: String });\n *     mongoose.model('Actor', schema);\n *\n *     // create a new connection\n *     const conn = mongoose.createConnection(..);\n *\n *     // create Actor model\n *     const Actor = conn.model('Actor', schema);\n *     conn.model('Actor') === Actor; // true\n *     conn.model('Actor', schema) === Actor; // true, same schema\n *     conn.model('Actor', schema, 'actors') === Actor; // true, same schema and collection name\n *\n *     // This throws an `OverwriteModelError` because the schema is different.\n *     conn.model('Actor', new Schema({ name: String }));\n *\n * _When no `collection` argument is passed, Mongoose uses the model name. If you don't like this behavior, either pass a collection name, use `mongoose.pluralize()`, or set your schemas collection name option._\n *\n * #### Example:\n *\n *     const schema = new Schema({ name: String }, { collection: 'actor' });\n *\n *     // or\n *\n *     schema.set('collection', 'actor');\n *\n *     // or\n *\n *     const collectionName = 'actor'\n *     const M = mongoose.model('Actor', schema, collectionName)\n *\n * @param {String|Function} name model name or class extending Model\n * @param {Schema} [schema] the schema to use.\n * @param {String} [collection] name (optional, inferred from model name)\n * @return {Model} The model associated with `name`. Mongoose will create the model if it doesn't already exist.\n * @api public\n */\n\nMongoose.prototype.model = function(name, schema, collection, options) {\n  const _mongoose = this instanceof Mongoose ? this : mongoose;\n\n  if (typeof schema === 'string') {\n    collection = schema;\n    schema = false;\n  }\n\n  if (arguments.length === 1) {\n    const model = _mongoose.models[name];\n    if (!model) {\n      throw new MongooseError.MissingSchemaError(name);\n    }\n    return model;\n  }\n\n  if (utils.isObject(schema) && !(schema instanceof Schema)) {\n    schema = new Schema(schema);\n  }\n  if (schema && !(schema instanceof Schema)) {\n    throw new Error('The 2nd parameter to `mongoose.model()` should be a ' +\n      'schema or a POJO');\n  }\n\n  // handle internal options from connection.model()\n  options = options || {};\n\n  const originalSchema = schema;\n  if (schema) {\n    if (_mongoose.get('cloneSchemas')) {\n      schema = schema.clone();\n    }\n    _mongoose._applyPlugins(schema);\n  }\n\n  // connection.model() may be passing a different schema for\n  // an existing model name. in this case don't read from cache.\n  const overwriteModels = _mongoose.options.hasOwnProperty('overwriteModels') ?\n    _mongoose.options.overwriteModels :\n    options.overwriteModels;\n  if (_mongoose.models.hasOwnProperty(name) && options.cache !== false && overwriteModels !== true) {\n    if (originalSchema &&\n        originalSchema.instanceOfSchema &&\n        originalSchema !== _mongoose.models[name].schema) {\n      throw new _mongoose.Error.OverwriteModelError(name);\n    }\n    if (collection && collection !== _mongoose.models[name].collection.name) {\n      // subclass current model with alternate collection\n      const model = _mongoose.models[name];\n      schema = model.prototype.schema;\n      const sub = model.__subclass(_mongoose.connection, schema, collection);\n      // do not cache the sub model\n      return sub;\n    }\n    return _mongoose.models[name];\n  }\n  if (schema == null) {\n    throw new _mongoose.Error.MissingSchemaError(name);\n  }\n\n  const model = _mongoose._model(name, schema, collection, options);\n  _mongoose.connection.models[name] = model;\n  _mongoose.models[name] = model;\n\n  return model;\n};\n\n/*!\n * ignore\n */\n\nMongoose.prototype._model = function(name, schema, collection, options) {\n  const _mongoose = this instanceof Mongoose ? this : mongoose;\n\n  let model;\n  if (typeof name === 'function') {\n    model = name;\n    name = model.name;\n    if (!(model.prototype instanceof Model)) {\n      throw new _mongoose.Error('The provided class ' + name + ' must extend Model');\n    }\n  }\n\n  if (schema) {\n    if (_mongoose.get('cloneSchemas')) {\n      schema = schema.clone();\n    }\n    _mongoose._applyPlugins(schema);\n  }\n\n  // Apply relevant \"global\" options to the schema\n  if (schema == null || !('pluralization' in schema.options)) {\n    schema.options.pluralization = _mongoose.options.pluralization;\n  }\n\n  if (!collection) {\n    collection = schema.get('collection') ||\n      utils.toCollectionName(name, _mongoose.pluralize());\n  }\n\n  const connection = options.connection || _mongoose.connection;\n  model = _mongoose.Model.compile(model || name, schema, collection, connection, _mongoose);\n  // Errors handled internally, so safe to ignore error\n  model.init().catch(function $modelInitNoop() {});\n\n  connection.emit('model', model);\n\n  if (schema._applyDiscriminators != null) {\n    for (const disc of schema._applyDiscriminators.keys()) {\n      model.discriminator(disc, schema._applyDiscriminators.get(disc));\n    }\n  }\n\n  applyEmbeddedDiscriminators(schema);\n\n  return model;\n};\n\n/**\n * Removes the model named `name` from the default connection, if it exists.\n * You can use this function to clean up any models you created in your tests to\n * prevent OverwriteModelErrors.\n *\n * Equivalent to `mongoose.connection.deleteModel(name)`.\n *\n * #### Example:\n *\n *     mongoose.model('User', new Schema({ name: String }));\n *     console.log(mongoose.model('User')); // Model object\n *     mongoose.deleteModel('User');\n *     console.log(mongoose.model('User')); // undefined\n *\n *     // Usually useful in a Mocha `afterEach()` hook\n *     afterEach(function() {\n *       mongoose.deleteModel(/.+/); // Delete every model\n *     });\n *\n * @api public\n * @param {String|RegExp} name if string, the name of the model to remove. If regexp, removes all models whose name matches the regexp.\n * @return {Mongoose} this\n */\n\nMongoose.prototype.deleteModel = function(name) {\n  const _mongoose = this instanceof Mongoose ? this : mongoose;\n\n  _mongoose.connection.deleteModel(name);\n  delete _mongoose.models[name];\n  return _mongoose;\n};\n\n/**\n * Returns an array of model names created on this instance of Mongoose.\n *\n * #### Note:\n *\n * _Does not include names of models created using `connection.model()`._\n *\n * @api public\n * @return {Array}\n */\n\nMongoose.prototype.modelNames = function() {\n  const _mongoose = this instanceof Mongoose ? this : mongoose;\n\n  const names = Object.keys(_mongoose.models);\n  return names;\n};\n\n/**\n * Applies global plugins to `schema`.\n *\n * @param {Schema} schema\n * @api private\n */\n\nMongoose.prototype._applyPlugins = function(schema, options) {\n  const _mongoose = this instanceof Mongoose ? this : mongoose;\n\n  options = options || {};\n  options.applyPluginsToDiscriminators = _mongoose.options && _mongoose.options.applyPluginsToDiscriminators || false;\n  options.applyPluginsToChildSchemas = typeof (_mongoose.options && _mongoose.options.applyPluginsToChildSchemas) === 'boolean' ?\n    _mongoose.options.applyPluginsToChildSchemas :\n    true;\n  applyPlugins(schema, _mongoose.plugins, options, '$globalPluginsApplied');\n};\n\n/**\n * Declares a global plugin executed on all Schemas.\n *\n * Equivalent to calling `.plugin(fn)` on each Schema you create.\n *\n * @param {Function} fn plugin callback\n * @param {Object} [opts] optional options\n * @return {Mongoose} this\n * @see plugins https://mongoosejs.com/docs/plugins.html\n * @api public\n */\n\nMongoose.prototype.plugin = function(fn, opts) {\n  const _mongoose = this instanceof Mongoose ? this : mongoose;\n\n  _mongoose.plugins.push([fn, opts]);\n  return _mongoose;\n};\n\n/**\n * The Mongoose module's default connection. Equivalent to `mongoose.connections[0]`, see [`connections`](https://mongoosejs.com/docs/api/mongoose.html#Mongoose.prototype.connections).\n *\n * #### Example:\n *\n *     const mongoose = require('mongoose');\n *     mongoose.connect(...);\n *     mongoose.connection.on('error', cb);\n *\n * This is the connection used by default for every model created using [mongoose.model](https://mongoosejs.com/docs/api/mongoose.html#Mongoose.prototype.model()).\n *\n * To create a new connection, use [`createConnection()`](https://mongoosejs.com/docs/api/mongoose.html#Mongoose.prototype.createConnection()).\n *\n * @memberOf Mongoose\n * @instance\n * @property {Connection} connection\n * @api public\n */\n\nMongoose.prototype.__defineGetter__('connection', function() {\n  return this.connections[0];\n});\n\nMongoose.prototype.__defineSetter__('connection', function(v) {\n  if (v instanceof this.__driver.Connection) {\n    this.connections[0] = v;\n    this.models = v.models;\n  }\n});\n\n/**\n * An array containing all [connections](connection.html) associated with this\n * Mongoose instance. By default, there is 1 connection. Calling\n * [`createConnection()`](https://mongoosejs.com/docs/api/mongoose.html#Mongoose.prototype.createConnection()) adds a connection\n * to this array.\n *\n * #### Example:\n *\n *     const mongoose = require('mongoose');\n *     mongoose.connections.length; // 1, just the default connection\n *     mongoose.connections[0] === mongoose.connection; // true\n *\n *     mongoose.createConnection('mongodb://127.0.0.1:27017/test');\n *     mongoose.connections.length; // 2\n *\n * @memberOf Mongoose\n * @instance\n * @property {Array} connections\n * @api public\n */\n\nMongoose.prototype.connections;\n\n/**\n * An integer containing the value of the next connection id. Calling\n * [`createConnection()`](https://mongoosejs.com/docs/api/mongoose.html#Mongoose.prototype.createConnection()) increments\n * this value.\n *\n * #### Example:\n *\n *     const mongoose = require('mongoose');\n *     mongoose.createConnection(); // id `0`, `nextConnectionId` becomes `1`\n *     mongoose.createConnection(); // id `1`, `nextConnectionId` becomes `2`\n *     mongoose.connections[0].destroy() // Removes connection with id `0`\n *     mongoose.createConnection(); // id `2`, `nextConnectionId` becomes `3`\n *\n * @memberOf Mongoose\n * @instance\n * @property {Number} nextConnectionId\n * @api private\n */\n\nMongoose.prototype.nextConnectionId;\n\n/**\n * The Mongoose Aggregate constructor\n *\n * @method Aggregate\n * @api public\n */\n\nMongoose.prototype.Aggregate = Aggregate;\n\n/**\n * The Mongoose Collection constructor\n *\n * @memberOf Mongoose\n * @instance\n * @method Collection\n * @api public\n */\n\nObject.defineProperty(Mongoose.prototype, 'Collection', {\n  get: function() {\n    return this.__driver.Collection;\n  },\n  set: function(Collection) {\n    this.__driver.Collection = Collection;\n  }\n});\n\n/**\n * The Mongoose [Connection](https://mongoosejs.com/docs/api/connection.html#Connection()) constructor\n *\n * @memberOf Mongoose\n * @instance\n * @method Connection\n * @api public\n */\n\nObject.defineProperty(Mongoose.prototype, 'Connection', {\n  get: function() {\n    return this.__driver.Connection;\n  },\n  set: function(Connection) {\n    if (Connection === this.__driver.Connection) {\n      return;\n    }\n\n    this.__driver.Connection = Connection;\n  }\n});\n\n/**\n * The Mongoose version\n *\n * #### Example:\n *\n *     console.log(mongoose.version); // '5.x.x'\n *\n * @property version\n * @api public\n */\n\nMongoose.prototype.version = pkg.version;\n\n/**\n * The Mongoose constructor\n *\n * The exports of the mongoose module is an instance of this class.\n *\n * #### Example:\n *\n *     const mongoose = require('mongoose');\n *     const mongoose2 = new mongoose.Mongoose();\n *\n * @method Mongoose\n * @api public\n */\n\nMongoose.prototype.Mongoose = Mongoose;\n\n/**\n * The Mongoose [Schema](https://mongoosejs.com/docs/api/schema.html#Schema()) constructor\n *\n * #### Example:\n *\n *     const mongoose = require('mongoose');\n *     const Schema = mongoose.Schema;\n *     const CatSchema = new Schema(..);\n *\n * @method Schema\n * @api public\n */\n\nMongoose.prototype.Schema = Schema;\n\n/**\n * The Mongoose [SchemaType](https://mongoosejs.com/docs/api/schematype.html#SchemaType()) constructor\n *\n * @method SchemaType\n * @api public\n */\n\nMongoose.prototype.SchemaType = SchemaType;\n\n/**\n * The various Mongoose SchemaTypes.\n *\n * #### Note:\n *\n * _Alias of mongoose.Schema.Types for backwards compatibility._\n *\n * @property SchemaTypes\n * @see Schema.SchemaTypes https://mongoosejs.com/docs/schematypes.html\n * @api public\n */\n\nMongoose.prototype.SchemaTypes = Schema.Types;\n\n/**\n * The Mongoose [VirtualType](https://mongoosejs.com/docs/api/virtualtype.html#VirtualType()) constructor\n *\n * @method VirtualType\n * @api public\n */\n\nMongoose.prototype.VirtualType = VirtualType;\n\n/**\n * The various Mongoose Types.\n *\n * #### Example:\n *\n *     const mongoose = require('mongoose');\n *     const array = mongoose.Types.Array;\n *\n * #### Types:\n *\n * - [Array](https://mongoosejs.com/docs/schematypes.html#arrays)\n * - [Buffer](https://mongoosejs.com/docs/schematypes.html#buffers)\n * - [Embedded](https://mongoosejs.com/docs/schematypes.html#schemas)\n * - [DocumentArray](https://mongoosejs.com/docs/api/documentarraypath.html)\n * - [Decimal128](https://mongoosejs.com/docs/api/mongoose.html#Mongoose.prototype.Decimal128)\n * - [ObjectId](https://mongoosejs.com/docs/schematypes.html#objectids)\n * - [Map](https://mongoosejs.com/docs/schematypes.html#maps)\n * - [Subdocument](https://mongoosejs.com/docs/schematypes.html#schemas)\n *\n * Using this exposed access to the `ObjectId` type, we can construct ids on demand.\n *\n *     const ObjectId = mongoose.Types.ObjectId;\n *     const id1 = new ObjectId;\n *\n * @property Types\n * @api public\n */\n\nMongoose.prototype.Types = Types;\n\n/**\n * The Mongoose [Query](https://mongoosejs.com/docs/api/query.html#Query()) constructor.\n *\n * @method Query\n * @api public\n */\n\nMongoose.prototype.Query = Query;\n\n/**\n * The Mongoose [Model](https://mongoosejs.com/docs/api/model.html#Model()) constructor.\n *\n * @method Model\n * @api public\n */\n\nMongoose.prototype.Model = Model;\n\n/**\n * The Mongoose [Document](https://mongoosejs.com/docs/api/document.html#Document()) constructor.\n *\n * @method Document\n * @api public\n */\n\nMongoose.prototype.Document = Document;\n\n/**\n * The Mongoose DocumentProvider constructor. Mongoose users should not have to\n * use this directly\n *\n * @method DocumentProvider\n * @api public\n */\n\nMongoose.prototype.DocumentProvider = __webpack_require__(/*! ./documentProvider */ \"../server/node_modules/mongoose/lib/documentProvider.js\");\n\n/**\n * The Mongoose ObjectId [SchemaType](https://mongoosejs.com/docs/schematypes.html). Used for\n * declaring paths in your schema that should be\n * [MongoDB ObjectIds](https://www.mongodb.com/docs/manual/reference/method/ObjectId/).\n * Do not use this to create a new ObjectId instance, use `mongoose.Types.ObjectId`\n * instead.\n *\n * #### Example:\n *\n *     const childSchema = new Schema({ parentId: mongoose.ObjectId });\n *\n * @property ObjectId\n * @api public\n */\n\nMongoose.prototype.ObjectId = SchemaTypes.ObjectId;\n\n/**\n * Returns true if Mongoose can cast the given value to an ObjectId, or\n * false otherwise.\n *\n * #### Example:\n *\n *     mongoose.isValidObjectId(new mongoose.Types.ObjectId()); // true\n *     mongoose.isValidObjectId('0123456789ab'); // true\n *     mongoose.isValidObjectId(6); // true\n *     mongoose.isValidObjectId(new User({ name: 'test' })); // true\n *\n *     mongoose.isValidObjectId({ test: 42 }); // false\n *\n * @method isValidObjectId\n * @param {Any} v\n * @returns {boolean} true if `v` is something Mongoose can coerce to an ObjectId\n * @api public\n */\n\nMongoose.prototype.isValidObjectId = function(v) {\n  const _mongoose = this instanceof Mongoose ? this : mongoose;\n  return _mongoose.Types.ObjectId.isValid(v);\n};\n\n/**\n * Returns true if the given value is a Mongoose ObjectId (using `instanceof`) or if the\n * given value is a 24 character hex string, which is the most commonly used string representation\n * of an ObjectId.\n *\n * This function is similar to `isValidObjectId()`, but considerably more strict, because\n * `isValidObjectId()` will return `true` for _any_ value that Mongoose can convert to an\n * ObjectId. That includes Mongoose documents, any string of length 12, and any number.\n * `isObjectIdOrHexString()` returns true only for `ObjectId` instances or 24 character hex\n * strings, and will return false for numbers, documents, and strings of length 12.\n *\n * #### Example:\n *\n *     mongoose.isObjectIdOrHexString(new mongoose.Types.ObjectId()); // true\n *     mongoose.isObjectIdOrHexString('62261a65d66c6be0a63c051f'); // true\n *\n *     mongoose.isObjectIdOrHexString('0123456789ab'); // false\n *     mongoose.isObjectIdOrHexString(6); // false\n *     mongoose.isObjectIdOrHexString(new User({ name: 'test' })); // false\n *     mongoose.isObjectIdOrHexString({ test: 42 }); // false\n *\n * @method isObjectIdOrHexString\n * @param {Any} v\n * @returns {boolean} true if `v` is an ObjectId instance _or_ a 24 char hex string\n * @api public\n */\n\nMongoose.prototype.isObjectIdOrHexString = function(v) {\n  return isBsonType(v, 'ObjectId') || (typeof v === 'string' && objectIdHexRegexp.test(v));\n};\n\n/**\n *\n * Syncs all the indexes for the models registered with this connection.\n *\n * @param {Object} options\n * @param {Boolean} options.continueOnError `false` by default. If set to `true`, mongoose will not throw an error if one model syncing failed, and will return an object where the keys are the names of the models, and the values are the results/errors for each model.\n * @return {Promise} Returns a Promise, when the Promise resolves the value is a list of the dropped indexes.\n */\nMongoose.prototype.syncIndexes = function(options) {\n  const _mongoose = this instanceof Mongoose ? this : mongoose;\n  return _mongoose.connection.syncIndexes(options);\n};\n\n/**\n * The Mongoose Decimal128 [SchemaType](https://mongoosejs.com/docs/schematypes.html). Used for\n * declaring paths in your schema that should be\n * [128-bit decimal floating points](https://thecodebarbarian.com/a-nodejs-perspective-on-mongodb-34-decimal.html).\n * Do not use this to create a new Decimal128 instance, use `mongoose.Types.Decimal128`\n * instead.\n *\n * #### Example:\n *\n *     const vehicleSchema = new Schema({ fuelLevel: mongoose.Decimal128 });\n *\n * @property Decimal128\n * @api public\n */\n\nMongoose.prototype.Decimal128 = SchemaTypes.Decimal128;\n\n/**\n * The Mongoose Mixed [SchemaType](https://mongoosejs.com/docs/schematypes.html). Used for\n * declaring paths in your schema that Mongoose's change tracking, casting,\n * and validation should ignore.\n *\n * #### Example:\n *\n *     const schema = new Schema({ arbitrary: mongoose.Mixed });\n *\n * @property Mixed\n * @api public\n */\n\nMongoose.prototype.Mixed = SchemaTypes.Mixed;\n\n/**\n * The Mongoose Date [SchemaType](https://mongoosejs.com/docs/schematypes.html).\n *\n * #### Example:\n *\n *     const schema = new Schema({ test: Date });\n *     schema.path('test') instanceof mongoose.Date; // true\n *\n * @property Date\n * @api public\n */\n\nMongoose.prototype.Date = SchemaTypes.Date;\n\n/**\n * The Mongoose Number [SchemaType](https://mongoosejs.com/docs/schematypes.html). Used for\n * declaring paths in your schema that Mongoose should cast to numbers.\n *\n * #### Example:\n *\n *     const schema = new Schema({ num: mongoose.Number });\n *     // Equivalent to:\n *     const schema = new Schema({ num: 'number' });\n *\n * @property Number\n * @api public\n */\n\nMongoose.prototype.Number = SchemaTypes.Number;\n\n/**\n * The [MongooseError](https://mongoosejs.com/docs/api/error.html#Error()) constructor.\n *\n * @method Error\n * @api public\n */\n\nMongoose.prototype.Error = __webpack_require__(/*! ./error/index */ \"../server/node_modules/mongoose/lib/error/index.js\");\nMongoose.prototype.MongooseError = __webpack_require__(/*! ./error/mongooseError */ \"../server/node_modules/mongoose/lib/error/mongooseError.js\");\n\n/**\n * Mongoose uses this function to get the current time when setting\n * [timestamps](https://mongoosejs.com/docs/guide.html#timestamps). You may stub out this function\n * using a tool like [Sinon](https://www.npmjs.com/package/sinon) for testing.\n *\n * @method now\n * @returns Date the current time\n * @api public\n */\n\nMongoose.prototype.now = function now() { return new Date(); };\n\n/**\n * The Mongoose CastError constructor\n *\n * @method CastError\n * @param {String} type The name of the type\n * @param {Any} value The value that failed to cast\n * @param {String} path The path `a.b.c` in the doc where this cast error occurred\n * @param {Error} [reason] The original error that was thrown\n * @api public\n */\n\nMongoose.prototype.CastError = __webpack_require__(/*! ./error/cast */ \"../server/node_modules/mongoose/lib/error/cast.js\");\n\n/**\n * The constructor used for schematype options\n *\n * @method SchemaTypeOptions\n * @api public\n */\n\nMongoose.prototype.SchemaTypeOptions = __webpack_require__(/*! ./options/schemaTypeOptions */ \"../server/node_modules/mongoose/lib/options/schemaTypeOptions.js\");\n\n/**\n * The [mquery](https://github.com/aheckmann/mquery) query builder Mongoose uses.\n *\n * @property mquery\n * @api public\n */\n\nMongoose.prototype.mquery = __webpack_require__(/*! mquery */ \"../server/node_modules/mquery/lib/mquery.js\");\n\n/**\n * Sanitizes query filters against [query selector injection attacks](https://thecodebarbarian.com/2014/09/04/defending-against-query-selector-injection-attacks.html)\n * by wrapping any nested objects that have a property whose name starts with `$` in a `$eq`.\n *\n * ```javascript\n * const obj = { username: 'val', pwd: { $ne: null } };\n * sanitizeFilter(obj);\n * obj; // { username: 'val', pwd: { $eq: { $ne: null } } });\n * ```\n *\n * @method sanitizeFilter\n * @param {Object} filter\n * @returns Object the sanitized object\n * @api public\n */\n\nMongoose.prototype.sanitizeFilter = sanitizeFilter;\n\n/**\n * Tells `sanitizeFilter()` to skip the given object when filtering out potential [query selector injection attacks](https://thecodebarbarian.com/2014/09/04/defending-against-query-selector-injection-attacks.html).\n * Use this method when you have a known query selector that you want to use.\n *\n * ```javascript\n * const obj = { username: 'val', pwd: trusted({ $type: 'string', $eq: 'my secret' }) };\n * sanitizeFilter(obj);\n *\n * // Note that `sanitizeFilter()` did not add `$eq` around `$type`.\n * obj; // { username: 'val', pwd: { $type: 'string', $eq: 'my secret' } });\n * ```\n *\n * @method trusted\n * @param {Object} obj\n * @returns Object the passed in object\n * @api public\n */\n\nMongoose.prototype.trusted = trusted;\n\n/**\n * Use this function in `pre()` middleware to skip calling the wrapped function.\n *\n * #### Example:\n *\n *     schema.pre('save', function() {\n *       // Will skip executing `save()`, but will execute post hooks as if\n *       // `save()` had executed with the result `{ matchedCount: 0 }`\n *       return mongoose.skipMiddlewareFunction({ matchedCount: 0 });\n *     });\n *\n * @method skipMiddlewareFunction\n * @param {any} result\n * @api public\n */\n\nMongoose.prototype.skipMiddlewareFunction = Kareem.skipWrappedFunction;\n\n/**\n * Use this function in `post()` middleware to replace the result\n *\n * #### Example:\n *\n *     schema.post('find', function(res) {\n *       // Normally you have to modify `res` in place. But with\n *       // `overwriteMiddlewarResult()`, you can make `find()` return a\n *       // completely different value.\n *       return mongoose.overwriteMiddlewareResult(res.filter(doc => !doc.isDeleted));\n *     });\n *\n * @method overwriteMiddlewareResult\n * @param {any} result\n * @api public\n */\n\nMongoose.prototype.overwriteMiddlewareResult = Kareem.overwriteResult;\n\n/**\n * The exports object is an instance of Mongoose.\n *\n * @api private\n */\n\nconst mongoose = module.exports = exports = new Mongoose({\n  [defaultMongooseSymbol]: true\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvbW9uZ29vc2UuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7QUFDQTtBQUNBOztBQUVBLGlCQUFpQixtQkFBTyxDQUFDLG1FQUFZO0FBQ3JDLHFCQUFxQiwwREFBOEI7QUFDbkQsZUFBZSxtQkFBTyxDQUFDLHNEQUFRO0FBQy9CLGVBQWUsbUJBQU8sQ0FBQywrREFBVTtBQUNqQyxtQkFBbUIsbUJBQU8sQ0FBQyx1RUFBYztBQUN6QyxvQkFBb0IsbUJBQU8sQ0FBQywyRUFBZ0I7QUFDNUMsb0JBQW9CLG1CQUFPLENBQUMseUVBQWU7QUFDM0MsZUFBZSxtQkFBTyxDQUFDLGlGQUFtQjtBQUMxQyxzQkFBc0IsbUJBQU8sQ0FBQywyRUFBZ0I7QUFDOUMsY0FBYyxtQkFBTyxDQUFDLG1FQUFTO0FBQy9CLGNBQWMsbUJBQU8sQ0FBQyw2REFBUztBQUMvQixjQUFjLG1CQUFPLENBQUMsNkRBQVM7QUFDL0IscUJBQXFCLG1CQUFPLENBQUMseUdBQStCO0FBQzVELHVCQUF1QixtQkFBTyxDQUFDLHVFQUFXO0FBQzFDLGVBQWUsbUJBQU8sQ0FBQywrREFBVTtBQUNqQyx3QkFBd0IsbUJBQU8sQ0FBQyxxRkFBcUI7QUFDckQsY0FBYyxtQkFBTyxDQUFDLDZEQUFTO0FBQy9CLFlBQVksbUJBQU8sQ0FBQyxxRUFBaUI7QUFDckMsYUFBYSxtQkFBTyxDQUFDLDJEQUFROztBQUU3QixrQkFBa0IsbUJBQU8sQ0FBQyxxRUFBYTtBQUN2QyxnQkFBZ0IsNEhBQTBDO0FBQzFELHVCQUF1QixtQkFBTyxDQUFDLDJHQUFnQztBQUMvRCxtQkFBbUIsbUJBQU8sQ0FBQyx1RkFBc0I7QUFDakQsc0JBQXNCLG1CQUFPLENBQUMseUZBQXVCO0FBQ3JELHVCQUF1QixtQkFBTyxDQUFDLDJGQUF3QjtBQUN2RCxvQ0FBb0MsbUJBQU8sQ0FBQyxxSkFBcUQ7O0FBRWpHOztBQUVBLG1CQUFPLENBQUMsbUdBQTRCOztBQUVwQyx3Q0FBd0Ms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QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0NBQXNDLG1CQUFPLENBQUMsbUZBQW9COztBQUVsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbGllbnQvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvbW9uZ29vc2UuanM/YzgyYSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbi8qIVxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG5jb25zdCBEb2N1bWVudCA9IHJlcXVpcmUoJy4vZG9jdW1lbnQnKTtcbmNvbnN0IEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcbmNvbnN0IEthcmVlbSA9IHJlcXVpcmUoJ2thcmVlbScpO1xuY29uc3QgU2NoZW1hID0gcmVxdWlyZSgnLi9zY2hlbWEnKTtcbmNvbnN0IFNjaGVtYVR5cGUgPSByZXF1aXJlKCcuL3NjaGVtYVR5cGUnKTtcbmNvbnN0IFNjaGVtYVR5cGVzID0gcmVxdWlyZSgnLi9zY2hlbWEvaW5kZXgnKTtcbmNvbnN0IFZpcnR1YWxUeXBlID0gcmVxdWlyZSgnLi92aXJ0dWFsVHlwZScpO1xuY29uc3QgU1RBVEVTID0gcmVxdWlyZSgnLi9jb25uZWN0aW9uU3RhdGUnKTtcbmNvbnN0IFZBTElEX09QVElPTlMgPSByZXF1aXJlKCcuL3ZhbGlkT3B0aW9ucycpO1xuY29uc3QgVHlwZXMgPSByZXF1aXJlKCcuL3R5cGVzJyk7XG5jb25zdCBRdWVyeSA9IHJlcXVpcmUoJy4vcXVlcnknKTtcbmNvbnN0IE1vZGVsID0gcmVxdWlyZSgnLi9tb2RlbCcpO1xuY29uc3QgYXBwbHlQbHVnaW5zID0gcmVxdWlyZSgnLi9oZWxwZXJzL3NjaGVtYS9hcHBseVBsdWdpbnMnKTtcbmNvbnN0IGJ1aWx0aW5QbHVnaW5zID0gcmVxdWlyZSgnLi9wbHVnaW5zJyk7XG5jb25zdCBkcml2ZXIgPSByZXF1aXJlKCcuL2RyaXZlcicpO1xuY29uc3QgbGVnYWN5UGx1cmFsaXplID0gcmVxdWlyZSgnLi9oZWxwZXJzL3BsdXJhbGl6ZScpO1xuY29uc3QgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG5jb25zdCBwa2cgPSByZXF1aXJlKCcuLi9wYWNrYWdlLmpzb24nKTtcbmNvbnN0IGNhc3QgPSByZXF1aXJlKCcuL2Nhc3QnKTtcblxuY29uc3QgQWdncmVnYXRlID0gcmVxdWlyZSgnLi9hZ2dyZWdhdGUnKTtcbmNvbnN0IHRydXN0ZWQgPSByZXF1aXJlKCcuL2hlbHBlcnMvcXVlcnkvdHJ1c3RlZCcpLnRydXN0ZWQ7XG5jb25zdCBzYW5pdGl6ZUZpbHRlciA9IHJlcXVpcmUoJy4vaGVscGVycy9xdWVyeS9zYW5pdGl6ZUZpbHRlcicpO1xuY29uc3QgaXNCc29uVHlwZSA9IHJlcXVpcmUoJy4vaGVscGVycy9pc0Jzb25UeXBlJyk7XG5jb25zdCBNb25nb29zZUVycm9yID0gcmVxdWlyZSgnLi9lcnJvci9tb25nb29zZUVycm9yJyk7XG5jb25zdCBTZXRPcHRpb25FcnJvciA9IHJlcXVpcmUoJy4vZXJyb3Ivc2V0T3B0aW9uRXJyb3InKTtcbmNvbnN0IGFwcGx5RW1iZWRkZWREaXNjcmltaW5hdG9ycyA9IHJlcXVpcmUoJy4vaGVscGVycy9kaXNjcmltaW5hdG9yL2FwcGx5RW1iZWRkZWREaXNjcmltaW5hdG9ycycpO1xuXG5jb25zdCBkZWZhdWx0TW9uZ29vc2VTeW1ib2wgPSBTeW1ib2wuZm9yKCdtb25nb29zZTpkZWZhdWx0Jyk7XG5cbnJlcXVpcmUoJy4vaGVscGVycy9wcmludEplc3RXYXJuaW5nJyk7XG5cbmNvbnN0IG9iamVjdElkSGV4UmVnZXhwID0gL15bMC05QS1GYS1mXXsyNH0kLztcblxuLyoqXG4gKiBNb25nb29zZSBjb25zdHJ1Y3Rvci5cbiAqXG4gKiBUaGUgZXhwb3J0cyBvYmplY3Qgb2YgdGhlIGBtb25nb29zZWAgbW9kdWxlIGlzIGFuIGluc3RhbmNlIG9mIHRoaXMgY2xhc3MuXG4gKiBNb3N0IGFwcHMgd2lsbCBvbmx5IHVzZSB0aGlzIG9uZSBpbnN0YW5jZS5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IG1vbmdvb3NlID0gcmVxdWlyZSgnbW9uZ29vc2UnKTtcbiAqICAgICBtb25nb29zZSBpbnN0YW5jZW9mIG1vbmdvb3NlLk1vbmdvb3NlOyAvLyB0cnVlXG4gKlxuICogICAgIC8vIENyZWF0ZSBhIG5ldyBNb25nb29zZSBpbnN0YW5jZSB3aXRoIGl0cyBvd24gYGNvbm5lY3QoKWAsIGBzZXQoKWAsIGBtb2RlbCgpYCwgZXRjLlxuICogICAgIGNvbnN0IG0gPSBuZXcgbW9uZ29vc2UuTW9uZ29vc2UoKTtcbiAqXG4gKiBAYXBpIHB1YmxpY1xuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgc2VlIFtgTW9uZ29vc2Ujc2V0KClgIGRvY3NdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvbW9uZ29vc2UuaHRtbCNNb25nb29zZS5wcm90b3R5cGUuc2V0KCkpXG4gKi9cbmZ1bmN0aW9uIE1vbmdvb3NlKG9wdGlvbnMpIHtcbiAgdGhpcy5jb25uZWN0aW9ucyA9IFtdO1xuICB0aGlzLm5leHRDb25uZWN0aW9uSWQgPSAwO1xuICB0aGlzLm1vZGVscyA9IHt9O1xuICB0aGlzLmV2ZW50cyA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgdGhpcy5fX2RyaXZlciA9IGRyaXZlci5nZXQoKTtcbiAgLy8gZGVmYXVsdCBnbG9iYWwgb3B0aW9uc1xuICB0aGlzLm9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHtcbiAgICBwbHVyYWxpemF0aW9uOiB0cnVlLFxuICAgIGF1dG9JbmRleDogdHJ1ZSxcbiAgICBhdXRvQ3JlYXRlOiB0cnVlLFxuICAgIGF1dG9TZWFyY2hJbmRleDogZmFsc2VcbiAgfSwgb3B0aW9ucyk7XG4gIGNvbnN0IGNyZWF0ZUluaXRpYWxDb25uZWN0aW9uID0gdXRpbHMuZ2V0T3B0aW9uKCdjcmVhdGVJbml0aWFsQ29ubmVjdGlvbicsIHRoaXMub3B0aW9ucyk7XG4gIGlmIChjcmVhdGVJbml0aWFsQ29ubmVjdGlvbiA9PSBudWxsIHx8IGNyZWF0ZUluaXRpYWxDb25uZWN0aW9uKSB7XG4gICAgY29uc3QgY29ubiA9IHRoaXMuY3JlYXRlQ29ubmVjdGlvbigpOyAvLyBkZWZhdWx0IGNvbm5lY3Rpb25cbiAgICBjb25uLm1vZGVscyA9IHRoaXMubW9kZWxzO1xuICB9XG5cbiAgaWYgKHRoaXMub3B0aW9ucy5wbHVyYWxpemF0aW9uKSB7XG4gICAgdGhpcy5fcGx1cmFsaXplID0gbGVnYWN5UGx1cmFsaXplO1xuICB9XG5cbiAgLy8gSWYgYSB1c2VyIGNyZWF0ZXMgdGhlaXIgb3duIE1vbmdvb3NlIGluc3RhbmNlLCBnaXZlIHRoZW0gYSBzZXBhcmF0ZSBjb3B5XG4gIC8vIG9mIHRoZSBgU2NoZW1hYCBjb25zdHJ1Y3RvciBzbyB0aGV5IGdldCBzZXBhcmF0ZSBjdXN0b20gdHlwZXMuIChnaC02OTMzKVxuICBpZiAoIW9wdGlvbnMgfHwgIW9wdGlvbnNbZGVmYXVsdE1vbmdvb3NlU3ltYm9sXSkge1xuICAgIGNvbnN0IF90aGlzID0gdGhpcztcbiAgICB0aGlzLlNjaGVtYSA9IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5iYXNlID0gX3RoaXM7XG4gICAgICByZXR1cm4gU2NoZW1hLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgICB0aGlzLlNjaGVtYS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFNjaGVtYS5wcm90b3R5cGUpO1xuXG4gICAgT2JqZWN0LmFzc2lnbih0aGlzLlNjaGVtYSwgU2NoZW1hKTtcbiAgICB0aGlzLlNjaGVtYS5iYXNlID0gdGhpcztcbiAgICB0aGlzLlNjaGVtYS5UeXBlcyA9IE9iamVjdC5hc3NpZ24oe30sIFNjaGVtYS5UeXBlcyk7XG4gIH0gZWxzZSB7XG4gICAgLy8gSGFjayB0byB3b3JrIGFyb3VuZCBiYWJlbCdzIHN0cmFuZ2UgYmVoYXZpb3Igd2l0aFxuICAgIC8vIGBpbXBvcnQgbW9uZ29vc2UsIHsgU2NoZW1hIH0gZnJvbSAnbW9uZ29vc2UnYC4gQmVjYXVzZSBgU2NoZW1hYCBpcyBub3RcbiAgICAvLyBhbiBvd24gcHJvcGVydHkgb2YgYSBNb25nb29zZSBnbG9iYWwsIFNjaGVtYSB3aWxsIGJlIHVuZGVmaW5lZC4gU2VlIGdoLTU2NDhcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBbJ1NjaGVtYScsICdtb2RlbCddKSB7XG4gICAgICB0aGlzW2tleV0gPSBNb25nb29zZS5wcm90b3R5cGVba2V5XTtcbiAgICB9XG4gIH1cbiAgdGhpcy5TY2hlbWEucHJvdG90eXBlLmJhc2UgPSB0aGlzO1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAncGx1Z2lucycsIHtcbiAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgd3JpdGFibGU6IGZhbHNlLFxuICAgIHZhbHVlOiBPYmplY3QudmFsdWVzKGJ1aWx0aW5QbHVnaW5zKS5tYXAocGx1Z2luID0+IChbcGx1Z2luLCB7IGRlZHVwbGljYXRlOiB0cnVlIH1dKSlcbiAgfSk7XG59XG5cbk1vbmdvb3NlLnByb3RvdHlwZS5jYXN0ID0gY2FzdDtcbi8qKlxuICogRXhwb3NlIGNvbm5lY3Rpb24gc3RhdGVzIGZvciB1c2VyLWxhbmRcbiAqXG4gKiBAbWVtYmVyT2YgTW9uZ29vc2VcbiAqIEBwcm9wZXJ0eSBTVEFURVNcbiAqIEBhcGkgcHVibGljXG4gKi9cbk1vbmdvb3NlLnByb3RvdHlwZS5TVEFURVMgPSBTVEFURVM7XG5cbi8qKlxuICogRXhwb3NlIGNvbm5lY3Rpb24gc3RhdGVzIGZvciB1c2VyLWxhbmRcbiAqXG4gKiBAbWVtYmVyT2YgTW9uZ29vc2VcbiAqIEBwcm9wZXJ0eSBDb25uZWN0aW9uU3RhdGVzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5Nb25nb29zZS5wcm90b3R5cGUuQ29ubmVjdGlvblN0YXRlcyA9IFNUQVRFUztcblxuLyoqXG4gKiBPYmplY3Qgd2l0aCBgZ2V0KClgIGFuZCBgc2V0KClgIGNvbnRhaW5pbmcgdGhlIHVuZGVybHlpbmcgZHJpdmVyIHRoaXMgTW9uZ29vc2UgaW5zdGFuY2VcbiAqIHVzZXMgdG8gY29tbXVuaWNhdGUgd2l0aCB0aGUgZGF0YWJhc2UuIEEgZHJpdmVyIGlzIGEgTW9uZ29vc2Utc3BlY2lmaWMgaW50ZXJmYWNlIHRoYXQgZGVmaW5lcyBmdW5jdGlvbnNcbiAqIGxpa2UgYGZpbmQoKWAuXG4gKlxuICogQGRlcHJlY2F0ZWRcbiAqIEBtZW1iZXJPZiBNb25nb29zZVxuICogQHByb3BlcnR5IGRyaXZlclxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Nb25nb29zZS5wcm90b3R5cGUuZHJpdmVyID0gZHJpdmVyO1xuXG4vKipcbiAqIE92ZXJ3cml0ZXMgdGhlIGN1cnJlbnQgZHJpdmVyIHVzZWQgYnkgdGhpcyBNb25nb29zZSBpbnN0YW5jZS4gQSBkcml2ZXIgaXMgYVxuICogTW9uZ29vc2Utc3BlY2lmaWMgaW50ZXJmYWNlIHRoYXQgZGVmaW5lcyBmdW5jdGlvbnMgbGlrZSBgZmluZCgpYC5cbiAqXG4gKiBAbWVtYmVyT2YgTW9uZ29vc2VcbiAqIEBtZXRob2Qgc2V0RHJpdmVyXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk1vbmdvb3NlLnByb3RvdHlwZS5zZXREcml2ZXIgPSBmdW5jdGlvbiBzZXREcml2ZXIoZHJpdmVyKSB7XG4gIGNvbnN0IF9tb25nb29zZSA9IHRoaXMgaW5zdGFuY2VvZiBNb25nb29zZSA/IHRoaXMgOiBtb25nb29zZTtcblxuICBpZiAoX21vbmdvb3NlLl9fZHJpdmVyID09PSBkcml2ZXIpIHtcbiAgICByZXR1cm4gX21vbmdvb3NlO1xuICB9XG5cbiAgY29uc3Qgb3BlbkNvbm5lY3Rpb24gPSBfbW9uZ29vc2UuY29ubmVjdGlvbnMgJiYgX21vbmdvb3NlLmNvbm5lY3Rpb25zLmZpbmQoY29ubiA9PiBjb25uLnJlYWR5U3RhdGUgIT09IFNUQVRFUy5kaXNjb25uZWN0ZWQpO1xuICBpZiAob3BlbkNvbm5lY3Rpb24pIHtcbiAgICBjb25zdCBtc2cgPSAnQ2Fubm90IG1vZGlmeSBNb25nb29zZSBkcml2ZXIgaWYgYSBjb25uZWN0aW9uIGlzIGFscmVhZHkgb3Blbi4gJyArXG4gICAgICAnQ2FsbCBgbW9uZ29vc2UuZGlzY29ubmVjdCgpYCBiZWZvcmUgbW9kaWZ5aW5nIHRoZSBkcml2ZXInO1xuICAgIHRocm93IG5ldyBNb25nb29zZUVycm9yKG1zZyk7XG4gIH1cbiAgX21vbmdvb3NlLl9fZHJpdmVyID0gZHJpdmVyO1xuXG4gIGNvbnN0IENvbm5lY3Rpb24gPSBkcml2ZXIuQ29ubmVjdGlvbjtcbiAgX21vbmdvb3NlLmNvbm5lY3Rpb25zID0gW25ldyBDb25uZWN0aW9uKF9tb25nb29zZSldO1xuICBfbW9uZ29vc2UuY29ubmVjdGlvbnNbMF0ubW9kZWxzID0gX21vbmdvb3NlLm1vZGVscztcblxuICByZXR1cm4gX21vbmdvb3NlO1xufTtcblxuLyoqXG4gKiBTZXRzIG1vbmdvb3NlIG9wdGlvbnNcbiAqXG4gKiBga2V5YCBjYW4gYmUgdXNlZCBhIG9iamVjdCB0byBzZXQgbXVsdGlwbGUgb3B0aW9ucyBhdCBvbmNlLlxuICogSWYgYSBlcnJvciBnZXRzIHRocm93biBmb3Igb25lIG9wdGlvbiwgb3RoZXIgb3B0aW9ucyB3aWxsIHN0aWxsIGJlIGV2YWx1YXRlZC5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIG1vbmdvb3NlLnNldCgndGVzdCcsIHZhbHVlKSAvLyBzZXRzIHRoZSAndGVzdCcgb3B0aW9uIHRvIGB2YWx1ZWBcbiAqXG4gKiAgICAgbW9uZ29vc2Uuc2V0KCdkZWJ1ZycsIHRydWUpIC8vIGVuYWJsZSBsb2dnaW5nIGNvbGxlY3Rpb24gbWV0aG9kcyArIGFyZ3VtZW50cyB0byB0aGUgY29uc29sZS9maWxlXG4gKlxuICogICAgIG1vbmdvb3NlLnNldCgnZGVidWcnLCBmdW5jdGlvbihjb2xsZWN0aW9uTmFtZSwgbWV0aG9kTmFtZSwgLi4ubWV0aG9kQXJncykge30pOyAvLyB1c2UgY3VzdG9tIGZ1bmN0aW9uIHRvIGxvZyBjb2xsZWN0aW9uIG1ldGhvZHMgKyBhcmd1bWVudHNcbiAqXG4gKiAgICAgbW9uZ29vc2Uuc2V0KHsgZGVidWc6IHRydWUsIGF1dG9JbmRleDogZmFsc2UgfSk7IC8vIHNldCBtdWx0aXBsZSBvcHRpb25zIGF0IG9uY2VcbiAqXG4gKiBDdXJyZW50bHkgc3VwcG9ydGVkIG9wdGlvbnMgYXJlOlxuICogLSBgYWxsb3dEaXNrVXNlYDogU2V0IHRvIGB0cnVlYCB0byBzZXQgYGFsbG93RGlza1VzZWAgdG8gdHJ1ZSB0byBhbGwgYWdncmVnYXRpb24gb3BlcmF0aW9ucyBieSBkZWZhdWx0LlxuICogLSBgYXBwbHlQbHVnaW5zVG9DaGlsZFNjaGVtYXNgOiBgdHJ1ZWAgYnkgZGVmYXVsdC4gU2V0IHRvIGZhbHNlIHRvIHNraXAgYXBwbHlpbmcgZ2xvYmFsIHBsdWdpbnMgdG8gY2hpbGQgc2NoZW1hc1xuICogLSBgYXBwbHlQbHVnaW5zVG9EaXNjcmltaW5hdG9yc2A6IGBmYWxzZWAgYnkgZGVmYXVsdC4gU2V0IHRvIHRydWUgdG8gYXBwbHkgZ2xvYmFsIHBsdWdpbnMgdG8gZGlzY3JpbWluYXRvciBzY2hlbWFzLiBUaGlzIHR5cGljYWxseSBpc24ndCBuZWNlc3NhcnkgYmVjYXVzZSBwbHVnaW5zIGFyZSBhcHBsaWVkIHRvIHRoZSBiYXNlIHNjaGVtYSBhbmQgZGlzY3JpbWluYXRvcnMgY29weSBhbGwgbWlkZGxld2FyZSwgbWV0aG9kcywgc3RhdGljcywgYW5kIHByb3BlcnRpZXMgZnJvbSB0aGUgYmFzZSBzY2hlbWEuXG4gKiAtIGBhdXRvQ3JlYXRlYDogU2V0IHRvIGB0cnVlYCB0byBtYWtlIE1vbmdvb3NlIGNhbGwgW2BNb2RlbC5jcmVhdGVDb2xsZWN0aW9uKClgXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvYXBpL21vZGVsLmh0bWwjTW9kZWwuY3JlYXRlQ29sbGVjdGlvbigpKSBhdXRvbWF0aWNhbGx5IHdoZW4geW91IGNyZWF0ZSBhIG1vZGVsIHdpdGggYG1vbmdvb3NlLm1vZGVsKClgIG9yIGBjb25uLm1vZGVsKClgLiBUaGlzIGlzIHVzZWZ1bCBmb3IgdGVzdGluZyB0cmFuc2FjdGlvbnMsIGNoYW5nZSBzdHJlYW1zLCBhbmQgb3RoZXIgZmVhdHVyZXMgdGhhdCByZXF1aXJlIHRoZSBjb2xsZWN0aW9uIHRvIGV4aXN0LlxuICogLSBgYXV0b0luZGV4YDogYHRydWVgIGJ5IGRlZmF1bHQuIFNldCB0byBmYWxzZSB0byBkaXNhYmxlIGF1dG9tYXRpYyBpbmRleCBjcmVhdGlvbiBmb3IgYWxsIG1vZGVscyBhc3NvY2lhdGVkIHdpdGggdGhpcyBNb25nb29zZSBpbnN0YW5jZS5cbiAqIC0gYGJ1ZmZlckNvbW1hbmRzYDogZW5hYmxlL2Rpc2FibGUgbW9uZ29vc2UncyBidWZmZXJpbmcgbWVjaGFuaXNtIGZvciBhbGwgY29ubmVjdGlvbnMgYW5kIG1vZGVsc1xuICogLSBgYnVmZmVyVGltZW91dE1TYDogSWYgYnVmZmVyQ29tbWFuZHMgaXMgb24sIHRoaXMgb3B0aW9uIHNldHMgdGhlIG1heGltdW0gYW1vdW50IG9mIHRpbWUgTW9uZ29vc2UgYnVmZmVyaW5nIHdpbGwgd2FpdCBiZWZvcmUgdGhyb3dpbmcgYW4gZXJyb3IuIElmIG5vdCBzcGVjaWZpZWQsIE1vbmdvb3NlIHdpbGwgdXNlIDEwMDAwICgxMCBzZWNvbmRzKS5cbiAqIC0gYGNsb25lU2NoZW1hc2A6IGBmYWxzZWAgYnkgZGVmYXVsdC4gU2V0IHRvIGB0cnVlYCB0byBgY2xvbmUoKWAgYWxsIHNjaGVtYXMgYmVmb3JlIGNvbXBpbGluZyBpbnRvIGEgbW9kZWwuXG4gKiAtIGBkZWJ1Z2A6IElmIGB0cnVlYCwgcHJpbnRzIHRoZSBvcGVyYXRpb25zIG1vbmdvb3NlIHNlbmRzIHRvIE1vbmdvREIgdG8gdGhlIGNvbnNvbGUuIElmIGEgd3JpdGFibGUgc3RyZWFtIGlzIHBhc3NlZCwgaXQgd2lsbCBsb2cgdG8gdGhhdCBzdHJlYW0sIHdpdGhvdXQgY29sb3JpemF0aW9uLiBJZiBhIGNhbGxiYWNrIGZ1bmN0aW9uIGlzIHBhc3NlZCwgaXQgd2lsbCByZWNlaXZlIHRoZSBjb2xsZWN0aW9uIG5hbWUsIHRoZSBtZXRob2QgbmFtZSwgdGhlbiBhbGwgYXJndW1lbnRzIHBhc3NlZCB0byB0aGUgbWV0aG9kLiBGb3IgZXhhbXBsZSwgaWYgeW91IHdhbnRlZCB0byByZXBsaWNhdGUgdGhlIGRlZmF1bHQgbG9nZ2luZywgeW91IGNvdWxkIG91dHB1dCBmcm9tIHRoZSBjYWxsYmFjayBgTW9uZ29vc2U6ICR7Y29sbGVjdGlvbk5hbWV9LiR7bWV0aG9kTmFtZX0oJHttZXRob2RBcmdzLmpvaW4oJywgJyl9KWAuXG4gKiAtIGBpZGA6IElmIGB0cnVlYCwgYWRkcyBhIGBpZGAgdmlydHVhbCB0byBhbGwgc2NoZW1hcyB1bmxlc3Mgb3ZlcndyaXR0ZW4gb24gYSBwZXItc2NoZW1hIGJhc2lzLlxuICogLSBgdGltZXN0YW1wcy5jcmVhdGVkQXQuaW1tdXRhYmxlYDogYHRydWVgIGJ5IGRlZmF1bHQuIElmIGBmYWxzZWAsIGl0IHdpbGwgY2hhbmdlIHRoZSBgY3JlYXRlZEF0YCBmaWVsZCB0byBiZSBbYGltbXV0YWJsZTogZmFsc2VgXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvYXBpL3NjaGVtYXR5cGUuaHRtbCNTY2hlbWFUeXBlLnByb3RvdHlwZS5pbW11dGFibGUpIHdoaWNoIG1lYW5zIHlvdSBjYW4gdXBkYXRlIHRoZSBgY3JlYXRlZEF0YFxuICogLSBgbWF4VGltZU1TYDogSWYgc2V0LCBhdHRhY2hlcyBbbWF4VGltZU1TXShodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9yZWZlcmVuY2Uvb3BlcmF0b3IvbWV0YS9tYXhUaW1lTVMvKSB0byBldmVyeSBxdWVyeVxuICogLSBgb2JqZWN0SWRHZXR0ZXJgOiBgdHJ1ZWAgYnkgZGVmYXVsdC4gTW9uZ29vc2UgYWRkcyBhIGdldHRlciB0byBNb25nb0RCIE9iamVjdElkJ3MgY2FsbGVkIGBfaWRgIHRoYXQgcmV0dXJucyBgdGhpc2AgZm9yIGNvbnZlbmllbmNlIHdpdGggcG9wdWxhdGUuIFNldCB0aGlzIHRvIGZhbHNlIHRvIHJlbW92ZSB0aGUgZ2V0dGVyLlxuICogLSBgb3ZlcndyaXRlTW9kZWxzYDogU2V0IHRvIGB0cnVlYCB0byBkZWZhdWx0IHRvIG92ZXJ3cml0aW5nIG1vZGVscyB3aXRoIHRoZSBzYW1lIG5hbWUgd2hlbiBjYWxsaW5nIGBtb25nb29zZS5tb2RlbCgpYCwgYXMgb3Bwb3NlZCB0byB0aHJvd2luZyBhbiBgT3ZlcndyaXRlTW9kZWxFcnJvcmAuXG4gKiAtIGByZXR1cm5PcmlnaW5hbGA6IElmIGBmYWxzZWAsIGNoYW5nZXMgdGhlIGRlZmF1bHQgYHJldHVybk9yaWdpbmFsYCBvcHRpb24gdG8gYGZpbmRPbmVBbmRVcGRhdGUoKWAsIGBmaW5kQnlJZEFuZFVwZGF0ZWAsIGFuZCBgZmluZE9uZUFuZFJlcGxhY2UoKWAgdG8gZmFsc2UuIFRoaXMgaXMgZXF1aXZhbGVudCB0byBzZXR0aW5nIHRoZSBgbmV3YCBvcHRpb24gdG8gYHRydWVgIGZvciBgZmluZE9uZUFuZFgoKWAgY2FsbHMgYnkgZGVmYXVsdC4gUmVhZCBvdXIgW2BmaW5kT25lQW5kVXBkYXRlKClgIHR1dG9yaWFsXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvdHV0b3JpYWxzL2ZpbmRvbmVhbmR1cGRhdGUuaHRtbCkgZm9yIG1vcmUgaW5mb3JtYXRpb24uXG4gKiAtIGBydW5WYWxpZGF0b3JzYDogYGZhbHNlYCBieSBkZWZhdWx0LiBTZXQgdG8gdHJ1ZSB0byBlbmFibGUgW3VwZGF0ZSB2YWxpZGF0b3JzXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvdmFsaWRhdGlvbi5odG1sI3VwZGF0ZS12YWxpZGF0b3JzKSBmb3IgYWxsIHZhbGlkYXRvcnMgYnkgZGVmYXVsdC5cbiAqIC0gYHNhbml0aXplRmlsdGVyYDogYGZhbHNlYCBieSBkZWZhdWx0LiBTZXQgdG8gdHJ1ZSB0byBlbmFibGUgdGhlIFtzYW5pdGl6YXRpb24gb2YgdGhlIHF1ZXJ5IGZpbHRlcnNdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvbW9uZ29vc2UuaHRtbCNNb25nb29zZS5wcm90b3R5cGUuc2FuaXRpemVGaWx0ZXIoKSkgYWdhaW5zdCBxdWVyeSBzZWxlY3RvciBpbmplY3Rpb24gYXR0YWNrcyBieSB3cmFwcGluZyBhbnkgbmVzdGVkIG9iamVjdHMgdGhhdCBoYXZlIGEgcHJvcGVydHkgd2hvc2UgbmFtZSBzdGFydHMgd2l0aCBgJGAgaW4gYSBgJGVxYC5cbiAqIC0gYHNlbGVjdFBvcHVsYXRlZFBhdGhzYDogYHRydWVgIGJ5IGRlZmF1bHQuIFNldCB0byBmYWxzZSB0byBvcHQgb3V0IG9mIE1vbmdvb3NlIGFkZGluZyBhbGwgZmllbGRzIHRoYXQgeW91IGBwb3B1bGF0ZSgpYCB0byB5b3VyIGBzZWxlY3QoKWAuIFRoZSBzY2hlbWEtbGV2ZWwgb3B0aW9uIGBzZWxlY3RQb3B1bGF0ZWRQYXRoc2Agb3ZlcndyaXRlcyB0aGlzIG9uZS5cbiAqIC0gYHN0cmljdGA6IGB0cnVlYCBieSBkZWZhdWx0LCBtYXkgYmUgYGZhbHNlYCwgYHRydWVgLCBvciBgJ3Rocm93J2AuIFNldHMgdGhlIGRlZmF1bHQgc3RyaWN0IG1vZGUgZm9yIHNjaGVtYXMuXG4gKiAtIGBzdHJpY3RRdWVyeWA6IGBmYWxzZWAgYnkgZGVmYXVsdC4gTWF5IGJlIGBmYWxzZWAsIGB0cnVlYCwgb3IgYCd0aHJvdydgLiBTZXRzIHRoZSBkZWZhdWx0IFtzdHJpY3RRdWVyeV0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2d1aWRlLmh0bWwjc3RyaWN0UXVlcnkpIG1vZGUgZm9yIHNjaGVtYXMuXG4gKiAtIGB0b0pTT05gOiBgeyB0cmFuc2Zvcm06IHRydWUsIGZsYXR0ZW5EZWNpbWFsczogdHJ1ZSB9YCBieSBkZWZhdWx0LiBPdmVyd3JpdGVzIGRlZmF1bHQgb2JqZWN0cyB0byBbYHRvSlNPTigpYF0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2FwaS9kb2N1bWVudC5odG1sI0RvY3VtZW50LnByb3RvdHlwZS50b0pTT04oKSksIGZvciBkZXRlcm1pbmluZyBob3cgTW9uZ29vc2UgZG9jdW1lbnRzIGdldCBzZXJpYWxpemVkIGJ5IGBKU09OLnN0cmluZ2lmeSgpYFxuICogLSBgdG9PYmplY3RgOiBgeyB0cmFuc2Zvcm06IHRydWUsIGZsYXR0ZW5EZWNpbWFsczogdHJ1ZSB9YCBieSBkZWZhdWx0LiBPdmVyd3JpdGVzIGRlZmF1bHQgb2JqZWN0cyB0byBbYHRvT2JqZWN0KClgXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvYXBpL2RvY3VtZW50Lmh0bWwjRG9jdW1lbnQucHJvdG90eXBlLnRvT2JqZWN0KCkpXG4gKlxuICogQHBhcmFtIHtTdHJpbmd8T2JqZWN0fSBrZXkgVGhlIG5hbWUgb2YgdGhlIG9wdGlvbiBvciBhIG9iamVjdCBvZiBtdWx0aXBsZSBrZXktdmFsdWUgcGFpcnNcbiAqIEBwYXJhbSB7U3RyaW5nfEZ1bmN0aW9ufEJvb2xlYW59IHZhbHVlIFRoZSB2YWx1ZSBvZiB0aGUgb3B0aW9uLCB1bnVzZWQgaWYgXCJrZXlcIiBpcyBhIG9iamVjdFxuICogQHJldHVybnMge01vbmdvb3NlfSBUaGUgdXNlZCBNb25nb29zZSBpbnN0bmFjZVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Nb25nb29zZS5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuICBjb25zdCBfbW9uZ29vc2UgPSB0aGlzIGluc3RhbmNlb2YgTW9uZ29vc2UgPyB0aGlzIDogbW9uZ29vc2U7XG5cbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEgJiYgdHlwZW9mIGtleSAhPT0gJ29iamVjdCcpIHtcbiAgICBpZiAoVkFMSURfT1BUSU9OUy5pbmRleE9mKGtleSkgPT09IC0xKSB7XG4gICAgICBjb25zdCBlcnJvciA9IG5ldyBTZXRPcHRpb25FcnJvcigpO1xuICAgICAgZXJyb3IuYWRkRXJyb3Ioa2V5LCBuZXcgU2V0T3B0aW9uRXJyb3IuU2V0T3B0aW9uSW5uZXJFcnJvcihrZXkpKTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cblxuICAgIHJldHVybiBfbW9uZ29vc2Uub3B0aW9uc1trZXldO1xuICB9XG5cbiAgbGV0IG9wdGlvbnMgPSB7fTtcblxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgIG9wdGlvbnMgPSB7IFtrZXldOiB2YWx1ZSB9O1xuICB9XG5cbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEgJiYgdHlwZW9mIGtleSA9PT0gJ29iamVjdCcpIHtcbiAgICBvcHRpb25zID0ga2V5O1xuICB9XG5cbiAgLy8gYXJyYXkgZm9yIGVycm9ycyB0byBjb2xsZWN0IGFsbCBlcnJvcnMgZm9yIGFsbCBrZXktdmFsdWUgcGFpcnMsIGxpa2UgXCIudmFsaWRhdGVcIlxuICBsZXQgZXJyb3IgPSB1bmRlZmluZWQ7XG5cbiAgZm9yIChjb25zdCBbb3B0aW9uS2V5LCBvcHRpb25WYWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMob3B0aW9ucykpIHtcbiAgICBpZiAoVkFMSURfT1BUSU9OUy5pbmRleE9mKG9wdGlvbktleSkgPT09IC0xKSB7XG4gICAgICBpZiAoIWVycm9yKSB7XG4gICAgICAgIGVycm9yID0gbmV3IFNldE9wdGlvbkVycm9yKCk7XG4gICAgICB9XG4gICAgICBlcnJvci5hZGRFcnJvcihvcHRpb25LZXksIG5ldyBTZXRPcHRpb25FcnJvci5TZXRPcHRpb25Jbm5lckVycm9yKG9wdGlvbktleSkpO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgX21vbmdvb3NlLm9wdGlvbnNbb3B0aW9uS2V5XSA9IG9wdGlvblZhbHVlO1xuXG4gICAgaWYgKG9wdGlvbktleSA9PT0gJ29iamVjdElkR2V0dGVyJykge1xuICAgICAgaWYgKG9wdGlvblZhbHVlKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtb25nb29zZS5UeXBlcy5PYmplY3RJZC5wcm90b3R5cGUsICdfaWQnLCB7XG4gICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVsZXRlIG1vbmdvb3NlLlR5cGVzLk9iamVjdElkLnByb3RvdHlwZS5faWQ7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKGVycm9yKSB7XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cblxuICByZXR1cm4gX21vbmdvb3NlO1xufTtcblxuLyoqXG4gKiBHZXRzIG1vbmdvb3NlIG9wdGlvbnNcbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIG1vbmdvb3NlLmdldCgndGVzdCcpIC8vIHJldHVybnMgdGhlICd0ZXN0JyB2YWx1ZVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBrZXlcbiAqIEBtZXRob2QgZ2V0XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk1vbmdvb3NlLnByb3RvdHlwZS5nZXQgPSBNb25nb29zZS5wcm90b3R5cGUuc2V0O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBDb25uZWN0aW9uIGluc3RhbmNlLlxuICpcbiAqIEVhY2ggYGNvbm5lY3Rpb25gIGluc3RhbmNlIG1hcHMgdG8gYSBzaW5nbGUgZGF0YWJhc2UuIFRoaXMgbWV0aG9kIGlzIGhlbHBmdWwgd2hlbiBtYW5hZ2luZyBtdWx0aXBsZSBkYiBjb25uZWN0aW9ucy5cbiAqXG4gKlxuICogX09wdGlvbnMgcGFzc2VkIHRha2UgcHJlY2VkZW5jZSBvdmVyIG9wdGlvbnMgaW5jbHVkZWQgaW4gY29ubmVjdGlvbiBzdHJpbmdzLl9cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIC8vIHdpdGggbW9uZ29kYjovLyBVUklcbiAqICAgICBkYiA9IG1vbmdvb3NlLmNyZWF0ZUNvbm5lY3Rpb24oJ21vbmdvZGI6Ly91c2VyOnBhc3NAMTI3LjAuMC4xOnBvcnQvZGF0YWJhc2UnKTtcbiAqXG4gKiAgICAgLy8gYW5kIG9wdGlvbnNcbiAqICAgICBjb25zdCBvcHRzID0geyBkYjogeyBuYXRpdmVfcGFyc2VyOiB0cnVlIH19XG4gKiAgICAgZGIgPSBtb25nb29zZS5jcmVhdGVDb25uZWN0aW9uKCdtb25nb2RiOi8vdXNlcjpwYXNzQDEyNy4wLjAuMTpwb3J0L2RhdGFiYXNlJywgb3B0cyk7XG4gKlxuICogICAgIC8vIHJlcGxpY2Egc2V0c1xuICogICAgIGRiID0gbW9uZ29vc2UuY3JlYXRlQ29ubmVjdGlvbignbW9uZ29kYjovL3VzZXI6cGFzc0AxMjcuMC4wLjE6cG9ydCxhbm90aGVyaG9zdDpwb3J0LHlldGFub3RoZXI6cG9ydC9kYXRhYmFzZScpO1xuICpcbiAqICAgICAvLyBhbmQgb3B0aW9uc1xuICogICAgIGNvbnN0IG9wdHMgPSB7IHJlcGxzZXQ6IHsgc3RyYXRlZ3k6ICdwaW5nJywgcnNfbmFtZTogJ3Rlc3RTZXQnIH19XG4gKiAgICAgZGIgPSBtb25nb29zZS5jcmVhdGVDb25uZWN0aW9uKCdtb25nb2RiOi8vdXNlcjpwYXNzQDEyNy4wLjAuMTpwb3J0LGFub3RoZXJob3N0OnBvcnQseWV0YW5vdGhlcjpwb3J0L2RhdGFiYXNlJywgb3B0cyk7XG4gKlxuICogICAgIC8vIGluaXRpYWxpemUgbm93LCBjb25uZWN0IGxhdGVyXG4gKiAgICAgZGIgPSBtb25nb29zZS5jcmVhdGVDb25uZWN0aW9uKCk7XG4gKiAgICAgZGIub3BlblVyaSgnMTI3LjAuMC4xJywgJ2RhdGFiYXNlJywgcG9ydCwgW29wdHNdKTtcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdXJpIG1vbmdvZGIgVVJJIHRvIGNvbm5lY3QgdG9cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gcGFzc2VkIGRvd24gdG8gdGhlIFtNb25nb0RCIGRyaXZlcidzIGBjb25uZWN0KClgIGZ1bmN0aW9uXShodHRwczovL21vbmdvZGIuZ2l0aHViLmlvL25vZGUtbW9uZ29kYi1uYXRpdmUvNC45L2ludGVyZmFjZXMvTW9uZ29DbGllbnRPcHRpb25zLmh0bWwpLCBleGNlcHQgZm9yIDQgbW9uZ29vc2Utc3BlY2lmaWMgb3B0aW9ucyBleHBsYWluZWQgYmVsb3cuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmJ1ZmZlckNvbW1hbmRzPXRydWVdIE1vbmdvb3NlIHNwZWNpZmljIG9wdGlvbi4gU2V0IHRvIGZhbHNlIHRvIFtkaXNhYmxlIGJ1ZmZlcmluZ10oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2ZhcS5odG1sI2NhbGxiYWNrX25ldmVyX2V4ZWN1dGVzKSBvbiBhbGwgbW9kZWxzIGFzc29jaWF0ZWQgd2l0aCB0aGlzIGNvbm5lY3Rpb24uXG4gKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuZGJOYW1lXSBUaGUgbmFtZSBvZiB0aGUgZGF0YWJhc2UgeW91IHdhbnQgdG8gdXNlLiBJZiBub3QgcHJvdmlkZWQsIE1vbmdvb3NlIHVzZXMgdGhlIGRhdGFiYXNlIG5hbWUgZnJvbSBjb25uZWN0aW9uIHN0cmluZy5cbiAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy51c2VyXSB1c2VybmFtZSBmb3IgYXV0aGVudGljYXRpb24sIGVxdWl2YWxlbnQgdG8gYG9wdGlvbnMuYXV0aC51c2VyYC4gTWFpbnRhaW5lZCBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkuXG4gKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMucGFzc10gcGFzc3dvcmQgZm9yIGF1dGhlbnRpY2F0aW9uLCBlcXVpdmFsZW50IHRvIGBvcHRpb25zLmF1dGgucGFzc3dvcmRgLiBNYWludGFpbmVkIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eS5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuYXV0b0luZGV4PXRydWVdIE1vbmdvb3NlLXNwZWNpZmljIG9wdGlvbi4gU2V0IHRvIGZhbHNlIHRvIGRpc2FibGUgYXV0b21hdGljIGluZGV4IGNyZWF0aW9uIGZvciBhbGwgbW9kZWxzIGFzc29jaWF0ZWQgd2l0aCB0aGlzIGNvbm5lY3Rpb24uXG4gKiBAcGFyYW0ge0NsYXNzfSBbb3B0aW9ucy5wcm9taXNlTGlicmFyeV0gU2V0cyB0aGUgW3VuZGVybHlpbmcgZHJpdmVyJ3MgcHJvbWlzZSBsaWJyYXJ5XShodHRwczovL21vbmdvZGIuZ2l0aHViLmlvL25vZGUtbW9uZ29kYi1uYXRpdmUvNC45L2ludGVyZmFjZXMvTW9uZ29DbGllbnRPcHRpb25zLmh0bWwjcHJvbWlzZUxpYnJhcnkpLlxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLm1heFBvb2xTaXplPTVdIFRoZSBtYXhpbXVtIG51bWJlciBvZiBzb2NrZXRzIHRoZSBNb25nb0RCIGRyaXZlciB3aWxsIGtlZXAgb3BlbiBmb3IgdGhpcyBjb25uZWN0aW9uLiBLZWVwIGluIG1pbmQgdGhhdCBNb25nb0RCIG9ubHkgYWxsb3dzIG9uZSBvcGVyYXRpb24gcGVyIHNvY2tldCBhdCBhIHRpbWUsIHNvIHlvdSBtYXkgd2FudCB0byBpbmNyZWFzZSB0aGlzIGlmIHlvdSBmaW5kIHlvdSBoYXZlIGEgZmV3IHNsb3cgcXVlcmllcyB0aGF0IGFyZSBibG9ja2luZyBmYXN0ZXIgcXVlcmllcyBmcm9tIHByb2NlZWRpbmcuIFNlZSBbU2xvdyBUcmFpbnMgaW4gTW9uZ29EQiBhbmQgTm9kZS5qc10oaHR0cHM6Ly90aGVjb2RlYmFyYmFyaWFuLmNvbS9zbG93LXRyYWlucy1pbi1tb25nb2RiLWFuZC1ub2RlanMpLlxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLm1pblBvb2xTaXplPTFdIFRoZSBtaW5pbXVtIG51bWJlciBvZiBzb2NrZXRzIHRoZSBNb25nb0RCIGRyaXZlciB3aWxsIGtlZXAgb3BlbiBmb3IgdGhpcyBjb25uZWN0aW9uLiBLZWVwIGluIG1pbmQgdGhhdCBNb25nb0RCIG9ubHkgYWxsb3dzIG9uZSBvcGVyYXRpb24gcGVyIHNvY2tldCBhdCBhIHRpbWUsIHNvIHlvdSBtYXkgd2FudCB0byBpbmNyZWFzZSB0aGlzIGlmIHlvdSBmaW5kIHlvdSBoYXZlIGEgZmV3IHNsb3cgcXVlcmllcyB0aGF0IGFyZSBibG9ja2luZyBmYXN0ZXIgcXVlcmllcyBmcm9tIHByb2NlZWRpbmcuIFNlZSBbU2xvdyBUcmFpbnMgaW4gTW9uZ29EQiBhbmQgTm9kZS5qc10oaHR0cHM6Ly90aGVjb2RlYmFyYmFyaWFuLmNvbS9zbG93LXRyYWlucy1pbi1tb25nb2RiLWFuZC1ub2RlanMpLlxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnNvY2tldFRpbWVvdXRNUz0wXSBIb3cgbG9uZyB0aGUgTW9uZ29EQiBkcml2ZXIgd2lsbCB3YWl0IGJlZm9yZSBraWxsaW5nIGEgc29ja2V0IGR1ZSB0byBpbmFjdGl2aXR5IF9hZnRlciBpbml0aWFsIGNvbm5lY3Rpb25fLiBEZWZhdWx0cyB0byAwLCB3aGljaCBtZWFucyBOb2RlLmpzIHdpbGwgbm90IHRpbWUgb3V0IHRoZSBzb2NrZXQgZHVlIHRvIGluYWN0aXZpdHkuIEEgc29ja2V0IG1heSBiZSBpbmFjdGl2ZSBiZWNhdXNlIG9mIGVpdGhlciBubyBhY3Rpdml0eSBvciBhIGxvbmctcnVubmluZyBvcGVyYXRpb24uIFRoaXMgb3B0aW9uIGlzIHBhc3NlZCB0byBbTm9kZS5qcyBgc29ja2V0I3NldFRpbWVvdXQoKWAgZnVuY3Rpb25dKGh0dHBzOi8vbm9kZWpzLm9yZy9hcGkvbmV0Lmh0bWwjbmV0X3NvY2tldF9zZXR0aW1lb3V0X3RpbWVvdXRfY2FsbGJhY2spIGFmdGVyIHRoZSBNb25nb0RCIGRyaXZlciBzdWNjZXNzZnVsbHkgY29tcGxldGVzLlxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmZhbWlseT0wXSBQYXNzZWQgdHJhbnNwYXJlbnRseSB0byBbTm9kZS5qcycgYGRucy5sb29rdXAoKWBdKGh0dHBzOi8vbm9kZWpzLm9yZy9hcGkvZG5zLmh0bWwjZG5zX2Ruc19sb29rdXBfaG9zdG5hbWVfb3B0aW9uc19jYWxsYmFjaykgZnVuY3Rpb24uIE1heSBiZSBlaXRoZXIgYDBgLCBgNGAsIG9yIGA2YC4gYDRgIG1lYW5zIHVzZSBJUHY0IG9ubHksIGA2YCBtZWFucyB1c2UgSVB2NiBvbmx5LCBgMGAgbWVhbnMgdHJ5IGJvdGguXG4gKiBAcmV0dXJuIHtDb25uZWN0aW9ufSB0aGUgY3JlYXRlZCBDb25uZWN0aW9uIG9iamVjdC4gQ29ubmVjdGlvbnMgYXJlIG5vdCB0aGVuYWJsZSwgc28geW91IGNhbid0IGRvIGBhd2FpdCBtb25nb29zZS5jcmVhdGVDb25uZWN0aW9uKClgLiBUbyBhd2FpdCB1c2UgYG1vbmdvb3NlLmNyZWF0ZUNvbm5lY3Rpb24odXJpKS5hc1Byb21pc2UoKWAgaW5zdGVhZC5cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuTW9uZ29vc2UucHJvdG90eXBlLmNyZWF0ZUNvbm5lY3Rpb24gPSBmdW5jdGlvbih1cmksIG9wdGlvbnMpIHtcbiAgY29uc3QgX21vbmdvb3NlID0gdGhpcyBpbnN0YW5jZW9mIE1vbmdvb3NlID8gdGhpcyA6IG1vbmdvb3NlO1xuXG4gIGNvbnN0IENvbm5lY3Rpb24gPSBfbW9uZ29vc2UuX19kcml2ZXIuQ29ubmVjdGlvbjtcbiAgY29uc3QgY29ubiA9IG5ldyBDb25uZWN0aW9uKF9tb25nb29zZSk7XG4gIF9tb25nb29zZS5jb25uZWN0aW9ucy5wdXNoKGNvbm4pO1xuICBfbW9uZ29vc2UubmV4dENvbm5lY3Rpb25JZCsrO1xuICBfbW9uZ29vc2UuZXZlbnRzLmVtaXQoJ2NyZWF0ZUNvbm5lY3Rpb24nLCBjb25uKTtcblxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDApIHtcbiAgICBjb25uLm9wZW5VcmkodXJpLCB7IC4uLm9wdGlvbnMsIF9maXJlQW5kRm9yZ2V0OiB0cnVlIH0pO1xuICB9XG5cbiAgcmV0dXJuIGNvbm47XG59O1xuXG4vKipcbiAqIE9wZW5zIHRoZSBkZWZhdWx0IG1vbmdvb3NlIGNvbm5lY3Rpb24uXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBtb25nb29zZS5jb25uZWN0KCdtb25nb2RiOi8vdXNlcjpwYXNzQDEyNy4wLjAuMTpwb3J0L2RhdGFiYXNlJyk7XG4gKlxuICogICAgIC8vIHJlcGxpY2Egc2V0c1xuICogICAgIGNvbnN0IHVyaSA9ICdtb25nb2RiOi8vdXNlcjpwYXNzQDEyNy4wLjAuMTpwb3J0LGFub3RoZXJob3N0OnBvcnQseWV0YW5vdGhlcjpwb3J0L215ZGF0YWJhc2UnO1xuICogICAgIG1vbmdvb3NlLmNvbm5lY3QodXJpKTtcbiAqXG4gKiAgICAgLy8gd2l0aCBvcHRpb25zXG4gKiAgICAgbW9uZ29vc2UuY29ubmVjdCh1cmksIG9wdGlvbnMpO1xuICpcbiAqICAgICAvLyBvcHRpb25hbCBjYWxsYmFjayB0aGF0IGdldHMgZmlyZWQgd2hlbiBpbml0aWFsIGNvbm5lY3Rpb24gY29tcGxldGVkXG4gKiAgICAgY29uc3QgdXJpID0gJ21vbmdvZGI6Ly9ub25leGlzdGVudC5kb21haW46MjcwMDAnO1xuICogICAgIG1vbmdvb3NlLmNvbm5lY3QodXJpLCBmdW5jdGlvbihlcnJvcikge1xuICogICAgICAgLy8gaWYgZXJyb3IgaXMgdHJ1dGh5LCB0aGUgaW5pdGlhbCBjb25uZWN0aW9uIGZhaWxlZC5cbiAqICAgICB9KVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB1cmkgbW9uZ29kYiBVUkkgdG8gY29ubmVjdCB0b1xuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBwYXNzZWQgZG93biB0byB0aGUgW01vbmdvREIgZHJpdmVyJ3MgYGNvbm5lY3QoKWAgZnVuY3Rpb25dKGh0dHBzOi8vbW9uZ29kYi5naXRodWIuaW8vbm9kZS1tb25nb2RiLW5hdGl2ZS80LjkvaW50ZXJmYWNlcy9Nb25nb0NsaWVudE9wdGlvbnMuaHRtbCksIGV4Y2VwdCBmb3IgNCBtb25nb29zZS1zcGVjaWZpYyBvcHRpb25zIGV4cGxhaW5lZCBiZWxvdy5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuYnVmZmVyQ29tbWFuZHM9dHJ1ZV0gTW9uZ29vc2Ugc3BlY2lmaWMgb3B0aW9uLiBTZXQgdG8gZmFsc2UgdG8gW2Rpc2FibGUgYnVmZmVyaW5nXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvZmFxLmh0bWwjY2FsbGJhY2tfbmV2ZXJfZXhlY3V0ZXMpIG9uIGFsbCBtb2RlbHMgYXNzb2NpYXRlZCB3aXRoIHRoaXMgY29ubmVjdGlvbi5cbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5idWZmZXJUaW1lb3V0TVM9MTAwMDBdIE1vbmdvb3NlIHNwZWNpZmljIG9wdGlvbi4gSWYgYGJ1ZmZlckNvbW1hbmRzYCBpcyB0cnVlLCBNb25nb29zZSB3aWxsIHRocm93IGFuIGVycm9yIGFmdGVyIGBidWZmZXJUaW1lb3V0TVNgIGlmIHRoZSBvcGVyYXRpb24gaXMgc3RpbGwgYnVmZmVyZWQuXG4gKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuZGJOYW1lXSBUaGUgbmFtZSBvZiB0aGUgZGF0YWJhc2Ugd2Ugd2FudCB0byB1c2UuIElmIG5vdCBwcm92aWRlZCwgdXNlIGRhdGFiYXNlIG5hbWUgZnJvbSBjb25uZWN0aW9uIHN0cmluZy5cbiAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy51c2VyXSB1c2VybmFtZSBmb3IgYXV0aGVudGljYXRpb24sIGVxdWl2YWxlbnQgdG8gYG9wdGlvbnMuYXV0aC51c2VyYC4gTWFpbnRhaW5lZCBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkuXG4gKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMucGFzc10gcGFzc3dvcmQgZm9yIGF1dGhlbnRpY2F0aW9uLCBlcXVpdmFsZW50IHRvIGBvcHRpb25zLmF1dGgucGFzc3dvcmRgLiBNYWludGFpbmVkIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eS5cbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5tYXhQb29sU2l6ZT0xMDBdIFRoZSBtYXhpbXVtIG51bWJlciBvZiBzb2NrZXRzIHRoZSBNb25nb0RCIGRyaXZlciB3aWxsIGtlZXAgb3BlbiBmb3IgdGhpcyBjb25uZWN0aW9uLiBLZWVwIGluIG1pbmQgdGhhdCBNb25nb0RCIG9ubHkgYWxsb3dzIG9uZSBvcGVyYXRpb24gcGVyIHNvY2tldCBhdCBhIHRpbWUsIHNvIHlvdSBtYXkgd2FudCB0byBpbmNyZWFzZSB0aGlzIGlmIHlvdSBmaW5kIHlvdSBoYXZlIGEgZmV3IHNsb3cgcXVlcmllcyB0aGF0IGFyZSBibG9ja2luZyBmYXN0ZXIgcXVlcmllcyBmcm9tIHByb2NlZWRpbmcuIFNlZSBbU2xvdyBUcmFpbnMgaW4gTW9uZ29EQiBhbmQgTm9kZS5qc10oaHR0cHM6Ly90aGVjb2RlYmFyYmFyaWFuLmNvbS9zbG93LXRyYWlucy1pbi1tb25nb2RiLWFuZC1ub2RlanMpLlxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLm1pblBvb2xTaXplPTBdIFRoZSBtaW5pbXVtIG51bWJlciBvZiBzb2NrZXRzIHRoZSBNb25nb0RCIGRyaXZlciB3aWxsIGtlZXAgb3BlbiBmb3IgdGhpcyBjb25uZWN0aW9uLlxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnNlcnZlclNlbGVjdGlvblRpbWVvdXRNU10gSWYgYHVzZVVuaWZpZWRUb3BvbG9neSA9IHRydWVgLCB0aGUgTW9uZ29EQiBkcml2ZXIgd2lsbCB0cnkgdG8gZmluZCBhIHNlcnZlciB0byBzZW5kIGFueSBnaXZlbiBvcGVyYXRpb24gdG8sIGFuZCBrZWVwIHJldHJ5aW5nIGZvciBgc2VydmVyU2VsZWN0aW9uVGltZW91dE1TYCBtaWxsaXNlY29uZHMgYmVmb3JlIGVycm9yaW5nIG91dC4gSWYgbm90IHNldCwgdGhlIE1vbmdvREIgZHJpdmVyIGRlZmF1bHRzIHRvIHVzaW5nIGAzMDAwMGAgKDMwIHNlY29uZHMpLlxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmhlYXJ0YmVhdEZyZXF1ZW5jeU1TXSBJZiBgdXNlVW5pZmllZFRvcG9sb2d5ID0gdHJ1ZWAsIHRoZSBNb25nb0RCIGRyaXZlciBzZW5kcyBhIGhlYXJ0YmVhdCBldmVyeSBgaGVhcnRiZWF0RnJlcXVlbmN5TVNgIHRvIGNoZWNrIG9uIHRoZSBzdGF0dXMgb2YgdGhlIGNvbm5lY3Rpb24uIEEgaGVhcnRiZWF0IGlzIHN1YmplY3QgdG8gYHNlcnZlclNlbGVjdGlvblRpbWVvdXRNU2AsIHNvIHRoZSBNb25nb0RCIGRyaXZlciB3aWxsIHJldHJ5IGZhaWxlZCBoZWFydGJlYXRzIGZvciB1cCB0byAzMCBzZWNvbmRzIGJ5IGRlZmF1bHQuIE1vbmdvb3NlIG9ubHkgZW1pdHMgYSBgJ2Rpc2Nvbm5lY3RlZCdgIGV2ZW50IGFmdGVyIGEgaGVhcnRiZWF0IGhhcyBmYWlsZWQsIHNvIHlvdSBtYXkgd2FudCB0byBkZWNyZWFzZSB0aGlzIHNldHRpbmcgdG8gcmVkdWNlIHRoZSB0aW1lIGJldHdlZW4gd2hlbiB5b3VyIHNlcnZlciBnb2VzIGRvd24gYW5kIHdoZW4gTW9uZ29vc2UgZW1pdHMgYCdkaXNjb25uZWN0ZWQnYC4gV2UgcmVjb21tZW5kIHlvdSBkbyAqKm5vdCoqIHNldCB0aGlzIHNldHRpbmcgYmVsb3cgMTAwMCwgdG9vIG1hbnkgaGVhcnRiZWF0cyBjYW4gbGVhZCB0byBwZXJmb3JtYW5jZSBkZWdyYWRhdGlvbi5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuYXV0b0luZGV4PXRydWVdIE1vbmdvb3NlLXNwZWNpZmljIG9wdGlvbi4gU2V0IHRvIGZhbHNlIHRvIGRpc2FibGUgYXV0b21hdGljIGluZGV4IGNyZWF0aW9uIGZvciBhbGwgbW9kZWxzIGFzc29jaWF0ZWQgd2l0aCB0aGlzIGNvbm5lY3Rpb24uXG4gKiBAcGFyYW0ge0NsYXNzfSBbb3B0aW9ucy5wcm9taXNlTGlicmFyeV0gU2V0cyB0aGUgW3VuZGVybHlpbmcgZHJpdmVyJ3MgcHJvbWlzZSBsaWJyYXJ5XShodHRwczovL21vbmdvZGIuZ2l0aHViLmlvL25vZGUtbW9uZ29kYi1uYXRpdmUvNC45L2ludGVyZmFjZXMvTW9uZ29DbGllbnRPcHRpb25zLmh0bWwjcHJvbWlzZUxpYnJhcnkpLlxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnNvY2tldFRpbWVvdXRNUz0wXSBIb3cgbG9uZyB0aGUgTW9uZ29EQiBkcml2ZXIgd2lsbCB3YWl0IGJlZm9yZSBraWxsaW5nIGEgc29ja2V0IGR1ZSB0byBpbmFjdGl2aXR5IF9hZnRlciBpbml0aWFsIGNvbm5lY3Rpb25fLiBBIHNvY2tldCBtYXkgYmUgaW5hY3RpdmUgYmVjYXVzZSBvZiBlaXRoZXIgbm8gYWN0aXZpdHkgb3IgYSBsb25nLXJ1bm5pbmcgb3BlcmF0aW9uLiBgc29ja2V0VGltZW91dE1TYCBkZWZhdWx0cyB0byAwLCB3aGljaCBtZWFucyBOb2RlLmpzIHdpbGwgbm90IHRpbWUgb3V0IHRoZSBzb2NrZXQgZHVlIHRvIGluYWN0aXZpdHkuIFRoaXMgb3B0aW9uIGlzIHBhc3NlZCB0byBbTm9kZS5qcyBgc29ja2V0I3NldFRpbWVvdXQoKWAgZnVuY3Rpb25dKGh0dHBzOi8vbm9kZWpzLm9yZy9hcGkvbmV0Lmh0bWwjbmV0X3NvY2tldF9zZXR0aW1lb3V0X3RpbWVvdXRfY2FsbGJhY2spIGFmdGVyIHRoZSBNb25nb0RCIGRyaXZlciBzdWNjZXNzZnVsbHkgY29tcGxldGVzLlxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmZhbWlseT0wXSBQYXNzZWQgdHJhbnNwYXJlbnRseSB0byBbTm9kZS5qcycgYGRucy5sb29rdXAoKWBdKGh0dHBzOi8vbm9kZWpzLm9yZy9hcGkvZG5zLmh0bWwjZG5zX2Ruc19sb29rdXBfaG9zdG5hbWVfb3B0aW9uc19jYWxsYmFjaykgZnVuY3Rpb24uIE1heSBiZSBlaXRoZXIgYDBgLCBgNGAsIG9yIGA2YC4gYDRgIG1lYW5zIHVzZSBJUHY0IG9ubHksIGA2YCBtZWFucyB1c2UgSVB2NiBvbmx5LCBgMGAgbWVhbnMgdHJ5IGJvdGguXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmF1dG9DcmVhdGU9ZmFsc2VdIFNldCB0byBgdHJ1ZWAgdG8gbWFrZSBNb25nb29zZSBhdXRvbWF0aWNhbGx5IGNhbGwgYGNyZWF0ZUNvbGxlY3Rpb24oKWAgb24gZXZlcnkgbW9kZWwgY3JlYXRlZCBvbiB0aGlzIGNvbm5lY3Rpb24uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdXG4gKiBAc2VlIE1vbmdvb3NlI2NyZWF0ZUNvbm5lY3Rpb24gaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2FwaS9tb25nb29zZS5odG1sI01vbmdvb3NlLnByb3RvdHlwZS5jcmVhdGVDb25uZWN0aW9uKClcbiAqIEBhcGkgcHVibGljXG4gKiBAcmV0dXJuIHtQcm9taXNlfSByZXNvbHZlcyB0byBgdGhpc2AgaWYgY29ubmVjdGlvbiBzdWNjZWVkZWRcbiAqL1xuXG5Nb25nb29zZS5wcm90b3R5cGUuY29ubmVjdCA9IGFzeW5jIGZ1bmN0aW9uIGNvbm5lY3QodXJpLCBvcHRpb25zKSB7XG4gIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJyB8fCAoYXJndW1lbnRzLmxlbmd0aCA+PSAzICYmIHR5cGVvZiBhcmd1bWVudHNbMl0gPT09ICdmdW5jdGlvbicpKSB7XG4gICAgdGhyb3cgbmV3IE1vbmdvb3NlRXJyb3IoJ01vbmdvb3NlLnByb3RvdHlwZS5jb25uZWN0KCkgbm8gbG9uZ2VyIGFjY2VwdHMgYSBjYWxsYmFjaycpO1xuICB9XG5cbiAgY29uc3QgX21vbmdvb3NlID0gdGhpcyBpbnN0YW5jZW9mIE1vbmdvb3NlID8gdGhpcyA6IG1vbmdvb3NlO1xuICBjb25zdCBjb25uID0gX21vbmdvb3NlLmNvbm5lY3Rpb247XG5cbiAgcmV0dXJuIGNvbm4ub3BlblVyaSh1cmksIG9wdGlvbnMpLnRoZW4oKCkgPT4gX21vbmdvb3NlKTtcbn07XG5cbi8qKlxuICogUnVucyBgLmNsb3NlKClgIG9uIGFsbCBjb25uZWN0aW9ucyBpbiBwYXJhbGxlbC5cbiAqXG4gKiBAcmV0dXJuIHtQcm9taXNlfSByZXNvbHZlcyB3aGVuIGFsbCBjb25uZWN0aW9ucyBhcmUgY2xvc2VkLCBvciByZWplY3RzIHdpdGggdGhlIGZpcnN0IGVycm9yIHRoYXQgb2NjdXJyZWQuXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk1vbmdvb3NlLnByb3RvdHlwZS5kaXNjb25uZWN0ID0gYXN5bmMgZnVuY3Rpb24gZGlzY29ubmVjdCgpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPj0gMSAmJiB0eXBlb2YgYXJndW1lbnRzWzBdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IE1vbmdvb3NlRXJyb3IoJ01vbmdvb3NlLnByb3RvdHlwZS5kaXNjb25uZWN0KCkgbm8gbG9uZ2VyIGFjY2VwdHMgYSBjYWxsYmFjaycpO1xuICB9XG5cbiAgY29uc3QgX21vbmdvb3NlID0gdGhpcyBpbnN0YW5jZW9mIE1vbmdvb3NlID8gdGhpcyA6IG1vbmdvb3NlO1xuXG4gIGNvbnN0IHJlbWFpbmluZyA9IF9tb25nb29zZS5jb25uZWN0aW9ucy5sZW5ndGg7XG4gIGlmIChyZW1haW5pbmcgPD0gMCkge1xuICAgIHJldHVybjtcbiAgfVxuICBhd2FpdCBQcm9taXNlLmFsbChfbW9uZ29vc2UuY29ubmVjdGlvbnMubWFwKGNvbm4gPT4gY29ubi5jbG9zZSgpKSk7XG59O1xuXG4vKipcbiAqIF9SZXF1aXJlcyBNb25nb0RCID49IDMuNi4wLl8gU3RhcnRzIGEgW01vbmdvREIgc2Vzc2lvbl0oaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvcmVsZWFzZS1ub3Rlcy8zLjYvI2NsaWVudC1zZXNzaW9ucylcbiAqIGZvciBiZW5lZml0cyBsaWtlIGNhdXNhbCBjb25zaXN0ZW5jeSwgW3JldHJ5YWJsZSB3cml0ZXNdKGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvbWFudWFsL2NvcmUvcmV0cnlhYmxlLXdyaXRlcy8pLFxuICogYW5kIFt0cmFuc2FjdGlvbnNdKGh0dHBzOi8vdGhlY29kZWJhcmJhcmlhbi5jb20vYS1ub2RlLWpzLXBlcnNwZWN0aXZlLW9uLW1vbmdvZGItNC10cmFuc2FjdGlvbnMuaHRtbCkuXG4gKlxuICogQ2FsbGluZyBgbW9uZ29vc2Uuc3RhcnRTZXNzaW9uKClgIGlzIGVxdWl2YWxlbnQgdG8gY2FsbGluZyBgbW9uZ29vc2UuY29ubmVjdGlvbi5zdGFydFNlc3Npb24oKWAuXG4gKiBTZXNzaW9ucyBhcmUgc2NvcGVkIHRvIGEgY29ubmVjdGlvbiwgc28gY2FsbGluZyBgbW9uZ29vc2Uuc3RhcnRTZXNzaW9uKClgXG4gKiBzdGFydHMgYSBzZXNzaW9uIG9uIHRoZSBbZGVmYXVsdCBtb25nb29zZSBjb25uZWN0aW9uXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvYXBpL21vbmdvb3NlLmh0bWwjTW9uZ29vc2UucHJvdG90eXBlLmNvbm5lY3Rpb24pLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gc2VlIHRoZSBbbW9uZ29kYiBkcml2ZXIgb3B0aW9uc10oaHR0cHM6Ly9tb25nb2RiLmdpdGh1Yi5pby9ub2RlLW1vbmdvZGItbmF0aXZlLzQuOS9jbGFzc2VzL01vbmdvQ2xpZW50Lmh0bWwjc3RhcnRTZXNzaW9uKVxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5jYXVzYWxDb25zaXN0ZW5jeT10cnVlXSBzZXQgdG8gZmFsc2UgdG8gZGlzYWJsZSBjYXVzYWwgY29uc2lzdGVuY3lcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja11cbiAqIEByZXR1cm4ge1Byb21pc2U8Q2xpZW50U2Vzc2lvbj59IHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIE1vbmdvREIgZHJpdmVyIGBDbGllbnRTZXNzaW9uYFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Nb25nb29zZS5wcm90b3R5cGUuc3RhcnRTZXNzaW9uID0gZnVuY3Rpb24oKSB7XG4gIGNvbnN0IF9tb25nb29zZSA9IHRoaXMgaW5zdGFuY2VvZiBNb25nb29zZSA/IHRoaXMgOiBtb25nb29zZTtcblxuICByZXR1cm4gX21vbmdvb3NlLmNvbm5lY3Rpb24uc3RhcnRTZXNzaW9uLmFwcGx5KF9tb25nb29zZS5jb25uZWN0aW9uLCBhcmd1bWVudHMpO1xufTtcblxuLyoqXG4gKiBHZXR0ZXIvc2V0dGVyIGFyb3VuZCBmdW5jdGlvbiBmb3IgcGx1cmFsaXppbmcgY29sbGVjdGlvbiBuYW1lcy5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufG51bGx9IFtmbl0gb3ZlcndyaXRlcyB0aGUgZnVuY3Rpb24gdXNlZCB0byBwbHVyYWxpemUgY29sbGVjdGlvbiBuYW1lc1xuICogQHJldHVybiB7RnVuY3Rpb258bnVsbH0gdGhlIGN1cnJlbnQgZnVuY3Rpb24gdXNlZCB0byBwbHVyYWxpemUgY29sbGVjdGlvbiBuYW1lcywgZGVmYXVsdHMgdG8gdGhlIGxlZ2FjeSBmdW5jdGlvbiBmcm9tIGBtb25nb29zZS1sZWdhY3ktcGx1cmFsaXplYC5cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuTW9uZ29vc2UucHJvdG90eXBlLnBsdXJhbGl6ZSA9IGZ1bmN0aW9uKGZuKSB7XG4gIGNvbnN0IF9tb25nb29zZSA9IHRoaXMgaW5zdGFuY2VvZiBNb25nb29zZSA/IHRoaXMgOiBtb25nb29zZTtcblxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDApIHtcbiAgICBfbW9uZ29vc2UuX3BsdXJhbGl6ZSA9IGZuO1xuICB9XG4gIHJldHVybiBfbW9uZ29vc2UuX3BsdXJhbGl6ZTtcbn07XG5cbi8qKlxuICogRGVmaW5lcyBhIG1vZGVsIG9yIHJldHJpZXZlcyBpdC5cbiAqXG4gKiBNb2RlbHMgZGVmaW5lZCBvbiB0aGUgYG1vbmdvb3NlYCBpbnN0YW5jZSBhcmUgYXZhaWxhYmxlIHRvIGFsbCBjb25uZWN0aW9uXG4gKiBjcmVhdGVkIGJ5IHRoZSBzYW1lIGBtb25nb29zZWAgaW5zdGFuY2UuXG4gKlxuICogSWYgeW91IGNhbGwgYG1vbmdvb3NlLm1vZGVsKClgIHdpdGggdHdpY2UgdGhlIHNhbWUgbmFtZSBidXQgYSBkaWZmZXJlbnQgc2NoZW1hLFxuICogeW91IHdpbGwgZ2V0IGFuIGBPdmVyd3JpdGVNb2RlbEVycm9yYC4gSWYgeW91IGNhbGwgYG1vbmdvb3NlLm1vZGVsKClgIHdpdGhcbiAqIHRoZSBzYW1lIG5hbWUgYW5kIHNhbWUgc2NoZW1hLCB5b3UnbGwgZ2V0IHRoZSBzYW1lIHNjaGVtYSBiYWNrLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgY29uc3QgbW9uZ29vc2UgPSByZXF1aXJlKCdtb25nb29zZScpO1xuICpcbiAqICAgICAvLyBkZWZpbmUgYW4gQWN0b3IgbW9kZWwgd2l0aCB0aGlzIG1vbmdvb3NlIGluc3RhbmNlXG4gKiAgICAgY29uc3Qgc2NoZW1hID0gbmV3IFNjaGVtYSh7IG5hbWU6IFN0cmluZyB9KTtcbiAqICAgICBtb25nb29zZS5tb2RlbCgnQWN0b3InLCBzY2hlbWEpO1xuICpcbiAqICAgICAvLyBjcmVhdGUgYSBuZXcgY29ubmVjdGlvblxuICogICAgIGNvbnN0IGNvbm4gPSBtb25nb29zZS5jcmVhdGVDb25uZWN0aW9uKC4uKTtcbiAqXG4gKiAgICAgLy8gY3JlYXRlIEFjdG9yIG1vZGVsXG4gKiAgICAgY29uc3QgQWN0b3IgPSBjb25uLm1vZGVsKCdBY3RvcicsIHNjaGVtYSk7XG4gKiAgICAgY29ubi5tb2RlbCgnQWN0b3InKSA9PT0gQWN0b3I7IC8vIHRydWVcbiAqICAgICBjb25uLm1vZGVsKCdBY3RvcicsIHNjaGVtYSkgPT09IEFjdG9yOyAvLyB0cnVlLCBzYW1lIHNjaGVtYVxuICogICAgIGNvbm4ubW9kZWwoJ0FjdG9yJywgc2NoZW1hLCAnYWN0b3JzJykgPT09IEFjdG9yOyAvLyB0cnVlLCBzYW1lIHNjaGVtYSBhbmQgY29sbGVjdGlvbiBuYW1lXG4gKlxuICogICAgIC8vIFRoaXMgdGhyb3dzIGFuIGBPdmVyd3JpdGVNb2RlbEVycm9yYCBiZWNhdXNlIHRoZSBzY2hlbWEgaXMgZGlmZmVyZW50LlxuICogICAgIGNvbm4ubW9kZWwoJ0FjdG9yJywgbmV3IFNjaGVtYSh7IG5hbWU6IFN0cmluZyB9KSk7XG4gKlxuICogX1doZW4gbm8gYGNvbGxlY3Rpb25gIGFyZ3VtZW50IGlzIHBhc3NlZCwgTW9uZ29vc2UgdXNlcyB0aGUgbW9kZWwgbmFtZS4gSWYgeW91IGRvbid0IGxpa2UgdGhpcyBiZWhhdmlvciwgZWl0aGVyIHBhc3MgYSBjb2xsZWN0aW9uIG5hbWUsIHVzZSBgbW9uZ29vc2UucGx1cmFsaXplKClgLCBvciBzZXQgeW91ciBzY2hlbWFzIGNvbGxlY3Rpb24gbmFtZSBvcHRpb24uX1xuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgY29uc3Qgc2NoZW1hID0gbmV3IFNjaGVtYSh7IG5hbWU6IFN0cmluZyB9LCB7IGNvbGxlY3Rpb246ICdhY3RvcicgfSk7XG4gKlxuICogICAgIC8vIG9yXG4gKlxuICogICAgIHNjaGVtYS5zZXQoJ2NvbGxlY3Rpb24nLCAnYWN0b3InKTtcbiAqXG4gKiAgICAgLy8gb3JcbiAqXG4gKiAgICAgY29uc3QgY29sbGVjdGlvbk5hbWUgPSAnYWN0b3InXG4gKiAgICAgY29uc3QgTSA9IG1vbmdvb3NlLm1vZGVsKCdBY3RvcicsIHNjaGVtYSwgY29sbGVjdGlvbk5hbWUpXG4gKlxuICogQHBhcmFtIHtTdHJpbmd8RnVuY3Rpb259IG5hbWUgbW9kZWwgbmFtZSBvciBjbGFzcyBleHRlbmRpbmcgTW9kZWxcbiAqIEBwYXJhbSB7U2NoZW1hfSBbc2NoZW1hXSB0aGUgc2NoZW1hIHRvIHVzZS5cbiAqIEBwYXJhbSB7U3RyaW5nfSBbY29sbGVjdGlvbl0gbmFtZSAob3B0aW9uYWwsIGluZmVycmVkIGZyb20gbW9kZWwgbmFtZSlcbiAqIEByZXR1cm4ge01vZGVsfSBUaGUgbW9kZWwgYXNzb2NpYXRlZCB3aXRoIGBuYW1lYC4gTW9uZ29vc2Ugd2lsbCBjcmVhdGUgdGhlIG1vZGVsIGlmIGl0IGRvZXNuJ3QgYWxyZWFkeSBleGlzdC5cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuTW9uZ29vc2UucHJvdG90eXBlLm1vZGVsID0gZnVuY3Rpb24obmFtZSwgc2NoZW1hLCBjb2xsZWN0aW9uLCBvcHRpb25zKSB7XG4gIGNvbnN0IF9tb25nb29zZSA9IHRoaXMgaW5zdGFuY2VvZiBNb25nb29zZSA/IHRoaXMgOiBtb25nb29zZTtcblxuICBpZiAodHlwZW9mIHNjaGVtYSA9PT0gJ3N0cmluZycpIHtcbiAgICBjb2xsZWN0aW9uID0gc2NoZW1hO1xuICAgIHNjaGVtYSA9IGZhbHNlO1xuICB9XG5cbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICBjb25zdCBtb2RlbCA9IF9tb25nb29zZS5tb2RlbHNbbmFtZV07XG4gICAgaWYgKCFtb2RlbCkge1xuICAgICAgdGhyb3cgbmV3IE1vbmdvb3NlRXJyb3IuTWlzc2luZ1NjaGVtYUVycm9yKG5hbWUpO1xuICAgIH1cbiAgICByZXR1cm4gbW9kZWw7XG4gIH1cblxuICBpZiAodXRpbHMuaXNPYmplY3Qoc2NoZW1hKSAmJiAhKHNjaGVtYSBpbnN0YW5jZW9mIFNjaGVtYSkpIHtcbiAgICBzY2hlbWEgPSBuZXcgU2NoZW1hKHNjaGVtYSk7XG4gIH1cbiAgaWYgKHNjaGVtYSAmJiAhKHNjaGVtYSBpbnN0YW5jZW9mIFNjaGVtYSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSAybmQgcGFyYW1ldGVyIHRvIGBtb25nb29zZS5tb2RlbCgpYCBzaG91bGQgYmUgYSAnICtcbiAgICAgICdzY2hlbWEgb3IgYSBQT0pPJyk7XG4gIH1cblxuICAvLyBoYW5kbGUgaW50ZXJuYWwgb3B0aW9ucyBmcm9tIGNvbm5lY3Rpb24ubW9kZWwoKVxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICBjb25zdCBvcmlnaW5hbFNjaGVtYSA9IHNjaGVtYTtcbiAgaWYgKHNjaGVtYSkge1xuICAgIGlmIChfbW9uZ29vc2UuZ2V0KCdjbG9uZVNjaGVtYXMnKSkge1xuICAgICAgc2NoZW1hID0gc2NoZW1hLmNsb25lKCk7XG4gICAgfVxuICAgIF9tb25nb29zZS5fYXBwbHlQbHVnaW5zKHNjaGVtYSk7XG4gIH1cblxuICAvLyBjb25uZWN0aW9uLm1vZGVsKCkgbWF5IGJlIHBhc3NpbmcgYSBkaWZmZXJlbnQgc2NoZW1hIGZvclxuICAvLyBhbiBleGlzdGluZyBtb2RlbCBuYW1lLiBpbiB0aGlzIGNhc2UgZG9uJ3QgcmVhZCBmcm9tIGNhY2hlLlxuICBjb25zdCBvdmVyd3JpdGVNb2RlbHMgPSBfbW9uZ29vc2Uub3B0aW9ucy5oYXNPd25Qcm9wZXJ0eSgnb3ZlcndyaXRlTW9kZWxzJykgP1xuICAgIF9tb25nb29zZS5vcHRpb25zLm92ZXJ3cml0ZU1vZGVscyA6XG4gICAgb3B0aW9ucy5vdmVyd3JpdGVNb2RlbHM7XG4gIGlmIChfbW9uZ29vc2UubW9kZWxzLmhhc093blByb3BlcnR5KG5hbWUpICYmIG9wdGlvbnMuY2FjaGUgIT09IGZhbHNlICYmIG92ZXJ3cml0ZU1vZGVscyAhPT0gdHJ1ZSkge1xuICAgIGlmIChvcmlnaW5hbFNjaGVtYSAmJlxuICAgICAgICBvcmlnaW5hbFNjaGVtYS5pbnN0YW5jZU9mU2NoZW1hICYmXG4gICAgICAgIG9yaWdpbmFsU2NoZW1hICE9PSBfbW9uZ29vc2UubW9kZWxzW25hbWVdLnNjaGVtYSkge1xuICAgICAgdGhyb3cgbmV3IF9tb25nb29zZS5FcnJvci5PdmVyd3JpdGVNb2RlbEVycm9yKG5hbWUpO1xuICAgIH1cbiAgICBpZiAoY29sbGVjdGlvbiAmJiBjb2xsZWN0aW9uICE9PSBfbW9uZ29vc2UubW9kZWxzW25hbWVdLmNvbGxlY3Rpb24ubmFtZSkge1xuICAgICAgLy8gc3ViY2xhc3MgY3VycmVudCBtb2RlbCB3aXRoIGFsdGVybmF0ZSBjb2xsZWN0aW9uXG4gICAgICBjb25zdCBtb2RlbCA9IF9tb25nb29zZS5tb2RlbHNbbmFtZV07XG4gICAgICBzY2hlbWEgPSBtb2RlbC5wcm90b3R5cGUuc2NoZW1hO1xuICAgICAgY29uc3Qgc3ViID0gbW9kZWwuX19zdWJjbGFzcyhfbW9uZ29vc2UuY29ubmVjdGlvbiwgc2NoZW1hLCBjb2xsZWN0aW9uKTtcbiAgICAgIC8vIGRvIG5vdCBjYWNoZSB0aGUgc3ViIG1vZGVsXG4gICAgICByZXR1cm4gc3ViO1xuICAgIH1cbiAgICByZXR1cm4gX21vbmdvb3NlLm1vZGVsc1tuYW1lXTtcbiAgfVxuICBpZiAoc2NoZW1hID09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgX21vbmdvb3NlLkVycm9yLk1pc3NpbmdTY2hlbWFFcnJvcihuYW1lKTtcbiAgfVxuXG4gIGNvbnN0IG1vZGVsID0gX21vbmdvb3NlLl9tb2RlbChuYW1lLCBzY2hlbWEsIGNvbGxlY3Rpb24sIG9wdGlvbnMpO1xuICBfbW9uZ29vc2UuY29ubmVjdGlvbi5tb2RlbHNbbmFtZV0gPSBtb2RlbDtcbiAgX21vbmdvb3NlLm1vZGVsc1tuYW1lXSA9IG1vZGVsO1xuXG4gIHJldHVybiBtb2RlbDtcbn07XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxuTW9uZ29vc2UucHJvdG90eXBlLl9tb2RlbCA9IGZ1bmN0aW9uKG5hbWUsIHNjaGVtYSwgY29sbGVjdGlvbiwgb3B0aW9ucykge1xuICBjb25zdCBfbW9uZ29vc2UgPSB0aGlzIGluc3RhbmNlb2YgTW9uZ29vc2UgPyB0aGlzIDogbW9uZ29vc2U7XG5cbiAgbGV0IG1vZGVsO1xuICBpZiAodHlwZW9mIG5hbWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICBtb2RlbCA9IG5hbWU7XG4gICAgbmFtZSA9IG1vZGVsLm5hbWU7XG4gICAgaWYgKCEobW9kZWwucHJvdG90eXBlIGluc3RhbmNlb2YgTW9kZWwpKSB7XG4gICAgICB0aHJvdyBuZXcgX21vbmdvb3NlLkVycm9yKCdUaGUgcHJvdmlkZWQgY2xhc3MgJyArIG5hbWUgKyAnIG11c3QgZXh0ZW5kIE1vZGVsJyk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHNjaGVtYSkge1xuICAgIGlmIChfbW9uZ29vc2UuZ2V0KCdjbG9uZVNjaGVtYXMnKSkge1xuICAgICAgc2NoZW1hID0gc2NoZW1hLmNsb25lKCk7XG4gICAgfVxuICAgIF9tb25nb29zZS5fYXBwbHlQbHVnaW5zKHNjaGVtYSk7XG4gIH1cblxuICAvLyBBcHBseSByZWxldmFudCBcImdsb2JhbFwiIG9wdGlvbnMgdG8gdGhlIHNjaGVtYVxuICBpZiAoc2NoZW1hID09IG51bGwgfHwgISgncGx1cmFsaXphdGlvbicgaW4gc2NoZW1hLm9wdGlvbnMpKSB7XG4gICAgc2NoZW1hLm9wdGlvbnMucGx1cmFsaXphdGlvbiA9IF9tb25nb29zZS5vcHRpb25zLnBsdXJhbGl6YXRpb247XG4gIH1cblxuICBpZiAoIWNvbGxlY3Rpb24pIHtcbiAgICBjb2xsZWN0aW9uID0gc2NoZW1hLmdldCgnY29sbGVjdGlvbicpIHx8XG4gICAgICB1dGlscy50b0NvbGxlY3Rpb25OYW1lKG5hbWUsIF9tb25nb29zZS5wbHVyYWxpemUoKSk7XG4gIH1cblxuICBjb25zdCBjb25uZWN0aW9uID0gb3B0aW9ucy5jb25uZWN0aW9uIHx8IF9tb25nb29zZS5jb25uZWN0aW9uO1xuICBtb2RlbCA9IF9tb25nb29zZS5Nb2RlbC5jb21waWxlKG1vZGVsIHx8IG5hbWUsIHNjaGVtYSwgY29sbGVjdGlvbiwgY29ubmVjdGlvbiwgX21vbmdvb3NlKTtcbiAgLy8gRXJyb3JzIGhhbmRsZWQgaW50ZXJuYWxseSwgc28gc2FmZSB0byBpZ25vcmUgZXJyb3JcbiAgbW9kZWwuaW5pdCgpLmNhdGNoKGZ1bmN0aW9uICRtb2RlbEluaXROb29wKCkge30pO1xuXG4gIGNvbm5lY3Rpb24uZW1pdCgnbW9kZWwnLCBtb2RlbCk7XG5cbiAgaWYgKHNjaGVtYS5fYXBwbHlEaXNjcmltaW5hdG9ycyAhPSBudWxsKSB7XG4gICAgZm9yIChjb25zdCBkaXNjIG9mIHNjaGVtYS5fYXBwbHlEaXNjcmltaW5hdG9ycy5rZXlzKCkpIHtcbiAgICAgIG1vZGVsLmRpc2NyaW1pbmF0b3IoZGlzYywgc2NoZW1hLl9hcHBseURpc2NyaW1pbmF0b3JzLmdldChkaXNjKSk7XG4gICAgfVxuICB9XG5cbiAgYXBwbHlFbWJlZGRlZERpc2NyaW1pbmF0b3JzKHNjaGVtYSk7XG5cbiAgcmV0dXJuIG1vZGVsO1xufTtcblxuLyoqXG4gKiBSZW1vdmVzIHRoZSBtb2RlbCBuYW1lZCBgbmFtZWAgZnJvbSB0aGUgZGVmYXVsdCBjb25uZWN0aW9uLCBpZiBpdCBleGlzdHMuXG4gKiBZb3UgY2FuIHVzZSB0aGlzIGZ1bmN0aW9uIHRvIGNsZWFuIHVwIGFueSBtb2RlbHMgeW91IGNyZWF0ZWQgaW4geW91ciB0ZXN0cyB0b1xuICogcHJldmVudCBPdmVyd3JpdGVNb2RlbEVycm9ycy5cbiAqXG4gKiBFcXVpdmFsZW50IHRvIGBtb25nb29zZS5jb25uZWN0aW9uLmRlbGV0ZU1vZGVsKG5hbWUpYC5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIG1vbmdvb3NlLm1vZGVsKCdVc2VyJywgbmV3IFNjaGVtYSh7IG5hbWU6IFN0cmluZyB9KSk7XG4gKiAgICAgY29uc29sZS5sb2cobW9uZ29vc2UubW9kZWwoJ1VzZXInKSk7IC8vIE1vZGVsIG9iamVjdFxuICogICAgIG1vbmdvb3NlLmRlbGV0ZU1vZGVsKCdVc2VyJyk7XG4gKiAgICAgY29uc29sZS5sb2cobW9uZ29vc2UubW9kZWwoJ1VzZXInKSk7IC8vIHVuZGVmaW5lZFxuICpcbiAqICAgICAvLyBVc3VhbGx5IHVzZWZ1bCBpbiBhIE1vY2hhIGBhZnRlckVhY2goKWAgaG9va1xuICogICAgIGFmdGVyRWFjaChmdW5jdGlvbigpIHtcbiAqICAgICAgIG1vbmdvb3NlLmRlbGV0ZU1vZGVsKC8uKy8pOyAvLyBEZWxldGUgZXZlcnkgbW9kZWxcbiAqICAgICB9KTtcbiAqXG4gKiBAYXBpIHB1YmxpY1xuICogQHBhcmFtIHtTdHJpbmd8UmVnRXhwfSBuYW1lIGlmIHN0cmluZywgdGhlIG5hbWUgb2YgdGhlIG1vZGVsIHRvIHJlbW92ZS4gSWYgcmVnZXhwLCByZW1vdmVzIGFsbCBtb2RlbHMgd2hvc2UgbmFtZSBtYXRjaGVzIHRoZSByZWdleHAuXG4gKiBAcmV0dXJuIHtNb25nb29zZX0gdGhpc1xuICovXG5cbk1vbmdvb3NlLnByb3RvdHlwZS5kZWxldGVNb2RlbCA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgY29uc3QgX21vbmdvb3NlID0gdGhpcyBpbnN0YW5jZW9mIE1vbmdvb3NlID8gdGhpcyA6IG1vbmdvb3NlO1xuXG4gIF9tb25nb29zZS5jb25uZWN0aW9uLmRlbGV0ZU1vZGVsKG5hbWUpO1xuICBkZWxldGUgX21vbmdvb3NlLm1vZGVsc1tuYW1lXTtcbiAgcmV0dXJuIF9tb25nb29zZTtcbn07XG5cbi8qKlxuICogUmV0dXJucyBhbiBhcnJheSBvZiBtb2RlbCBuYW1lcyBjcmVhdGVkIG9uIHRoaXMgaW5zdGFuY2Ugb2YgTW9uZ29vc2UuXG4gKlxuICogIyMjIyBOb3RlOlxuICpcbiAqIF9Eb2VzIG5vdCBpbmNsdWRlIG5hbWVzIG9mIG1vZGVscyBjcmVhdGVkIHVzaW5nIGBjb25uZWN0aW9uLm1vZGVsKClgLl9cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICogQHJldHVybiB7QXJyYXl9XG4gKi9cblxuTW9uZ29vc2UucHJvdG90eXBlLm1vZGVsTmFtZXMgPSBmdW5jdGlvbigpIHtcbiAgY29uc3QgX21vbmdvb3NlID0gdGhpcyBpbnN0YW5jZW9mIE1vbmdvb3NlID8gdGhpcyA6IG1vbmdvb3NlO1xuXG4gIGNvbnN0IG5hbWVzID0gT2JqZWN0LmtleXMoX21vbmdvb3NlLm1vZGVscyk7XG4gIHJldHVybiBuYW1lcztcbn07XG5cbi8qKlxuICogQXBwbGllcyBnbG9iYWwgcGx1Z2lucyB0byBgc2NoZW1hYC5cbiAqXG4gKiBAcGFyYW0ge1NjaGVtYX0gc2NoZW1hXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Nb25nb29zZS5wcm90b3R5cGUuX2FwcGx5UGx1Z2lucyA9IGZ1bmN0aW9uKHNjaGVtYSwgb3B0aW9ucykge1xuICBjb25zdCBfbW9uZ29vc2UgPSB0aGlzIGluc3RhbmNlb2YgTW9uZ29vc2UgPyB0aGlzIDogbW9uZ29vc2U7XG5cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIG9wdGlvbnMuYXBwbHlQbHVnaW5zVG9EaXNjcmltaW5hdG9ycyA9IF9tb25nb29zZS5vcHRpb25zICYmIF9tb25nb29zZS5vcHRpb25zLmFwcGx5UGx1Z2luc1RvRGlzY3JpbWluYXRvcnMgfHwgZmFsc2U7XG4gIG9wdGlvbnMuYXBwbHlQbHVnaW5zVG9DaGlsZFNjaGVtYXMgPSB0eXBlb2YgKF9tb25nb29zZS5vcHRpb25zICYmIF9tb25nb29zZS5vcHRpb25zLmFwcGx5UGx1Z2luc1RvQ2hpbGRTY2hlbWFzKSA9PT0gJ2Jvb2xlYW4nID9cbiAgICBfbW9uZ29vc2Uub3B0aW9ucy5hcHBseVBsdWdpbnNUb0NoaWxkU2NoZW1hcyA6XG4gICAgdHJ1ZTtcbiAgYXBwbHlQbHVnaW5zKHNjaGVtYSwgX21vbmdvb3NlLnBsdWdpbnMsIG9wdGlvbnMsICckZ2xvYmFsUGx1Z2luc0FwcGxpZWQnKTtcbn07XG5cbi8qKlxuICogRGVjbGFyZXMgYSBnbG9iYWwgcGx1Z2luIGV4ZWN1dGVkIG9uIGFsbCBTY2hlbWFzLlxuICpcbiAqIEVxdWl2YWxlbnQgdG8gY2FsbGluZyBgLnBsdWdpbihmbilgIG9uIGVhY2ggU2NoZW1hIHlvdSBjcmVhdGUuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gcGx1Z2luIGNhbGxiYWNrXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdHNdIG9wdGlvbmFsIG9wdGlvbnNcbiAqIEByZXR1cm4ge01vbmdvb3NlfSB0aGlzXG4gKiBAc2VlIHBsdWdpbnMgaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL3BsdWdpbnMuaHRtbFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Nb25nb29zZS5wcm90b3R5cGUucGx1Z2luID0gZnVuY3Rpb24oZm4sIG9wdHMpIHtcbiAgY29uc3QgX21vbmdvb3NlID0gdGhpcyBpbnN0YW5jZW9mIE1vbmdvb3NlID8gdGhpcyA6IG1vbmdvb3NlO1xuXG4gIF9tb25nb29zZS5wbHVnaW5zLnB1c2goW2ZuLCBvcHRzXSk7XG4gIHJldHVybiBfbW9uZ29vc2U7XG59O1xuXG4vKipcbiAqIFRoZSBNb25nb29zZSBtb2R1bGUncyBkZWZhdWx0IGNvbm5lY3Rpb24uIEVxdWl2YWxlbnQgdG8gYG1vbmdvb3NlLmNvbm5lY3Rpb25zWzBdYCwgc2VlIFtgY29ubmVjdGlvbnNgXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvYXBpL21vbmdvb3NlLmh0bWwjTW9uZ29vc2UucHJvdG90eXBlLmNvbm5lY3Rpb25zKS5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IG1vbmdvb3NlID0gcmVxdWlyZSgnbW9uZ29vc2UnKTtcbiAqICAgICBtb25nb29zZS5jb25uZWN0KC4uLik7XG4gKiAgICAgbW9uZ29vc2UuY29ubmVjdGlvbi5vbignZXJyb3InLCBjYik7XG4gKlxuICogVGhpcyBpcyB0aGUgY29ubmVjdGlvbiB1c2VkIGJ5IGRlZmF1bHQgZm9yIGV2ZXJ5IG1vZGVsIGNyZWF0ZWQgdXNpbmcgW21vbmdvb3NlLm1vZGVsXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvYXBpL21vbmdvb3NlLmh0bWwjTW9uZ29vc2UucHJvdG90eXBlLm1vZGVsKCkpLlxuICpcbiAqIFRvIGNyZWF0ZSBhIG5ldyBjb25uZWN0aW9uLCB1c2UgW2BjcmVhdGVDb25uZWN0aW9uKClgXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvYXBpL21vbmdvb3NlLmh0bWwjTW9uZ29vc2UucHJvdG90eXBlLmNyZWF0ZUNvbm5lY3Rpb24oKSkuXG4gKlxuICogQG1lbWJlck9mIE1vbmdvb3NlXG4gKiBAaW5zdGFuY2VcbiAqIEBwcm9wZXJ0eSB7Q29ubmVjdGlvbn0gY29ubmVjdGlvblxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Nb25nb29zZS5wcm90b3R5cGUuX19kZWZpbmVHZXR0ZXJfXygnY29ubmVjdGlvbicsIGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5jb25uZWN0aW9uc1swXTtcbn0pO1xuXG5Nb25nb29zZS5wcm90b3R5cGUuX19kZWZpbmVTZXR0ZXJfXygnY29ubmVjdGlvbicsIGZ1bmN0aW9uKHYpIHtcbiAgaWYgKHYgaW5zdGFuY2VvZiB0aGlzLl9fZHJpdmVyLkNvbm5lY3Rpb24pIHtcbiAgICB0aGlzLmNvbm5lY3Rpb25zWzBdID0gdjtcbiAgICB0aGlzLm1vZGVscyA9IHYubW9kZWxzO1xuICB9XG59KTtcblxuLyoqXG4gKiBBbiBhcnJheSBjb250YWluaW5nIGFsbCBbY29ubmVjdGlvbnNdKGNvbm5lY3Rpb24uaHRtbCkgYXNzb2NpYXRlZCB3aXRoIHRoaXNcbiAqIE1vbmdvb3NlIGluc3RhbmNlLiBCeSBkZWZhdWx0LCB0aGVyZSBpcyAxIGNvbm5lY3Rpb24uIENhbGxpbmdcbiAqIFtgY3JlYXRlQ29ubmVjdGlvbigpYF0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2FwaS9tb25nb29zZS5odG1sI01vbmdvb3NlLnByb3RvdHlwZS5jcmVhdGVDb25uZWN0aW9uKCkpIGFkZHMgYSBjb25uZWN0aW9uXG4gKiB0byB0aGlzIGFycmF5LlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgY29uc3QgbW9uZ29vc2UgPSByZXF1aXJlKCdtb25nb29zZScpO1xuICogICAgIG1vbmdvb3NlLmNvbm5lY3Rpb25zLmxlbmd0aDsgLy8gMSwganVzdCB0aGUgZGVmYXVsdCBjb25uZWN0aW9uXG4gKiAgICAgbW9uZ29vc2UuY29ubmVjdGlvbnNbMF0gPT09IG1vbmdvb3NlLmNvbm5lY3Rpb247IC8vIHRydWVcbiAqXG4gKiAgICAgbW9uZ29vc2UuY3JlYXRlQ29ubmVjdGlvbignbW9uZ29kYjovLzEyNy4wLjAuMToyNzAxNy90ZXN0Jyk7XG4gKiAgICAgbW9uZ29vc2UuY29ubmVjdGlvbnMubGVuZ3RoOyAvLyAyXG4gKlxuICogQG1lbWJlck9mIE1vbmdvb3NlXG4gKiBAaW5zdGFuY2VcbiAqIEBwcm9wZXJ0eSB7QXJyYXl9IGNvbm5lY3Rpb25zXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk1vbmdvb3NlLnByb3RvdHlwZS5jb25uZWN0aW9ucztcblxuLyoqXG4gKiBBbiBpbnRlZ2VyIGNvbnRhaW5pbmcgdGhlIHZhbHVlIG9mIHRoZSBuZXh0IGNvbm5lY3Rpb24gaWQuIENhbGxpbmdcbiAqIFtgY3JlYXRlQ29ubmVjdGlvbigpYF0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2FwaS9tb25nb29zZS5odG1sI01vbmdvb3NlLnByb3RvdHlwZS5jcmVhdGVDb25uZWN0aW9uKCkpIGluY3JlbWVudHNcbiAqIHRoaXMgdmFsdWUuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBjb25zdCBtb25nb29zZSA9IHJlcXVpcmUoJ21vbmdvb3NlJyk7XG4gKiAgICAgbW9uZ29vc2UuY3JlYXRlQ29ubmVjdGlvbigpOyAvLyBpZCBgMGAsIGBuZXh0Q29ubmVjdGlvbklkYCBiZWNvbWVzIGAxYFxuICogICAgIG1vbmdvb3NlLmNyZWF0ZUNvbm5lY3Rpb24oKTsgLy8gaWQgYDFgLCBgbmV4dENvbm5lY3Rpb25JZGAgYmVjb21lcyBgMmBcbiAqICAgICBtb25nb29zZS5jb25uZWN0aW9uc1swXS5kZXN0cm95KCkgLy8gUmVtb3ZlcyBjb25uZWN0aW9uIHdpdGggaWQgYDBgXG4gKiAgICAgbW9uZ29vc2UuY3JlYXRlQ29ubmVjdGlvbigpOyAvLyBpZCBgMmAsIGBuZXh0Q29ubmVjdGlvbklkYCBiZWNvbWVzIGAzYFxuICpcbiAqIEBtZW1iZXJPZiBNb25nb29zZVxuICogQGluc3RhbmNlXG4gKiBAcHJvcGVydHkge051bWJlcn0gbmV4dENvbm5lY3Rpb25JZFxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuTW9uZ29vc2UucHJvdG90eXBlLm5leHRDb25uZWN0aW9uSWQ7XG5cbi8qKlxuICogVGhlIE1vbmdvb3NlIEFnZ3JlZ2F0ZSBjb25zdHJ1Y3RvclxuICpcbiAqIEBtZXRob2QgQWdncmVnYXRlXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk1vbmdvb3NlLnByb3RvdHlwZS5BZ2dyZWdhdGUgPSBBZ2dyZWdhdGU7XG5cbi8qKlxuICogVGhlIE1vbmdvb3NlIENvbGxlY3Rpb24gY29uc3RydWN0b3JcbiAqXG4gKiBAbWVtYmVyT2YgTW9uZ29vc2VcbiAqIEBpbnN0YW5jZVxuICogQG1ldGhvZCBDb2xsZWN0aW9uXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShNb25nb29zZS5wcm90b3R5cGUsICdDb2xsZWN0aW9uJywge1xuICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl9fZHJpdmVyLkNvbGxlY3Rpb247XG4gIH0sXG4gIHNldDogZnVuY3Rpb24oQ29sbGVjdGlvbikge1xuICAgIHRoaXMuX19kcml2ZXIuQ29sbGVjdGlvbiA9IENvbGxlY3Rpb247XG4gIH1cbn0pO1xuXG4vKipcbiAqIFRoZSBNb25nb29zZSBbQ29ubmVjdGlvbl0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2FwaS9jb25uZWN0aW9uLmh0bWwjQ29ubmVjdGlvbigpKSBjb25zdHJ1Y3RvclxuICpcbiAqIEBtZW1iZXJPZiBNb25nb29zZVxuICogQGluc3RhbmNlXG4gKiBAbWV0aG9kIENvbm5lY3Rpb25cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KE1vbmdvb3NlLnByb3RvdHlwZSwgJ0Nvbm5lY3Rpb24nLCB7XG4gIGdldDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX19kcml2ZXIuQ29ubmVjdGlvbjtcbiAgfSxcbiAgc2V0OiBmdW5jdGlvbihDb25uZWN0aW9uKSB7XG4gICAgaWYgKENvbm5lY3Rpb24gPT09IHRoaXMuX19kcml2ZXIuQ29ubmVjdGlvbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuX19kcml2ZXIuQ29ubmVjdGlvbiA9IENvbm5lY3Rpb247XG4gIH1cbn0pO1xuXG4vKipcbiAqIFRoZSBNb25nb29zZSB2ZXJzaW9uXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBjb25zb2xlLmxvZyhtb25nb29zZS52ZXJzaW9uKTsgLy8gJzUueC54J1xuICpcbiAqIEBwcm9wZXJ0eSB2ZXJzaW9uXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk1vbmdvb3NlLnByb3RvdHlwZS52ZXJzaW9uID0gcGtnLnZlcnNpb247XG5cbi8qKlxuICogVGhlIE1vbmdvb3NlIGNvbnN0cnVjdG9yXG4gKlxuICogVGhlIGV4cG9ydHMgb2YgdGhlIG1vbmdvb3NlIG1vZHVsZSBpcyBhbiBpbnN0YW5jZSBvZiB0aGlzIGNsYXNzLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgY29uc3QgbW9uZ29vc2UgPSByZXF1aXJlKCdtb25nb29zZScpO1xuICogICAgIGNvbnN0IG1vbmdvb3NlMiA9IG5ldyBtb25nb29zZS5Nb25nb29zZSgpO1xuICpcbiAqIEBtZXRob2QgTW9uZ29vc2VcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuTW9uZ29vc2UucHJvdG90eXBlLk1vbmdvb3NlID0gTW9uZ29vc2U7XG5cbi8qKlxuICogVGhlIE1vbmdvb3NlIFtTY2hlbWFdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvc2NoZW1hLmh0bWwjU2NoZW1hKCkpIGNvbnN0cnVjdG9yXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBjb25zdCBtb25nb29zZSA9IHJlcXVpcmUoJ21vbmdvb3NlJyk7XG4gKiAgICAgY29uc3QgU2NoZW1hID0gbW9uZ29vc2UuU2NoZW1hO1xuICogICAgIGNvbnN0IENhdFNjaGVtYSA9IG5ldyBTY2hlbWEoLi4pO1xuICpcbiAqIEBtZXRob2QgU2NoZW1hXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk1vbmdvb3NlLnByb3RvdHlwZS5TY2hlbWEgPSBTY2hlbWE7XG5cbi8qKlxuICogVGhlIE1vbmdvb3NlIFtTY2hlbWFUeXBlXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvYXBpL3NjaGVtYXR5cGUuaHRtbCNTY2hlbWFUeXBlKCkpIGNvbnN0cnVjdG9yXG4gKlxuICogQG1ldGhvZCBTY2hlbWFUeXBlXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk1vbmdvb3NlLnByb3RvdHlwZS5TY2hlbWFUeXBlID0gU2NoZW1hVHlwZTtcblxuLyoqXG4gKiBUaGUgdmFyaW91cyBNb25nb29zZSBTY2hlbWFUeXBlcy5cbiAqXG4gKiAjIyMjIE5vdGU6XG4gKlxuICogX0FsaWFzIG9mIG1vbmdvb3NlLlNjaGVtYS5UeXBlcyBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkuX1xuICpcbiAqIEBwcm9wZXJ0eSBTY2hlbWFUeXBlc1xuICogQHNlZSBTY2hlbWEuU2NoZW1hVHlwZXMgaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL3NjaGVtYXR5cGVzLmh0bWxcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuTW9uZ29vc2UucHJvdG90eXBlLlNjaGVtYVR5cGVzID0gU2NoZW1hLlR5cGVzO1xuXG4vKipcbiAqIFRoZSBNb25nb29zZSBbVmlydHVhbFR5cGVdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvdmlydHVhbHR5cGUuaHRtbCNWaXJ0dWFsVHlwZSgpKSBjb25zdHJ1Y3RvclxuICpcbiAqIEBtZXRob2QgVmlydHVhbFR5cGVcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuTW9uZ29vc2UucHJvdG90eXBlLlZpcnR1YWxUeXBlID0gVmlydHVhbFR5cGU7XG5cbi8qKlxuICogVGhlIHZhcmlvdXMgTW9uZ29vc2UgVHlwZXMuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBjb25zdCBtb25nb29zZSA9IHJlcXVpcmUoJ21vbmdvb3NlJyk7XG4gKiAgICAgY29uc3QgYXJyYXkgPSBtb25nb29zZS5UeXBlcy5BcnJheTtcbiAqXG4gKiAjIyMjIFR5cGVzOlxuICpcbiAqIC0gW0FycmF5XShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3Mvc2NoZW1hdHlwZXMuaHRtbCNhcnJheXMpXG4gKiAtIFtCdWZmZXJdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9zY2hlbWF0eXBlcy5odG1sI2J1ZmZlcnMpXG4gKiAtIFtFbWJlZGRlZF0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL3NjaGVtYXR5cGVzLmh0bWwjc2NoZW1hcylcbiAqIC0gW0RvY3VtZW50QXJyYXldKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvZG9jdW1lbnRhcnJheXBhdGguaHRtbClcbiAqIC0gW0RlY2ltYWwxMjhdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvbW9uZ29vc2UuaHRtbCNNb25nb29zZS5wcm90b3R5cGUuRGVjaW1hbDEyOClcbiAqIC0gW09iamVjdElkXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3Mvc2NoZW1hdHlwZXMuaHRtbCNvYmplY3RpZHMpXG4gKiAtIFtNYXBdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9zY2hlbWF0eXBlcy5odG1sI21hcHMpXG4gKiAtIFtTdWJkb2N1bWVudF0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL3NjaGVtYXR5cGVzLmh0bWwjc2NoZW1hcylcbiAqXG4gKiBVc2luZyB0aGlzIGV4cG9zZWQgYWNjZXNzIHRvIHRoZSBgT2JqZWN0SWRgIHR5cGUsIHdlIGNhbiBjb25zdHJ1Y3QgaWRzIG9uIGRlbWFuZC5cbiAqXG4gKiAgICAgY29uc3QgT2JqZWN0SWQgPSBtb25nb29zZS5UeXBlcy5PYmplY3RJZDtcbiAqICAgICBjb25zdCBpZDEgPSBuZXcgT2JqZWN0SWQ7XG4gKlxuICogQHByb3BlcnR5IFR5cGVzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk1vbmdvb3NlLnByb3RvdHlwZS5UeXBlcyA9IFR5cGVzO1xuXG4vKipcbiAqIFRoZSBNb25nb29zZSBbUXVlcnldKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvcXVlcnkuaHRtbCNRdWVyeSgpKSBjb25zdHJ1Y3Rvci5cbiAqXG4gKiBAbWV0aG9kIFF1ZXJ5XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk1vbmdvb3NlLnByb3RvdHlwZS5RdWVyeSA9IFF1ZXJ5O1xuXG4vKipcbiAqIFRoZSBNb25nb29zZSBbTW9kZWxdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvbW9kZWwuaHRtbCNNb2RlbCgpKSBjb25zdHJ1Y3Rvci5cbiAqXG4gKiBAbWV0aG9kIE1vZGVsXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk1vbmdvb3NlLnByb3RvdHlwZS5Nb2RlbCA9IE1vZGVsO1xuXG4vKipcbiAqIFRoZSBNb25nb29zZSBbRG9jdW1lbnRdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvZG9jdW1lbnQuaHRtbCNEb2N1bWVudCgpKSBjb25zdHJ1Y3Rvci5cbiAqXG4gKiBAbWV0aG9kIERvY3VtZW50XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk1vbmdvb3NlLnByb3RvdHlwZS5Eb2N1bWVudCA9IERvY3VtZW50O1xuXG4vKipcbiAqIFRoZSBNb25nb29zZSBEb2N1bWVudFByb3ZpZGVyIGNvbnN0cnVjdG9yLiBNb25nb29zZSB1c2VycyBzaG91bGQgbm90IGhhdmUgdG9cbiAqIHVzZSB0aGlzIGRpcmVjdGx5XG4gKlxuICogQG1ldGhvZCBEb2N1bWVudFByb3ZpZGVyXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk1vbmdvb3NlLnByb3RvdHlwZS5Eb2N1bWVudFByb3ZpZGVyID0gcmVxdWlyZSgnLi9kb2N1bWVudFByb3ZpZGVyJyk7XG5cbi8qKlxuICogVGhlIE1vbmdvb3NlIE9iamVjdElkIFtTY2hlbWFUeXBlXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3Mvc2NoZW1hdHlwZXMuaHRtbCkuIFVzZWQgZm9yXG4gKiBkZWNsYXJpbmcgcGF0aHMgaW4geW91ciBzY2hlbWEgdGhhdCBzaG91bGQgYmVcbiAqIFtNb25nb0RCIE9iamVjdElkc10oaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvcmVmZXJlbmNlL21ldGhvZC9PYmplY3RJZC8pLlxuICogRG8gbm90IHVzZSB0aGlzIHRvIGNyZWF0ZSBhIG5ldyBPYmplY3RJZCBpbnN0YW5jZSwgdXNlIGBtb25nb29zZS5UeXBlcy5PYmplY3RJZGBcbiAqIGluc3RlYWQuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBjb25zdCBjaGlsZFNjaGVtYSA9IG5ldyBTY2hlbWEoeyBwYXJlbnRJZDogbW9uZ29vc2UuT2JqZWN0SWQgfSk7XG4gKlxuICogQHByb3BlcnR5IE9iamVjdElkXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk1vbmdvb3NlLnByb3RvdHlwZS5PYmplY3RJZCA9IFNjaGVtYVR5cGVzLk9iamVjdElkO1xuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiBNb25nb29zZSBjYW4gY2FzdCB0aGUgZ2l2ZW4gdmFsdWUgdG8gYW4gT2JqZWN0SWQsIG9yXG4gKiBmYWxzZSBvdGhlcndpc2UuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBtb25nb29zZS5pc1ZhbGlkT2JqZWN0SWQobmV3IG1vbmdvb3NlLlR5cGVzLk9iamVjdElkKCkpOyAvLyB0cnVlXG4gKiAgICAgbW9uZ29vc2UuaXNWYWxpZE9iamVjdElkKCcwMTIzNDU2Nzg5YWInKTsgLy8gdHJ1ZVxuICogICAgIG1vbmdvb3NlLmlzVmFsaWRPYmplY3RJZCg2KTsgLy8gdHJ1ZVxuICogICAgIG1vbmdvb3NlLmlzVmFsaWRPYmplY3RJZChuZXcgVXNlcih7IG5hbWU6ICd0ZXN0JyB9KSk7IC8vIHRydWVcbiAqXG4gKiAgICAgbW9uZ29vc2UuaXNWYWxpZE9iamVjdElkKHsgdGVzdDogNDIgfSk7IC8vIGZhbHNlXG4gKlxuICogQG1ldGhvZCBpc1ZhbGlkT2JqZWN0SWRcbiAqIEBwYXJhbSB7QW55fSB2XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gdHJ1ZSBpZiBgdmAgaXMgc29tZXRoaW5nIE1vbmdvb3NlIGNhbiBjb2VyY2UgdG8gYW4gT2JqZWN0SWRcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuTW9uZ29vc2UucHJvdG90eXBlLmlzVmFsaWRPYmplY3RJZCA9IGZ1bmN0aW9uKHYpIHtcbiAgY29uc3QgX21vbmdvb3NlID0gdGhpcyBpbnN0YW5jZW9mIE1vbmdvb3NlID8gdGhpcyA6IG1vbmdvb3NlO1xuICByZXR1cm4gX21vbmdvb3NlLlR5cGVzLk9iamVjdElkLmlzVmFsaWQodik7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gdmFsdWUgaXMgYSBNb25nb29zZSBPYmplY3RJZCAodXNpbmcgYGluc3RhbmNlb2ZgKSBvciBpZiB0aGVcbiAqIGdpdmVuIHZhbHVlIGlzIGEgMjQgY2hhcmFjdGVyIGhleCBzdHJpbmcsIHdoaWNoIGlzIHRoZSBtb3N0IGNvbW1vbmx5IHVzZWQgc3RyaW5nIHJlcHJlc2VudGF0aW9uXG4gKiBvZiBhbiBPYmplY3RJZC5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIHNpbWlsYXIgdG8gYGlzVmFsaWRPYmplY3RJZCgpYCwgYnV0IGNvbnNpZGVyYWJseSBtb3JlIHN0cmljdCwgYmVjYXVzZVxuICogYGlzVmFsaWRPYmplY3RJZCgpYCB3aWxsIHJldHVybiBgdHJ1ZWAgZm9yIF9hbnlfIHZhbHVlIHRoYXQgTW9uZ29vc2UgY2FuIGNvbnZlcnQgdG8gYW5cbiAqIE9iamVjdElkLiBUaGF0IGluY2x1ZGVzIE1vbmdvb3NlIGRvY3VtZW50cywgYW55IHN0cmluZyBvZiBsZW5ndGggMTIsIGFuZCBhbnkgbnVtYmVyLlxuICogYGlzT2JqZWN0SWRPckhleFN0cmluZygpYCByZXR1cm5zIHRydWUgb25seSBmb3IgYE9iamVjdElkYCBpbnN0YW5jZXMgb3IgMjQgY2hhcmFjdGVyIGhleFxuICogc3RyaW5ncywgYW5kIHdpbGwgcmV0dXJuIGZhbHNlIGZvciBudW1iZXJzLCBkb2N1bWVudHMsIGFuZCBzdHJpbmdzIG9mIGxlbmd0aCAxMi5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIG1vbmdvb3NlLmlzT2JqZWN0SWRPckhleFN0cmluZyhuZXcgbW9uZ29vc2UuVHlwZXMuT2JqZWN0SWQoKSk7IC8vIHRydWVcbiAqICAgICBtb25nb29zZS5pc09iamVjdElkT3JIZXhTdHJpbmcoJzYyMjYxYTY1ZDY2YzZiZTBhNjNjMDUxZicpOyAvLyB0cnVlXG4gKlxuICogICAgIG1vbmdvb3NlLmlzT2JqZWN0SWRPckhleFN0cmluZygnMDEyMzQ1Njc4OWFiJyk7IC8vIGZhbHNlXG4gKiAgICAgbW9uZ29vc2UuaXNPYmplY3RJZE9ySGV4U3RyaW5nKDYpOyAvLyBmYWxzZVxuICogICAgIG1vbmdvb3NlLmlzT2JqZWN0SWRPckhleFN0cmluZyhuZXcgVXNlcih7IG5hbWU6ICd0ZXN0JyB9KSk7IC8vIGZhbHNlXG4gKiAgICAgbW9uZ29vc2UuaXNPYmplY3RJZE9ySGV4U3RyaW5nKHsgdGVzdDogNDIgfSk7IC8vIGZhbHNlXG4gKlxuICogQG1ldGhvZCBpc09iamVjdElkT3JIZXhTdHJpbmdcbiAqIEBwYXJhbSB7QW55fSB2XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gdHJ1ZSBpZiBgdmAgaXMgYW4gT2JqZWN0SWQgaW5zdGFuY2UgX29yXyBhIDI0IGNoYXIgaGV4IHN0cmluZ1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Nb25nb29zZS5wcm90b3R5cGUuaXNPYmplY3RJZE9ySGV4U3RyaW5nID0gZnVuY3Rpb24odikge1xuICByZXR1cm4gaXNCc29uVHlwZSh2LCAnT2JqZWN0SWQnKSB8fCAodHlwZW9mIHYgPT09ICdzdHJpbmcnICYmIG9iamVjdElkSGV4UmVnZXhwLnRlc3QodikpO1xufTtcblxuLyoqXG4gKlxuICogU3luY3MgYWxsIHRoZSBpbmRleGVzIGZvciB0aGUgbW9kZWxzIHJlZ2lzdGVyZWQgd2l0aCB0aGlzIGNvbm5lY3Rpb24uXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gb3B0aW9ucy5jb250aW51ZU9uRXJyb3IgYGZhbHNlYCBieSBkZWZhdWx0LiBJZiBzZXQgdG8gYHRydWVgLCBtb25nb29zZSB3aWxsIG5vdCB0aHJvdyBhbiBlcnJvciBpZiBvbmUgbW9kZWwgc3luY2luZyBmYWlsZWQsIGFuZCB3aWxsIHJldHVybiBhbiBvYmplY3Qgd2hlcmUgdGhlIGtleXMgYXJlIHRoZSBuYW1lcyBvZiB0aGUgbW9kZWxzLCBhbmQgdGhlIHZhbHVlcyBhcmUgdGhlIHJlc3VsdHMvZXJyb3JzIGZvciBlYWNoIG1vZGVsLlxuICogQHJldHVybiB7UHJvbWlzZX0gUmV0dXJucyBhIFByb21pc2UsIHdoZW4gdGhlIFByb21pc2UgcmVzb2x2ZXMgdGhlIHZhbHVlIGlzIGEgbGlzdCBvZiB0aGUgZHJvcHBlZCBpbmRleGVzLlxuICovXG5Nb25nb29zZS5wcm90b3R5cGUuc3luY0luZGV4ZXMgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gIGNvbnN0IF9tb25nb29zZSA9IHRoaXMgaW5zdGFuY2VvZiBNb25nb29zZSA/IHRoaXMgOiBtb25nb29zZTtcbiAgcmV0dXJuIF9tb25nb29zZS5jb25uZWN0aW9uLnN5bmNJbmRleGVzKG9wdGlvbnMpO1xufTtcblxuLyoqXG4gKiBUaGUgTW9uZ29vc2UgRGVjaW1hbDEyOCBbU2NoZW1hVHlwZV0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL3NjaGVtYXR5cGVzLmh0bWwpLiBVc2VkIGZvclxuICogZGVjbGFyaW5nIHBhdGhzIGluIHlvdXIgc2NoZW1hIHRoYXQgc2hvdWxkIGJlXG4gKiBbMTI4LWJpdCBkZWNpbWFsIGZsb2F0aW5nIHBvaW50c10oaHR0cHM6Ly90aGVjb2RlYmFyYmFyaWFuLmNvbS9hLW5vZGVqcy1wZXJzcGVjdGl2ZS1vbi1tb25nb2RiLTM0LWRlY2ltYWwuaHRtbCkuXG4gKiBEbyBub3QgdXNlIHRoaXMgdG8gY3JlYXRlIGEgbmV3IERlY2ltYWwxMjggaW5zdGFuY2UsIHVzZSBgbW9uZ29vc2UuVHlwZXMuRGVjaW1hbDEyOGBcbiAqIGluc3RlYWQuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBjb25zdCB2ZWhpY2xlU2NoZW1hID0gbmV3IFNjaGVtYSh7IGZ1ZWxMZXZlbDogbW9uZ29vc2UuRGVjaW1hbDEyOCB9KTtcbiAqXG4gKiBAcHJvcGVydHkgRGVjaW1hbDEyOFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Nb25nb29zZS5wcm90b3R5cGUuRGVjaW1hbDEyOCA9IFNjaGVtYVR5cGVzLkRlY2ltYWwxMjg7XG5cbi8qKlxuICogVGhlIE1vbmdvb3NlIE1peGVkIFtTY2hlbWFUeXBlXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3Mvc2NoZW1hdHlwZXMuaHRtbCkuIFVzZWQgZm9yXG4gKiBkZWNsYXJpbmcgcGF0aHMgaW4geW91ciBzY2hlbWEgdGhhdCBNb25nb29zZSdzIGNoYW5nZSB0cmFja2luZywgY2FzdGluZyxcbiAqIGFuZCB2YWxpZGF0aW9uIHNob3VsZCBpZ25vcmUuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBjb25zdCBzY2hlbWEgPSBuZXcgU2NoZW1hKHsgYXJiaXRyYXJ5OiBtb25nb29zZS5NaXhlZCB9KTtcbiAqXG4gKiBAcHJvcGVydHkgTWl4ZWRcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuTW9uZ29vc2UucHJvdG90eXBlLk1peGVkID0gU2NoZW1hVHlwZXMuTWl4ZWQ7XG5cbi8qKlxuICogVGhlIE1vbmdvb3NlIERhdGUgW1NjaGVtYVR5cGVdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9zY2hlbWF0eXBlcy5odG1sKS5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IHNjaGVtYSA9IG5ldyBTY2hlbWEoeyB0ZXN0OiBEYXRlIH0pO1xuICogICAgIHNjaGVtYS5wYXRoKCd0ZXN0JykgaW5zdGFuY2VvZiBtb25nb29zZS5EYXRlOyAvLyB0cnVlXG4gKlxuICogQHByb3BlcnR5IERhdGVcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuTW9uZ29vc2UucHJvdG90eXBlLkRhdGUgPSBTY2hlbWFUeXBlcy5EYXRlO1xuXG4vKipcbiAqIFRoZSBNb25nb29zZSBOdW1iZXIgW1NjaGVtYVR5cGVdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9zY2hlbWF0eXBlcy5odG1sKS4gVXNlZCBmb3JcbiAqIGRlY2xhcmluZyBwYXRocyBpbiB5b3VyIHNjaGVtYSB0aGF0IE1vbmdvb3NlIHNob3VsZCBjYXN0IHRvIG51bWJlcnMuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBjb25zdCBzY2hlbWEgPSBuZXcgU2NoZW1hKHsgbnVtOiBtb25nb29zZS5OdW1iZXIgfSk7XG4gKiAgICAgLy8gRXF1aXZhbGVudCB0bzpcbiAqICAgICBjb25zdCBzY2hlbWEgPSBuZXcgU2NoZW1hKHsgbnVtOiAnbnVtYmVyJyB9KTtcbiAqXG4gKiBAcHJvcGVydHkgTnVtYmVyXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk1vbmdvb3NlLnByb3RvdHlwZS5OdW1iZXIgPSBTY2hlbWFUeXBlcy5OdW1iZXI7XG5cbi8qKlxuICogVGhlIFtNb25nb29zZUVycm9yXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvYXBpL2Vycm9yLmh0bWwjRXJyb3IoKSkgY29uc3RydWN0b3IuXG4gKlxuICogQG1ldGhvZCBFcnJvclxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Nb25nb29zZS5wcm90b3R5cGUuRXJyb3IgPSByZXF1aXJlKCcuL2Vycm9yL2luZGV4Jyk7XG5Nb25nb29zZS5wcm90b3R5cGUuTW9uZ29vc2VFcnJvciA9IHJlcXVpcmUoJy4vZXJyb3IvbW9uZ29vc2VFcnJvcicpO1xuXG4vKipcbiAqIE1vbmdvb3NlIHVzZXMgdGhpcyBmdW5jdGlvbiB0byBnZXQgdGhlIGN1cnJlbnQgdGltZSB3aGVuIHNldHRpbmdcbiAqIFt0aW1lc3RhbXBzXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvZ3VpZGUuaHRtbCN0aW1lc3RhbXBzKS4gWW91IG1heSBzdHViIG91dCB0aGlzIGZ1bmN0aW9uXG4gKiB1c2luZyBhIHRvb2wgbGlrZSBbU2lub25dKGh0dHBzOi8vd3d3Lm5wbWpzLmNvbS9wYWNrYWdlL3Npbm9uKSBmb3IgdGVzdGluZy5cbiAqXG4gKiBAbWV0aG9kIG5vd1xuICogQHJldHVybnMgRGF0ZSB0aGUgY3VycmVudCB0aW1lXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk1vbmdvb3NlLnByb3RvdHlwZS5ub3cgPSBmdW5jdGlvbiBub3coKSB7IHJldHVybiBuZXcgRGF0ZSgpOyB9O1xuXG4vKipcbiAqIFRoZSBNb25nb29zZSBDYXN0RXJyb3IgY29uc3RydWN0b3JcbiAqXG4gKiBAbWV0aG9kIENhc3RFcnJvclxuICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgVGhlIG5hbWUgb2YgdGhlIHR5cGVcbiAqIEBwYXJhbSB7QW55fSB2YWx1ZSBUaGUgdmFsdWUgdGhhdCBmYWlsZWQgdG8gY2FzdFxuICogQHBhcmFtIHtTdHJpbmd9IHBhdGggVGhlIHBhdGggYGEuYi5jYCBpbiB0aGUgZG9jIHdoZXJlIHRoaXMgY2FzdCBlcnJvciBvY2N1cnJlZFxuICogQHBhcmFtIHtFcnJvcn0gW3JlYXNvbl0gVGhlIG9yaWdpbmFsIGVycm9yIHRoYXQgd2FzIHRocm93blxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Nb25nb29zZS5wcm90b3R5cGUuQ2FzdEVycm9yID0gcmVxdWlyZSgnLi9lcnJvci9jYXN0Jyk7XG5cbi8qKlxuICogVGhlIGNvbnN0cnVjdG9yIHVzZWQgZm9yIHNjaGVtYXR5cGUgb3B0aW9uc1xuICpcbiAqIEBtZXRob2QgU2NoZW1hVHlwZU9wdGlvbnNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuTW9uZ29vc2UucHJvdG90eXBlLlNjaGVtYVR5cGVPcHRpb25zID0gcmVxdWlyZSgnLi9vcHRpb25zL3NjaGVtYVR5cGVPcHRpb25zJyk7XG5cbi8qKlxuICogVGhlIFttcXVlcnldKGh0dHBzOi8vZ2l0aHViLmNvbS9haGVja21hbm4vbXF1ZXJ5KSBxdWVyeSBidWlsZGVyIE1vbmdvb3NlIHVzZXMuXG4gKlxuICogQHByb3BlcnR5IG1xdWVyeVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Nb25nb29zZS5wcm90b3R5cGUubXF1ZXJ5ID0gcmVxdWlyZSgnbXF1ZXJ5Jyk7XG5cbi8qKlxuICogU2FuaXRpemVzIHF1ZXJ5IGZpbHRlcnMgYWdhaW5zdCBbcXVlcnkgc2VsZWN0b3IgaW5qZWN0aW9uIGF0dGFja3NdKGh0dHBzOi8vdGhlY29kZWJhcmJhcmlhbi5jb20vMjAxNC8wOS8wNC9kZWZlbmRpbmctYWdhaW5zdC1xdWVyeS1zZWxlY3Rvci1pbmplY3Rpb24tYXR0YWNrcy5odG1sKVxuICogYnkgd3JhcHBpbmcgYW55IG5lc3RlZCBvYmplY3RzIHRoYXQgaGF2ZSBhIHByb3BlcnR5IHdob3NlIG5hbWUgc3RhcnRzIHdpdGggYCRgIGluIGEgYCRlcWAuXG4gKlxuICogYGBgamF2YXNjcmlwdFxuICogY29uc3Qgb2JqID0geyB1c2VybmFtZTogJ3ZhbCcsIHB3ZDogeyAkbmU6IG51bGwgfSB9O1xuICogc2FuaXRpemVGaWx0ZXIob2JqKTtcbiAqIG9iajsgLy8geyB1c2VybmFtZTogJ3ZhbCcsIHB3ZDogeyAkZXE6IHsgJG5lOiBudWxsIH0gfSB9KTtcbiAqIGBgYFxuICpcbiAqIEBtZXRob2Qgc2FuaXRpemVGaWx0ZXJcbiAqIEBwYXJhbSB7T2JqZWN0fSBmaWx0ZXJcbiAqIEByZXR1cm5zIE9iamVjdCB0aGUgc2FuaXRpemVkIG9iamVjdFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Nb25nb29zZS5wcm90b3R5cGUuc2FuaXRpemVGaWx0ZXIgPSBzYW5pdGl6ZUZpbHRlcjtcblxuLyoqXG4gKiBUZWxscyBgc2FuaXRpemVGaWx0ZXIoKWAgdG8gc2tpcCB0aGUgZ2l2ZW4gb2JqZWN0IHdoZW4gZmlsdGVyaW5nIG91dCBwb3RlbnRpYWwgW3F1ZXJ5IHNlbGVjdG9yIGluamVjdGlvbiBhdHRhY2tzXShodHRwczovL3RoZWNvZGViYXJiYXJpYW4uY29tLzIwMTQvMDkvMDQvZGVmZW5kaW5nLWFnYWluc3QtcXVlcnktc2VsZWN0b3ItaW5qZWN0aW9uLWF0dGFja3MuaHRtbCkuXG4gKiBVc2UgdGhpcyBtZXRob2Qgd2hlbiB5b3UgaGF2ZSBhIGtub3duIHF1ZXJ5IHNlbGVjdG9yIHRoYXQgeW91IHdhbnQgdG8gdXNlLlxuICpcbiAqIGBgYGphdmFzY3JpcHRcbiAqIGNvbnN0IG9iaiA9IHsgdXNlcm5hbWU6ICd2YWwnLCBwd2Q6IHRydXN0ZWQoeyAkdHlwZTogJ3N0cmluZycsICRlcTogJ215IHNlY3JldCcgfSkgfTtcbiAqIHNhbml0aXplRmlsdGVyKG9iaik7XG4gKlxuICogLy8gTm90ZSB0aGF0IGBzYW5pdGl6ZUZpbHRlcigpYCBkaWQgbm90IGFkZCBgJGVxYCBhcm91bmQgYCR0eXBlYC5cbiAqIG9iajsgLy8geyB1c2VybmFtZTogJ3ZhbCcsIHB3ZDogeyAkdHlwZTogJ3N0cmluZycsICRlcTogJ215IHNlY3JldCcgfSB9KTtcbiAqIGBgYFxuICpcbiAqIEBtZXRob2QgdHJ1c3RlZFxuICogQHBhcmFtIHtPYmplY3R9IG9ialxuICogQHJldHVybnMgT2JqZWN0IHRoZSBwYXNzZWQgaW4gb2JqZWN0XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk1vbmdvb3NlLnByb3RvdHlwZS50cnVzdGVkID0gdHJ1c3RlZDtcblxuLyoqXG4gKiBVc2UgdGhpcyBmdW5jdGlvbiBpbiBgcHJlKClgIG1pZGRsZXdhcmUgdG8gc2tpcCBjYWxsaW5nIHRoZSB3cmFwcGVkIGZ1bmN0aW9uLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgc2NoZW1hLnByZSgnc2F2ZScsIGZ1bmN0aW9uKCkge1xuICogICAgICAgLy8gV2lsbCBza2lwIGV4ZWN1dGluZyBgc2F2ZSgpYCwgYnV0IHdpbGwgZXhlY3V0ZSBwb3N0IGhvb2tzIGFzIGlmXG4gKiAgICAgICAvLyBgc2F2ZSgpYCBoYWQgZXhlY3V0ZWQgd2l0aCB0aGUgcmVzdWx0IGB7IG1hdGNoZWRDb3VudDogMCB9YFxuICogICAgICAgcmV0dXJuIG1vbmdvb3NlLnNraXBNaWRkbGV3YXJlRnVuY3Rpb24oeyBtYXRjaGVkQ291bnQ6IDAgfSk7XG4gKiAgICAgfSk7XG4gKlxuICogQG1ldGhvZCBza2lwTWlkZGxld2FyZUZ1bmN0aW9uXG4gKiBAcGFyYW0ge2FueX0gcmVzdWx0XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk1vbmdvb3NlLnByb3RvdHlwZS5za2lwTWlkZGxld2FyZUZ1bmN0aW9uID0gS2FyZWVtLnNraXBXcmFwcGVkRnVuY3Rpb247XG5cbi8qKlxuICogVXNlIHRoaXMgZnVuY3Rpb24gaW4gYHBvc3QoKWAgbWlkZGxld2FyZSB0byByZXBsYWNlIHRoZSByZXN1bHRcbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIHNjaGVtYS5wb3N0KCdmaW5kJywgZnVuY3Rpb24ocmVzKSB7XG4gKiAgICAgICAvLyBOb3JtYWxseSB5b3UgaGF2ZSB0byBtb2RpZnkgYHJlc2AgaW4gcGxhY2UuIEJ1dCB3aXRoXG4gKiAgICAgICAvLyBgb3ZlcndyaXRlTWlkZGxld2FyUmVzdWx0KClgLCB5b3UgY2FuIG1ha2UgYGZpbmQoKWAgcmV0dXJuIGFcbiAqICAgICAgIC8vIGNvbXBsZXRlbHkgZGlmZmVyZW50IHZhbHVlLlxuICogICAgICAgcmV0dXJuIG1vbmdvb3NlLm92ZXJ3cml0ZU1pZGRsZXdhcmVSZXN1bHQocmVzLmZpbHRlcihkb2MgPT4gIWRvYy5pc0RlbGV0ZWQpKTtcbiAqICAgICB9KTtcbiAqXG4gKiBAbWV0aG9kIG92ZXJ3cml0ZU1pZGRsZXdhcmVSZXN1bHRcbiAqIEBwYXJhbSB7YW55fSByZXN1bHRcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuTW9uZ29vc2UucHJvdG90eXBlLm92ZXJ3cml0ZU1pZGRsZXdhcmVSZXN1bHQgPSBLYXJlZW0ub3ZlcndyaXRlUmVzdWx0O1xuXG4vKipcbiAqIFRoZSBleHBvcnRzIG9iamVjdCBpcyBhbiBpbnN0YW5jZSBvZiBNb25nb29zZS5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5jb25zdCBtb25nb29zZSA9IG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IG5ldyBNb25nb29zZSh7XG4gIFtkZWZhdWx0TW9uZ29vc2VTeW1ib2xdOiB0cnVlXG59KTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../server/node_modules/mongoose/lib/mongoose.js\n");

/***/ }),

/***/ "../server/node_modules/mongoose/lib/options.js":
/*!******************************************************!*\
  !*** ../server/node_modules/mongoose/lib/options.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\n/*!\n * ignore\n */\n\nexports.internalToObjectOptions = {\n  transform: false,\n  virtuals: false,\n  getters: false,\n  _skipDepopulateTopLevel: true,\n  depopulate: true,\n  flattenDecimals: false,\n  useProjection: false,\n  versionKey: true\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvb3B0aW9ucy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBO0FBQ0E7O0FBRUEsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2NsaWVudC8uLi9zZXJ2ZXIvbm9kZV9tb2R1bGVzL21vbmdvb3NlL2xpYi9vcHRpb25zLmpzPzBjNTYiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cbmV4cG9ydHMuaW50ZXJuYWxUb09iamVjdE9wdGlvbnMgPSB7XG4gIHRyYW5zZm9ybTogZmFsc2UsXG4gIHZpcnR1YWxzOiBmYWxzZSxcbiAgZ2V0dGVyczogZmFsc2UsXG4gIF9za2lwRGVwb3B1bGF0ZVRvcExldmVsOiB0cnVlLFxuICBkZXBvcHVsYXRlOiB0cnVlLFxuICBmbGF0dGVuRGVjaW1hbHM6IGZhbHNlLFxuICB1c2VQcm9qZWN0aW9uOiBmYWxzZSxcbiAgdmVyc2lvbktleTogdHJ1ZVxufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../server/node_modules/mongoose/lib/options.js\n");

/***/ }),

/***/ "../server/node_modules/mongoose/lib/options/populateOptions.js":
/*!**********************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/options/populateOptions.js ***!
  \**********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst clone = __webpack_require__(/*! ../helpers/clone */ \"../server/node_modules/mongoose/lib/helpers/clone.js\");\n\nclass PopulateOptions {\n  constructor(obj) {\n    this._docs = {};\n    this._childDocs = [];\n\n    if (obj == null) {\n      return;\n    }\n    obj = clone(obj);\n    Object.assign(this, obj);\n    if (typeof obj.subPopulate === 'object') {\n      this.populate = obj.subPopulate;\n    }\n\n\n    if (obj.perDocumentLimit != null && obj.limit != null) {\n      throw new Error('Can not use `limit` and `perDocumentLimit` at the same time. Path: `' + obj.path + '`.');\n    }\n  }\n}\n\n/**\n * The connection used to look up models by name. If not specified, Mongoose\n * will default to using the connection associated with the model in\n * `PopulateOptions#model`.\n *\n * @memberOf PopulateOptions\n * @property {Connection} connection\n * @api public\n */\n\nmodule.exports = PopulateOptions;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvb3B0aW9ucy9wb3B1bGF0ZU9wdGlvbnMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsY0FBYyxtQkFBTyxDQUFDLDhFQUFrQjs7QUFFeEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFlBQVk7QUFDMUI7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL2NsaWVudC8uLi9zZXJ2ZXIvbm9kZV9tb2R1bGVzL21vbmdvb3NlL2xpYi9vcHRpb25zL3BvcHVsYXRlT3B0aW9ucy5qcz9lNDVlIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3QgY2xvbmUgPSByZXF1aXJlKCcuLi9oZWxwZXJzL2Nsb25lJyk7XG5cbmNsYXNzIFBvcHVsYXRlT3B0aW9ucyB7XG4gIGNvbnN0cnVjdG9yKG9iaikge1xuICAgIHRoaXMuX2RvY3MgPSB7fTtcbiAgICB0aGlzLl9jaGlsZERvY3MgPSBbXTtcblxuICAgIGlmIChvYmogPT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBvYmogPSBjbG9uZShvYmopO1xuICAgIE9iamVjdC5hc3NpZ24odGhpcywgb2JqKTtcbiAgICBpZiAodHlwZW9mIG9iai5zdWJQb3B1bGF0ZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIHRoaXMucG9wdWxhdGUgPSBvYmouc3ViUG9wdWxhdGU7XG4gICAgfVxuXG5cbiAgICBpZiAob2JqLnBlckRvY3VtZW50TGltaXQgIT0gbnVsbCAmJiBvYmoubGltaXQgIT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW4gbm90IHVzZSBgbGltaXRgIGFuZCBgcGVyRG9jdW1lbnRMaW1pdGAgYXQgdGhlIHNhbWUgdGltZS4gUGF0aDogYCcgKyBvYmoucGF0aCArICdgLicpO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFRoZSBjb25uZWN0aW9uIHVzZWQgdG8gbG9vayB1cCBtb2RlbHMgYnkgbmFtZS4gSWYgbm90IHNwZWNpZmllZCwgTW9uZ29vc2VcbiAqIHdpbGwgZGVmYXVsdCB0byB1c2luZyB0aGUgY29ubmVjdGlvbiBhc3NvY2lhdGVkIHdpdGggdGhlIG1vZGVsIGluXG4gKiBgUG9wdWxhdGVPcHRpb25zI21vZGVsYC5cbiAqXG4gKiBAbWVtYmVyT2YgUG9wdWxhdGVPcHRpb25zXG4gKiBAcHJvcGVydHkge0Nvbm5lY3Rpb259IGNvbm5lY3Rpb25cbiAqIEBhcGkgcHVibGljXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBQb3B1bGF0ZU9wdGlvbnM7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../server/node_modules/mongoose/lib/options/populateOptions.js\n");

/***/ }),

/***/ "../server/node_modules/mongoose/lib/options/propertyOptions.js":
/*!**********************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/options/propertyOptions.js ***!
  \**********************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nmodule.exports = Object.freeze({\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value: void 0\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvb3B0aW9ucy9wcm9wZXJ0eU9wdGlvbnMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbGllbnQvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvb3B0aW9ucy9wcm9wZXJ0eU9wdGlvbnMuanM/NWU2YyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0LmZyZWV6ZSh7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgd3JpdGFibGU6IHRydWUsXG4gIHZhbHVlOiB2b2lkIDBcbn0pO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../server/node_modules/mongoose/lib/options/propertyOptions.js\n");

/***/ }),

/***/ "../server/node_modules/mongoose/lib/options/saveOptions.js":
/*!******************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/options/saveOptions.js ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst clone = __webpack_require__(/*! ../helpers/clone */ \"../server/node_modules/mongoose/lib/helpers/clone.js\");\n\nclass SaveOptions {\n  constructor(obj) {\n    if (obj == null) {\n      return;\n    }\n    Object.assign(this, clone(obj));\n  }\n}\n\nmodule.exports = SaveOptions;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvb3B0aW9ucy9zYXZlT3B0aW9ucy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixjQUFjLG1CQUFPLENBQUMsOEVBQWtCOztBQUV4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2xpZW50Ly4uL3NlcnZlci9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL29wdGlvbnMvc2F2ZU9wdGlvbnMuanM/MjEzMyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IGNsb25lID0gcmVxdWlyZSgnLi4vaGVscGVycy9jbG9uZScpO1xuXG5jbGFzcyBTYXZlT3B0aW9ucyB7XG4gIGNvbnN0cnVjdG9yKG9iaikge1xuICAgIGlmIChvYmogPT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBPYmplY3QuYXNzaWduKHRoaXMsIGNsb25lKG9iaikpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gU2F2ZU9wdGlvbnM7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../server/node_modules/mongoose/lib/options/saveOptions.js\n");

/***/ }),

/***/ "../server/node_modules/mongoose/lib/options/schemaArrayOptions.js":
/*!*************************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/options/schemaArrayOptions.js ***!
  \*************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst SchemaTypeOptions = __webpack_require__(/*! ./schemaTypeOptions */ \"../server/node_modules/mongoose/lib/options/schemaTypeOptions.js\");\n\n/**\n * The options defined on an Array schematype.\n *\n * #### Example:\n *\n *     const schema = new Schema({ tags: [String] });\n *     schema.path('tags').options; // SchemaArrayOptions instance\n *\n * @api public\n * @inherits SchemaTypeOptions\n * @constructor SchemaArrayOptions\n */\n\nclass SchemaArrayOptions extends SchemaTypeOptions {}\n\nconst opts = __webpack_require__(/*! ./propertyOptions */ \"../server/node_modules/mongoose/lib/options/propertyOptions.js\");\n\n/**\n * If this is an array of strings, an array of allowed values for this path.\n * Throws an error if this array isn't an array of strings.\n *\n * @api public\n * @property enum\n * @memberOf SchemaArrayOptions\n * @type {Array}\n * @instance\n */\n\nObject.defineProperty(SchemaArrayOptions.prototype, 'enum', opts);\n\n/**\n * If set, specifies the type of this array's values. Equivalent to setting\n * `type` to an array whose first element is `of`.\n *\n * #### Example:\n *\n *     // `arr` is an array of numbers.\n *     new Schema({ arr: [Number] });\n *     // Equivalent way to define `arr` as an array of numbers\n *     new Schema({ arr: { type: Array, of: Number } });\n *\n * @api public\n * @property of\n * @memberOf SchemaArrayOptions\n * @type {Function|String}\n * @instance\n */\n\nObject.defineProperty(SchemaArrayOptions.prototype, 'of', opts);\n\n/**\n * If set to `false`, will always deactivate casting non-array values to arrays.\n * If set to `true`, will cast non-array values to arrays if `init` and `SchemaArray.options.castNonArrays` are also `true`\n *\n * #### Example:\n *\n *     const Model = db.model('Test', new Schema({ x1: { castNonArrays: false, type: [String] } }));\n *     const doc = new Model({ x1: \"some non-array value\" });\n *     await doc.validate(); // Errors with \"CastError\"\n *\n * @api public\n * @property castNonArrays\n * @memberOf SchemaArrayOptions\n * @type {Boolean}\n * @instance\n */\n\nObject.defineProperty(SchemaArrayOptions.prototype, 'castNonArrays', opts);\n\n/*!\n * ignore\n */\n\nmodule.exports = SchemaArrayOptions;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvb3B0aW9ucy9zY2hlbWFBcnJheU9wdGlvbnMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsMEJBQTBCLG1CQUFPLENBQUMsNkZBQXFCOztBQUV2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLGdCQUFnQjtBQUNuRCxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxhQUFhLG1CQUFPLENBQUMseUZBQW1COztBQUV4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGVBQWU7QUFDbkM7QUFDQSxvQkFBb0IsT0FBTywyQkFBMkI7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsTUFBTSx3Q0FBd0M7QUFDakcsK0JBQStCLDRCQUE0QjtBQUMzRCw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbGllbnQvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvb3B0aW9ucy9zY2hlbWFBcnJheU9wdGlvbnMuanM/NWEwNiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IFNjaGVtYVR5cGVPcHRpb25zID0gcmVxdWlyZSgnLi9zY2hlbWFUeXBlT3B0aW9ucycpO1xuXG4vKipcbiAqIFRoZSBvcHRpb25zIGRlZmluZWQgb24gYW4gQXJyYXkgc2NoZW1hdHlwZS5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IHNjaGVtYSA9IG5ldyBTY2hlbWEoeyB0YWdzOiBbU3RyaW5nXSB9KTtcbiAqICAgICBzY2hlbWEucGF0aCgndGFncycpLm9wdGlvbnM7IC8vIFNjaGVtYUFycmF5T3B0aW9ucyBpbnN0YW5jZVxuICpcbiAqIEBhcGkgcHVibGljXG4gKiBAaW5oZXJpdHMgU2NoZW1hVHlwZU9wdGlvbnNcbiAqIEBjb25zdHJ1Y3RvciBTY2hlbWFBcnJheU9wdGlvbnNcbiAqL1xuXG5jbGFzcyBTY2hlbWFBcnJheU9wdGlvbnMgZXh0ZW5kcyBTY2hlbWFUeXBlT3B0aW9ucyB7fVxuXG5jb25zdCBvcHRzID0gcmVxdWlyZSgnLi9wcm9wZXJ0eU9wdGlvbnMnKTtcblxuLyoqXG4gKiBJZiB0aGlzIGlzIGFuIGFycmF5IG9mIHN0cmluZ3MsIGFuIGFycmF5IG9mIGFsbG93ZWQgdmFsdWVzIGZvciB0aGlzIHBhdGguXG4gKiBUaHJvd3MgYW4gZXJyb3IgaWYgdGhpcyBhcnJheSBpc24ndCBhbiBhcnJheSBvZiBzdHJpbmdzLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKiBAcHJvcGVydHkgZW51bVxuICogQG1lbWJlck9mIFNjaGVtYUFycmF5T3B0aW9uc1xuICogQHR5cGUge0FycmF5fVxuICogQGluc3RhbmNlXG4gKi9cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFNjaGVtYUFycmF5T3B0aW9ucy5wcm90b3R5cGUsICdlbnVtJywgb3B0cyk7XG5cbi8qKlxuICogSWYgc2V0LCBzcGVjaWZpZXMgdGhlIHR5cGUgb2YgdGhpcyBhcnJheSdzIHZhbHVlcy4gRXF1aXZhbGVudCB0byBzZXR0aW5nXG4gKiBgdHlwZWAgdG8gYW4gYXJyYXkgd2hvc2UgZmlyc3QgZWxlbWVudCBpcyBgb2ZgLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgLy8gYGFycmAgaXMgYW4gYXJyYXkgb2YgbnVtYmVycy5cbiAqICAgICBuZXcgU2NoZW1hKHsgYXJyOiBbTnVtYmVyXSB9KTtcbiAqICAgICAvLyBFcXVpdmFsZW50IHdheSB0byBkZWZpbmUgYGFycmAgYXMgYW4gYXJyYXkgb2YgbnVtYmVyc1xuICogICAgIG5ldyBTY2hlbWEoeyBhcnI6IHsgdHlwZTogQXJyYXksIG9mOiBOdW1iZXIgfSB9KTtcbiAqXG4gKiBAYXBpIHB1YmxpY1xuICogQHByb3BlcnR5IG9mXG4gKiBAbWVtYmVyT2YgU2NoZW1hQXJyYXlPcHRpb25zXG4gKiBAdHlwZSB7RnVuY3Rpb258U3RyaW5nfVxuICogQGluc3RhbmNlXG4gKi9cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFNjaGVtYUFycmF5T3B0aW9ucy5wcm90b3R5cGUsICdvZicsIG9wdHMpO1xuXG4vKipcbiAqIElmIHNldCB0byBgZmFsc2VgLCB3aWxsIGFsd2F5cyBkZWFjdGl2YXRlIGNhc3Rpbmcgbm9uLWFycmF5IHZhbHVlcyB0byBhcnJheXMuXG4gKiBJZiBzZXQgdG8gYHRydWVgLCB3aWxsIGNhc3Qgbm9uLWFycmF5IHZhbHVlcyB0byBhcnJheXMgaWYgYGluaXRgIGFuZCBgU2NoZW1hQXJyYXkub3B0aW9ucy5jYXN0Tm9uQXJyYXlzYCBhcmUgYWxzbyBgdHJ1ZWBcbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IE1vZGVsID0gZGIubW9kZWwoJ1Rlc3QnLCBuZXcgU2NoZW1hKHsgeDE6IHsgY2FzdE5vbkFycmF5czogZmFsc2UsIHR5cGU6IFtTdHJpbmddIH0gfSkpO1xuICogICAgIGNvbnN0IGRvYyA9IG5ldyBNb2RlbCh7IHgxOiBcInNvbWUgbm9uLWFycmF5IHZhbHVlXCIgfSk7XG4gKiAgICAgYXdhaXQgZG9jLnZhbGlkYXRlKCk7IC8vIEVycm9ycyB3aXRoIFwiQ2FzdEVycm9yXCJcbiAqXG4gKiBAYXBpIHB1YmxpY1xuICogQHByb3BlcnR5IGNhc3ROb25BcnJheXNcbiAqIEBtZW1iZXJPZiBTY2hlbWFBcnJheU9wdGlvbnNcbiAqIEB0eXBlIHtCb29sZWFufVxuICogQGluc3RhbmNlXG4gKi9cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFNjaGVtYUFycmF5T3B0aW9ucy5wcm90b3R5cGUsICdjYXN0Tm9uQXJyYXlzJywgb3B0cyk7XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBTY2hlbWFBcnJheU9wdGlvbnM7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../server/node_modules/mongoose/lib/options/schemaArrayOptions.js\n");

/***/ }),

/***/ "../server/node_modules/mongoose/lib/options/schemaBufferOptions.js":
/*!**************************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/options/schemaBufferOptions.js ***!
  \**************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst SchemaTypeOptions = __webpack_require__(/*! ./schemaTypeOptions */ \"../server/node_modules/mongoose/lib/options/schemaTypeOptions.js\");\n\n/**\n * The options defined on a Buffer schematype.\n *\n * #### Example:\n *\n *     const schema = new Schema({ bitmap: Buffer });\n *     schema.path('bitmap').options; // SchemaBufferOptions instance\n *\n * @api public\n * @inherits SchemaTypeOptions\n * @constructor SchemaBufferOptions\n */\n\nclass SchemaBufferOptions extends SchemaTypeOptions {}\n\nconst opts = __webpack_require__(/*! ./propertyOptions */ \"../server/node_modules/mongoose/lib/options/propertyOptions.js\");\n\n/**\n * Set the default subtype for this buffer.\n *\n * @api public\n * @property subtype\n * @memberOf SchemaBufferOptions\n * @type {Number}\n * @instance\n */\n\nObject.defineProperty(SchemaBufferOptions.prototype, 'subtype', opts);\n\n/*!\n * ignore\n */\n\nmodule.exports = SchemaBufferOptions;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvb3B0aW9ucy9zY2hlbWFCdWZmZXJPcHRpb25zLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLDBCQUEwQixtQkFBTyxDQUFDLDZGQUFxQjs7QUFFdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxnQkFBZ0I7QUFDbkQsc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsYUFBYSxtQkFBTyxDQUFDLHlGQUFtQjs7QUFFeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2xpZW50Ly4uL3NlcnZlci9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL29wdGlvbnMvc2NoZW1hQnVmZmVyT3B0aW9ucy5qcz85ZGFkIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3QgU2NoZW1hVHlwZU9wdGlvbnMgPSByZXF1aXJlKCcuL3NjaGVtYVR5cGVPcHRpb25zJyk7XG5cbi8qKlxuICogVGhlIG9wdGlvbnMgZGVmaW5lZCBvbiBhIEJ1ZmZlciBzY2hlbWF0eXBlLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgY29uc3Qgc2NoZW1hID0gbmV3IFNjaGVtYSh7IGJpdG1hcDogQnVmZmVyIH0pO1xuICogICAgIHNjaGVtYS5wYXRoKCdiaXRtYXAnKS5vcHRpb25zOyAvLyBTY2hlbWFCdWZmZXJPcHRpb25zIGluc3RhbmNlXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqIEBpbmhlcml0cyBTY2hlbWFUeXBlT3B0aW9uc1xuICogQGNvbnN0cnVjdG9yIFNjaGVtYUJ1ZmZlck9wdGlvbnNcbiAqL1xuXG5jbGFzcyBTY2hlbWFCdWZmZXJPcHRpb25zIGV4dGVuZHMgU2NoZW1hVHlwZU9wdGlvbnMge31cblxuY29uc3Qgb3B0cyA9IHJlcXVpcmUoJy4vcHJvcGVydHlPcHRpb25zJyk7XG5cbi8qKlxuICogU2V0IHRoZSBkZWZhdWx0IHN1YnR5cGUgZm9yIHRoaXMgYnVmZmVyLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKiBAcHJvcGVydHkgc3VidHlwZVxuICogQG1lbWJlck9mIFNjaGVtYUJ1ZmZlck9wdGlvbnNcbiAqIEB0eXBlIHtOdW1iZXJ9XG4gKiBAaW5zdGFuY2VcbiAqL1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoU2NoZW1hQnVmZmVyT3B0aW9ucy5wcm90b3R5cGUsICdzdWJ0eXBlJywgb3B0cyk7XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBTY2hlbWFCdWZmZXJPcHRpb25zO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../server/node_modules/mongoose/lib/options/schemaBufferOptions.js\n");

/***/ }),

/***/ "../server/node_modules/mongoose/lib/options/schemaDateOptions.js":
/*!************************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/options/schemaDateOptions.js ***!
  \************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst SchemaTypeOptions = __webpack_require__(/*! ./schemaTypeOptions */ \"../server/node_modules/mongoose/lib/options/schemaTypeOptions.js\");\n\n/**\n * The options defined on a Date schematype.\n *\n * #### Example:\n *\n *     const schema = new Schema({ startedAt: Date });\n *     schema.path('startedAt').options; // SchemaDateOptions instance\n *\n * @api public\n * @inherits SchemaTypeOptions\n * @constructor SchemaDateOptions\n */\n\nclass SchemaDateOptions extends SchemaTypeOptions {}\n\nconst opts = __webpack_require__(/*! ./propertyOptions */ \"../server/node_modules/mongoose/lib/options/propertyOptions.js\");\n\n/**\n * If set, Mongoose adds a validator that checks that this path is after the\n * given `min`.\n *\n * @api public\n * @property min\n * @memberOf SchemaDateOptions\n * @type {Date}\n * @instance\n */\n\nObject.defineProperty(SchemaDateOptions.prototype, 'min', opts);\n\n/**\n * If set, Mongoose adds a validator that checks that this path is before the\n * given `max`.\n *\n * @api public\n * @property max\n * @memberOf SchemaDateOptions\n * @type {Date}\n * @instance\n */\n\nObject.defineProperty(SchemaDateOptions.prototype, 'max', opts);\n\n/**\n * If set, Mongoose creates a TTL index on this path.\n *\n * mongo TTL index `expireAfterSeconds` value will take 'expires' value expressed in seconds.\n *\n * #### Example:\n *\n *     const schema = new Schema({ \"expireAt\": { type: Date,  expires: 11 } });\n *     // if 'expireAt' is set, then document expires at expireAt + 11 seconds\n *\n * @api public\n * @property expires\n * @memberOf SchemaDateOptions\n * @type {Date}\n * @instance\n */\n\nObject.defineProperty(SchemaDateOptions.prototype, 'expires', opts);\n\n/*!\n * ignore\n */\n\nmodule.exports = SchemaDateOptions;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvb3B0aW9ucy9zY2hlbWFEYXRlT3B0aW9ucy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYiwwQkFBMEIsbUJBQU8sQ0FBQyw2RkFBcUI7O0FBRXZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsaUJBQWlCO0FBQ3BELHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLGFBQWEsbUJBQU8sQ0FBQyx5RkFBbUI7O0FBRXhDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxjQUFjLDRCQUE0QjtBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2xpZW50Ly4uL3NlcnZlci9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL29wdGlvbnMvc2NoZW1hRGF0ZU9wdGlvbnMuanM/ZTYzNiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IFNjaGVtYVR5cGVPcHRpb25zID0gcmVxdWlyZSgnLi9zY2hlbWFUeXBlT3B0aW9ucycpO1xuXG4vKipcbiAqIFRoZSBvcHRpb25zIGRlZmluZWQgb24gYSBEYXRlIHNjaGVtYXR5cGUuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBjb25zdCBzY2hlbWEgPSBuZXcgU2NoZW1hKHsgc3RhcnRlZEF0OiBEYXRlIH0pO1xuICogICAgIHNjaGVtYS5wYXRoKCdzdGFydGVkQXQnKS5vcHRpb25zOyAvLyBTY2hlbWFEYXRlT3B0aW9ucyBpbnN0YW5jZVxuICpcbiAqIEBhcGkgcHVibGljXG4gKiBAaW5oZXJpdHMgU2NoZW1hVHlwZU9wdGlvbnNcbiAqIEBjb25zdHJ1Y3RvciBTY2hlbWFEYXRlT3B0aW9uc1xuICovXG5cbmNsYXNzIFNjaGVtYURhdGVPcHRpb25zIGV4dGVuZHMgU2NoZW1hVHlwZU9wdGlvbnMge31cblxuY29uc3Qgb3B0cyA9IHJlcXVpcmUoJy4vcHJvcGVydHlPcHRpb25zJyk7XG5cbi8qKlxuICogSWYgc2V0LCBNb25nb29zZSBhZGRzIGEgdmFsaWRhdG9yIHRoYXQgY2hlY2tzIHRoYXQgdGhpcyBwYXRoIGlzIGFmdGVyIHRoZVxuICogZ2l2ZW4gYG1pbmAuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqIEBwcm9wZXJ0eSBtaW5cbiAqIEBtZW1iZXJPZiBTY2hlbWFEYXRlT3B0aW9uc1xuICogQHR5cGUge0RhdGV9XG4gKiBAaW5zdGFuY2VcbiAqL1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoU2NoZW1hRGF0ZU9wdGlvbnMucHJvdG90eXBlLCAnbWluJywgb3B0cyk7XG5cbi8qKlxuICogSWYgc2V0LCBNb25nb29zZSBhZGRzIGEgdmFsaWRhdG9yIHRoYXQgY2hlY2tzIHRoYXQgdGhpcyBwYXRoIGlzIGJlZm9yZSB0aGVcbiAqIGdpdmVuIGBtYXhgLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKiBAcHJvcGVydHkgbWF4XG4gKiBAbWVtYmVyT2YgU2NoZW1hRGF0ZU9wdGlvbnNcbiAqIEB0eXBlIHtEYXRlfVxuICogQGluc3RhbmNlXG4gKi9cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFNjaGVtYURhdGVPcHRpb25zLnByb3RvdHlwZSwgJ21heCcsIG9wdHMpO1xuXG4vKipcbiAqIElmIHNldCwgTW9uZ29vc2UgY3JlYXRlcyBhIFRUTCBpbmRleCBvbiB0aGlzIHBhdGguXG4gKlxuICogbW9uZ28gVFRMIGluZGV4IGBleHBpcmVBZnRlclNlY29uZHNgIHZhbHVlIHdpbGwgdGFrZSAnZXhwaXJlcycgdmFsdWUgZXhwcmVzc2VkIGluIHNlY29uZHMuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBjb25zdCBzY2hlbWEgPSBuZXcgU2NoZW1hKHsgXCJleHBpcmVBdFwiOiB7IHR5cGU6IERhdGUsICBleHBpcmVzOiAxMSB9IH0pO1xuICogICAgIC8vIGlmICdleHBpcmVBdCcgaXMgc2V0LCB0aGVuIGRvY3VtZW50IGV4cGlyZXMgYXQgZXhwaXJlQXQgKyAxMSBzZWNvbmRzXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqIEBwcm9wZXJ0eSBleHBpcmVzXG4gKiBAbWVtYmVyT2YgU2NoZW1hRGF0ZU9wdGlvbnNcbiAqIEB0eXBlIHtEYXRlfVxuICogQGluc3RhbmNlXG4gKi9cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFNjaGVtYURhdGVPcHRpb25zLnByb3RvdHlwZSwgJ2V4cGlyZXMnLCBvcHRzKTtcblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNjaGVtYURhdGVPcHRpb25zO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../server/node_modules/mongoose/lib/options/schemaDateOptions.js\n");

/***/ }),

/***/ "../server/node_modules/mongoose/lib/options/schemaDocumentArrayOptions.js":
/*!*********************************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/options/schemaDocumentArrayOptions.js ***!
  \*********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst SchemaTypeOptions = __webpack_require__(/*! ./schemaTypeOptions */ \"../server/node_modules/mongoose/lib/options/schemaTypeOptions.js\");\n\n/**\n * The options defined on an Document Array schematype.\n *\n * #### Example:\n *\n *     const schema = new Schema({ users: [{ name: string }] });\n *     schema.path('users').options; // SchemaDocumentArrayOptions instance\n *\n * @api public\n * @inherits SchemaTypeOptions\n * @constructor SchemaDocumentOptions\n */\n\nclass SchemaDocumentArrayOptions extends SchemaTypeOptions {}\n\nconst opts = __webpack_require__(/*! ./propertyOptions */ \"../server/node_modules/mongoose/lib/options/propertyOptions.js\");\n\n/**\n * If `true`, Mongoose will skip building any indexes defined in this array's schema.\n * If not set, Mongoose will build all indexes defined in this array's schema.\n *\n * #### Example:\n *\n *     const childSchema = Schema({ name: { type: String, index: true } });\n *     // If `excludeIndexes` is `true`, Mongoose will skip building an index\n *     // on `arr.name`. Otherwise, Mongoose will build an index on `arr.name`.\n *     const parentSchema = Schema({\n *       arr: { type: [childSchema], excludeIndexes: true }\n *     });\n *\n * @api public\n * @property excludeIndexes\n * @memberOf SchemaDocumentArrayOptions\n * @type {Array}\n * @instance\n */\n\nObject.defineProperty(SchemaDocumentArrayOptions.prototype, 'excludeIndexes', opts);\n\n/**\n * If set, overwrites the child schema's `_id` option.\n *\n * #### Example:\n *\n *     const childSchema = Schema({ name: String });\n *     const parentSchema = Schema({\n *       child: { type: childSchema, _id: false }\n *     });\n *     parentSchema.path('child').schema.options._id; // false\n *\n * @api public\n * @property _id\n * @memberOf SchemaDocumentArrayOptions\n * @type {Array}\n * @instance\n */\n\nObject.defineProperty(SchemaDocumentArrayOptions.prototype, '_id', opts);\n\n/*!\n * ignore\n */\n\nmodule.exports = SchemaDocumentArrayOptions;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvb3B0aW9ucy9zY2hlbWFEb2N1bWVudEFycmF5T3B0aW9ucy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYiwwQkFBMEIsbUJBQU8sQ0FBQyw2RkFBcUI7O0FBRXZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsVUFBVSxjQUFjLEdBQUc7QUFDOUQscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsYUFBYSxtQkFBTyxDQUFDLHlGQUFtQjs7QUFFeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLFFBQVEsNkJBQTZCO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQixRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLGNBQWM7QUFDbEQ7QUFDQSxrQkFBa0I7QUFDbEIsUUFBUTtBQUNSLHNEQUFzRDtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL2NsaWVudC8uLi9zZXJ2ZXIvbm9kZV9tb2R1bGVzL21vbmdvb3NlL2xpYi9vcHRpb25zL3NjaGVtYURvY3VtZW50QXJyYXlPcHRpb25zLmpzPzllZGYiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBTY2hlbWFUeXBlT3B0aW9ucyA9IHJlcXVpcmUoJy4vc2NoZW1hVHlwZU9wdGlvbnMnKTtcblxuLyoqXG4gKiBUaGUgb3B0aW9ucyBkZWZpbmVkIG9uIGFuIERvY3VtZW50IEFycmF5IHNjaGVtYXR5cGUuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBjb25zdCBzY2hlbWEgPSBuZXcgU2NoZW1hKHsgdXNlcnM6IFt7IG5hbWU6IHN0cmluZyB9XSB9KTtcbiAqICAgICBzY2hlbWEucGF0aCgndXNlcnMnKS5vcHRpb25zOyAvLyBTY2hlbWFEb2N1bWVudEFycmF5T3B0aW9ucyBpbnN0YW5jZVxuICpcbiAqIEBhcGkgcHVibGljXG4gKiBAaW5oZXJpdHMgU2NoZW1hVHlwZU9wdGlvbnNcbiAqIEBjb25zdHJ1Y3RvciBTY2hlbWFEb2N1bWVudE9wdGlvbnNcbiAqL1xuXG5jbGFzcyBTY2hlbWFEb2N1bWVudEFycmF5T3B0aW9ucyBleHRlbmRzIFNjaGVtYVR5cGVPcHRpb25zIHt9XG5cbmNvbnN0IG9wdHMgPSByZXF1aXJlKCcuL3Byb3BlcnR5T3B0aW9ucycpO1xuXG4vKipcbiAqIElmIGB0cnVlYCwgTW9uZ29vc2Ugd2lsbCBza2lwIGJ1aWxkaW5nIGFueSBpbmRleGVzIGRlZmluZWQgaW4gdGhpcyBhcnJheSdzIHNjaGVtYS5cbiAqIElmIG5vdCBzZXQsIE1vbmdvb3NlIHdpbGwgYnVpbGQgYWxsIGluZGV4ZXMgZGVmaW5lZCBpbiB0aGlzIGFycmF5J3Mgc2NoZW1hLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgY29uc3QgY2hpbGRTY2hlbWEgPSBTY2hlbWEoeyBuYW1lOiB7IHR5cGU6IFN0cmluZywgaW5kZXg6IHRydWUgfSB9KTtcbiAqICAgICAvLyBJZiBgZXhjbHVkZUluZGV4ZXNgIGlzIGB0cnVlYCwgTW9uZ29vc2Ugd2lsbCBza2lwIGJ1aWxkaW5nIGFuIGluZGV4XG4gKiAgICAgLy8gb24gYGFyci5uYW1lYC4gT3RoZXJ3aXNlLCBNb25nb29zZSB3aWxsIGJ1aWxkIGFuIGluZGV4IG9uIGBhcnIubmFtZWAuXG4gKiAgICAgY29uc3QgcGFyZW50U2NoZW1hID0gU2NoZW1hKHtcbiAqICAgICAgIGFycjogeyB0eXBlOiBbY2hpbGRTY2hlbWFdLCBleGNsdWRlSW5kZXhlczogdHJ1ZSB9XG4gKiAgICAgfSk7XG4gKlxuICogQGFwaSBwdWJsaWNcbiAqIEBwcm9wZXJ0eSBleGNsdWRlSW5kZXhlc1xuICogQG1lbWJlck9mIFNjaGVtYURvY3VtZW50QXJyYXlPcHRpb25zXG4gKiBAdHlwZSB7QXJyYXl9XG4gKiBAaW5zdGFuY2VcbiAqL1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoU2NoZW1hRG9jdW1lbnRBcnJheU9wdGlvbnMucHJvdG90eXBlLCAnZXhjbHVkZUluZGV4ZXMnLCBvcHRzKTtcblxuLyoqXG4gKiBJZiBzZXQsIG92ZXJ3cml0ZXMgdGhlIGNoaWxkIHNjaGVtYSdzIGBfaWRgIG9wdGlvbi5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IGNoaWxkU2NoZW1hID0gU2NoZW1hKHsgbmFtZTogU3RyaW5nIH0pO1xuICogICAgIGNvbnN0IHBhcmVudFNjaGVtYSA9IFNjaGVtYSh7XG4gKiAgICAgICBjaGlsZDogeyB0eXBlOiBjaGlsZFNjaGVtYSwgX2lkOiBmYWxzZSB9XG4gKiAgICAgfSk7XG4gKiAgICAgcGFyZW50U2NoZW1hLnBhdGgoJ2NoaWxkJykuc2NoZW1hLm9wdGlvbnMuX2lkOyAvLyBmYWxzZVxuICpcbiAqIEBhcGkgcHVibGljXG4gKiBAcHJvcGVydHkgX2lkXG4gKiBAbWVtYmVyT2YgU2NoZW1hRG9jdW1lbnRBcnJheU9wdGlvbnNcbiAqIEB0eXBlIHtBcnJheX1cbiAqIEBpbnN0YW5jZVxuICovXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShTY2hlbWFEb2N1bWVudEFycmF5T3B0aW9ucy5wcm90b3R5cGUsICdfaWQnLCBvcHRzKTtcblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNjaGVtYURvY3VtZW50QXJyYXlPcHRpb25zO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../server/node_modules/mongoose/lib/options/schemaDocumentArrayOptions.js\n");

/***/ }),

/***/ "../server/node_modules/mongoose/lib/options/schemaMapOptions.js":
/*!***********************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/options/schemaMapOptions.js ***!
  \***********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst SchemaTypeOptions = __webpack_require__(/*! ./schemaTypeOptions */ \"../server/node_modules/mongoose/lib/options/schemaTypeOptions.js\");\n\n/**\n * The options defined on a Map schematype.\n *\n * #### Example:\n *\n *     const schema = new Schema({ socialMediaHandles: { type: Map, of: String } });\n *     schema.path('socialMediaHandles').options; // SchemaMapOptions instance\n *\n * @api public\n * @inherits SchemaTypeOptions\n * @constructor SchemaMapOptions\n */\n\nclass SchemaMapOptions extends SchemaTypeOptions {}\n\nconst opts = __webpack_require__(/*! ./propertyOptions */ \"../server/node_modules/mongoose/lib/options/propertyOptions.js\");\n\n/**\n * If set, specifies the type of this map's values. Mongoose will cast\n * this map's values to the given type.\n *\n * If not set, Mongoose will not cast the map's values.\n *\n * #### Example:\n *\n *     // Mongoose will cast `socialMediaHandles` values to strings\n *     const schema = new Schema({ socialMediaHandles: { type: Map, of: String } });\n *     schema.path('socialMediaHandles').options.of; // String\n *\n * @api public\n * @property of\n * @memberOf SchemaMapOptions\n * @type {Function|string}\n * @instance\n */\n\nObject.defineProperty(SchemaMapOptions.prototype, 'of', opts);\n\nmodule.exports = SchemaMapOptions;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvb3B0aW9ucy9zY2hlbWFNYXBPcHRpb25zLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLDBCQUEwQixtQkFBTyxDQUFDLDZGQUFxQjs7QUFFdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxzQkFBc0IseUJBQXlCO0FBQ2xGLGtEQUFrRDtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLGFBQWEsbUJBQU8sQ0FBQyx5RkFBbUI7O0FBRXhDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxzQkFBc0IseUJBQXlCO0FBQ2xGLHFEQUFxRDtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2xpZW50Ly4uL3NlcnZlci9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL29wdGlvbnMvc2NoZW1hTWFwT3B0aW9ucy5qcz9hMTZlIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3QgU2NoZW1hVHlwZU9wdGlvbnMgPSByZXF1aXJlKCcuL3NjaGVtYVR5cGVPcHRpb25zJyk7XG5cbi8qKlxuICogVGhlIG9wdGlvbnMgZGVmaW5lZCBvbiBhIE1hcCBzY2hlbWF0eXBlLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgY29uc3Qgc2NoZW1hID0gbmV3IFNjaGVtYSh7IHNvY2lhbE1lZGlhSGFuZGxlczogeyB0eXBlOiBNYXAsIG9mOiBTdHJpbmcgfSB9KTtcbiAqICAgICBzY2hlbWEucGF0aCgnc29jaWFsTWVkaWFIYW5kbGVzJykub3B0aW9uczsgLy8gU2NoZW1hTWFwT3B0aW9ucyBpbnN0YW5jZVxuICpcbiAqIEBhcGkgcHVibGljXG4gKiBAaW5oZXJpdHMgU2NoZW1hVHlwZU9wdGlvbnNcbiAqIEBjb25zdHJ1Y3RvciBTY2hlbWFNYXBPcHRpb25zXG4gKi9cblxuY2xhc3MgU2NoZW1hTWFwT3B0aW9ucyBleHRlbmRzIFNjaGVtYVR5cGVPcHRpb25zIHt9XG5cbmNvbnN0IG9wdHMgPSByZXF1aXJlKCcuL3Byb3BlcnR5T3B0aW9ucycpO1xuXG4vKipcbiAqIElmIHNldCwgc3BlY2lmaWVzIHRoZSB0eXBlIG9mIHRoaXMgbWFwJ3MgdmFsdWVzLiBNb25nb29zZSB3aWxsIGNhc3RcbiAqIHRoaXMgbWFwJ3MgdmFsdWVzIHRvIHRoZSBnaXZlbiB0eXBlLlxuICpcbiAqIElmIG5vdCBzZXQsIE1vbmdvb3NlIHdpbGwgbm90IGNhc3QgdGhlIG1hcCdzIHZhbHVlcy5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIC8vIE1vbmdvb3NlIHdpbGwgY2FzdCBgc29jaWFsTWVkaWFIYW5kbGVzYCB2YWx1ZXMgdG8gc3RyaW5nc1xuICogICAgIGNvbnN0IHNjaGVtYSA9IG5ldyBTY2hlbWEoeyBzb2NpYWxNZWRpYUhhbmRsZXM6IHsgdHlwZTogTWFwLCBvZjogU3RyaW5nIH0gfSk7XG4gKiAgICAgc2NoZW1hLnBhdGgoJ3NvY2lhbE1lZGlhSGFuZGxlcycpLm9wdGlvbnMub2Y7IC8vIFN0cmluZ1xuICpcbiAqIEBhcGkgcHVibGljXG4gKiBAcHJvcGVydHkgb2ZcbiAqIEBtZW1iZXJPZiBTY2hlbWFNYXBPcHRpb25zXG4gKiBAdHlwZSB7RnVuY3Rpb258c3RyaW5nfVxuICogQGluc3RhbmNlXG4gKi9cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFNjaGVtYU1hcE9wdGlvbnMucHJvdG90eXBlLCAnb2YnLCBvcHRzKTtcblxubW9kdWxlLmV4cG9ydHMgPSBTY2hlbWFNYXBPcHRpb25zO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../server/node_modules/mongoose/lib/options/schemaMapOptions.js\n");

/***/ }),

/***/ "../server/node_modules/mongoose/lib/options/schemaNumberOptions.js":
/*!**************************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/options/schemaNumberOptions.js ***!
  \**************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst SchemaTypeOptions = __webpack_require__(/*! ./schemaTypeOptions */ \"../server/node_modules/mongoose/lib/options/schemaTypeOptions.js\");\n\n/**\n * The options defined on a Number schematype.\n *\n * #### Example:\n *\n *     const schema = new Schema({ count: Number });\n *     schema.path('count').options; // SchemaNumberOptions instance\n *\n * @api public\n * @inherits SchemaTypeOptions\n * @constructor SchemaNumberOptions\n */\n\nclass SchemaNumberOptions extends SchemaTypeOptions {}\n\nconst opts = __webpack_require__(/*! ./propertyOptions */ \"../server/node_modules/mongoose/lib/options/propertyOptions.js\");\n\n/**\n * If set, Mongoose adds a validator that checks that this path is at least the\n * given `min`.\n *\n * @api public\n * @property min\n * @memberOf SchemaNumberOptions\n * @type {Number}\n * @instance\n */\n\nObject.defineProperty(SchemaNumberOptions.prototype, 'min', opts);\n\n/**\n * If set, Mongoose adds a validator that checks that this path is less than the\n * given `max`.\n *\n * @api public\n * @property max\n * @memberOf SchemaNumberOptions\n * @type {Number}\n * @instance\n */\n\nObject.defineProperty(SchemaNumberOptions.prototype, 'max', opts);\n\n/**\n * If set, Mongoose adds a validator that checks that this path is strictly\n * equal to one of the given values.\n *\n * #### Example:\n *\n *     const schema = new Schema({\n *       favoritePrime: {\n *         type: Number,\n *         enum: [3, 5, 7]\n *       }\n *     });\n *     schema.path('favoritePrime').options.enum; // [3, 5, 7]\n *\n * @api public\n * @property enum\n * @memberOf SchemaNumberOptions\n * @type {Array}\n * @instance\n */\n\nObject.defineProperty(SchemaNumberOptions.prototype, 'enum', opts);\n\n/**\n * Sets default [populate options](https://mongoosejs.com/docs/populate.html#query-conditions).\n *\n * #### Example:\n *\n *     const schema = new Schema({\n *       child: {\n *         type: Number,\n *         ref: 'Child',\n *         populate: { select: 'name' }\n *       }\n *     });\n *     const Parent = mongoose.model('Parent', schema);\n *\n *     // Automatically adds `.select('name')`\n *     Parent.findOne().populate('child');\n *\n * @api public\n * @property populate\n * @memberOf SchemaNumberOptions\n * @type {Object}\n * @instance\n */\n\nObject.defineProperty(SchemaNumberOptions.prototype, 'populate', opts);\n\n/*!\n * ignore\n */\n\nmodule.exports = SchemaNumberOptions;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvb3B0aW9ucy9zY2hlbWFOdW1iZXJPcHRpb25zLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLDBCQUEwQixtQkFBTyxDQUFDLDZGQUFxQjs7QUFFdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxlQUFlO0FBQ2xELHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLGFBQWEsbUJBQU8sQ0FBQyx5RkFBbUI7O0FBRXhDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLGtEQUFrRDtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2xpZW50Ly4uL3NlcnZlci9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL29wdGlvbnMvc2NoZW1hTnVtYmVyT3B0aW9ucy5qcz83OTU4Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3QgU2NoZW1hVHlwZU9wdGlvbnMgPSByZXF1aXJlKCcuL3NjaGVtYVR5cGVPcHRpb25zJyk7XG5cbi8qKlxuICogVGhlIG9wdGlvbnMgZGVmaW5lZCBvbiBhIE51bWJlciBzY2hlbWF0eXBlLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgY29uc3Qgc2NoZW1hID0gbmV3IFNjaGVtYSh7IGNvdW50OiBOdW1iZXIgfSk7XG4gKiAgICAgc2NoZW1hLnBhdGgoJ2NvdW50Jykub3B0aW9uczsgLy8gU2NoZW1hTnVtYmVyT3B0aW9ucyBpbnN0YW5jZVxuICpcbiAqIEBhcGkgcHVibGljXG4gKiBAaW5oZXJpdHMgU2NoZW1hVHlwZU9wdGlvbnNcbiAqIEBjb25zdHJ1Y3RvciBTY2hlbWFOdW1iZXJPcHRpb25zXG4gKi9cblxuY2xhc3MgU2NoZW1hTnVtYmVyT3B0aW9ucyBleHRlbmRzIFNjaGVtYVR5cGVPcHRpb25zIHt9XG5cbmNvbnN0IG9wdHMgPSByZXF1aXJlKCcuL3Byb3BlcnR5T3B0aW9ucycpO1xuXG4vKipcbiAqIElmIHNldCwgTW9uZ29vc2UgYWRkcyBhIHZhbGlkYXRvciB0aGF0IGNoZWNrcyB0aGF0IHRoaXMgcGF0aCBpcyBhdCBsZWFzdCB0aGVcbiAqIGdpdmVuIGBtaW5gLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKiBAcHJvcGVydHkgbWluXG4gKiBAbWVtYmVyT2YgU2NoZW1hTnVtYmVyT3B0aW9uc1xuICogQHR5cGUge051bWJlcn1cbiAqIEBpbnN0YW5jZVxuICovXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShTY2hlbWFOdW1iZXJPcHRpb25zLnByb3RvdHlwZSwgJ21pbicsIG9wdHMpO1xuXG4vKipcbiAqIElmIHNldCwgTW9uZ29vc2UgYWRkcyBhIHZhbGlkYXRvciB0aGF0IGNoZWNrcyB0aGF0IHRoaXMgcGF0aCBpcyBsZXNzIHRoYW4gdGhlXG4gKiBnaXZlbiBgbWF4YC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICogQHByb3BlcnR5IG1heFxuICogQG1lbWJlck9mIFNjaGVtYU51bWJlck9wdGlvbnNcbiAqIEB0eXBlIHtOdW1iZXJ9XG4gKiBAaW5zdGFuY2VcbiAqL1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoU2NoZW1hTnVtYmVyT3B0aW9ucy5wcm90b3R5cGUsICdtYXgnLCBvcHRzKTtcblxuLyoqXG4gKiBJZiBzZXQsIE1vbmdvb3NlIGFkZHMgYSB2YWxpZGF0b3IgdGhhdCBjaGVja3MgdGhhdCB0aGlzIHBhdGggaXMgc3RyaWN0bHlcbiAqIGVxdWFsIHRvIG9uZSBvZiB0aGUgZ2l2ZW4gdmFsdWVzLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgY29uc3Qgc2NoZW1hID0gbmV3IFNjaGVtYSh7XG4gKiAgICAgICBmYXZvcml0ZVByaW1lOiB7XG4gKiAgICAgICAgIHR5cGU6IE51bWJlcixcbiAqICAgICAgICAgZW51bTogWzMsIDUsIDddXG4gKiAgICAgICB9XG4gKiAgICAgfSk7XG4gKiAgICAgc2NoZW1hLnBhdGgoJ2Zhdm9yaXRlUHJpbWUnKS5vcHRpb25zLmVudW07IC8vIFszLCA1LCA3XVxuICpcbiAqIEBhcGkgcHVibGljXG4gKiBAcHJvcGVydHkgZW51bVxuICogQG1lbWJlck9mIFNjaGVtYU51bWJlck9wdGlvbnNcbiAqIEB0eXBlIHtBcnJheX1cbiAqIEBpbnN0YW5jZVxuICovXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShTY2hlbWFOdW1iZXJPcHRpb25zLnByb3RvdHlwZSwgJ2VudW0nLCBvcHRzKTtcblxuLyoqXG4gKiBTZXRzIGRlZmF1bHQgW3BvcHVsYXRlIG9wdGlvbnNdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9wb3B1bGF0ZS5odG1sI3F1ZXJ5LWNvbmRpdGlvbnMpLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgY29uc3Qgc2NoZW1hID0gbmV3IFNjaGVtYSh7XG4gKiAgICAgICBjaGlsZDoge1xuICogICAgICAgICB0eXBlOiBOdW1iZXIsXG4gKiAgICAgICAgIHJlZjogJ0NoaWxkJyxcbiAqICAgICAgICAgcG9wdWxhdGU6IHsgc2VsZWN0OiAnbmFtZScgfVxuICogICAgICAgfVxuICogICAgIH0pO1xuICogICAgIGNvbnN0IFBhcmVudCA9IG1vbmdvb3NlLm1vZGVsKCdQYXJlbnQnLCBzY2hlbWEpO1xuICpcbiAqICAgICAvLyBBdXRvbWF0aWNhbGx5IGFkZHMgYC5zZWxlY3QoJ25hbWUnKWBcbiAqICAgICBQYXJlbnQuZmluZE9uZSgpLnBvcHVsYXRlKCdjaGlsZCcpO1xuICpcbiAqIEBhcGkgcHVibGljXG4gKiBAcHJvcGVydHkgcG9wdWxhdGVcbiAqIEBtZW1iZXJPZiBTY2hlbWFOdW1iZXJPcHRpb25zXG4gKiBAdHlwZSB7T2JqZWN0fVxuICogQGluc3RhbmNlXG4gKi9cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFNjaGVtYU51bWJlck9wdGlvbnMucHJvdG90eXBlLCAncG9wdWxhdGUnLCBvcHRzKTtcblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNjaGVtYU51bWJlck9wdGlvbnM7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../server/node_modules/mongoose/lib/options/schemaNumberOptions.js\n");

/***/ }),

/***/ "../server/node_modules/mongoose/lib/options/schemaObjectIdOptions.js":
/*!****************************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/options/schemaObjectIdOptions.js ***!
  \****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst SchemaTypeOptions = __webpack_require__(/*! ./schemaTypeOptions */ \"../server/node_modules/mongoose/lib/options/schemaTypeOptions.js\");\n\n/**\n * The options defined on an ObjectId schematype.\n *\n * #### Example:\n *\n *     const schema = new Schema({ testId: mongoose.ObjectId });\n *     schema.path('testId').options; // SchemaObjectIdOptions instance\n *\n * @api public\n * @inherits SchemaTypeOptions\n * @constructor SchemaObjectIdOptions\n */\n\nclass SchemaObjectIdOptions extends SchemaTypeOptions {}\n\nconst opts = __webpack_require__(/*! ./propertyOptions */ \"../server/node_modules/mongoose/lib/options/propertyOptions.js\");\n\n/**\n * If truthy, uses Mongoose's default built-in ObjectId path.\n *\n * @api public\n * @property auto\n * @memberOf SchemaObjectIdOptions\n * @type {Boolean}\n * @instance\n */\n\nObject.defineProperty(SchemaObjectIdOptions.prototype, 'auto', opts);\n\n/**\n * Sets default [populate options](https://mongoosejs.com/docs/populate.html#query-conditions).\n *\n * #### Example:\n *\n *     const schema = new Schema({\n *       child: {\n *         type: 'ObjectId',\n *         ref: 'Child',\n *         populate: { select: 'name' }\n *       }\n *     });\n *     const Parent = mongoose.model('Parent', schema);\n *\n *     // Automatically adds `.select('name')`\n *     Parent.findOne().populate('child');\n *\n * @api public\n * @property populate\n * @memberOf SchemaObjectIdOptions\n * @type {Object}\n * @instance\n */\n\nObject.defineProperty(SchemaObjectIdOptions.prototype, 'populate', opts);\n\n/*!\n * ignore\n */\n\nmodule.exports = SchemaObjectIdOptions;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvb3B0aW9ucy9zY2hlbWFPYmplY3RJZE9wdGlvbnMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsMEJBQTBCLG1CQUFPLENBQUMsNkZBQXFCOztBQUV2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLDJCQUEyQjtBQUM5RCxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxhQUFhLG1CQUFPLENBQUMseUZBQW1COztBQUV4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL2NsaWVudC8uLi9zZXJ2ZXIvbm9kZV9tb2R1bGVzL21vbmdvb3NlL2xpYi9vcHRpb25zL3NjaGVtYU9iamVjdElkT3B0aW9ucy5qcz9kZGNhIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3QgU2NoZW1hVHlwZU9wdGlvbnMgPSByZXF1aXJlKCcuL3NjaGVtYVR5cGVPcHRpb25zJyk7XG5cbi8qKlxuICogVGhlIG9wdGlvbnMgZGVmaW5lZCBvbiBhbiBPYmplY3RJZCBzY2hlbWF0eXBlLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgY29uc3Qgc2NoZW1hID0gbmV3IFNjaGVtYSh7IHRlc3RJZDogbW9uZ29vc2UuT2JqZWN0SWQgfSk7XG4gKiAgICAgc2NoZW1hLnBhdGgoJ3Rlc3RJZCcpLm9wdGlvbnM7IC8vIFNjaGVtYU9iamVjdElkT3B0aW9ucyBpbnN0YW5jZVxuICpcbiAqIEBhcGkgcHVibGljXG4gKiBAaW5oZXJpdHMgU2NoZW1hVHlwZU9wdGlvbnNcbiAqIEBjb25zdHJ1Y3RvciBTY2hlbWFPYmplY3RJZE9wdGlvbnNcbiAqL1xuXG5jbGFzcyBTY2hlbWFPYmplY3RJZE9wdGlvbnMgZXh0ZW5kcyBTY2hlbWFUeXBlT3B0aW9ucyB7fVxuXG5jb25zdCBvcHRzID0gcmVxdWlyZSgnLi9wcm9wZXJ0eU9wdGlvbnMnKTtcblxuLyoqXG4gKiBJZiB0cnV0aHksIHVzZXMgTW9uZ29vc2UncyBkZWZhdWx0IGJ1aWx0LWluIE9iamVjdElkIHBhdGguXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqIEBwcm9wZXJ0eSBhdXRvXG4gKiBAbWVtYmVyT2YgU2NoZW1hT2JqZWN0SWRPcHRpb25zXG4gKiBAdHlwZSB7Qm9vbGVhbn1cbiAqIEBpbnN0YW5jZVxuICovXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShTY2hlbWFPYmplY3RJZE9wdGlvbnMucHJvdG90eXBlLCAnYXV0bycsIG9wdHMpO1xuXG4vKipcbiAqIFNldHMgZGVmYXVsdCBbcG9wdWxhdGUgb3B0aW9uc10oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL3BvcHVsYXRlLmh0bWwjcXVlcnktY29uZGl0aW9ucykuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBjb25zdCBzY2hlbWEgPSBuZXcgU2NoZW1hKHtcbiAqICAgICAgIGNoaWxkOiB7XG4gKiAgICAgICAgIHR5cGU6ICdPYmplY3RJZCcsXG4gKiAgICAgICAgIHJlZjogJ0NoaWxkJyxcbiAqICAgICAgICAgcG9wdWxhdGU6IHsgc2VsZWN0OiAnbmFtZScgfVxuICogICAgICAgfVxuICogICAgIH0pO1xuICogICAgIGNvbnN0IFBhcmVudCA9IG1vbmdvb3NlLm1vZGVsKCdQYXJlbnQnLCBzY2hlbWEpO1xuICpcbiAqICAgICAvLyBBdXRvbWF0aWNhbGx5IGFkZHMgYC5zZWxlY3QoJ25hbWUnKWBcbiAqICAgICBQYXJlbnQuZmluZE9uZSgpLnBvcHVsYXRlKCdjaGlsZCcpO1xuICpcbiAqIEBhcGkgcHVibGljXG4gKiBAcHJvcGVydHkgcG9wdWxhdGVcbiAqIEBtZW1iZXJPZiBTY2hlbWFPYmplY3RJZE9wdGlvbnNcbiAqIEB0eXBlIHtPYmplY3R9XG4gKiBAaW5zdGFuY2VcbiAqL1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoU2NoZW1hT2JqZWN0SWRPcHRpb25zLnByb3RvdHlwZSwgJ3BvcHVsYXRlJywgb3B0cyk7XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBTY2hlbWFPYmplY3RJZE9wdGlvbnM7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../server/node_modules/mongoose/lib/options/schemaObjectIdOptions.js\n");

/***/ }),

/***/ "../server/node_modules/mongoose/lib/options/schemaStringOptions.js":
/*!**************************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/options/schemaStringOptions.js ***!
  \**************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst SchemaTypeOptions = __webpack_require__(/*! ./schemaTypeOptions */ \"../server/node_modules/mongoose/lib/options/schemaTypeOptions.js\");\n\n/**\n * The options defined on a string schematype.\n *\n * #### Example:\n *\n *     const schema = new Schema({ name: String });\n *     schema.path('name').options; // SchemaStringOptions instance\n *\n * @api public\n * @inherits SchemaTypeOptions\n * @constructor SchemaStringOptions\n */\n\nclass SchemaStringOptions extends SchemaTypeOptions {}\n\nconst opts = __webpack_require__(/*! ./propertyOptions */ \"../server/node_modules/mongoose/lib/options/propertyOptions.js\");\n\n/**\n * Array of allowed values for this path\n *\n * @api public\n * @property enum\n * @memberOf SchemaStringOptions\n * @type {Array}\n * @instance\n */\n\nObject.defineProperty(SchemaStringOptions.prototype, 'enum', opts);\n\n/**\n * Attach a validator that succeeds if the data string matches the given regular\n * expression, and fails otherwise.\n *\n * @api public\n * @property match\n * @memberOf SchemaStringOptions\n * @type {RegExp}\n * @instance\n */\n\nObject.defineProperty(SchemaStringOptions.prototype, 'match', opts);\n\n/**\n * If truthy, Mongoose will add a custom setter that lowercases this string\n * using JavaScript's built-in `String#toLowerCase()`.\n *\n * @api public\n * @property lowercase\n * @memberOf SchemaStringOptions\n * @type {Boolean}\n * @instance\n */\n\nObject.defineProperty(SchemaStringOptions.prototype, 'lowercase', opts);\n\n/**\n * If truthy, Mongoose will add a custom setter that removes leading and trailing\n * whitespace using [JavaScript's built-in `String#trim()`](https://masteringjs.io/tutorials/fundamentals/trim-string).\n *\n * @api public\n * @property trim\n * @memberOf SchemaStringOptions\n * @type {Boolean}\n * @instance\n */\n\nObject.defineProperty(SchemaStringOptions.prototype, 'trim', opts);\n\n/**\n * If truthy, Mongoose will add a custom setter that uppercases this string\n * using JavaScript's built-in [`String#toUpperCase()`](https://masteringjs.io/tutorials/fundamentals/uppercase).\n *\n * @api public\n * @property uppercase\n * @memberOf SchemaStringOptions\n * @type {Boolean}\n * @instance\n */\n\nObject.defineProperty(SchemaStringOptions.prototype, 'uppercase', opts);\n\n/**\n * If set, Mongoose will add a custom validator that ensures the given\n * string's `length` is at least the given number.\n *\n * Mongoose supports two different spellings for this option: `minLength` and `minlength`.\n * `minLength` is the recommended way to specify this option, but Mongoose also supports\n * `minlength` (lowercase \"l\").\n *\n * @api public\n * @property minLength\n * @memberOf SchemaStringOptions\n * @type {Number}\n * @instance\n */\n\nObject.defineProperty(SchemaStringOptions.prototype, 'minLength', opts);\nObject.defineProperty(SchemaStringOptions.prototype, 'minlength', opts);\n\n/**\n * If set, Mongoose will add a custom validator that ensures the given\n * string's `length` is at most the given number.\n *\n * Mongoose supports two different spellings for this option: `maxLength` and `maxlength`.\n * `maxLength` is the recommended way to specify this option, but Mongoose also supports\n * `maxlength` (lowercase \"l\").\n *\n * @api public\n * @property maxLength\n * @memberOf SchemaStringOptions\n * @type {Number}\n * @instance\n */\n\nObject.defineProperty(SchemaStringOptions.prototype, 'maxLength', opts);\nObject.defineProperty(SchemaStringOptions.prototype, 'maxlength', opts);\n\n/**\n * Sets default [populate options](https://mongoosejs.com/docs/populate.html#query-conditions).\n *\n * @api public\n * @property populate\n * @memberOf SchemaStringOptions\n * @type {Object}\n * @instance\n */\n\nObject.defineProperty(SchemaStringOptions.prototype, 'populate', opts);\n\n/*!\n * ignore\n */\n\nmodule.exports = SchemaStringOptions;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvb3B0aW9ucy9zY2hlbWFTdHJpbmdPcHRpb25zLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLDBCQUEwQixtQkFBTyxDQUFDLDZGQUFxQjs7QUFFdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxjQUFjO0FBQ2pELG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLGFBQWEsbUJBQU8sQ0FBQyx5RkFBbUI7O0FBRXhDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2xpZW50Ly4uL3NlcnZlci9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL29wdGlvbnMvc2NoZW1hU3RyaW5nT3B0aW9ucy5qcz8wYzEyIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3QgU2NoZW1hVHlwZU9wdGlvbnMgPSByZXF1aXJlKCcuL3NjaGVtYVR5cGVPcHRpb25zJyk7XG5cbi8qKlxuICogVGhlIG9wdGlvbnMgZGVmaW5lZCBvbiBhIHN0cmluZyBzY2hlbWF0eXBlLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgY29uc3Qgc2NoZW1hID0gbmV3IFNjaGVtYSh7IG5hbWU6IFN0cmluZyB9KTtcbiAqICAgICBzY2hlbWEucGF0aCgnbmFtZScpLm9wdGlvbnM7IC8vIFNjaGVtYVN0cmluZ09wdGlvbnMgaW5zdGFuY2VcbiAqXG4gKiBAYXBpIHB1YmxpY1xuICogQGluaGVyaXRzIFNjaGVtYVR5cGVPcHRpb25zXG4gKiBAY29uc3RydWN0b3IgU2NoZW1hU3RyaW5nT3B0aW9uc1xuICovXG5cbmNsYXNzIFNjaGVtYVN0cmluZ09wdGlvbnMgZXh0ZW5kcyBTY2hlbWFUeXBlT3B0aW9ucyB7fVxuXG5jb25zdCBvcHRzID0gcmVxdWlyZSgnLi9wcm9wZXJ0eU9wdGlvbnMnKTtcblxuLyoqXG4gKiBBcnJheSBvZiBhbGxvd2VkIHZhbHVlcyBmb3IgdGhpcyBwYXRoXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqIEBwcm9wZXJ0eSBlbnVtXG4gKiBAbWVtYmVyT2YgU2NoZW1hU3RyaW5nT3B0aW9uc1xuICogQHR5cGUge0FycmF5fVxuICogQGluc3RhbmNlXG4gKi9cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFNjaGVtYVN0cmluZ09wdGlvbnMucHJvdG90eXBlLCAnZW51bScsIG9wdHMpO1xuXG4vKipcbiAqIEF0dGFjaCBhIHZhbGlkYXRvciB0aGF0IHN1Y2NlZWRzIGlmIHRoZSBkYXRhIHN0cmluZyBtYXRjaGVzIHRoZSBnaXZlbiByZWd1bGFyXG4gKiBleHByZXNzaW9uLCBhbmQgZmFpbHMgb3RoZXJ3aXNlLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKiBAcHJvcGVydHkgbWF0Y2hcbiAqIEBtZW1iZXJPZiBTY2hlbWFTdHJpbmdPcHRpb25zXG4gKiBAdHlwZSB7UmVnRXhwfVxuICogQGluc3RhbmNlXG4gKi9cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFNjaGVtYVN0cmluZ09wdGlvbnMucHJvdG90eXBlLCAnbWF0Y2gnLCBvcHRzKTtcblxuLyoqXG4gKiBJZiB0cnV0aHksIE1vbmdvb3NlIHdpbGwgYWRkIGEgY3VzdG9tIHNldHRlciB0aGF0IGxvd2VyY2FzZXMgdGhpcyBzdHJpbmdcbiAqIHVzaW5nIEphdmFTY3JpcHQncyBidWlsdC1pbiBgU3RyaW5nI3RvTG93ZXJDYXNlKClgLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKiBAcHJvcGVydHkgbG93ZXJjYXNlXG4gKiBAbWVtYmVyT2YgU2NoZW1hU3RyaW5nT3B0aW9uc1xuICogQHR5cGUge0Jvb2xlYW59XG4gKiBAaW5zdGFuY2VcbiAqL1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoU2NoZW1hU3RyaW5nT3B0aW9ucy5wcm90b3R5cGUsICdsb3dlcmNhc2UnLCBvcHRzKTtcblxuLyoqXG4gKiBJZiB0cnV0aHksIE1vbmdvb3NlIHdpbGwgYWRkIGEgY3VzdG9tIHNldHRlciB0aGF0IHJlbW92ZXMgbGVhZGluZyBhbmQgdHJhaWxpbmdcbiAqIHdoaXRlc3BhY2UgdXNpbmcgW0phdmFTY3JpcHQncyBidWlsdC1pbiBgU3RyaW5nI3RyaW0oKWBdKGh0dHBzOi8vbWFzdGVyaW5nanMuaW8vdHV0b3JpYWxzL2Z1bmRhbWVudGFscy90cmltLXN0cmluZykuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqIEBwcm9wZXJ0eSB0cmltXG4gKiBAbWVtYmVyT2YgU2NoZW1hU3RyaW5nT3B0aW9uc1xuICogQHR5cGUge0Jvb2xlYW59XG4gKiBAaW5zdGFuY2VcbiAqL1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoU2NoZW1hU3RyaW5nT3B0aW9ucy5wcm90b3R5cGUsICd0cmltJywgb3B0cyk7XG5cbi8qKlxuICogSWYgdHJ1dGh5LCBNb25nb29zZSB3aWxsIGFkZCBhIGN1c3RvbSBzZXR0ZXIgdGhhdCB1cHBlcmNhc2VzIHRoaXMgc3RyaW5nXG4gKiB1c2luZyBKYXZhU2NyaXB0J3MgYnVpbHQtaW4gW2BTdHJpbmcjdG9VcHBlckNhc2UoKWBdKGh0dHBzOi8vbWFzdGVyaW5nanMuaW8vdHV0b3JpYWxzL2Z1bmRhbWVudGFscy91cHBlcmNhc2UpLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKiBAcHJvcGVydHkgdXBwZXJjYXNlXG4gKiBAbWVtYmVyT2YgU2NoZW1hU3RyaW5nT3B0aW9uc1xuICogQHR5cGUge0Jvb2xlYW59XG4gKiBAaW5zdGFuY2VcbiAqL1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoU2NoZW1hU3RyaW5nT3B0aW9ucy5wcm90b3R5cGUsICd1cHBlcmNhc2UnLCBvcHRzKTtcblxuLyoqXG4gKiBJZiBzZXQsIE1vbmdvb3NlIHdpbGwgYWRkIGEgY3VzdG9tIHZhbGlkYXRvciB0aGF0IGVuc3VyZXMgdGhlIGdpdmVuXG4gKiBzdHJpbmcncyBgbGVuZ3RoYCBpcyBhdCBsZWFzdCB0aGUgZ2l2ZW4gbnVtYmVyLlxuICpcbiAqIE1vbmdvb3NlIHN1cHBvcnRzIHR3byBkaWZmZXJlbnQgc3BlbGxpbmdzIGZvciB0aGlzIG9wdGlvbjogYG1pbkxlbmd0aGAgYW5kIGBtaW5sZW5ndGhgLlxuICogYG1pbkxlbmd0aGAgaXMgdGhlIHJlY29tbWVuZGVkIHdheSB0byBzcGVjaWZ5IHRoaXMgb3B0aW9uLCBidXQgTW9uZ29vc2UgYWxzbyBzdXBwb3J0c1xuICogYG1pbmxlbmd0aGAgKGxvd2VyY2FzZSBcImxcIikuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqIEBwcm9wZXJ0eSBtaW5MZW5ndGhcbiAqIEBtZW1iZXJPZiBTY2hlbWFTdHJpbmdPcHRpb25zXG4gKiBAdHlwZSB7TnVtYmVyfVxuICogQGluc3RhbmNlXG4gKi9cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFNjaGVtYVN0cmluZ09wdGlvbnMucHJvdG90eXBlLCAnbWluTGVuZ3RoJywgb3B0cyk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoU2NoZW1hU3RyaW5nT3B0aW9ucy5wcm90b3R5cGUsICdtaW5sZW5ndGgnLCBvcHRzKTtcblxuLyoqXG4gKiBJZiBzZXQsIE1vbmdvb3NlIHdpbGwgYWRkIGEgY3VzdG9tIHZhbGlkYXRvciB0aGF0IGVuc3VyZXMgdGhlIGdpdmVuXG4gKiBzdHJpbmcncyBgbGVuZ3RoYCBpcyBhdCBtb3N0IHRoZSBnaXZlbiBudW1iZXIuXG4gKlxuICogTW9uZ29vc2Ugc3VwcG9ydHMgdHdvIGRpZmZlcmVudCBzcGVsbGluZ3MgZm9yIHRoaXMgb3B0aW9uOiBgbWF4TGVuZ3RoYCBhbmQgYG1heGxlbmd0aGAuXG4gKiBgbWF4TGVuZ3RoYCBpcyB0aGUgcmVjb21tZW5kZWQgd2F5IHRvIHNwZWNpZnkgdGhpcyBvcHRpb24sIGJ1dCBNb25nb29zZSBhbHNvIHN1cHBvcnRzXG4gKiBgbWF4bGVuZ3RoYCAobG93ZXJjYXNlIFwibFwiKS5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICogQHByb3BlcnR5IG1heExlbmd0aFxuICogQG1lbWJlck9mIFNjaGVtYVN0cmluZ09wdGlvbnNcbiAqIEB0eXBlIHtOdW1iZXJ9XG4gKiBAaW5zdGFuY2VcbiAqL1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoU2NoZW1hU3RyaW5nT3B0aW9ucy5wcm90b3R5cGUsICdtYXhMZW5ndGgnLCBvcHRzKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShTY2hlbWFTdHJpbmdPcHRpb25zLnByb3RvdHlwZSwgJ21heGxlbmd0aCcsIG9wdHMpO1xuXG4vKipcbiAqIFNldHMgZGVmYXVsdCBbcG9wdWxhdGUgb3B0aW9uc10oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL3BvcHVsYXRlLmh0bWwjcXVlcnktY29uZGl0aW9ucykuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqIEBwcm9wZXJ0eSBwb3B1bGF0ZVxuICogQG1lbWJlck9mIFNjaGVtYVN0cmluZ09wdGlvbnNcbiAqIEB0eXBlIHtPYmplY3R9XG4gKiBAaW5zdGFuY2VcbiAqL1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoU2NoZW1hU3RyaW5nT3B0aW9ucy5wcm90b3R5cGUsICdwb3B1bGF0ZScsIG9wdHMpO1xuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gU2NoZW1hU3RyaW5nT3B0aW9ucztcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../server/node_modules/mongoose/lib/options/schemaStringOptions.js\n");

/***/ }),

/***/ "../server/node_modules/mongoose/lib/options/schemaSubdocumentOptions.js":
/*!*******************************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/options/schemaSubdocumentOptions.js ***!
  \*******************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst SchemaTypeOptions = __webpack_require__(/*! ./schemaTypeOptions */ \"../server/node_modules/mongoose/lib/options/schemaTypeOptions.js\");\n\n/**\n * The options defined on a single nested schematype.\n *\n * #### Example:\n *\n *     const schema = Schema({ child: Schema({ name: String }) });\n *     schema.path('child').options; // SchemaSubdocumentOptions instance\n *\n * @api public\n * @inherits SchemaTypeOptions\n * @constructor SchemaSubdocumentOptions\n */\n\nclass SchemaSubdocumentOptions extends SchemaTypeOptions {}\n\nconst opts = __webpack_require__(/*! ./propertyOptions */ \"../server/node_modules/mongoose/lib/options/propertyOptions.js\");\n\n/**\n * If set, overwrites the child schema's `_id` option.\n *\n * #### Example:\n *\n *     const childSchema = Schema({ name: String });\n *     const parentSchema = Schema({\n *       child: { type: childSchema, _id: false }\n *     });\n *     parentSchema.path('child').schema.options._id; // false\n *\n * @api public\n * @property of\n * @memberOf SchemaSubdocumentOptions\n * @type {Function|string}\n * @instance\n */\n\nObject.defineProperty(SchemaSubdocumentOptions.prototype, '_id', opts);\n\nmodule.exports = SchemaSubdocumentOptions;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvb3B0aW9ucy9zY2hlbWFTdWJkb2N1bWVudE9wdGlvbnMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsMEJBQTBCLG1CQUFPLENBQUMsNkZBQXFCOztBQUV2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLGdCQUFnQixjQUFjLEdBQUc7QUFDaEUscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsYUFBYSxtQkFBTyxDQUFDLHlGQUFtQjs7QUFFeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxjQUFjO0FBQ2xEO0FBQ0Esa0JBQWtCO0FBQ2xCLFFBQVE7QUFDUixzREFBc0Q7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL2NsaWVudC8uLi9zZXJ2ZXIvbm9kZV9tb2R1bGVzL21vbmdvb3NlL2xpYi9vcHRpb25zL3NjaGVtYVN1YmRvY3VtZW50T3B0aW9ucy5qcz85MzkwIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3QgU2NoZW1hVHlwZU9wdGlvbnMgPSByZXF1aXJlKCcuL3NjaGVtYVR5cGVPcHRpb25zJyk7XG5cbi8qKlxuICogVGhlIG9wdGlvbnMgZGVmaW5lZCBvbiBhIHNpbmdsZSBuZXN0ZWQgc2NoZW1hdHlwZS5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IHNjaGVtYSA9IFNjaGVtYSh7IGNoaWxkOiBTY2hlbWEoeyBuYW1lOiBTdHJpbmcgfSkgfSk7XG4gKiAgICAgc2NoZW1hLnBhdGgoJ2NoaWxkJykub3B0aW9uczsgLy8gU2NoZW1hU3ViZG9jdW1lbnRPcHRpb25zIGluc3RhbmNlXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqIEBpbmhlcml0cyBTY2hlbWFUeXBlT3B0aW9uc1xuICogQGNvbnN0cnVjdG9yIFNjaGVtYVN1YmRvY3VtZW50T3B0aW9uc1xuICovXG5cbmNsYXNzIFNjaGVtYVN1YmRvY3VtZW50T3B0aW9ucyBleHRlbmRzIFNjaGVtYVR5cGVPcHRpb25zIHt9XG5cbmNvbnN0IG9wdHMgPSByZXF1aXJlKCcuL3Byb3BlcnR5T3B0aW9ucycpO1xuXG4vKipcbiAqIElmIHNldCwgb3ZlcndyaXRlcyB0aGUgY2hpbGQgc2NoZW1hJ3MgYF9pZGAgb3B0aW9uLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgY29uc3QgY2hpbGRTY2hlbWEgPSBTY2hlbWEoeyBuYW1lOiBTdHJpbmcgfSk7XG4gKiAgICAgY29uc3QgcGFyZW50U2NoZW1hID0gU2NoZW1hKHtcbiAqICAgICAgIGNoaWxkOiB7IHR5cGU6IGNoaWxkU2NoZW1hLCBfaWQ6IGZhbHNlIH1cbiAqICAgICB9KTtcbiAqICAgICBwYXJlbnRTY2hlbWEucGF0aCgnY2hpbGQnKS5zY2hlbWEub3B0aW9ucy5faWQ7IC8vIGZhbHNlXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqIEBwcm9wZXJ0eSBvZlxuICogQG1lbWJlck9mIFNjaGVtYVN1YmRvY3VtZW50T3B0aW9uc1xuICogQHR5cGUge0Z1bmN0aW9ufHN0cmluZ31cbiAqIEBpbnN0YW5jZVxuICovXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShTY2hlbWFTdWJkb2N1bWVudE9wdGlvbnMucHJvdG90eXBlLCAnX2lkJywgb3B0cyk7XG5cbm1vZHVsZS5leHBvcnRzID0gU2NoZW1hU3ViZG9jdW1lbnRPcHRpb25zO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../server/node_modules/mongoose/lib/options/schemaSubdocumentOptions.js\n");

/***/ }),

/***/ "../server/node_modules/mongoose/lib/options/schemaTypeOptions.js":
/*!************************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/options/schemaTypeOptions.js ***!
  \************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst clone = __webpack_require__(/*! ../helpers/clone */ \"../server/node_modules/mongoose/lib/helpers/clone.js\");\n\n/**\n * The options defined on a schematype.\n *\n * #### Example:\n *\n *     const schema = new Schema({ name: String });\n *     schema.path('name').options instanceof mongoose.SchemaTypeOptions; // true\n *\n * @api public\n * @constructor SchemaTypeOptions\n */\n\nclass SchemaTypeOptions {\n  constructor(obj) {\n    if (obj == null) {\n      return this;\n    }\n    Object.assign(this, clone(obj));\n  }\n}\n\nconst opts = __webpack_require__(/*! ./propertyOptions */ \"../server/node_modules/mongoose/lib/options/propertyOptions.js\");\n\n/**\n * The type to cast this path to.\n *\n * @api public\n * @property type\n * @memberOf SchemaTypeOptions\n * @type {Function|String|Object}\n * @instance\n */\n\nObject.defineProperty(SchemaTypeOptions.prototype, 'type', opts);\n\n/**\n * Function or object describing how to validate this schematype.\n *\n * @api public\n * @property validate\n * @memberOf SchemaTypeOptions\n * @type {Function|Object}\n * @instance\n */\n\nObject.defineProperty(SchemaTypeOptions.prototype, 'validate', opts);\n\n/**\n * Allows overriding casting logic for this individual path. If a string, the\n * given string overwrites Mongoose's default cast error message.\n *\n * #### Example:\n *\n *     const schema = new Schema({\n *       num: {\n *         type: Number,\n *         cast: '{VALUE} is not a valid number'\n *       }\n *     });\n *\n *     // Throws 'CastError: \"bad\" is not a valid number'\n *     schema.path('num').cast('bad');\n *\n *     const Model = mongoose.model('Test', schema);\n *     const doc = new Model({ num: 'fail' });\n *     const err = doc.validateSync();\n *\n *     err.errors['num']; // 'CastError: \"fail\" is not a valid number'\n *\n * @api public\n * @property cast\n * @memberOf SchemaTypeOptions\n * @type {String}\n * @instance\n */\n\nObject.defineProperty(SchemaTypeOptions.prototype, 'cast', opts);\n\n/**\n * If true, attach a required validator to this path, which ensures this path\n * cannot be set to a nullish value. If a function, Mongoose calls the\n * function and only checks for nullish values if the function returns a truthy value.\n *\n * @api public\n * @property required\n * @memberOf SchemaTypeOptions\n * @type {Function|Boolean}\n * @instance\n */\n\nObject.defineProperty(SchemaTypeOptions.prototype, 'required', opts);\n\n/**\n * The default value for this path. If a function, Mongoose executes the function\n * and uses the return value as the default.\n *\n * @api public\n * @property default\n * @memberOf SchemaTypeOptions\n * @type {Function|Any}\n * @instance\n */\n\nObject.defineProperty(SchemaTypeOptions.prototype, 'default', opts);\n\n/**\n * The model that `populate()` should use if populating this path.\n *\n * @api public\n * @property ref\n * @memberOf SchemaTypeOptions\n * @type {Function|String}\n * @instance\n */\n\nObject.defineProperty(SchemaTypeOptions.prototype, 'ref', opts);\n\n/**\n * The path in the document that `populate()` should use to find the model\n * to use.\n *\n * @api public\n * @property ref\n * @memberOf SchemaTypeOptions\n * @type {Function|String}\n * @instance\n */\n\nObject.defineProperty(SchemaTypeOptions.prototype, 'refPath', opts);\n\n/**\n * Whether to include or exclude this path by default when loading documents\n * using `find()`, `findOne()`, etc.\n *\n * @api public\n * @property select\n * @memberOf SchemaTypeOptions\n * @type {Boolean|Number}\n * @instance\n */\n\nObject.defineProperty(SchemaTypeOptions.prototype, 'select', opts);\n\n/**\n * If [truthy](https://masteringjs.io/tutorials/fundamentals/truthy), Mongoose will\n * build an index on this path when the model is compiled.\n *\n * @api public\n * @property index\n * @memberOf SchemaTypeOptions\n * @type {Boolean|Number|Object}\n * @instance\n */\n\nObject.defineProperty(SchemaTypeOptions.prototype, 'index', opts);\n\n/**\n * If [truthy](https://masteringjs.io/tutorials/fundamentals/truthy), Mongoose\n * will build a unique index on this path when the\n * model is compiled. [The `unique` option is **not** a validator](https://mongoosejs.com/docs/validation.html#the-unique-option-is-not-a-validator).\n *\n * @api public\n * @property unique\n * @memberOf SchemaTypeOptions\n * @type {Boolean|Number}\n * @instance\n */\n\nObject.defineProperty(SchemaTypeOptions.prototype, 'unique', opts);\n\n/**\n * If [truthy](https://masteringjs.io/tutorials/fundamentals/truthy), Mongoose will\n * disallow changes to this path once the document\n * is saved to the database for the first time. Read more about [immutability in Mongoose here](https://thecodebarbarian.com/whats-new-in-mongoose-5-6-immutable-properties.html).\n *\n * @api public\n * @property immutable\n * @memberOf SchemaTypeOptions\n * @type {Function|Boolean}\n * @instance\n */\n\nObject.defineProperty(SchemaTypeOptions.prototype, 'immutable', opts);\n\n/**\n * If [truthy](https://masteringjs.io/tutorials/fundamentals/truthy), Mongoose will\n * build a sparse index on this path.\n *\n * @api public\n * @property sparse\n * @memberOf SchemaTypeOptions\n * @type {Boolean|Number}\n * @instance\n */\n\nObject.defineProperty(SchemaTypeOptions.prototype, 'sparse', opts);\n\n/**\n * If [truthy](https://masteringjs.io/tutorials/fundamentals/truthy), Mongoose\n * will build a text index on this path.\n *\n * @api public\n * @property text\n * @memberOf SchemaTypeOptions\n * @type {Boolean|Number|Object}\n * @instance\n */\n\nObject.defineProperty(SchemaTypeOptions.prototype, 'text', opts);\n\n/**\n * Define a transform function for this individual schema type.\n * Only called when calling `toJSON()` or `toObject()`.\n *\n * #### Example:\n *\n *     const schema = Schema({\n *       myDate: {\n *         type: Date,\n *         transform: v => v.getFullYear()\n *       }\n *     });\n *     const Model = mongoose.model('Test', schema);\n *\n *     const doc = new Model({ myDate: new Date('2019/06/01') });\n *     doc.myDate instanceof Date; // true\n *\n *     const res = doc.toObject({ transform: true });\n *     res.myDate; // 2019\n *\n * @api public\n * @property transform\n * @memberOf SchemaTypeOptions\n * @type {Function}\n * @instance\n */\n\nObject.defineProperty(SchemaTypeOptions.prototype, 'transform', opts);\n\nmodule.exports = SchemaTypeOptions;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvb3B0aW9ucy9zY2hlbWFUeXBlT3B0aW9ucy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixjQUFjLG1CQUFPLENBQUMsOEVBQWtCOztBQUV4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLGNBQWM7QUFDakQsMEVBQTBFO0FBQzFFO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsYUFBYSxtQkFBTyxDQUFDLHlGQUFtQjs7QUFFeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLE9BQU87QUFDMUI7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixhQUFhO0FBQzVDO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSwrQkFBK0IsZ0NBQWdDO0FBQy9ELG1DQUFtQztBQUNuQztBQUNBLGtDQUFrQyxpQkFBaUI7QUFDbkQsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbGllbnQvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvb3B0aW9ucy9zY2hlbWFUeXBlT3B0aW9ucy5qcz8xZTA2Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3QgY2xvbmUgPSByZXF1aXJlKCcuLi9oZWxwZXJzL2Nsb25lJyk7XG5cbi8qKlxuICogVGhlIG9wdGlvbnMgZGVmaW5lZCBvbiBhIHNjaGVtYXR5cGUuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBjb25zdCBzY2hlbWEgPSBuZXcgU2NoZW1hKHsgbmFtZTogU3RyaW5nIH0pO1xuICogICAgIHNjaGVtYS5wYXRoKCduYW1lJykub3B0aW9ucyBpbnN0YW5jZW9mIG1vbmdvb3NlLlNjaGVtYVR5cGVPcHRpb25zOyAvLyB0cnVlXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqIEBjb25zdHJ1Y3RvciBTY2hlbWFUeXBlT3B0aW9uc1xuICovXG5cbmNsYXNzIFNjaGVtYVR5cGVPcHRpb25zIHtcbiAgY29uc3RydWN0b3Iob2JqKSB7XG4gICAgaWYgKG9iaiA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgT2JqZWN0LmFzc2lnbih0aGlzLCBjbG9uZShvYmopKTtcbiAgfVxufVxuXG5jb25zdCBvcHRzID0gcmVxdWlyZSgnLi9wcm9wZXJ0eU9wdGlvbnMnKTtcblxuLyoqXG4gKiBUaGUgdHlwZSB0byBjYXN0IHRoaXMgcGF0aCB0by5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICogQHByb3BlcnR5IHR5cGVcbiAqIEBtZW1iZXJPZiBTY2hlbWFUeXBlT3B0aW9uc1xuICogQHR5cGUge0Z1bmN0aW9ufFN0cmluZ3xPYmplY3R9XG4gKiBAaW5zdGFuY2VcbiAqL1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoU2NoZW1hVHlwZU9wdGlvbnMucHJvdG90eXBlLCAndHlwZScsIG9wdHMpO1xuXG4vKipcbiAqIEZ1bmN0aW9uIG9yIG9iamVjdCBkZXNjcmliaW5nIGhvdyB0byB2YWxpZGF0ZSB0aGlzIHNjaGVtYXR5cGUuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqIEBwcm9wZXJ0eSB2YWxpZGF0ZVxuICogQG1lbWJlck9mIFNjaGVtYVR5cGVPcHRpb25zXG4gKiBAdHlwZSB7RnVuY3Rpb258T2JqZWN0fVxuICogQGluc3RhbmNlXG4gKi9cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFNjaGVtYVR5cGVPcHRpb25zLnByb3RvdHlwZSwgJ3ZhbGlkYXRlJywgb3B0cyk7XG5cbi8qKlxuICogQWxsb3dzIG92ZXJyaWRpbmcgY2FzdGluZyBsb2dpYyBmb3IgdGhpcyBpbmRpdmlkdWFsIHBhdGguIElmIGEgc3RyaW5nLCB0aGVcbiAqIGdpdmVuIHN0cmluZyBvdmVyd3JpdGVzIE1vbmdvb3NlJ3MgZGVmYXVsdCBjYXN0IGVycm9yIG1lc3NhZ2UuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBjb25zdCBzY2hlbWEgPSBuZXcgU2NoZW1hKHtcbiAqICAgICAgIG51bToge1xuICogICAgICAgICB0eXBlOiBOdW1iZXIsXG4gKiAgICAgICAgIGNhc3Q6ICd7VkFMVUV9IGlzIG5vdCBhIHZhbGlkIG51bWJlcidcbiAqICAgICAgIH1cbiAqICAgICB9KTtcbiAqXG4gKiAgICAgLy8gVGhyb3dzICdDYXN0RXJyb3I6IFwiYmFkXCIgaXMgbm90IGEgdmFsaWQgbnVtYmVyJ1xuICogICAgIHNjaGVtYS5wYXRoKCdudW0nKS5jYXN0KCdiYWQnKTtcbiAqXG4gKiAgICAgY29uc3QgTW9kZWwgPSBtb25nb29zZS5tb2RlbCgnVGVzdCcsIHNjaGVtYSk7XG4gKiAgICAgY29uc3QgZG9jID0gbmV3IE1vZGVsKHsgbnVtOiAnZmFpbCcgfSk7XG4gKiAgICAgY29uc3QgZXJyID0gZG9jLnZhbGlkYXRlU3luYygpO1xuICpcbiAqICAgICBlcnIuZXJyb3JzWydudW0nXTsgLy8gJ0Nhc3RFcnJvcjogXCJmYWlsXCIgaXMgbm90IGEgdmFsaWQgbnVtYmVyJ1xuICpcbiAqIEBhcGkgcHVibGljXG4gKiBAcHJvcGVydHkgY2FzdFxuICogQG1lbWJlck9mIFNjaGVtYVR5cGVPcHRpb25zXG4gKiBAdHlwZSB7U3RyaW5nfVxuICogQGluc3RhbmNlXG4gKi9cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFNjaGVtYVR5cGVPcHRpb25zLnByb3RvdHlwZSwgJ2Nhc3QnLCBvcHRzKTtcblxuLyoqXG4gKiBJZiB0cnVlLCBhdHRhY2ggYSByZXF1aXJlZCB2YWxpZGF0b3IgdG8gdGhpcyBwYXRoLCB3aGljaCBlbnN1cmVzIHRoaXMgcGF0aFxuICogY2Fubm90IGJlIHNldCB0byBhIG51bGxpc2ggdmFsdWUuIElmIGEgZnVuY3Rpb24sIE1vbmdvb3NlIGNhbGxzIHRoZVxuICogZnVuY3Rpb24gYW5kIG9ubHkgY2hlY2tzIGZvciBudWxsaXNoIHZhbHVlcyBpZiB0aGUgZnVuY3Rpb24gcmV0dXJucyBhIHRydXRoeSB2YWx1ZS5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICogQHByb3BlcnR5IHJlcXVpcmVkXG4gKiBAbWVtYmVyT2YgU2NoZW1hVHlwZU9wdGlvbnNcbiAqIEB0eXBlIHtGdW5jdGlvbnxCb29sZWFufVxuICogQGluc3RhbmNlXG4gKi9cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFNjaGVtYVR5cGVPcHRpb25zLnByb3RvdHlwZSwgJ3JlcXVpcmVkJywgb3B0cyk7XG5cbi8qKlxuICogVGhlIGRlZmF1bHQgdmFsdWUgZm9yIHRoaXMgcGF0aC4gSWYgYSBmdW5jdGlvbiwgTW9uZ29vc2UgZXhlY3V0ZXMgdGhlIGZ1bmN0aW9uXG4gKiBhbmQgdXNlcyB0aGUgcmV0dXJuIHZhbHVlIGFzIHRoZSBkZWZhdWx0LlxuICpcbiAqIEBhcGkgcHVibGljXG4gKiBAcHJvcGVydHkgZGVmYXVsdFxuICogQG1lbWJlck9mIFNjaGVtYVR5cGVPcHRpb25zXG4gKiBAdHlwZSB7RnVuY3Rpb258QW55fVxuICogQGluc3RhbmNlXG4gKi9cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFNjaGVtYVR5cGVPcHRpb25zLnByb3RvdHlwZSwgJ2RlZmF1bHQnLCBvcHRzKTtcblxuLyoqXG4gKiBUaGUgbW9kZWwgdGhhdCBgcG9wdWxhdGUoKWAgc2hvdWxkIHVzZSBpZiBwb3B1bGF0aW5nIHRoaXMgcGF0aC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICogQHByb3BlcnR5IHJlZlxuICogQG1lbWJlck9mIFNjaGVtYVR5cGVPcHRpb25zXG4gKiBAdHlwZSB7RnVuY3Rpb258U3RyaW5nfVxuICogQGluc3RhbmNlXG4gKi9cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFNjaGVtYVR5cGVPcHRpb25zLnByb3RvdHlwZSwgJ3JlZicsIG9wdHMpO1xuXG4vKipcbiAqIFRoZSBwYXRoIGluIHRoZSBkb2N1bWVudCB0aGF0IGBwb3B1bGF0ZSgpYCBzaG91bGQgdXNlIHRvIGZpbmQgdGhlIG1vZGVsXG4gKiB0byB1c2UuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqIEBwcm9wZXJ0eSByZWZcbiAqIEBtZW1iZXJPZiBTY2hlbWFUeXBlT3B0aW9uc1xuICogQHR5cGUge0Z1bmN0aW9ufFN0cmluZ31cbiAqIEBpbnN0YW5jZVxuICovXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShTY2hlbWFUeXBlT3B0aW9ucy5wcm90b3R5cGUsICdyZWZQYXRoJywgb3B0cyk7XG5cbi8qKlxuICogV2hldGhlciB0byBpbmNsdWRlIG9yIGV4Y2x1ZGUgdGhpcyBwYXRoIGJ5IGRlZmF1bHQgd2hlbiBsb2FkaW5nIGRvY3VtZW50c1xuICogdXNpbmcgYGZpbmQoKWAsIGBmaW5kT25lKClgLCBldGMuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqIEBwcm9wZXJ0eSBzZWxlY3RcbiAqIEBtZW1iZXJPZiBTY2hlbWFUeXBlT3B0aW9uc1xuICogQHR5cGUge0Jvb2xlYW58TnVtYmVyfVxuICogQGluc3RhbmNlXG4gKi9cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFNjaGVtYVR5cGVPcHRpb25zLnByb3RvdHlwZSwgJ3NlbGVjdCcsIG9wdHMpO1xuXG4vKipcbiAqIElmIFt0cnV0aHldKGh0dHBzOi8vbWFzdGVyaW5nanMuaW8vdHV0b3JpYWxzL2Z1bmRhbWVudGFscy90cnV0aHkpLCBNb25nb29zZSB3aWxsXG4gKiBidWlsZCBhbiBpbmRleCBvbiB0aGlzIHBhdGggd2hlbiB0aGUgbW9kZWwgaXMgY29tcGlsZWQuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqIEBwcm9wZXJ0eSBpbmRleFxuICogQG1lbWJlck9mIFNjaGVtYVR5cGVPcHRpb25zXG4gKiBAdHlwZSB7Qm9vbGVhbnxOdW1iZXJ8T2JqZWN0fVxuICogQGluc3RhbmNlXG4gKi9cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFNjaGVtYVR5cGVPcHRpb25zLnByb3RvdHlwZSwgJ2luZGV4Jywgb3B0cyk7XG5cbi8qKlxuICogSWYgW3RydXRoeV0oaHR0cHM6Ly9tYXN0ZXJpbmdqcy5pby90dXRvcmlhbHMvZnVuZGFtZW50YWxzL3RydXRoeSksIE1vbmdvb3NlXG4gKiB3aWxsIGJ1aWxkIGEgdW5pcXVlIGluZGV4IG9uIHRoaXMgcGF0aCB3aGVuIHRoZVxuICogbW9kZWwgaXMgY29tcGlsZWQuIFtUaGUgYHVuaXF1ZWAgb3B0aW9uIGlzICoqbm90KiogYSB2YWxpZGF0b3JdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy92YWxpZGF0aW9uLmh0bWwjdGhlLXVuaXF1ZS1vcHRpb24taXMtbm90LWEtdmFsaWRhdG9yKS5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICogQHByb3BlcnR5IHVuaXF1ZVxuICogQG1lbWJlck9mIFNjaGVtYVR5cGVPcHRpb25zXG4gKiBAdHlwZSB7Qm9vbGVhbnxOdW1iZXJ9XG4gKiBAaW5zdGFuY2VcbiAqL1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoU2NoZW1hVHlwZU9wdGlvbnMucHJvdG90eXBlLCAndW5pcXVlJywgb3B0cyk7XG5cbi8qKlxuICogSWYgW3RydXRoeV0oaHR0cHM6Ly9tYXN0ZXJpbmdqcy5pby90dXRvcmlhbHMvZnVuZGFtZW50YWxzL3RydXRoeSksIE1vbmdvb3NlIHdpbGxcbiAqIGRpc2FsbG93IGNoYW5nZXMgdG8gdGhpcyBwYXRoIG9uY2UgdGhlIGRvY3VtZW50XG4gKiBpcyBzYXZlZCB0byB0aGUgZGF0YWJhc2UgZm9yIHRoZSBmaXJzdCB0aW1lLiBSZWFkIG1vcmUgYWJvdXQgW2ltbXV0YWJpbGl0eSBpbiBNb25nb29zZSBoZXJlXShodHRwczovL3RoZWNvZGViYXJiYXJpYW4uY29tL3doYXRzLW5ldy1pbi1tb25nb29zZS01LTYtaW1tdXRhYmxlLXByb3BlcnRpZXMuaHRtbCkuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqIEBwcm9wZXJ0eSBpbW11dGFibGVcbiAqIEBtZW1iZXJPZiBTY2hlbWFUeXBlT3B0aW9uc1xuICogQHR5cGUge0Z1bmN0aW9ufEJvb2xlYW59XG4gKiBAaW5zdGFuY2VcbiAqL1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoU2NoZW1hVHlwZU9wdGlvbnMucHJvdG90eXBlLCAnaW1tdXRhYmxlJywgb3B0cyk7XG5cbi8qKlxuICogSWYgW3RydXRoeV0oaHR0cHM6Ly9tYXN0ZXJpbmdqcy5pby90dXRvcmlhbHMvZnVuZGFtZW50YWxzL3RydXRoeSksIE1vbmdvb3NlIHdpbGxcbiAqIGJ1aWxkIGEgc3BhcnNlIGluZGV4IG9uIHRoaXMgcGF0aC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICogQHByb3BlcnR5IHNwYXJzZVxuICogQG1lbWJlck9mIFNjaGVtYVR5cGVPcHRpb25zXG4gKiBAdHlwZSB7Qm9vbGVhbnxOdW1iZXJ9XG4gKiBAaW5zdGFuY2VcbiAqL1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoU2NoZW1hVHlwZU9wdGlvbnMucHJvdG90eXBlLCAnc3BhcnNlJywgb3B0cyk7XG5cbi8qKlxuICogSWYgW3RydXRoeV0oaHR0cHM6Ly9tYXN0ZXJpbmdqcy5pby90dXRvcmlhbHMvZnVuZGFtZW50YWxzL3RydXRoeSksIE1vbmdvb3NlXG4gKiB3aWxsIGJ1aWxkIGEgdGV4dCBpbmRleCBvbiB0aGlzIHBhdGguXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqIEBwcm9wZXJ0eSB0ZXh0XG4gKiBAbWVtYmVyT2YgU2NoZW1hVHlwZU9wdGlvbnNcbiAqIEB0eXBlIHtCb29sZWFufE51bWJlcnxPYmplY3R9XG4gKiBAaW5zdGFuY2VcbiAqL1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoU2NoZW1hVHlwZU9wdGlvbnMucHJvdG90eXBlLCAndGV4dCcsIG9wdHMpO1xuXG4vKipcbiAqIERlZmluZSBhIHRyYW5zZm9ybSBmdW5jdGlvbiBmb3IgdGhpcyBpbmRpdmlkdWFsIHNjaGVtYSB0eXBlLlxuICogT25seSBjYWxsZWQgd2hlbiBjYWxsaW5nIGB0b0pTT04oKWAgb3IgYHRvT2JqZWN0KClgLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgY29uc3Qgc2NoZW1hID0gU2NoZW1hKHtcbiAqICAgICAgIG15RGF0ZToge1xuICogICAgICAgICB0eXBlOiBEYXRlLFxuICogICAgICAgICB0cmFuc2Zvcm06IHYgPT4gdi5nZXRGdWxsWWVhcigpXG4gKiAgICAgICB9XG4gKiAgICAgfSk7XG4gKiAgICAgY29uc3QgTW9kZWwgPSBtb25nb29zZS5tb2RlbCgnVGVzdCcsIHNjaGVtYSk7XG4gKlxuICogICAgIGNvbnN0IGRvYyA9IG5ldyBNb2RlbCh7IG15RGF0ZTogbmV3IERhdGUoJzIwMTkvMDYvMDEnKSB9KTtcbiAqICAgICBkb2MubXlEYXRlIGluc3RhbmNlb2YgRGF0ZTsgLy8gdHJ1ZVxuICpcbiAqICAgICBjb25zdCByZXMgPSBkb2MudG9PYmplY3QoeyB0cmFuc2Zvcm06IHRydWUgfSk7XG4gKiAgICAgcmVzLm15RGF0ZTsgLy8gMjAxOVxuICpcbiAqIEBhcGkgcHVibGljXG4gKiBAcHJvcGVydHkgdHJhbnNmb3JtXG4gKiBAbWVtYmVyT2YgU2NoZW1hVHlwZU9wdGlvbnNcbiAqIEB0eXBlIHtGdW5jdGlvbn1cbiAqIEBpbnN0YW5jZVxuICovXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShTY2hlbWFUeXBlT3B0aW9ucy5wcm90b3R5cGUsICd0cmFuc2Zvcm0nLCBvcHRzKTtcblxubW9kdWxlLmV4cG9ydHMgPSBTY2hlbWFUeXBlT3B0aW9ucztcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../server/node_modules/mongoose/lib/options/schemaTypeOptions.js\n");

/***/ }),

/***/ "../server/node_modules/mongoose/lib/options/virtualOptions.js":
/*!*********************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/options/virtualOptions.js ***!
  \*********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst opts = __webpack_require__(/*! ./propertyOptions */ \"../server/node_modules/mongoose/lib/options/propertyOptions.js\");\n\nclass VirtualOptions {\n  constructor(obj) {\n    Object.assign(this, obj);\n\n    if (obj != null && obj.options != null) {\n      this.options = Object.assign({}, obj.options);\n    }\n  }\n}\n\n/**\n * Marks this virtual as a populate virtual, and specifies the model to\n * use for populate.\n *\n * @api public\n * @property ref\n * @memberOf VirtualOptions\n * @type {String|Model|Function}\n * @instance\n */\n\nObject.defineProperty(VirtualOptions.prototype, 'ref', opts);\n\n/**\n * Marks this virtual as a populate virtual, and specifies the path that\n * contains the name of the model to populate\n *\n * @api public\n * @property refPath\n * @memberOf VirtualOptions\n * @type {String|Function}\n * @instance\n */\n\nObject.defineProperty(VirtualOptions.prototype, 'refPath', opts);\n\n/**\n * The name of the property in the local model to match to `foreignField`\n * in the foreign model.\n *\n * @api public\n * @property localField\n * @memberOf VirtualOptions\n * @type {String|Function}\n * @instance\n */\n\nObject.defineProperty(VirtualOptions.prototype, 'localField', opts);\n\n/**\n * The name of the property in the foreign model to match to `localField`\n * in the local model.\n *\n * @api public\n * @property foreignField\n * @memberOf VirtualOptions\n * @type {String|Function}\n * @instance\n */\n\nObject.defineProperty(VirtualOptions.prototype, 'foreignField', opts);\n\n/**\n * Whether to populate this virtual as a single document (true) or an\n * array of documents (false).\n *\n * @api public\n * @property justOne\n * @memberOf VirtualOptions\n * @type {Boolean}\n * @instance\n */\n\nObject.defineProperty(VirtualOptions.prototype, 'justOne', opts);\n\n/**\n * If true, populate just the number of documents where `localField`\n * matches `foreignField`, as opposed to the documents themselves.\n *\n * If `count` is set, it overrides `justOne`.\n *\n * @api public\n * @property count\n * @memberOf VirtualOptions\n * @type {Boolean}\n * @instance\n */\n\nObject.defineProperty(VirtualOptions.prototype, 'count', opts);\n\n/**\n * Add an additional filter to populate, in addition to `localField`\n * matches `foreignField`.\n *\n * @api public\n * @property match\n * @memberOf VirtualOptions\n * @type {Object|Function}\n * @instance\n */\n\nObject.defineProperty(VirtualOptions.prototype, 'match', opts);\n\n/**\n * Additional options to pass to the query used to `populate()`:\n *\n * - `sort`\n * - `skip`\n * - `limit`\n *\n * @api public\n * @property options\n * @memberOf VirtualOptions\n * @type {Object}\n * @instance\n */\n\nObject.defineProperty(VirtualOptions.prototype, 'options', opts);\n\n/**\n * If true, add a `skip` to the query used to `populate()`.\n *\n * @api public\n * @property skip\n * @memberOf VirtualOptions\n * @type {Number}\n * @instance\n */\n\nObject.defineProperty(VirtualOptions.prototype, 'skip', opts);\n\n/**\n * If true, add a `limit` to the query used to `populate()`.\n *\n * @api public\n * @property limit\n * @memberOf VirtualOptions\n * @type {Number}\n * @instance\n */\n\nObject.defineProperty(VirtualOptions.prototype, 'limit', opts);\n\n/**\n * The `limit` option for `populate()` has [some unfortunate edge cases](https://mongoosejs.com/docs/populate.html#query-conditions)\n * when working with multiple documents, like `.find().populate()`. The\n * `perDocumentLimit` option makes `populate()` execute a separate query\n * for each document returned from `find()` to ensure each document\n * gets up to `perDocumentLimit` populated docs if possible.\n *\n * @api public\n * @property perDocumentLimit\n * @memberOf VirtualOptions\n * @type {Number}\n * @instance\n */\n\nObject.defineProperty(VirtualOptions.prototype, 'perDocumentLimit', opts);\n\nmodule.exports = VirtualOptions;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvb3B0aW9ucy92aXJ0dWFsT3B0aW9ucy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixhQUFhLG1CQUFPLENBQUMseUZBQW1COztBQUV4QztBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL2NsaWVudC8uLi9zZXJ2ZXIvbm9kZV9tb2R1bGVzL21vbmdvb3NlL2xpYi9vcHRpb25zL3ZpcnR1YWxPcHRpb25zLmpzPzk4ZGQiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBvcHRzID0gcmVxdWlyZSgnLi9wcm9wZXJ0eU9wdGlvbnMnKTtcblxuY2xhc3MgVmlydHVhbE9wdGlvbnMge1xuICBjb25zdHJ1Y3RvcihvYmopIHtcbiAgICBPYmplY3QuYXNzaWduKHRoaXMsIG9iaik7XG5cbiAgICBpZiAob2JqICE9IG51bGwgJiYgb2JqLm9wdGlvbnMgIT0gbnVsbCkge1xuICAgICAgdGhpcy5vcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgb2JqLm9wdGlvbnMpO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIE1hcmtzIHRoaXMgdmlydHVhbCBhcyBhIHBvcHVsYXRlIHZpcnR1YWwsIGFuZCBzcGVjaWZpZXMgdGhlIG1vZGVsIHRvXG4gKiB1c2UgZm9yIHBvcHVsYXRlLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKiBAcHJvcGVydHkgcmVmXG4gKiBAbWVtYmVyT2YgVmlydHVhbE9wdGlvbnNcbiAqIEB0eXBlIHtTdHJpbmd8TW9kZWx8RnVuY3Rpb259XG4gKiBAaW5zdGFuY2VcbiAqL1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoVmlydHVhbE9wdGlvbnMucHJvdG90eXBlLCAncmVmJywgb3B0cyk7XG5cbi8qKlxuICogTWFya3MgdGhpcyB2aXJ0dWFsIGFzIGEgcG9wdWxhdGUgdmlydHVhbCwgYW5kIHNwZWNpZmllcyB0aGUgcGF0aCB0aGF0XG4gKiBjb250YWlucyB0aGUgbmFtZSBvZiB0aGUgbW9kZWwgdG8gcG9wdWxhdGVcbiAqXG4gKiBAYXBpIHB1YmxpY1xuICogQHByb3BlcnR5IHJlZlBhdGhcbiAqIEBtZW1iZXJPZiBWaXJ0dWFsT3B0aW9uc1xuICogQHR5cGUge1N0cmluZ3xGdW5jdGlvbn1cbiAqIEBpbnN0YW5jZVxuICovXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShWaXJ0dWFsT3B0aW9ucy5wcm90b3R5cGUsICdyZWZQYXRoJywgb3B0cyk7XG5cbi8qKlxuICogVGhlIG5hbWUgb2YgdGhlIHByb3BlcnR5IGluIHRoZSBsb2NhbCBtb2RlbCB0byBtYXRjaCB0byBgZm9yZWlnbkZpZWxkYFxuICogaW4gdGhlIGZvcmVpZ24gbW9kZWwuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqIEBwcm9wZXJ0eSBsb2NhbEZpZWxkXG4gKiBAbWVtYmVyT2YgVmlydHVhbE9wdGlvbnNcbiAqIEB0eXBlIHtTdHJpbmd8RnVuY3Rpb259XG4gKiBAaW5zdGFuY2VcbiAqL1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoVmlydHVhbE9wdGlvbnMucHJvdG90eXBlLCAnbG9jYWxGaWVsZCcsIG9wdHMpO1xuXG4vKipcbiAqIFRoZSBuYW1lIG9mIHRoZSBwcm9wZXJ0eSBpbiB0aGUgZm9yZWlnbiBtb2RlbCB0byBtYXRjaCB0byBgbG9jYWxGaWVsZGBcbiAqIGluIHRoZSBsb2NhbCBtb2RlbC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICogQHByb3BlcnR5IGZvcmVpZ25GaWVsZFxuICogQG1lbWJlck9mIFZpcnR1YWxPcHRpb25zXG4gKiBAdHlwZSB7U3RyaW5nfEZ1bmN0aW9ufVxuICogQGluc3RhbmNlXG4gKi9cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFZpcnR1YWxPcHRpb25zLnByb3RvdHlwZSwgJ2ZvcmVpZ25GaWVsZCcsIG9wdHMpO1xuXG4vKipcbiAqIFdoZXRoZXIgdG8gcG9wdWxhdGUgdGhpcyB2aXJ0dWFsIGFzIGEgc2luZ2xlIGRvY3VtZW50ICh0cnVlKSBvciBhblxuICogYXJyYXkgb2YgZG9jdW1lbnRzIChmYWxzZSkuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqIEBwcm9wZXJ0eSBqdXN0T25lXG4gKiBAbWVtYmVyT2YgVmlydHVhbE9wdGlvbnNcbiAqIEB0eXBlIHtCb29sZWFufVxuICogQGluc3RhbmNlXG4gKi9cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFZpcnR1YWxPcHRpb25zLnByb3RvdHlwZSwgJ2p1c3RPbmUnLCBvcHRzKTtcblxuLyoqXG4gKiBJZiB0cnVlLCBwb3B1bGF0ZSBqdXN0IHRoZSBudW1iZXIgb2YgZG9jdW1lbnRzIHdoZXJlIGBsb2NhbEZpZWxkYFxuICogbWF0Y2hlcyBgZm9yZWlnbkZpZWxkYCwgYXMgb3Bwb3NlZCB0byB0aGUgZG9jdW1lbnRzIHRoZW1zZWx2ZXMuXG4gKlxuICogSWYgYGNvdW50YCBpcyBzZXQsIGl0IG92ZXJyaWRlcyBganVzdE9uZWAuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqIEBwcm9wZXJ0eSBjb3VudFxuICogQG1lbWJlck9mIFZpcnR1YWxPcHRpb25zXG4gKiBAdHlwZSB7Qm9vbGVhbn1cbiAqIEBpbnN0YW5jZVxuICovXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShWaXJ0dWFsT3B0aW9ucy5wcm90b3R5cGUsICdjb3VudCcsIG9wdHMpO1xuXG4vKipcbiAqIEFkZCBhbiBhZGRpdGlvbmFsIGZpbHRlciB0byBwb3B1bGF0ZSwgaW4gYWRkaXRpb24gdG8gYGxvY2FsRmllbGRgXG4gKiBtYXRjaGVzIGBmb3JlaWduRmllbGRgLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKiBAcHJvcGVydHkgbWF0Y2hcbiAqIEBtZW1iZXJPZiBWaXJ0dWFsT3B0aW9uc1xuICogQHR5cGUge09iamVjdHxGdW5jdGlvbn1cbiAqIEBpbnN0YW5jZVxuICovXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShWaXJ0dWFsT3B0aW9ucy5wcm90b3R5cGUsICdtYXRjaCcsIG9wdHMpO1xuXG4vKipcbiAqIEFkZGl0aW9uYWwgb3B0aW9ucyB0byBwYXNzIHRvIHRoZSBxdWVyeSB1c2VkIHRvIGBwb3B1bGF0ZSgpYDpcbiAqXG4gKiAtIGBzb3J0YFxuICogLSBgc2tpcGBcbiAqIC0gYGxpbWl0YFxuICpcbiAqIEBhcGkgcHVibGljXG4gKiBAcHJvcGVydHkgb3B0aW9uc1xuICogQG1lbWJlck9mIFZpcnR1YWxPcHRpb25zXG4gKiBAdHlwZSB7T2JqZWN0fVxuICogQGluc3RhbmNlXG4gKi9cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFZpcnR1YWxPcHRpb25zLnByb3RvdHlwZSwgJ29wdGlvbnMnLCBvcHRzKTtcblxuLyoqXG4gKiBJZiB0cnVlLCBhZGQgYSBgc2tpcGAgdG8gdGhlIHF1ZXJ5IHVzZWQgdG8gYHBvcHVsYXRlKClgLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKiBAcHJvcGVydHkgc2tpcFxuICogQG1lbWJlck9mIFZpcnR1YWxPcHRpb25zXG4gKiBAdHlwZSB7TnVtYmVyfVxuICogQGluc3RhbmNlXG4gKi9cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFZpcnR1YWxPcHRpb25zLnByb3RvdHlwZSwgJ3NraXAnLCBvcHRzKTtcblxuLyoqXG4gKiBJZiB0cnVlLCBhZGQgYSBgbGltaXRgIHRvIHRoZSBxdWVyeSB1c2VkIHRvIGBwb3B1bGF0ZSgpYC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICogQHByb3BlcnR5IGxpbWl0XG4gKiBAbWVtYmVyT2YgVmlydHVhbE9wdGlvbnNcbiAqIEB0eXBlIHtOdW1iZXJ9XG4gKiBAaW5zdGFuY2VcbiAqL1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoVmlydHVhbE9wdGlvbnMucHJvdG90eXBlLCAnbGltaXQnLCBvcHRzKTtcblxuLyoqXG4gKiBUaGUgYGxpbWl0YCBvcHRpb24gZm9yIGBwb3B1bGF0ZSgpYCBoYXMgW3NvbWUgdW5mb3J0dW5hdGUgZWRnZSBjYXNlc10oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL3BvcHVsYXRlLmh0bWwjcXVlcnktY29uZGl0aW9ucylcbiAqIHdoZW4gd29ya2luZyB3aXRoIG11bHRpcGxlIGRvY3VtZW50cywgbGlrZSBgLmZpbmQoKS5wb3B1bGF0ZSgpYC4gVGhlXG4gKiBgcGVyRG9jdW1lbnRMaW1pdGAgb3B0aW9uIG1ha2VzIGBwb3B1bGF0ZSgpYCBleGVjdXRlIGEgc2VwYXJhdGUgcXVlcnlcbiAqIGZvciBlYWNoIGRvY3VtZW50IHJldHVybmVkIGZyb20gYGZpbmQoKWAgdG8gZW5zdXJlIGVhY2ggZG9jdW1lbnRcbiAqIGdldHMgdXAgdG8gYHBlckRvY3VtZW50TGltaXRgIHBvcHVsYXRlZCBkb2NzIGlmIHBvc3NpYmxlLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKiBAcHJvcGVydHkgcGVyRG9jdW1lbnRMaW1pdFxuICogQG1lbWJlck9mIFZpcnR1YWxPcHRpb25zXG4gKiBAdHlwZSB7TnVtYmVyfVxuICogQGluc3RhbmNlXG4gKi9cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFZpcnR1YWxPcHRpb25zLnByb3RvdHlwZSwgJ3BlckRvY3VtZW50TGltaXQnLCBvcHRzKTtcblxubW9kdWxlLmV4cG9ydHMgPSBWaXJ0dWFsT3B0aW9ucztcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../server/node_modules/mongoose/lib/options/virtualOptions.js\n");

/***/ }),

/***/ "../server/node_modules/mongoose/lib/plugins/index.js":
/*!************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/plugins/index.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nexports.saveSubdocs = __webpack_require__(/*! ./saveSubdocs */ \"../server/node_modules/mongoose/lib/plugins/saveSubdocs.js\");\nexports.sharding = __webpack_require__(/*! ./sharding */ \"../server/node_modules/mongoose/lib/plugins/sharding.js\");\nexports.trackTransaction = __webpack_require__(/*! ./trackTransaction */ \"../server/node_modules/mongoose/lib/plugins/trackTransaction.js\");\nexports.validateBeforeSave = __webpack_require__(/*! ./validateBeforeSave */ \"../server/node_modules/mongoose/lib/plugins/validateBeforeSave.js\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvcGx1Z2lucy9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYiw0SEFBOEM7QUFDOUMsbUhBQXdDO0FBQ3hDLDJJQUF3RDtBQUN4RCxpSkFBNEQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbGllbnQvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvcGx1Z2lucy9pbmRleC5qcz8xMmRlIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5zYXZlU3ViZG9jcyA9IHJlcXVpcmUoJy4vc2F2ZVN1YmRvY3MnKTtcbmV4cG9ydHMuc2hhcmRpbmcgPSByZXF1aXJlKCcuL3NoYXJkaW5nJyk7XG5leHBvcnRzLnRyYWNrVHJhbnNhY3Rpb24gPSByZXF1aXJlKCcuL3RyYWNrVHJhbnNhY3Rpb24nKTtcbmV4cG9ydHMudmFsaWRhdGVCZWZvcmVTYXZlID0gcmVxdWlyZSgnLi92YWxpZGF0ZUJlZm9yZVNhdmUnKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../server/node_modules/mongoose/lib/plugins/index.js\n");

/***/ }),

/***/ "../server/node_modules/mongoose/lib/plugins/saveSubdocs.js":
/*!******************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/plugins/saveSubdocs.js ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst each = __webpack_require__(/*! ../helpers/each */ \"../server/node_modules/mongoose/lib/helpers/each.js\");\n\n/*!\n * ignore\n */\n\nmodule.exports = function saveSubdocs(schema) {\n  const unshift = true;\n  schema.s.hooks.pre('save', false, function saveSubdocsPreSave(next) {\n    if (this.$isSubdocument) {\n      next();\n      return;\n    }\n\n    const _this = this;\n    const subdocs = this.$getAllSubdocs();\n\n    if (!subdocs.length) {\n      next();\n      return;\n    }\n\n    each(subdocs, function(subdoc, cb) {\n      subdoc.$__schema.s.hooks.execPre('save', subdoc, function(err) {\n        cb(err);\n      });\n    }, function(error) {\n      if (error) {\n        return _this.$__schema.s.hooks.execPost('save:error', _this, [_this], { error: error }, function(error) {\n          next(error);\n        });\n      }\n      next();\n    });\n  }, null, unshift);\n\n  schema.s.hooks.post('save', function saveSubdocsPostSave(doc, next) {\n    if (this.$isSubdocument) {\n      next();\n      return;\n    }\n\n    const _this = this;\n    const subdocs = this.$getAllSubdocs();\n\n    if (!subdocs.length) {\n      next();\n      return;\n    }\n\n    each(subdocs, function(subdoc, cb) {\n      subdoc.$__schema.s.hooks.execPost('save', subdoc, [subdoc], function(err) {\n        cb(err);\n      });\n    }, function(error) {\n      if (error) {\n        return _this.$__schema.s.hooks.execPost('save:error', _this, [_this], { error: error }, function(error) {\n          next(error);\n        });\n      }\n      next();\n    });\n  }, null, unshift);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvcGx1Z2lucy9zYXZlU3ViZG9jcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixhQUFhLG1CQUFPLENBQUMsNEVBQWlCOztBQUV0QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0EsZ0ZBQWdGLGNBQWM7QUFDOUY7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0EsZ0ZBQWdGLGNBQWM7QUFDOUY7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0giLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbGllbnQvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvcGx1Z2lucy9zYXZlU3ViZG9jcy5qcz82Yjg1Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3QgZWFjaCA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvZWFjaCcpO1xuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gc2F2ZVN1YmRvY3Moc2NoZW1hKSB7XG4gIGNvbnN0IHVuc2hpZnQgPSB0cnVlO1xuICBzY2hlbWEucy5ob29rcy5wcmUoJ3NhdmUnLCBmYWxzZSwgZnVuY3Rpb24gc2F2ZVN1YmRvY3NQcmVTYXZlKG5leHQpIHtcbiAgICBpZiAodGhpcy4kaXNTdWJkb2N1bWVudCkge1xuICAgICAgbmV4dCgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IF90aGlzID0gdGhpcztcbiAgICBjb25zdCBzdWJkb2NzID0gdGhpcy4kZ2V0QWxsU3ViZG9jcygpO1xuXG4gICAgaWYgKCFzdWJkb2NzLmxlbmd0aCkge1xuICAgICAgbmV4dCgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGVhY2goc3ViZG9jcywgZnVuY3Rpb24oc3ViZG9jLCBjYikge1xuICAgICAgc3ViZG9jLiRfX3NjaGVtYS5zLmhvb2tzLmV4ZWNQcmUoJ3NhdmUnLCBzdWJkb2MsIGZ1bmN0aW9uKGVycikge1xuICAgICAgICBjYihlcnIpO1xuICAgICAgfSk7XG4gICAgfSwgZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAgIGlmIChlcnJvcikge1xuICAgICAgICByZXR1cm4gX3RoaXMuJF9fc2NoZW1hLnMuaG9va3MuZXhlY1Bvc3QoJ3NhdmU6ZXJyb3InLCBfdGhpcywgW190aGlzXSwgeyBlcnJvcjogZXJyb3IgfSwgZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAgICAgICBuZXh0KGVycm9yKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBuZXh0KCk7XG4gICAgfSk7XG4gIH0sIG51bGwsIHVuc2hpZnQpO1xuXG4gIHNjaGVtYS5zLmhvb2tzLnBvc3QoJ3NhdmUnLCBmdW5jdGlvbiBzYXZlU3ViZG9jc1Bvc3RTYXZlKGRvYywgbmV4dCkge1xuICAgIGlmICh0aGlzLiRpc1N1YmRvY3VtZW50KSB7XG4gICAgICBuZXh0KCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgX3RoaXMgPSB0aGlzO1xuICAgIGNvbnN0IHN1YmRvY3MgPSB0aGlzLiRnZXRBbGxTdWJkb2NzKCk7XG5cbiAgICBpZiAoIXN1YmRvY3MubGVuZ3RoKSB7XG4gICAgICBuZXh0KCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZWFjaChzdWJkb2NzLCBmdW5jdGlvbihzdWJkb2MsIGNiKSB7XG4gICAgICBzdWJkb2MuJF9fc2NoZW1hLnMuaG9va3MuZXhlY1Bvc3QoJ3NhdmUnLCBzdWJkb2MsIFtzdWJkb2NdLCBmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgY2IoZXJyKTtcbiAgICAgIH0pO1xuICAgIH0sIGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzLiRfX3NjaGVtYS5zLmhvb2tzLmV4ZWNQb3N0KCdzYXZlOmVycm9yJywgX3RoaXMsIFtfdGhpc10sIHsgZXJyb3I6IGVycm9yIH0sIGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgICAgICAgbmV4dChlcnJvcik7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgbmV4dCgpO1xuICAgIH0pO1xuICB9LCBudWxsLCB1bnNoaWZ0KTtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../server/node_modules/mongoose/lib/plugins/saveSubdocs.js\n");

/***/ }),

/***/ "../server/node_modules/mongoose/lib/plugins/sharding.js":
/*!***************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/plugins/sharding.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst objectIdSymbol = (__webpack_require__(/*! ../helpers/symbols */ \"../server/node_modules/mongoose/lib/helpers/symbols.js\").objectIdSymbol);\nconst utils = __webpack_require__(/*! ../utils */ \"../server/node_modules/mongoose/lib/utils.js\");\n\n/*!\n * ignore\n */\n\nmodule.exports = function shardingPlugin(schema) {\n  schema.post('init', function shardingPluginPostInit() {\n    storeShard.call(this);\n    return this;\n  });\n  schema.pre('save', function shardingPluginPreSave(next) {\n    applyWhere.call(this);\n    next();\n  });\n  schema.pre('remove', function shardingPluginPreRemove(next) {\n    applyWhere.call(this);\n    next();\n  });\n  schema.post('save', function shardingPluginPostSave() {\n    storeShard.call(this);\n  });\n};\n\n/*!\n * ignore\n */\n\nfunction applyWhere() {\n  let paths;\n  let len;\n\n  if (this.$__.shardval) {\n    paths = Object.keys(this.$__.shardval);\n    len = paths.length;\n\n    this.$where = this.$where || {};\n    for (let i = 0; i < len; ++i) {\n      this.$where[paths[i]] = this.$__.shardval[paths[i]];\n    }\n  }\n}\n\n/*!\n * ignore\n */\n\nmodule.exports.storeShard = storeShard;\n\n/*!\n * ignore\n */\n\nfunction storeShard() {\n  // backwards compat\n  const key = this.$__schema.options.shardKey || this.$__schema.options.shardkey;\n  if (!utils.isPOJO(key)) {\n    return;\n  }\n\n  const orig = this.$__.shardval = {};\n  const paths = Object.keys(key);\n  const len = paths.length;\n  let val;\n\n  for (let i = 0; i < len; ++i) {\n    val = this.$__getValue(paths[i]);\n    if (val == null) {\n      orig[paths[i]] = val;\n    } else if (utils.isMongooseObject(val)) {\n      orig[paths[i]] = val.toObject({ depopulate: true, _isNested: true });\n    } else if (val instanceof Date || val[objectIdSymbol]) {\n      orig[paths[i]] = val;\n    } else if (typeof val.valueOf === 'function') {\n      orig[paths[i]] = val.valueOf();\n    } else {\n      orig[paths[i]] = val;\n    }\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvcGx1Z2lucy9zaGFyZGluZy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYix1QkFBdUIsd0hBQTRDO0FBQ25FLGNBQWMsbUJBQU8sQ0FBQyw4REFBVTs7QUFFaEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSx5QkFBeUI7O0FBRXpCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLFNBQVM7QUFDM0I7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLHNDQUFzQyxtQ0FBbUM7QUFDekUsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2xpZW50Ly4uL3NlcnZlci9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL3BsdWdpbnMvc2hhcmRpbmcuanM/M2E3NyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IG9iamVjdElkU3ltYm9sID0gcmVxdWlyZSgnLi4vaGVscGVycy9zeW1ib2xzJykub2JqZWN0SWRTeW1ib2w7XG5jb25zdCB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzJyk7XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBzaGFyZGluZ1BsdWdpbihzY2hlbWEpIHtcbiAgc2NoZW1hLnBvc3QoJ2luaXQnLCBmdW5jdGlvbiBzaGFyZGluZ1BsdWdpblBvc3RJbml0KCkge1xuICAgIHN0b3JlU2hhcmQuY2FsbCh0aGlzKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSk7XG4gIHNjaGVtYS5wcmUoJ3NhdmUnLCBmdW5jdGlvbiBzaGFyZGluZ1BsdWdpblByZVNhdmUobmV4dCkge1xuICAgIGFwcGx5V2hlcmUuY2FsbCh0aGlzKTtcbiAgICBuZXh0KCk7XG4gIH0pO1xuICBzY2hlbWEucHJlKCdyZW1vdmUnLCBmdW5jdGlvbiBzaGFyZGluZ1BsdWdpblByZVJlbW92ZShuZXh0KSB7XG4gICAgYXBwbHlXaGVyZS5jYWxsKHRoaXMpO1xuICAgIG5leHQoKTtcbiAgfSk7XG4gIHNjaGVtYS5wb3N0KCdzYXZlJywgZnVuY3Rpb24gc2hhcmRpbmdQbHVnaW5Qb3N0U2F2ZSgpIHtcbiAgICBzdG9yZVNoYXJkLmNhbGwodGhpcyk7XG4gIH0pO1xufTtcblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5mdW5jdGlvbiBhcHBseVdoZXJlKCkge1xuICBsZXQgcGF0aHM7XG4gIGxldCBsZW47XG5cbiAgaWYgKHRoaXMuJF9fLnNoYXJkdmFsKSB7XG4gICAgcGF0aHMgPSBPYmplY3Qua2V5cyh0aGlzLiRfXy5zaGFyZHZhbCk7XG4gICAgbGVuID0gcGF0aHMubGVuZ3RoO1xuXG4gICAgdGhpcy4kd2hlcmUgPSB0aGlzLiR3aGVyZSB8fCB7fTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICB0aGlzLiR3aGVyZVtwYXRoc1tpXV0gPSB0aGlzLiRfXy5zaGFyZHZhbFtwYXRoc1tpXV07XG4gICAgfVxuICB9XG59XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxubW9kdWxlLmV4cG9ydHMuc3RvcmVTaGFyZCA9IHN0b3JlU2hhcmQ7XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxuZnVuY3Rpb24gc3RvcmVTaGFyZCgpIHtcbiAgLy8gYmFja3dhcmRzIGNvbXBhdFxuICBjb25zdCBrZXkgPSB0aGlzLiRfX3NjaGVtYS5vcHRpb25zLnNoYXJkS2V5IHx8IHRoaXMuJF9fc2NoZW1hLm9wdGlvbnMuc2hhcmRrZXk7XG4gIGlmICghdXRpbHMuaXNQT0pPKGtleSkpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBjb25zdCBvcmlnID0gdGhpcy4kX18uc2hhcmR2YWwgPSB7fTtcbiAgY29uc3QgcGF0aHMgPSBPYmplY3Qua2V5cyhrZXkpO1xuICBjb25zdCBsZW4gPSBwYXRocy5sZW5ndGg7XG4gIGxldCB2YWw7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgIHZhbCA9IHRoaXMuJF9fZ2V0VmFsdWUocGF0aHNbaV0pO1xuICAgIGlmICh2YWwgPT0gbnVsbCkge1xuICAgICAgb3JpZ1twYXRoc1tpXV0gPSB2YWw7XG4gICAgfSBlbHNlIGlmICh1dGlscy5pc01vbmdvb3NlT2JqZWN0KHZhbCkpIHtcbiAgICAgIG9yaWdbcGF0aHNbaV1dID0gdmFsLnRvT2JqZWN0KHsgZGVwb3B1bGF0ZTogdHJ1ZSwgX2lzTmVzdGVkOiB0cnVlIH0pO1xuICAgIH0gZWxzZSBpZiAodmFsIGluc3RhbmNlb2YgRGF0ZSB8fCB2YWxbb2JqZWN0SWRTeW1ib2xdKSB7XG4gICAgICBvcmlnW3BhdGhzW2ldXSA9IHZhbDtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwudmFsdWVPZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgb3JpZ1twYXRoc1tpXV0gPSB2YWwudmFsdWVPZigpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvcmlnW3BhdGhzW2ldXSA9IHZhbDtcbiAgICB9XG4gIH1cbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../server/node_modules/mongoose/lib/plugins/sharding.js\n");

/***/ }),

/***/ "../server/node_modules/mongoose/lib/plugins/trackTransaction.js":
/*!***********************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/plugins/trackTransaction.js ***!
  \***********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst arrayAtomicsSymbol = (__webpack_require__(/*! ../helpers/symbols */ \"../server/node_modules/mongoose/lib/helpers/symbols.js\").arrayAtomicsSymbol);\nconst sessionNewDocuments = (__webpack_require__(/*! ../helpers/symbols */ \"../server/node_modules/mongoose/lib/helpers/symbols.js\").sessionNewDocuments);\nconst utils = __webpack_require__(/*! ../utils */ \"../server/node_modules/mongoose/lib/utils.js\");\n\nmodule.exports = function trackTransaction(schema) {\n  schema.pre('save', function trackTransactionPreSave() {\n    const session = this.$session();\n    if (session == null) {\n      return;\n    }\n    if (session.transaction == null || session[sessionNewDocuments] == null) {\n      return;\n    }\n\n    if (!session[sessionNewDocuments].has(this)) {\n      const initialState = {};\n      if (this.isNew) {\n        initialState.isNew = true;\n      }\n      if (this.$__schema.options.versionKey) {\n        initialState.versionKey = this.get(this.$__schema.options.versionKey);\n      }\n\n      initialState.modifiedPaths = new Set(Object.keys(this.$__.activePaths.getStatePaths('modify')));\n      initialState.atomics = _getAtomics(this);\n\n      session[sessionNewDocuments].set(this, initialState);\n    } else {\n      const state = session[sessionNewDocuments].get(this);\n\n      for (const path of Object.keys(this.$__.activePaths.getStatePaths('modify'))) {\n        state.modifiedPaths.add(path);\n      }\n      state.atomics = _getAtomics(this, state.atomics);\n    }\n  });\n};\n\nfunction _getAtomics(doc, previous) {\n  const pathToAtomics = new Map();\n  previous = previous || new Map();\n\n  const pathsToCheck = Object.keys(doc.$__.activePaths.init).concat(Object.keys(doc.$__.activePaths.modify));\n\n  for (const path of pathsToCheck) {\n    const val = doc.$__getValue(path);\n    if (val != null &&\n        Array.isArray(val) &&\n        utils.isMongooseDocumentArray(val) &&\n        val.length &&\n        val[arrayAtomicsSymbol] != null &&\n        Object.keys(val[arrayAtomicsSymbol]).length !== 0) {\n      const existing = previous.get(path) || {};\n      pathToAtomics.set(path, mergeAtomics(existing, val[arrayAtomicsSymbol]));\n    }\n  }\n\n  const dirty = doc.$__dirty();\n  for (const dirt of dirty) {\n    const path = dirt.path;\n\n    const val = dirt.value;\n    if (val != null && val[arrayAtomicsSymbol] != null && Object.keys(val[arrayAtomicsSymbol]).length !== 0) {\n      const existing = previous.get(path) || {};\n      pathToAtomics.set(path, mergeAtomics(existing, val[arrayAtomicsSymbol]));\n    }\n  }\n\n  return pathToAtomics;\n}\n\nfunction mergeAtomics(destination, source) {\n  destination = destination || {};\n\n  if (source.$pullAll != null) {\n    destination.$pullAll = (destination.$pullAll || []).concat(source.$pullAll);\n  }\n  if (source.$push != null) {\n    destination.$push = destination.$push || {};\n    destination.$push.$each = (destination.$push.$each || []).concat(source.$push.$each);\n  }\n  if (source.$addToSet != null) {\n    destination.$addToSet = (destination.$addToSet || []).concat(source.$addToSet);\n  }\n  if (source.$set != null) {\n    destination.$set = Array.isArray(source.$set) ? [...source.$set] : Object.assign({}, source.$set);\n  }\n\n  return destination;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvcGx1Z2lucy90cmFja1RyYW5zYWN0aW9uLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLDJCQUEyQiw0SEFBZ0Q7QUFDM0UsNEJBQTRCLDZIQUFpRDtBQUM3RSxjQUFjLG1CQUFPLENBQUMsOERBQVU7O0FBRWhDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNO0FBQ047O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1RkFBdUY7QUFDdkY7O0FBRUE7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2NsaWVudC8uLi9zZXJ2ZXIvbm9kZV9tb2R1bGVzL21vbmdvb3NlL2xpYi9wbHVnaW5zL3RyYWNrVHJhbnNhY3Rpb24uanM/OTJjMyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IGFycmF5QXRvbWljc1N5bWJvbCA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvc3ltYm9scycpLmFycmF5QXRvbWljc1N5bWJvbDtcbmNvbnN0IHNlc3Npb25OZXdEb2N1bWVudHMgPSByZXF1aXJlKCcuLi9oZWxwZXJzL3N5bWJvbHMnKS5zZXNzaW9uTmV3RG9jdW1lbnRzO1xuY29uc3QgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHRyYWNrVHJhbnNhY3Rpb24oc2NoZW1hKSB7XG4gIHNjaGVtYS5wcmUoJ3NhdmUnLCBmdW5jdGlvbiB0cmFja1RyYW5zYWN0aW9uUHJlU2F2ZSgpIHtcbiAgICBjb25zdCBzZXNzaW9uID0gdGhpcy4kc2Vzc2lvbigpO1xuICAgIGlmIChzZXNzaW9uID09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHNlc3Npb24udHJhbnNhY3Rpb24gPT0gbnVsbCB8fCBzZXNzaW9uW3Nlc3Npb25OZXdEb2N1bWVudHNdID09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoIXNlc3Npb25bc2Vzc2lvbk5ld0RvY3VtZW50c10uaGFzKHRoaXMpKSB7XG4gICAgICBjb25zdCBpbml0aWFsU3RhdGUgPSB7fTtcbiAgICAgIGlmICh0aGlzLmlzTmV3KSB7XG4gICAgICAgIGluaXRpYWxTdGF0ZS5pc05ldyA9IHRydWU7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy4kX19zY2hlbWEub3B0aW9ucy52ZXJzaW9uS2V5KSB7XG4gICAgICAgIGluaXRpYWxTdGF0ZS52ZXJzaW9uS2V5ID0gdGhpcy5nZXQodGhpcy4kX19zY2hlbWEub3B0aW9ucy52ZXJzaW9uS2V5KTtcbiAgICAgIH1cblxuICAgICAgaW5pdGlhbFN0YXRlLm1vZGlmaWVkUGF0aHMgPSBuZXcgU2V0KE9iamVjdC5rZXlzKHRoaXMuJF9fLmFjdGl2ZVBhdGhzLmdldFN0YXRlUGF0aHMoJ21vZGlmeScpKSk7XG4gICAgICBpbml0aWFsU3RhdGUuYXRvbWljcyA9IF9nZXRBdG9taWNzKHRoaXMpO1xuXG4gICAgICBzZXNzaW9uW3Nlc3Npb25OZXdEb2N1bWVudHNdLnNldCh0aGlzLCBpbml0aWFsU3RhdGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBzdGF0ZSA9IHNlc3Npb25bc2Vzc2lvbk5ld0RvY3VtZW50c10uZ2V0KHRoaXMpO1xuXG4gICAgICBmb3IgKGNvbnN0IHBhdGggb2YgT2JqZWN0LmtleXModGhpcy4kX18uYWN0aXZlUGF0aHMuZ2V0U3RhdGVQYXRocygnbW9kaWZ5JykpKSB7XG4gICAgICAgIHN0YXRlLm1vZGlmaWVkUGF0aHMuYWRkKHBhdGgpO1xuICAgICAgfVxuICAgICAgc3RhdGUuYXRvbWljcyA9IF9nZXRBdG9taWNzKHRoaXMsIHN0YXRlLmF0b21pY3MpO1xuICAgIH1cbiAgfSk7XG59O1xuXG5mdW5jdGlvbiBfZ2V0QXRvbWljcyhkb2MsIHByZXZpb3VzKSB7XG4gIGNvbnN0IHBhdGhUb0F0b21pY3MgPSBuZXcgTWFwKCk7XG4gIHByZXZpb3VzID0gcHJldmlvdXMgfHwgbmV3IE1hcCgpO1xuXG4gIGNvbnN0IHBhdGhzVG9DaGVjayA9IE9iamVjdC5rZXlzKGRvYy4kX18uYWN0aXZlUGF0aHMuaW5pdCkuY29uY2F0KE9iamVjdC5rZXlzKGRvYy4kX18uYWN0aXZlUGF0aHMubW9kaWZ5KSk7XG5cbiAgZm9yIChjb25zdCBwYXRoIG9mIHBhdGhzVG9DaGVjaykge1xuICAgIGNvbnN0IHZhbCA9IGRvYy4kX19nZXRWYWx1ZShwYXRoKTtcbiAgICBpZiAodmFsICE9IG51bGwgJiZcbiAgICAgICAgQXJyYXkuaXNBcnJheSh2YWwpICYmXG4gICAgICAgIHV0aWxzLmlzTW9uZ29vc2VEb2N1bWVudEFycmF5KHZhbCkgJiZcbiAgICAgICAgdmFsLmxlbmd0aCAmJlxuICAgICAgICB2YWxbYXJyYXlBdG9taWNzU3ltYm9sXSAhPSBudWxsICYmXG4gICAgICAgIE9iamVjdC5rZXlzKHZhbFthcnJheUF0b21pY3NTeW1ib2xdKS5sZW5ndGggIT09IDApIHtcbiAgICAgIGNvbnN0IGV4aXN0aW5nID0gcHJldmlvdXMuZ2V0KHBhdGgpIHx8IHt9O1xuICAgICAgcGF0aFRvQXRvbWljcy5zZXQocGF0aCwgbWVyZ2VBdG9taWNzKGV4aXN0aW5nLCB2YWxbYXJyYXlBdG9taWNzU3ltYm9sXSkpO1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0IGRpcnR5ID0gZG9jLiRfX2RpcnR5KCk7XG4gIGZvciAoY29uc3QgZGlydCBvZiBkaXJ0eSkge1xuICAgIGNvbnN0IHBhdGggPSBkaXJ0LnBhdGg7XG5cbiAgICBjb25zdCB2YWwgPSBkaXJ0LnZhbHVlO1xuICAgIGlmICh2YWwgIT0gbnVsbCAmJiB2YWxbYXJyYXlBdG9taWNzU3ltYm9sXSAhPSBudWxsICYmIE9iamVjdC5rZXlzKHZhbFthcnJheUF0b21pY3NTeW1ib2xdKS5sZW5ndGggIT09IDApIHtcbiAgICAgIGNvbnN0IGV4aXN0aW5nID0gcHJldmlvdXMuZ2V0KHBhdGgpIHx8IHt9O1xuICAgICAgcGF0aFRvQXRvbWljcy5zZXQocGF0aCwgbWVyZ2VBdG9taWNzKGV4aXN0aW5nLCB2YWxbYXJyYXlBdG9taWNzU3ltYm9sXSkpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBwYXRoVG9BdG9taWNzO1xufVxuXG5mdW5jdGlvbiBtZXJnZUF0b21pY3MoZGVzdGluYXRpb24sIHNvdXJjZSkge1xuICBkZXN0aW5hdGlvbiA9IGRlc3RpbmF0aW9uIHx8IHt9O1xuXG4gIGlmIChzb3VyY2UuJHB1bGxBbGwgIT0gbnVsbCkge1xuICAgIGRlc3RpbmF0aW9uLiRwdWxsQWxsID0gKGRlc3RpbmF0aW9uLiRwdWxsQWxsIHx8IFtdKS5jb25jYXQoc291cmNlLiRwdWxsQWxsKTtcbiAgfVxuICBpZiAoc291cmNlLiRwdXNoICE9IG51bGwpIHtcbiAgICBkZXN0aW5hdGlvbi4kcHVzaCA9IGRlc3RpbmF0aW9uLiRwdXNoIHx8IHt9O1xuICAgIGRlc3RpbmF0aW9uLiRwdXNoLiRlYWNoID0gKGRlc3RpbmF0aW9uLiRwdXNoLiRlYWNoIHx8IFtdKS5jb25jYXQoc291cmNlLiRwdXNoLiRlYWNoKTtcbiAgfVxuICBpZiAoc291cmNlLiRhZGRUb1NldCAhPSBudWxsKSB7XG4gICAgZGVzdGluYXRpb24uJGFkZFRvU2V0ID0gKGRlc3RpbmF0aW9uLiRhZGRUb1NldCB8fCBbXSkuY29uY2F0KHNvdXJjZS4kYWRkVG9TZXQpO1xuICB9XG4gIGlmIChzb3VyY2UuJHNldCAhPSBudWxsKSB7XG4gICAgZGVzdGluYXRpb24uJHNldCA9IEFycmF5LmlzQXJyYXkoc291cmNlLiRzZXQpID8gWy4uLnNvdXJjZS4kc2V0XSA6IE9iamVjdC5hc3NpZ24oe30sIHNvdXJjZS4kc2V0KTtcbiAgfVxuXG4gIHJldHVybiBkZXN0aW5hdGlvbjtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../server/node_modules/mongoose/lib/plugins/trackTransaction.js\n");

/***/ }),

/***/ "../server/node_modules/mongoose/lib/plugins/validateBeforeSave.js":
/*!*************************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/plugins/validateBeforeSave.js ***!
  \*************************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/*!\n * ignore\n */\n\nmodule.exports = function validateBeforeSave(schema) {\n  const unshift = true;\n  schema.pre('save', false, function validateBeforeSave(next, options) {\n    const _this = this;\n    // Nested docs have their own presave\n    if (this.$isSubdocument) {\n      return next();\n    }\n\n    const hasValidateBeforeSaveOption = options &&\n        (typeof options === 'object') &&\n        ('validateBeforeSave' in options);\n\n    let shouldValidate;\n    if (hasValidateBeforeSaveOption) {\n      shouldValidate = !!options.validateBeforeSave;\n    } else {\n      shouldValidate = this.$__schema.options.validateBeforeSave;\n    }\n\n    // Validate\n    if (shouldValidate) {\n      const hasValidateModifiedOnlyOption = options &&\n          (typeof options === 'object') &&\n          ('validateModifiedOnly' in options);\n      const validateOptions = hasValidateModifiedOnlyOption ?\n        { validateModifiedOnly: options.validateModifiedOnly } :\n        null;\n      this.$validate(validateOptions).then(\n        () => {\n          this.$op = 'save';\n          next();\n        },\n        error => {\n          _this.$__schema.s.hooks.execPost('save:error', _this, [_this], { error: error }, function(error) {\n            _this.$op = 'save';\n            next(error);\n          });\n        }\n      );\n    } else {\n      next();\n    }\n  }, null, unshift);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvcGx1Z2lucy92YWxpZGF0ZUJlZm9yZVNhdmUuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUscURBQXFEO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSwyRUFBMkUsY0FBYztBQUN6RjtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEdBQUc7QUFDSCIsInNvdXJjZXMiOlsid2VicGFjazovL2NsaWVudC8uLi9zZXJ2ZXIvbm9kZV9tb2R1bGVzL21vbmdvb3NlL2xpYi9wbHVnaW5zL3ZhbGlkYXRlQmVmb3JlU2F2ZS5qcz9kMTY3Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHZhbGlkYXRlQmVmb3JlU2F2ZShzY2hlbWEpIHtcbiAgY29uc3QgdW5zaGlmdCA9IHRydWU7XG4gIHNjaGVtYS5wcmUoJ3NhdmUnLCBmYWxzZSwgZnVuY3Rpb24gdmFsaWRhdGVCZWZvcmVTYXZlKG5leHQsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBfdGhpcyA9IHRoaXM7XG4gICAgLy8gTmVzdGVkIGRvY3MgaGF2ZSB0aGVpciBvd24gcHJlc2F2ZVxuICAgIGlmICh0aGlzLiRpc1N1YmRvY3VtZW50KSB7XG4gICAgICByZXR1cm4gbmV4dCgpO1xuICAgIH1cblxuICAgIGNvbnN0IGhhc1ZhbGlkYXRlQmVmb3JlU2F2ZU9wdGlvbiA9IG9wdGlvbnMgJiZcbiAgICAgICAgKHR5cGVvZiBvcHRpb25zID09PSAnb2JqZWN0JykgJiZcbiAgICAgICAgKCd2YWxpZGF0ZUJlZm9yZVNhdmUnIGluIG9wdGlvbnMpO1xuXG4gICAgbGV0IHNob3VsZFZhbGlkYXRlO1xuICAgIGlmIChoYXNWYWxpZGF0ZUJlZm9yZVNhdmVPcHRpb24pIHtcbiAgICAgIHNob3VsZFZhbGlkYXRlID0gISFvcHRpb25zLnZhbGlkYXRlQmVmb3JlU2F2ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2hvdWxkVmFsaWRhdGUgPSB0aGlzLiRfX3NjaGVtYS5vcHRpb25zLnZhbGlkYXRlQmVmb3JlU2F2ZTtcbiAgICB9XG5cbiAgICAvLyBWYWxpZGF0ZVxuICAgIGlmIChzaG91bGRWYWxpZGF0ZSkge1xuICAgICAgY29uc3QgaGFzVmFsaWRhdGVNb2RpZmllZE9ubHlPcHRpb24gPSBvcHRpb25zICYmXG4gICAgICAgICAgKHR5cGVvZiBvcHRpb25zID09PSAnb2JqZWN0JykgJiZcbiAgICAgICAgICAoJ3ZhbGlkYXRlTW9kaWZpZWRPbmx5JyBpbiBvcHRpb25zKTtcbiAgICAgIGNvbnN0IHZhbGlkYXRlT3B0aW9ucyA9IGhhc1ZhbGlkYXRlTW9kaWZpZWRPbmx5T3B0aW9uID9cbiAgICAgICAgeyB2YWxpZGF0ZU1vZGlmaWVkT25seTogb3B0aW9ucy52YWxpZGF0ZU1vZGlmaWVkT25seSB9IDpcbiAgICAgICAgbnVsbDtcbiAgICAgIHRoaXMuJHZhbGlkYXRlKHZhbGlkYXRlT3B0aW9ucykudGhlbihcbiAgICAgICAgKCkgPT4ge1xuICAgICAgICAgIHRoaXMuJG9wID0gJ3NhdmUnO1xuICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgfSxcbiAgICAgICAgZXJyb3IgPT4ge1xuICAgICAgICAgIF90aGlzLiRfX3NjaGVtYS5zLmhvb2tzLmV4ZWNQb3N0KCdzYXZlOmVycm9yJywgX3RoaXMsIFtfdGhpc10sIHsgZXJyb3I6IGVycm9yIH0sIGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgICAgICAgICBfdGhpcy4kb3AgPSAnc2F2ZSc7XG4gICAgICAgICAgICBuZXh0KGVycm9yKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbmV4dCgpO1xuICAgIH1cbiAgfSwgbnVsbCwgdW5zaGlmdCk7XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../server/node_modules/mongoose/lib/plugins/validateBeforeSave.js\n");

/***/ }),

/***/ "../server/node_modules/mongoose/lib/query.js":
/*!****************************************************!*\
  !*** ../server/node_modules/mongoose/lib/query.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\n/*!\n * Module dependencies.\n */\n\nconst CastError = __webpack_require__(/*! ./error/cast */ \"../server/node_modules/mongoose/lib/error/cast.js\");\nconst DocumentNotFoundError = __webpack_require__(/*! ./error/notFound */ \"../server/node_modules/mongoose/lib/error/notFound.js\");\nconst Kareem = __webpack_require__(/*! kareem */ \"../server/node_modules/kareem/index.js\");\nconst MongooseError = __webpack_require__(/*! ./error/mongooseError */ \"../server/node_modules/mongoose/lib/error/mongooseError.js\");\nconst ObjectParameterError = __webpack_require__(/*! ./error/objectParameter */ \"../server/node_modules/mongoose/lib/error/objectParameter.js\");\nconst QueryCursor = __webpack_require__(/*! ./cursor/queryCursor */ \"../server/node_modules/mongoose/lib/cursor/queryCursor.js\");\nconst ValidationError = __webpack_require__(/*! ./error/validation */ \"../server/node_modules/mongoose/lib/error/validation.js\");\nconst { applyGlobalMaxTimeMS, applyGlobalDiskUse } = __webpack_require__(/*! ./helpers/query/applyGlobalOption */ \"../server/node_modules/mongoose/lib/helpers/query/applyGlobalOption.js\");\nconst handleReadPreferenceAliases = __webpack_require__(/*! ./helpers/query/handleReadPreferenceAliases */ \"../server/node_modules/mongoose/lib/helpers/query/handleReadPreferenceAliases.js\");\nconst applyWriteConcern = __webpack_require__(/*! ./helpers/schema/applyWriteConcern */ \"../server/node_modules/mongoose/lib/helpers/schema/applyWriteConcern.js\");\nconst cast = __webpack_require__(/*! ./cast */ \"../server/node_modules/mongoose/lib/cast.js\");\nconst castArrayFilters = __webpack_require__(/*! ./helpers/update/castArrayFilters */ \"../server/node_modules/mongoose/lib/helpers/update/castArrayFilters.js\");\nconst castNumber = __webpack_require__(/*! ./cast/number */ \"../server/node_modules/mongoose/lib/cast/number.js\");\nconst castUpdate = __webpack_require__(/*! ./helpers/query/castUpdate */ \"../server/node_modules/mongoose/lib/helpers/query/castUpdate.js\");\nconst clone = __webpack_require__(/*! ./helpers/clone */ \"../server/node_modules/mongoose/lib/helpers/clone.js\");\nconst getDiscriminatorByValue = __webpack_require__(/*! ./helpers/discriminator/getDiscriminatorByValue */ \"../server/node_modules/mongoose/lib/helpers/discriminator/getDiscriminatorByValue.js\");\nconst helpers = __webpack_require__(/*! ./queryHelpers */ \"../server/node_modules/mongoose/lib/queryHelpers.js\");\nconst immediate = __webpack_require__(/*! ./helpers/immediate */ \"../server/node_modules/mongoose/lib/helpers/immediate.js\");\nconst internalToObjectOptions = (__webpack_require__(/*! ./options */ \"../server/node_modules/mongoose/lib/options.js\").internalToObjectOptions);\nconst isExclusive = __webpack_require__(/*! ./helpers/projection/isExclusive */ \"../server/node_modules/mongoose/lib/helpers/projection/isExclusive.js\");\nconst isInclusive = __webpack_require__(/*! ./helpers/projection/isInclusive */ \"../server/node_modules/mongoose/lib/helpers/projection/isInclusive.js\");\nconst isPathSelectedInclusive = __webpack_require__(/*! ./helpers/projection/isPathSelectedInclusive */ \"../server/node_modules/mongoose/lib/helpers/projection/isPathSelectedInclusive.js\");\nconst isSubpath = __webpack_require__(/*! ./helpers/projection/isSubpath */ \"../server/node_modules/mongoose/lib/helpers/projection/isSubpath.js\");\nconst mpath = __webpack_require__(/*! mpath */ \"../server/node_modules/mpath/index.js\");\nconst mquery = __webpack_require__(/*! mquery */ \"../server/node_modules/mquery/lib/mquery.js\");\nconst parseProjection = __webpack_require__(/*! ./helpers/projection/parseProjection */ \"../server/node_modules/mongoose/lib/helpers/projection/parseProjection.js\");\nconst removeUnusedArrayFilters = __webpack_require__(/*! ./helpers/update/removeUnusedArrayFilters */ \"../server/node_modules/mongoose/lib/helpers/update/removeUnusedArrayFilters.js\");\nconst sanitizeFilter = __webpack_require__(/*! ./helpers/query/sanitizeFilter */ \"../server/node_modules/mongoose/lib/helpers/query/sanitizeFilter.js\");\nconst sanitizeProjection = __webpack_require__(/*! ./helpers/query/sanitizeProjection */ \"../server/node_modules/mongoose/lib/helpers/query/sanitizeProjection.js\");\nconst selectPopulatedFields = __webpack_require__(/*! ./helpers/query/selectPopulatedFields */ \"../server/node_modules/mongoose/lib/helpers/query/selectPopulatedFields.js\");\nconst setDefaultsOnInsert = __webpack_require__(/*! ./helpers/setDefaultsOnInsert */ \"../server/node_modules/mongoose/lib/helpers/setDefaultsOnInsert.js\");\nconst specialProperties = __webpack_require__(/*! ./helpers/specialProperties */ \"../server/node_modules/mongoose/lib/helpers/specialProperties.js\");\nconst updateValidators = __webpack_require__(/*! ./helpers/updateValidators */ \"../server/node_modules/mongoose/lib/helpers/updateValidators.js\");\nconst util = __webpack_require__(/*! util */ \"util\");\nconst utils = __webpack_require__(/*! ./utils */ \"../server/node_modules/mongoose/lib/utils.js\");\nconst queryMiddlewareFunctions = (__webpack_require__(/*! ./constants */ \"../server/node_modules/mongoose/lib/constants.js\").queryMiddlewareFunctions);\n\nconst queryOptionMethods = new Set([\n  'allowDiskUse',\n  'batchSize',\n  'collation',\n  'comment',\n  'explain',\n  'hint',\n  'j',\n  'lean',\n  'limit',\n  'maxTimeMS',\n  'populate',\n  'projection',\n  'read',\n  'select',\n  'skip',\n  'slice',\n  'sort',\n  'tailable',\n  'w',\n  'writeConcern',\n  'wtimeout'\n]);\n\n/**\n * Query constructor used for building queries. You do not need\n * to instantiate a `Query` directly. Instead use Model functions like\n * [`Model.find()`](https://mongoosejs.com/docs/api/model.html#Model.find()).\n *\n * #### Example:\n *\n *     const query = MyModel.find(); // `query` is an instance of `Query`\n *     query.setOptions({ lean : true });\n *     query.collection(MyModel.collection);\n *     query.where('age').gte(21).exec(callback);\n *\n *     // You can instantiate a query directly. There is no need to do\n *     // this unless you're an advanced user with a very good reason to.\n *     const query = new mongoose.Query();\n *\n * @param {Object} [options]\n * @param {Object} [model]\n * @param {Object} [conditions]\n * @param {Object} [collection] Mongoose collection\n * @api public\n */\n\nfunction Query(conditions, options, model, collection) {\n  // this stuff is for dealing with custom queries created by #toConstructor\n  if (!this._mongooseOptions) {\n    this._mongooseOptions = {};\n  }\n  options = options || {};\n\n  this._transforms = [];\n  this._hooks = new Kareem();\n  this._executionStack = null;\n\n  // this is the case where we have a CustomQuery, we need to check if we got\n  // options passed in, and if we did, merge them in\n  const keys = Object.keys(options);\n  for (const key of keys) {\n    this._mongooseOptions[key] = options[key];\n  }\n\n  if (collection) {\n    this.mongooseCollection = collection;\n  }\n\n  if (model) {\n    this.model = model;\n    this.schema = model.schema;\n  }\n\n  // this is needed because map reduce returns a model that can be queried, but\n  // all of the queries on said model should be lean\n  if (this.model && this.model._mapreduce) {\n    this.lean();\n  }\n\n  // inherit mquery\n  mquery.call(this, null, options);\n  if (collection) {\n    this.collection(collection);\n  }\n\n  if (conditions) {\n    this.find(conditions);\n  }\n\n  this.options = this.options || {};\n\n  // For gh-6880. mquery still needs to support `fields` by default for old\n  // versions of MongoDB\n  this.$useProjection = true;\n\n  const collation = this &&\n    this.schema &&\n    this.schema.options &&\n    this.schema.options.collation || null;\n  if (collation != null) {\n    this.options.collation = collation;\n  }\n}\n\n/*!\n * inherit mquery\n */\n\nQuery.prototype = new mquery();\nQuery.prototype.constructor = Query;\nQuery.base = mquery.prototype;\n\n/*!\n * Overwrite mquery's `_distinct`, because Mongoose uses that name\n * to store the field to apply distinct on.\n */\n\nObject.defineProperty(Query.prototype, '_distinct', {\n  configurable: true,\n  writable: true,\n  enumerable: true,\n  value: undefined\n});\n\n/**\n * Flag to opt out of using `$geoWithin`.\n *\n * ```javascript\n * mongoose.Query.use$geoWithin = false;\n * ```\n *\n * MongoDB 2.4 deprecated the use of `$within`, replacing it with `$geoWithin`. Mongoose uses `$geoWithin` by default (which is 100% backward compatible with `$within`). If you are running an older version of MongoDB, set this flag to `false` so your `within()` queries continue to work.\n *\n * @see geoWithin https://www.mongodb.com/docs/manual/reference/operator/geoWithin/\n * @default true\n * @property use$geoWithin\n * @memberOf Query\n * @static\n * @api public\n */\n\nQuery.use$geoWithin = mquery.use$geoWithin;\n\n/**\n * Converts this query to a customized, reusable query constructor with all arguments and options retained.\n *\n * #### Example:\n *\n *     // Create a query for adventure movies and read from the primary\n *     // node in the replica-set unless it is down, in which case we'll\n *     // read from a secondary node.\n *     const query = Movie.find({ tags: 'adventure' }).read('primaryPreferred');\n *\n *     // create a custom Query constructor based off these settings\n *     const Adventure = query.toConstructor();\n *\n *     // further narrow down our query results while still using the previous settings\n *     await Adventure().where({ name: /^Life/ }).exec();\n *\n *     // since Adventure is a stand-alone constructor we can also add our own\n *     // helper methods and getters without impacting global queries\n *     Adventure.prototype.startsWith = function (prefix) {\n *       this.where({ name: new RegExp('^' + prefix) })\n *       return this;\n *     }\n *     Object.defineProperty(Adventure.prototype, 'highlyRated', {\n *       get: function () {\n *         this.where({ rating: { $gt: 4.5 }});\n *         return this;\n *       }\n *     })\n *     await Adventure().highlyRated.startsWith('Life').exec();\n *\n * @return {Query} subclass-of-Query\n * @api public\n */\n\nQuery.prototype.toConstructor = function toConstructor() {\n  const model = this.model;\n  const coll = this.mongooseCollection;\n\n  const CustomQuery = function(criteria, options) {\n    if (!(this instanceof CustomQuery)) {\n      return new CustomQuery(criteria, options);\n    }\n    this._mongooseOptions = clone(p._mongooseOptions);\n    Query.call(this, criteria, options || null, model, coll);\n  };\n\n  util.inherits(CustomQuery, model.Query);\n\n  // set inherited defaults\n  const p = CustomQuery.prototype;\n\n  p.options = {};\n\n  // Need to handle `sort()` separately because entries-style `sort()` syntax\n  // `sort([['prop1', 1]])` confuses mquery into losing the outer nested array.\n  // See gh-8159\n  const options = Object.assign({}, this.options);\n  if (options.sort != null) {\n    p.sort(options.sort);\n    delete options.sort;\n  }\n  p.setOptions(options);\n\n  p.op = this.op;\n  p._validateOp();\n  p._conditions = clone(this._conditions);\n  p._fields = clone(this._fields);\n  p._update = clone(this._update, {\n    flattenDecimals: false\n  });\n  p._path = this._path;\n  p._distinct = this._distinct;\n  p._collection = this._collection;\n  p._mongooseOptions = this._mongooseOptions;\n\n  return CustomQuery;\n};\n\n/**\n * Make a copy of this query so you can re-execute it.\n *\n * #### Example:\n *\n *     const q = Book.findOne({ title: 'Casino Royale' });\n *     await q.exec();\n *     await q.exec(); // Throws an error because you can't execute a query twice\n *\n *     await q.clone().exec(); // Works\n *\n * @method clone\n * @return {Query} copy\n * @memberOf Query\n * @instance\n * @api public\n */\n\nQuery.prototype.clone = function() {\n  const model = this.model;\n  const collection = this.mongooseCollection;\n\n  const q = new this.model.Query({}, {}, model, collection);\n\n  // Need to handle `sort()` separately because entries-style `sort()` syntax\n  // `sort([['prop1', 1]])` confuses mquery into losing the outer nested array.\n  // See gh-8159\n  const options = Object.assign({}, this.options);\n  if (options.sort != null) {\n    q.sort(options.sort);\n    delete options.sort;\n  }\n  q.setOptions(options);\n\n  q.op = this.op;\n  q._validateOp();\n  q._conditions = clone(this._conditions);\n  q._fields = clone(this._fields);\n  q._update = clone(this._update, {\n    flattenDecimals: false\n  });\n  q._path = this._path;\n  q._distinct = this._distinct;\n  q._collection = this._collection;\n  q._mongooseOptions = this._mongooseOptions;\n\n  return q;\n};\n\n/**\n * Specifies a javascript function or expression to pass to MongoDBs query system.\n *\n * #### Example:\n *\n *     query.$where('this.comments.length === 10 || this.name.length === 5')\n *\n *     // or\n *\n *     query.$where(function () {\n *       return this.comments.length === 10 || this.name.length === 5;\n *     })\n *\n * #### Note:\n *\n * Only use `$where` when you have a condition that cannot be met using other MongoDB operators like `$lt`.\n * **Be sure to read about all of [its caveats](https://www.mongodb.com/docs/manual/reference/operator/where/) before using.**\n *\n * @see $where https://www.mongodb.com/docs/manual/reference/operator/where/\n * @method $where\n * @param {String|Function} js javascript string or function\n * @return {Query} this\n * @memberOf Query\n * @instance\n * @method $where\n * @api public\n */\n\n/**\n * Specifies a `path` for use with chaining.\n *\n * #### Example:\n *\n *     // instead of writing:\n *     User.find({age: {$gte: 21, $lte: 65}});\n *\n *     // we can instead write:\n *     User.where('age').gte(21).lte(65);\n *\n *     // passing query conditions is permitted\n *     User.find().where({ name: 'vonderful' })\n *\n *     // chaining\n *     User\n *     .where('age').gte(21).lte(65)\n *     .where('name', /^vonderful/i)\n *     .where('friends').slice(10)\n *     .exec()\n *\n * @method where\n * @memberOf Query\n * @instance\n * @param {String|Object} [path]\n * @param {any} [val]\n * @return {Query} this\n * @api public\n */\n\n/**\n * Specifies a `$slice` projection for an array.\n *\n * #### Example:\n *\n *     query.slice('comments', 5); // Returns the first 5 comments\n *     query.slice('comments', -5); // Returns the last 5 comments\n *     query.slice('comments', [10, 5]); // Returns the first 5 comments after the 10-th\n *     query.where('comments').slice(5); // Returns the first 5 comments\n *     query.where('comments').slice([-10, 5]); // Returns the first 5 comments after the 10-th to last\n *\n * **Note:** If the absolute value of the number of elements to be sliced is greater than the number of elements in the array, all array elements will be returned.\n *\n *      // Given `arr`: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n *      query.slice('arr', 20); // Returns [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n *      query.slice('arr', -20); // Returns [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n *\n * **Note:** If the number of elements to skip is positive and greater than the number of elements in the array, an empty array will be returned.\n *\n *      // Given `arr`: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n *      query.slice('arr', [20, 5]); // Returns []\n *\n * **Note:** If the number of elements to skip is negative and its absolute value is greater than the number of elements in the array, the starting position is the start of the array.\n *\n *      // Given `arr`: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n *      query.slice('arr', [-20, 5]); // Returns [1, 2, 3, 4, 5]\n *\n * @method slice\n * @memberOf Query\n * @instance\n * @param {String} [path]\n * @param {Number|Array} val number of elements to slice or array with number of elements to skip and number of elements to slice\n * @return {Query} this\n * @see mongodb https://www.mongodb.com/docs/manual/tutorial/query-documents/#projection\n * @see $slice https://www.mongodb.com/docs/manual/reference/projection/slice/#prj._S_slice\n * @api public\n */\n\nQuery.prototype.slice = function() {\n  if (arguments.length === 0) {\n    return this;\n  }\n\n  this._validate('slice');\n\n  let path;\n  let val;\n\n  if (arguments.length === 1) {\n    const arg = arguments[0];\n    if (typeof arg === 'object' && !Array.isArray(arg)) {\n      const keys = Object.keys(arg);\n      const numKeys = keys.length;\n      for (let i = 0; i < numKeys; ++i) {\n        this.slice(keys[i], arg[keys[i]]);\n      }\n      return this;\n    }\n    this._ensurePath('slice');\n    path = this._path;\n    val = arguments[0];\n  } else if (arguments.length === 2) {\n    if ('number' === typeof arguments[0]) {\n      this._ensurePath('slice');\n      path = this._path;\n      val = [arguments[0], arguments[1]];\n    } else {\n      path = arguments[0];\n      val = arguments[1];\n    }\n  } else if (arguments.length === 3) {\n    path = arguments[0];\n    val = [arguments[1], arguments[2]];\n  }\n\n  const p = {};\n  p[path] = { $slice: val };\n  this.select(p);\n\n  return this;\n};\n\n/*!\n * ignore\n */\n\nconst validOpsSet = new Set(queryMiddlewareFunctions);\n\nQuery.prototype._validateOp = function() {\n  if (this.op != null && !validOpsSet.has(this.op)) {\n    this.error(new Error('Query has invalid `op`: \"' + this.op + '\"'));\n  }\n};\n\n/**\n * Specifies the complementary comparison value for paths specified with `where()`\n *\n * #### Example:\n *\n *     User.where('age').equals(49);\n *\n *     // is the same as\n *\n *     User.where('age', 49);\n *\n * @method equals\n * @memberOf Query\n * @instance\n * @param {Object} val\n * @return {Query} this\n * @api public\n */\n\n/**\n * Specifies arguments for an `$or` condition.\n *\n * #### Example:\n *\n *     query.or([{ color: 'red' }, { status: 'emergency' }]);\n *\n * @see $or https://www.mongodb.com/docs/manual/reference/operator/or/\n * @method or\n * @memberOf Query\n * @instance\n * @param {Array} array array of conditions\n * @return {Query} this\n * @api public\n */\n\n/**\n * Specifies arguments for a `$nor` condition.\n *\n * #### Example:\n *\n *     query.nor([{ color: 'green' }, { status: 'ok' }]);\n *\n * @see $nor https://www.mongodb.com/docs/manual/reference/operator/nor/\n * @method nor\n * @memberOf Query\n * @instance\n * @param {Array} array array of conditions\n * @return {Query} this\n * @api public\n */\n\n/**\n * Specifies arguments for a `$and` condition.\n *\n * #### Example:\n *\n *     query.and([{ color: 'green' }, { status: 'ok' }])\n *\n * @method and\n * @memberOf Query\n * @instance\n * @see $and https://www.mongodb.com/docs/manual/reference/operator/and/\n * @param {Array} array array of conditions\n * @return {Query} this\n * @api public\n */\n\n/**\n * Specifies a `$gt` query condition.\n *\n * When called with one argument, the most recent path passed to `where()` is used.\n *\n * #### Example:\n *\n *     Thing.find().where('age').gt(21);\n *\n *     // or\n *     Thing.find().gt('age', 21);\n *\n * @method gt\n * @memberOf Query\n * @instance\n * @param {String} [path]\n * @param {Number} val\n * @see $gt https://www.mongodb.com/docs/manual/reference/operator/gt/\n * @api public\n */\n\n/**\n * Specifies a `$gte` query condition.\n *\n * When called with one argument, the most recent path passed to `where()` is used.\n *\n * @method gte\n * @memberOf Query\n * @instance\n * @param {String} [path]\n * @param {Number} val\n * @see $gte https://www.mongodb.com/docs/manual/reference/operator/gte/\n * @api public\n */\n\n/**\n * Specifies a `$lt` query condition.\n *\n * When called with one argument, the most recent path passed to `where()` is used.\n *\n * @method lt\n * @memberOf Query\n * @instance\n * @param {String} [path]\n * @param {Number} val\n * @see $lt https://www.mongodb.com/docs/manual/reference/operator/lt/\n * @api public\n */\n\n/**\n * Specifies a `$lte` query condition.\n *\n * When called with one argument, the most recent path passed to `where()` is used.\n *\n * @method lte\n * @see $lte https://www.mongodb.com/docs/manual/reference/operator/lte/\n * @memberOf Query\n * @instance\n * @param {String} [path]\n * @param {Number} val\n * @api public\n */\n\n/**\n * Specifies a `$ne` query condition.\n *\n * When called with one argument, the most recent path passed to `where()` is used.\n *\n * @see $ne https://www.mongodb.com/docs/manual/reference/operator/ne/\n * @method ne\n * @memberOf Query\n * @instance\n * @param {String} [path]\n * @param {any} val\n * @api public\n */\n\n/**\n * Specifies an `$in` query condition.\n *\n * When called with one argument, the most recent path passed to `where()` is used.\n *\n * @see $in https://www.mongodb.com/docs/manual/reference/operator/in/\n * @method in\n * @memberOf Query\n * @instance\n * @param {String} [path]\n * @param {Array} val\n * @api public\n */\n\n/**\n * Specifies an `$nin` query condition.\n *\n * When called with one argument, the most recent path passed to `where()` is used.\n *\n * @see $nin https://www.mongodb.com/docs/manual/reference/operator/nin/\n * @method nin\n * @memberOf Query\n * @instance\n * @param {String} [path]\n * @param {Array} val\n * @api public\n */\n\n/**\n * Specifies an `$all` query condition.\n *\n * When called with one argument, the most recent path passed to `where()` is used.\n *\n * #### Example:\n *\n *     MyModel.find().where('pets').all(['dog', 'cat', 'ferret']);\n *     // Equivalent:\n *     MyModel.find().all('pets', ['dog', 'cat', 'ferret']);\n *\n * @see $all https://www.mongodb.com/docs/manual/reference/operator/all/\n * @method all\n * @memberOf Query\n * @instance\n * @param {String} [path]\n * @param {Array} val\n * @api public\n */\n\n/**\n * Specifies a `$size` query condition.\n *\n * When called with one argument, the most recent path passed to `where()` is used.\n *\n * #### Example:\n *\n *     const docs = await MyModel.where('tags').size(0).exec();\n *     assert(Array.isArray(docs));\n *     console.log('documents with 0 tags', docs);\n *\n * @see $size https://www.mongodb.com/docs/manual/reference/operator/size/\n * @method size\n * @memberOf Query\n * @instance\n * @param {String} [path]\n * @param {Number} val\n * @api public\n */\n\n/**\n * Specifies a `$regex` query condition.\n *\n * When called with one argument, the most recent path passed to `where()` is used.\n *\n * @see $regex https://www.mongodb.com/docs/manual/reference/operator/regex/\n * @method regex\n * @memberOf Query\n * @instance\n * @param {String} [path]\n * @param {String|RegExp} val\n * @api public\n */\n\n/**\n * Specifies a `maxDistance` query condition.\n *\n * When called with one argument, the most recent path passed to `where()` is used.\n *\n * @see $maxDistance https://www.mongodb.com/docs/manual/reference/operator/maxDistance/\n * @method maxDistance\n * @memberOf Query\n * @instance\n * @param {String} [path]\n * @param {Number} val\n * @api public\n */\n\n/**\n * Specifies a `$mod` condition, filters documents for documents whose\n * `path` property is a number that is equal to `remainder` modulo `divisor`.\n *\n * #### Example:\n *\n *     // All find products whose inventory is odd\n *     Product.find().mod('inventory', [2, 1]);\n *     Product.find().where('inventory').mod([2, 1]);\n *     // This syntax is a little strange, but supported.\n *     Product.find().where('inventory').mod(2, 1);\n *\n * @method mod\n * @memberOf Query\n * @instance\n * @param {String} [path]\n * @param {Array} val must be of length 2, first element is `divisor`, 2nd element is `remainder`.\n * @return {Query} this\n * @see $mod https://www.mongodb.com/docs/manual/reference/operator/mod/\n * @api public\n */\n\nQuery.prototype.mod = function() {\n  let val;\n  let path;\n\n  if (arguments.length === 1) {\n    this._ensurePath('mod');\n    val = arguments[0];\n    path = this._path;\n  } else if (arguments.length === 2 && !Array.isArray(arguments[1])) {\n    this._ensurePath('mod');\n    val = [arguments[0], arguments[1]];\n    path = this._path;\n  } else if (arguments.length === 3) {\n    val = [arguments[1], arguments[2]];\n    path = arguments[0];\n  } else {\n    val = arguments[1];\n    path = arguments[0];\n  }\n\n  const conds = this._conditions[path] || (this._conditions[path] = {});\n  conds.$mod = val;\n  return this;\n};\n\n/**\n * Specifies an `$exists` condition\n *\n * #### Example:\n *\n *     // { name: { $exists: true }}\n *     Thing.where('name').exists()\n *     Thing.where('name').exists(true)\n *     Thing.find().exists('name')\n *\n *     // { name: { $exists: false }}\n *     Thing.where('name').exists(false);\n *     Thing.find().exists('name', false);\n *\n * @method exists\n * @memberOf Query\n * @instance\n * @param {String} [path]\n * @param {Boolean} val\n * @return {Query} this\n * @see $exists https://www.mongodb.com/docs/manual/reference/operator/exists/\n * @api public\n */\n\n/**\n * Specifies an `$elemMatch` condition\n *\n * #### Example:\n *\n *     query.elemMatch('comment', { author: 'autobot', votes: {$gte: 5}})\n *\n *     query.where('comment').elemMatch({ author: 'autobot', votes: {$gte: 5}})\n *\n *     query.elemMatch('comment', function (elem) {\n *       elem.where('author').equals('autobot');\n *       elem.where('votes').gte(5);\n *     })\n *\n *     query.where('comment').elemMatch(function (elem) {\n *       elem.where({ author: 'autobot' });\n *       elem.where('votes').gte(5);\n *     })\n *\n * @method elemMatch\n * @memberOf Query\n * @instance\n * @param {String|Object|Function} path\n * @param {Object|Function} filter\n * @return {Query} this\n * @see $elemMatch https://www.mongodb.com/docs/manual/reference/operator/elemMatch/\n * @api public\n */\n\n/**\n * Defines a `$within` or `$geoWithin` argument for geo-spatial queries.\n *\n * #### Example:\n *\n *     query.where(path).within().box()\n *     query.where(path).within().circle()\n *     query.where(path).within().geometry()\n *\n *     query.where('loc').within({ center: [50,50], radius: 10, unique: true, spherical: true });\n *     query.where('loc').within({ box: [[40.73, -73.9], [40.7, -73.988]] });\n *     query.where('loc').within({ polygon: [[],[],[],[]] });\n *\n *     query.where('loc').within([], [], []) // polygon\n *     query.where('loc').within([], []) // box\n *     query.where('loc').within({ type: 'LineString', coordinates: [...] }); // geometry\n *\n * **MUST** be used after `where()`.\n *\n * #### Note:\n *\n * As of Mongoose 3.7, `$geoWithin` is always used for queries. To change this behavior, see [Query.use$geoWithin](https://mongoosejs.com/docs/api/query.html#Query.prototype.use$geoWithin).\n *\n * #### Note:\n *\n * In Mongoose 3.7, `within` changed from a getter to a function. If you need the old syntax, use [this](https://github.com/ebensing/mongoose-within).\n *\n * @method within\n * @see $polygon https://www.mongodb.com/docs/manual/reference/operator/polygon/\n * @see $box https://www.mongodb.com/docs/manual/reference/operator/box/\n * @see $geometry https://www.mongodb.com/docs/manual/reference/operator/geometry/\n * @see $center https://www.mongodb.com/docs/manual/reference/operator/center/\n * @see $centerSphere https://www.mongodb.com/docs/manual/reference/operator/centerSphere/\n * @memberOf Query\n * @instance\n * @return {Query} this\n * @api public\n */\n\n/**\n * Specifies the maximum number of documents the query will return.\n *\n * #### Example:\n *\n *     query.limit(20);\n *\n * #### Note:\n *\n * Cannot be used with `distinct()`\n *\n * @method limit\n * @memberOf Query\n * @instance\n * @param {Number} val\n * @api public\n */\n\nQuery.prototype.limit = function limit(v) {\n  this._validate('limit');\n\n  if (typeof v === 'string') {\n    try {\n      v = castNumber(v);\n    } catch (err) {\n      throw new CastError('Number', v, 'limit');\n    }\n  }\n\n  this.options.limit = v;\n  return this;\n};\n\n/**\n * Specifies the number of documents to skip.\n *\n * #### Example:\n *\n *     query.skip(100).limit(20);\n *\n * #### Note:\n *\n * Cannot be used with `distinct()`\n *\n * @method skip\n * @memberOf Query\n * @instance\n * @param {Number} val\n * @see cursor.skip https://www.mongodb.com/docs/manual/reference/method/cursor.skip/\n * @api public\n */\n\nQuery.prototype.skip = function skip(v) {\n  this._validate('skip');\n\n  if (typeof v === 'string') {\n    try {\n      v = castNumber(v);\n    } catch (err) {\n      throw new CastError('Number', v, 'skip');\n    }\n  }\n\n  this.options.skip = v;\n  return this;\n};\n\n/**\n * Specifies the batchSize option.\n *\n * #### Example:\n *\n *     query.batchSize(100)\n *\n * #### Note:\n *\n * Cannot be used with `distinct()`\n *\n * @method batchSize\n * @memberOf Query\n * @instance\n * @param {Number} val\n * @see batchSize https://www.mongodb.com/docs/manual/reference/method/cursor.batchSize/\n * @api public\n */\n\n/**\n * Specifies the `comment` option.\n *\n * #### Example:\n *\n *     query.comment('login query')\n *\n * #### Note:\n *\n * Cannot be used with `distinct()`\n *\n * @method comment\n * @memberOf Query\n * @instance\n * @param {String} val\n * @see comment https://www.mongodb.com/docs/manual/reference/operator/comment/\n * @api public\n */\n\n/**\n * Sets query hints.\n *\n * #### Example:\n *\n *     query.hint({ indexA: 1, indexB: -1 });\n *\n * #### Note:\n *\n * Cannot be used with `distinct()`\n *\n * @method hint\n * @memberOf Query\n * @instance\n * @param {Object} val a hint object\n * @return {Query} this\n * @see $hint https://www.mongodb.com/docs/manual/reference/operator/hint/\n * @api public\n */\n\n/**\n * Get/set the current projection (AKA fields). Pass `null` to remove the\n * current projection.\n *\n * Unlike `projection()`, the `select()` function modifies the current\n * projection in place. This function overwrites the existing projection.\n *\n * #### Example:\n *\n *     const q = Model.find();\n *     q.projection(); // null\n *\n *     q.select('a b');\n *     q.projection(); // { a: 1, b: 1 }\n *\n *     q.projection({ c: 1 });\n *     q.projection(); // { c: 1 }\n *\n *     q.projection(null);\n *     q.projection(); // null\n *\n *\n * @method projection\n * @memberOf Query\n * @instance\n * @param {Object|null} arg\n * @return {Object} the current projection\n * @api public\n */\n\nQuery.prototype.projection = function(arg) {\n  if (arguments.length === 0) {\n    return this._fields;\n  }\n\n  this._fields = {};\n  this._userProvidedFields = {};\n  this.select(arg);\n  return this._fields;\n};\n\n/**\n * Specifies which document fields to include or exclude (also known as the query \"projection\")\n *\n * When using string syntax, prefixing a path with `-` will flag that path as excluded. When a path does not have the `-` prefix, it is included. Lastly, if a path is prefixed with `+`, it forces inclusion of the path, which is useful for paths excluded at the [schema level](https://mongoosejs.com/docs/api/schematype.html#SchemaType.prototype.select()).\n *\n * A projection _must_ be either inclusive or exclusive. In other words, you must\n * either list the fields to include (which excludes all others), or list the fields\n * to exclude (which implies all other fields are included). The [`_id` field is the only exception because MongoDB includes it by default](https://www.mongodb.com/docs/manual/tutorial/project-fields-from-query-results/#suppress-id-field).\n *\n * #### Example:\n *\n *     // include a and b, exclude other fields\n *     query.select('a b');\n *     // Equivalent syntaxes:\n *     query.select(['a', 'b']);\n *     query.select({ a: 1, b: 1 });\n *\n *     // exclude c and d, include other fields\n *     query.select('-c -d');\n *\n *     // Use `+` to override schema-level `select: false` without making the\n *     // projection inclusive.\n *     const schema = new Schema({\n *       foo: { type: String, select: false },\n *       bar: String\n *     });\n *     // ...\n *     query.select('+foo'); // Override foo's `select: false` without excluding `bar`\n *\n *     // or you may use object notation, useful when\n *     // you have keys already prefixed with a \"-\"\n *     query.select({ a: 1, b: 1 });\n *     query.select({ c: 0, d: 0 });\n *\n *     Additional calls to select can override the previous selection:\n *     query.select({ a: 1, b: 1 }).select({ b: 0 }); // selection is now { a: 1 }\n *     query.select({ a: 0, b: 0 }).select({ b: 1 }); // selection is now { a: 0 }\n *\n *\n * @method select\n * @memberOf Query\n * @instance\n * @param {Object|String|String[]} arg\n * @return {Query} this\n * @see SchemaType https://mongoosejs.com/docs/api/schematype.html\n * @api public\n */\n\nQuery.prototype.select = function select() {\n  let arg = arguments[0];\n  if (!arg) return this;\n\n  if (arguments.length !== 1) {\n    throw new Error('Invalid select: select only takes 1 argument');\n  }\n\n  this._validate('select');\n\n  const fields = this._fields || (this._fields = {});\n  const userProvidedFields = this._userProvidedFields || (this._userProvidedFields = {});\n  let sanitizeProjection = undefined;\n  if (this.model != null && utils.hasUserDefinedProperty(this.model.db.options, 'sanitizeProjection')) {\n    sanitizeProjection = this.model.db.options.sanitizeProjection;\n  } else if (this.model != null && utils.hasUserDefinedProperty(this.model.base.options, 'sanitizeProjection')) {\n    sanitizeProjection = this.model.base.options.sanitizeProjection;\n  } else {\n    sanitizeProjection = this._mongooseOptions.sanitizeProjection;\n  }\n\n  function sanitizeValue(value) {\n    return typeof value === 'string' && sanitizeProjection ? value = 1 : value;\n  }\n  arg = parseProjection(arg, true); // we want to keep the minus and pluses, so add boolean arg.\n  if (utils.isObject(arg)) {\n    if (this.selectedInclusively()) {\n      Object.entries(arg).forEach(([key, value]) => {\n        if (value) {\n          // Add the field to the projection\n          if (fields['-' + key] != null) {\n            delete fields['-' + key];\n          }\n          fields[key] = userProvidedFields[key] = sanitizeValue(value);\n        } else {\n          // Remove the field from the projection\n          Object.keys(userProvidedFields).forEach(field => {\n            if (isSubpath(key, field)) {\n              delete fields[field];\n              delete userProvidedFields[field];\n            }\n          });\n        }\n      });\n    } else if (this.selectedExclusively()) {\n      Object.entries(arg).forEach(([key, value]) => {\n        if (!value) {\n          // Add the field to the projection\n          if (fields['+' + key] != null) {\n            delete fields['+' + key];\n          }\n          fields[key] = userProvidedFields[key] = sanitizeValue(value);\n        } else {\n          // Remove the field from the projection\n          Object.keys(userProvidedFields).forEach(field => {\n            if (isSubpath(key, field)) {\n              delete fields[field];\n              delete userProvidedFields[field];\n            }\n          });\n        }\n      });\n    } else {\n      const keys = Object.keys(arg);\n      for (let i = 0; i < keys.length; ++i) {\n        const value = arg[keys[i]];\n        const key = keys[i];\n        fields[key] = sanitizeValue(value);\n        userProvidedFields[key] = sanitizeValue(value);\n      }\n    }\n\n    return this;\n  }\n\n  throw new TypeError('Invalid select() argument. Must be string or object.');\n};\n\n/**\n * Determines the MongoDB nodes from which to read.\n *\n * #### Preferences:\n *\n * ```\n * primary - (default) Read from primary only. Operations will produce an error if primary is unavailable. Cannot be combined with tags.\n * secondary            Read from secondary if available, otherwise error.\n * primaryPreferred     Read from primary if available, otherwise a secondary.\n * secondaryPreferred   Read from a secondary if available, otherwise read from the primary.\n * nearest              All operations read from among the nearest candidates, but unlike other modes, this option will include both the primary and all secondaries in the random selection.\n * ```\n *\n * Aliases\n *\n * ```\n * p   primary\n * pp  primaryPreferred\n * s   secondary\n * sp  secondaryPreferred\n * n   nearest\n * ```\n *\n * #### Example:\n *\n *     new Query().read('primary')\n *     new Query().read('p')  // same as primary\n *\n *     new Query().read('primaryPreferred')\n *     new Query().read('pp') // same as primaryPreferred\n *\n *     new Query().read('secondary')\n *     new Query().read('s')  // same as secondary\n *\n *     new Query().read('secondaryPreferred')\n *     new Query().read('sp') // same as secondaryPreferred\n *\n *     new Query().read('nearest')\n *     new Query().read('n')  // same as nearest\n *\n *     // read from secondaries with matching tags\n *     new Query().read('s', [{ dc:'sf', s: 1 },{ dc:'ma', s: 2 }])\n *\n * Read more about how to use read preferences [here](https://www.mongodb.com/docs/manual/applications/replication/#read-preference).\n *\n * @method read\n * @memberOf Query\n * @instance\n * @param {String} mode one of the listed preference options or aliases\n * @param {Array} [tags] optional tags for this query\n * @see mongodb https://www.mongodb.com/docs/manual/applications/replication/#read-preference\n * @return {Query} this\n * @api public\n */\n\nQuery.prototype.read = function read(mode, tags) {\n  if (typeof mode === 'string') {\n    mode = handleReadPreferenceAliases(mode);\n    this.options.readPreference = { mode, tags };\n  } else {\n    this.options.readPreference = mode;\n  }\n  return this;\n};\n\n/**\n * Overwrite default `.toString` to make logging more useful\n *\n * @memberOf Query\n * @instance\n * @method toString\n * @api private\n */\n\nQuery.prototype.toString = function toString() {\n  if (this.op === 'count' ||\n      this.op === 'countDocuments' ||\n      this.op === 'find' ||\n      this.op === 'findOne' ||\n      this.op === 'deleteMany' ||\n      this.op === 'deleteOne' ||\n      this.op === 'findOneAndDelete' ||\n      this.op === 'remove') {\n    return `${this.model.modelName}.${this.op}(${util.inspect(this._conditions)})`;\n  }\n  if (this.op === 'distinct') {\n    return `${this.model.modelName}.distinct('${this._distinct}', ${util.inspect(this._conditions)})`;\n  }\n  if (this.op === 'findOneAndReplace' ||\n      this.op === 'findOneAndUpdate' ||\n      this.op === 'replaceOne' ||\n      this.op === 'update' ||\n      this.op === 'updateMany' ||\n      this.op === 'updateOne') {\n    return `${this.model.modelName}.${this.op}(${util.inspect(this._conditions)}, ${util.inspect(this._update)})`;\n  }\n\n  // 'estimatedDocumentCount' or any others\n  return `${this.model.modelName}.${this.op}()`;\n};\n\n/**\n * Sets the [MongoDB session](https://www.mongodb.com/docs/manual/reference/server-sessions/)\n * associated with this query. Sessions are how you mark a query as part of a\n * [transaction](https://mongoosejs.com/docs/transactions.html).\n *\n * Calling `session(null)` removes the session from this query.\n *\n * #### Example:\n *\n *     const s = await mongoose.startSession();\n *     await mongoose.model('Person').findOne({ name: 'Axl Rose' }).session(s);\n *\n * @method session\n * @memberOf Query\n * @instance\n * @param {ClientSession} [session] from `await conn.startSession()`\n * @see Connection.prototype.startSession() https://mongoosejs.com/docs/api/connection.html#Connection.prototype.startSession()\n * @see mongoose.startSession() https://mongoosejs.com/docs/api/mongoose.html#Mongoose.prototype.startSession()\n * @return {Query} this\n * @api public\n */\n\nQuery.prototype.session = function session(v) {\n  if (v == null) {\n    delete this.options.session;\n  }\n  this.options.session = v;\n  return this;\n};\n\n/**\n * Sets the 3 write concern parameters for this query:\n *\n * - `w`: Sets the specified number of `mongod` servers, or tag set of `mongod` servers, that must acknowledge this write before this write is considered successful.\n * - `j`: Boolean, set to `true` to request acknowledgement that this operation has been persisted to MongoDB's on-disk journal.\n * - `wtimeout`: If [`w > 1`](https://mongoosejs.com/docs/api/query.html#Query.prototype.w()), the maximum amount of time to wait for this write to propagate through the replica set before this operation fails. The default is `0`, which means no timeout.\n *\n * This option is only valid for operations that write to the database:\n *\n * - `deleteOne()`\n * - `deleteMany()`\n * - `findOneAndDelete()`\n * - `findOneAndReplace()`\n * - `findOneAndUpdate()`\n * - `updateOne()`\n * - `updateMany()`\n *\n * Defaults to the schema's [`writeConcern` option](https://mongoosejs.com/docs/guide.html#writeConcern)\n *\n * #### Example:\n *\n *     // The 'majority' option means the `deleteOne()` promise won't resolve\n *     // until the `deleteOne()` has propagated to the majority of the replica set\n *     await mongoose.model('Person').\n *       deleteOne({ name: 'Ned Stark' }).\n *       writeConcern({ w: 'majority' });\n *\n * @method writeConcern\n * @memberOf Query\n * @instance\n * @param {Object} writeConcern the write concern value to set\n * @see WriteConcernSettings https://mongodb.github.io/node-mongodb-native/4.9/interfaces/WriteConcernSettings.html\n * @return {Query} this\n * @api public\n */\n\nQuery.prototype.writeConcern = function writeConcern(val) {\n  if (val == null) {\n    delete this.options.writeConcern;\n    return this;\n  }\n  this.options.writeConcern = val;\n  return this;\n};\n\n/**\n * Sets the specified number of `mongod` servers, or tag set of `mongod` servers,\n * that must acknowledge this write before this write is considered successful.\n * This option is only valid for operations that write to the database:\n *\n * - `deleteOne()`\n * - `deleteMany()`\n * - `findOneAndDelete()`\n * - `findOneAndReplace()`\n * - `findOneAndUpdate()`\n * - `updateOne()`\n * - `updateMany()`\n *\n * Defaults to the schema's [`writeConcern.w` option](https://mongoosejs.com/docs/guide.html#writeConcern)\n *\n * #### Example:\n *\n *     // The 'majority' option means the `deleteOne()` promise won't resolve\n *     // until the `deleteOne()` has propagated to the majority of the replica set\n *     await mongoose.model('Person').\n *       deleteOne({ name: 'Ned Stark' }).\n *       w('majority');\n *\n * @method w\n * @memberOf Query\n * @instance\n * @param {String|number} val 0 for fire-and-forget, 1 for acknowledged by one server, 'majority' for majority of the replica set, or [any of the more advanced options](https://www.mongodb.com/docs/manual/reference/write-concern/#w-option).\n * @see mongodb https://www.mongodb.com/docs/manual/reference/write-concern/#w-option\n * @return {Query} this\n * @api public\n */\n\nQuery.prototype.w = function w(val) {\n  if (val == null) {\n    delete this.options.w;\n  }\n  if (this.options.writeConcern != null) {\n    this.options.writeConcern.w = val;\n  } else {\n    this.options.w = val;\n  }\n  return this;\n};\n\n/**\n * Requests acknowledgement that this operation has been persisted to MongoDB's\n * on-disk journal.\n * This option is only valid for operations that write to the database:\n *\n * - `deleteOne()`\n * - `deleteMany()`\n * - `findOneAndDelete()`\n * - `findOneAndReplace()`\n * - `findOneAndUpdate()`\n * - `updateOne()`\n * - `updateMany()`\n *\n * Defaults to the schema's [`writeConcern.j` option](https://mongoosejs.com/docs/guide.html#writeConcern)\n *\n * #### Example:\n *\n *     await mongoose.model('Person').deleteOne({ name: 'Ned Stark' }).j(true);\n *\n * @method j\n * @memberOf Query\n * @instance\n * @param {boolean} val\n * @see mongodb https://www.mongodb.com/docs/manual/reference/write-concern/#j-option\n * @return {Query} this\n * @api public\n */\n\nQuery.prototype.j = function j(val) {\n  if (val == null) {\n    delete this.options.j;\n  }\n  if (this.options.writeConcern != null) {\n    this.options.writeConcern.j = val;\n  } else {\n    this.options.j = val;\n  }\n  return this;\n};\n\n/**\n * If [`w > 1`](https://mongoosejs.com/docs/api/query.html#Query.prototype.w()), the maximum amount of time to\n * wait for this write to propagate through the replica set before this\n * operation fails. The default is `0`, which means no timeout.\n *\n * This option is only valid for operations that write to the database:\n *\n * - `deleteOne()`\n * - `deleteMany()`\n * - `findOneAndDelete()`\n * - `findOneAndReplace()`\n * - `findOneAndUpdate()`\n * - `updateOne()`\n * - `updateMany()`\n *\n * Defaults to the schema's [`writeConcern.wtimeout` option](https://mongoosejs.com/docs/guide.html#writeConcern)\n *\n * #### Example:\n *\n *     // The `deleteOne()` promise won't resolve until this `deleteOne()` has\n *     // propagated to at least `w = 2` members of the replica set. If it takes\n *     // longer than 1 second, this `deleteOne()` will fail.\n *     await mongoose.model('Person').\n *       deleteOne({ name: 'Ned Stark' }).\n *       w(2).\n *       wtimeout(1000);\n *\n * @method wtimeout\n * @memberOf Query\n * @instance\n * @param {number} ms number of milliseconds to wait\n * @see mongodb https://www.mongodb.com/docs/manual/reference/write-concern/#wtimeout\n * @return {Query} this\n * @api public\n */\n\nQuery.prototype.wtimeout = function wtimeout(ms) {\n  if (ms == null) {\n    delete this.options.wtimeout;\n  }\n  if (this.options.writeConcern != null) {\n    this.options.writeConcern.wtimeout = ms;\n  } else {\n    this.options.wtimeout = ms;\n  }\n  return this;\n};\n\n/**\n * Sets the readConcern option for the query.\n *\n * #### Example:\n *\n *     new Query().readConcern('local')\n *     new Query().readConcern('l')  // same as local\n *\n *     new Query().readConcern('available')\n *     new Query().readConcern('a')  // same as available\n *\n *     new Query().readConcern('majority')\n *     new Query().readConcern('m')  // same as majority\n *\n *     new Query().readConcern('linearizable')\n *     new Query().readConcern('lz') // same as linearizable\n *\n *     new Query().readConcern('snapshot')\n *     new Query().readConcern('s')  // same as snapshot\n *\n *\n * #### Read Concern Level:\n *\n * ```\n * local         MongoDB 3.2+ The query returns from the instance with no guarantee guarantee that the data has been written to a majority of the replica set members (i.e. may be rolled back).\n * available     MongoDB 3.6+ The query returns from the instance with no guarantee guarantee that the data has been written to a majority of the replica set members (i.e. may be rolled back).\n * majority      MongoDB 3.2+ The query returns the data that has been acknowledged by a majority of the replica set members. The documents returned by the read operation are durable, even in the event of failure.\n * linearizable  MongoDB 3.4+ The query returns data that reflects all successful majority-acknowledged writes that completed prior to the start of the read operation. The query may wait for concurrently executing writes to propagate to a majority of replica set members before returning results.\n * snapshot      MongoDB 4.0+ Only available for operations within multi-document transactions. Upon transaction commit with write concern \"majority\", the transaction operations are guaranteed to have read from a snapshot of majority-committed data.\n * ```\n *\n * Aliases\n *\n * ```\n * l   local\n * a   available\n * m   majority\n * lz  linearizable\n * s   snapshot\n * ```\n *\n * Read more about how to use read concern [here](https://www.mongodb.com/docs/manual/reference/read-concern/).\n *\n * @memberOf Query\n * @method readConcern\n * @param {String} level one of the listed read concern level or their aliases\n * @see mongodb https://www.mongodb.com/docs/manual/reference/read-concern/\n * @return {Query} this\n * @api public\n */\n\n/**\n * Gets query options.\n *\n * #### Example:\n *\n *     const query = new Query();\n *     query.limit(10);\n *     query.setOptions({ maxTimeMS: 1000 });\n *     query.getOptions(); // { limit: 10, maxTimeMS: 1000 }\n *\n * @return {Object} the options\n * @api public\n */\n\nQuery.prototype.getOptions = function() {\n  return this.options;\n};\n\n/**\n * Sets query options. Some options only make sense for certain operations.\n *\n * #### Options:\n *\n * The following options are only for `find()`:\n *\n * - [tailable](https://www.mongodb.com/docs/manual/core/tailable-cursors/)\n * - [limit](https://www.mongodb.com/docs/manual/reference/method/cursor.limit/)\n * - [skip](https://www.mongodb.com/docs/manual/reference/method/cursor.skip/)\n * - [allowDiskUse](https://www.mongodb.com/docs/manual/reference/method/cursor.allowDiskUse/)\n * - [batchSize](https://www.mongodb.com/docs/manual/reference/method/cursor.batchSize/)\n * - [readPreference](https://www.mongodb.com/docs/manual/applications/replication/#read-preference)\n * - [hint](https://www.mongodb.com/docs/manual/reference/method/cursor.hint/)\n * - [comment](https://www.mongodb.com/docs/manual/reference/method/cursor.comment/)\n *\n * The following options are only for write operations: `updateOne()`, `updateMany()`, `replaceOne()`, `findOneAndUpdate()`, and `findByIdAndUpdate()`:\n *\n * - [upsert](https://www.mongodb.com/docs/manual/reference/method/db.collection.update/)\n * - [writeConcern](https://www.mongodb.com/docs/manual/reference/method/db.collection.update/)\n * - [timestamps](https://mongoosejs.com/docs/guide.html#timestamps): If `timestamps` is set in the schema, set this option to `false` to skip timestamps for that particular update. Has no effect if `timestamps` is not enabled in the schema options.\n * - overwriteDiscriminatorKey: allow setting the discriminator key in the update. Will use the correct discriminator schema if the update changes the discriminator key.\n *\n * The following options are only for `find()`, `findOne()`, `findById()`, `findOneAndUpdate()`, `findOneAndReplace()`, `findOneAndDelete()`, and `findByIdAndUpdate()`:\n *\n * - [lean](https://mongoosejs.com/docs/api/query.html#Query.prototype.lean())\n * - [populate](https://mongoosejs.com/docs/populate.html)\n * - [projection](https://mongoosejs.com/docs/api/query.html#Query.prototype.projection())\n * - sanitizeProjection\n * - useBigInt64\n *\n * The following options are only for all operations **except** `updateOne()`, `updateMany()`, `deleteOne()`, and `deleteMany()`:\n *\n * - [maxTimeMS](https://www.mongodb.com/docs/manual/reference/operator/meta/maxTimeMS/)\n *\n * The following options are for `find()`, `findOne()`, `findOneAndUpdate()`, `findOneAndDelete()`, `updateOne()`, and `deleteOne()`:\n *\n * - [sort](https://www.mongodb.com/docs/manual/reference/method/cursor.sort/)\n *\n * The following options are for `findOneAndUpdate()` and `findOneAndDelete()`\n *\n * - includeResultMetadata\n *\n * The following options are for all operations:\n *\n * - [strict](https://mongoosejs.com/docs/guide.html#strict)\n * - [collation](https://www.mongodb.com/docs/manual/reference/collation/)\n * - [session](https://www.mongodb.com/docs/manual/reference/server-sessions/)\n * - [explain](https://www.mongodb.com/docs/manual/reference/method/cursor.explain/)\n *\n * @param {Object} options\n * @return {Query} this\n * @api public\n */\n\nQuery.prototype.setOptions = function(options, overwrite) {\n  // overwrite is only for internal use\n  if (overwrite) {\n    // ensure that _mongooseOptions & options are two different objects\n    this._mongooseOptions = (options && clone(options)) || {};\n    this.options = options || {};\n\n    if ('populate' in options) {\n      this.populate(this._mongooseOptions);\n    }\n    return this;\n  }\n  if (options == null) {\n    return this;\n  }\n  if (typeof options !== 'object') {\n    throw new Error('Options must be an object, got \"' + options + '\"');\n  }\n\n  options = Object.assign({}, options);\n\n  if (Array.isArray(options.populate)) {\n    const populate = options.populate;\n    delete options.populate;\n    const _numPopulate = populate.length;\n    for (let i = 0; i < _numPopulate; ++i) {\n      this.populate(populate[i]);\n    }\n  }\n\n  if ('setDefaultsOnInsert' in options) {\n    this._mongooseOptions.setDefaultsOnInsert = options.setDefaultsOnInsert;\n    delete options.setDefaultsOnInsert;\n  }\n  if ('overwriteDiscriminatorKey' in options) {\n    this._mongooseOptions.overwriteDiscriminatorKey = options.overwriteDiscriminatorKey;\n    delete options.overwriteDiscriminatorKey;\n  }\n  if ('sanitizeProjection' in options) {\n    if (options.sanitizeProjection && !this._mongooseOptions.sanitizeProjection) {\n      sanitizeProjection(this._fields);\n    }\n\n    this._mongooseOptions.sanitizeProjection = options.sanitizeProjection;\n    delete options.sanitizeProjection;\n  }\n  if ('sanitizeFilter' in options) {\n    this._mongooseOptions.sanitizeFilter = options.sanitizeFilter;\n    delete options.sanitizeFilter;\n  }\n  if ('timestamps' in options) {\n    this._mongooseOptions.timestamps = options.timestamps;\n    delete options.timestamps;\n  }\n  if ('defaults' in options) {\n    this._mongooseOptions.defaults = options.defaults;\n    // deleting options.defaults will cause 7287 to fail\n  }\n  if ('translateAliases' in options) {\n    this._mongooseOptions.translateAliases = options.translateAliases;\n    delete options.translateAliases;\n  }\n\n  if (options.lean == null && this.schema && 'lean' in this.schema.options) {\n    this._mongooseOptions.lean = this.schema.options.lean;\n  }\n\n  if (typeof options.limit === 'string') {\n    try {\n      options.limit = castNumber(options.limit);\n    } catch (err) {\n      throw new CastError('Number', options.limit, 'limit');\n    }\n  }\n  if (typeof options.skip === 'string') {\n    try {\n      options.skip = castNumber(options.skip);\n    } catch (err) {\n      throw new CastError('Number', options.skip, 'skip');\n    }\n  }\n\n  // set arbitrary options\n  for (const key of Object.keys(options)) {\n    if (queryOptionMethods.has(key)) {\n      const args = Array.isArray(options[key]) ?\n        options[key] :\n        [options[key]];\n      this[key].apply(this, args);\n    } else {\n      this.options[key] = options[key];\n    }\n  }\n\n  return this;\n};\n\n/**\n * Sets the [`explain` option](https://www.mongodb.com/docs/manual/reference/method/cursor.explain/),\n * which makes this query return detailed execution stats instead of the actual\n * query result. This method is useful for determining what index your queries\n * use.\n *\n * Calling `query.explain(v)` is equivalent to `query.setOptions({ explain: v })`\n *\n * #### Example:\n *\n *     const query = new Query();\n *     const res = await query.find({ a: 1 }).explain('queryPlanner');\n *     console.log(res);\n *\n * @param {String} [verbose] The verbosity mode. Either 'queryPlanner', 'executionStats', or 'allPlansExecution'. The default is 'queryPlanner'\n * @return {Query} this\n * @api public\n */\n\nQuery.prototype.explain = function explain(verbose) {\n  if (arguments.length === 0) {\n    this.options.explain = true;\n  } else if (verbose === false) {\n    delete this.options.explain;\n  } else {\n    this.options.explain = verbose;\n  }\n  return this;\n};\n\n/**\n * Sets the [`allowDiskUse` option](https://www.mongodb.com/docs/manual/reference/method/cursor.allowDiskUse/),\n * which allows the MongoDB server to use more than 100 MB for this query's `sort()`. This option can\n * let you work around `QueryExceededMemoryLimitNoDiskUseAllowed` errors from the MongoDB server.\n *\n * Note that this option requires MongoDB server >= 4.4. Setting this option is a no-op for MongoDB 4.2\n * and earlier.\n *\n * Calling `query.allowDiskUse(v)` is equivalent to `query.setOptions({ allowDiskUse: v })`\n *\n * #### Example:\n *\n *     await query.find().sort({ name: 1 }).allowDiskUse(true);\n *     // Equivalent:\n *     await query.find().sort({ name: 1 }).allowDiskUse();\n *\n * @param {Boolean} [v] Enable/disable `allowDiskUse`. If called with 0 arguments, sets `allowDiskUse: true`\n * @return {Query} this\n * @api public\n */\n\nQuery.prototype.allowDiskUse = function(v) {\n  if (arguments.length === 0) {\n    this.options.allowDiskUse = true;\n  } else if (v === false) {\n    delete this.options.allowDiskUse;\n  } else {\n    this.options.allowDiskUse = v;\n  }\n  return this;\n};\n\n/**\n * Sets the [maxTimeMS](https://www.mongodb.com/docs/manual/reference/method/cursor.maxTimeMS/)\n * option. This will tell the MongoDB server to abort if the query or write op\n * has been running for more than `ms` milliseconds.\n *\n * Calling `query.maxTimeMS(v)` is equivalent to `query.setOptions({ maxTimeMS: v })`\n *\n * #### Example:\n *\n *     const query = new Query();\n *     // Throws an error 'operation exceeded time limit' as long as there's\n *     // >= 1 doc in the queried collection\n *     const res = await query.find({ $where: 'sleep(1000) || true' }).maxTimeMS(100);\n *\n * @param {Number} [ms] The number of milliseconds\n * @return {Query} this\n * @api public\n */\n\nQuery.prototype.maxTimeMS = function(ms) {\n  this.options.maxTimeMS = ms;\n  return this;\n};\n\n/**\n * Returns the current query filter (also known as conditions) as a [POJO](https://masteringjs.io/tutorials/fundamentals/pojo).\n *\n * #### Example:\n *\n *     const query = new Query();\n *     query.find({ a: 1 }).where('b').gt(2);\n *     query.getFilter(); // { a: 1, b: { $gt: 2 } }\n *\n * @return {Object} current query filter\n * @api public\n */\n\nQuery.prototype.getFilter = function() {\n  return this._conditions;\n};\n\n/**\n * Returns the current query filter. Equivalent to `getFilter()`.\n *\n * You should use `getFilter()` instead of `getQuery()` where possible. `getQuery()`\n * will likely be deprecated in a future release.\n *\n * #### Example:\n *\n *     const query = new Query();\n *     query.find({ a: 1 }).where('b').gt(2);\n *     query.getQuery(); // { a: 1, b: { $gt: 2 } }\n *\n * @return {Object} current query filter\n * @api public\n */\n\nQuery.prototype.getQuery = function() {\n  return this._conditions;\n};\n\n/**\n * Sets the query conditions to the provided JSON object.\n *\n * #### Example:\n *\n *     const query = new Query();\n *     query.find({ a: 1 })\n *     query.setQuery({ a: 2 });\n *     query.getQuery(); // { a: 2 }\n *\n * @param {Object} new query conditions\n * @return {undefined}\n * @api public\n */\n\nQuery.prototype.setQuery = function(val) {\n  this._conditions = val;\n};\n\n/**\n * Returns the current update operations as a JSON object.\n *\n * #### Example:\n *\n *     const query = new Query();\n *     query.updateOne({}, { $set: { a: 5 } });\n *     query.getUpdate(); // { $set: { a: 5 } }\n *\n * @return {Object} current update operations\n * @api public\n */\n\nQuery.prototype.getUpdate = function() {\n  return this._update;\n};\n\n/**\n * Sets the current update operation to new value.\n *\n * #### Example:\n *\n *     const query = new Query();\n *     query.updateOne({}, { $set: { a: 5 } });\n *     query.setUpdate({ $set: { b: 6 } });\n *     query.getUpdate(); // { $set: { b: 6 } }\n *\n * @param {Object} new update operation\n * @return {undefined}\n * @api public\n */\n\nQuery.prototype.setUpdate = function(val) {\n  this._update = val;\n};\n\n/**\n * Returns fields selection for this query.\n *\n * @method _fieldsForExec\n * @return {Object}\n * @api private\n * @memberOf Query\n */\n\nQuery.prototype._fieldsForExec = function() {\n  if (this._fields == null) {\n    return null;\n  }\n  if (Object.keys(this._fields).length === 0) {\n    return null;\n  }\n  return clone(this._fields);\n};\n\n\n/**\n * Return an update document with corrected `$set` operations.\n *\n * @method _updateForExec\n * @return {Object}\n * @api private\n * @memberOf Query\n */\n\nQuery.prototype._updateForExec = function() {\n  const update = clone(this._update, {\n    transform: false,\n    depopulate: true\n  });\n  const ops = Object.keys(update);\n  let i = ops.length;\n  const ret = {};\n\n  while (i--) {\n    const op = ops[i];\n\n    if ('$' !== op[0]) {\n      // fix up $set sugar\n      if (!ret.$set) {\n        if (update.$set) {\n          ret.$set = update.$set;\n        } else {\n          ret.$set = {};\n        }\n      }\n      ret.$set[op] = update[op];\n      ops.splice(i, 1);\n      if (!~ops.indexOf('$set')) ops.push('$set');\n    } else if ('$set' === op) {\n      if (!ret.$set) {\n        ret[op] = update[op];\n      }\n    } else {\n      ret[op] = update[op];\n    }\n  }\n\n  return ret;\n};\n\n/**\n * Makes sure _path is set.\n *\n * This method is inherited by `mquery`\n *\n * @method _ensurePath\n * @param {String} method\n * @api private\n * @memberOf Query\n */\n\n/**\n * Determines if `conds` can be merged using `mquery().merge()`\n *\n * @method canMerge\n * @memberOf Query\n * @instance\n * @param {Object} conds\n * @return {Boolean}\n * @api private\n */\n\n/**\n * Returns default options for this query.\n *\n * @param {Model} model\n * @api private\n */\n\nQuery.prototype._optionsForExec = function(model) {\n  const options = clone(this.options);\n  delete options.populate;\n  model = model || this.model;\n\n  if (!model) {\n    return options;\n  }\n  // Apply schema-level `writeConcern` option\n  applyWriteConcern(model.schema, options);\n\n  const readPreference = model &&\n  model.schema &&\n  model.schema.options &&\n  model.schema.options.read;\n  if (!('readPreference' in options) && readPreference) {\n    options.readPreference = readPreference;\n  }\n\n  if (options.upsert !== void 0) {\n    options.upsert = !!options.upsert;\n  }\n  if (options.writeConcern) {\n    if (options.j) {\n      options.writeConcern.j = options.j;\n      delete options.j;\n    }\n    if (options.w) {\n      options.writeConcern.w = options.w;\n      delete options.w;\n    }\n    if (options.wtimeout) {\n      options.writeConcern.wtimeout = options.wtimeout;\n      delete options.wtimeout;\n    }\n  }\n\n  this._applyPaths();\n  if (this._fields != null) {\n    this._fields = this._castFields(this._fields);\n    const projection = this._fieldsForExec();\n    if (projection != null) {\n      options.projection = projection;\n    }\n  }\n\n  return options;\n};\n\n/**\n * Sets the lean option.\n *\n * Documents returned from queries with the `lean` option enabled are plain\n * javascript objects, not [Mongoose Documents](https://mongoosejs.com/docs/api/document.html). They have no\n * `save` method, getters/setters, virtuals, or other Mongoose features.\n *\n * #### Example:\n *\n *     new Query().lean() // true\n *     new Query().lean(true)\n *     new Query().lean(false)\n *\n *     const docs = await Model.find().lean();\n *     docs[0] instanceof mongoose.Document; // false\n *\n * [Lean is great for high-performance, read-only cases](https://mongoosejs.com/docs/tutorials/lean.html),\n * especially when combined\n * with [cursors](https://mongoosejs.com/docs/queries.html#streaming).\n *\n * If you need virtuals, getters/setters, or defaults with `lean()`, you need\n * to use a plugin. See:\n *\n * - [mongoose-lean-virtuals](https://plugins.mongoosejs.io/plugins/lean-virtuals)\n * - [mongoose-lean-getters](https://plugins.mongoosejs.io/plugins/lean-getters)\n * - [mongoose-lean-defaults](https://www.npmjs.com/package/mongoose-lean-defaults)\n *\n * @param {Boolean|Object} bool defaults to true\n * @return {Query} this\n * @api public\n */\n\nQuery.prototype.lean = function(v) {\n  this._mongooseOptions.lean = arguments.length ? v : true;\n  return this;\n};\n\n/**\n * Adds a `$set` to this query's update without changing the operation.\n * This is useful for query middleware so you can add an update regardless\n * of whether you use `updateOne()`, `updateMany()`, `findOneAndUpdate()`, etc.\n *\n * #### Example:\n *\n *     // Updates `{ $set: { updatedAt: new Date() } }`\n *     new Query().updateOne({}, {}).set('updatedAt', new Date());\n *     new Query().updateMany({}, {}).set({ updatedAt: new Date() });\n *\n * @param {String|Object} path path or object of key/value pairs to set\n * @param {Any} [val] the value to set\n * @return {Query} this\n * @api public\n */\n\nQuery.prototype.set = function(path, val) {\n  if (typeof path === 'object') {\n    const keys = Object.keys(path);\n    for (const key of keys) {\n      this.set(key, path[key]);\n    }\n    return this;\n  }\n\n  this._update = this._update || {};\n  if (path in this._update) {\n    delete this._update[path];\n  }\n  this._update.$set = this._update.$set || {};\n  this._update.$set[path] = val;\n  return this;\n};\n\n/**\n * For update operations, returns the value of a path in the update's `$set`.\n * Useful for writing getters/setters that can work with both update operations\n * and `save()`.\n *\n * #### Example:\n *\n *     const query = Model.updateOne({}, { $set: { name: 'Jean-Luc Picard' } });\n *     query.get('name'); // 'Jean-Luc Picard'\n *\n * @param {String|Object} path path or object of key/value pairs to get\n * @return {Query} this\n * @api public\n */\n\nQuery.prototype.get = function get(path) {\n  const update = this._update;\n  if (update == null) {\n    return void 0;\n  }\n  const $set = update.$set;\n  if ($set == null) {\n    return update[path];\n  }\n\n  if (utils.hasUserDefinedProperty(update, path)) {\n    return update[path];\n  }\n  if (utils.hasUserDefinedProperty($set, path)) {\n    return $set[path];\n  }\n\n  return void 0;\n};\n\n/**\n * Gets/sets the error flag on this query. If this flag is not null or\n * undefined, the `exec()` promise will reject without executing.\n *\n * #### Example:\n *\n *     Query().error(); // Get current error value\n *     Query().error(null); // Unset the current error\n *     Query().error(new Error('test')); // `exec()` will resolve with test\n *     Schema.pre('find', function() {\n *       if (!this.getQuery().userId) {\n *         this.error(new Error('Not allowed to query without setting userId'));\n *       }\n *     });\n *\n * Note that query casting runs **after** hooks, so cast errors will override\n * custom errors.\n *\n * #### Example:\n *\n *     const TestSchema = new Schema({ num: Number });\n *     const TestModel = db.model('Test', TestSchema);\n *     TestModel.find({ num: 'not a number' }).error(new Error('woops')).exec(function(error) {\n *       // `error` will be a cast error because `num` failed to cast\n *     });\n *\n * @param {Error|null} err if set, `exec()` will fail fast before sending the query to MongoDB\n * @return {Query} this\n * @api public\n */\n\nQuery.prototype.error = function error(err) {\n  if (arguments.length === 0) {\n    return this._error;\n  }\n\n  this._error = err;\n  return this;\n};\n\n/**\n * ignore\n * @method _unsetCastError\n * @instance\n * @memberOf Query\n * @api private\n */\n\nQuery.prototype._unsetCastError = function _unsetCastError() {\n  if (this._error != null && !(this._error instanceof CastError)) {\n    return;\n  }\n  return this.error(null);\n};\n\n/**\n * Getter/setter around the current mongoose-specific options for this query\n * Below are the current Mongoose-specific options.\n *\n * - `populate`: an array representing what paths will be populated. Should have one entry for each call to [`Query.prototype.populate()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.populate())\n * - `lean`: if truthy, Mongoose will not [hydrate](https://mongoosejs.com/docs/api/model.html#Model.hydrate()) any documents that are returned from this query. See [`Query.prototype.lean()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.lean()) for more information.\n * - `strict`: controls how Mongoose handles keys that aren't in the schema for updates. This option is `true` by default, which means Mongoose will silently strip any paths in the update that aren't in the schema. See the [`strict` mode docs](https://mongoosejs.com/docs/guide.html#strict) for more information.\n * - `strictQuery`: controls how Mongoose handles keys that aren't in the schema for the query `filter`. This option is `false` by default, which means Mongoose will allow `Model.find({ foo: 'bar' })` even if `foo` is not in the schema. See the [`strictQuery` docs](https://mongoosejs.com/docs/guide.html#strictQuery) for more information.\n * - `nearSphere`: use `$nearSphere` instead of `near()`. See the [`Query.prototype.nearSphere()` docs](https://mongoosejs.com/docs/api/query.html#Query.prototype.nearSphere())\n *\n * Mongoose maintains a separate object for internal options because\n * Mongoose sends `Query.prototype.options` to the MongoDB server, and the\n * above options are not relevant for the MongoDB server.\n *\n * @param {Object} options if specified, overwrites the current options\n * @return {Object} the options\n * @api public\n */\n\nQuery.prototype.mongooseOptions = function(v) {\n  if (arguments.length > 0) {\n    this._mongooseOptions = v;\n  }\n  return this._mongooseOptions;\n};\n\n/**\n * ignore\n * @method _castConditions\n * @memberOf Query\n * @api private\n * @instance\n */\n\nQuery.prototype._castConditions = function() {\n  let sanitizeFilterOpt = undefined;\n  if (this.model != null && utils.hasUserDefinedProperty(this.model.db.options, 'sanitizeFilter')) {\n    sanitizeFilterOpt = this.model.db.options.sanitizeFilter;\n  } else if (this.model != null && utils.hasUserDefinedProperty(this.model.base.options, 'sanitizeFilter')) {\n    sanitizeFilterOpt = this.model.base.options.sanitizeFilter;\n  } else {\n    sanitizeFilterOpt = this._mongooseOptions.sanitizeFilter;\n  }\n\n  if (sanitizeFilterOpt) {\n    sanitizeFilter(this._conditions);\n  }\n\n  try {\n    this.cast(this.model);\n    this._unsetCastError();\n  } catch (err) {\n    this.error(err);\n  }\n};\n\n/*!\n * ignore\n */\n\nfunction _castArrayFilters(query) {\n  try {\n    castArrayFilters(query);\n  } catch (err) {\n    query.error(err);\n  }\n}\n\n/**\n * Execute a `find()`\n *\n * @return {Query} this\n * @api private\n */\nQuery.prototype._find = async function _find() {\n  this._castConditions();\n\n  if (this.error() != null) {\n    throw this.error();\n  }\n\n  const mongooseOptions = this._mongooseOptions;\n  const _this = this;\n  const userProvidedFields = _this._userProvidedFields || {};\n\n  applyGlobalMaxTimeMS(this.options, this.model.db.options, this.model.base.options);\n  applyGlobalDiskUse(this.options, this.model.db.options, this.model.base.options);\n\n  // Separate options to pass down to `completeMany()` in case we need to\n  // set a session on the document\n  const completeManyOptions = Object.assign({}, {\n    session: this && this.options && this.options.session || null,\n    lean: mongooseOptions.lean || null\n  });\n\n  const options = this._optionsForExec();\n\n  this._applyTranslateAliases(options);\n\n  const filter = this._conditions;\n  const fields = options.projection;\n\n  const cursor = await this.mongooseCollection.find(filter, options);\n  if (options.explain) {\n    return cursor.explain();\n  }\n\n  let docs = await cursor.toArray();\n  if (docs.length === 0) {\n    return docs;\n  }\n\n  if (!mongooseOptions.populate) {\n    const versionKey = _this.schema.options.versionKey;\n    if (mongooseOptions.lean && mongooseOptions.lean.versionKey === false && versionKey) {\n      docs.forEach((doc) => {\n        if (versionKey in doc) {\n          delete doc[versionKey];\n        }\n      });\n    }\n    return mongooseOptions.lean ?\n      _completeManyLean(_this.model.schema, docs, null, completeManyOptions) :\n      _this._completeMany(docs, fields, userProvidedFields, completeManyOptions);\n  }\n  const pop = helpers.preparePopulationOptionsMQ(_this, mongooseOptions);\n\n  if (mongooseOptions.lean) {\n    return _this.model.populate(docs, pop);\n  }\n\n  docs = await _this._completeMany(docs, fields, userProvidedFields, completeManyOptions);\n  await this.model.populate(docs, pop);\n\n  return docs;\n};\n\n/**\n * Find all documents that match `selector`. The result will be an array of documents.\n *\n * If there are too many documents in the result to fit in memory, use\n * [`Query.prototype.cursor()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.cursor())\n *\n * #### Example:\n *\n *     const arr = await Movie.find({ year: { $gte: 1980, $lte: 1989 } });\n *\n * @param {Object|ObjectId} [filter] mongodb filter. If not specified, returns all documents.\n * @return {Query} this\n * @api public\n */\n\nQuery.prototype.find = function(conditions) {\n  if (typeof conditions === 'function' ||\n      typeof arguments[1] === 'function') {\n    throw new MongooseError('Query.prototype.find() no longer accepts a callback');\n  }\n\n  this.op = 'find';\n\n  if (mquery.canMerge(conditions)) {\n    this.merge(conditions);\n\n    prepareDiscriminatorCriteria(this);\n  } else if (conditions != null) {\n    this.error(new ObjectParameterError(conditions, 'filter', 'find'));\n  }\n\n  return this;\n};\n\n/**\n * Merges another Query or conditions object into this one.\n *\n * When a Query is passed, conditions, field selection and options are merged.\n *\n * @param {Query|Object} source\n * @return {Query} this\n */\n\nQuery.prototype.merge = function(source) {\n  if (!source) {\n    return this;\n  }\n\n  const opts = { overwrite: true };\n\n  if (source instanceof Query) {\n    // if source has a feature, apply it to ourselves\n\n    if (source._conditions) {\n      opts.omit = {};\n      if (this._conditions && this._conditions.$and && source._conditions.$and) {\n        opts.omit['$and'] = true;\n        this._conditions.$and = this._conditions.$and.concat(source._conditions.$and);\n      }\n      if (this._conditions && this._conditions.$or && source._conditions.$or) {\n        opts.omit['$or'] = true;\n        this._conditions.$or = this._conditions.$or.concat(source._conditions.$or);\n      }\n      utils.merge(this._conditions, source._conditions, opts);\n    }\n\n    if (source._fields) {\n      this._fields || (this._fields = {});\n      utils.merge(this._fields, source._fields, opts);\n    }\n\n    if (source.options) {\n      this.options || (this.options = {});\n      utils.merge(this.options, source.options, opts);\n    }\n\n    if (source._update) {\n      this._update || (this._update = {});\n      utils.mergeClone(this._update, source._update);\n    }\n\n    if (source._distinct) {\n      this._distinct = source._distinct;\n    }\n\n    utils.merge(this._mongooseOptions, source._mongooseOptions);\n\n    return this;\n  } else if (this.model != null && source instanceof this.model.base.Types.ObjectId) {\n    utils.merge(this._conditions, { _id: source }, opts);\n\n    return this;\n  } else if (source && source.$__) {\n    source = source.toObject(internalToObjectOptions);\n  }\n\n  opts.omit = {};\n  if (this._conditions && this._conditions.$and && source.$and) {\n    opts.omit['$and'] = true;\n    this._conditions.$and = this._conditions.$and.concat(source.$and);\n  }\n  if (this._conditions && this._conditions.$or && source.$or) {\n    opts.omit['$or'] = true;\n    this._conditions.$or = this._conditions.$or.concat(source.$or);\n  }\n\n  // plain object\n  utils.merge(this._conditions, source, opts);\n\n  return this;\n};\n\n/**\n * Adds a collation to this op (MongoDB 3.4 and up)\n *\n * @param {Object} value\n * @return {Query} this\n * @see MongoDB docs https://www.mongodb.com/docs/manual/reference/method/cursor.collation/#cursor.collation\n * @api public\n */\n\nQuery.prototype.collation = function(value) {\n  if (this.options == null) {\n    this.options = {};\n  }\n  this.options.collation = value;\n  return this;\n};\n\n/**\n * Hydrate a single doc from `findOne()`, `findOneAndUpdate()`, etc.\n *\n * @api private\n */\n\nQuery.prototype._completeOne = function(doc, res, callback) {\n  if (!doc && !this.options.includeResultMetadata) {\n    return callback(null, null);\n  }\n\n  const model = this.model;\n  const projection = clone(this._fields);\n  const userProvidedFields = this._userProvidedFields || {};\n  // `populate`, `lean`\n  const mongooseOptions = this._mongooseOptions;\n\n  const options = this.options;\n  if (!options.lean && mongooseOptions.lean) {\n    options.lean = mongooseOptions.lean;\n  }\n\n  if (options.explain) {\n    return callback(null, doc);\n  }\n\n  if (!mongooseOptions.populate) {\n    const versionKey = this.schema.options.versionKey;\n    if (mongooseOptions.lean && mongooseOptions.lean.versionKey === false && versionKey) {\n      if (versionKey in doc) {\n        delete doc[versionKey];\n      }\n    }\n    return mongooseOptions.lean ?\n      _completeOneLean(model.schema, doc, null, res, options, callback) :\n      completeOne(model, doc, res, options, projection, userProvidedFields,\n        null, callback);\n  }\n\n  const pop = helpers.preparePopulationOptionsMQ(this, this._mongooseOptions);\n  if (mongooseOptions.lean) {\n    return model.populate(doc, pop).then(\n      doc => {\n        _completeOneLean(model.schema, doc, null, res, options, callback);\n      },\n      error => {\n        callback(error);\n      }\n    );\n  }\n\n  completeOne(model, doc, res, options, projection, userProvidedFields, [], (err, doc) => {\n    if (err != null) {\n      return callback(err);\n    }\n    model.populate(doc, pop).then(res => { callback(null, res); }, err => { callback(err); });\n  });\n};\n\n/**\n * Given a model and an array of docs, hydrates all the docs to be instances\n * of the model. Used to initialize docs returned from the db from `find()`\n *\n * @param {Array} docs\n * @param {Object} fields the projection used, including `select` from schemas\n * @param {Object} userProvidedFields the user-specified projection\n * @param {Object} [opts]\n * @param {Array} [opts.populated]\n * @param {ClientSession} [opts.session]\n * @api private\n */\n\nQuery.prototype._completeMany = async function _completeMany(docs, fields, userProvidedFields, opts) {\n  const model = this.model;\n  return Promise.all(docs.map(doc => new Promise((resolve, reject) => {\n    const rawDoc = doc;\n    doc = helpers.createModel(model, doc, fields, userProvidedFields);\n    if (opts.session != null) {\n      doc.$session(opts.session);\n    }\n    doc.$init(rawDoc, opts, (err) => {\n      if (err != null) {\n        return reject(err);\n      }\n      resolve(doc);\n    });\n  })));\n};\n\n/**\n * Internal helper to execute a findOne() operation\n *\n * @see findOne https://www.mongodb.com/docs/manual/reference/method/db.collection.findOne/\n * @api private\n */\n\nQuery.prototype._findOne = async function _findOne() {\n  this._castConditions();\n\n  if (this.error()) {\n    const err = this.error();\n    throw err;\n  }\n\n  applyGlobalMaxTimeMS(this.options, this.model.db.options, this.model.base.options);\n  applyGlobalDiskUse(this.options, this.model.db.options, this.model.base.options);\n\n  const options = this._optionsForExec();\n\n  this._applyTranslateAliases(options);\n\n  // don't pass in the conditions because we already merged them in\n  const doc = await this.mongooseCollection.findOne(this._conditions, options);\n  return new Promise((resolve, reject) => {\n    this._completeOne(doc, null, (err, res) => {\n      if (err) {\n        return reject(err);\n      }\n      resolve(res);\n    });\n  });\n};\n\n/**\n * Declares the query a findOne operation. When executed, the first found document is passed to the callback.\n *\n * The result of the query is a single document, or `null` if no document was found.\n *\n * * *Note:* `conditions` is optional, and if `conditions` is null or undefined,\n * mongoose will send an empty `findOne` command to MongoDB, which will return\n * an arbitrary document. If you're querying by `_id`, use `Model.findById()`\n * instead.\n *\n * This function triggers the following middleware.\n *\n * - `findOne()`\n *\n * #### Example:\n *\n *     const query = Kitten.where({ color: 'white' });\n *     const kitten = await query.findOne();\n *\n * @param {Object} [filter] mongodb selector\n * @param {Object} [projection] optional fields to return\n * @param {Object} [options] see [`setOptions()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.setOptions())\n * @param {Boolean} [options.translateAliases=null] If set to `true`, translates any schema-defined aliases in `filter`, `projection`, `update`, and `distinct`. Throws an error if there are any conflicts where both alias and raw property are defined on the same object.\n * @return {Query} this\n * @see findOne https://www.mongodb.com/docs/manual/reference/method/db.collection.findOne/\n * @see Query.select https://mongoosejs.com/docs/api/query.html#Query.prototype.select()\n * @api public\n */\n\nQuery.prototype.findOne = function(conditions, projection, options) {\n  if (typeof conditions === 'function' ||\n      typeof projection === 'function' ||\n      typeof options === 'function' ||\n      typeof arguments[3] === 'function') {\n    throw new MongooseError('Query.prototype.findOne() no longer accepts a callback');\n  }\n\n  this.op = 'findOne';\n  this._validateOp();\n\n  if (options) {\n    this.setOptions(options);\n  }\n\n  if (projection) {\n    this.select(projection);\n  }\n\n  if (mquery.canMerge(conditions)) {\n    this.merge(conditions);\n\n    prepareDiscriminatorCriteria(this);\n  } else if (conditions != null) {\n    this.error(new ObjectParameterError(conditions, 'filter', 'findOne'));\n  }\n\n  return this;\n};\n\n\n/**\n * Execute a countDocuments query\n *\n * @see countDocuments https://mongodb.github.io/node-mongodb-native/4.9/classes/Collection.html#countDocuments\n * @api private\n */\n\nQuery.prototype._countDocuments = async function _countDocuments() {\n  try {\n    this.cast(this.model);\n  } catch (err) {\n    this.error(err);\n  }\n\n  if (this.error()) {\n    throw this.error();\n  }\n\n  applyGlobalMaxTimeMS(this.options, this.model.db.options, this.model.base.options);\n  applyGlobalDiskUse(this.options, this.model.db.options, this.model.base.options);\n\n  const options = this._optionsForExec();\n\n  this._applyTranslateAliases(options);\n\n  const conds = this._conditions;\n\n  return this.mongooseCollection.countDocuments(conds, options);\n};\n\n/*!\n * If `translateAliases` option is set, call `Model.translateAliases()`\n * on the following query properties: filter, projection, update, distinct.\n */\n\nQuery.prototype._applyTranslateAliases = function _applyTranslateAliases(options) {\n  let applyTranslateAliases = false;\n  if ('translateAliases' in this._mongooseOptions) {\n    applyTranslateAliases = this._mongooseOptions.translateAliases;\n  } else if (this.model?.schema?._userProvidedOptions?.translateAliases != null) {\n    applyTranslateAliases = this.model.schema._userProvidedOptions.translateAliases;\n  } else if (this.model?.base?.options?.translateAliases != null) {\n    applyTranslateAliases = this.model.base.options.translateAliases;\n  }\n  if (!applyTranslateAliases) {\n    return;\n  }\n\n  if (this.model?.schema?.aliases && Object.keys(this.model.schema.aliases).length > 0) {\n    this.model.translateAliases(this._conditions, true);\n    this.model.translateAliases(options.projection, true);\n    this.model.translateAliases(this._update, true);\n    if (this._distinct != null && this.model.schema.aliases[this._distinct] != null) {\n      this._distinct = this.model.schema.aliases[this._distinct];\n    }\n  }\n};\n\n/**\n * Execute a estimatedDocumentCount() query\n *\n * @see estimatedDocumentCount https://mongodb.github.io/node-mongodb-native/4.9/classes/Collection.html#estimatedDocumentCount\n * @api private\n */\n\nQuery.prototype._estimatedDocumentCount = async function _estimatedDocumentCount() {\n  if (this.error()) {\n    throw this.error();\n  }\n\n  const options = this._optionsForExec();\n\n  return this.mongooseCollection.estimatedDocumentCount(options);\n};\n\n/**\n * Specifies this query as a `estimatedDocumentCount()` query. Faster than\n * using `countDocuments()` for large collections because\n * `estimatedDocumentCount()` uses collection metadata rather than scanning\n * the entire collection.\n *\n * `estimatedDocumentCount()` does **not** accept a filter. `Model.find({ foo: bar }).estimatedDocumentCount()`\n * is equivalent to `Model.find().estimatedDocumentCount()`\n *\n * This function triggers the following middleware.\n *\n * - `estimatedDocumentCount()`\n *\n * #### Example:\n *\n *     await Model.find().estimatedDocumentCount();\n *\n * @param {Object} [options] passed transparently to the [MongoDB driver](https://mongodb.github.io/node-mongodb-native/4.9/interfaces/EstimatedDocumentCountOptions.html)\n * @return {Query} this\n * @see estimatedDocumentCount https://mongodb.github.io/node-mongodb-native/4.9/classes/Collection.html#estimatedDocumentCount\n * @api public\n */\n\nQuery.prototype.estimatedDocumentCount = function(options) {\n  if (typeof options === 'function' ||\n      typeof arguments[1] === 'function') {\n    throw new MongooseError('Query.prototype.estimatedDocumentCount() no longer accepts a callback');\n  }\n\n  this.op = 'estimatedDocumentCount';\n  this._validateOp();\n\n  if (typeof options === 'object' && options != null) {\n    this.setOptions(options);\n  }\n\n  return this;\n};\n\n/**\n * Specifies this query as a `countDocuments()` query. Behaves like `count()`,\n * except it always does a full collection scan when passed an empty filter `{}`.\n *\n * There are also minor differences in how `countDocuments()` handles\n * [`$where` and a couple geospatial operators](https://mongodb.github.io/node-mongodb-native/4.9/classes/Collection.html#countDocuments).\n * versus `count()`.\n *\n * This function triggers the following middleware.\n *\n * - `countDocuments()`\n *\n * #### Example:\n *\n *     const countQuery = model.where({ 'color': 'black' }).countDocuments();\n *\n *     query.countDocuments({ color: 'black' }).count().exec();\n *\n *     await query.countDocuments({ color: 'black' });\n *\n *     query.where('color', 'black').countDocuments().exec();\n *\n * The `countDocuments()` function is similar to `count()`, but there are a\n * [few operators that `countDocuments()` does not support](https://mongodb.github.io/node-mongodb-native/4.9/classes/Collection.html#countDocuments).\n * Below are the operators that `count()` supports but `countDocuments()` does not,\n * and the suggested replacement:\n *\n * - `$where`: [`$expr`](https://www.mongodb.com/docs/manual/reference/operator/query/expr/)\n * - `$near`: [`$geoWithin`](https://www.mongodb.com/docs/manual/reference/operator/query/geoWithin/) with [`$center`](https://www.mongodb.com/docs/manual/reference/operator/query/center/#op._S_center)\n * - `$nearSphere`: [`$geoWithin`](https://www.mongodb.com/docs/manual/reference/operator/query/geoWithin/) with [`$centerSphere`](https://www.mongodb.com/docs/manual/reference/operator/query/centerSphere/#op._S_centerSphere)\n *\n * @param {Object} [filter] mongodb selector\n * @param {Object} [options]\n * @return {Query} this\n * @see countDocuments https://mongodb.github.io/node-mongodb-native/4.9/classes/Collection.html#countDocuments\n * @api public\n */\n\nQuery.prototype.countDocuments = function(conditions, options) {\n  if (typeof conditions === 'function' ||\n      typeof options === 'function' ||\n      typeof arguments[2] === 'function') {\n    throw new MongooseError('Query.prototype.countDocuments() no longer accepts a callback');\n  }\n\n  this.op = 'countDocuments';\n  this._validateOp();\n\n  if (mquery.canMerge(conditions)) {\n    this.merge(conditions);\n  }\n\n  if (typeof options === 'object' && options != null) {\n    this.setOptions(options);\n  }\n\n  return this;\n};\n\n/**\n * Execute a `distinct()` query\n *\n * @see distinct https://www.mongodb.com/docs/manual/reference/method/db.collection.distinct/\n * @api private\n */\n\nQuery.prototype.__distinct = async function __distinct() {\n  this._castConditions();\n\n  if (this.error()) {\n    throw this.error();\n  }\n\n  applyGlobalMaxTimeMS(this.options, this.model.db.options, this.model.base.options);\n  applyGlobalDiskUse(this.options, this.model.db.options, this.model.base.options);\n\n  const options = this._optionsForExec();\n  this._applyTranslateAliases(options);\n\n  return this.mongooseCollection.\n    distinct(this._distinct, this._conditions, options);\n};\n\n/**\n * Declares or executes a distinct() operation.\n *\n * This function does not trigger any middleware.\n *\n * #### Example:\n *\n *     distinct(field, conditions)\n *     distinct(field)\n *     distinct()\n *\n * @param {String} [field]\n * @param {Object|Query} [filter]\n * @return {Query} this\n * @see distinct https://www.mongodb.com/docs/manual/reference/method/db.collection.distinct/\n * @api public\n */\n\nQuery.prototype.distinct = function(field, conditions) {\n  if (typeof field === 'function' ||\n      typeof conditions === 'function' ||\n      typeof arguments[2] === 'function') {\n    throw new MongooseError('Query.prototype.distinct() no longer accepts a callback');\n  }\n\n  this.op = 'distinct';\n  this._validateOp();\n\n  if (mquery.canMerge(conditions)) {\n    this.merge(conditions);\n\n    prepareDiscriminatorCriteria(this);\n  } else if (conditions != null) {\n    this.error(new ObjectParameterError(conditions, 'filter', 'distinct'));\n  }\n\n  if (field != null) {\n    this._distinct = field;\n  }\n\n  return this;\n};\n\n/**\n * Sets the sort order\n *\n * If an object is passed, values allowed are `asc`, `desc`, `ascending`, `descending`, `1`, and `-1`.\n *\n * If a string is passed, it must be a space delimited list of path names. The\n * sort order of each path is ascending unless the path name is prefixed with `-`\n * which will be treated as descending.\n *\n * #### Example:\n *\n *     // sort by \"field\" ascending and \"test\" descending\n *     query.sort({ field: 'asc', test: -1 });\n *\n *     // equivalent\n *     query.sort('field -test');\n *\n *     // also possible is to use a array with array key-value pairs\n *     query.sort([['field', 'asc']]);\n *\n * #### Note:\n *\n * Cannot be used with `distinct()`\n *\n * @param {Object|String|Array<Array<(string | number)>>} arg\n * @return {Query} this\n * @see cursor.sort https://www.mongodb.com/docs/manual/reference/method/cursor.sort/\n * @api public\n */\n\nQuery.prototype.sort = function(arg) {\n  if (arguments.length > 1) {\n    throw new Error('sort() only takes 1 Argument');\n  }\n\n  if (this.options.sort == null) {\n    this.options.sort = {};\n  }\n  const sort = this.options.sort;\n  if (typeof arg === 'string') {\n    const properties = arg.indexOf(' ') === -1 ? [arg] : arg.split(' ');\n    for (let property of properties) {\n      const ascend = '-' == property[0] ? -1 : 1;\n      if (ascend === -1) {\n        property = property.slice(1);\n      }\n      if (specialProperties.has(property)) {\n        continue;\n      }\n      sort[property] = ascend;\n    }\n  } else if (Array.isArray(arg)) {\n    for (const pair of arg) {\n      if (!Array.isArray(pair)) {\n        throw new TypeError('Invalid sort() argument, must be array of arrays');\n      }\n      const key = '' + pair[0];\n      if (specialProperties.has(key)) {\n        continue;\n      }\n      sort[key] = _handleSortValue(pair[1], key);\n    }\n  } else if (typeof arg === 'object' && arg != null && !(arg instanceof Map)) {\n    for (const key of Object.keys(arg)) {\n      if (specialProperties.has(key)) {\n        continue;\n      }\n      sort[key] = _handleSortValue(arg[key], key);\n    }\n  } else if (arg instanceof Map) {\n    for (let key of arg.keys()) {\n      key = '' + key;\n      if (specialProperties.has(key)) {\n        continue;\n      }\n      sort[key] = _handleSortValue(arg.get(key), key);\n    }\n  } else if (arg != null) {\n    throw new TypeError('Invalid sort() argument. Must be a string, object, array, or map.');\n  }\n\n  return this;\n};\n\n/*!\n * Convert sort values\n */\n\nfunction _handleSortValue(val, key) {\n  if (val === 1 || val === 'asc' || val === 'ascending') {\n    return 1;\n  }\n  if (val === -1 || val === 'desc' || val === 'descending') {\n    return -1;\n  }\n  if (val?.$meta != null) {\n    return { $meta: val.$meta };\n  }\n  throw new TypeError('Invalid sort value: { ' + key + ': ' + val + ' }');\n}\n\n/**\n * Declare and/or execute this query as a `deleteOne()` operation. Works like\n * remove, except it deletes at most one document regardless of the `single`\n * option.\n *\n * This function triggers `deleteOne` middleware.\n *\n * #### Example:\n *\n *     await Character.deleteOne({ name: 'Eddard Stark' });\n *\n * This function calls the MongoDB driver's [`Collection#deleteOne()` function](https://mongodb.github.io/node-mongodb-native/4.9/classes/Collection.html#deleteOne).\n * The returned [promise](https://mongoosejs.com/docs/queries.html) resolves to an\n * object that contains 3 properties:\n *\n * - `ok`: `1` if no errors occurred\n * - `deletedCount`: the number of documents deleted\n * - `n`: the number of documents deleted. Equal to `deletedCount`.\n *\n * #### Example:\n *\n *     const res = await Character.deleteOne({ name: 'Eddard Stark' });\n *     // `1` if MongoDB deleted a doc, `0` if no docs matched the filter `{ name: ... }`\n *     res.deletedCount;\n *\n * @param {Object|Query} [filter] mongodb selector\n * @param {Object} [options] optional see [`Query.prototype.setOptions()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.setOptions())\n * @return {Query} this\n * @see DeleteResult https://mongodb.github.io/node-mongodb-native/4.9/interfaces/DeleteResult.html\n * @see deleteOne https://mongodb.github.io/node-mongodb-native/4.9/classes/Collection.html#deleteOne\n * @api public\n */\n\nQuery.prototype.deleteOne = function deleteOne(filter, options) {\n  if (typeof filter === 'function' || typeof options === 'function' || typeof arguments[2] === 'function') {\n    throw new MongooseError('Query.prototype.deleteOne() no longer accepts a callback');\n  }\n  this.op = 'deleteOne';\n  this.setOptions(options);\n\n  if (mquery.canMerge(filter)) {\n    this.merge(filter);\n\n    prepareDiscriminatorCriteria(this);\n  } else if (filter != null) {\n    this.error(new ObjectParameterError(filter, 'filter', 'deleteOne'));\n  }\n\n  return this;\n};\n\n/**\n * Internal thunk for `deleteOne()`\n *\n * @method _deleteOne\n * @instance\n * @memberOf Query\n * @api private\n */\n\nQuery.prototype._deleteOne = async function _deleteOne() {\n  this._castConditions();\n\n  if (this.error() != null) {\n    throw this.error();\n  }\n\n  const options = this._optionsForExec();\n  this._applyTranslateAliases(options);\n\n  return this.mongooseCollection.deleteOne(this._conditions, options);\n};\n\n/**\n * Declare and/or execute this query as a `deleteMany()` operation. Works like\n * remove, except it deletes _every_ document that matches `filter` in the\n * collection, regardless of the value of `single`.\n *\n * This function triggers `deleteMany` middleware.\n *\n * #### Example:\n *\n *     await Character.deleteMany({ name: /Stark/, age: { $gte: 18 } });\n *\n * This function calls the MongoDB driver's [`Collection#deleteMany()` function](https://mongodb.github.io/node-mongodb-native/4.9/classes/Collection.html#deleteMany).\n * The returned [promise](https://mongoosejs.com/docs/queries.html) resolves to an\n * object that contains 3 properties:\n *\n * - `ok`: `1` if no errors occurred\n * - `deletedCount`: the number of documents deleted\n * - `n`: the number of documents deleted. Equal to `deletedCount`.\n *\n * #### Example:\n *\n *     const res = await Character.deleteMany({ name: /Stark/, age: { $gte: 18 } });\n *     // `0` if no docs matched the filter, number of docs deleted otherwise\n *     res.deletedCount;\n *\n * @param {Object|Query} [filter] mongodb selector\n * @param {Object} [options] optional see [`Query.prototype.setOptions()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.setOptions())\n * @return {Query} this\n * @see DeleteResult https://mongodb.github.io/node-mongodb-native/4.9/interfaces/DeleteResult.html\n * @see deleteMany https://mongodb.github.io/node-mongodb-native/4.9/classes/Collection.html#deleteMany\n * @api public\n */\n\nQuery.prototype.deleteMany = function(filter, options) {\n  if (typeof filter === 'function' || typeof options === 'function' || typeof arguments[2] === 'function') {\n    throw new MongooseError('Query.prototype.deleteMany() no longer accepts a callback');\n  }\n  this.setOptions(options);\n  this.op = 'deleteMany';\n\n  if (mquery.canMerge(filter)) {\n    this.merge(filter);\n\n    prepareDiscriminatorCriteria(this);\n  } else if (filter != null) {\n    this.error(new ObjectParameterError(filter, 'filter', 'deleteMany'));\n  }\n\n  return this;\n};\n\n/**\n * Execute a `deleteMany()` query\n *\n * @param {Function} callback\n * @method _deleteMany\n * @instance\n * @memberOf Query\n * @api private\n */\n\nQuery.prototype._deleteMany = async function _deleteMany() {\n  this._castConditions();\n\n  if (this.error() != null) {\n    throw this.error();\n  }\n\n  const options = this._optionsForExec();\n  this._applyTranslateAliases(options);\n\n  return this.mongooseCollection.deleteMany(this._conditions, options);\n};\n\n/**\n * hydrates a document\n *\n * @param {Model} model\n * @param {Document} doc\n * @param {Object} res 3rd parameter to callback\n * @param {Object} fields\n * @param {Query} self\n * @param {Array} [pop] array of paths used in population\n * @param {Function} callback\n * @api private\n */\n\nfunction completeOne(model, doc, res, options, fields, userProvidedFields, pop, callback) {\n  if (options.includeResultMetadata && doc == null) {\n    _init(null);\n    return null;\n  }\n\n  helpers.createModelAndInit(model, doc, fields, userProvidedFields, options, pop, _init);\n\n  function _init(err, casted) {\n    if (err) {\n      return immediate(() => callback(err));\n    }\n\n\n    if (options.includeResultMetadata) {\n      if (doc && casted) {\n        if (options.session != null) {\n          casted.$session(options.session);\n        }\n        res.value = casted;\n      } else {\n        res.value = null;\n      }\n      return immediate(() => callback(null, res));\n    }\n    if (options.session != null) {\n      casted.$session(options.session);\n    }\n    immediate(() => callback(null, casted));\n  }\n}\n\n/**\n * If the model is a discriminator type and not root, then add the key & value to the criteria.\n * @param {Query} query\n * @api private\n */\n\nfunction prepareDiscriminatorCriteria(query) {\n  if (!query || !query.model || !query.model.schema) {\n    return;\n  }\n\n  const schema = query.model.schema;\n\n  if (schema && schema.discriminatorMapping && !schema.discriminatorMapping.isRoot) {\n    query._conditions[schema.discriminatorMapping.key] = schema.discriminatorMapping.value;\n  }\n}\n\n/**\n * Issues a mongodb `findOneAndUpdate()` command.\n *\n * Finds a matching document, updates it according to the `update` arg, passing any `options`, and returns the found\n * document (if any).\n *\n * This function triggers the following middleware.\n *\n * - `findOneAndUpdate()`\n *\n * #### Available options\n *\n * - `new`: bool - if true, return the modified document rather than the original. defaults to false (changed in 4.0)\n * - `upsert`: bool - creates the object if it doesn't exist. defaults to false.\n * - `fields`: {Object|String} - Field selection. Equivalent to `.select(fields).findOneAndUpdate()`\n * - `sort`: if multiple docs are found by the conditions, sets the sort order to choose which doc to update\n * - `maxTimeMS`: puts a time limit on the query - requires mongodb >= 2.6.0\n * - `runValidators`: if true, runs [update validators](https://mongoosejs.com/docs/validation.html#update-validators) on this command. Update validators validate the update operation against the model's schema.\n * - `setDefaultsOnInsert`: `true` by default. If `setDefaultsOnInsert` and `upsert` are true, mongoose will apply the [defaults](https://mongoosejs.com/docs/defaults.html) specified in the model's schema if a new document is created.\n *\n * #### Example:\n *\n *     query.findOneAndUpdate(conditions, update, options)  // returns Query\n *     query.findOneAndUpdate(conditions, update)           // returns Query\n *     query.findOneAndUpdate(update)                       // returns Query\n *     query.findOneAndUpdate()                             // returns Query\n *\n * @method findOneAndUpdate\n * @memberOf Query\n * @instance\n * @param {Object|Query} [filter]\n * @param {Object} [doc]\n * @param {Object} [options]\n * @param {Boolean} [options.includeResultMetadata] if true, returns the full [ModifyResult from the MongoDB driver](https://mongodb.github.io/node-mongodb-native/4.9/interfaces/ModifyResult.html) rather than just the document\n * @param {Boolean|String} [options.strict] overwrites the schema's [strict mode option](https://mongoosejs.com/docs/guide.html#strict)\n * @param {ClientSession} [options.session=null] The session associated with this query. See [transactions docs](https://mongoosejs.com/docs/transactions.html).\n * @param {Boolean} [options.multipleCastError] by default, mongoose only returns the first error that occurred in casting the query. Turn on this option to aggregate all the cast errors.\n * @param {Boolean} [options.new=false] By default, `findOneAndUpdate()` returns the document as it was **before** `update` was applied. If you set `new: true`, `findOneAndUpdate()` will instead give you the object after `update` was applied.\n * @param {Object} [options.lean] if truthy, mongoose will return the document as a plain JavaScript object rather than a mongoose document. See [`Query.lean()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.lean()) and [the Mongoose lean tutorial](https://mongoosejs.com/docs/tutorials/lean.html).\n * @param {ClientSession} [options.session=null] The session associated with this query. See [transactions docs](https://mongoosejs.com/docs/transactions.html).\n * @param {Boolean|String} [options.strict] overwrites the schema's [strict mode option](https://mongoosejs.com/docs/guide.html#strict)\n * @param {Boolean} [options.timestamps=null] If set to `false` and [schema-level timestamps](https://mongoosejs.com/docs/guide.html#timestamps) are enabled, skip timestamps for this update. Note that this allows you to overwrite timestamps. Does nothing if schema-level timestamps are not set.\n * @param {Boolean} [options.returnOriginal=null] An alias for the `new` option. `returnOriginal: false` is equivalent to `new: true`.\n * @param {Boolean} [options.translateAliases=null] If set to `true`, translates any schema-defined aliases in `filter`, `projection`, `update`, and `distinct`. Throws an error if there are any conflicts where both alias and raw property are defined on the same object.\n * @see Tutorial https://mongoosejs.com/docs/tutorials/findoneandupdate.html\n * @see findAndModify command https://www.mongodb.com/docs/manual/reference/command/findAndModify/\n * @see ModifyResult https://mongodb.github.io/node-mongodb-native/4.9/interfaces/ModifyResult.html\n * @see findOneAndUpdate https://mongodb.github.io/node-mongodb-native/4.9/classes/Collection.html#findOneAndUpdate\n * @return {Query} this\n * @api public\n */\n\nQuery.prototype.findOneAndUpdate = function(filter, doc, options) {\n  if (typeof filter === 'function' ||\n      typeof doc === 'function' ||\n      typeof options === 'function' ||\n      typeof arguments[3] === 'function') {\n    throw new MongooseError('Query.prototype.findOneAndUpdate() no longer accepts a callback');\n  }\n\n  this.op = 'findOneAndUpdate';\n  this._validateOp();\n  this._validate();\n\n  switch (arguments.length) {\n    case 2:\n      options = undefined;\n      break;\n    case 1:\n      doc = filter;\n      filter = options = undefined;\n      break;\n  }\n\n  if (mquery.canMerge(filter)) {\n    this.merge(filter);\n  } else if (filter != null) {\n    this.error(\n      new ObjectParameterError(filter, 'filter', 'findOneAndUpdate')\n    );\n  }\n\n  // apply doc\n  if (doc) {\n    this._mergeUpdate(doc);\n  }\n\n  options = options ? clone(options) : {};\n\n  if (options.projection) {\n    this.select(options.projection);\n    delete options.projection;\n  }\n  if (options.fields) {\n    this.select(options.fields);\n    delete options.fields;\n  }\n\n  const returnOriginal = this &&\n    this.model &&\n    this.model.base &&\n    this.model.base.options &&\n    this.model.base.options.returnOriginal;\n  if (options.new == null && options.returnDocument == null && options.returnOriginal == null && returnOriginal != null) {\n    options.returnOriginal = returnOriginal;\n  }\n\n  this.setOptions(options);\n\n  return this;\n};\n\n/**\n * Execute a findOneAndUpdate operation\n *\n * @method _findOneAndUpdate\n * @memberOf Query\n * @api private\n */\n\nQuery.prototype._findOneAndUpdate = async function _findOneAndUpdate() {\n  this._castConditions();\n\n  _castArrayFilters(this);\n\n  if (this.error()) {\n    throw this.error();\n  }\n\n  applyGlobalMaxTimeMS(this.options, this.model.db.options, this.model.base.options);\n  applyGlobalDiskUse(this.options, this.model.db.options, this.model.base.options);\n\n  if ('strict' in this.options) {\n    this._mongooseOptions.strict = this.options.strict;\n  }\n  const options = this._optionsForExec(this.model);\n  convertNewToReturnDocument(options);\n  this._applyTranslateAliases(options);\n\n  this._update = this._castUpdate(this._update);\n\n  const _opts = Object.assign({}, options, {\n    setDefaultsOnInsert: this._mongooseOptions.setDefaultsOnInsert\n  });\n  this._update = setDefaultsOnInsert(this._conditions, this.model.schema,\n    this._update, _opts);\n\n  if (!this._update || Object.keys(this._update).length === 0) {\n    if (options.upsert) {\n      // still need to do the upsert to empty doc\n      const doc = clone(this._update);\n      delete doc._id;\n      this._update = { $set: doc };\n    } else {\n      this._executionStack = null;\n      const res = await this._findOne();\n      return res;\n    }\n  } else if (this._update instanceof Error) {\n    throw this._update;\n  } else {\n    // In order to make MongoDB 2.6 happy (see\n    // https://jira.mongodb.org/browse/SERVER-12266 and related issues)\n    // if we have an actual update document but $set is empty, junk the $set.\n    if (this._update.$set && Object.keys(this._update.$set).length === 0) {\n      delete this._update.$set;\n    }\n  }\n\n  const runValidators = _getOption(this, 'runValidators', false);\n  if (runValidators) {\n    await this.validate(this._update, options, false);\n  }\n\n  if (this._update.toBSON) {\n    this._update = this._update.toBSON();\n  }\n\n  let res = await this.mongooseCollection.findOneAndUpdate(this._conditions, this._update, options);\n  for (const fn of this._transforms) {\n    res = fn(res);\n  }\n  const doc = !options.includeResultMetadata ? res : res.value;\n\n  return new Promise((resolve, reject) => {\n    this._completeOne(doc, res, (err, res) => {\n      if (err) {\n        return reject(err);\n      }\n      resolve(res);\n    });\n  });\n};\n\n/**\n * Issues a MongoDB [findOneAndDelete](https://www.mongodb.com/docs/manual/reference/method/db.collection.findOneAndDelete/) command.\n *\n * Finds a matching document, removes it, and returns the found document (if any).\n *\n * This function triggers the following middleware.\n *\n * - `findOneAndDelete()`\n *\n * #### Available options\n *\n * - `sort`: if multiple docs are found by the conditions, sets the sort order to choose which doc to update\n * - `maxTimeMS`: puts a time limit on the query - requires mongodb >= 2.6.0\n *\n * #### Callback Signature\n *\n *     function(error, doc) {\n *       // error: any errors that occurred\n *       // doc: the document before updates are applied if `new: false`, or after updates if `new = true`\n *     }\n *\n * #### Example:\n *\n *     A.where().findOneAndDelete(conditions, options)  // return Query\n *     A.where().findOneAndDelete(conditions) // returns Query\n *     A.where().findOneAndDelete()           // returns Query\n *\n * @method findOneAndDelete\n * @memberOf Query\n * @param {Object} [filter]\n * @param {Object} [options]\n * @param {Boolean} [options.includeResultMetadata] if true, returns the full [ModifyResult from the MongoDB driver](https://mongodb.github.io/node-mongodb-native/4.9/interfaces/ModifyResult.html) rather than just the document\n * @param {ClientSession} [options.session=null] The session associated with this query. See [transactions docs](https://mongoosejs.com/docs/transactions.html).\n * @param {Boolean|String} [options.strict] overwrites the schema's [strict mode option](https://mongoosejs.com/docs/guide.html#strict)\n * @return {Query} this\n * @see findAndModify command https://www.mongodb.com/docs/manual/reference/command/findAndModify/\n * @api public\n */\n\nQuery.prototype.findOneAndDelete = function(filter, options) {\n  if (typeof filter === 'function' ||\n      typeof options === 'function' ||\n      typeof arguments[2] === 'function') {\n    throw new MongooseError('Query.prototype.findOneAndDelete() no longer accepts a callback');\n  }\n\n  this.op = 'findOneAndDelete';\n  this._validateOp();\n  this._validate();\n\n  if (mquery.canMerge(filter)) {\n    this.merge(filter);\n  }\n\n  options && this.setOptions(options);\n\n  return this;\n};\n\n/**\n * Execute a `findOneAndDelete()` query\n *\n * @return {Query} this\n * @method _findOneAndDelete\n * @memberOf Query\n * @api private\n */\nQuery.prototype._findOneAndDelete = async function _findOneAndDelete() {\n  this._castConditions();\n\n  if (this.error() != null) {\n    throw this.error();\n  }\n\n  const includeResultMetadata = this.options.includeResultMetadata;\n\n  const filter = this._conditions;\n  const options = this._optionsForExec(this.model);\n  this._applyTranslateAliases(options);\n\n  let res = await this.mongooseCollection.findOneAndDelete(filter, options);\n  for (const fn of this._transforms) {\n    res = fn(res);\n  }\n  const doc = !includeResultMetadata ? res : res.value;\n\n  return new Promise((resolve, reject) => {\n    this._completeOne(doc, res, (err, res) => {\n      if (err) {\n        return reject(err);\n      }\n      resolve(res);\n    });\n  });\n};\n\n/**\n * Issues a MongoDB [findOneAndReplace](https://www.mongodb.com/docs/manual/reference/method/db.collection.findOneAndReplace/) command.\n *\n * Finds a matching document, removes it, and returns the found document (if any).\n *\n * This function triggers the following middleware.\n *\n * - `findOneAndReplace()`\n *\n * #### Available options\n *\n * - `sort`: if multiple docs are found by the conditions, sets the sort order to choose which doc to update\n * - `maxTimeMS`: puts a time limit on the query - requires mongodb >= 2.6.0\n * - `includeResultMetadata`: if true, returns the full [ModifyResult from the MongoDB driver](https://mongodb.github.io/node-mongodb-native/4.9/interfaces/ModifyResult.html) rather than just the document\n *\n * #### Callback Signature\n *\n *     function(error, doc) {\n *       // error: any errors that occurred\n *       // doc: the document before updates are applied if `new: false`, or after updates if `new = true`\n *     }\n *\n * #### Example:\n *\n *     A.where().findOneAndReplace(filter, replacement, options); // return Query\n *     A.where().findOneAndReplace(filter); // returns Query\n *     A.where().findOneAndReplace(); // returns Query\n *\n * @method findOneAndReplace\n * @memberOf Query\n * @param {Object} [filter]\n * @param {Object} [replacement]\n * @param {Object} [options]\n * @param {Boolean} [options.includeResultMetadata] if true, returns the full [ModifyResult from the MongoDB driver](https://mongodb.github.io/node-mongodb-native/4.9/interfaces/ModifyResult.html) rather than just the document\n * @param {ClientSession} [options.session=null] The session associated with this query. See [transactions docs](https://mongoosejs.com/docs/transactions.html).\n * @param {Boolean|String} [options.strict] overwrites the schema's [strict mode option](https://mongoosejs.com/docs/guide.html#strict)\n * @param {Boolean} [options.new=false] By default, `findOneAndUpdate()` returns the document as it was **before** `update` was applied. If you set `new: true`, `findOneAndUpdate()` will instead give you the object after `update` was applied.\n * @param {Object} [options.lean] if truthy, mongoose will return the document as a plain JavaScript object rather than a mongoose document. See [`Query.lean()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.lean()) and [the Mongoose lean tutorial](https://mongoosejs.com/docs/tutorials/lean.html).\n * @param {ClientSession} [options.session=null] The session associated with this query. See [transactions docs](https://mongoosejs.com/docs/transactions.html).\n * @param {Boolean|String} [options.strict] overwrites the schema's [strict mode option](https://mongoosejs.com/docs/guide.html#strict)\n * @param {Boolean} [options.timestamps=null] If set to `false` and [schema-level timestamps](https://mongoosejs.com/docs/guide.html#timestamps) are enabled, skip timestamps for this update. Note that this allows you to overwrite timestamps. Does nothing if schema-level timestamps are not set.\n * @param {Boolean} [options.returnOriginal=null] An alias for the `new` option. `returnOriginal: false` is equivalent to `new: true`.\n * @param {Boolean} [options.translateAliases=null] If set to `true`, translates any schema-defined aliases in `filter`, `projection`, `update`, and `distinct`. Throws an error if there are any conflicts where both alias and raw property are defined on the same object.\n * @return {Query} this\n * @api public\n */\n\nQuery.prototype.findOneAndReplace = function(filter, replacement, options) {\n  if (typeof filter === 'function' ||\n      typeof replacement === 'function' ||\n      typeof options === 'function' ||\n      typeof arguments[4] === 'function') {\n    throw new MongooseError('Query.prototype.findOneAndReplace() no longer accepts a callback');\n  }\n\n  this.op = 'findOneAndReplace';\n  this._validateOp();\n  this._validate();\n\n  if (mquery.canMerge(filter)) {\n    this.merge(filter);\n  } else if (filter != null) {\n    this.error(\n      new ObjectParameterError(filter, 'filter', 'findOneAndReplace')\n    );\n  }\n\n  if (replacement != null) {\n    this._mergeUpdate(replacement);\n  }\n\n  options = options || {};\n\n  const returnOriginal = this &&\n  this.model &&\n  this.model.base &&\n  this.model.base.options &&\n  this.model.base.options.returnOriginal;\n  if (options.new == null && options.returnDocument == null && options.returnOriginal == null && returnOriginal != null) {\n    options.returnOriginal = returnOriginal;\n  }\n  this.setOptions(options);\n\n  return this;\n};\n\n/**\n * Execute a findOneAndReplace() query\n *\n * @return {Query} this\n * @method _findOneAndReplace\n * @instance\n * @memberOf Query\n * @api private\n */\nQuery.prototype._findOneAndReplace = async function _findOneAndReplace() {\n  this._castConditions();\n  if (this.error() != null) {\n    throw this.error();\n  }\n\n  if ('strict' in this.options) {\n    this._mongooseOptions.strict = this.options.strict;\n    delete this.options.strict;\n  }\n\n  const filter = this._conditions;\n  const options = this._optionsForExec();\n  this._applyTranslateAliases(options);\n  convertNewToReturnDocument(options);\n\n  const includeResultMetadata = this.options.includeResultMetadata;\n\n  const modelOpts = { skipId: true };\n  if ('strict' in this._mongooseOptions) {\n    modelOpts.strict = this._mongooseOptions.strict;\n  }\n\n  const runValidators = _getOption(this, 'runValidators', false);\n\n  try {\n    const update = new this.model(this._update, null, modelOpts);\n    if (runValidators) {\n      await update.validate();\n    } else if (update.$__.validationError) {\n      throw update.$__.validationError;\n    }\n    this._update = update.toBSON();\n  } catch (err) {\n    if (err instanceof ValidationError) {\n      throw err;\n    }\n    const validationError = new ValidationError();\n    validationError.errors[err.path] = err;\n    throw validationError;\n  }\n\n  let res = await this.mongooseCollection.findOneAndReplace(filter, this._update, options);\n\n  for (const fn of this._transforms) {\n    res = fn(res);\n  }\n\n  const doc = !includeResultMetadata ? res : res.value;\n  return new Promise((resolve, reject) => {\n    this._completeOne(doc, res, (err, res) => {\n      if (err) {\n        return reject(err);\n      }\n      resolve(res);\n    });\n  });\n};\n\n/**\n * Support the `new` option as an alternative to `returnOriginal` for backwards\n * compat.\n * @api private\n */\n\nfunction convertNewToReturnDocument(options) {\n  if ('new' in options) {\n    options.returnDocument = options['new'] ? 'after' : 'before';\n    delete options['new'];\n  }\n  if ('returnOriginal' in options) {\n    options.returnDocument = options['returnOriginal'] ? 'before' : 'after';\n    delete options['returnOriginal'];\n  }\n  // Temporary since driver 4.0.0-beta does not support `returnDocument`\n  if (typeof options.returnDocument === 'string') {\n    options.returnOriginal = options.returnDocument === 'before';\n  }\n}\n\n/**\n * Get options from query opts, falling back to the base mongoose object.\n * @param {Query} query\n * @param {Object} option\n * @param {Any} def\n * @api private\n */\n\nfunction _getOption(query, option, def) {\n  const opts = query._optionsForExec(query.model);\n\n  if (option in opts) {\n    return opts[option];\n  }\n  if (option in query.model.base.options) {\n    return query.model.base.options[option];\n  }\n  return def;\n}\n\n/*!\n * ignore\n */\n\nfunction _completeOneLean(schema, doc, path, res, opts, callback) {\n  if (opts.lean && typeof opts.lean.transform === 'function') {\n    opts.lean.transform(doc);\n\n    for (let i = 0; i < schema.childSchemas.length; i++) {\n      const childPath = path ? path + '.' + schema.childSchemas[i].model.path : schema.childSchemas[i].model.path;\n      const _schema = schema.childSchemas[i].schema;\n      const obj = mpath.get(childPath, doc);\n      if (obj == null) {\n        continue;\n      }\n      if (Array.isArray(obj)) {\n        for (let i = 0; i < obj.length; i++) {\n          opts.lean.transform(obj[i]);\n        }\n      } else {\n        opts.lean.transform(obj);\n      }\n      _completeOneLean(_schema, obj, childPath, res, opts);\n    }\n    if (callback) {\n      return callback(null, doc);\n    } else {\n      return;\n    }\n  }\n  if (opts.includeResultMetadata) {\n    return callback(null, res);\n  }\n  return callback(null, doc);\n}\n\n/*!\n * ignore\n */\n\nfunction _completeManyLean(schema, docs, path, opts) {\n  if (opts.lean && typeof opts.lean.transform === 'function') {\n    for (const doc of docs) {\n      opts.lean.transform(doc);\n    }\n\n    for (let i = 0; i < schema.childSchemas.length; i++) {\n      const childPath = path ? path + '.' + schema.childSchemas[i].model.path : schema.childSchemas[i].model.path;\n      const _schema = schema.childSchemas[i].schema;\n      let doc = mpath.get(childPath, docs);\n      if (doc == null) {\n        continue;\n      }\n      doc = doc.flat();\n      for (let i = 0; i < doc.length; i++) {\n        opts.lean.transform(doc[i]);\n      }\n      _completeManyLean(_schema, doc, childPath, opts);\n    }\n  }\n\n  return docs;\n}\n/**\n * Override mquery.prototype._mergeUpdate to handle mongoose objects in\n * updates.\n *\n * @param {Object} doc\n * @method _mergeUpdate\n * @memberOf Query\n * @instance\n * @api private\n */\n\nQuery.prototype._mergeUpdate = function(doc) {\n  if (!this._update) {\n    this._update = Array.isArray(doc) ? [] : {};\n  }\n\n  if (doc == null || (typeof doc === 'object' && Object.keys(doc).length === 0)) {\n    return;\n  }\n\n  if (doc instanceof Query) {\n    if (Array.isArray(this._update)) {\n      throw new Error('Cannot mix array and object updates');\n    }\n    if (doc._update) {\n      utils.mergeClone(this._update, doc._update);\n    }\n  } else if (Array.isArray(doc)) {\n    if (!Array.isArray(this._update)) {\n      throw new Error('Cannot mix array and object updates');\n    }\n    this._update = this._update.concat(doc);\n  } else {\n    if (Array.isArray(this._update)) {\n      throw new Error('Cannot mix array and object updates');\n    }\n    utils.mergeClone(this._update, doc);\n  }\n};\n\n/*!\n * ignore\n */\n\nasync function _updateThunk(op) {\n  this._castConditions();\n\n  _castArrayFilters(this);\n\n  if (this.error() != null) {\n    throw this.error();\n  }\n\n  const castedQuery = this._conditions;\n  const options = this._optionsForExec(this.model);\n  this._applyTranslateAliases(options);\n\n  this._update = clone(this._update, options);\n  const isOverwriting = op === 'replaceOne';\n  if (isOverwriting) {\n    this._update = new this.model(this._update, null, true);\n  } else {\n    this._update = this._castUpdate(this._update);\n\n    if (this._update == null || Object.keys(this._update).length === 0) {\n      return { acknowledged: false };\n    }\n\n    const _opts = Object.assign({}, options, {\n      setDefaultsOnInsert: this._mongooseOptions.setDefaultsOnInsert\n    });\n    this._update = setDefaultsOnInsert(this._conditions, this.model.schema,\n      this._update, _opts);\n  }\n\n  if (Array.isArray(options.arrayFilters)) {\n    options.arrayFilters = removeUnusedArrayFilters(this._update, options.arrayFilters);\n  }\n\n  const runValidators = _getOption(this, 'runValidators', false);\n  if (runValidators) {\n    await this.validate(this._update, options, isOverwriting);\n  }\n\n  if (this._update.toBSON) {\n    this._update = this._update.toBSON();\n  }\n\n  return this.mongooseCollection[op](castedQuery, this._update, options);\n}\n\n/**\n * Mongoose calls this function internally to validate the query if\n * `runValidators` is set\n *\n * @param {Object} castedDoc the update, after casting\n * @param {Object} options the options from `_optionsForExec()`\n * @param {Boolean} isOverwriting\n * @method validate\n * @memberOf Query\n * @instance\n * @api private\n */\n\nQuery.prototype.validate = async function validate(castedDoc, options, isOverwriting) {\n  if (typeof arguments[3] === 'function') {\n    throw new MongooseError('Query.prototype.validate() no longer accepts a callback');\n  }\n\n  await _executePreHooks(this, 'validate');\n\n  if (isOverwriting) {\n    await castedDoc.$validate();\n  } else {\n    await new Promise((resolve, reject) => {\n      updateValidators(this, this.model.schema, castedDoc, options, (err) => {\n        if (err != null) {\n          return reject(err);\n        }\n        resolve();\n      });\n    });\n  }\n\n  await _executePostHooks(this, null, null, 'validate');\n};\n\n/**\n * Execute an updateMany query\n *\n * @see Model.update https://mongoosejs.com/docs/api/model.html#Model.update()\n * @method _updateMany\n * @memberOf Query\n * @instance\n * @api private\n */\nQuery.prototype._updateMany = async function _updateMany() {\n  return _updateThunk.call(this, 'updateMany');\n};\n\n/**\n * Execute an updateOne query\n *\n * @see Model.update https://mongoosejs.com/docs/api/model.html#Model.update()\n * @method _updateOne\n * @memberOf Query\n * @instance\n * @api private\n */\nQuery.prototype._updateOne = async function _updateOne() {\n  return _updateThunk.call(this, 'updateOne');\n};\n\n/**\n * Execute a replaceOne query\n *\n * @see Model.replaceOne https://mongoosejs.com/docs/api/model.html#Model.replaceOne()\n * @method _replaceOne\n * @memberOf Query\n * @instance\n * @api private\n */\nQuery.prototype._replaceOne = async function _replaceOne() {\n  return _updateThunk.call(this, 'replaceOne');\n};\n\n/**\n * Declare and/or execute this query as an updateMany() operation.\n * MongoDB will update _all_ documents that match `filter` (as opposed to just the first one).\n *\n * **Note** updateMany will _not_ fire update middleware. Use `pre('updateMany')`\n * and `post('updateMany')` instead.\n *\n * #### Example:\n *\n *     const res = await Person.updateMany({ name: /Stark$/ }, { isDeleted: true });\n *     res.n; // Number of documents matched\n *     res.nModified; // Number of documents modified\n *\n * This function triggers the following middleware.\n *\n * - `updateMany()`\n *\n * @param {Object} [filter]\n * @param {Object|Array} [update] the update command\n * @param {Object} [options]\n * @param {Boolean} [options.multipleCastError] by default, mongoose only returns the first error that occurred in casting the query. Turn on this option to aggregate all the cast errors.\n * @param {Boolean|String} [options.strict] overwrites the schema's [strict mode option](https://mongoosejs.com/docs/guide.html#strict)\n * @param {Boolean} [options.upsert=false] if true, and no documents found, insert a new document\n * @param {Object} [options.writeConcern=null] sets the [write concern](https://www.mongodb.com/docs/manual/reference/write-concern/) for replica sets. Overrides the [schema-level write concern](https://mongoosejs.com/docs/guide.html#writeConcern)\n * @param {Boolean} [options.timestamps=null] If set to `false` and [schema-level timestamps](https://mongoosejs.com/docs/guide.html#timestamps) are enabled, skip timestamps for this update. Does nothing if schema-level timestamps are not set.\n * @param {Boolean} [options.translateAliases=null] If set to `true`, translates any schema-defined aliases in `filter`, `projection`, `update`, and `distinct`. Throws an error if there are any conflicts where both alias and raw property are defined on the same object.\n * @param {Function} [callback] params are (error, writeOpResult)\n * @return {Query} this\n * @see Model.update https://mongoosejs.com/docs/api/model.html#Model.update()\n * @see Query docs https://mongoosejs.com/docs/queries.html\n * @see update https://www.mongodb.com/docs/manual/reference/method/db.collection.update/\n * @see UpdateResult https://mongodb.github.io/node-mongodb-native/4.9/interfaces/UpdateResult.html\n * @see MongoDB docs https://www.mongodb.com/docs/manual/reference/command/update/#update-command-output\n * @api public\n */\n\nQuery.prototype.updateMany = function(conditions, doc, options, callback) {\n  if (typeof options === 'function') {\n    // .update(conditions, doc, callback)\n    callback = options;\n    options = null;\n  } else if (typeof doc === 'function') {\n    // .update(doc, callback);\n    callback = doc;\n    doc = conditions;\n    conditions = {};\n    options = null;\n  } else if (typeof conditions === 'function') {\n    // .update(callback)\n    callback = conditions;\n    conditions = undefined;\n    doc = undefined;\n    options = undefined;\n  } else if (typeof conditions === 'object' && !doc && !options && !callback) {\n    // .update(doc)\n    doc = conditions;\n    conditions = undefined;\n    options = undefined;\n    callback = undefined;\n  }\n\n  return _update(this, 'updateMany', conditions, doc, options, callback);\n};\n\n/**\n * Declare and/or execute this query as an updateOne() operation.\n * MongoDB will update _only_ the first document that matches `filter`.\n *\n * - Use `replaceOne()` if you want to overwrite an entire document rather than using [atomic operators](https://www.mongodb.com/docs/manual/tutorial/model-data-for-atomic-operations/#pattern) like `$set`.\n *\n * **Note** updateOne will _not_ fire update middleware. Use `pre('updateOne')`\n * and `post('updateOne')` instead.\n *\n * #### Example:\n *\n *     const res = await Person.updateOne({ name: 'Jean-Luc Picard' }, { ship: 'USS Enterprise' });\n *     res.acknowledged; // Indicates if this write result was acknowledged. If not, then all other members of this result will be undefined.\n *     res.matchedCount; // Number of documents that matched the filter\n *     res.modifiedCount; // Number of documents that were modified\n *     res.upsertedCount; // Number of documents that were upserted\n *     res.upsertedId; // Identifier of the inserted document (if an upsert took place)\n *\n * This function triggers the following middleware.\n *\n * - `updateOne()`\n *\n * @param {Object} [filter]\n * @param {Object|Array} [update] the update command\n * @param {Object} [options]\n * @param {Boolean} [options.multipleCastError] by default, mongoose only returns the first error that occurred in casting the query. Turn on this option to aggregate all the cast errors.\n * @param {Boolean|String} [options.strict] overwrites the schema's [strict mode option](https://mongoosejs.com/docs/guide.html#strict)\n * @param {Boolean} [options.upsert=false] if true, and no documents found, insert a new document\n * @param {Object} [options.writeConcern=null] sets the [write concern](https://www.mongodb.com/docs/manual/reference/write-concern/) for replica sets. Overrides the [schema-level write concern](https://mongoosejs.com/docs/guide.html#writeConcern)\n * @param {Boolean} [options.timestamps=null] If set to `false` and [schema-level timestamps](https://mongoosejs.com/docs/guide.html#timestamps) are enabled, skip timestamps for this update. Note that this allows you to overwrite timestamps. Does nothing if schema-level timestamps are not set.\n @param {Boolean} [options.translateAliases=null] If set to `true`, translates any schema-defined aliases in `filter`, `projection`, `update`, and `distinct`. Throws an error if there are any conflicts where both alias and raw property are defined on the same object.\n * @param {Function} [callback] params are (error, writeOpResult)\n * @return {Query} this\n * @see Model.update https://mongoosejs.com/docs/api/model.html#Model.update()\n * @see Query docs https://mongoosejs.com/docs/queries.html\n * @see update https://www.mongodb.com/docs/manual/reference/method/db.collection.update/\n * @see UpdateResult https://mongodb.github.io/node-mongodb-native/4.9/interfaces/UpdateResult.html\n * @see MongoDB docs https://www.mongodb.com/docs/manual/reference/command/update/#update-command-output\n * @api public\n */\n\nQuery.prototype.updateOne = function(conditions, doc, options, callback) {\n  if (typeof options === 'function') {\n    // .update(conditions, doc, callback)\n    callback = options;\n    options = null;\n  } else if (typeof doc === 'function') {\n    // .update(doc, callback);\n    callback = doc;\n    doc = conditions;\n    conditions = {};\n    options = null;\n  } else if (typeof conditions === 'function') {\n    // .update(callback)\n    callback = conditions;\n    conditions = undefined;\n    doc = undefined;\n    options = undefined;\n  } else if (typeof conditions === 'object' && !doc && !options && !callback) {\n    // .update(doc)\n    doc = conditions;\n    conditions = undefined;\n    options = undefined;\n    callback = undefined;\n  }\n\n  return _update(this, 'updateOne', conditions, doc, options, callback);\n};\n\n/**\n * Declare and/or execute this query as a replaceOne() operation.\n * MongoDB will replace the existing document and will not accept any [atomic operators](https://www.mongodb.com/docs/manual/tutorial/model-data-for-atomic-operations/#pattern) (`$set`, etc.)\n *\n * **Note** replaceOne will _not_ fire update middleware. Use `pre('replaceOne')`\n * and `post('replaceOne')` instead.\n *\n * #### Example:\n *\n *     const res = await Person.replaceOne({ _id: 24601 }, { name: 'Jean Valjean' });\n *     res.acknowledged; // Indicates if this write result was acknowledged. If not, then all other members of this result will be undefined.\n *     res.matchedCount; // Number of documents that matched the filter\n *     res.modifiedCount; // Number of documents that were modified\n *     res.upsertedCount; // Number of documents that were upserted\n *     res.upsertedId; // Identifier of the inserted document (if an upsert took place)\n *\n * This function triggers the following middleware.\n *\n * - `replaceOne()`\n *\n * @param {Object} [filter]\n * @param {Object} [doc] the update command\n * @param {Object} [options]\n * @param {Boolean} [options.multipleCastError] by default, mongoose only returns the first error that occurred in casting the query. Turn on this option to aggregate all the cast errors.\n * @param {Boolean|String} [options.strict] overwrites the schema's [strict mode option](https://mongoosejs.com/docs/guide.html#strict)\n * @param {Boolean} [options.upsert=false] if true, and no documents found, insert a new document\n * @param {Object} [options.writeConcern=null] sets the [write concern](https://www.mongodb.com/docs/manual/reference/write-concern/) for replica sets. Overrides the [schema-level write concern](https://mongoosejs.com/docs/guide.html#writeConcern)\n * @param {Boolean} [options.timestamps=null] If set to `false` and [schema-level timestamps](https://mongoosejs.com/docs/guide.html#timestamps) are enabled, skip timestamps for this update. Does nothing if schema-level timestamps are not set.\n * @param {Boolean} [options.translateAliases=null] If set to `true`, translates any schema-defined aliases in `filter`, `projection`, `update`, and `distinct`. Throws an error if there are any conflicts where both alias and raw property are defined on the same object.\n * @param {Function} [callback] params are (error, writeOpResult)\n * @return {Query} this\n * @see Model.update https://mongoosejs.com/docs/api/model.html#Model.update()\n * @see Query docs https://mongoosejs.com/docs/queries.html\n * @see update https://www.mongodb.com/docs/manual/reference/method/db.collection.update/\n * @see UpdateResult https://mongodb.github.io/node-mongodb-native/4.9/interfaces/UpdateResult.html\n * @see MongoDB docs https://www.mongodb.com/docs/manual/reference/command/update/#update-command-output\n * @api public\n */\n\nQuery.prototype.replaceOne = function(conditions, doc, options, callback) {\n  if (typeof options === 'function') {\n    // .update(conditions, doc, callback)\n    callback = options;\n    options = null;\n  } else if (typeof doc === 'function') {\n    // .update(doc, callback);\n    callback = doc;\n    doc = conditions;\n    conditions = {};\n    options = null;\n  } else if (typeof conditions === 'function') {\n    // .update(callback)\n    callback = conditions;\n    conditions = undefined;\n    doc = undefined;\n    options = undefined;\n  } else if (typeof conditions === 'object' && !doc && !options && !callback) {\n    // .update(doc)\n    doc = conditions;\n    conditions = undefined;\n    options = undefined;\n    callback = undefined;\n  }\n\n  return _update(this, 'replaceOne', conditions, doc, options, callback);\n};\n\n/**\n * Internal helper for update, updateMany, updateOne, replaceOne\n * @param {Query} query\n * @param {String} op\n * @param {Object} filter\n * @param {Document} [doc]\n * @param {Object} [options]\n * @param {Function} callback\n * @api private\n */\n\nfunction _update(query, op, filter, doc, options, callback) {\n  // make sure we don't send in the whole Document to merge()\n  query.op = op;\n  query._validateOp();\n  doc = doc || {};\n\n  // strict is an option used in the update checking, make sure it gets set\n  if (options != null) {\n    if ('strict' in options) {\n      query._mongooseOptions.strict = options.strict;\n    }\n  }\n\n  if (!(filter instanceof Query) &&\n      filter != null &&\n      filter.toString() !== '[object Object]') {\n    query.error(new ObjectParameterError(filter, 'filter', op));\n  } else {\n    query.merge(filter);\n  }\n\n  if (utils.isObject(options)) {\n    query.setOptions(options);\n  }\n\n  query._mergeUpdate(doc);\n\n  // Hooks\n  if (callback) {\n    query.exec(callback);\n\n    return query;\n  }\n\n  return query;\n}\n\n/**\n * Runs a function `fn` and treats the return value of `fn` as the new value\n * for the query to resolve to.\n *\n * Any functions you pass to `transform()` will run **after** any post hooks.\n *\n * #### Example:\n *\n *     const res = await MyModel.findOne().transform(res => {\n *       // Sets a `loadedAt` property on the doc that tells you the time the\n *       // document was loaded.\n *       return res == null ?\n *         res :\n *         Object.assign(res, { loadedAt: new Date() });\n *     });\n *\n * @method transform\n * @memberOf Query\n * @instance\n * @param {Function} fn function to run to transform the query result\n * @return {Query} this\n */\n\nQuery.prototype.transform = function(fn) {\n  this._transforms.push(fn);\n  return this;\n};\n\n/**\n * Make this query throw an error if no documents match the given `filter`.\n * This is handy for integrating with async/await, because `orFail()` saves you\n * an extra `if` statement to check if no document was found.\n *\n * #### Example:\n *\n *     // Throws if no doc returned\n *     await Model.findOne({ foo: 'bar' }).orFail();\n *\n *     // Throws if no document was updated. Note that `orFail()` will still\n *     // throw if the only document that matches is `{ foo: 'bar', name: 'test' }`,\n *     // because `orFail()` will throw if no document was _updated_, not\n *     // if no document was _found_.\n *     await Model.updateOne({ foo: 'bar' }, { name: 'test' }).orFail();\n *\n *     // Throws \"No docs found!\" error if no docs match `{ foo: 'bar' }`\n *     await Model.find({ foo: 'bar' }).orFail(new Error('No docs found!'));\n *\n *     // Throws \"Not found\" error if no document was found\n *     await Model.findOneAndUpdate({ foo: 'bar' }, { name: 'test' }).\n *       orFail(() => Error('Not found'));\n *\n * @method orFail\n * @memberOf Query\n * @instance\n * @param {Function|Error} [err] optional error to throw if no docs match `filter`. If not specified, `orFail()` will throw a `DocumentNotFoundError`\n * @return {Query} this\n */\n\nQuery.prototype.orFail = function(err) {\n  this.transform(res => {\n    switch (this.op) {\n      case 'find':\n        if (res.length === 0) {\n          throw _orFailError(err, this);\n        }\n        break;\n      case 'findOne':\n        if (res == null) {\n          throw _orFailError(err, this);\n        }\n        break;\n      case 'replaceOne':\n      case 'updateMany':\n      case 'updateOne':\n        if (res && res.matchedCount === 0) {\n          throw _orFailError(err, this);\n        }\n        break;\n      case 'findOneAndDelete':\n      case 'findOneAndUpdate':\n      case 'findOneAndReplace':\n        if (this.options.includeResultMetadata && res != null && res.value == null) {\n          throw _orFailError(err, this);\n        }\n        if (!this.options.includeResultMetadata && res == null) {\n          throw _orFailError(err, this);\n        }\n        break;\n      case 'deleteMany':\n      case 'deleteOne':\n        if (res.deletedCount === 0) {\n          throw _orFailError(err, this);\n        }\n        break;\n      default:\n        break;\n    }\n\n    return res;\n  });\n  return this;\n};\n\n/**\n * Get the error to throw for `orFail()`\n * @param {Error|undefined} err\n * @param {Query} query\n * @api private\n */\n\nfunction _orFailError(err, query) {\n  if (typeof err === 'function') {\n    err = err.call(query);\n  }\n\n  if (err == null) {\n    err = new DocumentNotFoundError(query.getQuery(), query.model.modelName);\n  }\n\n  return err;\n}\n\n/**\n * Wrapper function to call isPathSelectedInclusive on a query.\n * @param {String} path\n * @return {Boolean}\n * @api public\n */\n\nQuery.prototype.isPathSelectedInclusive = function(path) {\n  return isPathSelectedInclusive(this._fields, path);\n};\n\n/**\n * Executes the query\n *\n * #### Example:\n *\n *     const promise = query.exec();\n *     const promise = query.exec('update');\n *\n * @param {String|Function} [operation]\n * @return {Promise}\n * @api public\n */\n\nQuery.prototype.exec = async function exec(op) {\n  if (typeof op === 'function' || (arguments.length >= 2 && typeof arguments[1] === 'function')) {\n    throw new MongooseError('Query.prototype.exec() no longer accepts a callback');\n  }\n\n  if (typeof op === 'string') {\n    this.op = op;\n  }\n\n  if (this.op == null) {\n    throw new MongooseError('Query must have `op` before executing');\n  }\n  if (this.model == null) {\n    throw new MongooseError('Query must have an associated model before executing');\n  }\n  this._validateOp();\n\n  if (!this.op) {\n    return;\n  }\n\n  if (this.options && this.options.sort) {\n    const keys = Object.keys(this.options.sort);\n    if (keys.includes('')) {\n      throw new Error('Invalid field \"\" passed to sort()');\n    }\n  }\n\n  let thunk = '_' + this.op;\n  if (this.op === 'distinct') {\n    thunk = '__distinct';\n  }\n\n  if (this._executionStack != null) {\n    let str = this.toString();\n    if (str.length > 60) {\n      str = str.slice(0, 60) + '...';\n    }\n    const err = new MongooseError('Query was already executed: ' + str);\n    err.originalStack = this._executionStack.stack;\n    throw err;\n  } else {\n    this._executionStack = new Error();\n  }\n\n  let skipWrappedFunction = null;\n  try {\n    await _executePreExecHooks(this);\n  } catch (err) {\n    if (err instanceof Kareem.skipWrappedFunction) {\n      skipWrappedFunction = err;\n    } else {\n      throw err;\n    }\n  }\n\n  let res;\n\n  let error = null;\n  try {\n    await _executePreHooks(this);\n    res = skipWrappedFunction ? skipWrappedFunction.args[0] : await this[thunk]();\n\n    for (const fn of this._transforms) {\n      res = fn(res);\n    }\n  } catch (err) {\n    if (err instanceof Kareem.skipWrappedFunction) {\n      res = err.args[0];\n    } else {\n      error = err;\n    }\n  }\n\n  res = await _executePostHooks(this, res, error);\n\n  await _executePostExecHooks(this);\n\n  return res;\n};\n\n/*!\n * ignore\n */\n\nfunction _executePostExecHooks(query) {\n  return new Promise((resolve, reject) => {\n    query._hooks.execPost('exec', query, [], {}, (error) => {\n      if (error) {\n        return reject(error);\n      }\n\n      resolve();\n    });\n  });\n}\n\n/*!\n * ignore\n */\n\nfunction _executePostHooks(query, res, error, op) {\n  if (query._queryMiddleware == null) {\n    if (error != null) {\n      throw error;\n    }\n    return res;\n  }\n\n  return new Promise((resolve, reject) => {\n    const opts = error ? { error } : {};\n\n    query._queryMiddleware.execPost(op || query.op, query, [res], opts, (error, res) => {\n      if (error) {\n        return reject(error);\n      }\n\n      resolve(res);\n    });\n  });\n}\n\n/*!\n * ignore\n */\n\nfunction _executePreExecHooks(query) {\n  return new Promise((resolve, reject) => {\n    query._hooks.execPre('exec', query, [], (error) => {\n      if (error != null) {\n        return reject(error);\n      }\n      resolve();\n    });\n  });\n}\n\n/*!\n * ignore\n */\n\nfunction _executePreHooks(query, op) {\n  if (query._queryMiddleware == null) {\n    return;\n  }\n\n  return new Promise((resolve, reject) => {\n    query._queryMiddleware.execPre(op || query.op, query, [], (error) => {\n      if (error != null) {\n        return reject(error);\n      }\n      resolve();\n    });\n  });\n}\n\n/**\n * Executes the query returning a `Promise` which will be\n * resolved with either the doc(s) or rejected with the error.\n *\n * More about [`then()` in JavaScript](https://masteringjs.io/tutorials/fundamentals/then).\n *\n * @param {Function} [resolve]\n * @param {Function} [reject]\n * @return {Promise}\n * @api public\n */\n\nQuery.prototype.then = function(resolve, reject) {\n  return this.exec().then(resolve, reject);\n};\n\n/**\n * Executes the query returning a `Promise` which will be\n * resolved with either the doc(s) or rejected with the error.\n * Like `.then()`, but only takes a rejection handler.\n *\n * More about [Promise `catch()` in JavaScript](https://masteringjs.io/tutorials/fundamentals/catch).\n *\n * @param {Function} [reject]\n * @return {Promise}\n * @api public\n */\n\nQuery.prototype.catch = function(reject) {\n  return this.exec().then(null, reject);\n};\n\n/**\n * Executes the query returning a `Promise` which will be\n * resolved with `.finally()` chained.\n *\n * More about [Promise `finally()` in JavaScript](https://thecodebarbarian.com/using-promise-finally-in-node-js.html).\n *\n * @param {Function} [onFinally]\n * @return {Promise}\n * @api public\n */\n\nQuery.prototype.finally = function(onFinally) {\n  return this.exec().finally(onFinally);\n};\n\n/**\n * Returns a string representation of this query.\n *\n * More about [`toString()` in JavaScript](https://masteringjs.io/tutorials/fundamentals/tostring).\n *\n * #### Example:\n *     const q = Model.find();\n *     console.log(q); // Prints \"Query { find }\"\n *\n * @return {String}\n * @api public\n * @method [Symbol.toStringTag]\n * @memberOf Query\n */\n\nQuery.prototype[Symbol.toStringTag] = function toString() {\n  return `Query { ${this.op} }`;\n};\n\n/**\n * Add pre [middleware](https://mongoosejs.com/docs/middleware.html) to this query instance. Doesn't affect\n * other queries.\n *\n * #### Example:\n *\n *     const q1 = Question.find({ answer: 42 });\n *     q1.pre(function middleware() {\n *       console.log(this.getFilter());\n *     });\n *     await q1.exec(); // Prints \"{ answer: 42 }\"\n *\n *     // Doesn't print anything, because `middleware()` is only\n *     // registered on `q1`.\n *     await Question.find({ answer: 42 });\n *\n * @param {Function} fn\n * @return {Promise}\n * @api public\n */\n\nQuery.prototype.pre = function(fn) {\n  this._hooks.pre('exec', fn);\n  return this;\n};\n\n/**\n * Add post [middleware](https://mongoosejs.com/docs/middleware.html) to this query instance. Doesn't affect\n * other queries.\n *\n * #### Example:\n *\n *     const q1 = Question.find({ answer: 42 });\n *     q1.post(function middleware() {\n *       console.log(this.getFilter());\n *     });\n *     await q1.exec(); // Prints \"{ answer: 42 }\"\n *\n *     // Doesn't print anything, because `middleware()` is only\n *     // registered on `q1`.\n *     await Question.find({ answer: 42 });\n *\n * @param {Function} fn\n * @return {Promise}\n * @api public\n */\n\nQuery.prototype.post = function(fn) {\n  this._hooks.post('exec', fn);\n  return this;\n};\n\n/**\n * Casts obj for an update command.\n *\n * @param {Object} obj\n * @return {Object} obj after casting its values\n * @method _castUpdate\n * @memberOf Query\n * @instance\n * @api private\n */\n\nQuery.prototype._castUpdate = function _castUpdate(obj) {\n  let schema = this.schema;\n\n  const discriminatorKey = schema.options.discriminatorKey;\n  const baseSchema = schema._baseSchema ? schema._baseSchema : schema;\n  if (this._mongooseOptions.overwriteDiscriminatorKey &&\n      obj[discriminatorKey] != null &&\n      baseSchema.discriminators) {\n    const _schema = Object.values(baseSchema.discriminators).find(\n      discriminator => discriminator.discriminatorMapping.value === obj[discriminatorKey]\n    );\n    if (_schema != null) {\n      schema = _schema;\n    }\n  }\n\n  let upsert;\n  if ('upsert' in this.options) {\n    upsert = this.options.upsert;\n  }\n\n  const filter = this._conditions;\n  if (schema != null &&\n      utils.hasUserDefinedProperty(filter, schema.options.discriminatorKey) &&\n      typeof filter[schema.options.discriminatorKey] !== 'object' &&\n      schema.discriminators != null) {\n    const discriminatorValue = filter[schema.options.discriminatorKey];\n    const byValue = getDiscriminatorByValue(this.model.discriminators, discriminatorValue);\n    schema = schema.discriminators[discriminatorValue] ||\n      (byValue && byValue.schema) ||\n      schema;\n  }\n\n  return castUpdate(schema, obj, {\n    strict: this._mongooseOptions.strict,\n    upsert: upsert,\n    arrayFilters: this.options.arrayFilters,\n    overwriteDiscriminatorKey: this._mongooseOptions.overwriteDiscriminatorKey\n  }, this, this._conditions);\n};\n\n/**\n * Specifies paths which should be populated with other documents.\n *\n * #### Example:\n *\n *     let book = await Book.findOne().populate('authors');\n *     book.title; // 'Node.js in Action'\n *     book.authors[0].name; // 'TJ Holowaychuk'\n *     book.authors[1].name; // 'Nathan Rajlich'\n *\n *     let books = await Book.find().populate({\n *       path: 'authors',\n *       // `match` and `sort` apply to the Author model,\n *       // not the Book model. These options do not affect\n *       // which documents are in `books`, just the order and\n *       // contents of each book document's `authors`.\n *       match: { name: new RegExp('.*h.*', 'i') },\n *       sort: { name: -1 }\n *     });\n *     books[0].title; // 'Node.js in Action'\n *     // Each book's `authors` are sorted by name, descending.\n *     books[0].authors[0].name; // 'TJ Holowaychuk'\n *     books[0].authors[1].name; // 'Marc Harter'\n *\n *     books[1].title; // 'Professional AngularJS'\n *     // Empty array, no authors' name has the letter 'h'\n *     books[1].authors; // []\n *\n * Paths are populated after the query executes and a response is received. A\n * separate query is then executed for each path specified for population. After\n * a response for each query has also been returned, the results are passed to\n * the callback.\n *\n * @param {Object|String|String[]} path either the path(s) to populate or an object specifying all parameters\n * @param {Object|String} [select] Field selection for the population query\n * @param {Model} [model] The model you wish to use for population. If not specified, populate will look up the model by the name in the Schema's `ref` field.\n * @param {Object} [match] Conditions for the population query\n * @param {Object} [options] Options for the population query (sort, etc)\n * @param {String} [options.path=null] The path to populate.\n * @param {boolean} [options.retainNullValues=false] by default, Mongoose removes null and undefined values from populated arrays. Use this option to make `populate()` retain `null` and `undefined` array entries.\n * @param {boolean} [options.getters=false] if true, Mongoose will call any getters defined on the `localField`. By default, Mongoose gets the raw value of `localField`. For example, you would need to set this option to `true` if you wanted to [add a `lowercase` getter to your `localField`](https://mongoosejs.com/docs/schematypes.html#schematype-options).\n * @param {boolean} [options.clone=false] When you do `BlogPost.find().populate('author')`, blog posts with the same author will share 1 copy of an `author` doc. Enable this option to make Mongoose clone populated docs before assigning them.\n * @param {Object|Function} [options.match=null] Add an additional filter to the populate query. Can be a filter object containing [MongoDB query syntax](https://www.mongodb.com/docs/manual/tutorial/query-documents/), or a function that returns a filter object.\n * @param {Function} [options.transform=null] Function that Mongoose will call on every populated document that allows you to transform the populated document.\n * @param {Object} [options.options=null] Additional options like `limit` and `lean`.\n * @see population https://mongoosejs.com/docs/populate.html\n * @see Query#select https://mongoosejs.com/docs/api/query.html#Query.prototype.select()\n * @see Model.populate https://mongoosejs.com/docs/api/model.html#Model.populate()\n * @return {Query} this\n * @api public\n */\n\nQuery.prototype.populate = function() {\n  // Bail when given no truthy arguments\n  if (!Array.from(arguments).some(Boolean)) {\n    return this;\n  }\n\n  const res = utils.populate.apply(null, arguments);\n\n  // Propagate readConcern and readPreference and lean from parent query,\n  // unless one already specified\n  if (this.options != null) {\n    const readConcern = this.options.readConcern;\n    const readPref = this.options.readPreference;\n\n    for (const populateOptions of res) {\n      if (readConcern != null && (populateOptions && populateOptions.options && populateOptions.options.readConcern) == null) {\n        populateOptions.options = populateOptions.options || {};\n        populateOptions.options.readConcern = readConcern;\n      }\n      if (readPref != null && (populateOptions && populateOptions.options && populateOptions.options.readPreference) == null) {\n        populateOptions.options = populateOptions.options || {};\n        populateOptions.options.readPreference = readPref;\n      }\n    }\n  }\n\n  const opts = this._mongooseOptions;\n\n  if (opts.lean != null) {\n    const lean = opts.lean;\n    for (const populateOptions of res) {\n      if ((populateOptions && populateOptions.options && populateOptions.options.lean) == null) {\n        populateOptions.options = populateOptions.options || {};\n        populateOptions.options.lean = lean;\n      }\n    }\n  }\n\n  if (!utils.isObject(opts.populate)) {\n    opts.populate = {};\n  }\n\n  const pop = opts.populate;\n\n  for (const populateOptions of res) {\n    const path = populateOptions.path;\n    if (pop[path] && pop[path].populate && populateOptions.populate) {\n      populateOptions.populate = pop[path].populate.concat(populateOptions.populate);\n    }\n\n    pop[populateOptions.path] = populateOptions;\n  }\n  return this;\n};\n\n/**\n * Gets a list of paths to be populated by this query\n *\n * #### Example:\n *\n *      bookSchema.pre('findOne', function() {\n *        let keys = this.getPopulatedPaths(); // ['author']\n *      });\n *      ...\n *      Book.findOne({}).populate('author');\n *\n * #### Example:\n *\n *      // Deep populate\n *      const q = L1.find().populate({\n *        path: 'level2',\n *        populate: { path: 'level3' }\n *      });\n *      q.getPopulatedPaths(); // ['level2', 'level2.level3']\n *\n * @return {Array} an array of strings representing populated paths\n * @api public\n */\n\nQuery.prototype.getPopulatedPaths = function getPopulatedPaths() {\n  const obj = this._mongooseOptions.populate || {};\n  const ret = Object.keys(obj);\n  for (const path of Object.keys(obj)) {\n    const pop = obj[path];\n    if (!Array.isArray(pop.populate)) {\n      continue;\n    }\n    _getPopulatedPaths(ret, pop.populate, path + '.');\n  }\n  return ret;\n};\n\n/*!\n * ignore\n */\n\nfunction _getPopulatedPaths(list, arr, prefix) {\n  for (const pop of arr) {\n    list.push(prefix + pop.path);\n    if (!Array.isArray(pop.populate)) {\n      continue;\n    }\n    _getPopulatedPaths(list, pop.populate, prefix + pop.path + '.');\n  }\n}\n\n/**\n * Casts this query to the schema of `model`\n *\n * #### Note:\n *\n * If `obj` is present, it is cast instead of this query.\n *\n * @param {Model} [model] the model to cast to. If not set, defaults to `this.model`\n * @param {Object} [obj]\n * @return {Object}\n * @api public\n */\n\nQuery.prototype.cast = function(model, obj) {\n  obj || (obj = this._conditions);\n  model = model || this.model;\n  const discriminatorKey = model.schema.options.discriminatorKey;\n  if (obj != null &&\n      obj.hasOwnProperty(discriminatorKey)) {\n    model = getDiscriminatorByValue(model.discriminators, obj[discriminatorKey]) || model;\n  }\n\n  const opts = { upsert: this.options && this.options.upsert };\n  if (this.options) {\n    if ('strict' in this.options) {\n      opts.strict = this.options.strict;\n    }\n    if ('strictQuery' in this.options) {\n      opts.strictQuery = this.options.strictQuery;\n    }\n  }\n\n  try {\n    return cast(model.schema, obj, opts, this);\n  } catch (err) {\n    // CastError, assign model\n    if (typeof err.setModel === 'function') {\n      err.setModel(model);\n    }\n    throw err;\n  }\n};\n\n/**\n * Casts selected field arguments for field selection with mongo 2.2\n *\n *     query.select({ ids: { $elemMatch: { $in: [hexString] }})\n *\n * @param {Object} fields\n * @see https://github.com/Automattic/mongoose/issues/1091\n * @see https://www.mongodb.com/docs/manual/reference/projection/elemMatch/\n * @api private\n */\n\nQuery.prototype._castFields = function _castFields(fields) {\n  let selected,\n      elemMatchKeys,\n      keys,\n      key,\n      out;\n\n  if (fields) {\n    keys = Object.keys(fields);\n    elemMatchKeys = [];\n\n    // collect $elemMatch args\n    for (let i = 0; i < keys.length; ++i) {\n      key = keys[i];\n      if (fields[key].$elemMatch) {\n        selected || (selected = {});\n        selected[key] = fields[key];\n        elemMatchKeys.push(key);\n      }\n    }\n  }\n\n  if (selected) {\n    // they passed $elemMatch, cast em\n    try {\n      out = this.cast(this.model, selected);\n    } catch (err) {\n      return err;\n    }\n\n    // apply the casted field args\n    for (let i = 0; i < elemMatchKeys.length; ++i) {\n      key = elemMatchKeys[i];\n      fields[key] = out[key];\n    }\n  }\n\n  return fields;\n};\n\n/**\n * Applies schematype selected options to this query.\n * @api private\n */\n\nQuery.prototype._applyPaths = function applyPaths() {\n  if (!this.model) {\n    return;\n  }\n  this._fields = this._fields || {};\n  helpers.applyPaths(this._fields, this.model.schema);\n\n  let _selectPopulatedPaths = true;\n\n  if ('selectPopulatedPaths' in this.model.base.options) {\n    _selectPopulatedPaths = this.model.base.options.selectPopulatedPaths;\n  }\n  if ('selectPopulatedPaths' in this.model.schema.options) {\n    _selectPopulatedPaths = this.model.schema.options.selectPopulatedPaths;\n  }\n\n  if (_selectPopulatedPaths) {\n    selectPopulatedFields(this._fields, this._userProvidedFields, this._mongooseOptions.populate);\n  }\n};\n\n/**\n * Returns a wrapper around a [mongodb driver cursor](https://mongodb.github.io/node-mongodb-native/4.9/classes/FindCursor.html).\n * A QueryCursor exposes a Streams3 interface, as well as a `.next()` function.\n *\n * The `.cursor()` function triggers pre find hooks, but **not** post find hooks.\n *\n * #### Example:\n *\n *     // There are 2 ways to use a cursor. First, as a stream:\n *     Thing.\n *       find({ name: /^hello/ }).\n *       cursor().\n *       on('data', function(doc) { console.log(doc); }).\n *       on('end', function() { console.log('Done!'); });\n *\n *     // Or you can use `.next()` to manually get the next doc in the stream.\n *     // `.next()` returns a promise, so you can use promises or callbacks.\n *     const cursor = Thing.find({ name: /^hello/ }).cursor();\n *     cursor.next(function(error, doc) {\n *       console.log(doc);\n *     });\n *\n *     // Because `.next()` returns a promise, you can use co\n *     // to easily iterate through all documents without loading them\n *     // all into memory.\n *     const cursor = Thing.find({ name: /^hello/ }).cursor();\n *     for (let doc = await cursor.next(); doc != null; doc = await cursor.next()) {\n *       console.log(doc);\n *     }\n *\n * #### Valid options\n *\n *   - `transform`: optional function which accepts a mongoose document. The return value of the function will be emitted on `data` and returned by `.next()`.\n *\n * @return {QueryCursor}\n * @param {Object} [options]\n * @see QueryCursor https://mongoosejs.com/docs/api/querycursor.html\n * @api public\n */\n\nQuery.prototype.cursor = function cursor(opts) {\n  if (opts) {\n    this.setOptions(opts);\n  }\n\n  try {\n    this.cast(this.model);\n  } catch (err) {\n    return (new QueryCursor(this))._markError(err);\n  }\n\n  return new QueryCursor(this);\n};\n\n// the rest of these are basically to support older Mongoose syntax with mquery\n\n/**\n * Sets the tailable option (for use with capped collections).\n *\n * #### Example:\n *\n *     query.tailable(); // true\n *     query.tailable(true);\n *     query.tailable(false);\n *\n *     // Set both `tailable` and `awaitData` options\n *     query.tailable({ awaitData: true });\n *\n * #### Note:\n *\n * Cannot be used with `distinct()`\n *\n * @param {Boolean} bool defaults to true\n * @param {Object} [opts] options to set\n * @param {Boolean} [opts.awaitData] false by default. Set to true to keep the cursor open even if there's no data.\n * @param {Number} [opts.maxAwaitTimeMS] the maximum amount of time for the server to wait on new documents to satisfy a tailable cursor query. Requires `tailable` and `awaitData` to be true\n * @see tailable https://www.mongodb.com/docs/manual/tutorial/create-tailable-cursor/\n * @api public\n */\n\nQuery.prototype.tailable = function(val, opts) {\n  // we need to support the tailable({ awaitData : true }) as well as the\n  // tailable(true, {awaitData :true}) syntax that mquery does not support\n  if (val != null && typeof val.constructor === 'function' && val.constructor.name === 'Object') {\n    opts = val;\n    val = true;\n  }\n\n  if (val === undefined) {\n    val = true;\n  }\n\n  if (opts && typeof opts === 'object') {\n    for (const key of Object.keys(opts)) {\n      if (key === 'awaitData' || key === 'awaitdata') { // backwards compat, see gh-10875\n        // For backwards compatibility\n        this.options['awaitData'] = !!opts[key];\n      } else {\n        this.options[key] = opts[key];\n      }\n    }\n  }\n\n  this.options.tailable = arguments.length ? !!val : true;\n\n  return this;\n};\n\n/**\n * Declares an intersects query for `geometry()`.\n *\n * #### Example:\n *\n *     query.where('path').intersects().geometry({\n *       type: 'LineString',\n *       coordinates: [[180.0, 11.0], [180, 9.0]]\n *     });\n *\n *     query.where('path').intersects({\n *       type: 'LineString',\n *       coordinates: [[180.0, 11.0], [180, 9.0]]\n *     });\n *\n * #### Note:\n *\n * **MUST** be used after `where()`.\n *\n * #### Note:\n *\n * In Mongoose 3.7, `intersects` changed from a getter to a function. If you need the old syntax, use [this](https://github.com/ebensing/mongoose-within).\n *\n * @method intersects\n * @memberOf Query\n * @instance\n * @param {Object} [arg]\n * @return {Query} this\n * @see $geometry https://www.mongodb.com/docs/manual/reference/operator/geometry/\n * @see geoIntersects https://www.mongodb.com/docs/manual/reference/operator/geoIntersects/\n * @api public\n */\n\n/**\n * Specifies a `$geometry` condition\n *\n * #### Example:\n *\n *     const polyA = [[[ 10, 20 ], [ 10, 40 ], [ 30, 40 ], [ 30, 20 ]]]\n *     query.where('loc').within().geometry({ type: 'Polygon', coordinates: polyA })\n *\n *     // or\n *     const polyB = [[ 0, 0 ], [ 1, 1 ]]\n *     query.where('loc').within().geometry({ type: 'LineString', coordinates: polyB })\n *\n *     // or\n *     const polyC = [ 0, 0 ]\n *     query.where('loc').within().geometry({ type: 'Point', coordinates: polyC })\n *\n *     // or\n *     query.where('loc').intersects().geometry({ type: 'Point', coordinates: polyC })\n *\n * The argument is assigned to the most recent path passed to `where()`.\n *\n * #### Note:\n *\n * `geometry()` **must** come after either `intersects()` or `within()`.\n *\n * The `object` argument must contain `type` and `coordinates` properties.\n * - type {String}\n * - coordinates {Array}\n *\n * @method geometry\n * @memberOf Query\n * @instance\n * @param {Object} object Must contain a `type` property which is a String and a `coordinates` property which is an Array. See the examples.\n * @return {Query} this\n * @see $geometry https://www.mongodb.com/docs/manual/reference/operator/geometry/\n * @see Geospatial Support Enhancements https://www.mongodb.com/docs/manual/release-notes/2.4/#geospatial-support-enhancements\n * @see MongoDB Geospatial Indexing https://www.mongodb.com/docs/manual/core/geospatial-indexes/\n * @api public\n */\n\n/**\n * Specifies a `$near` or `$nearSphere` condition\n *\n * These operators return documents sorted by distance.\n *\n * #### Example:\n *\n *     query.where('loc').near({ center: [10, 10] });\n *     query.where('loc').near({ center: [10, 10], maxDistance: 5 });\n *     query.where('loc').near({ center: [10, 10], maxDistance: 5, spherical: true });\n *     query.near('loc', { center: [10, 10], maxDistance: 5 });\n *\n * @method near\n * @memberOf Query\n * @instance\n * @param {String} [path]\n * @param {Object} val\n * @return {Query} this\n * @see $near https://www.mongodb.com/docs/manual/reference/operator/near/\n * @see $nearSphere https://www.mongodb.com/docs/manual/reference/operator/nearSphere/\n * @see $maxDistance https://www.mongodb.com/docs/manual/reference/operator/maxDistance/\n * @see MongoDB Geospatial Indexing https://www.mongodb.com/docs/manual/core/geospatial-indexes/\n * @api public\n */\n\n/**\n * Overwriting mquery is needed to support a couple different near() forms found in older\n * versions of mongoose\n * near([1,1])\n * near(1,1)\n * near(field, [1,2])\n * near(field, 1, 2)\n * In addition to all of the normal forms supported by mquery\n *\n * @method near\n * @memberOf Query\n * @instance\n * @api private\n */\n\nQuery.prototype.near = function() {\n  const params = [];\n  const sphere = this._mongooseOptions.nearSphere;\n\n  // TODO refactor\n\n  if (arguments.length === 1) {\n    if (Array.isArray(arguments[0])) {\n      params.push({ center: arguments[0], spherical: sphere });\n    } else if (typeof arguments[0] === 'string') {\n      // just passing a path\n      params.push(arguments[0]);\n    } else if (utils.isObject(arguments[0])) {\n      if (typeof arguments[0].spherical !== 'boolean') {\n        arguments[0].spherical = sphere;\n      }\n      params.push(arguments[0]);\n    } else {\n      throw new TypeError('invalid argument');\n    }\n  } else if (arguments.length === 2) {\n    if (typeof arguments[0] === 'number' && typeof arguments[1] === 'number') {\n      params.push({ center: [arguments[0], arguments[1]], spherical: sphere });\n    } else if (typeof arguments[0] === 'string' && Array.isArray(arguments[1])) {\n      params.push(arguments[0]);\n      params.push({ center: arguments[1], spherical: sphere });\n    } else if (typeof arguments[0] === 'string' && utils.isObject(arguments[1])) {\n      params.push(arguments[0]);\n      if (typeof arguments[1].spherical !== 'boolean') {\n        arguments[1].spherical = sphere;\n      }\n      params.push(arguments[1]);\n    } else {\n      throw new TypeError('invalid argument');\n    }\n  } else if (arguments.length === 3) {\n    if (typeof arguments[0] === 'string' && typeof arguments[1] === 'number'\n        && typeof arguments[2] === 'number') {\n      params.push(arguments[0]);\n      params.push({ center: [arguments[1], arguments[2]], spherical: sphere });\n    } else {\n      throw new TypeError('invalid argument');\n    }\n  } else {\n    throw new TypeError('invalid argument');\n  }\n\n  return Query.base.near.apply(this, params);\n};\n\n/**\n * _DEPRECATED_ Specifies a `$nearSphere` condition\n *\n * #### Example:\n *\n *     query.where('loc').nearSphere({ center: [10, 10], maxDistance: 5 });\n *\n * **Deprecated.** Use `query.near()` instead with the `spherical` option set to `true`.\n *\n * #### Example:\n *\n *     query.where('loc').near({ center: [10, 10], spherical: true });\n *\n * @deprecated\n * @see near() https://mongoosejs.com/docs/api/query.html#Query.prototype.near()\n * @see $near https://www.mongodb.com/docs/manual/reference/operator/near/\n * @see $nearSphere https://www.mongodb.com/docs/manual/reference/operator/nearSphere/\n * @see $maxDistance https://www.mongodb.com/docs/manual/reference/operator/maxDistance/\n */\n\nQuery.prototype.nearSphere = function() {\n  this._mongooseOptions.nearSphere = true;\n  this.near.apply(this, arguments);\n  return this;\n};\n\n/**\n * Returns an asyncIterator for use with [`for/await/of` loops](https://thecodebarbarian.com/getting-started-with-async-iterators-in-node-js)\n * This function *only* works for `find()` queries.\n * You do not need to call this function explicitly, the JavaScript runtime\n * will call it for you.\n *\n * #### Example:\n *\n *     for await (const doc of Model.aggregate([{ $sort: { name: 1 } }])) {\n *       console.log(doc.name);\n *     }\n *\n * Node.js 10.x supports async iterators natively without any flags. You can\n * enable async iterators in Node.js 8.x using the [`--harmony_async_iteration` flag](https://github.com/tc39/proposal-async-iteration/issues/117#issuecomment-346695187).\n *\n * **Note:** This function is not if `Symbol.asyncIterator` is undefined. If\n * `Symbol.asyncIterator` is undefined, that means your Node.js version does not\n * support async iterators.\n *\n * @method [Symbol.asyncIterator]\n * @memberOf Query\n * @instance\n * @api public\n */\n\nif (Symbol.asyncIterator != null) {\n  Query.prototype[Symbol.asyncIterator] = function() {\n    return this.cursor().transformNull()._transformForAsyncIterator();\n  };\n}\n\n/**\n * Specifies a `$polygon` condition\n *\n * #### Example:\n *\n *     query.where('loc').within().polygon([10, 20], [13, 25], [7, 15]);\n *     query.polygon('loc', [10, 20], [13, 25], [7, 15]);\n *\n * @method polygon\n * @memberOf Query\n * @instance\n * @param {String|Array} [path]\n * @param {...Array|Object} [coordinatePairs]\n * @return {Query} this\n * @see $polygon https://www.mongodb.com/docs/manual/reference/operator/polygon/\n * @see MongoDB Geospatial Indexing https://www.mongodb.com/docs/manual/core/geospatial-indexes/\n * @api public\n */\n\n/**\n * Specifies a `$box` condition\n *\n * #### Example:\n *\n *     const lowerLeft = [40.73083, -73.99756]\n *     const upperRight= [40.741404,  -73.988135]\n *\n *     query.where('loc').within().box(lowerLeft, upperRight)\n *     query.box({ ll : lowerLeft, ur : upperRight })\n *\n * @method box\n * @memberOf Query\n * @instance\n * @see $box https://www.mongodb.com/docs/manual/reference/operator/box/\n * @see within() Query#within https://mongoosejs.com/docs/api/query.html#Query.prototype.within()\n * @see MongoDB Geospatial Indexing https://www.mongodb.com/docs/manual/core/geospatial-indexes/\n * @param {Object|Array<Number>} val1 Lower Left Coordinates OR a object of lower-left(ll) and upper-right(ur) Coordinates\n * @param {Array<Number>} [val2] Upper Right Coordinates\n * @return {Query} this\n * @api public\n */\n\n/**\n * this is needed to support the mongoose syntax of:\n * box(field, { ll : [x,y], ur : [x2,y2] })\n * box({ ll : [x,y], ur : [x2,y2] })\n *\n * @method box\n * @memberOf Query\n * @instance\n * @api private\n */\n\nQuery.prototype.box = function(ll, ur) {\n  if (!Array.isArray(ll) && utils.isObject(ll)) {\n    ur = ll.ur;\n    ll = ll.ll;\n  }\n  return Query.base.box.call(this, ll, ur);\n};\n\n/**\n * Specifies a `$center` or `$centerSphere` condition.\n *\n * #### Example:\n *\n *     const area = { center: [50, 50], radius: 10, unique: true }\n *     query.where('loc').within().circle(area)\n *     // alternatively\n *     query.circle('loc', area);\n *\n *     // spherical calculations\n *     const area = { center: [50, 50], radius: 10, unique: true, spherical: true }\n *     query.where('loc').within().circle(area)\n *     // alternatively\n *     query.circle('loc', area);\n *\n * @method circle\n * @memberOf Query\n * @instance\n * @param {String} [path]\n * @param {Object} area\n * @return {Query} this\n * @see $center https://www.mongodb.com/docs/manual/reference/operator/center/\n * @see $centerSphere https://www.mongodb.com/docs/manual/reference/operator/centerSphere/\n * @see $geoWithin https://www.mongodb.com/docs/manual/reference/operator/geoWithin/\n * @see MongoDB Geospatial Indexing https://www.mongodb.com/docs/manual/core/geospatial-indexes/\n * @api public\n */\n\n/**\n * _DEPRECATED_ Alias for [circle](https://mongoosejs.com/docs/api/query.html#Query.prototype.circle())\n *\n * **Deprecated.** Use [circle](https://mongoosejs.com/docs/api/query.html#Query.prototype.circle()) instead.\n *\n * @deprecated\n * @method center\n * @memberOf Query\n * @instance\n * @api public\n */\n\nQuery.prototype.center = Query.base.circle;\n\n/**\n * _DEPRECATED_ Specifies a `$centerSphere` condition\n *\n * **Deprecated.** Use [circle](https://mongoosejs.com/docs/api/query.html#Query.prototype.circle()) instead.\n *\n * #### Example:\n *\n *     const area = { center: [50, 50], radius: 10 };\n *     query.where('loc').within().centerSphere(area);\n *\n * @deprecated\n * @param {String} [path]\n * @param {Object} val\n * @return {Query} this\n * @see MongoDB Geospatial Indexing https://www.mongodb.com/docs/manual/core/geospatial-indexes/\n * @see $centerSphere https://www.mongodb.com/docs/manual/reference/operator/centerSphere/\n * @api public\n */\n\nQuery.prototype.centerSphere = function() {\n  if (arguments[0] != null && typeof arguments[0].constructor === 'function' && arguments[0].constructor.name === 'Object') {\n    arguments[0].spherical = true;\n  }\n\n  if (arguments[1] != null && typeof arguments[1].constructor === 'function' && arguments[1].constructor.name === 'Object') {\n    arguments[1].spherical = true;\n  }\n\n  Query.base.circle.apply(this, arguments);\n};\n\n/**\n * Determines if field selection has been made.\n *\n * @method selected\n * @memberOf Query\n * @instance\n * @return {Boolean}\n * @api public\n */\n\n/**\n * Determines if inclusive field selection has been made.\n *\n *     query.selectedInclusively(); // false\n *     query.select('name');\n *     query.selectedInclusively(); // true\n *\n * @method selectedInclusively\n * @memberOf Query\n * @instance\n * @return {Boolean}\n * @api public\n */\n\nQuery.prototype.selectedInclusively = function selectedInclusively() {\n  return isInclusive(this._fields);\n};\n\n/**\n * Determines if exclusive field selection has been made.\n *\n *     query.selectedExclusively(); // false\n *     query.select('-name');\n *     query.selectedExclusively(); // true\n *     query.selectedInclusively(); // false\n *\n * @method selectedExclusively\n * @memberOf Query\n * @instance\n * @return {Boolean}\n * @api public\n */\n\nQuery.prototype.selectedExclusively = function selectedExclusively() {\n  return isExclusive(this._fields);\n};\n\n/**\n * The model this query is associated with.\n *\n * #### Example:\n *\n *     const q = MyModel.find();\n *     q.model === MyModel; // true\n *\n * @api public\n * @property model\n * @memberOf Query\n * @instance\n */\n\nQuery.prototype.model;\n\n/*!\n * Export\n */\n\nmodule.exports = Query;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvcXVlcnkuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7QUFDQTtBQUNBOztBQUVBLGtCQUFrQixtQkFBTyxDQUFDLHVFQUFjO0FBQ3hDLDhCQUE4QixtQkFBTyxDQUFDLCtFQUFrQjtBQUN4RCxlQUFlLG1CQUFPLENBQUMsc0RBQVE7QUFDL0Isc0JBQXNCLG1CQUFPLENBQUMseUZBQXVCO0FBQ3JELDZCQUE2QixtQkFBTyxDQUFDLDZGQUF5QjtBQUM5RCxvQkFBb0IsbUJBQU8sQ0FBQyx1RkFBc0I7QUFDbEQsd0JBQXdCLG1CQUFPLENBQUMsbUZBQW9CO0FBQ3BELFFBQVEsMkNBQTJDLEVBQUUsbUJBQU8sQ0FBQyxpSEFBbUM7QUFDaEcsb0NBQW9DLG1CQUFPLENBQUMscUlBQTZDO0FBQ3pGLDBCQUEwQixtQkFBTyxDQUFDLG1IQUFvQztBQUN0RSxhQUFhLG1CQUFPLENBQUMsMkRBQVE7QUFDN0IseUJBQXlCLG1CQUFPLENBQUMsaUhBQW1DO0FBQ3BFLG1CQUFtQixtQkFBTyxDQUFDLHlFQUFlO0FBQzFDLG1CQUFtQixtQkFBTyxDQUFDLG1HQUE0QjtBQUN2RCxjQUFjLG1CQUFPLENBQUMsNkVBQWlCO0FBQ3ZDLGdDQUFnQyxtQkFBTyxDQUFDLDZJQUFpRDtBQUN6RixnQkFBZ0IsbUJBQU8sQ0FBQywyRUFBZ0I7QUFDeEMsa0JBQWtCLG1CQUFPLENBQUMscUZBQXFCO0FBQy9DLGdDQUFnQyxnSEFBNEM7QUFDNUUsb0JBQW9CLG1CQUFPLENBQUMsK0dBQWtDO0FBQzlELG9CQUFvQixtQkFBTyxDQUFDLCtHQUFrQztBQUM5RCxnQ0FBZ0MsbUJBQU8sQ0FBQyx1SUFBOEM7QUFDdEYsa0JBQWtCLG1CQUFPLENBQUMsMkdBQWdDO0FBQzFELGNBQWMsbUJBQU8sQ0FBQyxvREFBTztBQUM3QixlQUFlLG1CQUFPLENBQUMsMkRBQVE7QUFDL0Isd0JBQXdCLG1CQUFPLENBQUMsdUhBQXNDO0FBQ3RFLGlDQUFp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QTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQSxvQ0FBb0M7QUFDcEMsb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2xpZW50Ly4uL3NlcnZlci9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL3F1ZXJ5LmpzP2E5NmMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG4vKiFcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxuY29uc3QgQ2FzdEVycm9yID0gcmVxdWlyZSgnLi9lcnJvci9jYXN0Jyk7XG5jb25zdCBEb2N1bWVudE5vdEZvdW5kRXJyb3IgPSByZXF1aXJlKCcuL2Vycm9yL25vdEZvdW5kJyk7XG5jb25zdCBLYXJlZW0gPSByZXF1aXJlKCdrYXJlZW0nKTtcbmNvbnN0IE1vbmdvb3NlRXJyb3IgPSByZXF1aXJlKCcuL2Vycm9yL21vbmdvb3NlRXJyb3InKTtcbmNvbnN0IE9iamVjdFBhcmFtZXRlckVycm9yID0gcmVxdWlyZSgnLi9lcnJvci9vYmplY3RQYXJhbWV0ZXInKTtcbmNvbnN0IFF1ZXJ5Q3Vyc29yID0gcmVxdWlyZSgnLi9jdXJzb3IvcXVlcnlDdXJzb3InKTtcbmNvbnN0IFZhbGlkYXRpb25FcnJvciA9IHJlcXVpcmUoJy4vZXJyb3IvdmFsaWRhdGlvbicpO1xuY29uc3QgeyBhcHBseUdsb2JhbE1heFRpbWVNUywgYXBwbHlHbG9iYWxEaXNrVXNlIH0gPSByZXF1aXJlKCcuL2hlbHBlcnMvcXVlcnkvYXBwbHlHbG9iYWxPcHRpb24nKTtcbmNvbnN0IGhhbmRsZVJlYWRQcmVmZXJlbmNlQWxpYXNlcyA9IHJlcXVpcmUoJy4vaGVscGVycy9xdWVyeS9oYW5kbGVSZWFkUHJlZmVyZW5jZUFsaWFzZXMnKTtcbmNvbnN0IGFwcGx5V3JpdGVDb25jZXJuID0gcmVxdWlyZSgnLi9oZWxwZXJzL3NjaGVtYS9hcHBseVdyaXRlQ29uY2VybicpO1xuY29uc3QgY2FzdCA9IHJlcXVpcmUoJy4vY2FzdCcpO1xuY29uc3QgY2FzdEFycmF5RmlsdGVycyA9IHJlcXVpcmUoJy4vaGVscGVycy91cGRhdGUvY2FzdEFycmF5RmlsdGVycycpO1xuY29uc3QgY2FzdE51bWJlciA9IHJlcXVpcmUoJy4vY2FzdC9udW1iZXInKTtcbmNvbnN0IGNhc3RVcGRhdGUgPSByZXF1aXJlKCcuL2hlbHBlcnMvcXVlcnkvY2FzdFVwZGF0ZScpO1xuY29uc3QgY2xvbmUgPSByZXF1aXJlKCcuL2hlbHBlcnMvY2xvbmUnKTtcbmNvbnN0IGdldERpc2NyaW1pbmF0b3JCeVZhbHVlID0gcmVxdWlyZSgnLi9oZWxwZXJzL2Rpc2NyaW1pbmF0b3IvZ2V0RGlzY3JpbWluYXRvckJ5VmFsdWUnKTtcbmNvbnN0IGhlbHBlcnMgPSByZXF1aXJlKCcuL3F1ZXJ5SGVscGVycycpO1xuY29uc3QgaW1tZWRpYXRlID0gcmVxdWlyZSgnLi9oZWxwZXJzL2ltbWVkaWF0ZScpO1xuY29uc3QgaW50ZXJuYWxUb09iamVjdE9wdGlvbnMgPSByZXF1aXJlKCcuL29wdGlvbnMnKS5pbnRlcm5hbFRvT2JqZWN0T3B0aW9ucztcbmNvbnN0IGlzRXhjbHVzaXZlID0gcmVxdWlyZSgnLi9oZWxwZXJzL3Byb2plY3Rpb24vaXNFeGNsdXNpdmUnKTtcbmNvbnN0IGlzSW5jbHVzaXZlID0gcmVxdWlyZSgnLi9oZWxwZXJzL3Byb2plY3Rpb24vaXNJbmNsdXNpdmUnKTtcbmNvbnN0IGlzUGF0aFNlbGVjdGVkSW5jbHVzaXZlID0gcmVxdWlyZSgnLi9oZWxwZXJzL3Byb2plY3Rpb24vaXNQYXRoU2VsZWN0ZWRJbmNsdXNpdmUnKTtcbmNvbnN0IGlzU3VicGF0aCA9IHJlcXVpcmUoJy4vaGVscGVycy9wcm9qZWN0aW9uL2lzU3VicGF0aCcpO1xuY29uc3QgbXBhdGggPSByZXF1aXJlKCdtcGF0aCcpO1xuY29uc3QgbXF1ZXJ5ID0gcmVxdWlyZSgnbXF1ZXJ5Jyk7XG5jb25zdCBwYXJzZVByb2plY3Rpb24gPSByZXF1aXJlKCcuL2hlbHBlcnMvcHJvamVjdGlvbi9wYXJzZVByb2plY3Rpb24nKTtcbmNvbnN0IHJlbW92ZVVudXNlZEFycmF5RmlsdGVycyA9IHJlcXVpcmUoJy4vaGVscGVycy91cGRhdGUvcmVtb3ZlVW51c2VkQXJyYXlGaWx0ZXJzJyk7XG5jb25zdCBzYW5pdGl6ZUZpbHRlciA9IHJlcXVpcmUoJy4vaGVscGVycy9xdWVyeS9zYW5pdGl6ZUZpbHRlcicpO1xuY29uc3Qgc2FuaXRpemVQcm9qZWN0aW9uID0gcmVxdWlyZSgnLi9oZWxwZXJzL3F1ZXJ5L3Nhbml0aXplUHJvamVjdGlvbicpO1xuY29uc3Qgc2VsZWN0UG9wdWxhdGVkRmllbGRzID0gcmVxdWlyZSgnLi9oZWxwZXJzL3F1ZXJ5L3NlbGVjdFBvcHVsYXRlZEZpZWxkcycpO1xuY29uc3Qgc2V0RGVmYXVsdHNPbkluc2VydCA9IHJlcXVpcmUoJy4vaGVscGVycy9zZXREZWZhdWx0c09uSW5zZXJ0Jyk7XG5jb25zdCBzcGVjaWFsUHJvcGVydGllcyA9IHJlcXVpcmUoJy4vaGVscGVycy9zcGVjaWFsUHJvcGVydGllcycpO1xuY29uc3QgdXBkYXRlVmFsaWRhdG9ycyA9IHJlcXVpcmUoJy4vaGVscGVycy91cGRhdGVWYWxpZGF0b3JzJyk7XG5jb25zdCB1dGlsID0gcmVxdWlyZSgndXRpbCcpO1xuY29uc3QgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG5jb25zdCBxdWVyeU1pZGRsZXdhcmVGdW5jdGlvbnMgPSByZXF1aXJlKCcuL2NvbnN0YW50cycpLnF1ZXJ5TWlkZGxld2FyZUZ1bmN0aW9ucztcblxuY29uc3QgcXVlcnlPcHRpb25NZXRob2RzID0gbmV3IFNldChbXG4gICdhbGxvd0Rpc2tVc2UnLFxuICAnYmF0Y2hTaXplJyxcbiAgJ2NvbGxhdGlvbicsXG4gICdjb21tZW50JyxcbiAgJ2V4cGxhaW4nLFxuICAnaGludCcsXG4gICdqJyxcbiAgJ2xlYW4nLFxuICAnbGltaXQnLFxuICAnbWF4VGltZU1TJyxcbiAgJ3BvcHVsYXRlJyxcbiAgJ3Byb2plY3Rpb24nLFxuICAncmVhZCcsXG4gICdzZWxlY3QnLFxuICAnc2tpcCcsXG4gICdzbGljZScsXG4gICdzb3J0JyxcbiAgJ3RhaWxhYmxlJyxcbiAgJ3cnLFxuICAnd3JpdGVDb25jZXJuJyxcbiAgJ3d0aW1lb3V0J1xuXSk7XG5cbi8qKlxuICogUXVlcnkgY29uc3RydWN0b3IgdXNlZCBmb3IgYnVpbGRpbmcgcXVlcmllcy4gWW91IGRvIG5vdCBuZWVkXG4gKiB0byBpbnN0YW50aWF0ZSBhIGBRdWVyeWAgZGlyZWN0bHkuIEluc3RlYWQgdXNlIE1vZGVsIGZ1bmN0aW9ucyBsaWtlXG4gKiBbYE1vZGVsLmZpbmQoKWBdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvbW9kZWwuaHRtbCNNb2RlbC5maW5kKCkpLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgY29uc3QgcXVlcnkgPSBNeU1vZGVsLmZpbmQoKTsgLy8gYHF1ZXJ5YCBpcyBhbiBpbnN0YW5jZSBvZiBgUXVlcnlgXG4gKiAgICAgcXVlcnkuc2V0T3B0aW9ucyh7IGxlYW4gOiB0cnVlIH0pO1xuICogICAgIHF1ZXJ5LmNvbGxlY3Rpb24oTXlNb2RlbC5jb2xsZWN0aW9uKTtcbiAqICAgICBxdWVyeS53aGVyZSgnYWdlJykuZ3RlKDIxKS5leGVjKGNhbGxiYWNrKTtcbiAqXG4gKiAgICAgLy8gWW91IGNhbiBpbnN0YW50aWF0ZSBhIHF1ZXJ5IGRpcmVjdGx5LiBUaGVyZSBpcyBubyBuZWVkIHRvIGRvXG4gKiAgICAgLy8gdGhpcyB1bmxlc3MgeW91J3JlIGFuIGFkdmFuY2VkIHVzZXIgd2l0aCBhIHZlcnkgZ29vZCByZWFzb24gdG8uXG4gKiAgICAgY29uc3QgcXVlcnkgPSBuZXcgbW9uZ29vc2UuUXVlcnkoKTtcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiBAcGFyYW0ge09iamVjdH0gW21vZGVsXVxuICogQHBhcmFtIHtPYmplY3R9IFtjb25kaXRpb25zXVxuICogQHBhcmFtIHtPYmplY3R9IFtjb2xsZWN0aW9uXSBNb25nb29zZSBjb2xsZWN0aW9uXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIFF1ZXJ5KGNvbmRpdGlvbnMsIG9wdGlvbnMsIG1vZGVsLCBjb2xsZWN0aW9uKSB7XG4gIC8vIHRoaXMgc3R1ZmYgaXMgZm9yIGRlYWxpbmcgd2l0aCBjdXN0b20gcXVlcmllcyBjcmVhdGVkIGJ5ICN0b0NvbnN0cnVjdG9yXG4gIGlmICghdGhpcy5fbW9uZ29vc2VPcHRpb25zKSB7XG4gICAgdGhpcy5fbW9uZ29vc2VPcHRpb25zID0ge307XG4gIH1cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgdGhpcy5fdHJhbnNmb3JtcyA9IFtdO1xuICB0aGlzLl9ob29rcyA9IG5ldyBLYXJlZW0oKTtcbiAgdGhpcy5fZXhlY3V0aW9uU3RhY2sgPSBudWxsO1xuXG4gIC8vIHRoaXMgaXMgdGhlIGNhc2Ugd2hlcmUgd2UgaGF2ZSBhIEN1c3RvbVF1ZXJ5LCB3ZSBuZWVkIHRvIGNoZWNrIGlmIHdlIGdvdFxuICAvLyBvcHRpb25zIHBhc3NlZCBpbiwgYW5kIGlmIHdlIGRpZCwgbWVyZ2UgdGhlbSBpblxuICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMob3B0aW9ucyk7XG4gIGZvciAoY29uc3Qga2V5IG9mIGtleXMpIHtcbiAgICB0aGlzLl9tb25nb29zZU9wdGlvbnNba2V5XSA9IG9wdGlvbnNba2V5XTtcbiAgfVxuXG4gIGlmIChjb2xsZWN0aW9uKSB7XG4gICAgdGhpcy5tb25nb29zZUNvbGxlY3Rpb24gPSBjb2xsZWN0aW9uO1xuICB9XG5cbiAgaWYgKG1vZGVsKSB7XG4gICAgdGhpcy5tb2RlbCA9IG1vZGVsO1xuICAgIHRoaXMuc2NoZW1hID0gbW9kZWwuc2NoZW1hO1xuICB9XG5cbiAgLy8gdGhpcyBpcyBuZWVkZWQgYmVjYXVzZSBtYXAgcmVkdWNlIHJldHVybnMgYSBtb2RlbCB0aGF0IGNhbiBiZSBxdWVyaWVkLCBidXRcbiAgLy8gYWxsIG9mIHRoZSBxdWVyaWVzIG9uIHNhaWQgbW9kZWwgc2hvdWxkIGJlIGxlYW5cbiAgaWYgKHRoaXMubW9kZWwgJiYgdGhpcy5tb2RlbC5fbWFwcmVkdWNlKSB7XG4gICAgdGhpcy5sZWFuKCk7XG4gIH1cblxuICAvLyBpbmhlcml0IG1xdWVyeVxuICBtcXVlcnkuY2FsbCh0aGlzLCBudWxsLCBvcHRpb25zKTtcbiAgaWYgKGNvbGxlY3Rpb24pIHtcbiAgICB0aGlzLmNvbGxlY3Rpb24oY29sbGVjdGlvbik7XG4gIH1cblxuICBpZiAoY29uZGl0aW9ucykge1xuICAgIHRoaXMuZmluZChjb25kaXRpb25zKTtcbiAgfVxuXG4gIHRoaXMub3B0aW9ucyA9IHRoaXMub3B0aW9ucyB8fCB7fTtcblxuICAvLyBGb3IgZ2gtNjg4MC4gbXF1ZXJ5IHN0aWxsIG5lZWRzIHRvIHN1cHBvcnQgYGZpZWxkc2AgYnkgZGVmYXVsdCBmb3Igb2xkXG4gIC8vIHZlcnNpb25zIG9mIE1vbmdvREJcbiAgdGhpcy4kdXNlUHJvamVjdGlvbiA9IHRydWU7XG5cbiAgY29uc3QgY29sbGF0aW9uID0gdGhpcyAmJlxuICAgIHRoaXMuc2NoZW1hICYmXG4gICAgdGhpcy5zY2hlbWEub3B0aW9ucyAmJlxuICAgIHRoaXMuc2NoZW1hLm9wdGlvbnMuY29sbGF0aW9uIHx8IG51bGw7XG4gIGlmIChjb2xsYXRpb24gIT0gbnVsbCkge1xuICAgIHRoaXMub3B0aW9ucy5jb2xsYXRpb24gPSBjb2xsYXRpb247XG4gIH1cbn1cblxuLyohXG4gKiBpbmhlcml0IG1xdWVyeVxuICovXG5cblF1ZXJ5LnByb3RvdHlwZSA9IG5ldyBtcXVlcnkoKTtcblF1ZXJ5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFF1ZXJ5O1xuUXVlcnkuYmFzZSA9IG1xdWVyeS5wcm90b3R5cGU7XG5cbi8qIVxuICogT3ZlcndyaXRlIG1xdWVyeSdzIGBfZGlzdGluY3RgLCBiZWNhdXNlIE1vbmdvb3NlIHVzZXMgdGhhdCBuYW1lXG4gKiB0byBzdG9yZSB0aGUgZmllbGQgdG8gYXBwbHkgZGlzdGluY3Qgb24uXG4gKi9cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFF1ZXJ5LnByb3RvdHlwZSwgJ19kaXN0aW5jdCcsIHtcbiAgY29uZmlndXJhYmxlOiB0cnVlLFxuICB3cml0YWJsZTogdHJ1ZSxcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgdmFsdWU6IHVuZGVmaW5lZFxufSk7XG5cbi8qKlxuICogRmxhZyB0byBvcHQgb3V0IG9mIHVzaW5nIGAkZ2VvV2l0aGluYC5cbiAqXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiBtb25nb29zZS5RdWVyeS51c2UkZ2VvV2l0aGluID0gZmFsc2U7XG4gKiBgYGBcbiAqXG4gKiBNb25nb0RCIDIuNCBkZXByZWNhdGVkIHRoZSB1c2Ugb2YgYCR3aXRoaW5gLCByZXBsYWNpbmcgaXQgd2l0aCBgJGdlb1dpdGhpbmAuIE1vbmdvb3NlIHVzZXMgYCRnZW9XaXRoaW5gIGJ5IGRlZmF1bHQgKHdoaWNoIGlzIDEwMCUgYmFja3dhcmQgY29tcGF0aWJsZSB3aXRoIGAkd2l0aGluYCkuIElmIHlvdSBhcmUgcnVubmluZyBhbiBvbGRlciB2ZXJzaW9uIG9mIE1vbmdvREIsIHNldCB0aGlzIGZsYWcgdG8gYGZhbHNlYCBzbyB5b3VyIGB3aXRoaW4oKWAgcXVlcmllcyBjb250aW51ZSB0byB3b3JrLlxuICpcbiAqIEBzZWUgZ2VvV2l0aGluIGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvbWFudWFsL3JlZmVyZW5jZS9vcGVyYXRvci9nZW9XaXRoaW4vXG4gKiBAZGVmYXVsdCB0cnVlXG4gKiBAcHJvcGVydHkgdXNlJGdlb1dpdGhpblxuICogQG1lbWJlck9mIFF1ZXJ5XG4gKiBAc3RhdGljXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblF1ZXJ5LnVzZSRnZW9XaXRoaW4gPSBtcXVlcnkudXNlJGdlb1dpdGhpbjtcblxuLyoqXG4gKiBDb252ZXJ0cyB0aGlzIHF1ZXJ5IHRvIGEgY3VzdG9taXplZCwgcmV1c2FibGUgcXVlcnkgY29uc3RydWN0b3Igd2l0aCBhbGwgYXJndW1lbnRzIGFuZCBvcHRpb25zIHJldGFpbmVkLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgLy8gQ3JlYXRlIGEgcXVlcnkgZm9yIGFkdmVudHVyZSBtb3ZpZXMgYW5kIHJlYWQgZnJvbSB0aGUgcHJpbWFyeVxuICogICAgIC8vIG5vZGUgaW4gdGhlIHJlcGxpY2Etc2V0IHVubGVzcyBpdCBpcyBkb3duLCBpbiB3aGljaCBjYXNlIHdlJ2xsXG4gKiAgICAgLy8gcmVhZCBmcm9tIGEgc2Vjb25kYXJ5IG5vZGUuXG4gKiAgICAgY29uc3QgcXVlcnkgPSBNb3ZpZS5maW5kKHsgdGFnczogJ2FkdmVudHVyZScgfSkucmVhZCgncHJpbWFyeVByZWZlcnJlZCcpO1xuICpcbiAqICAgICAvLyBjcmVhdGUgYSBjdXN0b20gUXVlcnkgY29uc3RydWN0b3IgYmFzZWQgb2ZmIHRoZXNlIHNldHRpbmdzXG4gKiAgICAgY29uc3QgQWR2ZW50dXJlID0gcXVlcnkudG9Db25zdHJ1Y3RvcigpO1xuICpcbiAqICAgICAvLyBmdXJ0aGVyIG5hcnJvdyBkb3duIG91ciBxdWVyeSByZXN1bHRzIHdoaWxlIHN0aWxsIHVzaW5nIHRoZSBwcmV2aW91cyBzZXR0aW5nc1xuICogICAgIGF3YWl0IEFkdmVudHVyZSgpLndoZXJlKHsgbmFtZTogL15MaWZlLyB9KS5leGVjKCk7XG4gKlxuICogICAgIC8vIHNpbmNlIEFkdmVudHVyZSBpcyBhIHN0YW5kLWFsb25lIGNvbnN0cnVjdG9yIHdlIGNhbiBhbHNvIGFkZCBvdXIgb3duXG4gKiAgICAgLy8gaGVscGVyIG1ldGhvZHMgYW5kIGdldHRlcnMgd2l0aG91dCBpbXBhY3RpbmcgZ2xvYmFsIHF1ZXJpZXNcbiAqICAgICBBZHZlbnR1cmUucHJvdG90eXBlLnN0YXJ0c1dpdGggPSBmdW5jdGlvbiAocHJlZml4KSB7XG4gKiAgICAgICB0aGlzLndoZXJlKHsgbmFtZTogbmV3IFJlZ0V4cCgnXicgKyBwcmVmaXgpIH0pXG4gKiAgICAgICByZXR1cm4gdGhpcztcbiAqICAgICB9XG4gKiAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFkdmVudHVyZS5wcm90b3R5cGUsICdoaWdobHlSYXRlZCcsIHtcbiAqICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICogICAgICAgICB0aGlzLndoZXJlKHsgcmF0aW5nOiB7ICRndDogNC41IH19KTtcbiAqICAgICAgICAgcmV0dXJuIHRoaXM7XG4gKiAgICAgICB9XG4gKiAgICAgfSlcbiAqICAgICBhd2FpdCBBZHZlbnR1cmUoKS5oaWdobHlSYXRlZC5zdGFydHNXaXRoKCdMaWZlJykuZXhlYygpO1xuICpcbiAqIEByZXR1cm4ge1F1ZXJ5fSBzdWJjbGFzcy1vZi1RdWVyeVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5RdWVyeS5wcm90b3R5cGUudG9Db25zdHJ1Y3RvciA9IGZ1bmN0aW9uIHRvQ29uc3RydWN0b3IoKSB7XG4gIGNvbnN0IG1vZGVsID0gdGhpcy5tb2RlbDtcbiAgY29uc3QgY29sbCA9IHRoaXMubW9uZ29vc2VDb2xsZWN0aW9uO1xuXG4gIGNvbnN0IEN1c3RvbVF1ZXJ5ID0gZnVuY3Rpb24oY3JpdGVyaWEsIG9wdGlvbnMpIHtcbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgQ3VzdG9tUXVlcnkpKSB7XG4gICAgICByZXR1cm4gbmV3IEN1c3RvbVF1ZXJ5KGNyaXRlcmlhLCBvcHRpb25zKTtcbiAgICB9XG4gICAgdGhpcy5fbW9uZ29vc2VPcHRpb25zID0gY2xvbmUocC5fbW9uZ29vc2VPcHRpb25zKTtcbiAgICBRdWVyeS5jYWxsKHRoaXMsIGNyaXRlcmlhLCBvcHRpb25zIHx8IG51bGwsIG1vZGVsLCBjb2xsKTtcbiAgfTtcblxuICB1dGlsLmluaGVyaXRzKEN1c3RvbVF1ZXJ5LCBtb2RlbC5RdWVyeSk7XG5cbiAgLy8gc2V0IGluaGVyaXRlZCBkZWZhdWx0c1xuICBjb25zdCBwID0gQ3VzdG9tUXVlcnkucHJvdG90eXBlO1xuXG4gIHAub3B0aW9ucyA9IHt9O1xuXG4gIC8vIE5lZWQgdG8gaGFuZGxlIGBzb3J0KClgIHNlcGFyYXRlbHkgYmVjYXVzZSBlbnRyaWVzLXN0eWxlIGBzb3J0KClgIHN5bnRheFxuICAvLyBgc29ydChbWydwcm9wMScsIDFdXSlgIGNvbmZ1c2VzIG1xdWVyeSBpbnRvIGxvc2luZyB0aGUgb3V0ZXIgbmVzdGVkIGFycmF5LlxuICAvLyBTZWUgZ2gtODE1OVxuICBjb25zdCBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5vcHRpb25zKTtcbiAgaWYgKG9wdGlvbnMuc29ydCAhPSBudWxsKSB7XG4gICAgcC5zb3J0KG9wdGlvbnMuc29ydCk7XG4gICAgZGVsZXRlIG9wdGlvbnMuc29ydDtcbiAgfVxuICBwLnNldE9wdGlvbnMob3B0aW9ucyk7XG5cbiAgcC5vcCA9IHRoaXMub3A7XG4gIHAuX3ZhbGlkYXRlT3AoKTtcbiAgcC5fY29uZGl0aW9ucyA9IGNsb25lKHRoaXMuX2NvbmRpdGlvbnMpO1xuICBwLl9maWVsZHMgPSBjbG9uZSh0aGlzLl9maWVsZHMpO1xuICBwLl91cGRhdGUgPSBjbG9uZSh0aGlzLl91cGRhdGUsIHtcbiAgICBmbGF0dGVuRGVjaW1hbHM6IGZhbHNlXG4gIH0pO1xuICBwLl9wYXRoID0gdGhpcy5fcGF0aDtcbiAgcC5fZGlzdGluY3QgPSB0aGlzLl9kaXN0aW5jdDtcbiAgcC5fY29sbGVjdGlvbiA9IHRoaXMuX2NvbGxlY3Rpb247XG4gIHAuX21vbmdvb3NlT3B0aW9ucyA9IHRoaXMuX21vbmdvb3NlT3B0aW9ucztcblxuICByZXR1cm4gQ3VzdG9tUXVlcnk7XG59O1xuXG4vKipcbiAqIE1ha2UgYSBjb3B5IG9mIHRoaXMgcXVlcnkgc28geW91IGNhbiByZS1leGVjdXRlIGl0LlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgY29uc3QgcSA9IEJvb2suZmluZE9uZSh7IHRpdGxlOiAnQ2FzaW5vIFJveWFsZScgfSk7XG4gKiAgICAgYXdhaXQgcS5leGVjKCk7XG4gKiAgICAgYXdhaXQgcS5leGVjKCk7IC8vIFRocm93cyBhbiBlcnJvciBiZWNhdXNlIHlvdSBjYW4ndCBleGVjdXRlIGEgcXVlcnkgdHdpY2VcbiAqXG4gKiAgICAgYXdhaXQgcS5jbG9uZSgpLmV4ZWMoKTsgLy8gV29ya3NcbiAqXG4gKiBAbWV0aG9kIGNsb25lXG4gKiBAcmV0dXJuIHtRdWVyeX0gY29weVxuICogQG1lbWJlck9mIFF1ZXJ5XG4gKiBAaW5zdGFuY2VcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUXVlcnkucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24oKSB7XG4gIGNvbnN0IG1vZGVsID0gdGhpcy5tb2RlbDtcbiAgY29uc3QgY29sbGVjdGlvbiA9IHRoaXMubW9uZ29vc2VDb2xsZWN0aW9uO1xuXG4gIGNvbnN0IHEgPSBuZXcgdGhpcy5tb2RlbC5RdWVyeSh7fSwge30sIG1vZGVsLCBjb2xsZWN0aW9uKTtcblxuICAvLyBOZWVkIHRvIGhhbmRsZSBgc29ydCgpYCBzZXBhcmF0ZWx5IGJlY2F1c2UgZW50cmllcy1zdHlsZSBgc29ydCgpYCBzeW50YXhcbiAgLy8gYHNvcnQoW1sncHJvcDEnLCAxXV0pYCBjb25mdXNlcyBtcXVlcnkgaW50byBsb3NpbmcgdGhlIG91dGVyIG5lc3RlZCBhcnJheS5cbiAgLy8gU2VlIGdoLTgxNTlcbiAgY29uc3Qgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMub3B0aW9ucyk7XG4gIGlmIChvcHRpb25zLnNvcnQgIT0gbnVsbCkge1xuICAgIHEuc29ydChvcHRpb25zLnNvcnQpO1xuICAgIGRlbGV0ZSBvcHRpb25zLnNvcnQ7XG4gIH1cbiAgcS5zZXRPcHRpb25zKG9wdGlvbnMpO1xuXG4gIHEub3AgPSB0aGlzLm9wO1xuICBxLl92YWxpZGF0ZU9wKCk7XG4gIHEuX2NvbmRpdGlvbnMgPSBjbG9uZSh0aGlzLl9jb25kaXRpb25zKTtcbiAgcS5fZmllbGRzID0gY2xvbmUodGhpcy5fZmllbGRzKTtcbiAgcS5fdXBkYXRlID0gY2xvbmUodGhpcy5fdXBkYXRlLCB7XG4gICAgZmxhdHRlbkRlY2ltYWxzOiBmYWxzZVxuICB9KTtcbiAgcS5fcGF0aCA9IHRoaXMuX3BhdGg7XG4gIHEuX2Rpc3RpbmN0ID0gdGhpcy5fZGlzdGluY3Q7XG4gIHEuX2NvbGxlY3Rpb24gPSB0aGlzLl9jb2xsZWN0aW9uO1xuICBxLl9tb25nb29zZU9wdGlvbnMgPSB0aGlzLl9tb25nb29zZU9wdGlvbnM7XG5cbiAgcmV0dXJuIHE7XG59O1xuXG4vKipcbiAqIFNwZWNpZmllcyBhIGphdmFzY3JpcHQgZnVuY3Rpb24gb3IgZXhwcmVzc2lvbiB0byBwYXNzIHRvIE1vbmdvREJzIHF1ZXJ5IHN5c3RlbS5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIHF1ZXJ5LiR3aGVyZSgndGhpcy5jb21tZW50cy5sZW5ndGggPT09IDEwIHx8IHRoaXMubmFtZS5sZW5ndGggPT09IDUnKVxuICpcbiAqICAgICAvLyBvclxuICpcbiAqICAgICBxdWVyeS4kd2hlcmUoZnVuY3Rpb24gKCkge1xuICogICAgICAgcmV0dXJuIHRoaXMuY29tbWVudHMubGVuZ3RoID09PSAxMCB8fCB0aGlzLm5hbWUubGVuZ3RoID09PSA1O1xuICogICAgIH0pXG4gKlxuICogIyMjIyBOb3RlOlxuICpcbiAqIE9ubHkgdXNlIGAkd2hlcmVgIHdoZW4geW91IGhhdmUgYSBjb25kaXRpb24gdGhhdCBjYW5ub3QgYmUgbWV0IHVzaW5nIG90aGVyIE1vbmdvREIgb3BlcmF0b3JzIGxpa2UgYCRsdGAuXG4gKiAqKkJlIHN1cmUgdG8gcmVhZCBhYm91dCBhbGwgb2YgW2l0cyBjYXZlYXRzXShodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9yZWZlcmVuY2Uvb3BlcmF0b3Ivd2hlcmUvKSBiZWZvcmUgdXNpbmcuKipcbiAqXG4gKiBAc2VlICR3aGVyZSBodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9yZWZlcmVuY2Uvb3BlcmF0b3Ivd2hlcmUvXG4gKiBAbWV0aG9kICR3aGVyZVxuICogQHBhcmFtIHtTdHJpbmd8RnVuY3Rpb259IGpzIGphdmFzY3JpcHQgc3RyaW5nIG9yIGZ1bmN0aW9uXG4gKiBAcmV0dXJuIHtRdWVyeX0gdGhpc1xuICogQG1lbWJlck9mIFF1ZXJ5XG4gKiBAaW5zdGFuY2VcbiAqIEBtZXRob2QgJHdoZXJlXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbi8qKlxuICogU3BlY2lmaWVzIGEgYHBhdGhgIGZvciB1c2Ugd2l0aCBjaGFpbmluZy5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIC8vIGluc3RlYWQgb2Ygd3JpdGluZzpcbiAqICAgICBVc2VyLmZpbmQoe2FnZTogeyRndGU6IDIxLCAkbHRlOiA2NX19KTtcbiAqXG4gKiAgICAgLy8gd2UgY2FuIGluc3RlYWQgd3JpdGU6XG4gKiAgICAgVXNlci53aGVyZSgnYWdlJykuZ3RlKDIxKS5sdGUoNjUpO1xuICpcbiAqICAgICAvLyBwYXNzaW5nIHF1ZXJ5IGNvbmRpdGlvbnMgaXMgcGVybWl0dGVkXG4gKiAgICAgVXNlci5maW5kKCkud2hlcmUoeyBuYW1lOiAndm9uZGVyZnVsJyB9KVxuICpcbiAqICAgICAvLyBjaGFpbmluZ1xuICogICAgIFVzZXJcbiAqICAgICAud2hlcmUoJ2FnZScpLmd0ZSgyMSkubHRlKDY1KVxuICogICAgIC53aGVyZSgnbmFtZScsIC9edm9uZGVyZnVsL2kpXG4gKiAgICAgLndoZXJlKCdmcmllbmRzJykuc2xpY2UoMTApXG4gKiAgICAgLmV4ZWMoKVxuICpcbiAqIEBtZXRob2Qgd2hlcmVcbiAqIEBtZW1iZXJPZiBRdWVyeVxuICogQGluc3RhbmNlXG4gKiBAcGFyYW0ge1N0cmluZ3xPYmplY3R9IFtwYXRoXVxuICogQHBhcmFtIHthbnl9IFt2YWxdXG4gKiBAcmV0dXJuIHtRdWVyeX0gdGhpc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG4vKipcbiAqIFNwZWNpZmllcyBhIGAkc2xpY2VgIHByb2plY3Rpb24gZm9yIGFuIGFycmF5LlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgcXVlcnkuc2xpY2UoJ2NvbW1lbnRzJywgNSk7IC8vIFJldHVybnMgdGhlIGZpcnN0IDUgY29tbWVudHNcbiAqICAgICBxdWVyeS5zbGljZSgnY29tbWVudHMnLCAtNSk7IC8vIFJldHVybnMgdGhlIGxhc3QgNSBjb21tZW50c1xuICogICAgIHF1ZXJ5LnNsaWNlKCdjb21tZW50cycsIFsxMCwgNV0pOyAvLyBSZXR1cm5zIHRoZSBmaXJzdCA1IGNvbW1lbnRzIGFmdGVyIHRoZSAxMC10aFxuICogICAgIHF1ZXJ5LndoZXJlKCdjb21tZW50cycpLnNsaWNlKDUpOyAvLyBSZXR1cm5zIHRoZSBmaXJzdCA1IGNvbW1lbnRzXG4gKiAgICAgcXVlcnkud2hlcmUoJ2NvbW1lbnRzJykuc2xpY2UoWy0xMCwgNV0pOyAvLyBSZXR1cm5zIHRoZSBmaXJzdCA1IGNvbW1lbnRzIGFmdGVyIHRoZSAxMC10aCB0byBsYXN0XG4gKlxuICogKipOb3RlOioqIElmIHRoZSBhYnNvbHV0ZSB2YWx1ZSBvZiB0aGUgbnVtYmVyIG9mIGVsZW1lbnRzIHRvIGJlIHNsaWNlZCBpcyBncmVhdGVyIHRoYW4gdGhlIG51bWJlciBvZiBlbGVtZW50cyBpbiB0aGUgYXJyYXksIGFsbCBhcnJheSBlbGVtZW50cyB3aWxsIGJlIHJldHVybmVkLlxuICpcbiAqICAgICAgLy8gR2l2ZW4gYGFycmA6IFsxLCAyLCAzLCA0LCA1LCA2LCA3LCA4LCA5LCAxMF1cbiAqICAgICAgcXVlcnkuc2xpY2UoJ2FycicsIDIwKTsgLy8gUmV0dXJucyBbMSwgMiwgMywgNCwgNSwgNiwgNywgOCwgOSwgMTBdXG4gKiAgICAgIHF1ZXJ5LnNsaWNlKCdhcnInLCAtMjApOyAvLyBSZXR1cm5zIFsxLCAyLCAzLCA0LCA1LCA2LCA3LCA4LCA5LCAxMF1cbiAqXG4gKiAqKk5vdGU6KiogSWYgdGhlIG51bWJlciBvZiBlbGVtZW50cyB0byBza2lwIGlzIHBvc2l0aXZlIGFuZCBncmVhdGVyIHRoYW4gdGhlIG51bWJlciBvZiBlbGVtZW50cyBpbiB0aGUgYXJyYXksIGFuIGVtcHR5IGFycmF5IHdpbGwgYmUgcmV0dXJuZWQuXG4gKlxuICogICAgICAvLyBHaXZlbiBgYXJyYDogWzEsIDIsIDMsIDQsIDUsIDYsIDcsIDgsIDksIDEwXVxuICogICAgICBxdWVyeS5zbGljZSgnYXJyJywgWzIwLCA1XSk7IC8vIFJldHVybnMgW11cbiAqXG4gKiAqKk5vdGU6KiogSWYgdGhlIG51bWJlciBvZiBlbGVtZW50cyB0byBza2lwIGlzIG5lZ2F0aXZlIGFuZCBpdHMgYWJzb2x1dGUgdmFsdWUgaXMgZ3JlYXRlciB0aGFuIHRoZSBudW1iZXIgb2YgZWxlbWVudHMgaW4gdGhlIGFycmF5LCB0aGUgc3RhcnRpbmcgcG9zaXRpb24gaXMgdGhlIHN0YXJ0IG9mIHRoZSBhcnJheS5cbiAqXG4gKiAgICAgIC8vIEdpdmVuIGBhcnJgOiBbMSwgMiwgMywgNCwgNSwgNiwgNywgOCwgOSwgMTBdXG4gKiAgICAgIHF1ZXJ5LnNsaWNlKCdhcnInLCBbLTIwLCA1XSk7IC8vIFJldHVybnMgWzEsIDIsIDMsIDQsIDVdXG4gKlxuICogQG1ldGhvZCBzbGljZVxuICogQG1lbWJlck9mIFF1ZXJ5XG4gKiBAaW5zdGFuY2VcbiAqIEBwYXJhbSB7U3RyaW5nfSBbcGF0aF1cbiAqIEBwYXJhbSB7TnVtYmVyfEFycmF5fSB2YWwgbnVtYmVyIG9mIGVsZW1lbnRzIHRvIHNsaWNlIG9yIGFycmF5IHdpdGggbnVtYmVyIG9mIGVsZW1lbnRzIHRvIHNraXAgYW5kIG51bWJlciBvZiBlbGVtZW50cyB0byBzbGljZVxuICogQHJldHVybiB7UXVlcnl9IHRoaXNcbiAqIEBzZWUgbW9uZ29kYiBodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC90dXRvcmlhbC9xdWVyeS1kb2N1bWVudHMvI3Byb2plY3Rpb25cbiAqIEBzZWUgJHNsaWNlIGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvbWFudWFsL3JlZmVyZW5jZS9wcm9qZWN0aW9uL3NsaWNlLyNwcmouX1Nfc2xpY2VcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUXVlcnkucHJvdG90eXBlLnNsaWNlID0gZnVuY3Rpb24oKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICB0aGlzLl92YWxpZGF0ZSgnc2xpY2UnKTtcblxuICBsZXQgcGF0aDtcbiAgbGV0IHZhbDtcblxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgIGNvbnN0IGFyZyA9IGFyZ3VtZW50c1swXTtcbiAgICBpZiAodHlwZW9mIGFyZyA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkoYXJnKSkge1xuICAgICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKGFyZyk7XG4gICAgICBjb25zdCBudW1LZXlzID0ga2V5cy5sZW5ndGg7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bUtleXM7ICsraSkge1xuICAgICAgICB0aGlzLnNsaWNlKGtleXNbaV0sIGFyZ1trZXlzW2ldXSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgdGhpcy5fZW5zdXJlUGF0aCgnc2xpY2UnKTtcbiAgICBwYXRoID0gdGhpcy5fcGF0aDtcbiAgICB2YWwgPSBhcmd1bWVudHNbMF07XG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgIGlmICgnbnVtYmVyJyA9PT0gdHlwZW9mIGFyZ3VtZW50c1swXSkge1xuICAgICAgdGhpcy5fZW5zdXJlUGF0aCgnc2xpY2UnKTtcbiAgICAgIHBhdGggPSB0aGlzLl9wYXRoO1xuICAgICAgdmFsID0gW2FyZ3VtZW50c1swXSwgYXJndW1lbnRzWzFdXTtcbiAgICB9IGVsc2Uge1xuICAgICAgcGF0aCA9IGFyZ3VtZW50c1swXTtcbiAgICAgIHZhbCA9IGFyZ3VtZW50c1sxXTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMykge1xuICAgIHBhdGggPSBhcmd1bWVudHNbMF07XG4gICAgdmFsID0gW2FyZ3VtZW50c1sxXSwgYXJndW1lbnRzWzJdXTtcbiAgfVxuXG4gIGNvbnN0IHAgPSB7fTtcbiAgcFtwYXRoXSA9IHsgJHNsaWNlOiB2YWwgfTtcbiAgdGhpcy5zZWxlY3QocCk7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cbmNvbnN0IHZhbGlkT3BzU2V0ID0gbmV3IFNldChxdWVyeU1pZGRsZXdhcmVGdW5jdGlvbnMpO1xuXG5RdWVyeS5wcm90b3R5cGUuX3ZhbGlkYXRlT3AgPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMub3AgIT0gbnVsbCAmJiAhdmFsaWRPcHNTZXQuaGFzKHRoaXMub3ApKSB7XG4gICAgdGhpcy5lcnJvcihuZXcgRXJyb3IoJ1F1ZXJ5IGhhcyBpbnZhbGlkIGBvcGA6IFwiJyArIHRoaXMub3AgKyAnXCInKSk7XG4gIH1cbn07XG5cbi8qKlxuICogU3BlY2lmaWVzIHRoZSBjb21wbGVtZW50YXJ5IGNvbXBhcmlzb24gdmFsdWUgZm9yIHBhdGhzIHNwZWNpZmllZCB3aXRoIGB3aGVyZSgpYFxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgVXNlci53aGVyZSgnYWdlJykuZXF1YWxzKDQ5KTtcbiAqXG4gKiAgICAgLy8gaXMgdGhlIHNhbWUgYXNcbiAqXG4gKiAgICAgVXNlci53aGVyZSgnYWdlJywgNDkpO1xuICpcbiAqIEBtZXRob2QgZXF1YWxzXG4gKiBAbWVtYmVyT2YgUXVlcnlcbiAqIEBpbnN0YW5jZVxuICogQHBhcmFtIHtPYmplY3R9IHZhbFxuICogQHJldHVybiB7UXVlcnl9IHRoaXNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuLyoqXG4gKiBTcGVjaWZpZXMgYXJndW1lbnRzIGZvciBhbiBgJG9yYCBjb25kaXRpb24uXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBxdWVyeS5vcihbeyBjb2xvcjogJ3JlZCcgfSwgeyBzdGF0dXM6ICdlbWVyZ2VuY3knIH1dKTtcbiAqXG4gKiBAc2VlICRvciBodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9yZWZlcmVuY2Uvb3BlcmF0b3Ivb3IvXG4gKiBAbWV0aG9kIG9yXG4gKiBAbWVtYmVyT2YgUXVlcnlcbiAqIEBpbnN0YW5jZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgYXJyYXkgb2YgY29uZGl0aW9uc1xuICogQHJldHVybiB7UXVlcnl9IHRoaXNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuLyoqXG4gKiBTcGVjaWZpZXMgYXJndW1lbnRzIGZvciBhIGAkbm9yYCBjb25kaXRpb24uXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBxdWVyeS5ub3IoW3sgY29sb3I6ICdncmVlbicgfSwgeyBzdGF0dXM6ICdvaycgfV0pO1xuICpcbiAqIEBzZWUgJG5vciBodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9yZWZlcmVuY2Uvb3BlcmF0b3Ivbm9yL1xuICogQG1ldGhvZCBub3JcbiAqIEBtZW1iZXJPZiBRdWVyeVxuICogQGluc3RhbmNlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBhcnJheSBvZiBjb25kaXRpb25zXG4gKiBAcmV0dXJuIHtRdWVyeX0gdGhpc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG4vKipcbiAqIFNwZWNpZmllcyBhcmd1bWVudHMgZm9yIGEgYCRhbmRgIGNvbmRpdGlvbi5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIHF1ZXJ5LmFuZChbeyBjb2xvcjogJ2dyZWVuJyB9LCB7IHN0YXR1czogJ29rJyB9XSlcbiAqXG4gKiBAbWV0aG9kIGFuZFxuICogQG1lbWJlck9mIFF1ZXJ5XG4gKiBAaW5zdGFuY2VcbiAqIEBzZWUgJGFuZCBodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9yZWZlcmVuY2Uvb3BlcmF0b3IvYW5kL1xuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgYXJyYXkgb2YgY29uZGl0aW9uc1xuICogQHJldHVybiB7UXVlcnl9IHRoaXNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuLyoqXG4gKiBTcGVjaWZpZXMgYSBgJGd0YCBxdWVyeSBjb25kaXRpb24uXG4gKlxuICogV2hlbiBjYWxsZWQgd2l0aCBvbmUgYXJndW1lbnQsIHRoZSBtb3N0IHJlY2VudCBwYXRoIHBhc3NlZCB0byBgd2hlcmUoKWAgaXMgdXNlZC5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIFRoaW5nLmZpbmQoKS53aGVyZSgnYWdlJykuZ3QoMjEpO1xuICpcbiAqICAgICAvLyBvclxuICogICAgIFRoaW5nLmZpbmQoKS5ndCgnYWdlJywgMjEpO1xuICpcbiAqIEBtZXRob2QgZ3RcbiAqIEBtZW1iZXJPZiBRdWVyeVxuICogQGluc3RhbmNlXG4gKiBAcGFyYW0ge1N0cmluZ30gW3BhdGhdXG4gKiBAcGFyYW0ge051bWJlcn0gdmFsXG4gKiBAc2VlICRndCBodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9yZWZlcmVuY2Uvb3BlcmF0b3IvZ3QvXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbi8qKlxuICogU3BlY2lmaWVzIGEgYCRndGVgIHF1ZXJ5IGNvbmRpdGlvbi5cbiAqXG4gKiBXaGVuIGNhbGxlZCB3aXRoIG9uZSBhcmd1bWVudCwgdGhlIG1vc3QgcmVjZW50IHBhdGggcGFzc2VkIHRvIGB3aGVyZSgpYCBpcyB1c2VkLlxuICpcbiAqIEBtZXRob2QgZ3RlXG4gKiBAbWVtYmVyT2YgUXVlcnlcbiAqIEBpbnN0YW5jZVxuICogQHBhcmFtIHtTdHJpbmd9IFtwYXRoXVxuICogQHBhcmFtIHtOdW1iZXJ9IHZhbFxuICogQHNlZSAkZ3RlIGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvbWFudWFsL3JlZmVyZW5jZS9vcGVyYXRvci9ndGUvXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbi8qKlxuICogU3BlY2lmaWVzIGEgYCRsdGAgcXVlcnkgY29uZGl0aW9uLlxuICpcbiAqIFdoZW4gY2FsbGVkIHdpdGggb25lIGFyZ3VtZW50LCB0aGUgbW9zdCByZWNlbnQgcGF0aCBwYXNzZWQgdG8gYHdoZXJlKClgIGlzIHVzZWQuXG4gKlxuICogQG1ldGhvZCBsdFxuICogQG1lbWJlck9mIFF1ZXJ5XG4gKiBAaW5zdGFuY2VcbiAqIEBwYXJhbSB7U3RyaW5nfSBbcGF0aF1cbiAqIEBwYXJhbSB7TnVtYmVyfSB2YWxcbiAqIEBzZWUgJGx0IGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvbWFudWFsL3JlZmVyZW5jZS9vcGVyYXRvci9sdC9cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuLyoqXG4gKiBTcGVjaWZpZXMgYSBgJGx0ZWAgcXVlcnkgY29uZGl0aW9uLlxuICpcbiAqIFdoZW4gY2FsbGVkIHdpdGggb25lIGFyZ3VtZW50LCB0aGUgbW9zdCByZWNlbnQgcGF0aCBwYXNzZWQgdG8gYHdoZXJlKClgIGlzIHVzZWQuXG4gKlxuICogQG1ldGhvZCBsdGVcbiAqIEBzZWUgJGx0ZSBodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9yZWZlcmVuY2Uvb3BlcmF0b3IvbHRlL1xuICogQG1lbWJlck9mIFF1ZXJ5XG4gKiBAaW5zdGFuY2VcbiAqIEBwYXJhbSB7U3RyaW5nfSBbcGF0aF1cbiAqIEBwYXJhbSB7TnVtYmVyfSB2YWxcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuLyoqXG4gKiBTcGVjaWZpZXMgYSBgJG5lYCBxdWVyeSBjb25kaXRpb24uXG4gKlxuICogV2hlbiBjYWxsZWQgd2l0aCBvbmUgYXJndW1lbnQsIHRoZSBtb3N0IHJlY2VudCBwYXRoIHBhc3NlZCB0byBgd2hlcmUoKWAgaXMgdXNlZC5cbiAqXG4gKiBAc2VlICRuZSBodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9yZWZlcmVuY2Uvb3BlcmF0b3IvbmUvXG4gKiBAbWV0aG9kIG5lXG4gKiBAbWVtYmVyT2YgUXVlcnlcbiAqIEBpbnN0YW5jZVxuICogQHBhcmFtIHtTdHJpbmd9IFtwYXRoXVxuICogQHBhcmFtIHthbnl9IHZhbFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG4vKipcbiAqIFNwZWNpZmllcyBhbiBgJGluYCBxdWVyeSBjb25kaXRpb24uXG4gKlxuICogV2hlbiBjYWxsZWQgd2l0aCBvbmUgYXJndW1lbnQsIHRoZSBtb3N0IHJlY2VudCBwYXRoIHBhc3NlZCB0byBgd2hlcmUoKWAgaXMgdXNlZC5cbiAqXG4gKiBAc2VlICRpbiBodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9yZWZlcmVuY2Uvb3BlcmF0b3IvaW4vXG4gKiBAbWV0aG9kIGluXG4gKiBAbWVtYmVyT2YgUXVlcnlcbiAqIEBpbnN0YW5jZVxuICogQHBhcmFtIHtTdHJpbmd9IFtwYXRoXVxuICogQHBhcmFtIHtBcnJheX0gdmFsXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbi8qKlxuICogU3BlY2lmaWVzIGFuIGAkbmluYCBxdWVyeSBjb25kaXRpb24uXG4gKlxuICogV2hlbiBjYWxsZWQgd2l0aCBvbmUgYXJndW1lbnQsIHRoZSBtb3N0IHJlY2VudCBwYXRoIHBhc3NlZCB0byBgd2hlcmUoKWAgaXMgdXNlZC5cbiAqXG4gKiBAc2VlICRuaW4gaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvcmVmZXJlbmNlL29wZXJhdG9yL25pbi9cbiAqIEBtZXRob2QgbmluXG4gKiBAbWVtYmVyT2YgUXVlcnlcbiAqIEBpbnN0YW5jZVxuICogQHBhcmFtIHtTdHJpbmd9IFtwYXRoXVxuICogQHBhcmFtIHtBcnJheX0gdmFsXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbi8qKlxuICogU3BlY2lmaWVzIGFuIGAkYWxsYCBxdWVyeSBjb25kaXRpb24uXG4gKlxuICogV2hlbiBjYWxsZWQgd2l0aCBvbmUgYXJndW1lbnQsIHRoZSBtb3N0IHJlY2VudCBwYXRoIHBhc3NlZCB0byBgd2hlcmUoKWAgaXMgdXNlZC5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIE15TW9kZWwuZmluZCgpLndoZXJlKCdwZXRzJykuYWxsKFsnZG9nJywgJ2NhdCcsICdmZXJyZXQnXSk7XG4gKiAgICAgLy8gRXF1aXZhbGVudDpcbiAqICAgICBNeU1vZGVsLmZpbmQoKS5hbGwoJ3BldHMnLCBbJ2RvZycsICdjYXQnLCAnZmVycmV0J10pO1xuICpcbiAqIEBzZWUgJGFsbCBodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9yZWZlcmVuY2Uvb3BlcmF0b3IvYWxsL1xuICogQG1ldGhvZCBhbGxcbiAqIEBtZW1iZXJPZiBRdWVyeVxuICogQGluc3RhbmNlXG4gKiBAcGFyYW0ge1N0cmluZ30gW3BhdGhdXG4gKiBAcGFyYW0ge0FycmF5fSB2YWxcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuLyoqXG4gKiBTcGVjaWZpZXMgYSBgJHNpemVgIHF1ZXJ5IGNvbmRpdGlvbi5cbiAqXG4gKiBXaGVuIGNhbGxlZCB3aXRoIG9uZSBhcmd1bWVudCwgdGhlIG1vc3QgcmVjZW50IHBhdGggcGFzc2VkIHRvIGB3aGVyZSgpYCBpcyB1c2VkLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgY29uc3QgZG9jcyA9IGF3YWl0IE15TW9kZWwud2hlcmUoJ3RhZ3MnKS5zaXplKDApLmV4ZWMoKTtcbiAqICAgICBhc3NlcnQoQXJyYXkuaXNBcnJheShkb2NzKSk7XG4gKiAgICAgY29uc29sZS5sb2coJ2RvY3VtZW50cyB3aXRoIDAgdGFncycsIGRvY3MpO1xuICpcbiAqIEBzZWUgJHNpemUgaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvcmVmZXJlbmNlL29wZXJhdG9yL3NpemUvXG4gKiBAbWV0aG9kIHNpemVcbiAqIEBtZW1iZXJPZiBRdWVyeVxuICogQGluc3RhbmNlXG4gKiBAcGFyYW0ge1N0cmluZ30gW3BhdGhdXG4gKiBAcGFyYW0ge051bWJlcn0gdmFsXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbi8qKlxuICogU3BlY2lmaWVzIGEgYCRyZWdleGAgcXVlcnkgY29uZGl0aW9uLlxuICpcbiAqIFdoZW4gY2FsbGVkIHdpdGggb25lIGFyZ3VtZW50LCB0aGUgbW9zdCByZWNlbnQgcGF0aCBwYXNzZWQgdG8gYHdoZXJlKClgIGlzIHVzZWQuXG4gKlxuICogQHNlZSAkcmVnZXggaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvcmVmZXJlbmNlL29wZXJhdG9yL3JlZ2V4L1xuICogQG1ldGhvZCByZWdleFxuICogQG1lbWJlck9mIFF1ZXJ5XG4gKiBAaW5zdGFuY2VcbiAqIEBwYXJhbSB7U3RyaW5nfSBbcGF0aF1cbiAqIEBwYXJhbSB7U3RyaW5nfFJlZ0V4cH0gdmFsXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbi8qKlxuICogU3BlY2lmaWVzIGEgYG1heERpc3RhbmNlYCBxdWVyeSBjb25kaXRpb24uXG4gKlxuICogV2hlbiBjYWxsZWQgd2l0aCBvbmUgYXJndW1lbnQsIHRoZSBtb3N0IHJlY2VudCBwYXRoIHBhc3NlZCB0byBgd2hlcmUoKWAgaXMgdXNlZC5cbiAqXG4gKiBAc2VlICRtYXhEaXN0YW5jZSBodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9yZWZlcmVuY2Uvb3BlcmF0b3IvbWF4RGlzdGFuY2UvXG4gKiBAbWV0aG9kIG1heERpc3RhbmNlXG4gKiBAbWVtYmVyT2YgUXVlcnlcbiAqIEBpbnN0YW5jZVxuICogQHBhcmFtIHtTdHJpbmd9IFtwYXRoXVxuICogQHBhcmFtIHtOdW1iZXJ9IHZhbFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG4vKipcbiAqIFNwZWNpZmllcyBhIGAkbW9kYCBjb25kaXRpb24sIGZpbHRlcnMgZG9jdW1lbnRzIGZvciBkb2N1bWVudHMgd2hvc2VcbiAqIGBwYXRoYCBwcm9wZXJ0eSBpcyBhIG51bWJlciB0aGF0IGlzIGVxdWFsIHRvIGByZW1haW5kZXJgIG1vZHVsbyBgZGl2aXNvcmAuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICAvLyBBbGwgZmluZCBwcm9kdWN0cyB3aG9zZSBpbnZlbnRvcnkgaXMgb2RkXG4gKiAgICAgUHJvZHVjdC5maW5kKCkubW9kKCdpbnZlbnRvcnknLCBbMiwgMV0pO1xuICogICAgIFByb2R1Y3QuZmluZCgpLndoZXJlKCdpbnZlbnRvcnknKS5tb2QoWzIsIDFdKTtcbiAqICAgICAvLyBUaGlzIHN5bnRheCBpcyBhIGxpdHRsZSBzdHJhbmdlLCBidXQgc3VwcG9ydGVkLlxuICogICAgIFByb2R1Y3QuZmluZCgpLndoZXJlKCdpbnZlbnRvcnknKS5tb2QoMiwgMSk7XG4gKlxuICogQG1ldGhvZCBtb2RcbiAqIEBtZW1iZXJPZiBRdWVyeVxuICogQGluc3RhbmNlXG4gKiBAcGFyYW0ge1N0cmluZ30gW3BhdGhdXG4gKiBAcGFyYW0ge0FycmF5fSB2YWwgbXVzdCBiZSBvZiBsZW5ndGggMiwgZmlyc3QgZWxlbWVudCBpcyBgZGl2aXNvcmAsIDJuZCBlbGVtZW50IGlzIGByZW1haW5kZXJgLlxuICogQHJldHVybiB7UXVlcnl9IHRoaXNcbiAqIEBzZWUgJG1vZCBodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9yZWZlcmVuY2Uvb3BlcmF0b3IvbW9kL1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5RdWVyeS5wcm90b3R5cGUubW9kID0gZnVuY3Rpb24oKSB7XG4gIGxldCB2YWw7XG4gIGxldCBwYXRoO1xuXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgdGhpcy5fZW5zdXJlUGF0aCgnbW9kJyk7XG4gICAgdmFsID0gYXJndW1lbnRzWzBdO1xuICAgIHBhdGggPSB0aGlzLl9wYXRoO1xuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIgJiYgIUFycmF5LmlzQXJyYXkoYXJndW1lbnRzWzFdKSkge1xuICAgIHRoaXMuX2Vuc3VyZVBhdGgoJ21vZCcpO1xuICAgIHZhbCA9IFthcmd1bWVudHNbMF0sIGFyZ3VtZW50c1sxXV07XG4gICAgcGF0aCA9IHRoaXMuX3BhdGg7XG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMykge1xuICAgIHZhbCA9IFthcmd1bWVudHNbMV0sIGFyZ3VtZW50c1syXV07XG4gICAgcGF0aCA9IGFyZ3VtZW50c1swXTtcbiAgfSBlbHNlIHtcbiAgICB2YWwgPSBhcmd1bWVudHNbMV07XG4gICAgcGF0aCA9IGFyZ3VtZW50c1swXTtcbiAgfVxuXG4gIGNvbnN0IGNvbmRzID0gdGhpcy5fY29uZGl0aW9uc1twYXRoXSB8fCAodGhpcy5fY29uZGl0aW9uc1twYXRoXSA9IHt9KTtcbiAgY29uZHMuJG1vZCA9IHZhbDtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNwZWNpZmllcyBhbiBgJGV4aXN0c2AgY29uZGl0aW9uXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICAvLyB7IG5hbWU6IHsgJGV4aXN0czogdHJ1ZSB9fVxuICogICAgIFRoaW5nLndoZXJlKCduYW1lJykuZXhpc3RzKClcbiAqICAgICBUaGluZy53aGVyZSgnbmFtZScpLmV4aXN0cyh0cnVlKVxuICogICAgIFRoaW5nLmZpbmQoKS5leGlzdHMoJ25hbWUnKVxuICpcbiAqICAgICAvLyB7IG5hbWU6IHsgJGV4aXN0czogZmFsc2UgfX1cbiAqICAgICBUaGluZy53aGVyZSgnbmFtZScpLmV4aXN0cyhmYWxzZSk7XG4gKiAgICAgVGhpbmcuZmluZCgpLmV4aXN0cygnbmFtZScsIGZhbHNlKTtcbiAqXG4gKiBAbWV0aG9kIGV4aXN0c1xuICogQG1lbWJlck9mIFF1ZXJ5XG4gKiBAaW5zdGFuY2VcbiAqIEBwYXJhbSB7U3RyaW5nfSBbcGF0aF1cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gdmFsXG4gKiBAcmV0dXJuIHtRdWVyeX0gdGhpc1xuICogQHNlZSAkZXhpc3RzIGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvbWFudWFsL3JlZmVyZW5jZS9vcGVyYXRvci9leGlzdHMvXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbi8qKlxuICogU3BlY2lmaWVzIGFuIGAkZWxlbU1hdGNoYCBjb25kaXRpb25cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIHF1ZXJ5LmVsZW1NYXRjaCgnY29tbWVudCcsIHsgYXV0aG9yOiAnYXV0b2JvdCcsIHZvdGVzOiB7JGd0ZTogNX19KVxuICpcbiAqICAgICBxdWVyeS53aGVyZSgnY29tbWVudCcpLmVsZW1NYXRjaCh7IGF1dGhvcjogJ2F1dG9ib3QnLCB2b3RlczogeyRndGU6IDV9fSlcbiAqXG4gKiAgICAgcXVlcnkuZWxlbU1hdGNoKCdjb21tZW50JywgZnVuY3Rpb24gKGVsZW0pIHtcbiAqICAgICAgIGVsZW0ud2hlcmUoJ2F1dGhvcicpLmVxdWFscygnYXV0b2JvdCcpO1xuICogICAgICAgZWxlbS53aGVyZSgndm90ZXMnKS5ndGUoNSk7XG4gKiAgICAgfSlcbiAqXG4gKiAgICAgcXVlcnkud2hlcmUoJ2NvbW1lbnQnKS5lbGVtTWF0Y2goZnVuY3Rpb24gKGVsZW0pIHtcbiAqICAgICAgIGVsZW0ud2hlcmUoeyBhdXRob3I6ICdhdXRvYm90JyB9KTtcbiAqICAgICAgIGVsZW0ud2hlcmUoJ3ZvdGVzJykuZ3RlKDUpO1xuICogICAgIH0pXG4gKlxuICogQG1ldGhvZCBlbGVtTWF0Y2hcbiAqIEBtZW1iZXJPZiBRdWVyeVxuICogQGluc3RhbmNlXG4gKiBAcGFyYW0ge1N0cmluZ3xPYmplY3R8RnVuY3Rpb259IHBhdGhcbiAqIEBwYXJhbSB7T2JqZWN0fEZ1bmN0aW9ufSBmaWx0ZXJcbiAqIEByZXR1cm4ge1F1ZXJ5fSB0aGlzXG4gKiBAc2VlICRlbGVtTWF0Y2ggaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvcmVmZXJlbmNlL29wZXJhdG9yL2VsZW1NYXRjaC9cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuLyoqXG4gKiBEZWZpbmVzIGEgYCR3aXRoaW5gIG9yIGAkZ2VvV2l0aGluYCBhcmd1bWVudCBmb3IgZ2VvLXNwYXRpYWwgcXVlcmllcy5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIHF1ZXJ5LndoZXJlKHBhdGgpLndpdGhpbigpLmJveCgpXG4gKiAgICAgcXVlcnkud2hlcmUocGF0aCkud2l0aGluKCkuY2lyY2xlKClcbiAqICAgICBxdWVyeS53aGVyZShwYXRoKS53aXRoaW4oKS5nZW9tZXRyeSgpXG4gKlxuICogICAgIHF1ZXJ5LndoZXJlKCdsb2MnKS53aXRoaW4oeyBjZW50ZXI6IFs1MCw1MF0sIHJhZGl1czogMTAsIHVuaXF1ZTogdHJ1ZSwgc3BoZXJpY2FsOiB0cnVlIH0pO1xuICogICAgIHF1ZXJ5LndoZXJlKCdsb2MnKS53aXRoaW4oeyBib3g6IFtbNDAuNzMsIC03My45XSwgWzQwLjcsIC03My45ODhdXSB9KTtcbiAqICAgICBxdWVyeS53aGVyZSgnbG9jJykud2l0aGluKHsgcG9seWdvbjogW1tdLFtdLFtdLFtdXSB9KTtcbiAqXG4gKiAgICAgcXVlcnkud2hlcmUoJ2xvYycpLndpdGhpbihbXSwgW10sIFtdKSAvLyBwb2x5Z29uXG4gKiAgICAgcXVlcnkud2hlcmUoJ2xvYycpLndpdGhpbihbXSwgW10pIC8vIGJveFxuICogICAgIHF1ZXJ5LndoZXJlKCdsb2MnKS53aXRoaW4oeyB0eXBlOiAnTGluZVN0cmluZycsIGNvb3JkaW5hdGVzOiBbLi4uXSB9KTsgLy8gZ2VvbWV0cnlcbiAqXG4gKiAqKk1VU1QqKiBiZSB1c2VkIGFmdGVyIGB3aGVyZSgpYC5cbiAqXG4gKiAjIyMjIE5vdGU6XG4gKlxuICogQXMgb2YgTW9uZ29vc2UgMy43LCBgJGdlb1dpdGhpbmAgaXMgYWx3YXlzIHVzZWQgZm9yIHF1ZXJpZXMuIFRvIGNoYW5nZSB0aGlzIGJlaGF2aW9yLCBzZWUgW1F1ZXJ5LnVzZSRnZW9XaXRoaW5dKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvcXVlcnkuaHRtbCNRdWVyeS5wcm90b3R5cGUudXNlJGdlb1dpdGhpbikuXG4gKlxuICogIyMjIyBOb3RlOlxuICpcbiAqIEluIE1vbmdvb3NlIDMuNywgYHdpdGhpbmAgY2hhbmdlZCBmcm9tIGEgZ2V0dGVyIHRvIGEgZnVuY3Rpb24uIElmIHlvdSBuZWVkIHRoZSBvbGQgc3ludGF4LCB1c2UgW3RoaXNdKGh0dHBzOi8vZ2l0aHViLmNvbS9lYmVuc2luZy9tb25nb29zZS13aXRoaW4pLlxuICpcbiAqIEBtZXRob2Qgd2l0aGluXG4gKiBAc2VlICRwb2x5Z29uIGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvbWFudWFsL3JlZmVyZW5jZS9vcGVyYXRvci9wb2x5Z29uL1xuICogQHNlZSAkYm94IGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvbWFudWFsL3JlZmVyZW5jZS9vcGVyYXRvci9ib3gvXG4gKiBAc2VlICRnZW9tZXRyeSBodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9yZWZlcmVuY2Uvb3BlcmF0b3IvZ2VvbWV0cnkvXG4gKiBAc2VlICRjZW50ZXIgaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvcmVmZXJlbmNlL29wZXJhdG9yL2NlbnRlci9cbiAqIEBzZWUgJGNlbnRlclNwaGVyZSBodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9yZWZlcmVuY2Uvb3BlcmF0b3IvY2VudGVyU3BoZXJlL1xuICogQG1lbWJlck9mIFF1ZXJ5XG4gKiBAaW5zdGFuY2VcbiAqIEByZXR1cm4ge1F1ZXJ5fSB0aGlzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbi8qKlxuICogU3BlY2lmaWVzIHRoZSBtYXhpbXVtIG51bWJlciBvZiBkb2N1bWVudHMgdGhlIHF1ZXJ5IHdpbGwgcmV0dXJuLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgcXVlcnkubGltaXQoMjApO1xuICpcbiAqICMjIyMgTm90ZTpcbiAqXG4gKiBDYW5ub3QgYmUgdXNlZCB3aXRoIGBkaXN0aW5jdCgpYFxuICpcbiAqIEBtZXRob2QgbGltaXRcbiAqIEBtZW1iZXJPZiBRdWVyeVxuICogQGluc3RhbmNlXG4gKiBAcGFyYW0ge051bWJlcn0gdmFsXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblF1ZXJ5LnByb3RvdHlwZS5saW1pdCA9IGZ1bmN0aW9uIGxpbWl0KHYpIHtcbiAgdGhpcy5fdmFsaWRhdGUoJ2xpbWl0Jyk7XG5cbiAgaWYgKHR5cGVvZiB2ID09PSAnc3RyaW5nJykge1xuICAgIHRyeSB7XG4gICAgICB2ID0gY2FzdE51bWJlcih2KTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHRocm93IG5ldyBDYXN0RXJyb3IoJ051bWJlcicsIHYsICdsaW1pdCcpO1xuICAgIH1cbiAgfVxuXG4gIHRoaXMub3B0aW9ucy5saW1pdCA9IHY7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTcGVjaWZpZXMgdGhlIG51bWJlciBvZiBkb2N1bWVudHMgdG8gc2tpcC5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIHF1ZXJ5LnNraXAoMTAwKS5saW1pdCgyMCk7XG4gKlxuICogIyMjIyBOb3RlOlxuICpcbiAqIENhbm5vdCBiZSB1c2VkIHdpdGggYGRpc3RpbmN0KClgXG4gKlxuICogQG1ldGhvZCBza2lwXG4gKiBAbWVtYmVyT2YgUXVlcnlcbiAqIEBpbnN0YW5jZVxuICogQHBhcmFtIHtOdW1iZXJ9IHZhbFxuICogQHNlZSBjdXJzb3Iuc2tpcCBodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9yZWZlcmVuY2UvbWV0aG9kL2N1cnNvci5za2lwL1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5RdWVyeS5wcm90b3R5cGUuc2tpcCA9IGZ1bmN0aW9uIHNraXAodikge1xuICB0aGlzLl92YWxpZGF0ZSgnc2tpcCcpO1xuXG4gIGlmICh0eXBlb2YgdiA9PT0gJ3N0cmluZycpIHtcbiAgICB0cnkge1xuICAgICAgdiA9IGNhc3ROdW1iZXIodik7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICB0aHJvdyBuZXcgQ2FzdEVycm9yKCdOdW1iZXInLCB2LCAnc2tpcCcpO1xuICAgIH1cbiAgfVxuXG4gIHRoaXMub3B0aW9ucy5za2lwID0gdjtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNwZWNpZmllcyB0aGUgYmF0Y2hTaXplIG9wdGlvbi5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIHF1ZXJ5LmJhdGNoU2l6ZSgxMDApXG4gKlxuICogIyMjIyBOb3RlOlxuICpcbiAqIENhbm5vdCBiZSB1c2VkIHdpdGggYGRpc3RpbmN0KClgXG4gKlxuICogQG1ldGhvZCBiYXRjaFNpemVcbiAqIEBtZW1iZXJPZiBRdWVyeVxuICogQGluc3RhbmNlXG4gKiBAcGFyYW0ge051bWJlcn0gdmFsXG4gKiBAc2VlIGJhdGNoU2l6ZSBodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9yZWZlcmVuY2UvbWV0aG9kL2N1cnNvci5iYXRjaFNpemUvXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbi8qKlxuICogU3BlY2lmaWVzIHRoZSBgY29tbWVudGAgb3B0aW9uLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgcXVlcnkuY29tbWVudCgnbG9naW4gcXVlcnknKVxuICpcbiAqICMjIyMgTm90ZTpcbiAqXG4gKiBDYW5ub3QgYmUgdXNlZCB3aXRoIGBkaXN0aW5jdCgpYFxuICpcbiAqIEBtZXRob2QgY29tbWVudFxuICogQG1lbWJlck9mIFF1ZXJ5XG4gKiBAaW5zdGFuY2VcbiAqIEBwYXJhbSB7U3RyaW5nfSB2YWxcbiAqIEBzZWUgY29tbWVudCBodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9yZWZlcmVuY2Uvb3BlcmF0b3IvY29tbWVudC9cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuLyoqXG4gKiBTZXRzIHF1ZXJ5IGhpbnRzLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgcXVlcnkuaGludCh7IGluZGV4QTogMSwgaW5kZXhCOiAtMSB9KTtcbiAqXG4gKiAjIyMjIE5vdGU6XG4gKlxuICogQ2Fubm90IGJlIHVzZWQgd2l0aCBgZGlzdGluY3QoKWBcbiAqXG4gKiBAbWV0aG9kIGhpbnRcbiAqIEBtZW1iZXJPZiBRdWVyeVxuICogQGluc3RhbmNlXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIGEgaGludCBvYmplY3RcbiAqIEByZXR1cm4ge1F1ZXJ5fSB0aGlzXG4gKiBAc2VlICRoaW50IGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvbWFudWFsL3JlZmVyZW5jZS9vcGVyYXRvci9oaW50L1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG4vKipcbiAqIEdldC9zZXQgdGhlIGN1cnJlbnQgcHJvamVjdGlvbiAoQUtBIGZpZWxkcykuIFBhc3MgYG51bGxgIHRvIHJlbW92ZSB0aGVcbiAqIGN1cnJlbnQgcHJvamVjdGlvbi5cbiAqXG4gKiBVbmxpa2UgYHByb2plY3Rpb24oKWAsIHRoZSBgc2VsZWN0KClgIGZ1bmN0aW9uIG1vZGlmaWVzIHRoZSBjdXJyZW50XG4gKiBwcm9qZWN0aW9uIGluIHBsYWNlLiBUaGlzIGZ1bmN0aW9uIG92ZXJ3cml0ZXMgdGhlIGV4aXN0aW5nIHByb2plY3Rpb24uXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBjb25zdCBxID0gTW9kZWwuZmluZCgpO1xuICogICAgIHEucHJvamVjdGlvbigpOyAvLyBudWxsXG4gKlxuICogICAgIHEuc2VsZWN0KCdhIGInKTtcbiAqICAgICBxLnByb2plY3Rpb24oKTsgLy8geyBhOiAxLCBiOiAxIH1cbiAqXG4gKiAgICAgcS5wcm9qZWN0aW9uKHsgYzogMSB9KTtcbiAqICAgICBxLnByb2plY3Rpb24oKTsgLy8geyBjOiAxIH1cbiAqXG4gKiAgICAgcS5wcm9qZWN0aW9uKG51bGwpO1xuICogICAgIHEucHJvamVjdGlvbigpOyAvLyBudWxsXG4gKlxuICpcbiAqIEBtZXRob2QgcHJvamVjdGlvblxuICogQG1lbWJlck9mIFF1ZXJ5XG4gKiBAaW5zdGFuY2VcbiAqIEBwYXJhbSB7T2JqZWN0fG51bGx9IGFyZ1xuICogQHJldHVybiB7T2JqZWN0fSB0aGUgY3VycmVudCBwcm9qZWN0aW9uXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblF1ZXJ5LnByb3RvdHlwZS5wcm9qZWN0aW9uID0gZnVuY3Rpb24oYXJnKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIHRoaXMuX2ZpZWxkcztcbiAgfVxuXG4gIHRoaXMuX2ZpZWxkcyA9IHt9O1xuICB0aGlzLl91c2VyUHJvdmlkZWRGaWVsZHMgPSB7fTtcbiAgdGhpcy5zZWxlY3QoYXJnKTtcbiAgcmV0dXJuIHRoaXMuX2ZpZWxkcztcbn07XG5cbi8qKlxuICogU3BlY2lmaWVzIHdoaWNoIGRvY3VtZW50IGZpZWxkcyB0byBpbmNsdWRlIG9yIGV4Y2x1ZGUgKGFsc28ga25vd24gYXMgdGhlIHF1ZXJ5IFwicHJvamVjdGlvblwiKVxuICpcbiAqIFdoZW4gdXNpbmcgc3RyaW5nIHN5bnRheCwgcHJlZml4aW5nIGEgcGF0aCB3aXRoIGAtYCB3aWxsIGZsYWcgdGhhdCBwYXRoIGFzIGV4Y2x1ZGVkLiBXaGVuIGEgcGF0aCBkb2VzIG5vdCBoYXZlIHRoZSBgLWAgcHJlZml4LCBpdCBpcyBpbmNsdWRlZC4gTGFzdGx5LCBpZiBhIHBhdGggaXMgcHJlZml4ZWQgd2l0aCBgK2AsIGl0IGZvcmNlcyBpbmNsdXNpb24gb2YgdGhlIHBhdGgsIHdoaWNoIGlzIHVzZWZ1bCBmb3IgcGF0aHMgZXhjbHVkZWQgYXQgdGhlIFtzY2hlbWEgbGV2ZWxdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvc2NoZW1hdHlwZS5odG1sI1NjaGVtYVR5cGUucHJvdG90eXBlLnNlbGVjdCgpKS5cbiAqXG4gKiBBIHByb2plY3Rpb24gX211c3RfIGJlIGVpdGhlciBpbmNsdXNpdmUgb3IgZXhjbHVzaXZlLiBJbiBvdGhlciB3b3JkcywgeW91IG11c3RcbiAqIGVpdGhlciBsaXN0IHRoZSBmaWVsZHMgdG8gaW5jbHVkZSAod2hpY2ggZXhjbHVkZXMgYWxsIG90aGVycyksIG9yIGxpc3QgdGhlIGZpZWxkc1xuICogdG8gZXhjbHVkZSAod2hpY2ggaW1wbGllcyBhbGwgb3RoZXIgZmllbGRzIGFyZSBpbmNsdWRlZCkuIFRoZSBbYF9pZGAgZmllbGQgaXMgdGhlIG9ubHkgZXhjZXB0aW9uIGJlY2F1c2UgTW9uZ29EQiBpbmNsdWRlcyBpdCBieSBkZWZhdWx0XShodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC90dXRvcmlhbC9wcm9qZWN0LWZpZWxkcy1mcm9tLXF1ZXJ5LXJlc3VsdHMvI3N1cHByZXNzLWlkLWZpZWxkKS5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIC8vIGluY2x1ZGUgYSBhbmQgYiwgZXhjbHVkZSBvdGhlciBmaWVsZHNcbiAqICAgICBxdWVyeS5zZWxlY3QoJ2EgYicpO1xuICogICAgIC8vIEVxdWl2YWxlbnQgc3ludGF4ZXM6XG4gKiAgICAgcXVlcnkuc2VsZWN0KFsnYScsICdiJ10pO1xuICogICAgIHF1ZXJ5LnNlbGVjdCh7IGE6IDEsIGI6IDEgfSk7XG4gKlxuICogICAgIC8vIGV4Y2x1ZGUgYyBhbmQgZCwgaW5jbHVkZSBvdGhlciBmaWVsZHNcbiAqICAgICBxdWVyeS5zZWxlY3QoJy1jIC1kJyk7XG4gKlxuICogICAgIC8vIFVzZSBgK2AgdG8gb3ZlcnJpZGUgc2NoZW1hLWxldmVsIGBzZWxlY3Q6IGZhbHNlYCB3aXRob3V0IG1ha2luZyB0aGVcbiAqICAgICAvLyBwcm9qZWN0aW9uIGluY2x1c2l2ZS5cbiAqICAgICBjb25zdCBzY2hlbWEgPSBuZXcgU2NoZW1hKHtcbiAqICAgICAgIGZvbzogeyB0eXBlOiBTdHJpbmcsIHNlbGVjdDogZmFsc2UgfSxcbiAqICAgICAgIGJhcjogU3RyaW5nXG4gKiAgICAgfSk7XG4gKiAgICAgLy8gLi4uXG4gKiAgICAgcXVlcnkuc2VsZWN0KCcrZm9vJyk7IC8vIE92ZXJyaWRlIGZvbydzIGBzZWxlY3Q6IGZhbHNlYCB3aXRob3V0IGV4Y2x1ZGluZyBgYmFyYFxuICpcbiAqICAgICAvLyBvciB5b3UgbWF5IHVzZSBvYmplY3Qgbm90YXRpb24sIHVzZWZ1bCB3aGVuXG4gKiAgICAgLy8geW91IGhhdmUga2V5cyBhbHJlYWR5IHByZWZpeGVkIHdpdGggYSBcIi1cIlxuICogICAgIHF1ZXJ5LnNlbGVjdCh7IGE6IDEsIGI6IDEgfSk7XG4gKiAgICAgcXVlcnkuc2VsZWN0KHsgYzogMCwgZDogMCB9KTtcbiAqXG4gKiAgICAgQWRkaXRpb25hbCBjYWxscyB0byBzZWxlY3QgY2FuIG92ZXJyaWRlIHRoZSBwcmV2aW91cyBzZWxlY3Rpb246XG4gKiAgICAgcXVlcnkuc2VsZWN0KHsgYTogMSwgYjogMSB9KS5zZWxlY3QoeyBiOiAwIH0pOyAvLyBzZWxlY3Rpb24gaXMgbm93IHsgYTogMSB9XG4gKiAgICAgcXVlcnkuc2VsZWN0KHsgYTogMCwgYjogMCB9KS5zZWxlY3QoeyBiOiAxIH0pOyAvLyBzZWxlY3Rpb24gaXMgbm93IHsgYTogMCB9XG4gKlxuICpcbiAqIEBtZXRob2Qgc2VsZWN0XG4gKiBAbWVtYmVyT2YgUXVlcnlcbiAqIEBpbnN0YW5jZVxuICogQHBhcmFtIHtPYmplY3R8U3RyaW5nfFN0cmluZ1tdfSBhcmdcbiAqIEByZXR1cm4ge1F1ZXJ5fSB0aGlzXG4gKiBAc2VlIFNjaGVtYVR5cGUgaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2FwaS9zY2hlbWF0eXBlLmh0bWxcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUXVlcnkucHJvdG90eXBlLnNlbGVjdCA9IGZ1bmN0aW9uIHNlbGVjdCgpIHtcbiAgbGV0IGFyZyA9IGFyZ3VtZW50c1swXTtcbiAgaWYgKCFhcmcpIHJldHVybiB0aGlzO1xuXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoICE9PSAxKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHNlbGVjdDogc2VsZWN0IG9ubHkgdGFrZXMgMSBhcmd1bWVudCcpO1xuICB9XG5cbiAgdGhpcy5fdmFsaWRhdGUoJ3NlbGVjdCcpO1xuXG4gIGNvbnN0IGZpZWxkcyA9IHRoaXMuX2ZpZWxkcyB8fCAodGhpcy5fZmllbGRzID0ge30pO1xuICBjb25zdCB1c2VyUHJvdmlkZWRGaWVsZHMgPSB0aGlzLl91c2VyUHJvdmlkZWRGaWVsZHMgfHwgKHRoaXMuX3VzZXJQcm92aWRlZEZpZWxkcyA9IHt9KTtcbiAgbGV0IHNhbml0aXplUHJvamVjdGlvbiA9IHVuZGVmaW5lZDtcbiAgaWYgKHRoaXMubW9kZWwgIT0gbnVsbCAmJiB1dGlscy5oYXNVc2VyRGVmaW5lZFByb3BlcnR5KHRoaXMubW9kZWwuZGIub3B0aW9ucywgJ3Nhbml0aXplUHJvamVjdGlvbicpKSB7XG4gICAgc2FuaXRpemVQcm9qZWN0aW9uID0gdGhpcy5tb2RlbC5kYi5vcHRpb25zLnNhbml0aXplUHJvamVjdGlvbjtcbiAgfSBlbHNlIGlmICh0aGlzLm1vZGVsICE9IG51bGwgJiYgdXRpbHMuaGFzVXNlckRlZmluZWRQcm9wZXJ0eSh0aGlzLm1vZGVsLmJhc2Uub3B0aW9ucywgJ3Nhbml0aXplUHJvamVjdGlvbicpKSB7XG4gICAgc2FuaXRpemVQcm9qZWN0aW9uID0gdGhpcy5tb2RlbC5iYXNlLm9wdGlvbnMuc2FuaXRpemVQcm9qZWN0aW9uO1xuICB9IGVsc2Uge1xuICAgIHNhbml0aXplUHJvamVjdGlvbiA9IHRoaXMuX21vbmdvb3NlT3B0aW9ucy5zYW5pdGl6ZVByb2plY3Rpb247XG4gIH1cblxuICBmdW5jdGlvbiBzYW5pdGl6ZVZhbHVlKHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgJiYgc2FuaXRpemVQcm9qZWN0aW9uID8gdmFsdWUgPSAxIDogdmFsdWU7XG4gIH1cbiAgYXJnID0gcGFyc2VQcm9qZWN0aW9uKGFyZywgdHJ1ZSk7IC8vIHdlIHdhbnQgdG8ga2VlcCB0aGUgbWludXMgYW5kIHBsdXNlcywgc28gYWRkIGJvb2xlYW4gYXJnLlxuICBpZiAodXRpbHMuaXNPYmplY3QoYXJnKSkge1xuICAgIGlmICh0aGlzLnNlbGVjdGVkSW5jbHVzaXZlbHkoKSkge1xuICAgICAgT2JqZWN0LmVudHJpZXMoYXJnKS5mb3JFYWNoKChba2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgLy8gQWRkIHRoZSBmaWVsZCB0byB0aGUgcHJvamVjdGlvblxuICAgICAgICAgIGlmIChmaWVsZHNbJy0nICsga2V5XSAhPSBudWxsKSB7XG4gICAgICAgICAgICBkZWxldGUgZmllbGRzWyctJyArIGtleV07XG4gICAgICAgICAgfVxuICAgICAgICAgIGZpZWxkc1trZXldID0gdXNlclByb3ZpZGVkRmllbGRzW2tleV0gPSBzYW5pdGl6ZVZhbHVlKHZhbHVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBSZW1vdmUgdGhlIGZpZWxkIGZyb20gdGhlIHByb2plY3Rpb25cbiAgICAgICAgICBPYmplY3Qua2V5cyh1c2VyUHJvdmlkZWRGaWVsZHMpLmZvckVhY2goZmllbGQgPT4ge1xuICAgICAgICAgICAgaWYgKGlzU3VicGF0aChrZXksIGZpZWxkKSkge1xuICAgICAgICAgICAgICBkZWxldGUgZmllbGRzW2ZpZWxkXTtcbiAgICAgICAgICAgICAgZGVsZXRlIHVzZXJQcm92aWRlZEZpZWxkc1tmaWVsZF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAodGhpcy5zZWxlY3RlZEV4Y2x1c2l2ZWx5KCkpIHtcbiAgICAgIE9iamVjdC5lbnRyaWVzKGFyZykuZm9yRWFjaCgoW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgICAgIGlmICghdmFsdWUpIHtcbiAgICAgICAgICAvLyBBZGQgdGhlIGZpZWxkIHRvIHRoZSBwcm9qZWN0aW9uXG4gICAgICAgICAgaWYgKGZpZWxkc1snKycgKyBrZXldICE9IG51bGwpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBmaWVsZHNbJysnICsga2V5XTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZmllbGRzW2tleV0gPSB1c2VyUHJvdmlkZWRGaWVsZHNba2V5XSA9IHNhbml0aXplVmFsdWUodmFsdWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIFJlbW92ZSB0aGUgZmllbGQgZnJvbSB0aGUgcHJvamVjdGlvblxuICAgICAgICAgIE9iamVjdC5rZXlzKHVzZXJQcm92aWRlZEZpZWxkcykuZm9yRWFjaChmaWVsZCA9PiB7XG4gICAgICAgICAgICBpZiAoaXNTdWJwYXRoKGtleSwgZmllbGQpKSB7XG4gICAgICAgICAgICAgIGRlbGV0ZSBmaWVsZHNbZmllbGRdO1xuICAgICAgICAgICAgICBkZWxldGUgdXNlclByb3ZpZGVkRmllbGRzW2ZpZWxkXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhhcmcpO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gYXJnW2tleXNbaV1dO1xuICAgICAgICBjb25zdCBrZXkgPSBrZXlzW2ldO1xuICAgICAgICBmaWVsZHNba2V5XSA9IHNhbml0aXplVmFsdWUodmFsdWUpO1xuICAgICAgICB1c2VyUHJvdmlkZWRGaWVsZHNba2V5XSA9IHNhbml0aXplVmFsdWUodmFsdWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBzZWxlY3QoKSBhcmd1bWVudC4gTXVzdCBiZSBzdHJpbmcgb3Igb2JqZWN0LicpO1xufTtcblxuLyoqXG4gKiBEZXRlcm1pbmVzIHRoZSBNb25nb0RCIG5vZGVzIGZyb20gd2hpY2ggdG8gcmVhZC5cbiAqXG4gKiAjIyMjIFByZWZlcmVuY2VzOlxuICpcbiAqIGBgYFxuICogcHJpbWFyeSAtIChkZWZhdWx0KSBSZWFkIGZyb20gcHJpbWFyeSBvbmx5LiBPcGVyYXRpb25zIHdpbGwgcHJvZHVjZSBhbiBlcnJvciBpZiBwcmltYXJ5IGlzIHVuYXZhaWxhYmxlLiBDYW5ub3QgYmUgY29tYmluZWQgd2l0aCB0YWdzLlxuICogc2Vjb25kYXJ5ICAgICAgICAgICAgUmVhZCBmcm9tIHNlY29uZGFyeSBpZiBhdmFpbGFibGUsIG90aGVyd2lzZSBlcnJvci5cbiAqIHByaW1hcnlQcmVmZXJyZWQgICAgIFJlYWQgZnJvbSBwcmltYXJ5IGlmIGF2YWlsYWJsZSwgb3RoZXJ3aXNlIGEgc2Vjb25kYXJ5LlxuICogc2Vjb25kYXJ5UHJlZmVycmVkICAgUmVhZCBmcm9tIGEgc2Vjb25kYXJ5IGlmIGF2YWlsYWJsZSwgb3RoZXJ3aXNlIHJlYWQgZnJvbSB0aGUgcHJpbWFyeS5cbiAqIG5lYXJlc3QgICAgICAgICAgICAgIEFsbCBvcGVyYXRpb25zIHJlYWQgZnJvbSBhbW9uZyB0aGUgbmVhcmVzdCBjYW5kaWRhdGVzLCBidXQgdW5saWtlIG90aGVyIG1vZGVzLCB0aGlzIG9wdGlvbiB3aWxsIGluY2x1ZGUgYm90aCB0aGUgcHJpbWFyeSBhbmQgYWxsIHNlY29uZGFyaWVzIGluIHRoZSByYW5kb20gc2VsZWN0aW9uLlxuICogYGBgXG4gKlxuICogQWxpYXNlc1xuICpcbiAqIGBgYFxuICogcCAgIHByaW1hcnlcbiAqIHBwICBwcmltYXJ5UHJlZmVycmVkXG4gKiBzICAgc2Vjb25kYXJ5XG4gKiBzcCAgc2Vjb25kYXJ5UHJlZmVycmVkXG4gKiBuICAgbmVhcmVzdFxuICogYGBgXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBuZXcgUXVlcnkoKS5yZWFkKCdwcmltYXJ5JylcbiAqICAgICBuZXcgUXVlcnkoKS5yZWFkKCdwJykgIC8vIHNhbWUgYXMgcHJpbWFyeVxuICpcbiAqICAgICBuZXcgUXVlcnkoKS5yZWFkKCdwcmltYXJ5UHJlZmVycmVkJylcbiAqICAgICBuZXcgUXVlcnkoKS5yZWFkKCdwcCcpIC8vIHNhbWUgYXMgcHJpbWFyeVByZWZlcnJlZFxuICpcbiAqICAgICBuZXcgUXVlcnkoKS5yZWFkKCdzZWNvbmRhcnknKVxuICogICAgIG5ldyBRdWVyeSgpLnJlYWQoJ3MnKSAgLy8gc2FtZSBhcyBzZWNvbmRhcnlcbiAqXG4gKiAgICAgbmV3IFF1ZXJ5KCkucmVhZCgnc2Vjb25kYXJ5UHJlZmVycmVkJylcbiAqICAgICBuZXcgUXVlcnkoKS5yZWFkKCdzcCcpIC8vIHNhbWUgYXMgc2Vjb25kYXJ5UHJlZmVycmVkXG4gKlxuICogICAgIG5ldyBRdWVyeSgpLnJlYWQoJ25lYXJlc3QnKVxuICogICAgIG5ldyBRdWVyeSgpLnJlYWQoJ24nKSAgLy8gc2FtZSBhcyBuZWFyZXN0XG4gKlxuICogICAgIC8vIHJlYWQgZnJvbSBzZWNvbmRhcmllcyB3aXRoIG1hdGNoaW5nIHRhZ3NcbiAqICAgICBuZXcgUXVlcnkoKS5yZWFkKCdzJywgW3sgZGM6J3NmJywgczogMSB9LHsgZGM6J21hJywgczogMiB9XSlcbiAqXG4gKiBSZWFkIG1vcmUgYWJvdXQgaG93IHRvIHVzZSByZWFkIHByZWZlcmVuY2VzIFtoZXJlXShodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9hcHBsaWNhdGlvbnMvcmVwbGljYXRpb24vI3JlYWQtcHJlZmVyZW5jZSkuXG4gKlxuICogQG1ldGhvZCByZWFkXG4gKiBAbWVtYmVyT2YgUXVlcnlcbiAqIEBpbnN0YW5jZVxuICogQHBhcmFtIHtTdHJpbmd9IG1vZGUgb25lIG9mIHRoZSBsaXN0ZWQgcHJlZmVyZW5jZSBvcHRpb25zIG9yIGFsaWFzZXNcbiAqIEBwYXJhbSB7QXJyYXl9IFt0YWdzXSBvcHRpb25hbCB0YWdzIGZvciB0aGlzIHF1ZXJ5XG4gKiBAc2VlIG1vbmdvZGIgaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvYXBwbGljYXRpb25zL3JlcGxpY2F0aW9uLyNyZWFkLXByZWZlcmVuY2VcbiAqIEByZXR1cm4ge1F1ZXJ5fSB0aGlzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblF1ZXJ5LnByb3RvdHlwZS5yZWFkID0gZnVuY3Rpb24gcmVhZChtb2RlLCB0YWdzKSB7XG4gIGlmICh0eXBlb2YgbW9kZSA9PT0gJ3N0cmluZycpIHtcbiAgICBtb2RlID0gaGFuZGxlUmVhZFByZWZlcmVuY2VBbGlhc2VzKG1vZGUpO1xuICAgIHRoaXMub3B0aW9ucy5yZWFkUHJlZmVyZW5jZSA9IHsgbW9kZSwgdGFncyB9O1xuICB9IGVsc2Uge1xuICAgIHRoaXMub3B0aW9ucy5yZWFkUHJlZmVyZW5jZSA9IG1vZGU7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIE92ZXJ3cml0ZSBkZWZhdWx0IGAudG9TdHJpbmdgIHRvIG1ha2UgbG9nZ2luZyBtb3JlIHVzZWZ1bFxuICpcbiAqIEBtZW1iZXJPZiBRdWVyeVxuICogQGluc3RhbmNlXG4gKiBAbWV0aG9kIHRvU3RyaW5nXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5RdWVyeS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgaWYgKHRoaXMub3AgPT09ICdjb3VudCcgfHxcbiAgICAgIHRoaXMub3AgPT09ICdjb3VudERvY3VtZW50cycgfHxcbiAgICAgIHRoaXMub3AgPT09ICdmaW5kJyB8fFxuICAgICAgdGhpcy5vcCA9PT0gJ2ZpbmRPbmUnIHx8XG4gICAgICB0aGlzLm9wID09PSAnZGVsZXRlTWFueScgfHxcbiAgICAgIHRoaXMub3AgPT09ICdkZWxldGVPbmUnIHx8XG4gICAgICB0aGlzLm9wID09PSAnZmluZE9uZUFuZERlbGV0ZScgfHxcbiAgICAgIHRoaXMub3AgPT09ICdyZW1vdmUnKSB7XG4gICAgcmV0dXJuIGAke3RoaXMubW9kZWwubW9kZWxOYW1lfS4ke3RoaXMub3B9KCR7dXRpbC5pbnNwZWN0KHRoaXMuX2NvbmRpdGlvbnMpfSlgO1xuICB9XG4gIGlmICh0aGlzLm9wID09PSAnZGlzdGluY3QnKSB7XG4gICAgcmV0dXJuIGAke3RoaXMubW9kZWwubW9kZWxOYW1lfS5kaXN0aW5jdCgnJHt0aGlzLl9kaXN0aW5jdH0nLCAke3V0aWwuaW5zcGVjdCh0aGlzLl9jb25kaXRpb25zKX0pYDtcbiAgfVxuICBpZiAodGhpcy5vcCA9PT0gJ2ZpbmRPbmVBbmRSZXBsYWNlJyB8fFxuICAgICAgdGhpcy5vcCA9PT0gJ2ZpbmRPbmVBbmRVcGRhdGUnIHx8XG4gICAgICB0aGlzLm9wID09PSAncmVwbGFjZU9uZScgfHxcbiAgICAgIHRoaXMub3AgPT09ICd1cGRhdGUnIHx8XG4gICAgICB0aGlzLm9wID09PSAndXBkYXRlTWFueScgfHxcbiAgICAgIHRoaXMub3AgPT09ICd1cGRhdGVPbmUnKSB7XG4gICAgcmV0dXJuIGAke3RoaXMubW9kZWwubW9kZWxOYW1lfS4ke3RoaXMub3B9KCR7dXRpbC5pbnNwZWN0KHRoaXMuX2NvbmRpdGlvbnMpfSwgJHt1dGlsLmluc3BlY3QodGhpcy5fdXBkYXRlKX0pYDtcbiAgfVxuXG4gIC8vICdlc3RpbWF0ZWREb2N1bWVudENvdW50JyBvciBhbnkgb3RoZXJzXG4gIHJldHVybiBgJHt0aGlzLm1vZGVsLm1vZGVsTmFtZX0uJHt0aGlzLm9wfSgpYDtcbn07XG5cbi8qKlxuICogU2V0cyB0aGUgW01vbmdvREIgc2Vzc2lvbl0oaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvcmVmZXJlbmNlL3NlcnZlci1zZXNzaW9ucy8pXG4gKiBhc3NvY2lhdGVkIHdpdGggdGhpcyBxdWVyeS4gU2Vzc2lvbnMgYXJlIGhvdyB5b3UgbWFyayBhIHF1ZXJ5IGFzIHBhcnQgb2YgYVxuICogW3RyYW5zYWN0aW9uXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvdHJhbnNhY3Rpb25zLmh0bWwpLlxuICpcbiAqIENhbGxpbmcgYHNlc3Npb24obnVsbClgIHJlbW92ZXMgdGhlIHNlc3Npb24gZnJvbSB0aGlzIHF1ZXJ5LlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgY29uc3QgcyA9IGF3YWl0IG1vbmdvb3NlLnN0YXJ0U2Vzc2lvbigpO1xuICogICAgIGF3YWl0IG1vbmdvb3NlLm1vZGVsKCdQZXJzb24nKS5maW5kT25lKHsgbmFtZTogJ0F4bCBSb3NlJyB9KS5zZXNzaW9uKHMpO1xuICpcbiAqIEBtZXRob2Qgc2Vzc2lvblxuICogQG1lbWJlck9mIFF1ZXJ5XG4gKiBAaW5zdGFuY2VcbiAqIEBwYXJhbSB7Q2xpZW50U2Vzc2lvbn0gW3Nlc3Npb25dIGZyb20gYGF3YWl0IGNvbm4uc3RhcnRTZXNzaW9uKClgXG4gKiBAc2VlIENvbm5lY3Rpb24ucHJvdG90eXBlLnN0YXJ0U2Vzc2lvbigpIGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvY29ubmVjdGlvbi5odG1sI0Nvbm5lY3Rpb24ucHJvdG90eXBlLnN0YXJ0U2Vzc2lvbigpXG4gKiBAc2VlIG1vbmdvb3NlLnN0YXJ0U2Vzc2lvbigpIGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvbW9uZ29vc2UuaHRtbCNNb25nb29zZS5wcm90b3R5cGUuc3RhcnRTZXNzaW9uKClcbiAqIEByZXR1cm4ge1F1ZXJ5fSB0aGlzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblF1ZXJ5LnByb3RvdHlwZS5zZXNzaW9uID0gZnVuY3Rpb24gc2Vzc2lvbih2KSB7XG4gIGlmICh2ID09IG51bGwpIHtcbiAgICBkZWxldGUgdGhpcy5vcHRpb25zLnNlc3Npb247XG4gIH1cbiAgdGhpcy5vcHRpb25zLnNlc3Npb24gPSB2O1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2V0cyB0aGUgMyB3cml0ZSBjb25jZXJuIHBhcmFtZXRlcnMgZm9yIHRoaXMgcXVlcnk6XG4gKlxuICogLSBgd2A6IFNldHMgdGhlIHNwZWNpZmllZCBudW1iZXIgb2YgYG1vbmdvZGAgc2VydmVycywgb3IgdGFnIHNldCBvZiBgbW9uZ29kYCBzZXJ2ZXJzLCB0aGF0IG11c3QgYWNrbm93bGVkZ2UgdGhpcyB3cml0ZSBiZWZvcmUgdGhpcyB3cml0ZSBpcyBjb25zaWRlcmVkIHN1Y2Nlc3NmdWwuXG4gKiAtIGBqYDogQm9vbGVhbiwgc2V0IHRvIGB0cnVlYCB0byByZXF1ZXN0IGFja25vd2xlZGdlbWVudCB0aGF0IHRoaXMgb3BlcmF0aW9uIGhhcyBiZWVuIHBlcnNpc3RlZCB0byBNb25nb0RCJ3Mgb24tZGlzayBqb3VybmFsLlxuICogLSBgd3RpbWVvdXRgOiBJZiBbYHcgPiAxYF0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2FwaS9xdWVyeS5odG1sI1F1ZXJ5LnByb3RvdHlwZS53KCkpLCB0aGUgbWF4aW11bSBhbW91bnQgb2YgdGltZSB0byB3YWl0IGZvciB0aGlzIHdyaXRlIHRvIHByb3BhZ2F0ZSB0aHJvdWdoIHRoZSByZXBsaWNhIHNldCBiZWZvcmUgdGhpcyBvcGVyYXRpb24gZmFpbHMuIFRoZSBkZWZhdWx0IGlzIGAwYCwgd2hpY2ggbWVhbnMgbm8gdGltZW91dC5cbiAqXG4gKiBUaGlzIG9wdGlvbiBpcyBvbmx5IHZhbGlkIGZvciBvcGVyYXRpb25zIHRoYXQgd3JpdGUgdG8gdGhlIGRhdGFiYXNlOlxuICpcbiAqIC0gYGRlbGV0ZU9uZSgpYFxuICogLSBgZGVsZXRlTWFueSgpYFxuICogLSBgZmluZE9uZUFuZERlbGV0ZSgpYFxuICogLSBgZmluZE9uZUFuZFJlcGxhY2UoKWBcbiAqIC0gYGZpbmRPbmVBbmRVcGRhdGUoKWBcbiAqIC0gYHVwZGF0ZU9uZSgpYFxuICogLSBgdXBkYXRlTWFueSgpYFxuICpcbiAqIERlZmF1bHRzIHRvIHRoZSBzY2hlbWEncyBbYHdyaXRlQ29uY2VybmAgb3B0aW9uXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvZ3VpZGUuaHRtbCN3cml0ZUNvbmNlcm4pXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICAvLyBUaGUgJ21ham9yaXR5JyBvcHRpb24gbWVhbnMgdGhlIGBkZWxldGVPbmUoKWAgcHJvbWlzZSB3b24ndCByZXNvbHZlXG4gKiAgICAgLy8gdW50aWwgdGhlIGBkZWxldGVPbmUoKWAgaGFzIHByb3BhZ2F0ZWQgdG8gdGhlIG1ham9yaXR5IG9mIHRoZSByZXBsaWNhIHNldFxuICogICAgIGF3YWl0IG1vbmdvb3NlLm1vZGVsKCdQZXJzb24nKS5cbiAqICAgICAgIGRlbGV0ZU9uZSh7IG5hbWU6ICdOZWQgU3RhcmsnIH0pLlxuICogICAgICAgd3JpdGVDb25jZXJuKHsgdzogJ21ham9yaXR5JyB9KTtcbiAqXG4gKiBAbWV0aG9kIHdyaXRlQ29uY2VyblxuICogQG1lbWJlck9mIFF1ZXJ5XG4gKiBAaW5zdGFuY2VcbiAqIEBwYXJhbSB7T2JqZWN0fSB3cml0ZUNvbmNlcm4gdGhlIHdyaXRlIGNvbmNlcm4gdmFsdWUgdG8gc2V0XG4gKiBAc2VlIFdyaXRlQ29uY2VyblNldHRpbmdzIGh0dHBzOi8vbW9uZ29kYi5naXRodWIuaW8vbm9kZS1tb25nb2RiLW5hdGl2ZS80LjkvaW50ZXJmYWNlcy9Xcml0ZUNvbmNlcm5TZXR0aW5ncy5odG1sXG4gKiBAcmV0dXJuIHtRdWVyeX0gdGhpc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5RdWVyeS5wcm90b3R5cGUud3JpdGVDb25jZXJuID0gZnVuY3Rpb24gd3JpdGVDb25jZXJuKHZhbCkge1xuICBpZiAodmFsID09IG51bGwpIHtcbiAgICBkZWxldGUgdGhpcy5vcHRpb25zLndyaXRlQ29uY2VybjtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICB0aGlzLm9wdGlvbnMud3JpdGVDb25jZXJuID0gdmFsO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2V0cyB0aGUgc3BlY2lmaWVkIG51bWJlciBvZiBgbW9uZ29kYCBzZXJ2ZXJzLCBvciB0YWcgc2V0IG9mIGBtb25nb2RgIHNlcnZlcnMsXG4gKiB0aGF0IG11c3QgYWNrbm93bGVkZ2UgdGhpcyB3cml0ZSBiZWZvcmUgdGhpcyB3cml0ZSBpcyBjb25zaWRlcmVkIHN1Y2Nlc3NmdWwuXG4gKiBUaGlzIG9wdGlvbiBpcyBvbmx5IHZhbGlkIGZvciBvcGVyYXRpb25zIHRoYXQgd3JpdGUgdG8gdGhlIGRhdGFiYXNlOlxuICpcbiAqIC0gYGRlbGV0ZU9uZSgpYFxuICogLSBgZGVsZXRlTWFueSgpYFxuICogLSBgZmluZE9uZUFuZERlbGV0ZSgpYFxuICogLSBgZmluZE9uZUFuZFJlcGxhY2UoKWBcbiAqIC0gYGZpbmRPbmVBbmRVcGRhdGUoKWBcbiAqIC0gYHVwZGF0ZU9uZSgpYFxuICogLSBgdXBkYXRlTWFueSgpYFxuICpcbiAqIERlZmF1bHRzIHRvIHRoZSBzY2hlbWEncyBbYHdyaXRlQ29uY2Vybi53YCBvcHRpb25dKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9ndWlkZS5odG1sI3dyaXRlQ29uY2VybilcbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIC8vIFRoZSAnbWFqb3JpdHknIG9wdGlvbiBtZWFucyB0aGUgYGRlbGV0ZU9uZSgpYCBwcm9taXNlIHdvbid0IHJlc29sdmVcbiAqICAgICAvLyB1bnRpbCB0aGUgYGRlbGV0ZU9uZSgpYCBoYXMgcHJvcGFnYXRlZCB0byB0aGUgbWFqb3JpdHkgb2YgdGhlIHJlcGxpY2Egc2V0XG4gKiAgICAgYXdhaXQgbW9uZ29vc2UubW9kZWwoJ1BlcnNvbicpLlxuICogICAgICAgZGVsZXRlT25lKHsgbmFtZTogJ05lZCBTdGFyaycgfSkuXG4gKiAgICAgICB3KCdtYWpvcml0eScpO1xuICpcbiAqIEBtZXRob2Qgd1xuICogQG1lbWJlck9mIFF1ZXJ5XG4gKiBAaW5zdGFuY2VcbiAqIEBwYXJhbSB7U3RyaW5nfG51bWJlcn0gdmFsIDAgZm9yIGZpcmUtYW5kLWZvcmdldCwgMSBmb3IgYWNrbm93bGVkZ2VkIGJ5IG9uZSBzZXJ2ZXIsICdtYWpvcml0eScgZm9yIG1ham9yaXR5IG9mIHRoZSByZXBsaWNhIHNldCwgb3IgW2FueSBvZiB0aGUgbW9yZSBhZHZhbmNlZCBvcHRpb25zXShodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9yZWZlcmVuY2Uvd3JpdGUtY29uY2Vybi8jdy1vcHRpb24pLlxuICogQHNlZSBtb25nb2RiIGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvbWFudWFsL3JlZmVyZW5jZS93cml0ZS1jb25jZXJuLyN3LW9wdGlvblxuICogQHJldHVybiB7UXVlcnl9IHRoaXNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUXVlcnkucHJvdG90eXBlLncgPSBmdW5jdGlvbiB3KHZhbCkge1xuICBpZiAodmFsID09IG51bGwpIHtcbiAgICBkZWxldGUgdGhpcy5vcHRpb25zLnc7XG4gIH1cbiAgaWYgKHRoaXMub3B0aW9ucy53cml0ZUNvbmNlcm4gIT0gbnVsbCkge1xuICAgIHRoaXMub3B0aW9ucy53cml0ZUNvbmNlcm4udyA9IHZhbDtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLm9wdGlvbnMudyA9IHZhbDtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUmVxdWVzdHMgYWNrbm93bGVkZ2VtZW50IHRoYXQgdGhpcyBvcGVyYXRpb24gaGFzIGJlZW4gcGVyc2lzdGVkIHRvIE1vbmdvREInc1xuICogb24tZGlzayBqb3VybmFsLlxuICogVGhpcyBvcHRpb24gaXMgb25seSB2YWxpZCBmb3Igb3BlcmF0aW9ucyB0aGF0IHdyaXRlIHRvIHRoZSBkYXRhYmFzZTpcbiAqXG4gKiAtIGBkZWxldGVPbmUoKWBcbiAqIC0gYGRlbGV0ZU1hbnkoKWBcbiAqIC0gYGZpbmRPbmVBbmREZWxldGUoKWBcbiAqIC0gYGZpbmRPbmVBbmRSZXBsYWNlKClgXG4gKiAtIGBmaW5kT25lQW5kVXBkYXRlKClgXG4gKiAtIGB1cGRhdGVPbmUoKWBcbiAqIC0gYHVwZGF0ZU1hbnkoKWBcbiAqXG4gKiBEZWZhdWx0cyB0byB0aGUgc2NoZW1hJ3MgW2B3cml0ZUNvbmNlcm4uamAgb3B0aW9uXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvZ3VpZGUuaHRtbCN3cml0ZUNvbmNlcm4pXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBhd2FpdCBtb25nb29zZS5tb2RlbCgnUGVyc29uJykuZGVsZXRlT25lKHsgbmFtZTogJ05lZCBTdGFyaycgfSkuaih0cnVlKTtcbiAqXG4gKiBAbWV0aG9kIGpcbiAqIEBtZW1iZXJPZiBRdWVyeVxuICogQGluc3RhbmNlXG4gKiBAcGFyYW0ge2Jvb2xlYW59IHZhbFxuICogQHNlZSBtb25nb2RiIGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvbWFudWFsL3JlZmVyZW5jZS93cml0ZS1jb25jZXJuLyNqLW9wdGlvblxuICogQHJldHVybiB7UXVlcnl9IHRoaXNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUXVlcnkucHJvdG90eXBlLmogPSBmdW5jdGlvbiBqKHZhbCkge1xuICBpZiAodmFsID09IG51bGwpIHtcbiAgICBkZWxldGUgdGhpcy5vcHRpb25zLmo7XG4gIH1cbiAgaWYgKHRoaXMub3B0aW9ucy53cml0ZUNvbmNlcm4gIT0gbnVsbCkge1xuICAgIHRoaXMub3B0aW9ucy53cml0ZUNvbmNlcm4uaiA9IHZhbDtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLm9wdGlvbnMuaiA9IHZhbDtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogSWYgW2B3ID4gMWBdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvcXVlcnkuaHRtbCNRdWVyeS5wcm90b3R5cGUudygpKSwgdGhlIG1heGltdW0gYW1vdW50IG9mIHRpbWUgdG9cbiAqIHdhaXQgZm9yIHRoaXMgd3JpdGUgdG8gcHJvcGFnYXRlIHRocm91Z2ggdGhlIHJlcGxpY2Egc2V0IGJlZm9yZSB0aGlzXG4gKiBvcGVyYXRpb24gZmFpbHMuIFRoZSBkZWZhdWx0IGlzIGAwYCwgd2hpY2ggbWVhbnMgbm8gdGltZW91dC5cbiAqXG4gKiBUaGlzIG9wdGlvbiBpcyBvbmx5IHZhbGlkIGZvciBvcGVyYXRpb25zIHRoYXQgd3JpdGUgdG8gdGhlIGRhdGFiYXNlOlxuICpcbiAqIC0gYGRlbGV0ZU9uZSgpYFxuICogLSBgZGVsZXRlTWFueSgpYFxuICogLSBgZmluZE9uZUFuZERlbGV0ZSgpYFxuICogLSBgZmluZE9uZUFuZFJlcGxhY2UoKWBcbiAqIC0gYGZpbmRPbmVBbmRVcGRhdGUoKWBcbiAqIC0gYHVwZGF0ZU9uZSgpYFxuICogLSBgdXBkYXRlTWFueSgpYFxuICpcbiAqIERlZmF1bHRzIHRvIHRoZSBzY2hlbWEncyBbYHdyaXRlQ29uY2Vybi53dGltZW91dGAgb3B0aW9uXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvZ3VpZGUuaHRtbCN3cml0ZUNvbmNlcm4pXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICAvLyBUaGUgYGRlbGV0ZU9uZSgpYCBwcm9taXNlIHdvbid0IHJlc29sdmUgdW50aWwgdGhpcyBgZGVsZXRlT25lKClgIGhhc1xuICogICAgIC8vIHByb3BhZ2F0ZWQgdG8gYXQgbGVhc3QgYHcgPSAyYCBtZW1iZXJzIG9mIHRoZSByZXBsaWNhIHNldC4gSWYgaXQgdGFrZXNcbiAqICAgICAvLyBsb25nZXIgdGhhbiAxIHNlY29uZCwgdGhpcyBgZGVsZXRlT25lKClgIHdpbGwgZmFpbC5cbiAqICAgICBhd2FpdCBtb25nb29zZS5tb2RlbCgnUGVyc29uJykuXG4gKiAgICAgICBkZWxldGVPbmUoeyBuYW1lOiAnTmVkIFN0YXJrJyB9KS5cbiAqICAgICAgIHcoMikuXG4gKiAgICAgICB3dGltZW91dCgxMDAwKTtcbiAqXG4gKiBAbWV0aG9kIHd0aW1lb3V0XG4gKiBAbWVtYmVyT2YgUXVlcnlcbiAqIEBpbnN0YW5jZVxuICogQHBhcmFtIHtudW1iZXJ9IG1zIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdG8gd2FpdFxuICogQHNlZSBtb25nb2RiIGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvbWFudWFsL3JlZmVyZW5jZS93cml0ZS1jb25jZXJuLyN3dGltZW91dFxuICogQHJldHVybiB7UXVlcnl9IHRoaXNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUXVlcnkucHJvdG90eXBlLnd0aW1lb3V0ID0gZnVuY3Rpb24gd3RpbWVvdXQobXMpIHtcbiAgaWYgKG1zID09IG51bGwpIHtcbiAgICBkZWxldGUgdGhpcy5vcHRpb25zLnd0aW1lb3V0O1xuICB9XG4gIGlmICh0aGlzLm9wdGlvbnMud3JpdGVDb25jZXJuICE9IG51bGwpIHtcbiAgICB0aGlzLm9wdGlvbnMud3JpdGVDb25jZXJuLnd0aW1lb3V0ID0gbXM7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5vcHRpb25zLnd0aW1lb3V0ID0gbXM7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNldHMgdGhlIHJlYWRDb25jZXJuIG9wdGlvbiBmb3IgdGhlIHF1ZXJ5LlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgbmV3IFF1ZXJ5KCkucmVhZENvbmNlcm4oJ2xvY2FsJylcbiAqICAgICBuZXcgUXVlcnkoKS5yZWFkQ29uY2VybignbCcpICAvLyBzYW1lIGFzIGxvY2FsXG4gKlxuICogICAgIG5ldyBRdWVyeSgpLnJlYWRDb25jZXJuKCdhdmFpbGFibGUnKVxuICogICAgIG5ldyBRdWVyeSgpLnJlYWRDb25jZXJuKCdhJykgIC8vIHNhbWUgYXMgYXZhaWxhYmxlXG4gKlxuICogICAgIG5ldyBRdWVyeSgpLnJlYWRDb25jZXJuKCdtYWpvcml0eScpXG4gKiAgICAgbmV3IFF1ZXJ5KCkucmVhZENvbmNlcm4oJ20nKSAgLy8gc2FtZSBhcyBtYWpvcml0eVxuICpcbiAqICAgICBuZXcgUXVlcnkoKS5yZWFkQ29uY2VybignbGluZWFyaXphYmxlJylcbiAqICAgICBuZXcgUXVlcnkoKS5yZWFkQ29uY2VybignbHonKSAvLyBzYW1lIGFzIGxpbmVhcml6YWJsZVxuICpcbiAqICAgICBuZXcgUXVlcnkoKS5yZWFkQ29uY2Vybignc25hcHNob3QnKVxuICogICAgIG5ldyBRdWVyeSgpLnJlYWRDb25jZXJuKCdzJykgIC8vIHNhbWUgYXMgc25hcHNob3RcbiAqXG4gKlxuICogIyMjIyBSZWFkIENvbmNlcm4gTGV2ZWw6XG4gKlxuICogYGBgXG4gKiBsb2NhbCAgICAgICAgIE1vbmdvREIgMy4yKyBUaGUgcXVlcnkgcmV0dXJucyBmcm9tIHRoZSBpbnN0YW5jZSB3aXRoIG5vIGd1YXJhbnRlZSBndWFyYW50ZWUgdGhhdCB0aGUgZGF0YSBoYXMgYmVlbiB3cml0dGVuIHRvIGEgbWFqb3JpdHkgb2YgdGhlIHJlcGxpY2Egc2V0IG1lbWJlcnMgKGkuZS4gbWF5IGJlIHJvbGxlZCBiYWNrKS5cbiAqIGF2YWlsYWJsZSAgICAgTW9uZ29EQiAzLjYrIFRoZSBxdWVyeSByZXR1cm5zIGZyb20gdGhlIGluc3RhbmNlIHdpdGggbm8gZ3VhcmFudGVlIGd1YXJhbnRlZSB0aGF0IHRoZSBkYXRhIGhhcyBiZWVuIHdyaXR0ZW4gdG8gYSBtYWpvcml0eSBvZiB0aGUgcmVwbGljYSBzZXQgbWVtYmVycyAoaS5lLiBtYXkgYmUgcm9sbGVkIGJhY2spLlxuICogbWFqb3JpdHkgICAgICBNb25nb0RCIDMuMisgVGhlIHF1ZXJ5IHJldHVybnMgdGhlIGRhdGEgdGhhdCBoYXMgYmVlbiBhY2tub3dsZWRnZWQgYnkgYSBtYWpvcml0eSBvZiB0aGUgcmVwbGljYSBzZXQgbWVtYmVycy4gVGhlIGRvY3VtZW50cyByZXR1cm5lZCBieSB0aGUgcmVhZCBvcGVyYXRpb24gYXJlIGR1cmFibGUsIGV2ZW4gaW4gdGhlIGV2ZW50IG9mIGZhaWx1cmUuXG4gKiBsaW5lYXJpemFibGUgIE1vbmdvREIgMy40KyBUaGUgcXVlcnkgcmV0dXJucyBkYXRhIHRoYXQgcmVmbGVjdHMgYWxsIHN1Y2Nlc3NmdWwgbWFqb3JpdHktYWNrbm93bGVkZ2VkIHdyaXRlcyB0aGF0IGNvbXBsZXRlZCBwcmlvciB0byB0aGUgc3RhcnQgb2YgdGhlIHJlYWQgb3BlcmF0aW9uLiBUaGUgcXVlcnkgbWF5IHdhaXQgZm9yIGNvbmN1cnJlbnRseSBleGVjdXRpbmcgd3JpdGVzIHRvIHByb3BhZ2F0ZSB0byBhIG1ham9yaXR5IG9mIHJlcGxpY2Egc2V0IG1lbWJlcnMgYmVmb3JlIHJldHVybmluZyByZXN1bHRzLlxuICogc25hcHNob3QgICAgICBNb25nb0RCIDQuMCsgT25seSBhdmFpbGFibGUgZm9yIG9wZXJhdGlvbnMgd2l0aGluIG11bHRpLWRvY3VtZW50IHRyYW5zYWN0aW9ucy4gVXBvbiB0cmFuc2FjdGlvbiBjb21taXQgd2l0aCB3cml0ZSBjb25jZXJuIFwibWFqb3JpdHlcIiwgdGhlIHRyYW5zYWN0aW9uIG9wZXJhdGlvbnMgYXJlIGd1YXJhbnRlZWQgdG8gaGF2ZSByZWFkIGZyb20gYSBzbmFwc2hvdCBvZiBtYWpvcml0eS1jb21taXR0ZWQgZGF0YS5cbiAqIGBgYFxuICpcbiAqIEFsaWFzZXNcbiAqXG4gKiBgYGBcbiAqIGwgICBsb2NhbFxuICogYSAgIGF2YWlsYWJsZVxuICogbSAgIG1ham9yaXR5XG4gKiBseiAgbGluZWFyaXphYmxlXG4gKiBzICAgc25hcHNob3RcbiAqIGBgYFxuICpcbiAqIFJlYWQgbW9yZSBhYm91dCBob3cgdG8gdXNlIHJlYWQgY29uY2VybiBbaGVyZV0oaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvcmVmZXJlbmNlL3JlYWQtY29uY2Vybi8pLlxuICpcbiAqIEBtZW1iZXJPZiBRdWVyeVxuICogQG1ldGhvZCByZWFkQ29uY2VyblxuICogQHBhcmFtIHtTdHJpbmd9IGxldmVsIG9uZSBvZiB0aGUgbGlzdGVkIHJlYWQgY29uY2VybiBsZXZlbCBvciB0aGVpciBhbGlhc2VzXG4gKiBAc2VlIG1vbmdvZGIgaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvcmVmZXJlbmNlL3JlYWQtY29uY2Vybi9cbiAqIEByZXR1cm4ge1F1ZXJ5fSB0aGlzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbi8qKlxuICogR2V0cyBxdWVyeSBvcHRpb25zLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgY29uc3QgcXVlcnkgPSBuZXcgUXVlcnkoKTtcbiAqICAgICBxdWVyeS5saW1pdCgxMCk7XG4gKiAgICAgcXVlcnkuc2V0T3B0aW9ucyh7IG1heFRpbWVNUzogMTAwMCB9KTtcbiAqICAgICBxdWVyeS5nZXRPcHRpb25zKCk7IC8vIHsgbGltaXQ6IDEwLCBtYXhUaW1lTVM6IDEwMDAgfVxuICpcbiAqIEByZXR1cm4ge09iamVjdH0gdGhlIG9wdGlvbnNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUXVlcnkucHJvdG90eXBlLmdldE9wdGlvbnMgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMub3B0aW9ucztcbn07XG5cbi8qKlxuICogU2V0cyBxdWVyeSBvcHRpb25zLiBTb21lIG9wdGlvbnMgb25seSBtYWtlIHNlbnNlIGZvciBjZXJ0YWluIG9wZXJhdGlvbnMuXG4gKlxuICogIyMjIyBPcHRpb25zOlxuICpcbiAqIFRoZSBmb2xsb3dpbmcgb3B0aW9ucyBhcmUgb25seSBmb3IgYGZpbmQoKWA6XG4gKlxuICogLSBbdGFpbGFibGVdKGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvbWFudWFsL2NvcmUvdGFpbGFibGUtY3Vyc29ycy8pXG4gKiAtIFtsaW1pdF0oaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvcmVmZXJlbmNlL21ldGhvZC9jdXJzb3IubGltaXQvKVxuICogLSBbc2tpcF0oaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvcmVmZXJlbmNlL21ldGhvZC9jdXJzb3Iuc2tpcC8pXG4gKiAtIFthbGxvd0Rpc2tVc2VdKGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvbWFudWFsL3JlZmVyZW5jZS9tZXRob2QvY3Vyc29yLmFsbG93RGlza1VzZS8pXG4gKiAtIFtiYXRjaFNpemVdKGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvbWFudWFsL3JlZmVyZW5jZS9tZXRob2QvY3Vyc29yLmJhdGNoU2l6ZS8pXG4gKiAtIFtyZWFkUHJlZmVyZW5jZV0oaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvYXBwbGljYXRpb25zL3JlcGxpY2F0aW9uLyNyZWFkLXByZWZlcmVuY2UpXG4gKiAtIFtoaW50XShodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9yZWZlcmVuY2UvbWV0aG9kL2N1cnNvci5oaW50LylcbiAqIC0gW2NvbW1lbnRdKGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvbWFudWFsL3JlZmVyZW5jZS9tZXRob2QvY3Vyc29yLmNvbW1lbnQvKVxuICpcbiAqIFRoZSBmb2xsb3dpbmcgb3B0aW9ucyBhcmUgb25seSBmb3Igd3JpdGUgb3BlcmF0aW9uczogYHVwZGF0ZU9uZSgpYCwgYHVwZGF0ZU1hbnkoKWAsIGByZXBsYWNlT25lKClgLCBgZmluZE9uZUFuZFVwZGF0ZSgpYCwgYW5kIGBmaW5kQnlJZEFuZFVwZGF0ZSgpYDpcbiAqXG4gKiAtIFt1cHNlcnRdKGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvbWFudWFsL3JlZmVyZW5jZS9tZXRob2QvZGIuY29sbGVjdGlvbi51cGRhdGUvKVxuICogLSBbd3JpdGVDb25jZXJuXShodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9yZWZlcmVuY2UvbWV0aG9kL2RiLmNvbGxlY3Rpb24udXBkYXRlLylcbiAqIC0gW3RpbWVzdGFtcHNdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9ndWlkZS5odG1sI3RpbWVzdGFtcHMpOiBJZiBgdGltZXN0YW1wc2AgaXMgc2V0IGluIHRoZSBzY2hlbWEsIHNldCB0aGlzIG9wdGlvbiB0byBgZmFsc2VgIHRvIHNraXAgdGltZXN0YW1wcyBmb3IgdGhhdCBwYXJ0aWN1bGFyIHVwZGF0ZS4gSGFzIG5vIGVmZmVjdCBpZiBgdGltZXN0YW1wc2AgaXMgbm90IGVuYWJsZWQgaW4gdGhlIHNjaGVtYSBvcHRpb25zLlxuICogLSBvdmVyd3JpdGVEaXNjcmltaW5hdG9yS2V5OiBhbGxvdyBzZXR0aW5nIHRoZSBkaXNjcmltaW5hdG9yIGtleSBpbiB0aGUgdXBkYXRlLiBXaWxsIHVzZSB0aGUgY29ycmVjdCBkaXNjcmltaW5hdG9yIHNjaGVtYSBpZiB0aGUgdXBkYXRlIGNoYW5nZXMgdGhlIGRpc2NyaW1pbmF0b3Iga2V5LlxuICpcbiAqIFRoZSBmb2xsb3dpbmcgb3B0aW9ucyBhcmUgb25seSBmb3IgYGZpbmQoKWAsIGBmaW5kT25lKClgLCBgZmluZEJ5SWQoKWAsIGBmaW5kT25lQW5kVXBkYXRlKClgLCBgZmluZE9uZUFuZFJlcGxhY2UoKWAsIGBmaW5kT25lQW5kRGVsZXRlKClgLCBhbmQgYGZpbmRCeUlkQW5kVXBkYXRlKClgOlxuICpcbiAqIC0gW2xlYW5dKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvcXVlcnkuaHRtbCNRdWVyeS5wcm90b3R5cGUubGVhbigpKVxuICogLSBbcG9wdWxhdGVdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9wb3B1bGF0ZS5odG1sKVxuICogLSBbcHJvamVjdGlvbl0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2FwaS9xdWVyeS5odG1sI1F1ZXJ5LnByb3RvdHlwZS5wcm9qZWN0aW9uKCkpXG4gKiAtIHNhbml0aXplUHJvamVjdGlvblxuICogLSB1c2VCaWdJbnQ2NFxuICpcbiAqIFRoZSBmb2xsb3dpbmcgb3B0aW9ucyBhcmUgb25seSBmb3IgYWxsIG9wZXJhdGlvbnMgKipleGNlcHQqKiBgdXBkYXRlT25lKClgLCBgdXBkYXRlTWFueSgpYCwgYGRlbGV0ZU9uZSgpYCwgYW5kIGBkZWxldGVNYW55KClgOlxuICpcbiAqIC0gW21heFRpbWVNU10oaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvcmVmZXJlbmNlL29wZXJhdG9yL21ldGEvbWF4VGltZU1TLylcbiAqXG4gKiBUaGUgZm9sbG93aW5nIG9wdGlvbnMgYXJlIGZvciBgZmluZCgpYCwgYGZpbmRPbmUoKWAsIGBmaW5kT25lQW5kVXBkYXRlKClgLCBgZmluZE9uZUFuZERlbGV0ZSgpYCwgYHVwZGF0ZU9uZSgpYCwgYW5kIGBkZWxldGVPbmUoKWA6XG4gKlxuICogLSBbc29ydF0oaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvcmVmZXJlbmNlL21ldGhvZC9jdXJzb3Iuc29ydC8pXG4gKlxuICogVGhlIGZvbGxvd2luZyBvcHRpb25zIGFyZSBmb3IgYGZpbmRPbmVBbmRVcGRhdGUoKWAgYW5kIGBmaW5kT25lQW5kRGVsZXRlKClgXG4gKlxuICogLSBpbmNsdWRlUmVzdWx0TWV0YWRhdGFcbiAqXG4gKiBUaGUgZm9sbG93aW5nIG9wdGlvbnMgYXJlIGZvciBhbGwgb3BlcmF0aW9uczpcbiAqXG4gKiAtIFtzdHJpY3RdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9ndWlkZS5odG1sI3N0cmljdClcbiAqIC0gW2NvbGxhdGlvbl0oaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvcmVmZXJlbmNlL2NvbGxhdGlvbi8pXG4gKiAtIFtzZXNzaW9uXShodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9yZWZlcmVuY2Uvc2VydmVyLXNlc3Npb25zLylcbiAqIC0gW2V4cGxhaW5dKGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvbWFudWFsL3JlZmVyZW5jZS9tZXRob2QvY3Vyc29yLmV4cGxhaW4vKVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAcmV0dXJuIHtRdWVyeX0gdGhpc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5RdWVyeS5wcm90b3R5cGUuc2V0T3B0aW9ucyA9IGZ1bmN0aW9uKG9wdGlvbnMsIG92ZXJ3cml0ZSkge1xuICAvLyBvdmVyd3JpdGUgaXMgb25seSBmb3IgaW50ZXJuYWwgdXNlXG4gIGlmIChvdmVyd3JpdGUpIHtcbiAgICAvLyBlbnN1cmUgdGhhdCBfbW9uZ29vc2VPcHRpb25zICYgb3B0aW9ucyBhcmUgdHdvIGRpZmZlcmVudCBvYmplY3RzXG4gICAgdGhpcy5fbW9uZ29vc2VPcHRpb25zID0gKG9wdGlvbnMgJiYgY2xvbmUob3B0aW9ucykpIHx8IHt9O1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICBpZiAoJ3BvcHVsYXRlJyBpbiBvcHRpb25zKSB7XG4gICAgICB0aGlzLnBvcHVsYXRlKHRoaXMuX21vbmdvb3NlT3B0aW9ucyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGlmIChvcHRpb25zID09IG51bGwpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBpZiAodHlwZW9mIG9wdGlvbnMgIT09ICdvYmplY3QnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdPcHRpb25zIG11c3QgYmUgYW4gb2JqZWN0LCBnb3QgXCInICsgb3B0aW9ucyArICdcIicpO1xuICB9XG5cbiAgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMpO1xuXG4gIGlmIChBcnJheS5pc0FycmF5KG9wdGlvbnMucG9wdWxhdGUpKSB7XG4gICAgY29uc3QgcG9wdWxhdGUgPSBvcHRpb25zLnBvcHVsYXRlO1xuICAgIGRlbGV0ZSBvcHRpb25zLnBvcHVsYXRlO1xuICAgIGNvbnN0IF9udW1Qb3B1bGF0ZSA9IHBvcHVsYXRlLmxlbmd0aDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IF9udW1Qb3B1bGF0ZTsgKytpKSB7XG4gICAgICB0aGlzLnBvcHVsYXRlKHBvcHVsYXRlW2ldKTtcbiAgICB9XG4gIH1cblxuICBpZiAoJ3NldERlZmF1bHRzT25JbnNlcnQnIGluIG9wdGlvbnMpIHtcbiAgICB0aGlzLl9tb25nb29zZU9wdGlvbnMuc2V0RGVmYXVsdHNPbkluc2VydCA9IG9wdGlvbnMuc2V0RGVmYXVsdHNPbkluc2VydDtcbiAgICBkZWxldGUgb3B0aW9ucy5zZXREZWZhdWx0c09uSW5zZXJ0O1xuICB9XG4gIGlmICgnb3ZlcndyaXRlRGlzY3JpbWluYXRvcktleScgaW4gb3B0aW9ucykge1xuICAgIHRoaXMuX21vbmdvb3NlT3B0aW9ucy5vdmVyd3JpdGVEaXNjcmltaW5hdG9yS2V5ID0gb3B0aW9ucy5vdmVyd3JpdGVEaXNjcmltaW5hdG9yS2V5O1xuICAgIGRlbGV0ZSBvcHRpb25zLm92ZXJ3cml0ZURpc2NyaW1pbmF0b3JLZXk7XG4gIH1cbiAgaWYgKCdzYW5pdGl6ZVByb2plY3Rpb24nIGluIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucy5zYW5pdGl6ZVByb2plY3Rpb24gJiYgIXRoaXMuX21vbmdvb3NlT3B0aW9ucy5zYW5pdGl6ZVByb2plY3Rpb24pIHtcbiAgICAgIHNhbml0aXplUHJvamVjdGlvbih0aGlzLl9maWVsZHMpO1xuICAgIH1cblxuICAgIHRoaXMuX21vbmdvb3NlT3B0aW9ucy5zYW5pdGl6ZVByb2plY3Rpb24gPSBvcHRpb25zLnNhbml0aXplUHJvamVjdGlvbjtcbiAgICBkZWxldGUgb3B0aW9ucy5zYW5pdGl6ZVByb2plY3Rpb247XG4gIH1cbiAgaWYgKCdzYW5pdGl6ZUZpbHRlcicgaW4gb3B0aW9ucykge1xuICAgIHRoaXMuX21vbmdvb3NlT3B0aW9ucy5zYW5pdGl6ZUZpbHRlciA9IG9wdGlvbnMuc2FuaXRpemVGaWx0ZXI7XG4gICAgZGVsZXRlIG9wdGlvbnMuc2FuaXRpemVGaWx0ZXI7XG4gIH1cbiAgaWYgKCd0aW1lc3RhbXBzJyBpbiBvcHRpb25zKSB7XG4gICAgdGhpcy5fbW9uZ29vc2VPcHRpb25zLnRpbWVzdGFtcHMgPSBvcHRpb25zLnRpbWVzdGFtcHM7XG4gICAgZGVsZXRlIG9wdGlvbnMudGltZXN0YW1wcztcbiAgfVxuICBpZiAoJ2RlZmF1bHRzJyBpbiBvcHRpb25zKSB7XG4gICAgdGhpcy5fbW9uZ29vc2VPcHRpb25zLmRlZmF1bHRzID0gb3B0aW9ucy5kZWZhdWx0cztcbiAgICAvLyBkZWxldGluZyBvcHRpb25zLmRlZmF1bHRzIHdpbGwgY2F1c2UgNzI4NyB0byBmYWlsXG4gIH1cbiAgaWYgKCd0cmFuc2xhdGVBbGlhc2VzJyBpbiBvcHRpb25zKSB7XG4gICAgdGhpcy5fbW9uZ29vc2VPcHRpb25zLnRyYW5zbGF0ZUFsaWFzZXMgPSBvcHRpb25zLnRyYW5zbGF0ZUFsaWFzZXM7XG4gICAgZGVsZXRlIG9wdGlvbnMudHJhbnNsYXRlQWxpYXNlcztcbiAgfVxuXG4gIGlmIChvcHRpb25zLmxlYW4gPT0gbnVsbCAmJiB0aGlzLnNjaGVtYSAmJiAnbGVhbicgaW4gdGhpcy5zY2hlbWEub3B0aW9ucykge1xuICAgIHRoaXMuX21vbmdvb3NlT3B0aW9ucy5sZWFuID0gdGhpcy5zY2hlbWEub3B0aW9ucy5sZWFuO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBvcHRpb25zLmxpbWl0ID09PSAnc3RyaW5nJykge1xuICAgIHRyeSB7XG4gICAgICBvcHRpb25zLmxpbWl0ID0gY2FzdE51bWJlcihvcHRpb25zLmxpbWl0KTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHRocm93IG5ldyBDYXN0RXJyb3IoJ051bWJlcicsIG9wdGlvbnMubGltaXQsICdsaW1pdCcpO1xuICAgIH1cbiAgfVxuICBpZiAodHlwZW9mIG9wdGlvbnMuc2tpcCA9PT0gJ3N0cmluZycpIHtcbiAgICB0cnkge1xuICAgICAgb3B0aW9ucy5za2lwID0gY2FzdE51bWJlcihvcHRpb25zLnNraXApO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgdGhyb3cgbmV3IENhc3RFcnJvcignTnVtYmVyJywgb3B0aW9ucy5za2lwLCAnc2tpcCcpO1xuICAgIH1cbiAgfVxuXG4gIC8vIHNldCBhcmJpdHJhcnkgb3B0aW9uc1xuICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhvcHRpb25zKSkge1xuICAgIGlmIChxdWVyeU9wdGlvbk1ldGhvZHMuaGFzKGtleSkpIHtcbiAgICAgIGNvbnN0IGFyZ3MgPSBBcnJheS5pc0FycmF5KG9wdGlvbnNba2V5XSkgP1xuICAgICAgICBvcHRpb25zW2tleV0gOlxuICAgICAgICBbb3B0aW9uc1trZXldXTtcbiAgICAgIHRoaXNba2V5XS5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5vcHRpb25zW2tleV0gPSBvcHRpb25zW2tleV07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNldHMgdGhlIFtgZXhwbGFpbmAgb3B0aW9uXShodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9yZWZlcmVuY2UvbWV0aG9kL2N1cnNvci5leHBsYWluLyksXG4gKiB3aGljaCBtYWtlcyB0aGlzIHF1ZXJ5IHJldHVybiBkZXRhaWxlZCBleGVjdXRpb24gc3RhdHMgaW5zdGVhZCBvZiB0aGUgYWN0dWFsXG4gKiBxdWVyeSByZXN1bHQuIFRoaXMgbWV0aG9kIGlzIHVzZWZ1bCBmb3IgZGV0ZXJtaW5pbmcgd2hhdCBpbmRleCB5b3VyIHF1ZXJpZXNcbiAqIHVzZS5cbiAqXG4gKiBDYWxsaW5nIGBxdWVyeS5leHBsYWluKHYpYCBpcyBlcXVpdmFsZW50IHRvIGBxdWVyeS5zZXRPcHRpb25zKHsgZXhwbGFpbjogdiB9KWBcbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IHF1ZXJ5ID0gbmV3IFF1ZXJ5KCk7XG4gKiAgICAgY29uc3QgcmVzID0gYXdhaXQgcXVlcnkuZmluZCh7IGE6IDEgfSkuZXhwbGFpbigncXVlcnlQbGFubmVyJyk7XG4gKiAgICAgY29uc29sZS5sb2cocmVzKTtcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gW3ZlcmJvc2VdIFRoZSB2ZXJib3NpdHkgbW9kZS4gRWl0aGVyICdxdWVyeVBsYW5uZXInLCAnZXhlY3V0aW9uU3RhdHMnLCBvciAnYWxsUGxhbnNFeGVjdXRpb24nLiBUaGUgZGVmYXVsdCBpcyAncXVlcnlQbGFubmVyJ1xuICogQHJldHVybiB7UXVlcnl9IHRoaXNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUXVlcnkucHJvdG90eXBlLmV4cGxhaW4gPSBmdW5jdGlvbiBleHBsYWluKHZlcmJvc2UpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICB0aGlzLm9wdGlvbnMuZXhwbGFpbiA9IHRydWU7XG4gIH0gZWxzZSBpZiAodmVyYm9zZSA9PT0gZmFsc2UpIHtcbiAgICBkZWxldGUgdGhpcy5vcHRpb25zLmV4cGxhaW47XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5vcHRpb25zLmV4cGxhaW4gPSB2ZXJib3NlO1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZXRzIHRoZSBbYGFsbG93RGlza1VzZWAgb3B0aW9uXShodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9yZWZlcmVuY2UvbWV0aG9kL2N1cnNvci5hbGxvd0Rpc2tVc2UvKSxcbiAqIHdoaWNoIGFsbG93cyB0aGUgTW9uZ29EQiBzZXJ2ZXIgdG8gdXNlIG1vcmUgdGhhbiAxMDAgTUIgZm9yIHRoaXMgcXVlcnkncyBgc29ydCgpYC4gVGhpcyBvcHRpb24gY2FuXG4gKiBsZXQgeW91IHdvcmsgYXJvdW5kIGBRdWVyeUV4Y2VlZGVkTWVtb3J5TGltaXROb0Rpc2tVc2VBbGxvd2VkYCBlcnJvcnMgZnJvbSB0aGUgTW9uZ29EQiBzZXJ2ZXIuXG4gKlxuICogTm90ZSB0aGF0IHRoaXMgb3B0aW9uIHJlcXVpcmVzIE1vbmdvREIgc2VydmVyID49IDQuNC4gU2V0dGluZyB0aGlzIG9wdGlvbiBpcyBhIG5vLW9wIGZvciBNb25nb0RCIDQuMlxuICogYW5kIGVhcmxpZXIuXG4gKlxuICogQ2FsbGluZyBgcXVlcnkuYWxsb3dEaXNrVXNlKHYpYCBpcyBlcXVpdmFsZW50IHRvIGBxdWVyeS5zZXRPcHRpb25zKHsgYWxsb3dEaXNrVXNlOiB2IH0pYFxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgYXdhaXQgcXVlcnkuZmluZCgpLnNvcnQoeyBuYW1lOiAxIH0pLmFsbG93RGlza1VzZSh0cnVlKTtcbiAqICAgICAvLyBFcXVpdmFsZW50OlxuICogICAgIGF3YWl0IHF1ZXJ5LmZpbmQoKS5zb3J0KHsgbmFtZTogMSB9KS5hbGxvd0Rpc2tVc2UoKTtcbiAqXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFt2XSBFbmFibGUvZGlzYWJsZSBgYWxsb3dEaXNrVXNlYC4gSWYgY2FsbGVkIHdpdGggMCBhcmd1bWVudHMsIHNldHMgYGFsbG93RGlza1VzZTogdHJ1ZWBcbiAqIEByZXR1cm4ge1F1ZXJ5fSB0aGlzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblF1ZXJ5LnByb3RvdHlwZS5hbGxvd0Rpc2tVc2UgPSBmdW5jdGlvbih2KSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgdGhpcy5vcHRpb25zLmFsbG93RGlza1VzZSA9IHRydWU7XG4gIH0gZWxzZSBpZiAodiA9PT0gZmFsc2UpIHtcbiAgICBkZWxldGUgdGhpcy5vcHRpb25zLmFsbG93RGlza1VzZTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLm9wdGlvbnMuYWxsb3dEaXNrVXNlID0gdjtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2V0cyB0aGUgW21heFRpbWVNU10oaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvcmVmZXJlbmNlL21ldGhvZC9jdXJzb3IubWF4VGltZU1TLylcbiAqIG9wdGlvbi4gVGhpcyB3aWxsIHRlbGwgdGhlIE1vbmdvREIgc2VydmVyIHRvIGFib3J0IGlmIHRoZSBxdWVyeSBvciB3cml0ZSBvcFxuICogaGFzIGJlZW4gcnVubmluZyBmb3IgbW9yZSB0aGFuIGBtc2AgbWlsbGlzZWNvbmRzLlxuICpcbiAqIENhbGxpbmcgYHF1ZXJ5Lm1heFRpbWVNUyh2KWAgaXMgZXF1aXZhbGVudCB0byBgcXVlcnkuc2V0T3B0aW9ucyh7IG1heFRpbWVNUzogdiB9KWBcbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IHF1ZXJ5ID0gbmV3IFF1ZXJ5KCk7XG4gKiAgICAgLy8gVGhyb3dzIGFuIGVycm9yICdvcGVyYXRpb24gZXhjZWVkZWQgdGltZSBsaW1pdCcgYXMgbG9uZyBhcyB0aGVyZSdzXG4gKiAgICAgLy8gPj0gMSBkb2MgaW4gdGhlIHF1ZXJpZWQgY29sbGVjdGlvblxuICogICAgIGNvbnN0IHJlcyA9IGF3YWl0IHF1ZXJ5LmZpbmQoeyAkd2hlcmU6ICdzbGVlcCgxMDAwKSB8fCB0cnVlJyB9KS5tYXhUaW1lTVMoMTAwKTtcbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gW21zXSBUaGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kc1xuICogQHJldHVybiB7UXVlcnl9IHRoaXNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUXVlcnkucHJvdG90eXBlLm1heFRpbWVNUyA9IGZ1bmN0aW9uKG1zKSB7XG4gIHRoaXMub3B0aW9ucy5tYXhUaW1lTVMgPSBtcztcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGN1cnJlbnQgcXVlcnkgZmlsdGVyIChhbHNvIGtub3duIGFzIGNvbmRpdGlvbnMpIGFzIGEgW1BPSk9dKGh0dHBzOi8vbWFzdGVyaW5nanMuaW8vdHV0b3JpYWxzL2Z1bmRhbWVudGFscy9wb2pvKS5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IHF1ZXJ5ID0gbmV3IFF1ZXJ5KCk7XG4gKiAgICAgcXVlcnkuZmluZCh7IGE6IDEgfSkud2hlcmUoJ2InKS5ndCgyKTtcbiAqICAgICBxdWVyeS5nZXRGaWx0ZXIoKTsgLy8geyBhOiAxLCBiOiB7ICRndDogMiB9IH1cbiAqXG4gKiBAcmV0dXJuIHtPYmplY3R9IGN1cnJlbnQgcXVlcnkgZmlsdGVyXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblF1ZXJ5LnByb3RvdHlwZS5nZXRGaWx0ZXIgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX2NvbmRpdGlvbnM7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGN1cnJlbnQgcXVlcnkgZmlsdGVyLiBFcXVpdmFsZW50IHRvIGBnZXRGaWx0ZXIoKWAuXG4gKlxuICogWW91IHNob3VsZCB1c2UgYGdldEZpbHRlcigpYCBpbnN0ZWFkIG9mIGBnZXRRdWVyeSgpYCB3aGVyZSBwb3NzaWJsZS4gYGdldFF1ZXJ5KClgXG4gKiB3aWxsIGxpa2VseSBiZSBkZXByZWNhdGVkIGluIGEgZnV0dXJlIHJlbGVhc2UuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBjb25zdCBxdWVyeSA9IG5ldyBRdWVyeSgpO1xuICogICAgIHF1ZXJ5LmZpbmQoeyBhOiAxIH0pLndoZXJlKCdiJykuZ3QoMik7XG4gKiAgICAgcXVlcnkuZ2V0UXVlcnkoKTsgLy8geyBhOiAxLCBiOiB7ICRndDogMiB9IH1cbiAqXG4gKiBAcmV0dXJuIHtPYmplY3R9IGN1cnJlbnQgcXVlcnkgZmlsdGVyXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblF1ZXJ5LnByb3RvdHlwZS5nZXRRdWVyeSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fY29uZGl0aW9ucztcbn07XG5cbi8qKlxuICogU2V0cyB0aGUgcXVlcnkgY29uZGl0aW9ucyB0byB0aGUgcHJvdmlkZWQgSlNPTiBvYmplY3QuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBjb25zdCBxdWVyeSA9IG5ldyBRdWVyeSgpO1xuICogICAgIHF1ZXJ5LmZpbmQoeyBhOiAxIH0pXG4gKiAgICAgcXVlcnkuc2V0UXVlcnkoeyBhOiAyIH0pO1xuICogICAgIHF1ZXJ5LmdldFF1ZXJ5KCk7IC8vIHsgYTogMiB9XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG5ldyBxdWVyeSBjb25kaXRpb25zXG4gKiBAcmV0dXJuIHt1bmRlZmluZWR9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblF1ZXJ5LnByb3RvdHlwZS5zZXRRdWVyeSA9IGZ1bmN0aW9uKHZhbCkge1xuICB0aGlzLl9jb25kaXRpb25zID0gdmFsO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBjdXJyZW50IHVwZGF0ZSBvcGVyYXRpb25zIGFzIGEgSlNPTiBvYmplY3QuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBjb25zdCBxdWVyeSA9IG5ldyBRdWVyeSgpO1xuICogICAgIHF1ZXJ5LnVwZGF0ZU9uZSh7fSwgeyAkc2V0OiB7IGE6IDUgfSB9KTtcbiAqICAgICBxdWVyeS5nZXRVcGRhdGUoKTsgLy8geyAkc2V0OiB7IGE6IDUgfSB9XG4gKlxuICogQHJldHVybiB7T2JqZWN0fSBjdXJyZW50IHVwZGF0ZSBvcGVyYXRpb25zXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblF1ZXJ5LnByb3RvdHlwZS5nZXRVcGRhdGUgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX3VwZGF0ZTtcbn07XG5cbi8qKlxuICogU2V0cyB0aGUgY3VycmVudCB1cGRhdGUgb3BlcmF0aW9uIHRvIG5ldyB2YWx1ZS5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IHF1ZXJ5ID0gbmV3IFF1ZXJ5KCk7XG4gKiAgICAgcXVlcnkudXBkYXRlT25lKHt9LCB7ICRzZXQ6IHsgYTogNSB9IH0pO1xuICogICAgIHF1ZXJ5LnNldFVwZGF0ZSh7ICRzZXQ6IHsgYjogNiB9IH0pO1xuICogICAgIHF1ZXJ5LmdldFVwZGF0ZSgpOyAvLyB7ICRzZXQ6IHsgYjogNiB9IH1cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gbmV3IHVwZGF0ZSBvcGVyYXRpb25cbiAqIEByZXR1cm4ge3VuZGVmaW5lZH1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUXVlcnkucHJvdG90eXBlLnNldFVwZGF0ZSA9IGZ1bmN0aW9uKHZhbCkge1xuICB0aGlzLl91cGRhdGUgPSB2YWw7XG59O1xuXG4vKipcbiAqIFJldHVybnMgZmllbGRzIHNlbGVjdGlvbiBmb3IgdGhpcyBxdWVyeS5cbiAqXG4gKiBAbWV0aG9kIF9maWVsZHNGb3JFeGVjXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKiBAYXBpIHByaXZhdGVcbiAqIEBtZW1iZXJPZiBRdWVyeVxuICovXG5cblF1ZXJ5LnByb3RvdHlwZS5fZmllbGRzRm9yRXhlYyA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5fZmllbGRzID09IG51bGwpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBpZiAoT2JqZWN0LmtleXModGhpcy5fZmllbGRzKS5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4gY2xvbmUodGhpcy5fZmllbGRzKTtcbn07XG5cblxuLyoqXG4gKiBSZXR1cm4gYW4gdXBkYXRlIGRvY3VtZW50IHdpdGggY29ycmVjdGVkIGAkc2V0YCBvcGVyYXRpb25zLlxuICpcbiAqIEBtZXRob2QgX3VwZGF0ZUZvckV4ZWNcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqIEBhcGkgcHJpdmF0ZVxuICogQG1lbWJlck9mIFF1ZXJ5XG4gKi9cblxuUXVlcnkucHJvdG90eXBlLl91cGRhdGVGb3JFeGVjID0gZnVuY3Rpb24oKSB7XG4gIGNvbnN0IHVwZGF0ZSA9IGNsb25lKHRoaXMuX3VwZGF0ZSwge1xuICAgIHRyYW5zZm9ybTogZmFsc2UsXG4gICAgZGVwb3B1bGF0ZTogdHJ1ZVxuICB9KTtcbiAgY29uc3Qgb3BzID0gT2JqZWN0LmtleXModXBkYXRlKTtcbiAgbGV0IGkgPSBvcHMubGVuZ3RoO1xuICBjb25zdCByZXQgPSB7fTtcblxuICB3aGlsZSAoaS0tKSB7XG4gICAgY29uc3Qgb3AgPSBvcHNbaV07XG5cbiAgICBpZiAoJyQnICE9PSBvcFswXSkge1xuICAgICAgLy8gZml4IHVwICRzZXQgc3VnYXJcbiAgICAgIGlmICghcmV0LiRzZXQpIHtcbiAgICAgICAgaWYgKHVwZGF0ZS4kc2V0KSB7XG4gICAgICAgICAgcmV0LiRzZXQgPSB1cGRhdGUuJHNldDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXQuJHNldCA9IHt9O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXQuJHNldFtvcF0gPSB1cGRhdGVbb3BdO1xuICAgICAgb3BzLnNwbGljZShpLCAxKTtcbiAgICAgIGlmICghfm9wcy5pbmRleE9mKCckc2V0JykpIG9wcy5wdXNoKCckc2V0Jyk7XG4gICAgfSBlbHNlIGlmICgnJHNldCcgPT09IG9wKSB7XG4gICAgICBpZiAoIXJldC4kc2V0KSB7XG4gICAgICAgIHJldFtvcF0gPSB1cGRhdGVbb3BdO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZXRbb3BdID0gdXBkYXRlW29wXTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmV0O1xufTtcblxuLyoqXG4gKiBNYWtlcyBzdXJlIF9wYXRoIGlzIHNldC5cbiAqXG4gKiBUaGlzIG1ldGhvZCBpcyBpbmhlcml0ZWQgYnkgYG1xdWVyeWBcbiAqXG4gKiBAbWV0aG9kIF9lbnN1cmVQYXRoXG4gKiBAcGFyYW0ge1N0cmluZ30gbWV0aG9kXG4gKiBAYXBpIHByaXZhdGVcbiAqIEBtZW1iZXJPZiBRdWVyeVxuICovXG5cbi8qKlxuICogRGV0ZXJtaW5lcyBpZiBgY29uZHNgIGNhbiBiZSBtZXJnZWQgdXNpbmcgYG1xdWVyeSgpLm1lcmdlKClgXG4gKlxuICogQG1ldGhvZCBjYW5NZXJnZVxuICogQG1lbWJlck9mIFF1ZXJ5XG4gKiBAaW5zdGFuY2VcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb25kc1xuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbi8qKlxuICogUmV0dXJucyBkZWZhdWx0IG9wdGlvbnMgZm9yIHRoaXMgcXVlcnkuXG4gKlxuICogQHBhcmFtIHtNb2RlbH0gbW9kZWxcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblF1ZXJ5LnByb3RvdHlwZS5fb3B0aW9uc0ZvckV4ZWMgPSBmdW5jdGlvbihtb2RlbCkge1xuICBjb25zdCBvcHRpb25zID0gY2xvbmUodGhpcy5vcHRpb25zKTtcbiAgZGVsZXRlIG9wdGlvbnMucG9wdWxhdGU7XG4gIG1vZGVsID0gbW9kZWwgfHwgdGhpcy5tb2RlbDtcblxuICBpZiAoIW1vZGVsKSB7XG4gICAgcmV0dXJuIG9wdGlvbnM7XG4gIH1cbiAgLy8gQXBwbHkgc2NoZW1hLWxldmVsIGB3cml0ZUNvbmNlcm5gIG9wdGlvblxuICBhcHBseVdyaXRlQ29uY2Vybihtb2RlbC5zY2hlbWEsIG9wdGlvbnMpO1xuXG4gIGNvbnN0IHJlYWRQcmVmZXJlbmNlID0gbW9kZWwgJiZcbiAgbW9kZWwuc2NoZW1hICYmXG4gIG1vZGVsLnNjaGVtYS5vcHRpb25zICYmXG4gIG1vZGVsLnNjaGVtYS5vcHRpb25zLnJlYWQ7XG4gIGlmICghKCdyZWFkUHJlZmVyZW5jZScgaW4gb3B0aW9ucykgJiYgcmVhZFByZWZlcmVuY2UpIHtcbiAgICBvcHRpb25zLnJlYWRQcmVmZXJlbmNlID0gcmVhZFByZWZlcmVuY2U7XG4gIH1cblxuICBpZiAob3B0aW9ucy51cHNlcnQgIT09IHZvaWQgMCkge1xuICAgIG9wdGlvbnMudXBzZXJ0ID0gISFvcHRpb25zLnVwc2VydDtcbiAgfVxuICBpZiAob3B0aW9ucy53cml0ZUNvbmNlcm4pIHtcbiAgICBpZiAob3B0aW9ucy5qKSB7XG4gICAgICBvcHRpb25zLndyaXRlQ29uY2Vybi5qID0gb3B0aW9ucy5qO1xuICAgICAgZGVsZXRlIG9wdGlvbnMuajtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMudykge1xuICAgICAgb3B0aW9ucy53cml0ZUNvbmNlcm4udyA9IG9wdGlvbnMudztcbiAgICAgIGRlbGV0ZSBvcHRpb25zLnc7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLnd0aW1lb3V0KSB7XG4gICAgICBvcHRpb25zLndyaXRlQ29uY2Vybi53dGltZW91dCA9IG9wdGlvbnMud3RpbWVvdXQ7XG4gICAgICBkZWxldGUgb3B0aW9ucy53dGltZW91dDtcbiAgICB9XG4gIH1cblxuICB0aGlzLl9hcHBseVBhdGhzKCk7XG4gIGlmICh0aGlzLl9maWVsZHMgIT0gbnVsbCkge1xuICAgIHRoaXMuX2ZpZWxkcyA9IHRoaXMuX2Nhc3RGaWVsZHModGhpcy5fZmllbGRzKTtcbiAgICBjb25zdCBwcm9qZWN0aW9uID0gdGhpcy5fZmllbGRzRm9yRXhlYygpO1xuICAgIGlmIChwcm9qZWN0aW9uICE9IG51bGwpIHtcbiAgICAgIG9wdGlvbnMucHJvamVjdGlvbiA9IHByb2plY3Rpb247XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG9wdGlvbnM7XG59O1xuXG4vKipcbiAqIFNldHMgdGhlIGxlYW4gb3B0aW9uLlxuICpcbiAqIERvY3VtZW50cyByZXR1cm5lZCBmcm9tIHF1ZXJpZXMgd2l0aCB0aGUgYGxlYW5gIG9wdGlvbiBlbmFibGVkIGFyZSBwbGFpblxuICogamF2YXNjcmlwdCBvYmplY3RzLCBub3QgW01vbmdvb3NlIERvY3VtZW50c10oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2FwaS9kb2N1bWVudC5odG1sKS4gVGhleSBoYXZlIG5vXG4gKiBgc2F2ZWAgbWV0aG9kLCBnZXR0ZXJzL3NldHRlcnMsIHZpcnR1YWxzLCBvciBvdGhlciBNb25nb29zZSBmZWF0dXJlcy5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIG5ldyBRdWVyeSgpLmxlYW4oKSAvLyB0cnVlXG4gKiAgICAgbmV3IFF1ZXJ5KCkubGVhbih0cnVlKVxuICogICAgIG5ldyBRdWVyeSgpLmxlYW4oZmFsc2UpXG4gKlxuICogICAgIGNvbnN0IGRvY3MgPSBhd2FpdCBNb2RlbC5maW5kKCkubGVhbigpO1xuICogICAgIGRvY3NbMF0gaW5zdGFuY2VvZiBtb25nb29zZS5Eb2N1bWVudDsgLy8gZmFsc2VcbiAqXG4gKiBbTGVhbiBpcyBncmVhdCBmb3IgaGlnaC1wZXJmb3JtYW5jZSwgcmVhZC1vbmx5IGNhc2VzXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvdHV0b3JpYWxzL2xlYW4uaHRtbCksXG4gKiBlc3BlY2lhbGx5IHdoZW4gY29tYmluZWRcbiAqIHdpdGggW2N1cnNvcnNdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9xdWVyaWVzLmh0bWwjc3RyZWFtaW5nKS5cbiAqXG4gKiBJZiB5b3UgbmVlZCB2aXJ0dWFscywgZ2V0dGVycy9zZXR0ZXJzLCBvciBkZWZhdWx0cyB3aXRoIGBsZWFuKClgLCB5b3UgbmVlZFxuICogdG8gdXNlIGEgcGx1Z2luLiBTZWU6XG4gKlxuICogLSBbbW9uZ29vc2UtbGVhbi12aXJ0dWFsc10oaHR0cHM6Ly9wbHVnaW5zLm1vbmdvb3NlanMuaW8vcGx1Z2lucy9sZWFuLXZpcnR1YWxzKVxuICogLSBbbW9uZ29vc2UtbGVhbi1nZXR0ZXJzXShodHRwczovL3BsdWdpbnMubW9uZ29vc2Vqcy5pby9wbHVnaW5zL2xlYW4tZ2V0dGVycylcbiAqIC0gW21vbmdvb3NlLWxlYW4tZGVmYXVsdHNdKGh0dHBzOi8vd3d3Lm5wbWpzLmNvbS9wYWNrYWdlL21vbmdvb3NlLWxlYW4tZGVmYXVsdHMpXG4gKlxuICogQHBhcmFtIHtCb29sZWFufE9iamVjdH0gYm9vbCBkZWZhdWx0cyB0byB0cnVlXG4gKiBAcmV0dXJuIHtRdWVyeX0gdGhpc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5RdWVyeS5wcm90b3R5cGUubGVhbiA9IGZ1bmN0aW9uKHYpIHtcbiAgdGhpcy5fbW9uZ29vc2VPcHRpb25zLmxlYW4gPSBhcmd1bWVudHMubGVuZ3RoID8gdiA6IHRydWU7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBBZGRzIGEgYCRzZXRgIHRvIHRoaXMgcXVlcnkncyB1cGRhdGUgd2l0aG91dCBjaGFuZ2luZyB0aGUgb3BlcmF0aW9uLlxuICogVGhpcyBpcyB1c2VmdWwgZm9yIHF1ZXJ5IG1pZGRsZXdhcmUgc28geW91IGNhbiBhZGQgYW4gdXBkYXRlIHJlZ2FyZGxlc3NcbiAqIG9mIHdoZXRoZXIgeW91IHVzZSBgdXBkYXRlT25lKClgLCBgdXBkYXRlTWFueSgpYCwgYGZpbmRPbmVBbmRVcGRhdGUoKWAsIGV0Yy5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIC8vIFVwZGF0ZXMgYHsgJHNldDogeyB1cGRhdGVkQXQ6IG5ldyBEYXRlKCkgfSB9YFxuICogICAgIG5ldyBRdWVyeSgpLnVwZGF0ZU9uZSh7fSwge30pLnNldCgndXBkYXRlZEF0JywgbmV3IERhdGUoKSk7XG4gKiAgICAgbmV3IFF1ZXJ5KCkudXBkYXRlTWFueSh7fSwge30pLnNldCh7IHVwZGF0ZWRBdDogbmV3IERhdGUoKSB9KTtcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ3xPYmplY3R9IHBhdGggcGF0aCBvciBvYmplY3Qgb2Yga2V5L3ZhbHVlIHBhaXJzIHRvIHNldFxuICogQHBhcmFtIHtBbnl9IFt2YWxdIHRoZSB2YWx1ZSB0byBzZXRcbiAqIEByZXR1cm4ge1F1ZXJ5fSB0aGlzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblF1ZXJ5LnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbihwYXRoLCB2YWwpIHtcbiAgaWYgKHR5cGVvZiBwYXRoID09PSAnb2JqZWN0Jykge1xuICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhwYXRoKTtcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBrZXlzKSB7XG4gICAgICB0aGlzLnNldChrZXksIHBhdGhba2V5XSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgdGhpcy5fdXBkYXRlID0gdGhpcy5fdXBkYXRlIHx8IHt9O1xuICBpZiAocGF0aCBpbiB0aGlzLl91cGRhdGUpIHtcbiAgICBkZWxldGUgdGhpcy5fdXBkYXRlW3BhdGhdO1xuICB9XG4gIHRoaXMuX3VwZGF0ZS4kc2V0ID0gdGhpcy5fdXBkYXRlLiRzZXQgfHwge307XG4gIHRoaXMuX3VwZGF0ZS4kc2V0W3BhdGhdID0gdmFsO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogRm9yIHVwZGF0ZSBvcGVyYXRpb25zLCByZXR1cm5zIHRoZSB2YWx1ZSBvZiBhIHBhdGggaW4gdGhlIHVwZGF0ZSdzIGAkc2V0YC5cbiAqIFVzZWZ1bCBmb3Igd3JpdGluZyBnZXR0ZXJzL3NldHRlcnMgdGhhdCBjYW4gd29yayB3aXRoIGJvdGggdXBkYXRlIG9wZXJhdGlvbnNcbiAqIGFuZCBgc2F2ZSgpYC5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IHF1ZXJ5ID0gTW9kZWwudXBkYXRlT25lKHt9LCB7ICRzZXQ6IHsgbmFtZTogJ0plYW4tTHVjIFBpY2FyZCcgfSB9KTtcbiAqICAgICBxdWVyeS5nZXQoJ25hbWUnKTsgLy8gJ0plYW4tTHVjIFBpY2FyZCdcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ3xPYmplY3R9IHBhdGggcGF0aCBvciBvYmplY3Qgb2Yga2V5L3ZhbHVlIHBhaXJzIHRvIGdldFxuICogQHJldHVybiB7UXVlcnl9IHRoaXNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUXVlcnkucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIGdldChwYXRoKSB7XG4gIGNvbnN0IHVwZGF0ZSA9IHRoaXMuX3VwZGF0ZTtcbiAgaWYgKHVwZGF0ZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxuICBjb25zdCAkc2V0ID0gdXBkYXRlLiRzZXQ7XG4gIGlmICgkc2V0ID09IG51bGwpIHtcbiAgICByZXR1cm4gdXBkYXRlW3BhdGhdO1xuICB9XG5cbiAgaWYgKHV0aWxzLmhhc1VzZXJEZWZpbmVkUHJvcGVydHkodXBkYXRlLCBwYXRoKSkge1xuICAgIHJldHVybiB1cGRhdGVbcGF0aF07XG4gIH1cbiAgaWYgKHV0aWxzLmhhc1VzZXJEZWZpbmVkUHJvcGVydHkoJHNldCwgcGF0aCkpIHtcbiAgICByZXR1cm4gJHNldFtwYXRoXTtcbiAgfVxuXG4gIHJldHVybiB2b2lkIDA7XG59O1xuXG4vKipcbiAqIEdldHMvc2V0cyB0aGUgZXJyb3IgZmxhZyBvbiB0aGlzIHF1ZXJ5LiBJZiB0aGlzIGZsYWcgaXMgbm90IG51bGwgb3JcbiAqIHVuZGVmaW5lZCwgdGhlIGBleGVjKClgIHByb21pc2Ugd2lsbCByZWplY3Qgd2l0aG91dCBleGVjdXRpbmcuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBRdWVyeSgpLmVycm9yKCk7IC8vIEdldCBjdXJyZW50IGVycm9yIHZhbHVlXG4gKiAgICAgUXVlcnkoKS5lcnJvcihudWxsKTsgLy8gVW5zZXQgdGhlIGN1cnJlbnQgZXJyb3JcbiAqICAgICBRdWVyeSgpLmVycm9yKG5ldyBFcnJvcigndGVzdCcpKTsgLy8gYGV4ZWMoKWAgd2lsbCByZXNvbHZlIHdpdGggdGVzdFxuICogICAgIFNjaGVtYS5wcmUoJ2ZpbmQnLCBmdW5jdGlvbigpIHtcbiAqICAgICAgIGlmICghdGhpcy5nZXRRdWVyeSgpLnVzZXJJZCkge1xuICogICAgICAgICB0aGlzLmVycm9yKG5ldyBFcnJvcignTm90IGFsbG93ZWQgdG8gcXVlcnkgd2l0aG91dCBzZXR0aW5nIHVzZXJJZCcpKTtcbiAqICAgICAgIH1cbiAqICAgICB9KTtcbiAqXG4gKiBOb3RlIHRoYXQgcXVlcnkgY2FzdGluZyBydW5zICoqYWZ0ZXIqKiBob29rcywgc28gY2FzdCBlcnJvcnMgd2lsbCBvdmVycmlkZVxuICogY3VzdG9tIGVycm9ycy5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IFRlc3RTY2hlbWEgPSBuZXcgU2NoZW1hKHsgbnVtOiBOdW1iZXIgfSk7XG4gKiAgICAgY29uc3QgVGVzdE1vZGVsID0gZGIubW9kZWwoJ1Rlc3QnLCBUZXN0U2NoZW1hKTtcbiAqICAgICBUZXN0TW9kZWwuZmluZCh7IG51bTogJ25vdCBhIG51bWJlcicgfSkuZXJyb3IobmV3IEVycm9yKCd3b29wcycpKS5leGVjKGZ1bmN0aW9uKGVycm9yKSB7XG4gKiAgICAgICAvLyBgZXJyb3JgIHdpbGwgYmUgYSBjYXN0IGVycm9yIGJlY2F1c2UgYG51bWAgZmFpbGVkIHRvIGNhc3RcbiAqICAgICB9KTtcbiAqXG4gKiBAcGFyYW0ge0Vycm9yfG51bGx9IGVyciBpZiBzZXQsIGBleGVjKClgIHdpbGwgZmFpbCBmYXN0IGJlZm9yZSBzZW5kaW5nIHRoZSBxdWVyeSB0byBNb25nb0RCXG4gKiBAcmV0dXJuIHtRdWVyeX0gdGhpc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5RdWVyeS5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbiBlcnJvcihlcnIpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gdGhpcy5fZXJyb3I7XG4gIH1cblxuICB0aGlzLl9lcnJvciA9IGVycjtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIGlnbm9yZVxuICogQG1ldGhvZCBfdW5zZXRDYXN0RXJyb3JcbiAqIEBpbnN0YW5jZVxuICogQG1lbWJlck9mIFF1ZXJ5XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5RdWVyeS5wcm90b3R5cGUuX3Vuc2V0Q2FzdEVycm9yID0gZnVuY3Rpb24gX3Vuc2V0Q2FzdEVycm9yKCkge1xuICBpZiAodGhpcy5fZXJyb3IgIT0gbnVsbCAmJiAhKHRoaXMuX2Vycm9yIGluc3RhbmNlb2YgQ2FzdEVycm9yKSkge1xuICAgIHJldHVybjtcbiAgfVxuICByZXR1cm4gdGhpcy5lcnJvcihudWxsKTtcbn07XG5cbi8qKlxuICogR2V0dGVyL3NldHRlciBhcm91bmQgdGhlIGN1cnJlbnQgbW9uZ29vc2Utc3BlY2lmaWMgb3B0aW9ucyBmb3IgdGhpcyBxdWVyeVxuICogQmVsb3cgYXJlIHRoZSBjdXJyZW50IE1vbmdvb3NlLXNwZWNpZmljIG9wdGlvbnMuXG4gKlxuICogLSBgcG9wdWxhdGVgOiBhbiBhcnJheSByZXByZXNlbnRpbmcgd2hhdCBwYXRocyB3aWxsIGJlIHBvcHVsYXRlZC4gU2hvdWxkIGhhdmUgb25lIGVudHJ5IGZvciBlYWNoIGNhbGwgdG8gW2BRdWVyeS5wcm90b3R5cGUucG9wdWxhdGUoKWBdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvcXVlcnkuaHRtbCNRdWVyeS5wcm90b3R5cGUucG9wdWxhdGUoKSlcbiAqIC0gYGxlYW5gOiBpZiB0cnV0aHksIE1vbmdvb3NlIHdpbGwgbm90IFtoeWRyYXRlXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvYXBpL21vZGVsLmh0bWwjTW9kZWwuaHlkcmF0ZSgpKSBhbnkgZG9jdW1lbnRzIHRoYXQgYXJlIHJldHVybmVkIGZyb20gdGhpcyBxdWVyeS4gU2VlIFtgUXVlcnkucHJvdG90eXBlLmxlYW4oKWBdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvcXVlcnkuaHRtbCNRdWVyeS5wcm90b3R5cGUubGVhbigpKSBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiAqIC0gYHN0cmljdGA6IGNvbnRyb2xzIGhvdyBNb25nb29zZSBoYW5kbGVzIGtleXMgdGhhdCBhcmVuJ3QgaW4gdGhlIHNjaGVtYSBmb3IgdXBkYXRlcy4gVGhpcyBvcHRpb24gaXMgYHRydWVgIGJ5IGRlZmF1bHQsIHdoaWNoIG1lYW5zIE1vbmdvb3NlIHdpbGwgc2lsZW50bHkgc3RyaXAgYW55IHBhdGhzIGluIHRoZSB1cGRhdGUgdGhhdCBhcmVuJ3QgaW4gdGhlIHNjaGVtYS4gU2VlIHRoZSBbYHN0cmljdGAgbW9kZSBkb2NzXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvZ3VpZGUuaHRtbCNzdHJpY3QpIGZvciBtb3JlIGluZm9ybWF0aW9uLlxuICogLSBgc3RyaWN0UXVlcnlgOiBjb250cm9scyBob3cgTW9uZ29vc2UgaGFuZGxlcyBrZXlzIHRoYXQgYXJlbid0IGluIHRoZSBzY2hlbWEgZm9yIHRoZSBxdWVyeSBgZmlsdGVyYC4gVGhpcyBvcHRpb24gaXMgYGZhbHNlYCBieSBkZWZhdWx0LCB3aGljaCBtZWFucyBNb25nb29zZSB3aWxsIGFsbG93IGBNb2RlbC5maW5kKHsgZm9vOiAnYmFyJyB9KWAgZXZlbiBpZiBgZm9vYCBpcyBub3QgaW4gdGhlIHNjaGVtYS4gU2VlIHRoZSBbYHN0cmljdFF1ZXJ5YCBkb2NzXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvZ3VpZGUuaHRtbCNzdHJpY3RRdWVyeSkgZm9yIG1vcmUgaW5mb3JtYXRpb24uXG4gKiAtIGBuZWFyU3BoZXJlYDogdXNlIGAkbmVhclNwaGVyZWAgaW5zdGVhZCBvZiBgbmVhcigpYC4gU2VlIHRoZSBbYFF1ZXJ5LnByb3RvdHlwZS5uZWFyU3BoZXJlKClgIGRvY3NdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvcXVlcnkuaHRtbCNRdWVyeS5wcm90b3R5cGUubmVhclNwaGVyZSgpKVxuICpcbiAqIE1vbmdvb3NlIG1haW50YWlucyBhIHNlcGFyYXRlIG9iamVjdCBmb3IgaW50ZXJuYWwgb3B0aW9ucyBiZWNhdXNlXG4gKiBNb25nb29zZSBzZW5kcyBgUXVlcnkucHJvdG90eXBlLm9wdGlvbnNgIHRvIHRoZSBNb25nb0RCIHNlcnZlciwgYW5kIHRoZVxuICogYWJvdmUgb3B0aW9ucyBhcmUgbm90IHJlbGV2YW50IGZvciB0aGUgTW9uZ29EQiBzZXJ2ZXIuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgaWYgc3BlY2lmaWVkLCBvdmVyd3JpdGVzIHRoZSBjdXJyZW50IG9wdGlvbnNcbiAqIEByZXR1cm4ge09iamVjdH0gdGhlIG9wdGlvbnNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUXVlcnkucHJvdG90eXBlLm1vbmdvb3NlT3B0aW9ucyA9IGZ1bmN0aW9uKHYpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAwKSB7XG4gICAgdGhpcy5fbW9uZ29vc2VPcHRpb25zID0gdjtcbiAgfVxuICByZXR1cm4gdGhpcy5fbW9uZ29vc2VPcHRpb25zO1xufTtcblxuLyoqXG4gKiBpZ25vcmVcbiAqIEBtZXRob2QgX2Nhc3RDb25kaXRpb25zXG4gKiBAbWVtYmVyT2YgUXVlcnlcbiAqIEBhcGkgcHJpdmF0ZVxuICogQGluc3RhbmNlXG4gKi9cblxuUXVlcnkucHJvdG90eXBlLl9jYXN0Q29uZGl0aW9ucyA9IGZ1bmN0aW9uKCkge1xuICBsZXQgc2FuaXRpemVGaWx0ZXJPcHQgPSB1bmRlZmluZWQ7XG4gIGlmICh0aGlzLm1vZGVsICE9IG51bGwgJiYgdXRpbHMuaGFzVXNlckRlZmluZWRQcm9wZXJ0eSh0aGlzLm1vZGVsLmRiLm9wdGlvbnMsICdzYW5pdGl6ZUZpbHRlcicpKSB7XG4gICAgc2FuaXRpemVGaWx0ZXJPcHQgPSB0aGlzLm1vZGVsLmRiLm9wdGlvbnMuc2FuaXRpemVGaWx0ZXI7XG4gIH0gZWxzZSBpZiAodGhpcy5tb2RlbCAhPSBudWxsICYmIHV0aWxzLmhhc1VzZXJEZWZpbmVkUHJvcGVydHkodGhpcy5tb2RlbC5iYXNlLm9wdGlvbnMsICdzYW5pdGl6ZUZpbHRlcicpKSB7XG4gICAgc2FuaXRpemVGaWx0ZXJPcHQgPSB0aGlzLm1vZGVsLmJhc2Uub3B0aW9ucy5zYW5pdGl6ZUZpbHRlcjtcbiAgfSBlbHNlIHtcbiAgICBzYW5pdGl6ZUZpbHRlck9wdCA9IHRoaXMuX21vbmdvb3NlT3B0aW9ucy5zYW5pdGl6ZUZpbHRlcjtcbiAgfVxuXG4gIGlmIChzYW5pdGl6ZUZpbHRlck9wdCkge1xuICAgIHNhbml0aXplRmlsdGVyKHRoaXMuX2NvbmRpdGlvbnMpO1xuICB9XG5cbiAgdHJ5IHtcbiAgICB0aGlzLmNhc3QodGhpcy5tb2RlbCk7XG4gICAgdGhpcy5fdW5zZXRDYXN0RXJyb3IoKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgdGhpcy5lcnJvcihlcnIpO1xuICB9XG59O1xuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cbmZ1bmN0aW9uIF9jYXN0QXJyYXlGaWx0ZXJzKHF1ZXJ5KSB7XG4gIHRyeSB7XG4gICAgY2FzdEFycmF5RmlsdGVycyhxdWVyeSk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHF1ZXJ5LmVycm9yKGVycik7XG4gIH1cbn1cblxuLyoqXG4gKiBFeGVjdXRlIGEgYGZpbmQoKWBcbiAqXG4gKiBAcmV0dXJuIHtRdWVyeX0gdGhpc1xuICogQGFwaSBwcml2YXRlXG4gKi9cblF1ZXJ5LnByb3RvdHlwZS5fZmluZCA9IGFzeW5jIGZ1bmN0aW9uIF9maW5kKCkge1xuICB0aGlzLl9jYXN0Q29uZGl0aW9ucygpO1xuXG4gIGlmICh0aGlzLmVycm9yKCkgIT0gbnVsbCkge1xuICAgIHRocm93IHRoaXMuZXJyb3IoKTtcbiAgfVxuXG4gIGNvbnN0IG1vbmdvb3NlT3B0aW9ucyA9IHRoaXMuX21vbmdvb3NlT3B0aW9ucztcbiAgY29uc3QgX3RoaXMgPSB0aGlzO1xuICBjb25zdCB1c2VyUHJvdmlkZWRGaWVsZHMgPSBfdGhpcy5fdXNlclByb3ZpZGVkRmllbGRzIHx8IHt9O1xuXG4gIGFwcGx5R2xvYmFsTWF4VGltZU1TKHRoaXMub3B0aW9ucywgdGhpcy5tb2RlbC5kYi5vcHRpb25zLCB0aGlzLm1vZGVsLmJhc2Uub3B0aW9ucyk7XG4gIGFwcGx5R2xvYmFsRGlza1VzZSh0aGlzLm9wdGlvbnMsIHRoaXMubW9kZWwuZGIub3B0aW9ucywgdGhpcy5tb2RlbC5iYXNlLm9wdGlvbnMpO1xuXG4gIC8vIFNlcGFyYXRlIG9wdGlvbnMgdG8gcGFzcyBkb3duIHRvIGBjb21wbGV0ZU1hbnkoKWAgaW4gY2FzZSB3ZSBuZWVkIHRvXG4gIC8vIHNldCBhIHNlc3Npb24gb24gdGhlIGRvY3VtZW50XG4gIGNvbnN0IGNvbXBsZXRlTWFueU9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCB7XG4gICAgc2Vzc2lvbjogdGhpcyAmJiB0aGlzLm9wdGlvbnMgJiYgdGhpcy5vcHRpb25zLnNlc3Npb24gfHwgbnVsbCxcbiAgICBsZWFuOiBtb25nb29zZU9wdGlvbnMubGVhbiB8fCBudWxsXG4gIH0pO1xuXG4gIGNvbnN0IG9wdGlvbnMgPSB0aGlzLl9vcHRpb25zRm9yRXhlYygpO1xuXG4gIHRoaXMuX2FwcGx5VHJhbnNsYXRlQWxpYXNlcyhvcHRpb25zKTtcblxuICBjb25zdCBmaWx0ZXIgPSB0aGlzLl9jb25kaXRpb25zO1xuICBjb25zdCBmaWVsZHMgPSBvcHRpb25zLnByb2plY3Rpb247XG5cbiAgY29uc3QgY3Vyc29yID0gYXdhaXQgdGhpcy5tb25nb29zZUNvbGxlY3Rpb24uZmluZChmaWx0ZXIsIG9wdGlvbnMpO1xuICBpZiAob3B0aW9ucy5leHBsYWluKSB7XG4gICAgcmV0dXJuIGN1cnNvci5leHBsYWluKCk7XG4gIH1cblxuICBsZXQgZG9jcyA9IGF3YWl0IGN1cnNvci50b0FycmF5KCk7XG4gIGlmIChkb2NzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBkb2NzO1xuICB9XG5cbiAgaWYgKCFtb25nb29zZU9wdGlvbnMucG9wdWxhdGUpIHtcbiAgICBjb25zdCB2ZXJzaW9uS2V5ID0gX3RoaXMuc2NoZW1hLm9wdGlvbnMudmVyc2lvbktleTtcbiAgICBpZiAobW9uZ29vc2VPcHRpb25zLmxlYW4gJiYgbW9uZ29vc2VPcHRpb25zLmxlYW4udmVyc2lvbktleSA9PT0gZmFsc2UgJiYgdmVyc2lvbktleSkge1xuICAgICAgZG9jcy5mb3JFYWNoKChkb2MpID0+IHtcbiAgICAgICAgaWYgKHZlcnNpb25LZXkgaW4gZG9jKSB7XG4gICAgICAgICAgZGVsZXRlIGRvY1t2ZXJzaW9uS2V5XTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBtb25nb29zZU9wdGlvbnMubGVhbiA/XG4gICAgICBfY29tcGxldGVNYW55TGVhbihfdGhpcy5tb2RlbC5zY2hlbWEsIGRvY3MsIG51bGwsIGNvbXBsZXRlTWFueU9wdGlvbnMpIDpcbiAgICAgIF90aGlzLl9jb21wbGV0ZU1hbnkoZG9jcywgZmllbGRzLCB1c2VyUHJvdmlkZWRGaWVsZHMsIGNvbXBsZXRlTWFueU9wdGlvbnMpO1xuICB9XG4gIGNvbnN0IHBvcCA9IGhlbHBlcnMucHJlcGFyZVBvcHVsYXRpb25PcHRpb25zTVEoX3RoaXMsIG1vbmdvb3NlT3B0aW9ucyk7XG5cbiAgaWYgKG1vbmdvb3NlT3B0aW9ucy5sZWFuKSB7XG4gICAgcmV0dXJuIF90aGlzLm1vZGVsLnBvcHVsYXRlKGRvY3MsIHBvcCk7XG4gIH1cblxuICBkb2NzID0gYXdhaXQgX3RoaXMuX2NvbXBsZXRlTWFueShkb2NzLCBmaWVsZHMsIHVzZXJQcm92aWRlZEZpZWxkcywgY29tcGxldGVNYW55T3B0aW9ucyk7XG4gIGF3YWl0IHRoaXMubW9kZWwucG9wdWxhdGUoZG9jcywgcG9wKTtcblxuICByZXR1cm4gZG9jcztcbn07XG5cbi8qKlxuICogRmluZCBhbGwgZG9jdW1lbnRzIHRoYXQgbWF0Y2ggYHNlbGVjdG9yYC4gVGhlIHJlc3VsdCB3aWxsIGJlIGFuIGFycmF5IG9mIGRvY3VtZW50cy5cbiAqXG4gKiBJZiB0aGVyZSBhcmUgdG9vIG1hbnkgZG9jdW1lbnRzIGluIHRoZSByZXN1bHQgdG8gZml0IGluIG1lbW9yeSwgdXNlXG4gKiBbYFF1ZXJ5LnByb3RvdHlwZS5jdXJzb3IoKWBdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvcXVlcnkuaHRtbCNRdWVyeS5wcm90b3R5cGUuY3Vyc29yKCkpXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBjb25zdCBhcnIgPSBhd2FpdCBNb3ZpZS5maW5kKHsgeWVhcjogeyAkZ3RlOiAxOTgwLCAkbHRlOiAxOTg5IH0gfSk7XG4gKlxuICogQHBhcmFtIHtPYmplY3R8T2JqZWN0SWR9IFtmaWx0ZXJdIG1vbmdvZGIgZmlsdGVyLiBJZiBub3Qgc3BlY2lmaWVkLCByZXR1cm5zIGFsbCBkb2N1bWVudHMuXG4gKiBAcmV0dXJuIHtRdWVyeX0gdGhpc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5RdWVyeS5wcm90b3R5cGUuZmluZCA9IGZ1bmN0aW9uKGNvbmRpdGlvbnMpIHtcbiAgaWYgKHR5cGVvZiBjb25kaXRpb25zID09PSAnZnVuY3Rpb24nIHx8XG4gICAgICB0eXBlb2YgYXJndW1lbnRzWzFdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IE1vbmdvb3NlRXJyb3IoJ1F1ZXJ5LnByb3RvdHlwZS5maW5kKCkgbm8gbG9uZ2VyIGFjY2VwdHMgYSBjYWxsYmFjaycpO1xuICB9XG5cbiAgdGhpcy5vcCA9ICdmaW5kJztcblxuICBpZiAobXF1ZXJ5LmNhbk1lcmdlKGNvbmRpdGlvbnMpKSB7XG4gICAgdGhpcy5tZXJnZShjb25kaXRpb25zKTtcblxuICAgIHByZXBhcmVEaXNjcmltaW5hdG9yQ3JpdGVyaWEodGhpcyk7XG4gIH0gZWxzZSBpZiAoY29uZGl0aW9ucyAhPSBudWxsKSB7XG4gICAgdGhpcy5lcnJvcihuZXcgT2JqZWN0UGFyYW1ldGVyRXJyb3IoY29uZGl0aW9ucywgJ2ZpbHRlcicsICdmaW5kJykpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIE1lcmdlcyBhbm90aGVyIFF1ZXJ5IG9yIGNvbmRpdGlvbnMgb2JqZWN0IGludG8gdGhpcyBvbmUuXG4gKlxuICogV2hlbiBhIFF1ZXJ5IGlzIHBhc3NlZCwgY29uZGl0aW9ucywgZmllbGQgc2VsZWN0aW9uIGFuZCBvcHRpb25zIGFyZSBtZXJnZWQuXG4gKlxuICogQHBhcmFtIHtRdWVyeXxPYmplY3R9IHNvdXJjZVxuICogQHJldHVybiB7UXVlcnl9IHRoaXNcbiAqL1xuXG5RdWVyeS5wcm90b3R5cGUubWVyZ2UgPSBmdW5jdGlvbihzb3VyY2UpIHtcbiAgaWYgKCFzb3VyY2UpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGNvbnN0IG9wdHMgPSB7IG92ZXJ3cml0ZTogdHJ1ZSB9O1xuXG4gIGlmIChzb3VyY2UgaW5zdGFuY2VvZiBRdWVyeSkge1xuICAgIC8vIGlmIHNvdXJjZSBoYXMgYSBmZWF0dXJlLCBhcHBseSBpdCB0byBvdXJzZWx2ZXNcblxuICAgIGlmIChzb3VyY2UuX2NvbmRpdGlvbnMpIHtcbiAgICAgIG9wdHMub21pdCA9IHt9O1xuICAgICAgaWYgKHRoaXMuX2NvbmRpdGlvbnMgJiYgdGhpcy5fY29uZGl0aW9ucy4kYW5kICYmIHNvdXJjZS5fY29uZGl0aW9ucy4kYW5kKSB7XG4gICAgICAgIG9wdHMub21pdFsnJGFuZCddID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fY29uZGl0aW9ucy4kYW5kID0gdGhpcy5fY29uZGl0aW9ucy4kYW5kLmNvbmNhdChzb3VyY2UuX2NvbmRpdGlvbnMuJGFuZCk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5fY29uZGl0aW9ucyAmJiB0aGlzLl9jb25kaXRpb25zLiRvciAmJiBzb3VyY2UuX2NvbmRpdGlvbnMuJG9yKSB7XG4gICAgICAgIG9wdHMub21pdFsnJG9yJ10gPSB0cnVlO1xuICAgICAgICB0aGlzLl9jb25kaXRpb25zLiRvciA9IHRoaXMuX2NvbmRpdGlvbnMuJG9yLmNvbmNhdChzb3VyY2UuX2NvbmRpdGlvbnMuJG9yKTtcbiAgICAgIH1cbiAgICAgIHV0aWxzLm1lcmdlKHRoaXMuX2NvbmRpdGlvbnMsIHNvdXJjZS5fY29uZGl0aW9ucywgb3B0cyk7XG4gICAgfVxuXG4gICAgaWYgKHNvdXJjZS5fZmllbGRzKSB7XG4gICAgICB0aGlzLl9maWVsZHMgfHwgKHRoaXMuX2ZpZWxkcyA9IHt9KTtcbiAgICAgIHV0aWxzLm1lcmdlKHRoaXMuX2ZpZWxkcywgc291cmNlLl9maWVsZHMsIG9wdHMpO1xuICAgIH1cblxuICAgIGlmIChzb3VyY2Uub3B0aW9ucykge1xuICAgICAgdGhpcy5vcHRpb25zIHx8ICh0aGlzLm9wdGlvbnMgPSB7fSk7XG4gICAgICB1dGlscy5tZXJnZSh0aGlzLm9wdGlvbnMsIHNvdXJjZS5vcHRpb25zLCBvcHRzKTtcbiAgICB9XG5cbiAgICBpZiAoc291cmNlLl91cGRhdGUpIHtcbiAgICAgIHRoaXMuX3VwZGF0ZSB8fCAodGhpcy5fdXBkYXRlID0ge30pO1xuICAgICAgdXRpbHMubWVyZ2VDbG9uZSh0aGlzLl91cGRhdGUsIHNvdXJjZS5fdXBkYXRlKTtcbiAgICB9XG5cbiAgICBpZiAoc291cmNlLl9kaXN0aW5jdCkge1xuICAgICAgdGhpcy5fZGlzdGluY3QgPSBzb3VyY2UuX2Rpc3RpbmN0O1xuICAgIH1cblxuICAgIHV0aWxzLm1lcmdlKHRoaXMuX21vbmdvb3NlT3B0aW9ucywgc291cmNlLl9tb25nb29zZU9wdGlvbnMpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0gZWxzZSBpZiAodGhpcy5tb2RlbCAhPSBudWxsICYmIHNvdXJjZSBpbnN0YW5jZW9mIHRoaXMubW9kZWwuYmFzZS5UeXBlcy5PYmplY3RJZCkge1xuICAgIHV0aWxzLm1lcmdlKHRoaXMuX2NvbmRpdGlvbnMsIHsgX2lkOiBzb3VyY2UgfSwgb3B0cyk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSBlbHNlIGlmIChzb3VyY2UgJiYgc291cmNlLiRfXykge1xuICAgIHNvdXJjZSA9IHNvdXJjZS50b09iamVjdChpbnRlcm5hbFRvT2JqZWN0T3B0aW9ucyk7XG4gIH1cblxuICBvcHRzLm9taXQgPSB7fTtcbiAgaWYgKHRoaXMuX2NvbmRpdGlvbnMgJiYgdGhpcy5fY29uZGl0aW9ucy4kYW5kICYmIHNvdXJjZS4kYW5kKSB7XG4gICAgb3B0cy5vbWl0WyckYW5kJ10gPSB0cnVlO1xuICAgIHRoaXMuX2NvbmRpdGlvbnMuJGFuZCA9IHRoaXMuX2NvbmRpdGlvbnMuJGFuZC5jb25jYXQoc291cmNlLiRhbmQpO1xuICB9XG4gIGlmICh0aGlzLl9jb25kaXRpb25zICYmIHRoaXMuX2NvbmRpdGlvbnMuJG9yICYmIHNvdXJjZS4kb3IpIHtcbiAgICBvcHRzLm9taXRbJyRvciddID0gdHJ1ZTtcbiAgICB0aGlzLl9jb25kaXRpb25zLiRvciA9IHRoaXMuX2NvbmRpdGlvbnMuJG9yLmNvbmNhdChzb3VyY2UuJG9yKTtcbiAgfVxuXG4gIC8vIHBsYWluIG9iamVjdFxuICB1dGlscy5tZXJnZSh0aGlzLl9jb25kaXRpb25zLCBzb3VyY2UsIG9wdHMpO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBBZGRzIGEgY29sbGF0aW9uIHRvIHRoaXMgb3AgKE1vbmdvREIgMy40IGFuZCB1cClcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsdWVcbiAqIEByZXR1cm4ge1F1ZXJ5fSB0aGlzXG4gKiBAc2VlIE1vbmdvREIgZG9jcyBodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9yZWZlcmVuY2UvbWV0aG9kL2N1cnNvci5jb2xsYXRpb24vI2N1cnNvci5jb2xsYXRpb25cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUXVlcnkucHJvdG90eXBlLmNvbGxhdGlvbiA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gIGlmICh0aGlzLm9wdGlvbnMgPT0gbnVsbCkge1xuICAgIHRoaXMub3B0aW9ucyA9IHt9O1xuICB9XG4gIHRoaXMub3B0aW9ucy5jb2xsYXRpb24gPSB2YWx1ZTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEh5ZHJhdGUgYSBzaW5nbGUgZG9jIGZyb20gYGZpbmRPbmUoKWAsIGBmaW5kT25lQW5kVXBkYXRlKClgLCBldGMuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuUXVlcnkucHJvdG90eXBlLl9jb21wbGV0ZU9uZSA9IGZ1bmN0aW9uKGRvYywgcmVzLCBjYWxsYmFjaykge1xuICBpZiAoIWRvYyAmJiAhdGhpcy5vcHRpb25zLmluY2x1ZGVSZXN1bHRNZXRhZGF0YSkge1xuICAgIHJldHVybiBjYWxsYmFjayhudWxsLCBudWxsKTtcbiAgfVxuXG4gIGNvbnN0IG1vZGVsID0gdGhpcy5tb2RlbDtcbiAgY29uc3QgcHJvamVjdGlvbiA9IGNsb25lKHRoaXMuX2ZpZWxkcyk7XG4gIGNvbnN0IHVzZXJQcm92aWRlZEZpZWxkcyA9IHRoaXMuX3VzZXJQcm92aWRlZEZpZWxkcyB8fCB7fTtcbiAgLy8gYHBvcHVsYXRlYCwgYGxlYW5gXG4gIGNvbnN0IG1vbmdvb3NlT3B0aW9ucyA9IHRoaXMuX21vbmdvb3NlT3B0aW9ucztcblxuICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICBpZiAoIW9wdGlvbnMubGVhbiAmJiBtb25nb29zZU9wdGlvbnMubGVhbikge1xuICAgIG9wdGlvbnMubGVhbiA9IG1vbmdvb3NlT3B0aW9ucy5sZWFuO1xuICB9XG5cbiAgaWYgKG9wdGlvbnMuZXhwbGFpbikge1xuICAgIHJldHVybiBjYWxsYmFjayhudWxsLCBkb2MpO1xuICB9XG5cbiAgaWYgKCFtb25nb29zZU9wdGlvbnMucG9wdWxhdGUpIHtcbiAgICBjb25zdCB2ZXJzaW9uS2V5ID0gdGhpcy5zY2hlbWEub3B0aW9ucy52ZXJzaW9uS2V5O1xuICAgIGlmIChtb25nb29zZU9wdGlvbnMubGVhbiAmJiBtb25nb29zZU9wdGlvbnMubGVhbi52ZXJzaW9uS2V5ID09PSBmYWxzZSAmJiB2ZXJzaW9uS2V5KSB7XG4gICAgICBpZiAodmVyc2lvbktleSBpbiBkb2MpIHtcbiAgICAgICAgZGVsZXRlIGRvY1t2ZXJzaW9uS2V5XTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG1vbmdvb3NlT3B0aW9ucy5sZWFuID9cbiAgICAgIF9jb21wbGV0ZU9uZUxlYW4obW9kZWwuc2NoZW1hLCBkb2MsIG51bGwsIHJlcywgb3B0aW9ucywgY2FsbGJhY2spIDpcbiAgICAgIGNvbXBsZXRlT25lKG1vZGVsLCBkb2MsIHJlcywgb3B0aW9ucywgcHJvamVjdGlvbiwgdXNlclByb3ZpZGVkRmllbGRzLFxuICAgICAgICBudWxsLCBjYWxsYmFjayk7XG4gIH1cblxuICBjb25zdCBwb3AgPSBoZWxwZXJzLnByZXBhcmVQb3B1bGF0aW9uT3B0aW9uc01RKHRoaXMsIHRoaXMuX21vbmdvb3NlT3B0aW9ucyk7XG4gIGlmIChtb25nb29zZU9wdGlvbnMubGVhbikge1xuICAgIHJldHVybiBtb2RlbC5wb3B1bGF0ZShkb2MsIHBvcCkudGhlbihcbiAgICAgIGRvYyA9PiB7XG4gICAgICAgIF9jb21wbGV0ZU9uZUxlYW4obW9kZWwuc2NoZW1hLCBkb2MsIG51bGwsIHJlcywgb3B0aW9ucywgY2FsbGJhY2spO1xuICAgICAgfSxcbiAgICAgIGVycm9yID0+IHtcbiAgICAgICAgY2FsbGJhY2soZXJyb3IpO1xuICAgICAgfVxuICAgICk7XG4gIH1cblxuICBjb21wbGV0ZU9uZShtb2RlbCwgZG9jLCByZXMsIG9wdGlvbnMsIHByb2plY3Rpb24sIHVzZXJQcm92aWRlZEZpZWxkcywgW10sIChlcnIsIGRvYykgPT4ge1xuICAgIGlmIChlcnIgIT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgfVxuICAgIG1vZGVsLnBvcHVsYXRlKGRvYywgcG9wKS50aGVuKHJlcyA9PiB7IGNhbGxiYWNrKG51bGwsIHJlcyk7IH0sIGVyciA9PiB7IGNhbGxiYWNrKGVycik7IH0pO1xuICB9KTtcbn07XG5cbi8qKlxuICogR2l2ZW4gYSBtb2RlbCBhbmQgYW4gYXJyYXkgb2YgZG9jcywgaHlkcmF0ZXMgYWxsIHRoZSBkb2NzIHRvIGJlIGluc3RhbmNlc1xuICogb2YgdGhlIG1vZGVsLiBVc2VkIHRvIGluaXRpYWxpemUgZG9jcyByZXR1cm5lZCBmcm9tIHRoZSBkYiBmcm9tIGBmaW5kKClgXG4gKlxuICogQHBhcmFtIHtBcnJheX0gZG9jc1xuICogQHBhcmFtIHtPYmplY3R9IGZpZWxkcyB0aGUgcHJvamVjdGlvbiB1c2VkLCBpbmNsdWRpbmcgYHNlbGVjdGAgZnJvbSBzY2hlbWFzXG4gKiBAcGFyYW0ge09iamVjdH0gdXNlclByb3ZpZGVkRmllbGRzIHRoZSB1c2VyLXNwZWNpZmllZCBwcm9qZWN0aW9uXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdHNdXG4gKiBAcGFyYW0ge0FycmF5fSBbb3B0cy5wb3B1bGF0ZWRdXG4gKiBAcGFyYW0ge0NsaWVudFNlc3Npb259IFtvcHRzLnNlc3Npb25dXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5RdWVyeS5wcm90b3R5cGUuX2NvbXBsZXRlTWFueSA9IGFzeW5jIGZ1bmN0aW9uIF9jb21wbGV0ZU1hbnkoZG9jcywgZmllbGRzLCB1c2VyUHJvdmlkZWRGaWVsZHMsIG9wdHMpIHtcbiAgY29uc3QgbW9kZWwgPSB0aGlzLm1vZGVsO1xuICByZXR1cm4gUHJvbWlzZS5hbGwoZG9jcy5tYXAoZG9jID0+IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBjb25zdCByYXdEb2MgPSBkb2M7XG4gICAgZG9jID0gaGVscGVycy5jcmVhdGVNb2RlbChtb2RlbCwgZG9jLCBmaWVsZHMsIHVzZXJQcm92aWRlZEZpZWxkcyk7XG4gICAgaWYgKG9wdHMuc2Vzc2lvbiAhPSBudWxsKSB7XG4gICAgICBkb2MuJHNlc3Npb24ob3B0cy5zZXNzaW9uKTtcbiAgICB9XG4gICAgZG9jLiRpbml0KHJhd0RvYywgb3B0cywgKGVycikgPT4ge1xuICAgICAgaWYgKGVyciAhPSBudWxsKSB7XG4gICAgICAgIHJldHVybiByZWplY3QoZXJyKTtcbiAgICAgIH1cbiAgICAgIHJlc29sdmUoZG9jKTtcbiAgICB9KTtcbiAgfSkpKTtcbn07XG5cbi8qKlxuICogSW50ZXJuYWwgaGVscGVyIHRvIGV4ZWN1dGUgYSBmaW5kT25lKCkgb3BlcmF0aW9uXG4gKlxuICogQHNlZSBmaW5kT25lIGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvbWFudWFsL3JlZmVyZW5jZS9tZXRob2QvZGIuY29sbGVjdGlvbi5maW5kT25lL1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuUXVlcnkucHJvdG90eXBlLl9maW5kT25lID0gYXN5bmMgZnVuY3Rpb24gX2ZpbmRPbmUoKSB7XG4gIHRoaXMuX2Nhc3RDb25kaXRpb25zKCk7XG5cbiAgaWYgKHRoaXMuZXJyb3IoKSkge1xuICAgIGNvbnN0IGVyciA9IHRoaXMuZXJyb3IoKTtcbiAgICB0aHJvdyBlcnI7XG4gIH1cblxuICBhcHBseUdsb2JhbE1heFRpbWVNUyh0aGlzLm9wdGlvbnMsIHRoaXMubW9kZWwuZGIub3B0aW9ucywgdGhpcy5tb2RlbC5iYXNlLm9wdGlvbnMpO1xuICBhcHBseUdsb2JhbERpc2tVc2UodGhpcy5vcHRpb25zLCB0aGlzLm1vZGVsLmRiLm9wdGlvbnMsIHRoaXMubW9kZWwuYmFzZS5vcHRpb25zKTtcblxuICBjb25zdCBvcHRpb25zID0gdGhpcy5fb3B0aW9uc0ZvckV4ZWMoKTtcblxuICB0aGlzLl9hcHBseVRyYW5zbGF0ZUFsaWFzZXMob3B0aW9ucyk7XG5cbiAgLy8gZG9uJ3QgcGFzcyBpbiB0aGUgY29uZGl0aW9ucyBiZWNhdXNlIHdlIGFscmVhZHkgbWVyZ2VkIHRoZW0gaW5cbiAgY29uc3QgZG9jID0gYXdhaXQgdGhpcy5tb25nb29zZUNvbGxlY3Rpb24uZmluZE9uZSh0aGlzLl9jb25kaXRpb25zLCBvcHRpb25zKTtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICB0aGlzLl9jb21wbGV0ZU9uZShkb2MsIG51bGwsIChlcnIsIHJlcykgPT4ge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICByZXR1cm4gcmVqZWN0KGVycik7XG4gICAgICB9XG4gICAgICByZXNvbHZlKHJlcyk7XG4gICAgfSk7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBEZWNsYXJlcyB0aGUgcXVlcnkgYSBmaW5kT25lIG9wZXJhdGlvbi4gV2hlbiBleGVjdXRlZCwgdGhlIGZpcnN0IGZvdW5kIGRvY3VtZW50IGlzIHBhc3NlZCB0byB0aGUgY2FsbGJhY2suXG4gKlxuICogVGhlIHJlc3VsdCBvZiB0aGUgcXVlcnkgaXMgYSBzaW5nbGUgZG9jdW1lbnQsIG9yIGBudWxsYCBpZiBubyBkb2N1bWVudCB3YXMgZm91bmQuXG4gKlxuICogKiAqTm90ZToqIGBjb25kaXRpb25zYCBpcyBvcHRpb25hbCwgYW5kIGlmIGBjb25kaXRpb25zYCBpcyBudWxsIG9yIHVuZGVmaW5lZCxcbiAqIG1vbmdvb3NlIHdpbGwgc2VuZCBhbiBlbXB0eSBgZmluZE9uZWAgY29tbWFuZCB0byBNb25nb0RCLCB3aGljaCB3aWxsIHJldHVyblxuICogYW4gYXJiaXRyYXJ5IGRvY3VtZW50LiBJZiB5b3UncmUgcXVlcnlpbmcgYnkgYF9pZGAsIHVzZSBgTW9kZWwuZmluZEJ5SWQoKWBcbiAqIGluc3RlYWQuXG4gKlxuICogVGhpcyBmdW5jdGlvbiB0cmlnZ2VycyB0aGUgZm9sbG93aW5nIG1pZGRsZXdhcmUuXG4gKlxuICogLSBgZmluZE9uZSgpYFxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgY29uc3QgcXVlcnkgPSBLaXR0ZW4ud2hlcmUoeyBjb2xvcjogJ3doaXRlJyB9KTtcbiAqICAgICBjb25zdCBraXR0ZW4gPSBhd2FpdCBxdWVyeS5maW5kT25lKCk7XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IFtmaWx0ZXJdIG1vbmdvZGIgc2VsZWN0b3JcbiAqIEBwYXJhbSB7T2JqZWN0fSBbcHJvamVjdGlvbl0gb3B0aW9uYWwgZmllbGRzIHRvIHJldHVyblxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBzZWUgW2BzZXRPcHRpb25zKClgXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvYXBpL3F1ZXJ5Lmh0bWwjUXVlcnkucHJvdG90eXBlLnNldE9wdGlvbnMoKSlcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMudHJhbnNsYXRlQWxpYXNlcz1udWxsXSBJZiBzZXQgdG8gYHRydWVgLCB0cmFuc2xhdGVzIGFueSBzY2hlbWEtZGVmaW5lZCBhbGlhc2VzIGluIGBmaWx0ZXJgLCBgcHJvamVjdGlvbmAsIGB1cGRhdGVgLCBhbmQgYGRpc3RpbmN0YC4gVGhyb3dzIGFuIGVycm9yIGlmIHRoZXJlIGFyZSBhbnkgY29uZmxpY3RzIHdoZXJlIGJvdGggYWxpYXMgYW5kIHJhdyBwcm9wZXJ0eSBhcmUgZGVmaW5lZCBvbiB0aGUgc2FtZSBvYmplY3QuXG4gKiBAcmV0dXJuIHtRdWVyeX0gdGhpc1xuICogQHNlZSBmaW5kT25lIGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvbWFudWFsL3JlZmVyZW5jZS9tZXRob2QvZGIuY29sbGVjdGlvbi5maW5kT25lL1xuICogQHNlZSBRdWVyeS5zZWxlY3QgaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2FwaS9xdWVyeS5odG1sI1F1ZXJ5LnByb3RvdHlwZS5zZWxlY3QoKVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5RdWVyeS5wcm90b3R5cGUuZmluZE9uZSA9IGZ1bmN0aW9uKGNvbmRpdGlvbnMsIHByb2plY3Rpb24sIG9wdGlvbnMpIHtcbiAgaWYgKHR5cGVvZiBjb25kaXRpb25zID09PSAnZnVuY3Rpb24nIHx8XG4gICAgICB0eXBlb2YgcHJvamVjdGlvbiA9PT0gJ2Z1bmN0aW9uJyB8fFxuICAgICAgdHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicgfHxcbiAgICAgIHR5cGVvZiBhcmd1bWVudHNbM10gPT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgTW9uZ29vc2VFcnJvcignUXVlcnkucHJvdG90eXBlLmZpbmRPbmUoKSBubyBsb25nZXIgYWNjZXB0cyBhIGNhbGxiYWNrJyk7XG4gIH1cblxuICB0aGlzLm9wID0gJ2ZpbmRPbmUnO1xuICB0aGlzLl92YWxpZGF0ZU9wKCk7XG5cbiAgaWYgKG9wdGlvbnMpIHtcbiAgICB0aGlzLnNldE9wdGlvbnMob3B0aW9ucyk7XG4gIH1cblxuICBpZiAocHJvamVjdGlvbikge1xuICAgIHRoaXMuc2VsZWN0KHByb2plY3Rpb24pO1xuICB9XG5cbiAgaWYgKG1xdWVyeS5jYW5NZXJnZShjb25kaXRpb25zKSkge1xuICAgIHRoaXMubWVyZ2UoY29uZGl0aW9ucyk7XG5cbiAgICBwcmVwYXJlRGlzY3JpbWluYXRvckNyaXRlcmlhKHRoaXMpO1xuICB9IGVsc2UgaWYgKGNvbmRpdGlvbnMgIT0gbnVsbCkge1xuICAgIHRoaXMuZXJyb3IobmV3IE9iamVjdFBhcmFtZXRlckVycm9yKGNvbmRpdGlvbnMsICdmaWx0ZXInLCAnZmluZE9uZScpKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuXG4vKipcbiAqIEV4ZWN1dGUgYSBjb3VudERvY3VtZW50cyBxdWVyeVxuICpcbiAqIEBzZWUgY291bnREb2N1bWVudHMgaHR0cHM6Ly9tb25nb2RiLmdpdGh1Yi5pby9ub2RlLW1vbmdvZGItbmF0aXZlLzQuOS9jbGFzc2VzL0NvbGxlY3Rpb24uaHRtbCNjb3VudERvY3VtZW50c1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuUXVlcnkucHJvdG90eXBlLl9jb3VudERvY3VtZW50cyA9IGFzeW5jIGZ1bmN0aW9uIF9jb3VudERvY3VtZW50cygpIHtcbiAgdHJ5IHtcbiAgICB0aGlzLmNhc3QodGhpcy5tb2RlbCk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHRoaXMuZXJyb3IoZXJyKTtcbiAgfVxuXG4gIGlmICh0aGlzLmVycm9yKCkpIHtcbiAgICB0aHJvdyB0aGlzLmVycm9yKCk7XG4gIH1cblxuICBhcHBseUdsb2JhbE1heFRpbWVNUyh0aGlzLm9wdGlvbnMsIHRoaXMubW9kZWwuZGIub3B0aW9ucywgdGhpcy5tb2RlbC5iYXNlLm9wdGlvbnMpO1xuICBhcHBseUdsb2JhbERpc2tVc2UodGhpcy5vcHRpb25zLCB0aGlzLm1vZGVsLmRiLm9wdGlvbnMsIHRoaXMubW9kZWwuYmFzZS5vcHRpb25zKTtcblxuICBjb25zdCBvcHRpb25zID0gdGhpcy5fb3B0aW9uc0ZvckV4ZWMoKTtcblxuICB0aGlzLl9hcHBseVRyYW5zbGF0ZUFsaWFzZXMob3B0aW9ucyk7XG5cbiAgY29uc3QgY29uZHMgPSB0aGlzLl9jb25kaXRpb25zO1xuXG4gIHJldHVybiB0aGlzLm1vbmdvb3NlQ29sbGVjdGlvbi5jb3VudERvY3VtZW50cyhjb25kcywgb3B0aW9ucyk7XG59O1xuXG4vKiFcbiAqIElmIGB0cmFuc2xhdGVBbGlhc2VzYCBvcHRpb24gaXMgc2V0LCBjYWxsIGBNb2RlbC50cmFuc2xhdGVBbGlhc2VzKClgXG4gKiBvbiB0aGUgZm9sbG93aW5nIHF1ZXJ5IHByb3BlcnRpZXM6IGZpbHRlciwgcHJvamVjdGlvbiwgdXBkYXRlLCBkaXN0aW5jdC5cbiAqL1xuXG5RdWVyeS5wcm90b3R5cGUuX2FwcGx5VHJhbnNsYXRlQWxpYXNlcyA9IGZ1bmN0aW9uIF9hcHBseVRyYW5zbGF0ZUFsaWFzZXMob3B0aW9ucykge1xuICBsZXQgYXBwbHlUcmFuc2xhdGVBbGlhc2VzID0gZmFsc2U7XG4gIGlmICgndHJhbnNsYXRlQWxpYXNlcycgaW4gdGhpcy5fbW9uZ29vc2VPcHRpb25zKSB7XG4gICAgYXBwbHlUcmFuc2xhdGVBbGlhc2VzID0gdGhpcy5fbW9uZ29vc2VPcHRpb25zLnRyYW5zbGF0ZUFsaWFzZXM7XG4gIH0gZWxzZSBpZiAodGhpcy5tb2RlbD8uc2NoZW1hPy5fdXNlclByb3ZpZGVkT3B0aW9ucz8udHJhbnNsYXRlQWxpYXNlcyAhPSBudWxsKSB7XG4gICAgYXBwbHlUcmFuc2xhdGVBbGlhc2VzID0gdGhpcy5tb2RlbC5zY2hlbWEuX3VzZXJQcm92aWRlZE9wdGlvbnMudHJhbnNsYXRlQWxpYXNlcztcbiAgfSBlbHNlIGlmICh0aGlzLm1vZGVsPy5iYXNlPy5vcHRpb25zPy50cmFuc2xhdGVBbGlhc2VzICE9IG51bGwpIHtcbiAgICBhcHBseVRyYW5zbGF0ZUFsaWFzZXMgPSB0aGlzLm1vZGVsLmJhc2Uub3B0aW9ucy50cmFuc2xhdGVBbGlhc2VzO1xuICB9XG4gIGlmICghYXBwbHlUcmFuc2xhdGVBbGlhc2VzKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKHRoaXMubW9kZWw/LnNjaGVtYT8uYWxpYXNlcyAmJiBPYmplY3Qua2V5cyh0aGlzLm1vZGVsLnNjaGVtYS5hbGlhc2VzKS5sZW5ndGggPiAwKSB7XG4gICAgdGhpcy5tb2RlbC50cmFuc2xhdGVBbGlhc2VzKHRoaXMuX2NvbmRpdGlvbnMsIHRydWUpO1xuICAgIHRoaXMubW9kZWwudHJhbnNsYXRlQWxpYXNlcyhvcHRpb25zLnByb2plY3Rpb24sIHRydWUpO1xuICAgIHRoaXMubW9kZWwudHJhbnNsYXRlQWxpYXNlcyh0aGlzLl91cGRhdGUsIHRydWUpO1xuICAgIGlmICh0aGlzLl9kaXN0aW5jdCAhPSBudWxsICYmIHRoaXMubW9kZWwuc2NoZW1hLmFsaWFzZXNbdGhpcy5fZGlzdGluY3RdICE9IG51bGwpIHtcbiAgICAgIHRoaXMuX2Rpc3RpbmN0ID0gdGhpcy5tb2RlbC5zY2hlbWEuYWxpYXNlc1t0aGlzLl9kaXN0aW5jdF07XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIEV4ZWN1dGUgYSBlc3RpbWF0ZWREb2N1bWVudENvdW50KCkgcXVlcnlcbiAqXG4gKiBAc2VlIGVzdGltYXRlZERvY3VtZW50Q291bnQgaHR0cHM6Ly9tb25nb2RiLmdpdGh1Yi5pby9ub2RlLW1vbmdvZGItbmF0aXZlLzQuOS9jbGFzc2VzL0NvbGxlY3Rpb24uaHRtbCNlc3RpbWF0ZWREb2N1bWVudENvdW50XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5RdWVyeS5wcm90b3R5cGUuX2VzdGltYXRlZERvY3VtZW50Q291bnQgPSBhc3luYyBmdW5jdGlvbiBfZXN0aW1hdGVkRG9jdW1lbnRDb3VudCgpIHtcbiAgaWYgKHRoaXMuZXJyb3IoKSkge1xuICAgIHRocm93IHRoaXMuZXJyb3IoKTtcbiAgfVxuXG4gIGNvbnN0IG9wdGlvbnMgPSB0aGlzLl9vcHRpb25zRm9yRXhlYygpO1xuXG4gIHJldHVybiB0aGlzLm1vbmdvb3NlQ29sbGVjdGlvbi5lc3RpbWF0ZWREb2N1bWVudENvdW50KG9wdGlvbnMpO1xufTtcblxuLyoqXG4gKiBTcGVjaWZpZXMgdGhpcyBxdWVyeSBhcyBhIGBlc3RpbWF0ZWREb2N1bWVudENvdW50KClgIHF1ZXJ5LiBGYXN0ZXIgdGhhblxuICogdXNpbmcgYGNvdW50RG9jdW1lbnRzKClgIGZvciBsYXJnZSBjb2xsZWN0aW9ucyBiZWNhdXNlXG4gKiBgZXN0aW1hdGVkRG9jdW1lbnRDb3VudCgpYCB1c2VzIGNvbGxlY3Rpb24gbWV0YWRhdGEgcmF0aGVyIHRoYW4gc2Nhbm5pbmdcbiAqIHRoZSBlbnRpcmUgY29sbGVjdGlvbi5cbiAqXG4gKiBgZXN0aW1hdGVkRG9jdW1lbnRDb3VudCgpYCBkb2VzICoqbm90KiogYWNjZXB0IGEgZmlsdGVyLiBgTW9kZWwuZmluZCh7IGZvbzogYmFyIH0pLmVzdGltYXRlZERvY3VtZW50Q291bnQoKWBcbiAqIGlzIGVxdWl2YWxlbnQgdG8gYE1vZGVsLmZpbmQoKS5lc3RpbWF0ZWREb2N1bWVudENvdW50KClgXG4gKlxuICogVGhpcyBmdW5jdGlvbiB0cmlnZ2VycyB0aGUgZm9sbG93aW5nIG1pZGRsZXdhcmUuXG4gKlxuICogLSBgZXN0aW1hdGVkRG9jdW1lbnRDb3VudCgpYFxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgYXdhaXQgTW9kZWwuZmluZCgpLmVzdGltYXRlZERvY3VtZW50Q291bnQoKTtcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIHBhc3NlZCB0cmFuc3BhcmVudGx5IHRvIHRoZSBbTW9uZ29EQiBkcml2ZXJdKGh0dHBzOi8vbW9uZ29kYi5naXRodWIuaW8vbm9kZS1tb25nb2RiLW5hdGl2ZS80LjkvaW50ZXJmYWNlcy9Fc3RpbWF0ZWREb2N1bWVudENvdW50T3B0aW9ucy5odG1sKVxuICogQHJldHVybiB7UXVlcnl9IHRoaXNcbiAqIEBzZWUgZXN0aW1hdGVkRG9jdW1lbnRDb3VudCBodHRwczovL21vbmdvZGIuZ2l0aHViLmlvL25vZGUtbW9uZ29kYi1uYXRpdmUvNC45L2NsYXNzZXMvQ29sbGVjdGlvbi5odG1sI2VzdGltYXRlZERvY3VtZW50Q291bnRcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUXVlcnkucHJvdG90eXBlLmVzdGltYXRlZERvY3VtZW50Q291bnQgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJyB8fFxuICAgICAgdHlwZW9mIGFyZ3VtZW50c1sxXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBNb25nb29zZUVycm9yKCdRdWVyeS5wcm90b3R5cGUuZXN0aW1hdGVkRG9jdW1lbnRDb3VudCgpIG5vIGxvbmdlciBhY2NlcHRzIGEgY2FsbGJhY2snKTtcbiAgfVxuXG4gIHRoaXMub3AgPSAnZXN0aW1hdGVkRG9jdW1lbnRDb3VudCc7XG4gIHRoaXMuX3ZhbGlkYXRlT3AoKTtcblxuICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdvYmplY3QnICYmIG9wdGlvbnMgIT0gbnVsbCkge1xuICAgIHRoaXMuc2V0T3B0aW9ucyhvcHRpb25zKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTcGVjaWZpZXMgdGhpcyBxdWVyeSBhcyBhIGBjb3VudERvY3VtZW50cygpYCBxdWVyeS4gQmVoYXZlcyBsaWtlIGBjb3VudCgpYCxcbiAqIGV4Y2VwdCBpdCBhbHdheXMgZG9lcyBhIGZ1bGwgY29sbGVjdGlvbiBzY2FuIHdoZW4gcGFzc2VkIGFuIGVtcHR5IGZpbHRlciBge31gLlxuICpcbiAqIFRoZXJlIGFyZSBhbHNvIG1pbm9yIGRpZmZlcmVuY2VzIGluIGhvdyBgY291bnREb2N1bWVudHMoKWAgaGFuZGxlc1xuICogW2Akd2hlcmVgIGFuZCBhIGNvdXBsZSBnZW9zcGF0aWFsIG9wZXJhdG9yc10oaHR0cHM6Ly9tb25nb2RiLmdpdGh1Yi5pby9ub2RlLW1vbmdvZGItbmF0aXZlLzQuOS9jbGFzc2VzL0NvbGxlY3Rpb24uaHRtbCNjb3VudERvY3VtZW50cykuXG4gKiB2ZXJzdXMgYGNvdW50KClgLlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gdHJpZ2dlcnMgdGhlIGZvbGxvd2luZyBtaWRkbGV3YXJlLlxuICpcbiAqIC0gYGNvdW50RG9jdW1lbnRzKClgXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBjb25zdCBjb3VudFF1ZXJ5ID0gbW9kZWwud2hlcmUoeyAnY29sb3InOiAnYmxhY2snIH0pLmNvdW50RG9jdW1lbnRzKCk7XG4gKlxuICogICAgIHF1ZXJ5LmNvdW50RG9jdW1lbnRzKHsgY29sb3I6ICdibGFjaycgfSkuY291bnQoKS5leGVjKCk7XG4gKlxuICogICAgIGF3YWl0IHF1ZXJ5LmNvdW50RG9jdW1lbnRzKHsgY29sb3I6ICdibGFjaycgfSk7XG4gKlxuICogICAgIHF1ZXJ5LndoZXJlKCdjb2xvcicsICdibGFjaycpLmNvdW50RG9jdW1lbnRzKCkuZXhlYygpO1xuICpcbiAqIFRoZSBgY291bnREb2N1bWVudHMoKWAgZnVuY3Rpb24gaXMgc2ltaWxhciB0byBgY291bnQoKWAsIGJ1dCB0aGVyZSBhcmUgYVxuICogW2ZldyBvcGVyYXRvcnMgdGhhdCBgY291bnREb2N1bWVudHMoKWAgZG9lcyBub3Qgc3VwcG9ydF0oaHR0cHM6Ly9tb25nb2RiLmdpdGh1Yi5pby9ub2RlLW1vbmdvZGItbmF0aXZlLzQuOS9jbGFzc2VzL0NvbGxlY3Rpb24uaHRtbCNjb3VudERvY3VtZW50cykuXG4gKiBCZWxvdyBhcmUgdGhlIG9wZXJhdG9ycyB0aGF0IGBjb3VudCgpYCBzdXBwb3J0cyBidXQgYGNvdW50RG9jdW1lbnRzKClgIGRvZXMgbm90LFxuICogYW5kIHRoZSBzdWdnZXN0ZWQgcmVwbGFjZW1lbnQ6XG4gKlxuICogLSBgJHdoZXJlYDogW2AkZXhwcmBdKGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvbWFudWFsL3JlZmVyZW5jZS9vcGVyYXRvci9xdWVyeS9leHByLylcbiAqIC0gYCRuZWFyYDogW2AkZ2VvV2l0aGluYF0oaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvcmVmZXJlbmNlL29wZXJhdG9yL3F1ZXJ5L2dlb1dpdGhpbi8pIHdpdGggW2AkY2VudGVyYF0oaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvcmVmZXJlbmNlL29wZXJhdG9yL3F1ZXJ5L2NlbnRlci8jb3AuX1NfY2VudGVyKVxuICogLSBgJG5lYXJTcGhlcmVgOiBbYCRnZW9XaXRoaW5gXShodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9yZWZlcmVuY2Uvb3BlcmF0b3IvcXVlcnkvZ2VvV2l0aGluLykgd2l0aCBbYCRjZW50ZXJTcGhlcmVgXShodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9yZWZlcmVuY2Uvb3BlcmF0b3IvcXVlcnkvY2VudGVyU3BoZXJlLyNvcC5fU19jZW50ZXJTcGhlcmUpXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IFtmaWx0ZXJdIG1vbmdvZGIgc2VsZWN0b3JcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEByZXR1cm4ge1F1ZXJ5fSB0aGlzXG4gKiBAc2VlIGNvdW50RG9jdW1lbnRzIGh0dHBzOi8vbW9uZ29kYi5naXRodWIuaW8vbm9kZS1tb25nb2RiLW5hdGl2ZS80LjkvY2xhc3Nlcy9Db2xsZWN0aW9uLmh0bWwjY291bnREb2N1bWVudHNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUXVlcnkucHJvdG90eXBlLmNvdW50RG9jdW1lbnRzID0gZnVuY3Rpb24oY29uZGl0aW9ucywgb3B0aW9ucykge1xuICBpZiAodHlwZW9mIGNvbmRpdGlvbnMgPT09ICdmdW5jdGlvbicgfHxcbiAgICAgIHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nIHx8XG4gICAgICB0eXBlb2YgYXJndW1lbnRzWzJdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IE1vbmdvb3NlRXJyb3IoJ1F1ZXJ5LnByb3RvdHlwZS5jb3VudERvY3VtZW50cygpIG5vIGxvbmdlciBhY2NlcHRzIGEgY2FsbGJhY2snKTtcbiAgfVxuXG4gIHRoaXMub3AgPSAnY291bnREb2N1bWVudHMnO1xuICB0aGlzLl92YWxpZGF0ZU9wKCk7XG5cbiAgaWYgKG1xdWVyeS5jYW5NZXJnZShjb25kaXRpb25zKSkge1xuICAgIHRoaXMubWVyZ2UoY29uZGl0aW9ucyk7XG4gIH1cblxuICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdvYmplY3QnICYmIG9wdGlvbnMgIT0gbnVsbCkge1xuICAgIHRoaXMuc2V0T3B0aW9ucyhvcHRpb25zKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBFeGVjdXRlIGEgYGRpc3RpbmN0KClgIHF1ZXJ5XG4gKlxuICogQHNlZSBkaXN0aW5jdCBodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9yZWZlcmVuY2UvbWV0aG9kL2RiLmNvbGxlY3Rpb24uZGlzdGluY3QvXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5RdWVyeS5wcm90b3R5cGUuX19kaXN0aW5jdCA9IGFzeW5jIGZ1bmN0aW9uIF9fZGlzdGluY3QoKSB7XG4gIHRoaXMuX2Nhc3RDb25kaXRpb25zKCk7XG5cbiAgaWYgKHRoaXMuZXJyb3IoKSkge1xuICAgIHRocm93IHRoaXMuZXJyb3IoKTtcbiAgfVxuXG4gIGFwcGx5R2xvYmFsTWF4VGltZU1TKHRoaXMub3B0aW9ucywgdGhpcy5tb2RlbC5kYi5vcHRpb25zLCB0aGlzLm1vZGVsLmJhc2Uub3B0aW9ucyk7XG4gIGFwcGx5R2xvYmFsRGlza1VzZSh0aGlzLm9wdGlvbnMsIHRoaXMubW9kZWwuZGIub3B0aW9ucywgdGhpcy5tb2RlbC5iYXNlLm9wdGlvbnMpO1xuXG4gIGNvbnN0IG9wdGlvbnMgPSB0aGlzLl9vcHRpb25zRm9yRXhlYygpO1xuICB0aGlzLl9hcHBseVRyYW5zbGF0ZUFsaWFzZXMob3B0aW9ucyk7XG5cbiAgcmV0dXJuIHRoaXMubW9uZ29vc2VDb2xsZWN0aW9uLlxuICAgIGRpc3RpbmN0KHRoaXMuX2Rpc3RpbmN0LCB0aGlzLl9jb25kaXRpb25zLCBvcHRpb25zKTtcbn07XG5cbi8qKlxuICogRGVjbGFyZXMgb3IgZXhlY3V0ZXMgYSBkaXN0aW5jdCgpIG9wZXJhdGlvbi5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIGRvZXMgbm90IHRyaWdnZXIgYW55IG1pZGRsZXdhcmUuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBkaXN0aW5jdChmaWVsZCwgY29uZGl0aW9ucylcbiAqICAgICBkaXN0aW5jdChmaWVsZClcbiAqICAgICBkaXN0aW5jdCgpXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IFtmaWVsZF1cbiAqIEBwYXJhbSB7T2JqZWN0fFF1ZXJ5fSBbZmlsdGVyXVxuICogQHJldHVybiB7UXVlcnl9IHRoaXNcbiAqIEBzZWUgZGlzdGluY3QgaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvcmVmZXJlbmNlL21ldGhvZC9kYi5jb2xsZWN0aW9uLmRpc3RpbmN0L1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5RdWVyeS5wcm90b3R5cGUuZGlzdGluY3QgPSBmdW5jdGlvbihmaWVsZCwgY29uZGl0aW9ucykge1xuICBpZiAodHlwZW9mIGZpZWxkID09PSAnZnVuY3Rpb24nIHx8XG4gICAgICB0eXBlb2YgY29uZGl0aW9ucyA9PT0gJ2Z1bmN0aW9uJyB8fFxuICAgICAgdHlwZW9mIGFyZ3VtZW50c1syXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBNb25nb29zZUVycm9yKCdRdWVyeS5wcm90b3R5cGUuZGlzdGluY3QoKSBubyBsb25nZXIgYWNjZXB0cyBhIGNhbGxiYWNrJyk7XG4gIH1cblxuICB0aGlzLm9wID0gJ2Rpc3RpbmN0JztcbiAgdGhpcy5fdmFsaWRhdGVPcCgpO1xuXG4gIGlmIChtcXVlcnkuY2FuTWVyZ2UoY29uZGl0aW9ucykpIHtcbiAgICB0aGlzLm1lcmdlKGNvbmRpdGlvbnMpO1xuXG4gICAgcHJlcGFyZURpc2NyaW1pbmF0b3JDcml0ZXJpYSh0aGlzKTtcbiAgfSBlbHNlIGlmIChjb25kaXRpb25zICE9IG51bGwpIHtcbiAgICB0aGlzLmVycm9yKG5ldyBPYmplY3RQYXJhbWV0ZXJFcnJvcihjb25kaXRpb25zLCAnZmlsdGVyJywgJ2Rpc3RpbmN0JykpO1xuICB9XG5cbiAgaWYgKGZpZWxkICE9IG51bGwpIHtcbiAgICB0aGlzLl9kaXN0aW5jdCA9IGZpZWxkO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNldHMgdGhlIHNvcnQgb3JkZXJcbiAqXG4gKiBJZiBhbiBvYmplY3QgaXMgcGFzc2VkLCB2YWx1ZXMgYWxsb3dlZCBhcmUgYGFzY2AsIGBkZXNjYCwgYGFzY2VuZGluZ2AsIGBkZXNjZW5kaW5nYCwgYDFgLCBhbmQgYC0xYC5cbiAqXG4gKiBJZiBhIHN0cmluZyBpcyBwYXNzZWQsIGl0IG11c3QgYmUgYSBzcGFjZSBkZWxpbWl0ZWQgbGlzdCBvZiBwYXRoIG5hbWVzLiBUaGVcbiAqIHNvcnQgb3JkZXIgb2YgZWFjaCBwYXRoIGlzIGFzY2VuZGluZyB1bmxlc3MgdGhlIHBhdGggbmFtZSBpcyBwcmVmaXhlZCB3aXRoIGAtYFxuICogd2hpY2ggd2lsbCBiZSB0cmVhdGVkIGFzIGRlc2NlbmRpbmcuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICAvLyBzb3J0IGJ5IFwiZmllbGRcIiBhc2NlbmRpbmcgYW5kIFwidGVzdFwiIGRlc2NlbmRpbmdcbiAqICAgICBxdWVyeS5zb3J0KHsgZmllbGQ6ICdhc2MnLCB0ZXN0OiAtMSB9KTtcbiAqXG4gKiAgICAgLy8gZXF1aXZhbGVudFxuICogICAgIHF1ZXJ5LnNvcnQoJ2ZpZWxkIC10ZXN0Jyk7XG4gKlxuICogICAgIC8vIGFsc28gcG9zc2libGUgaXMgdG8gdXNlIGEgYXJyYXkgd2l0aCBhcnJheSBrZXktdmFsdWUgcGFpcnNcbiAqICAgICBxdWVyeS5zb3J0KFtbJ2ZpZWxkJywgJ2FzYyddXSk7XG4gKlxuICogIyMjIyBOb3RlOlxuICpcbiAqIENhbm5vdCBiZSB1c2VkIHdpdGggYGRpc3RpbmN0KClgXG4gKlxuICogQHBhcmFtIHtPYmplY3R8U3RyaW5nfEFycmF5PEFycmF5PChzdHJpbmcgfCBudW1iZXIpPj59IGFyZ1xuICogQHJldHVybiB7UXVlcnl9IHRoaXNcbiAqIEBzZWUgY3Vyc29yLnNvcnQgaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvcmVmZXJlbmNlL21ldGhvZC9jdXJzb3Iuc29ydC9cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUXVlcnkucHJvdG90eXBlLnNvcnQgPSBmdW5jdGlvbihhcmcpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdzb3J0KCkgb25seSB0YWtlcyAxIEFyZ3VtZW50Jyk7XG4gIH1cblxuICBpZiAodGhpcy5vcHRpb25zLnNvcnQgPT0gbnVsbCkge1xuICAgIHRoaXMub3B0aW9ucy5zb3J0ID0ge307XG4gIH1cbiAgY29uc3Qgc29ydCA9IHRoaXMub3B0aW9ucy5zb3J0O1xuICBpZiAodHlwZW9mIGFyZyA9PT0gJ3N0cmluZycpIHtcbiAgICBjb25zdCBwcm9wZXJ0aWVzID0gYXJnLmluZGV4T2YoJyAnKSA9PT0gLTEgPyBbYXJnXSA6IGFyZy5zcGxpdCgnICcpO1xuICAgIGZvciAobGV0IHByb3BlcnR5IG9mIHByb3BlcnRpZXMpIHtcbiAgICAgIGNvbnN0IGFzY2VuZCA9ICctJyA9PSBwcm9wZXJ0eVswXSA/IC0xIDogMTtcbiAgICAgIGlmIChhc2NlbmQgPT09IC0xKSB7XG4gICAgICAgIHByb3BlcnR5ID0gcHJvcGVydHkuc2xpY2UoMSk7XG4gICAgICB9XG4gICAgICBpZiAoc3BlY2lhbFByb3BlcnRpZXMuaGFzKHByb3BlcnR5KSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHNvcnRbcHJvcGVydHldID0gYXNjZW5kO1xuICAgIH1cbiAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGFyZykpIHtcbiAgICBmb3IgKGNvbnN0IHBhaXIgb2YgYXJnKSB7XG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkocGFpcikpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBzb3J0KCkgYXJndW1lbnQsIG11c3QgYmUgYXJyYXkgb2YgYXJyYXlzJyk7XG4gICAgICB9XG4gICAgICBjb25zdCBrZXkgPSAnJyArIHBhaXJbMF07XG4gICAgICBpZiAoc3BlY2lhbFByb3BlcnRpZXMuaGFzKGtleSkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBzb3J0W2tleV0gPSBfaGFuZGxlU29ydFZhbHVlKHBhaXJbMV0sIGtleSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGVvZiBhcmcgPT09ICdvYmplY3QnICYmIGFyZyAhPSBudWxsICYmICEoYXJnIGluc3RhbmNlb2YgTWFwKSkge1xuICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKGFyZykpIHtcbiAgICAgIGlmIChzcGVjaWFsUHJvcGVydGllcy5oYXMoa2V5KSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHNvcnRba2V5XSA9IF9oYW5kbGVTb3J0VmFsdWUoYXJnW2tleV0sIGtleSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGFyZyBpbnN0YW5jZW9mIE1hcCkge1xuICAgIGZvciAobGV0IGtleSBvZiBhcmcua2V5cygpKSB7XG4gICAgICBrZXkgPSAnJyArIGtleTtcbiAgICAgIGlmIChzcGVjaWFsUHJvcGVydGllcy5oYXMoa2V5KSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHNvcnRba2V5XSA9IF9oYW5kbGVTb3J0VmFsdWUoYXJnLmdldChrZXkpLCBrZXkpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChhcmcgIT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgc29ydCgpIGFyZ3VtZW50LiBNdXN0IGJlIGEgc3RyaW5nLCBvYmplY3QsIGFycmF5LCBvciBtYXAuJyk7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qIVxuICogQ29udmVydCBzb3J0IHZhbHVlc1xuICovXG5cbmZ1bmN0aW9uIF9oYW5kbGVTb3J0VmFsdWUodmFsLCBrZXkpIHtcbiAgaWYgKHZhbCA9PT0gMSB8fCB2YWwgPT09ICdhc2MnIHx8IHZhbCA9PT0gJ2FzY2VuZGluZycpIHtcbiAgICByZXR1cm4gMTtcbiAgfVxuICBpZiAodmFsID09PSAtMSB8fCB2YWwgPT09ICdkZXNjJyB8fCB2YWwgPT09ICdkZXNjZW5kaW5nJykge1xuICAgIHJldHVybiAtMTtcbiAgfVxuICBpZiAodmFsPy4kbWV0YSAhPSBudWxsKSB7XG4gICAgcmV0dXJuIHsgJG1ldGE6IHZhbC4kbWV0YSB9O1xuICB9XG4gIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgc29ydCB2YWx1ZTogeyAnICsga2V5ICsgJzogJyArIHZhbCArICcgfScpO1xufVxuXG4vKipcbiAqIERlY2xhcmUgYW5kL29yIGV4ZWN1dGUgdGhpcyBxdWVyeSBhcyBhIGBkZWxldGVPbmUoKWAgb3BlcmF0aW9uLiBXb3JrcyBsaWtlXG4gKiByZW1vdmUsIGV4Y2VwdCBpdCBkZWxldGVzIGF0IG1vc3Qgb25lIGRvY3VtZW50IHJlZ2FyZGxlc3Mgb2YgdGhlIGBzaW5nbGVgXG4gKiBvcHRpb24uXG4gKlxuICogVGhpcyBmdW5jdGlvbiB0cmlnZ2VycyBgZGVsZXRlT25lYCBtaWRkbGV3YXJlLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgYXdhaXQgQ2hhcmFjdGVyLmRlbGV0ZU9uZSh7IG5hbWU6ICdFZGRhcmQgU3RhcmsnIH0pO1xuICpcbiAqIFRoaXMgZnVuY3Rpb24gY2FsbHMgdGhlIE1vbmdvREIgZHJpdmVyJ3MgW2BDb2xsZWN0aW9uI2RlbGV0ZU9uZSgpYCBmdW5jdGlvbl0oaHR0cHM6Ly9tb25nb2RiLmdpdGh1Yi5pby9ub2RlLW1vbmdvZGItbmF0aXZlLzQuOS9jbGFzc2VzL0NvbGxlY3Rpb24uaHRtbCNkZWxldGVPbmUpLlxuICogVGhlIHJldHVybmVkIFtwcm9taXNlXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvcXVlcmllcy5odG1sKSByZXNvbHZlcyB0byBhblxuICogb2JqZWN0IHRoYXQgY29udGFpbnMgMyBwcm9wZXJ0aWVzOlxuICpcbiAqIC0gYG9rYDogYDFgIGlmIG5vIGVycm9ycyBvY2N1cnJlZFxuICogLSBgZGVsZXRlZENvdW50YDogdGhlIG51bWJlciBvZiBkb2N1bWVudHMgZGVsZXRlZFxuICogLSBgbmA6IHRoZSBudW1iZXIgb2YgZG9jdW1lbnRzIGRlbGV0ZWQuIEVxdWFsIHRvIGBkZWxldGVkQ291bnRgLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgY29uc3QgcmVzID0gYXdhaXQgQ2hhcmFjdGVyLmRlbGV0ZU9uZSh7IG5hbWU6ICdFZGRhcmQgU3RhcmsnIH0pO1xuICogICAgIC8vIGAxYCBpZiBNb25nb0RCIGRlbGV0ZWQgYSBkb2MsIGAwYCBpZiBubyBkb2NzIG1hdGNoZWQgdGhlIGZpbHRlciBgeyBuYW1lOiAuLi4gfWBcbiAqICAgICByZXMuZGVsZXRlZENvdW50O1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fFF1ZXJ5fSBbZmlsdGVyXSBtb25nb2RiIHNlbGVjdG9yXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIG9wdGlvbmFsIHNlZSBbYFF1ZXJ5LnByb3RvdHlwZS5zZXRPcHRpb25zKClgXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvYXBpL3F1ZXJ5Lmh0bWwjUXVlcnkucHJvdG90eXBlLnNldE9wdGlvbnMoKSlcbiAqIEByZXR1cm4ge1F1ZXJ5fSB0aGlzXG4gKiBAc2VlIERlbGV0ZVJlc3VsdCBodHRwczovL21vbmdvZGIuZ2l0aHViLmlvL25vZGUtbW9uZ29kYi1uYXRpdmUvNC45L2ludGVyZmFjZXMvRGVsZXRlUmVzdWx0Lmh0bWxcbiAqIEBzZWUgZGVsZXRlT25lIGh0dHBzOi8vbW9uZ29kYi5naXRodWIuaW8vbm9kZS1tb25nb2RiLW5hdGl2ZS80LjkvY2xhc3Nlcy9Db2xsZWN0aW9uLmh0bWwjZGVsZXRlT25lXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblF1ZXJ5LnByb3RvdHlwZS5kZWxldGVPbmUgPSBmdW5jdGlvbiBkZWxldGVPbmUoZmlsdGVyLCBvcHRpb25zKSB7XG4gIGlmICh0eXBlb2YgZmlsdGVyID09PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBhcmd1bWVudHNbMl0gPT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgTW9uZ29vc2VFcnJvcignUXVlcnkucHJvdG90eXBlLmRlbGV0ZU9uZSgpIG5vIGxvbmdlciBhY2NlcHRzIGEgY2FsbGJhY2snKTtcbiAgfVxuICB0aGlzLm9wID0gJ2RlbGV0ZU9uZSc7XG4gIHRoaXMuc2V0T3B0aW9ucyhvcHRpb25zKTtcblxuICBpZiAobXF1ZXJ5LmNhbk1lcmdlKGZpbHRlcikpIHtcbiAgICB0aGlzLm1lcmdlKGZpbHRlcik7XG5cbiAgICBwcmVwYXJlRGlzY3JpbWluYXRvckNyaXRlcmlhKHRoaXMpO1xuICB9IGVsc2UgaWYgKGZpbHRlciAhPSBudWxsKSB7XG4gICAgdGhpcy5lcnJvcihuZXcgT2JqZWN0UGFyYW1ldGVyRXJyb3IoZmlsdGVyLCAnZmlsdGVyJywgJ2RlbGV0ZU9uZScpKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBJbnRlcm5hbCB0aHVuayBmb3IgYGRlbGV0ZU9uZSgpYFxuICpcbiAqIEBtZXRob2QgX2RlbGV0ZU9uZVxuICogQGluc3RhbmNlXG4gKiBAbWVtYmVyT2YgUXVlcnlcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblF1ZXJ5LnByb3RvdHlwZS5fZGVsZXRlT25lID0gYXN5bmMgZnVuY3Rpb24gX2RlbGV0ZU9uZSgpIHtcbiAgdGhpcy5fY2FzdENvbmRpdGlvbnMoKTtcblxuICBpZiAodGhpcy5lcnJvcigpICE9IG51bGwpIHtcbiAgICB0aHJvdyB0aGlzLmVycm9yKCk7XG4gIH1cblxuICBjb25zdCBvcHRpb25zID0gdGhpcy5fb3B0aW9uc0ZvckV4ZWMoKTtcbiAgdGhpcy5fYXBwbHlUcmFuc2xhdGVBbGlhc2VzKG9wdGlvbnMpO1xuXG4gIHJldHVybiB0aGlzLm1vbmdvb3NlQ29sbGVjdGlvbi5kZWxldGVPbmUodGhpcy5fY29uZGl0aW9ucywgb3B0aW9ucyk7XG59O1xuXG4vKipcbiAqIERlY2xhcmUgYW5kL29yIGV4ZWN1dGUgdGhpcyBxdWVyeSBhcyBhIGBkZWxldGVNYW55KClgIG9wZXJhdGlvbi4gV29ya3MgbGlrZVxuICogcmVtb3ZlLCBleGNlcHQgaXQgZGVsZXRlcyBfZXZlcnlfIGRvY3VtZW50IHRoYXQgbWF0Y2hlcyBgZmlsdGVyYCBpbiB0aGVcbiAqIGNvbGxlY3Rpb24sIHJlZ2FyZGxlc3Mgb2YgdGhlIHZhbHVlIG9mIGBzaW5nbGVgLlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gdHJpZ2dlcnMgYGRlbGV0ZU1hbnlgIG1pZGRsZXdhcmUuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBhd2FpdCBDaGFyYWN0ZXIuZGVsZXRlTWFueSh7IG5hbWU6IC9TdGFyay8sIGFnZTogeyAkZ3RlOiAxOCB9IH0pO1xuICpcbiAqIFRoaXMgZnVuY3Rpb24gY2FsbHMgdGhlIE1vbmdvREIgZHJpdmVyJ3MgW2BDb2xsZWN0aW9uI2RlbGV0ZU1hbnkoKWAgZnVuY3Rpb25dKGh0dHBzOi8vbW9uZ29kYi5naXRodWIuaW8vbm9kZS1tb25nb2RiLW5hdGl2ZS80LjkvY2xhc3Nlcy9Db2xsZWN0aW9uLmh0bWwjZGVsZXRlTWFueSkuXG4gKiBUaGUgcmV0dXJuZWQgW3Byb21pc2VdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9xdWVyaWVzLmh0bWwpIHJlc29sdmVzIHRvIGFuXG4gKiBvYmplY3QgdGhhdCBjb250YWlucyAzIHByb3BlcnRpZXM6XG4gKlxuICogLSBgb2tgOiBgMWAgaWYgbm8gZXJyb3JzIG9jY3VycmVkXG4gKiAtIGBkZWxldGVkQ291bnRgOiB0aGUgbnVtYmVyIG9mIGRvY3VtZW50cyBkZWxldGVkXG4gKiAtIGBuYDogdGhlIG51bWJlciBvZiBkb2N1bWVudHMgZGVsZXRlZC4gRXF1YWwgdG8gYGRlbGV0ZWRDb3VudGAuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBjb25zdCByZXMgPSBhd2FpdCBDaGFyYWN0ZXIuZGVsZXRlTWFueSh7IG5hbWU6IC9TdGFyay8sIGFnZTogeyAkZ3RlOiAxOCB9IH0pO1xuICogICAgIC8vIGAwYCBpZiBubyBkb2NzIG1hdGNoZWQgdGhlIGZpbHRlciwgbnVtYmVyIG9mIGRvY3MgZGVsZXRlZCBvdGhlcndpc2VcbiAqICAgICByZXMuZGVsZXRlZENvdW50O1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fFF1ZXJ5fSBbZmlsdGVyXSBtb25nb2RiIHNlbGVjdG9yXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIG9wdGlvbmFsIHNlZSBbYFF1ZXJ5LnByb3RvdHlwZS5zZXRPcHRpb25zKClgXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvYXBpL3F1ZXJ5Lmh0bWwjUXVlcnkucHJvdG90eXBlLnNldE9wdGlvbnMoKSlcbiAqIEByZXR1cm4ge1F1ZXJ5fSB0aGlzXG4gKiBAc2VlIERlbGV0ZVJlc3VsdCBodHRwczovL21vbmdvZGIuZ2l0aHViLmlvL25vZGUtbW9uZ29kYi1uYXRpdmUvNC45L2ludGVyZmFjZXMvRGVsZXRlUmVzdWx0Lmh0bWxcbiAqIEBzZWUgZGVsZXRlTWFueSBodHRwczovL21vbmdvZGIuZ2l0aHViLmlvL25vZGUtbW9uZ29kYi1uYXRpdmUvNC45L2NsYXNzZXMvQ29sbGVjdGlvbi5odG1sI2RlbGV0ZU1hbnlcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUXVlcnkucHJvdG90eXBlLmRlbGV0ZU1hbnkgPSBmdW5jdGlvbihmaWx0ZXIsIG9wdGlvbnMpIHtcbiAgaWYgKHR5cGVvZiBmaWx0ZXIgPT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIGFyZ3VtZW50c1syXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBNb25nb29zZUVycm9yKCdRdWVyeS5wcm90b3R5cGUuZGVsZXRlTWFueSgpIG5vIGxvbmdlciBhY2NlcHRzIGEgY2FsbGJhY2snKTtcbiAgfVxuICB0aGlzLnNldE9wdGlvbnMob3B0aW9ucyk7XG4gIHRoaXMub3AgPSAnZGVsZXRlTWFueSc7XG5cbiAgaWYgKG1xdWVyeS5jYW5NZXJnZShmaWx0ZXIpKSB7XG4gICAgdGhpcy5tZXJnZShmaWx0ZXIpO1xuXG4gICAgcHJlcGFyZURpc2NyaW1pbmF0b3JDcml0ZXJpYSh0aGlzKTtcbiAgfSBlbHNlIGlmIChmaWx0ZXIgIT0gbnVsbCkge1xuICAgIHRoaXMuZXJyb3IobmV3IE9iamVjdFBhcmFtZXRlckVycm9yKGZpbHRlciwgJ2ZpbHRlcicsICdkZWxldGVNYW55JykpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEV4ZWN1dGUgYSBgZGVsZXRlTWFueSgpYCBxdWVyeVxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gKiBAbWV0aG9kIF9kZWxldGVNYW55XG4gKiBAaW5zdGFuY2VcbiAqIEBtZW1iZXJPZiBRdWVyeVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuUXVlcnkucHJvdG90eXBlLl9kZWxldGVNYW55ID0gYXN5bmMgZnVuY3Rpb24gX2RlbGV0ZU1hbnkoKSB7XG4gIHRoaXMuX2Nhc3RDb25kaXRpb25zKCk7XG5cbiAgaWYgKHRoaXMuZXJyb3IoKSAhPSBudWxsKSB7XG4gICAgdGhyb3cgdGhpcy5lcnJvcigpO1xuICB9XG5cbiAgY29uc3Qgb3B0aW9ucyA9IHRoaXMuX29wdGlvbnNGb3JFeGVjKCk7XG4gIHRoaXMuX2FwcGx5VHJhbnNsYXRlQWxpYXNlcyhvcHRpb25zKTtcblxuICByZXR1cm4gdGhpcy5tb25nb29zZUNvbGxlY3Rpb24uZGVsZXRlTWFueSh0aGlzLl9jb25kaXRpb25zLCBvcHRpb25zKTtcbn07XG5cbi8qKlxuICogaHlkcmF0ZXMgYSBkb2N1bWVudFxuICpcbiAqIEBwYXJhbSB7TW9kZWx9IG1vZGVsXG4gKiBAcGFyYW0ge0RvY3VtZW50fSBkb2NcbiAqIEBwYXJhbSB7T2JqZWN0fSByZXMgM3JkIHBhcmFtZXRlciB0byBjYWxsYmFja1xuICogQHBhcmFtIHtPYmplY3R9IGZpZWxkc1xuICogQHBhcmFtIHtRdWVyeX0gc2VsZlxuICogQHBhcmFtIHtBcnJheX0gW3BvcF0gYXJyYXkgb2YgcGF0aHMgdXNlZCBpbiBwb3B1bGF0aW9uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gY29tcGxldGVPbmUobW9kZWwsIGRvYywgcmVzLCBvcHRpb25zLCBmaWVsZHMsIHVzZXJQcm92aWRlZEZpZWxkcywgcG9wLCBjYWxsYmFjaykge1xuICBpZiAob3B0aW9ucy5pbmNsdWRlUmVzdWx0TWV0YWRhdGEgJiYgZG9jID09IG51bGwpIHtcbiAgICBfaW5pdChudWxsKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGhlbHBlcnMuY3JlYXRlTW9kZWxBbmRJbml0KG1vZGVsLCBkb2MsIGZpZWxkcywgdXNlclByb3ZpZGVkRmllbGRzLCBvcHRpb25zLCBwb3AsIF9pbml0KTtcblxuICBmdW5jdGlvbiBfaW5pdChlcnIsIGNhc3RlZCkge1xuICAgIGlmIChlcnIpIHtcbiAgICAgIHJldHVybiBpbW1lZGlhdGUoKCkgPT4gY2FsbGJhY2soZXJyKSk7XG4gICAgfVxuXG5cbiAgICBpZiAob3B0aW9ucy5pbmNsdWRlUmVzdWx0TWV0YWRhdGEpIHtcbiAgICAgIGlmIChkb2MgJiYgY2FzdGVkKSB7XG4gICAgICAgIGlmIChvcHRpb25zLnNlc3Npb24gIT0gbnVsbCkge1xuICAgICAgICAgIGNhc3RlZC4kc2Vzc2lvbihvcHRpb25zLnNlc3Npb24pO1xuICAgICAgICB9XG4gICAgICAgIHJlcy52YWx1ZSA9IGNhc3RlZDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlcy52YWx1ZSA9IG51bGw7XG4gICAgICB9XG4gICAgICByZXR1cm4gaW1tZWRpYXRlKCgpID0+IGNhbGxiYWNrKG51bGwsIHJlcykpO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5zZXNzaW9uICE9IG51bGwpIHtcbiAgICAgIGNhc3RlZC4kc2Vzc2lvbihvcHRpb25zLnNlc3Npb24pO1xuICAgIH1cbiAgICBpbW1lZGlhdGUoKCkgPT4gY2FsbGJhY2sobnVsbCwgY2FzdGVkKSk7XG4gIH1cbn1cblxuLyoqXG4gKiBJZiB0aGUgbW9kZWwgaXMgYSBkaXNjcmltaW5hdG9yIHR5cGUgYW5kIG5vdCByb290LCB0aGVuIGFkZCB0aGUga2V5ICYgdmFsdWUgdG8gdGhlIGNyaXRlcmlhLlxuICogQHBhcmFtIHtRdWVyeX0gcXVlcnlcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHByZXBhcmVEaXNjcmltaW5hdG9yQ3JpdGVyaWEocXVlcnkpIHtcbiAgaWYgKCFxdWVyeSB8fCAhcXVlcnkubW9kZWwgfHwgIXF1ZXJ5Lm1vZGVsLnNjaGVtYSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGNvbnN0IHNjaGVtYSA9IHF1ZXJ5Lm1vZGVsLnNjaGVtYTtcblxuICBpZiAoc2NoZW1hICYmIHNjaGVtYS5kaXNjcmltaW5hdG9yTWFwcGluZyAmJiAhc2NoZW1hLmRpc2NyaW1pbmF0b3JNYXBwaW5nLmlzUm9vdCkge1xuICAgIHF1ZXJ5Ll9jb25kaXRpb25zW3NjaGVtYS5kaXNjcmltaW5hdG9yTWFwcGluZy5rZXldID0gc2NoZW1hLmRpc2NyaW1pbmF0b3JNYXBwaW5nLnZhbHVlO1xuICB9XG59XG5cbi8qKlxuICogSXNzdWVzIGEgbW9uZ29kYiBgZmluZE9uZUFuZFVwZGF0ZSgpYCBjb21tYW5kLlxuICpcbiAqIEZpbmRzIGEgbWF0Y2hpbmcgZG9jdW1lbnQsIHVwZGF0ZXMgaXQgYWNjb3JkaW5nIHRvIHRoZSBgdXBkYXRlYCBhcmcsIHBhc3NpbmcgYW55IGBvcHRpb25zYCwgYW5kIHJldHVybnMgdGhlIGZvdW5kXG4gKiBkb2N1bWVudCAoaWYgYW55KS5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIHRyaWdnZXJzIHRoZSBmb2xsb3dpbmcgbWlkZGxld2FyZS5cbiAqXG4gKiAtIGBmaW5kT25lQW5kVXBkYXRlKClgXG4gKlxuICogIyMjIyBBdmFpbGFibGUgb3B0aW9uc1xuICpcbiAqIC0gYG5ld2A6IGJvb2wgLSBpZiB0cnVlLCByZXR1cm4gdGhlIG1vZGlmaWVkIGRvY3VtZW50IHJhdGhlciB0aGFuIHRoZSBvcmlnaW5hbC4gZGVmYXVsdHMgdG8gZmFsc2UgKGNoYW5nZWQgaW4gNC4wKVxuICogLSBgdXBzZXJ0YDogYm9vbCAtIGNyZWF0ZXMgdGhlIG9iamVjdCBpZiBpdCBkb2Vzbid0IGV4aXN0LiBkZWZhdWx0cyB0byBmYWxzZS5cbiAqIC0gYGZpZWxkc2A6IHtPYmplY3R8U3RyaW5nfSAtIEZpZWxkIHNlbGVjdGlvbi4gRXF1aXZhbGVudCB0byBgLnNlbGVjdChmaWVsZHMpLmZpbmRPbmVBbmRVcGRhdGUoKWBcbiAqIC0gYHNvcnRgOiBpZiBtdWx0aXBsZSBkb2NzIGFyZSBmb3VuZCBieSB0aGUgY29uZGl0aW9ucywgc2V0cyB0aGUgc29ydCBvcmRlciB0byBjaG9vc2Ugd2hpY2ggZG9jIHRvIHVwZGF0ZVxuICogLSBgbWF4VGltZU1TYDogcHV0cyBhIHRpbWUgbGltaXQgb24gdGhlIHF1ZXJ5IC0gcmVxdWlyZXMgbW9uZ29kYiA+PSAyLjYuMFxuICogLSBgcnVuVmFsaWRhdG9yc2A6IGlmIHRydWUsIHJ1bnMgW3VwZGF0ZSB2YWxpZGF0b3JzXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvdmFsaWRhdGlvbi5odG1sI3VwZGF0ZS12YWxpZGF0b3JzKSBvbiB0aGlzIGNvbW1hbmQuIFVwZGF0ZSB2YWxpZGF0b3JzIHZhbGlkYXRlIHRoZSB1cGRhdGUgb3BlcmF0aW9uIGFnYWluc3QgdGhlIG1vZGVsJ3Mgc2NoZW1hLlxuICogLSBgc2V0RGVmYXVsdHNPbkluc2VydGA6IGB0cnVlYCBieSBkZWZhdWx0LiBJZiBgc2V0RGVmYXVsdHNPbkluc2VydGAgYW5kIGB1cHNlcnRgIGFyZSB0cnVlLCBtb25nb29zZSB3aWxsIGFwcGx5IHRoZSBbZGVmYXVsdHNdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9kZWZhdWx0cy5odG1sKSBzcGVjaWZpZWQgaW4gdGhlIG1vZGVsJ3Mgc2NoZW1hIGlmIGEgbmV3IGRvY3VtZW50IGlzIGNyZWF0ZWQuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBxdWVyeS5maW5kT25lQW5kVXBkYXRlKGNvbmRpdGlvbnMsIHVwZGF0ZSwgb3B0aW9ucykgIC8vIHJldHVybnMgUXVlcnlcbiAqICAgICBxdWVyeS5maW5kT25lQW5kVXBkYXRlKGNvbmRpdGlvbnMsIHVwZGF0ZSkgICAgICAgICAgIC8vIHJldHVybnMgUXVlcnlcbiAqICAgICBxdWVyeS5maW5kT25lQW5kVXBkYXRlKHVwZGF0ZSkgICAgICAgICAgICAgICAgICAgICAgIC8vIHJldHVybnMgUXVlcnlcbiAqICAgICBxdWVyeS5maW5kT25lQW5kVXBkYXRlKCkgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJldHVybnMgUXVlcnlcbiAqXG4gKiBAbWV0aG9kIGZpbmRPbmVBbmRVcGRhdGVcbiAqIEBtZW1iZXJPZiBRdWVyeVxuICogQGluc3RhbmNlXG4gKiBAcGFyYW0ge09iamVjdHxRdWVyeX0gW2ZpbHRlcl1cbiAqIEBwYXJhbSB7T2JqZWN0fSBbZG9jXVxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5pbmNsdWRlUmVzdWx0TWV0YWRhdGFdIGlmIHRydWUsIHJldHVybnMgdGhlIGZ1bGwgW01vZGlmeVJlc3VsdCBmcm9tIHRoZSBNb25nb0RCIGRyaXZlcl0oaHR0cHM6Ly9tb25nb2RiLmdpdGh1Yi5pby9ub2RlLW1vbmdvZGItbmF0aXZlLzQuOS9pbnRlcmZhY2VzL01vZGlmeVJlc3VsdC5odG1sKSByYXRoZXIgdGhhbiBqdXN0IHRoZSBkb2N1bWVudFxuICogQHBhcmFtIHtCb29sZWFufFN0cmluZ30gW29wdGlvbnMuc3RyaWN0XSBvdmVyd3JpdGVzIHRoZSBzY2hlbWEncyBbc3RyaWN0IG1vZGUgb3B0aW9uXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvZ3VpZGUuaHRtbCNzdHJpY3QpXG4gKiBAcGFyYW0ge0NsaWVudFNlc3Npb259IFtvcHRpb25zLnNlc3Npb249bnVsbF0gVGhlIHNlc3Npb24gYXNzb2NpYXRlZCB3aXRoIHRoaXMgcXVlcnkuIFNlZSBbdHJhbnNhY3Rpb25zIGRvY3NdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy90cmFuc2FjdGlvbnMuaHRtbCkuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLm11bHRpcGxlQ2FzdEVycm9yXSBieSBkZWZhdWx0LCBtb25nb29zZSBvbmx5IHJldHVybnMgdGhlIGZpcnN0IGVycm9yIHRoYXQgb2NjdXJyZWQgaW4gY2FzdGluZyB0aGUgcXVlcnkuIFR1cm4gb24gdGhpcyBvcHRpb24gdG8gYWdncmVnYXRlIGFsbCB0aGUgY2FzdCBlcnJvcnMuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLm5ldz1mYWxzZV0gQnkgZGVmYXVsdCwgYGZpbmRPbmVBbmRVcGRhdGUoKWAgcmV0dXJucyB0aGUgZG9jdW1lbnQgYXMgaXQgd2FzICoqYmVmb3JlKiogYHVwZGF0ZWAgd2FzIGFwcGxpZWQuIElmIHlvdSBzZXQgYG5ldzogdHJ1ZWAsIGBmaW5kT25lQW5kVXBkYXRlKClgIHdpbGwgaW5zdGVhZCBnaXZlIHlvdSB0aGUgb2JqZWN0IGFmdGVyIGB1cGRhdGVgIHdhcyBhcHBsaWVkLlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLmxlYW5dIGlmIHRydXRoeSwgbW9uZ29vc2Ugd2lsbCByZXR1cm4gdGhlIGRvY3VtZW50IGFzIGEgcGxhaW4gSmF2YVNjcmlwdCBvYmplY3QgcmF0aGVyIHRoYW4gYSBtb25nb29zZSBkb2N1bWVudC4gU2VlIFtgUXVlcnkubGVhbigpYF0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2FwaS9xdWVyeS5odG1sI1F1ZXJ5LnByb3RvdHlwZS5sZWFuKCkpIGFuZCBbdGhlIE1vbmdvb3NlIGxlYW4gdHV0b3JpYWxdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy90dXRvcmlhbHMvbGVhbi5odG1sKS5cbiAqIEBwYXJhbSB7Q2xpZW50U2Vzc2lvbn0gW29wdGlvbnMuc2Vzc2lvbj1udWxsXSBUaGUgc2Vzc2lvbiBhc3NvY2lhdGVkIHdpdGggdGhpcyBxdWVyeS4gU2VlIFt0cmFuc2FjdGlvbnMgZG9jc10oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL3RyYW5zYWN0aW9ucy5odG1sKS5cbiAqIEBwYXJhbSB7Qm9vbGVhbnxTdHJpbmd9IFtvcHRpb25zLnN0cmljdF0gb3ZlcndyaXRlcyB0aGUgc2NoZW1hJ3MgW3N0cmljdCBtb2RlIG9wdGlvbl0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2d1aWRlLmh0bWwjc3RyaWN0KVxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy50aW1lc3RhbXBzPW51bGxdIElmIHNldCB0byBgZmFsc2VgIGFuZCBbc2NoZW1hLWxldmVsIHRpbWVzdGFtcHNdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9ndWlkZS5odG1sI3RpbWVzdGFtcHMpIGFyZSBlbmFibGVkLCBza2lwIHRpbWVzdGFtcHMgZm9yIHRoaXMgdXBkYXRlLiBOb3RlIHRoYXQgdGhpcyBhbGxvd3MgeW91IHRvIG92ZXJ3cml0ZSB0aW1lc3RhbXBzLiBEb2VzIG5vdGhpbmcgaWYgc2NoZW1hLWxldmVsIHRpbWVzdGFtcHMgYXJlIG5vdCBzZXQuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnJldHVybk9yaWdpbmFsPW51bGxdIEFuIGFsaWFzIGZvciB0aGUgYG5ld2Agb3B0aW9uLiBgcmV0dXJuT3JpZ2luYWw6IGZhbHNlYCBpcyBlcXVpdmFsZW50IHRvIGBuZXc6IHRydWVgLlxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy50cmFuc2xhdGVBbGlhc2VzPW51bGxdIElmIHNldCB0byBgdHJ1ZWAsIHRyYW5zbGF0ZXMgYW55IHNjaGVtYS1kZWZpbmVkIGFsaWFzZXMgaW4gYGZpbHRlcmAsIGBwcm9qZWN0aW9uYCwgYHVwZGF0ZWAsIGFuZCBgZGlzdGluY3RgLiBUaHJvd3MgYW4gZXJyb3IgaWYgdGhlcmUgYXJlIGFueSBjb25mbGljdHMgd2hlcmUgYm90aCBhbGlhcyBhbmQgcmF3IHByb3BlcnR5IGFyZSBkZWZpbmVkIG9uIHRoZSBzYW1lIG9iamVjdC5cbiAqIEBzZWUgVHV0b3JpYWwgaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL3R1dG9yaWFscy9maW5kb25lYW5kdXBkYXRlLmh0bWxcbiAqIEBzZWUgZmluZEFuZE1vZGlmeSBjb21tYW5kIGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvbWFudWFsL3JlZmVyZW5jZS9jb21tYW5kL2ZpbmRBbmRNb2RpZnkvXG4gKiBAc2VlIE1vZGlmeVJlc3VsdCBodHRwczovL21vbmdvZGIuZ2l0aHViLmlvL25vZGUtbW9uZ29kYi1uYXRpdmUvNC45L2ludGVyZmFjZXMvTW9kaWZ5UmVzdWx0Lmh0bWxcbiAqIEBzZWUgZmluZE9uZUFuZFVwZGF0ZSBodHRwczovL21vbmdvZGIuZ2l0aHViLmlvL25vZGUtbW9uZ29kYi1uYXRpdmUvNC45L2NsYXNzZXMvQ29sbGVjdGlvbi5odG1sI2ZpbmRPbmVBbmRVcGRhdGVcbiAqIEByZXR1cm4ge1F1ZXJ5fSB0aGlzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblF1ZXJ5LnByb3RvdHlwZS5maW5kT25lQW5kVXBkYXRlID0gZnVuY3Rpb24oZmlsdGVyLCBkb2MsIG9wdGlvbnMpIHtcbiAgaWYgKHR5cGVvZiBmaWx0ZXIgPT09ICdmdW5jdGlvbicgfHxcbiAgICAgIHR5cGVvZiBkb2MgPT09ICdmdW5jdGlvbicgfHxcbiAgICAgIHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nIHx8XG4gICAgICB0eXBlb2YgYXJndW1lbnRzWzNdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IE1vbmdvb3NlRXJyb3IoJ1F1ZXJ5LnByb3RvdHlwZS5maW5kT25lQW5kVXBkYXRlKCkgbm8gbG9uZ2VyIGFjY2VwdHMgYSBjYWxsYmFjaycpO1xuICB9XG5cbiAgdGhpcy5vcCA9ICdmaW5kT25lQW5kVXBkYXRlJztcbiAgdGhpcy5fdmFsaWRhdGVPcCgpO1xuICB0aGlzLl92YWxpZGF0ZSgpO1xuXG4gIHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgIGNhc2UgMjpcbiAgICAgIG9wdGlvbnMgPSB1bmRlZmluZWQ7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDE6XG4gICAgICBkb2MgPSBmaWx0ZXI7XG4gICAgICBmaWx0ZXIgPSBvcHRpb25zID0gdW5kZWZpbmVkO1xuICAgICAgYnJlYWs7XG4gIH1cblxuICBpZiAobXF1ZXJ5LmNhbk1lcmdlKGZpbHRlcikpIHtcbiAgICB0aGlzLm1lcmdlKGZpbHRlcik7XG4gIH0gZWxzZSBpZiAoZmlsdGVyICE9IG51bGwpIHtcbiAgICB0aGlzLmVycm9yKFxuICAgICAgbmV3IE9iamVjdFBhcmFtZXRlckVycm9yKGZpbHRlciwgJ2ZpbHRlcicsICdmaW5kT25lQW5kVXBkYXRlJylcbiAgICApO1xuICB9XG5cbiAgLy8gYXBwbHkgZG9jXG4gIGlmIChkb2MpIHtcbiAgICB0aGlzLl9tZXJnZVVwZGF0ZShkb2MpO1xuICB9XG5cbiAgb3B0aW9ucyA9IG9wdGlvbnMgPyBjbG9uZShvcHRpb25zKSA6IHt9O1xuXG4gIGlmIChvcHRpb25zLnByb2plY3Rpb24pIHtcbiAgICB0aGlzLnNlbGVjdChvcHRpb25zLnByb2plY3Rpb24pO1xuICAgIGRlbGV0ZSBvcHRpb25zLnByb2plY3Rpb247XG4gIH1cbiAgaWYgKG9wdGlvbnMuZmllbGRzKSB7XG4gICAgdGhpcy5zZWxlY3Qob3B0aW9ucy5maWVsZHMpO1xuICAgIGRlbGV0ZSBvcHRpb25zLmZpZWxkcztcbiAgfVxuXG4gIGNvbnN0IHJldHVybk9yaWdpbmFsID0gdGhpcyAmJlxuICAgIHRoaXMubW9kZWwgJiZcbiAgICB0aGlzLm1vZGVsLmJhc2UgJiZcbiAgICB0aGlzLm1vZGVsLmJhc2Uub3B0aW9ucyAmJlxuICAgIHRoaXMubW9kZWwuYmFzZS5vcHRpb25zLnJldHVybk9yaWdpbmFsO1xuICBpZiAob3B0aW9ucy5uZXcgPT0gbnVsbCAmJiBvcHRpb25zLnJldHVybkRvY3VtZW50ID09IG51bGwgJiYgb3B0aW9ucy5yZXR1cm5PcmlnaW5hbCA9PSBudWxsICYmIHJldHVybk9yaWdpbmFsICE9IG51bGwpIHtcbiAgICBvcHRpb25zLnJldHVybk9yaWdpbmFsID0gcmV0dXJuT3JpZ2luYWw7XG4gIH1cblxuICB0aGlzLnNldE9wdGlvbnMob3B0aW9ucyk7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEV4ZWN1dGUgYSBmaW5kT25lQW5kVXBkYXRlIG9wZXJhdGlvblxuICpcbiAqIEBtZXRob2QgX2ZpbmRPbmVBbmRVcGRhdGVcbiAqIEBtZW1iZXJPZiBRdWVyeVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuUXVlcnkucHJvdG90eXBlLl9maW5kT25lQW5kVXBkYXRlID0gYXN5bmMgZnVuY3Rpb24gX2ZpbmRPbmVBbmRVcGRhdGUoKSB7XG4gIHRoaXMuX2Nhc3RDb25kaXRpb25zKCk7XG5cbiAgX2Nhc3RBcnJheUZpbHRlcnModGhpcyk7XG5cbiAgaWYgKHRoaXMuZXJyb3IoKSkge1xuICAgIHRocm93IHRoaXMuZXJyb3IoKTtcbiAgfVxuXG4gIGFwcGx5R2xvYmFsTWF4VGltZU1TKHRoaXMub3B0aW9ucywgdGhpcy5tb2RlbC5kYi5vcHRpb25zLCB0aGlzLm1vZGVsLmJhc2Uub3B0aW9ucyk7XG4gIGFwcGx5R2xvYmFsRGlza1VzZSh0aGlzLm9wdGlvbnMsIHRoaXMubW9kZWwuZGIub3B0aW9ucywgdGhpcy5tb2RlbC5iYXNlLm9wdGlvbnMpO1xuXG4gIGlmICgnc3RyaWN0JyBpbiB0aGlzLm9wdGlvbnMpIHtcbiAgICB0aGlzLl9tb25nb29zZU9wdGlvbnMuc3RyaWN0ID0gdGhpcy5vcHRpb25zLnN0cmljdDtcbiAgfVxuICBjb25zdCBvcHRpb25zID0gdGhpcy5fb3B0aW9uc0ZvckV4ZWModGhpcy5tb2RlbCk7XG4gIGNvbnZlcnROZXdUb1JldHVybkRvY3VtZW50KG9wdGlvbnMpO1xuICB0aGlzLl9hcHBseVRyYW5zbGF0ZUFsaWFzZXMob3B0aW9ucyk7XG5cbiAgdGhpcy5fdXBkYXRlID0gdGhpcy5fY2FzdFVwZGF0ZSh0aGlzLl91cGRhdGUpO1xuXG4gIGNvbnN0IF9vcHRzID0gT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucywge1xuICAgIHNldERlZmF1bHRzT25JbnNlcnQ6IHRoaXMuX21vbmdvb3NlT3B0aW9ucy5zZXREZWZhdWx0c09uSW5zZXJ0XG4gIH0pO1xuICB0aGlzLl91cGRhdGUgPSBzZXREZWZhdWx0c09uSW5zZXJ0KHRoaXMuX2NvbmRpdGlvbnMsIHRoaXMubW9kZWwuc2NoZW1hLFxuICAgIHRoaXMuX3VwZGF0ZSwgX29wdHMpO1xuXG4gIGlmICghdGhpcy5fdXBkYXRlIHx8IE9iamVjdC5rZXlzKHRoaXMuX3VwZGF0ZSkubGVuZ3RoID09PSAwKSB7XG4gICAgaWYgKG9wdGlvbnMudXBzZXJ0KSB7XG4gICAgICAvLyBzdGlsbCBuZWVkIHRvIGRvIHRoZSB1cHNlcnQgdG8gZW1wdHkgZG9jXG4gICAgICBjb25zdCBkb2MgPSBjbG9uZSh0aGlzLl91cGRhdGUpO1xuICAgICAgZGVsZXRlIGRvYy5faWQ7XG4gICAgICB0aGlzLl91cGRhdGUgPSB7ICRzZXQ6IGRvYyB9O1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9leGVjdXRpb25TdGFjayA9IG51bGw7XG4gICAgICBjb25zdCByZXMgPSBhd2FpdCB0aGlzLl9maW5kT25lKCk7XG4gICAgICByZXR1cm4gcmVzO1xuICAgIH1cbiAgfSBlbHNlIGlmICh0aGlzLl91cGRhdGUgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgIHRocm93IHRoaXMuX3VwZGF0ZTtcbiAgfSBlbHNlIHtcbiAgICAvLyBJbiBvcmRlciB0byBtYWtlIE1vbmdvREIgMi42IGhhcHB5IChzZWVcbiAgICAvLyBodHRwczovL2ppcmEubW9uZ29kYi5vcmcvYnJvd3NlL1NFUlZFUi0xMjI2NiBhbmQgcmVsYXRlZCBpc3N1ZXMpXG4gICAgLy8gaWYgd2UgaGF2ZSBhbiBhY3R1YWwgdXBkYXRlIGRvY3VtZW50IGJ1dCAkc2V0IGlzIGVtcHR5LCBqdW5rIHRoZSAkc2V0LlxuICAgIGlmICh0aGlzLl91cGRhdGUuJHNldCAmJiBPYmplY3Qua2V5cyh0aGlzLl91cGRhdGUuJHNldCkubGVuZ3RoID09PSAwKSB7XG4gICAgICBkZWxldGUgdGhpcy5fdXBkYXRlLiRzZXQ7XG4gICAgfVxuICB9XG5cbiAgY29uc3QgcnVuVmFsaWRhdG9ycyA9IF9nZXRPcHRpb24odGhpcywgJ3J1blZhbGlkYXRvcnMnLCBmYWxzZSk7XG4gIGlmIChydW5WYWxpZGF0b3JzKSB7XG4gICAgYXdhaXQgdGhpcy52YWxpZGF0ZSh0aGlzLl91cGRhdGUsIG9wdGlvbnMsIGZhbHNlKTtcbiAgfVxuXG4gIGlmICh0aGlzLl91cGRhdGUudG9CU09OKSB7XG4gICAgdGhpcy5fdXBkYXRlID0gdGhpcy5fdXBkYXRlLnRvQlNPTigpO1xuICB9XG5cbiAgbGV0IHJlcyA9IGF3YWl0IHRoaXMubW9uZ29vc2VDb2xsZWN0aW9uLmZpbmRPbmVBbmRVcGRhdGUodGhpcy5fY29uZGl0aW9ucywgdGhpcy5fdXBkYXRlLCBvcHRpb25zKTtcbiAgZm9yIChjb25zdCBmbiBvZiB0aGlzLl90cmFuc2Zvcm1zKSB7XG4gICAgcmVzID0gZm4ocmVzKTtcbiAgfVxuICBjb25zdCBkb2MgPSAhb3B0aW9ucy5pbmNsdWRlUmVzdWx0TWV0YWRhdGEgPyByZXMgOiByZXMudmFsdWU7XG5cbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICB0aGlzLl9jb21wbGV0ZU9uZShkb2MsIHJlcywgKGVyciwgcmVzKSA9PiB7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIHJldHVybiByZWplY3QoZXJyKTtcbiAgICAgIH1cbiAgICAgIHJlc29sdmUocmVzKTtcbiAgICB9KTtcbiAgfSk7XG59O1xuXG4vKipcbiAqIElzc3VlcyBhIE1vbmdvREIgW2ZpbmRPbmVBbmREZWxldGVdKGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvbWFudWFsL3JlZmVyZW5jZS9tZXRob2QvZGIuY29sbGVjdGlvbi5maW5kT25lQW5kRGVsZXRlLykgY29tbWFuZC5cbiAqXG4gKiBGaW5kcyBhIG1hdGNoaW5nIGRvY3VtZW50LCByZW1vdmVzIGl0LCBhbmQgcmV0dXJucyB0aGUgZm91bmQgZG9jdW1lbnQgKGlmIGFueSkuXG4gKlxuICogVGhpcyBmdW5jdGlvbiB0cmlnZ2VycyB0aGUgZm9sbG93aW5nIG1pZGRsZXdhcmUuXG4gKlxuICogLSBgZmluZE9uZUFuZERlbGV0ZSgpYFxuICpcbiAqICMjIyMgQXZhaWxhYmxlIG9wdGlvbnNcbiAqXG4gKiAtIGBzb3J0YDogaWYgbXVsdGlwbGUgZG9jcyBhcmUgZm91bmQgYnkgdGhlIGNvbmRpdGlvbnMsIHNldHMgdGhlIHNvcnQgb3JkZXIgdG8gY2hvb3NlIHdoaWNoIGRvYyB0byB1cGRhdGVcbiAqIC0gYG1heFRpbWVNU2A6IHB1dHMgYSB0aW1lIGxpbWl0IG9uIHRoZSBxdWVyeSAtIHJlcXVpcmVzIG1vbmdvZGIgPj0gMi42LjBcbiAqXG4gKiAjIyMjIENhbGxiYWNrIFNpZ25hdHVyZVxuICpcbiAqICAgICBmdW5jdGlvbihlcnJvciwgZG9jKSB7XG4gKiAgICAgICAvLyBlcnJvcjogYW55IGVycm9ycyB0aGF0IG9jY3VycmVkXG4gKiAgICAgICAvLyBkb2M6IHRoZSBkb2N1bWVudCBiZWZvcmUgdXBkYXRlcyBhcmUgYXBwbGllZCBpZiBgbmV3OiBmYWxzZWAsIG9yIGFmdGVyIHVwZGF0ZXMgaWYgYG5ldyA9IHRydWVgXG4gKiAgICAgfVxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgQS53aGVyZSgpLmZpbmRPbmVBbmREZWxldGUoY29uZGl0aW9ucywgb3B0aW9ucykgIC8vIHJldHVybiBRdWVyeVxuICogICAgIEEud2hlcmUoKS5maW5kT25lQW5kRGVsZXRlKGNvbmRpdGlvbnMpIC8vIHJldHVybnMgUXVlcnlcbiAqICAgICBBLndoZXJlKCkuZmluZE9uZUFuZERlbGV0ZSgpICAgICAgICAgICAvLyByZXR1cm5zIFF1ZXJ5XG4gKlxuICogQG1ldGhvZCBmaW5kT25lQW5kRGVsZXRlXG4gKiBAbWVtYmVyT2YgUXVlcnlcbiAqIEBwYXJhbSB7T2JqZWN0fSBbZmlsdGVyXVxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5pbmNsdWRlUmVzdWx0TWV0YWRhdGFdIGlmIHRydWUsIHJldHVybnMgdGhlIGZ1bGwgW01vZGlmeVJlc3VsdCBmcm9tIHRoZSBNb25nb0RCIGRyaXZlcl0oaHR0cHM6Ly9tb25nb2RiLmdpdGh1Yi5pby9ub2RlLW1vbmdvZGItbmF0aXZlLzQuOS9pbnRlcmZhY2VzL01vZGlmeVJlc3VsdC5odG1sKSByYXRoZXIgdGhhbiBqdXN0IHRoZSBkb2N1bWVudFxuICogQHBhcmFtIHtDbGllbnRTZXNzaW9ufSBbb3B0aW9ucy5zZXNzaW9uPW51bGxdIFRoZSBzZXNzaW9uIGFzc29jaWF0ZWQgd2l0aCB0aGlzIHF1ZXJ5LiBTZWUgW3RyYW5zYWN0aW9ucyBkb2NzXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvdHJhbnNhY3Rpb25zLmh0bWwpLlxuICogQHBhcmFtIHtCb29sZWFufFN0cmluZ30gW29wdGlvbnMuc3RyaWN0XSBvdmVyd3JpdGVzIHRoZSBzY2hlbWEncyBbc3RyaWN0IG1vZGUgb3B0aW9uXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvZ3VpZGUuaHRtbCNzdHJpY3QpXG4gKiBAcmV0dXJuIHtRdWVyeX0gdGhpc1xuICogQHNlZSBmaW5kQW5kTW9kaWZ5IGNvbW1hbmQgaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvcmVmZXJlbmNlL2NvbW1hbmQvZmluZEFuZE1vZGlmeS9cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUXVlcnkucHJvdG90eXBlLmZpbmRPbmVBbmREZWxldGUgPSBmdW5jdGlvbihmaWx0ZXIsIG9wdGlvbnMpIHtcbiAgaWYgKHR5cGVvZiBmaWx0ZXIgPT09ICdmdW5jdGlvbicgfHxcbiAgICAgIHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nIHx8XG4gICAgICB0eXBlb2YgYXJndW1lbnRzWzJdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IE1vbmdvb3NlRXJyb3IoJ1F1ZXJ5LnByb3RvdHlwZS5maW5kT25lQW5kRGVsZXRlKCkgbm8gbG9uZ2VyIGFjY2VwdHMgYSBjYWxsYmFjaycpO1xuICB9XG5cbiAgdGhpcy5vcCA9ICdmaW5kT25lQW5kRGVsZXRlJztcbiAgdGhpcy5fdmFsaWRhdGVPcCgpO1xuICB0aGlzLl92YWxpZGF0ZSgpO1xuXG4gIGlmIChtcXVlcnkuY2FuTWVyZ2UoZmlsdGVyKSkge1xuICAgIHRoaXMubWVyZ2UoZmlsdGVyKTtcbiAgfVxuXG4gIG9wdGlvbnMgJiYgdGhpcy5zZXRPcHRpb25zKG9wdGlvbnMpO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBFeGVjdXRlIGEgYGZpbmRPbmVBbmREZWxldGUoKWAgcXVlcnlcbiAqXG4gKiBAcmV0dXJuIHtRdWVyeX0gdGhpc1xuICogQG1ldGhvZCBfZmluZE9uZUFuZERlbGV0ZVxuICogQG1lbWJlck9mIFF1ZXJ5XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuUXVlcnkucHJvdG90eXBlLl9maW5kT25lQW5kRGVsZXRlID0gYXN5bmMgZnVuY3Rpb24gX2ZpbmRPbmVBbmREZWxldGUoKSB7XG4gIHRoaXMuX2Nhc3RDb25kaXRpb25zKCk7XG5cbiAgaWYgKHRoaXMuZXJyb3IoKSAhPSBudWxsKSB7XG4gICAgdGhyb3cgdGhpcy5lcnJvcigpO1xuICB9XG5cbiAgY29uc3QgaW5jbHVkZVJlc3VsdE1ldGFkYXRhID0gdGhpcy5vcHRpb25zLmluY2x1ZGVSZXN1bHRNZXRhZGF0YTtcblxuICBjb25zdCBmaWx0ZXIgPSB0aGlzLl9jb25kaXRpb25zO1xuICBjb25zdCBvcHRpb25zID0gdGhpcy5fb3B0aW9uc0ZvckV4ZWModGhpcy5tb2RlbCk7XG4gIHRoaXMuX2FwcGx5VHJhbnNsYXRlQWxpYXNlcyhvcHRpb25zKTtcblxuICBsZXQgcmVzID0gYXdhaXQgdGhpcy5tb25nb29zZUNvbGxlY3Rpb24uZmluZE9uZUFuZERlbGV0ZShmaWx0ZXIsIG9wdGlvbnMpO1xuICBmb3IgKGNvbnN0IGZuIG9mIHRoaXMuX3RyYW5zZm9ybXMpIHtcbiAgICByZXMgPSBmbihyZXMpO1xuICB9XG4gIGNvbnN0IGRvYyA9ICFpbmNsdWRlUmVzdWx0TWV0YWRhdGEgPyByZXMgOiByZXMudmFsdWU7XG5cbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICB0aGlzLl9jb21wbGV0ZU9uZShkb2MsIHJlcywgKGVyciwgcmVzKSA9PiB7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIHJldHVybiByZWplY3QoZXJyKTtcbiAgICAgIH1cbiAgICAgIHJlc29sdmUocmVzKTtcbiAgICB9KTtcbiAgfSk7XG59O1xuXG4vKipcbiAqIElzc3VlcyBhIE1vbmdvREIgW2ZpbmRPbmVBbmRSZXBsYWNlXShodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9yZWZlcmVuY2UvbWV0aG9kL2RiLmNvbGxlY3Rpb24uZmluZE9uZUFuZFJlcGxhY2UvKSBjb21tYW5kLlxuICpcbiAqIEZpbmRzIGEgbWF0Y2hpbmcgZG9jdW1lbnQsIHJlbW92ZXMgaXQsIGFuZCByZXR1cm5zIHRoZSBmb3VuZCBkb2N1bWVudCAoaWYgYW55KS5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIHRyaWdnZXJzIHRoZSBmb2xsb3dpbmcgbWlkZGxld2FyZS5cbiAqXG4gKiAtIGBmaW5kT25lQW5kUmVwbGFjZSgpYFxuICpcbiAqICMjIyMgQXZhaWxhYmxlIG9wdGlvbnNcbiAqXG4gKiAtIGBzb3J0YDogaWYgbXVsdGlwbGUgZG9jcyBhcmUgZm91bmQgYnkgdGhlIGNvbmRpdGlvbnMsIHNldHMgdGhlIHNvcnQgb3JkZXIgdG8gY2hvb3NlIHdoaWNoIGRvYyB0byB1cGRhdGVcbiAqIC0gYG1heFRpbWVNU2A6IHB1dHMgYSB0aW1lIGxpbWl0IG9uIHRoZSBxdWVyeSAtIHJlcXVpcmVzIG1vbmdvZGIgPj0gMi42LjBcbiAqIC0gYGluY2x1ZGVSZXN1bHRNZXRhZGF0YWA6IGlmIHRydWUsIHJldHVybnMgdGhlIGZ1bGwgW01vZGlmeVJlc3VsdCBmcm9tIHRoZSBNb25nb0RCIGRyaXZlcl0oaHR0cHM6Ly9tb25nb2RiLmdpdGh1Yi5pby9ub2RlLW1vbmdvZGItbmF0aXZlLzQuOS9pbnRlcmZhY2VzL01vZGlmeVJlc3VsdC5odG1sKSByYXRoZXIgdGhhbiBqdXN0IHRoZSBkb2N1bWVudFxuICpcbiAqICMjIyMgQ2FsbGJhY2sgU2lnbmF0dXJlXG4gKlxuICogICAgIGZ1bmN0aW9uKGVycm9yLCBkb2MpIHtcbiAqICAgICAgIC8vIGVycm9yOiBhbnkgZXJyb3JzIHRoYXQgb2NjdXJyZWRcbiAqICAgICAgIC8vIGRvYzogdGhlIGRvY3VtZW50IGJlZm9yZSB1cGRhdGVzIGFyZSBhcHBsaWVkIGlmIGBuZXc6IGZhbHNlYCwgb3IgYWZ0ZXIgdXBkYXRlcyBpZiBgbmV3ID0gdHJ1ZWBcbiAqICAgICB9XG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBBLndoZXJlKCkuZmluZE9uZUFuZFJlcGxhY2UoZmlsdGVyLCByZXBsYWNlbWVudCwgb3B0aW9ucyk7IC8vIHJldHVybiBRdWVyeVxuICogICAgIEEud2hlcmUoKS5maW5kT25lQW5kUmVwbGFjZShmaWx0ZXIpOyAvLyByZXR1cm5zIFF1ZXJ5XG4gKiAgICAgQS53aGVyZSgpLmZpbmRPbmVBbmRSZXBsYWNlKCk7IC8vIHJldHVybnMgUXVlcnlcbiAqXG4gKiBAbWV0aG9kIGZpbmRPbmVBbmRSZXBsYWNlXG4gKiBAbWVtYmVyT2YgUXVlcnlcbiAqIEBwYXJhbSB7T2JqZWN0fSBbZmlsdGVyXVxuICogQHBhcmFtIHtPYmplY3R9IFtyZXBsYWNlbWVudF1cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuaW5jbHVkZVJlc3VsdE1ldGFkYXRhXSBpZiB0cnVlLCByZXR1cm5zIHRoZSBmdWxsIFtNb2RpZnlSZXN1bHQgZnJvbSB0aGUgTW9uZ29EQiBkcml2ZXJdKGh0dHBzOi8vbW9uZ29kYi5naXRodWIuaW8vbm9kZS1tb25nb2RiLW5hdGl2ZS80LjkvaW50ZXJmYWNlcy9Nb2RpZnlSZXN1bHQuaHRtbCkgcmF0aGVyIHRoYW4ganVzdCB0aGUgZG9jdW1lbnRcbiAqIEBwYXJhbSB7Q2xpZW50U2Vzc2lvbn0gW29wdGlvbnMuc2Vzc2lvbj1udWxsXSBUaGUgc2Vzc2lvbiBhc3NvY2lhdGVkIHdpdGggdGhpcyBxdWVyeS4gU2VlIFt0cmFuc2FjdGlvbnMgZG9jc10oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL3RyYW5zYWN0aW9ucy5odG1sKS5cbiAqIEBwYXJhbSB7Qm9vbGVhbnxTdHJpbmd9IFtvcHRpb25zLnN0cmljdF0gb3ZlcndyaXRlcyB0aGUgc2NoZW1hJ3MgW3N0cmljdCBtb2RlIG9wdGlvbl0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2d1aWRlLmh0bWwjc3RyaWN0KVxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5uZXc9ZmFsc2VdIEJ5IGRlZmF1bHQsIGBmaW5kT25lQW5kVXBkYXRlKClgIHJldHVybnMgdGhlIGRvY3VtZW50IGFzIGl0IHdhcyAqKmJlZm9yZSoqIGB1cGRhdGVgIHdhcyBhcHBsaWVkLiBJZiB5b3Ugc2V0IGBuZXc6IHRydWVgLCBgZmluZE9uZUFuZFVwZGF0ZSgpYCB3aWxsIGluc3RlYWQgZ2l2ZSB5b3UgdGhlIG9iamVjdCBhZnRlciBgdXBkYXRlYCB3YXMgYXBwbGllZC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy5sZWFuXSBpZiB0cnV0aHksIG1vbmdvb3NlIHdpbGwgcmV0dXJuIHRoZSBkb2N1bWVudCBhcyBhIHBsYWluIEphdmFTY3JpcHQgb2JqZWN0IHJhdGhlciB0aGFuIGEgbW9uZ29vc2UgZG9jdW1lbnQuIFNlZSBbYFF1ZXJ5LmxlYW4oKWBdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvcXVlcnkuaHRtbCNRdWVyeS5wcm90b3R5cGUubGVhbigpKSBhbmQgW3RoZSBNb25nb29zZSBsZWFuIHR1dG9yaWFsXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvdHV0b3JpYWxzL2xlYW4uaHRtbCkuXG4gKiBAcGFyYW0ge0NsaWVudFNlc3Npb259IFtvcHRpb25zLnNlc3Npb249bnVsbF0gVGhlIHNlc3Npb24gYXNzb2NpYXRlZCB3aXRoIHRoaXMgcXVlcnkuIFNlZSBbdHJhbnNhY3Rpb25zIGRvY3NdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy90cmFuc2FjdGlvbnMuaHRtbCkuXG4gKiBAcGFyYW0ge0Jvb2xlYW58U3RyaW5nfSBbb3B0aW9ucy5zdHJpY3RdIG92ZXJ3cml0ZXMgdGhlIHNjaGVtYSdzIFtzdHJpY3QgbW9kZSBvcHRpb25dKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9ndWlkZS5odG1sI3N0cmljdClcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMudGltZXN0YW1wcz1udWxsXSBJZiBzZXQgdG8gYGZhbHNlYCBhbmQgW3NjaGVtYS1sZXZlbCB0aW1lc3RhbXBzXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvZ3VpZGUuaHRtbCN0aW1lc3RhbXBzKSBhcmUgZW5hYmxlZCwgc2tpcCB0aW1lc3RhbXBzIGZvciB0aGlzIHVwZGF0ZS4gTm90ZSB0aGF0IHRoaXMgYWxsb3dzIHlvdSB0byBvdmVyd3JpdGUgdGltZXN0YW1wcy4gRG9lcyBub3RoaW5nIGlmIHNjaGVtYS1sZXZlbCB0aW1lc3RhbXBzIGFyZSBub3Qgc2V0LlxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5yZXR1cm5PcmlnaW5hbD1udWxsXSBBbiBhbGlhcyBmb3IgdGhlIGBuZXdgIG9wdGlvbi4gYHJldHVybk9yaWdpbmFsOiBmYWxzZWAgaXMgZXF1aXZhbGVudCB0byBgbmV3OiB0cnVlYC5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMudHJhbnNsYXRlQWxpYXNlcz1udWxsXSBJZiBzZXQgdG8gYHRydWVgLCB0cmFuc2xhdGVzIGFueSBzY2hlbWEtZGVmaW5lZCBhbGlhc2VzIGluIGBmaWx0ZXJgLCBgcHJvamVjdGlvbmAsIGB1cGRhdGVgLCBhbmQgYGRpc3RpbmN0YC4gVGhyb3dzIGFuIGVycm9yIGlmIHRoZXJlIGFyZSBhbnkgY29uZmxpY3RzIHdoZXJlIGJvdGggYWxpYXMgYW5kIHJhdyBwcm9wZXJ0eSBhcmUgZGVmaW5lZCBvbiB0aGUgc2FtZSBvYmplY3QuXG4gKiBAcmV0dXJuIHtRdWVyeX0gdGhpc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5RdWVyeS5wcm90b3R5cGUuZmluZE9uZUFuZFJlcGxhY2UgPSBmdW5jdGlvbihmaWx0ZXIsIHJlcGxhY2VtZW50LCBvcHRpb25zKSB7XG4gIGlmICh0eXBlb2YgZmlsdGVyID09PSAnZnVuY3Rpb24nIHx8XG4gICAgICB0eXBlb2YgcmVwbGFjZW1lbnQgPT09ICdmdW5jdGlvbicgfHxcbiAgICAgIHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nIHx8XG4gICAgICB0eXBlb2YgYXJndW1lbnRzWzRdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IE1vbmdvb3NlRXJyb3IoJ1F1ZXJ5LnByb3RvdHlwZS5maW5kT25lQW5kUmVwbGFjZSgpIG5vIGxvbmdlciBhY2NlcHRzIGEgY2FsbGJhY2snKTtcbiAgfVxuXG4gIHRoaXMub3AgPSAnZmluZE9uZUFuZFJlcGxhY2UnO1xuICB0aGlzLl92YWxpZGF0ZU9wKCk7XG4gIHRoaXMuX3ZhbGlkYXRlKCk7XG5cbiAgaWYgKG1xdWVyeS5jYW5NZXJnZShmaWx0ZXIpKSB7XG4gICAgdGhpcy5tZXJnZShmaWx0ZXIpO1xuICB9IGVsc2UgaWYgKGZpbHRlciAhPSBudWxsKSB7XG4gICAgdGhpcy5lcnJvcihcbiAgICAgIG5ldyBPYmplY3RQYXJhbWV0ZXJFcnJvcihmaWx0ZXIsICdmaWx0ZXInLCAnZmluZE9uZUFuZFJlcGxhY2UnKVxuICAgICk7XG4gIH1cblxuICBpZiAocmVwbGFjZW1lbnQgIT0gbnVsbCkge1xuICAgIHRoaXMuX21lcmdlVXBkYXRlKHJlcGxhY2VtZW50KTtcbiAgfVxuXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIGNvbnN0IHJldHVybk9yaWdpbmFsID0gdGhpcyAmJlxuICB0aGlzLm1vZGVsICYmXG4gIHRoaXMubW9kZWwuYmFzZSAmJlxuICB0aGlzLm1vZGVsLmJhc2Uub3B0aW9ucyAmJlxuICB0aGlzLm1vZGVsLmJhc2Uub3B0aW9ucy5yZXR1cm5PcmlnaW5hbDtcbiAgaWYgKG9wdGlvbnMubmV3ID09IG51bGwgJiYgb3B0aW9ucy5yZXR1cm5Eb2N1bWVudCA9PSBudWxsICYmIG9wdGlvbnMucmV0dXJuT3JpZ2luYWwgPT0gbnVsbCAmJiByZXR1cm5PcmlnaW5hbCAhPSBudWxsKSB7XG4gICAgb3B0aW9ucy5yZXR1cm5PcmlnaW5hbCA9IHJldHVybk9yaWdpbmFsO1xuICB9XG4gIHRoaXMuc2V0T3B0aW9ucyhvcHRpb25zKTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogRXhlY3V0ZSBhIGZpbmRPbmVBbmRSZXBsYWNlKCkgcXVlcnlcbiAqXG4gKiBAcmV0dXJuIHtRdWVyeX0gdGhpc1xuICogQG1ldGhvZCBfZmluZE9uZUFuZFJlcGxhY2VcbiAqIEBpbnN0YW5jZVxuICogQG1lbWJlck9mIFF1ZXJ5XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuUXVlcnkucHJvdG90eXBlLl9maW5kT25lQW5kUmVwbGFjZSA9IGFzeW5jIGZ1bmN0aW9uIF9maW5kT25lQW5kUmVwbGFjZSgpIHtcbiAgdGhpcy5fY2FzdENvbmRpdGlvbnMoKTtcbiAgaWYgKHRoaXMuZXJyb3IoKSAhPSBudWxsKSB7XG4gICAgdGhyb3cgdGhpcy5lcnJvcigpO1xuICB9XG5cbiAgaWYgKCdzdHJpY3QnIGluIHRoaXMub3B0aW9ucykge1xuICAgIHRoaXMuX21vbmdvb3NlT3B0aW9ucy5zdHJpY3QgPSB0aGlzLm9wdGlvbnMuc3RyaWN0O1xuICAgIGRlbGV0ZSB0aGlzLm9wdGlvbnMuc3RyaWN0O1xuICB9XG5cbiAgY29uc3QgZmlsdGVyID0gdGhpcy5fY29uZGl0aW9ucztcbiAgY29uc3Qgb3B0aW9ucyA9IHRoaXMuX29wdGlvbnNGb3JFeGVjKCk7XG4gIHRoaXMuX2FwcGx5VHJhbnNsYXRlQWxpYXNlcyhvcHRpb25zKTtcbiAgY29udmVydE5ld1RvUmV0dXJuRG9jdW1lbnQob3B0aW9ucyk7XG5cbiAgY29uc3QgaW5jbHVkZVJlc3VsdE1ldGFkYXRhID0gdGhpcy5vcHRpb25zLmluY2x1ZGVSZXN1bHRNZXRhZGF0YTtcblxuICBjb25zdCBtb2RlbE9wdHMgPSB7IHNraXBJZDogdHJ1ZSB9O1xuICBpZiAoJ3N0cmljdCcgaW4gdGhpcy5fbW9uZ29vc2VPcHRpb25zKSB7XG4gICAgbW9kZWxPcHRzLnN0cmljdCA9IHRoaXMuX21vbmdvb3NlT3B0aW9ucy5zdHJpY3Q7XG4gIH1cblxuICBjb25zdCBydW5WYWxpZGF0b3JzID0gX2dldE9wdGlvbih0aGlzLCAncnVuVmFsaWRhdG9ycycsIGZhbHNlKTtcblxuICB0cnkge1xuICAgIGNvbnN0IHVwZGF0ZSA9IG5ldyB0aGlzLm1vZGVsKHRoaXMuX3VwZGF0ZSwgbnVsbCwgbW9kZWxPcHRzKTtcbiAgICBpZiAocnVuVmFsaWRhdG9ycykge1xuICAgICAgYXdhaXQgdXBkYXRlLnZhbGlkYXRlKCk7XG4gICAgfSBlbHNlIGlmICh1cGRhdGUuJF9fLnZhbGlkYXRpb25FcnJvcikge1xuICAgICAgdGhyb3cgdXBkYXRlLiRfXy52YWxpZGF0aW9uRXJyb3I7XG4gICAgfVxuICAgIHRoaXMuX3VwZGF0ZSA9IHVwZGF0ZS50b0JTT04oKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgaWYgKGVyciBpbnN0YW5jZW9mIFZhbGlkYXRpb25FcnJvcikge1xuICAgICAgdGhyb3cgZXJyO1xuICAgIH1cbiAgICBjb25zdCB2YWxpZGF0aW9uRXJyb3IgPSBuZXcgVmFsaWRhdGlvbkVycm9yKCk7XG4gICAgdmFsaWRhdGlvbkVycm9yLmVycm9yc1tlcnIucGF0aF0gPSBlcnI7XG4gICAgdGhyb3cgdmFsaWRhdGlvbkVycm9yO1xuICB9XG5cbiAgbGV0IHJlcyA9IGF3YWl0IHRoaXMubW9uZ29vc2VDb2xsZWN0aW9uLmZpbmRPbmVBbmRSZXBsYWNlKGZpbHRlciwgdGhpcy5fdXBkYXRlLCBvcHRpb25zKTtcblxuICBmb3IgKGNvbnN0IGZuIG9mIHRoaXMuX3RyYW5zZm9ybXMpIHtcbiAgICByZXMgPSBmbihyZXMpO1xuICB9XG5cbiAgY29uc3QgZG9jID0gIWluY2x1ZGVSZXN1bHRNZXRhZGF0YSA/IHJlcyA6IHJlcy52YWx1ZTtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICB0aGlzLl9jb21wbGV0ZU9uZShkb2MsIHJlcywgKGVyciwgcmVzKSA9PiB7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIHJldHVybiByZWplY3QoZXJyKTtcbiAgICAgIH1cbiAgICAgIHJlc29sdmUocmVzKTtcbiAgICB9KTtcbiAgfSk7XG59O1xuXG4vKipcbiAqIFN1cHBvcnQgdGhlIGBuZXdgIG9wdGlvbiBhcyBhbiBhbHRlcm5hdGl2ZSB0byBgcmV0dXJuT3JpZ2luYWxgIGZvciBiYWNrd2FyZHNcbiAqIGNvbXBhdC5cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGNvbnZlcnROZXdUb1JldHVybkRvY3VtZW50KG9wdGlvbnMpIHtcbiAgaWYgKCduZXcnIGluIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zLnJldHVybkRvY3VtZW50ID0gb3B0aW9uc1snbmV3J10gPyAnYWZ0ZXInIDogJ2JlZm9yZSc7XG4gICAgZGVsZXRlIG9wdGlvbnNbJ25ldyddO1xuICB9XG4gIGlmICgncmV0dXJuT3JpZ2luYWwnIGluIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zLnJldHVybkRvY3VtZW50ID0gb3B0aW9uc1sncmV0dXJuT3JpZ2luYWwnXSA/ICdiZWZvcmUnIDogJ2FmdGVyJztcbiAgICBkZWxldGUgb3B0aW9uc1sncmV0dXJuT3JpZ2luYWwnXTtcbiAgfVxuICAvLyBUZW1wb3Jhcnkgc2luY2UgZHJpdmVyIDQuMC4wLWJldGEgZG9lcyBub3Qgc3VwcG9ydCBgcmV0dXJuRG9jdW1lbnRgXG4gIGlmICh0eXBlb2Ygb3B0aW9ucy5yZXR1cm5Eb2N1bWVudCA9PT0gJ3N0cmluZycpIHtcbiAgICBvcHRpb25zLnJldHVybk9yaWdpbmFsID0gb3B0aW9ucy5yZXR1cm5Eb2N1bWVudCA9PT0gJ2JlZm9yZSc7XG4gIH1cbn1cblxuLyoqXG4gKiBHZXQgb3B0aW9ucyBmcm9tIHF1ZXJ5IG9wdHMsIGZhbGxpbmcgYmFjayB0byB0aGUgYmFzZSBtb25nb29zZSBvYmplY3QuXG4gKiBAcGFyYW0ge1F1ZXJ5fSBxdWVyeVxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvblxuICogQHBhcmFtIHtBbnl9IGRlZlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gX2dldE9wdGlvbihxdWVyeSwgb3B0aW9uLCBkZWYpIHtcbiAgY29uc3Qgb3B0cyA9IHF1ZXJ5Ll9vcHRpb25zRm9yRXhlYyhxdWVyeS5tb2RlbCk7XG5cbiAgaWYgKG9wdGlvbiBpbiBvcHRzKSB7XG4gICAgcmV0dXJuIG9wdHNbb3B0aW9uXTtcbiAgfVxuICBpZiAob3B0aW9uIGluIHF1ZXJ5Lm1vZGVsLmJhc2Uub3B0aW9ucykge1xuICAgIHJldHVybiBxdWVyeS5tb2RlbC5iYXNlLm9wdGlvbnNbb3B0aW9uXTtcbiAgfVxuICByZXR1cm4gZGVmO1xufVxuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cbmZ1bmN0aW9uIF9jb21wbGV0ZU9uZUxlYW4oc2NoZW1hLCBkb2MsIHBhdGgsIHJlcywgb3B0cywgY2FsbGJhY2spIHtcbiAgaWYgKG9wdHMubGVhbiAmJiB0eXBlb2Ygb3B0cy5sZWFuLnRyYW5zZm9ybSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIG9wdHMubGVhbi50cmFuc2Zvcm0oZG9jKTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2NoZW1hLmNoaWxkU2NoZW1hcy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgY2hpbGRQYXRoID0gcGF0aCA/IHBhdGggKyAnLicgKyBzY2hlbWEuY2hpbGRTY2hlbWFzW2ldLm1vZGVsLnBhdGggOiBzY2hlbWEuY2hpbGRTY2hlbWFzW2ldLm1vZGVsLnBhdGg7XG4gICAgICBjb25zdCBfc2NoZW1hID0gc2NoZW1hLmNoaWxkU2NoZW1hc1tpXS5zY2hlbWE7XG4gICAgICBjb25zdCBvYmogPSBtcGF0aC5nZXQoY2hpbGRQYXRoLCBkb2MpO1xuICAgICAgaWYgKG9iaiA9PSBudWxsKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkob2JqKSkge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG9iai5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIG9wdHMubGVhbi50cmFuc2Zvcm0ob2JqW2ldKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3B0cy5sZWFuLnRyYW5zZm9ybShvYmopO1xuICAgICAgfVxuICAgICAgX2NvbXBsZXRlT25lTGVhbihfc2NoZW1hLCBvYmosIGNoaWxkUGF0aCwgcmVzLCBvcHRzKTtcbiAgICB9XG4gICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCwgZG9jKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuICBpZiAob3B0cy5pbmNsdWRlUmVzdWx0TWV0YWRhdGEpIHtcbiAgICByZXR1cm4gY2FsbGJhY2sobnVsbCwgcmVzKTtcbiAgfVxuICByZXR1cm4gY2FsbGJhY2sobnVsbCwgZG9jKTtcbn1cblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5mdW5jdGlvbiBfY29tcGxldGVNYW55TGVhbihzY2hlbWEsIGRvY3MsIHBhdGgsIG9wdHMpIHtcbiAgaWYgKG9wdHMubGVhbiAmJiB0eXBlb2Ygb3B0cy5sZWFuLnRyYW5zZm9ybSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGZvciAoY29uc3QgZG9jIG9mIGRvY3MpIHtcbiAgICAgIG9wdHMubGVhbi50cmFuc2Zvcm0oZG9jKTtcbiAgICB9XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNjaGVtYS5jaGlsZFNjaGVtYXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGNoaWxkUGF0aCA9IHBhdGggPyBwYXRoICsgJy4nICsgc2NoZW1hLmNoaWxkU2NoZW1hc1tpXS5tb2RlbC5wYXRoIDogc2NoZW1hLmNoaWxkU2NoZW1hc1tpXS5tb2RlbC5wYXRoO1xuICAgICAgY29uc3QgX3NjaGVtYSA9IHNjaGVtYS5jaGlsZFNjaGVtYXNbaV0uc2NoZW1hO1xuICAgICAgbGV0IGRvYyA9IG1wYXRoLmdldChjaGlsZFBhdGgsIGRvY3MpO1xuICAgICAgaWYgKGRvYyA9PSBudWxsKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgZG9jID0gZG9jLmZsYXQoKTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZG9jLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIG9wdHMubGVhbi50cmFuc2Zvcm0oZG9jW2ldKTtcbiAgICAgIH1cbiAgICAgIF9jb21wbGV0ZU1hbnlMZWFuKF9zY2hlbWEsIGRvYywgY2hpbGRQYXRoLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZG9jcztcbn1cbi8qKlxuICogT3ZlcnJpZGUgbXF1ZXJ5LnByb3RvdHlwZS5fbWVyZ2VVcGRhdGUgdG8gaGFuZGxlIG1vbmdvb3NlIG9iamVjdHMgaW5cbiAqIHVwZGF0ZXMuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGRvY1xuICogQG1ldGhvZCBfbWVyZ2VVcGRhdGVcbiAqIEBtZW1iZXJPZiBRdWVyeVxuICogQGluc3RhbmNlXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5RdWVyeS5wcm90b3R5cGUuX21lcmdlVXBkYXRlID0gZnVuY3Rpb24oZG9jKSB7XG4gIGlmICghdGhpcy5fdXBkYXRlKSB7XG4gICAgdGhpcy5fdXBkYXRlID0gQXJyYXkuaXNBcnJheShkb2MpID8gW10gOiB7fTtcbiAgfVxuXG4gIGlmIChkb2MgPT0gbnVsbCB8fCAodHlwZW9mIGRvYyA9PT0gJ29iamVjdCcgJiYgT2JqZWN0LmtleXMoZG9jKS5sZW5ndGggPT09IDApKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKGRvYyBpbnN0YW5jZW9mIFF1ZXJ5KSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodGhpcy5fdXBkYXRlKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgbWl4IGFycmF5IGFuZCBvYmplY3QgdXBkYXRlcycpO1xuICAgIH1cbiAgICBpZiAoZG9jLl91cGRhdGUpIHtcbiAgICAgIHV0aWxzLm1lcmdlQ2xvbmUodGhpcy5fdXBkYXRlLCBkb2MuX3VwZGF0ZSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoZG9jKSkge1xuICAgIGlmICghQXJyYXkuaXNBcnJheSh0aGlzLl91cGRhdGUpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBtaXggYXJyYXkgYW5kIG9iamVjdCB1cGRhdGVzJyk7XG4gICAgfVxuICAgIHRoaXMuX3VwZGF0ZSA9IHRoaXMuX3VwZGF0ZS5jb25jYXQoZG9jKTtcbiAgfSBlbHNlIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh0aGlzLl91cGRhdGUpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBtaXggYXJyYXkgYW5kIG9iamVjdCB1cGRhdGVzJyk7XG4gICAgfVxuICAgIHV0aWxzLm1lcmdlQ2xvbmUodGhpcy5fdXBkYXRlLCBkb2MpO1xuICB9XG59O1xuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cbmFzeW5jIGZ1bmN0aW9uIF91cGRhdGVUaHVuayhvcCkge1xuICB0aGlzLl9jYXN0Q29uZGl0aW9ucygpO1xuXG4gIF9jYXN0QXJyYXlGaWx0ZXJzKHRoaXMpO1xuXG4gIGlmICh0aGlzLmVycm9yKCkgIT0gbnVsbCkge1xuICAgIHRocm93IHRoaXMuZXJyb3IoKTtcbiAgfVxuXG4gIGNvbnN0IGNhc3RlZFF1ZXJ5ID0gdGhpcy5fY29uZGl0aW9ucztcbiAgY29uc3Qgb3B0aW9ucyA9IHRoaXMuX29wdGlvbnNGb3JFeGVjKHRoaXMubW9kZWwpO1xuICB0aGlzLl9hcHBseVRyYW5zbGF0ZUFsaWFzZXMob3B0aW9ucyk7XG5cbiAgdGhpcy5fdXBkYXRlID0gY2xvbmUodGhpcy5fdXBkYXRlLCBvcHRpb25zKTtcbiAgY29uc3QgaXNPdmVyd3JpdGluZyA9IG9wID09PSAncmVwbGFjZU9uZSc7XG4gIGlmIChpc092ZXJ3cml0aW5nKSB7XG4gICAgdGhpcy5fdXBkYXRlID0gbmV3IHRoaXMubW9kZWwodGhpcy5fdXBkYXRlLCBudWxsLCB0cnVlKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLl91cGRhdGUgPSB0aGlzLl9jYXN0VXBkYXRlKHRoaXMuX3VwZGF0ZSk7XG5cbiAgICBpZiAodGhpcy5fdXBkYXRlID09IG51bGwgfHwgT2JqZWN0LmtleXModGhpcy5fdXBkYXRlKS5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiB7IGFja25vd2xlZGdlZDogZmFsc2UgfTtcbiAgICB9XG5cbiAgICBjb25zdCBfb3B0cyA9IE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMsIHtcbiAgICAgIHNldERlZmF1bHRzT25JbnNlcnQ6IHRoaXMuX21vbmdvb3NlT3B0aW9ucy5zZXREZWZhdWx0c09uSW5zZXJ0XG4gICAgfSk7XG4gICAgdGhpcy5fdXBkYXRlID0gc2V0RGVmYXVsdHNPbkluc2VydCh0aGlzLl9jb25kaXRpb25zLCB0aGlzLm1vZGVsLnNjaGVtYSxcbiAgICAgIHRoaXMuX3VwZGF0ZSwgX29wdHMpO1xuICB9XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkob3B0aW9ucy5hcnJheUZpbHRlcnMpKSB7XG4gICAgb3B0aW9ucy5hcnJheUZpbHRlcnMgPSByZW1vdmVVbnVzZWRBcnJheUZpbHRlcnModGhpcy5fdXBkYXRlLCBvcHRpb25zLmFycmF5RmlsdGVycyk7XG4gIH1cblxuICBjb25zdCBydW5WYWxpZGF0b3JzID0gX2dldE9wdGlvbih0aGlzLCAncnVuVmFsaWRhdG9ycycsIGZhbHNlKTtcbiAgaWYgKHJ1blZhbGlkYXRvcnMpIHtcbiAgICBhd2FpdCB0aGlzLnZhbGlkYXRlKHRoaXMuX3VwZGF0ZSwgb3B0aW9ucywgaXNPdmVyd3JpdGluZyk7XG4gIH1cblxuICBpZiAodGhpcy5fdXBkYXRlLnRvQlNPTikge1xuICAgIHRoaXMuX3VwZGF0ZSA9IHRoaXMuX3VwZGF0ZS50b0JTT04oKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzLm1vbmdvb3NlQ29sbGVjdGlvbltvcF0oY2FzdGVkUXVlcnksIHRoaXMuX3VwZGF0ZSwgb3B0aW9ucyk7XG59XG5cbi8qKlxuICogTW9uZ29vc2UgY2FsbHMgdGhpcyBmdW5jdGlvbiBpbnRlcm5hbGx5IHRvIHZhbGlkYXRlIHRoZSBxdWVyeSBpZlxuICogYHJ1blZhbGlkYXRvcnNgIGlzIHNldFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBjYXN0ZWREb2MgdGhlIHVwZGF0ZSwgYWZ0ZXIgY2FzdGluZ1xuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgdGhlIG9wdGlvbnMgZnJvbSBgX29wdGlvbnNGb3JFeGVjKClgXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGlzT3ZlcndyaXRpbmdcbiAqIEBtZXRob2QgdmFsaWRhdGVcbiAqIEBtZW1iZXJPZiBRdWVyeVxuICogQGluc3RhbmNlXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5RdWVyeS5wcm90b3R5cGUudmFsaWRhdGUgPSBhc3luYyBmdW5jdGlvbiB2YWxpZGF0ZShjYXN0ZWREb2MsIG9wdGlvbnMsIGlzT3ZlcndyaXRpbmcpIHtcbiAgaWYgKHR5cGVvZiBhcmd1bWVudHNbM10gPT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgTW9uZ29vc2VFcnJvcignUXVlcnkucHJvdG90eXBlLnZhbGlkYXRlKCkgbm8gbG9uZ2VyIGFjY2VwdHMgYSBjYWxsYmFjaycpO1xuICB9XG5cbiAgYXdhaXQgX2V4ZWN1dGVQcmVIb29rcyh0aGlzLCAndmFsaWRhdGUnKTtcblxuICBpZiAoaXNPdmVyd3JpdGluZykge1xuICAgIGF3YWl0IGNhc3RlZERvYy4kdmFsaWRhdGUoKTtcbiAgfSBlbHNlIHtcbiAgICBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICB1cGRhdGVWYWxpZGF0b3JzKHRoaXMsIHRoaXMubW9kZWwuc2NoZW1hLCBjYXN0ZWREb2MsIG9wdGlvbnMsIChlcnIpID0+IHtcbiAgICAgICAgaWYgKGVyciAhPSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIHJlamVjdChlcnIpO1xuICAgICAgICB9XG4gICAgICAgIHJlc29sdmUoKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgYXdhaXQgX2V4ZWN1dGVQb3N0SG9va3ModGhpcywgbnVsbCwgbnVsbCwgJ3ZhbGlkYXRlJyk7XG59O1xuXG4vKipcbiAqIEV4ZWN1dGUgYW4gdXBkYXRlTWFueSBxdWVyeVxuICpcbiAqIEBzZWUgTW9kZWwudXBkYXRlIGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvbW9kZWwuaHRtbCNNb2RlbC51cGRhdGUoKVxuICogQG1ldGhvZCBfdXBkYXRlTWFueVxuICogQG1lbWJlck9mIFF1ZXJ5XG4gKiBAaW5zdGFuY2VcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5RdWVyeS5wcm90b3R5cGUuX3VwZGF0ZU1hbnkgPSBhc3luYyBmdW5jdGlvbiBfdXBkYXRlTWFueSgpIHtcbiAgcmV0dXJuIF91cGRhdGVUaHVuay5jYWxsKHRoaXMsICd1cGRhdGVNYW55Jyk7XG59O1xuXG4vKipcbiAqIEV4ZWN1dGUgYW4gdXBkYXRlT25lIHF1ZXJ5XG4gKlxuICogQHNlZSBNb2RlbC51cGRhdGUgaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2FwaS9tb2RlbC5odG1sI01vZGVsLnVwZGF0ZSgpXG4gKiBAbWV0aG9kIF91cGRhdGVPbmVcbiAqIEBtZW1iZXJPZiBRdWVyeVxuICogQGluc3RhbmNlXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuUXVlcnkucHJvdG90eXBlLl91cGRhdGVPbmUgPSBhc3luYyBmdW5jdGlvbiBfdXBkYXRlT25lKCkge1xuICByZXR1cm4gX3VwZGF0ZVRodW5rLmNhbGwodGhpcywgJ3VwZGF0ZU9uZScpO1xufTtcblxuLyoqXG4gKiBFeGVjdXRlIGEgcmVwbGFjZU9uZSBxdWVyeVxuICpcbiAqIEBzZWUgTW9kZWwucmVwbGFjZU9uZSBodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvYXBpL21vZGVsLmh0bWwjTW9kZWwucmVwbGFjZU9uZSgpXG4gKiBAbWV0aG9kIF9yZXBsYWNlT25lXG4gKiBAbWVtYmVyT2YgUXVlcnlcbiAqIEBpbnN0YW5jZVxuICogQGFwaSBwcml2YXRlXG4gKi9cblF1ZXJ5LnByb3RvdHlwZS5fcmVwbGFjZU9uZSA9IGFzeW5jIGZ1bmN0aW9uIF9yZXBsYWNlT25lKCkge1xuICByZXR1cm4gX3VwZGF0ZVRodW5rLmNhbGwodGhpcywgJ3JlcGxhY2VPbmUnKTtcbn07XG5cbi8qKlxuICogRGVjbGFyZSBhbmQvb3IgZXhlY3V0ZSB0aGlzIHF1ZXJ5IGFzIGFuIHVwZGF0ZU1hbnkoKSBvcGVyYXRpb24uXG4gKiBNb25nb0RCIHdpbGwgdXBkYXRlIF9hbGxfIGRvY3VtZW50cyB0aGF0IG1hdGNoIGBmaWx0ZXJgIChhcyBvcHBvc2VkIHRvIGp1c3QgdGhlIGZpcnN0IG9uZSkuXG4gKlxuICogKipOb3RlKiogdXBkYXRlTWFueSB3aWxsIF9ub3RfIGZpcmUgdXBkYXRlIG1pZGRsZXdhcmUuIFVzZSBgcHJlKCd1cGRhdGVNYW55JylgXG4gKiBhbmQgYHBvc3QoJ3VwZGF0ZU1hbnknKWAgaW5zdGVhZC5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IHJlcyA9IGF3YWl0IFBlcnNvbi51cGRhdGVNYW55KHsgbmFtZTogL1N0YXJrJC8gfSwgeyBpc0RlbGV0ZWQ6IHRydWUgfSk7XG4gKiAgICAgcmVzLm47IC8vIE51bWJlciBvZiBkb2N1bWVudHMgbWF0Y2hlZFxuICogICAgIHJlcy5uTW9kaWZpZWQ7IC8vIE51bWJlciBvZiBkb2N1bWVudHMgbW9kaWZpZWRcbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIHRyaWdnZXJzIHRoZSBmb2xsb3dpbmcgbWlkZGxld2FyZS5cbiAqXG4gKiAtIGB1cGRhdGVNYW55KClgXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IFtmaWx0ZXJdXG4gKiBAcGFyYW0ge09iamVjdHxBcnJheX0gW3VwZGF0ZV0gdGhlIHVwZGF0ZSBjb21tYW5kXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLm11bHRpcGxlQ2FzdEVycm9yXSBieSBkZWZhdWx0LCBtb25nb29zZSBvbmx5IHJldHVybnMgdGhlIGZpcnN0IGVycm9yIHRoYXQgb2NjdXJyZWQgaW4gY2FzdGluZyB0aGUgcXVlcnkuIFR1cm4gb24gdGhpcyBvcHRpb24gdG8gYWdncmVnYXRlIGFsbCB0aGUgY2FzdCBlcnJvcnMuXG4gKiBAcGFyYW0ge0Jvb2xlYW58U3RyaW5nfSBbb3B0aW9ucy5zdHJpY3RdIG92ZXJ3cml0ZXMgdGhlIHNjaGVtYSdzIFtzdHJpY3QgbW9kZSBvcHRpb25dKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9ndWlkZS5odG1sI3N0cmljdClcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMudXBzZXJ0PWZhbHNlXSBpZiB0cnVlLCBhbmQgbm8gZG9jdW1lbnRzIGZvdW5kLCBpbnNlcnQgYSBuZXcgZG9jdW1lbnRcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy53cml0ZUNvbmNlcm49bnVsbF0gc2V0cyB0aGUgW3dyaXRlIGNvbmNlcm5dKGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvbWFudWFsL3JlZmVyZW5jZS93cml0ZS1jb25jZXJuLykgZm9yIHJlcGxpY2Egc2V0cy4gT3ZlcnJpZGVzIHRoZSBbc2NoZW1hLWxldmVsIHdyaXRlIGNvbmNlcm5dKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9ndWlkZS5odG1sI3dyaXRlQ29uY2VybilcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMudGltZXN0YW1wcz1udWxsXSBJZiBzZXQgdG8gYGZhbHNlYCBhbmQgW3NjaGVtYS1sZXZlbCB0aW1lc3RhbXBzXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvZ3VpZGUuaHRtbCN0aW1lc3RhbXBzKSBhcmUgZW5hYmxlZCwgc2tpcCB0aW1lc3RhbXBzIGZvciB0aGlzIHVwZGF0ZS4gRG9lcyBub3RoaW5nIGlmIHNjaGVtYS1sZXZlbCB0aW1lc3RhbXBzIGFyZSBub3Qgc2V0LlxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy50cmFuc2xhdGVBbGlhc2VzPW51bGxdIElmIHNldCB0byBgdHJ1ZWAsIHRyYW5zbGF0ZXMgYW55IHNjaGVtYS1kZWZpbmVkIGFsaWFzZXMgaW4gYGZpbHRlcmAsIGBwcm9qZWN0aW9uYCwgYHVwZGF0ZWAsIGFuZCBgZGlzdGluY3RgLiBUaHJvd3MgYW4gZXJyb3IgaWYgdGhlcmUgYXJlIGFueSBjb25mbGljdHMgd2hlcmUgYm90aCBhbGlhcyBhbmQgcmF3IHByb3BlcnR5IGFyZSBkZWZpbmVkIG9uIHRoZSBzYW1lIG9iamVjdC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gcGFyYW1zIGFyZSAoZXJyb3IsIHdyaXRlT3BSZXN1bHQpXG4gKiBAcmV0dXJuIHtRdWVyeX0gdGhpc1xuICogQHNlZSBNb2RlbC51cGRhdGUgaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2FwaS9tb2RlbC5odG1sI01vZGVsLnVwZGF0ZSgpXG4gKiBAc2VlIFF1ZXJ5IGRvY3MgaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL3F1ZXJpZXMuaHRtbFxuICogQHNlZSB1cGRhdGUgaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvcmVmZXJlbmNlL21ldGhvZC9kYi5jb2xsZWN0aW9uLnVwZGF0ZS9cbiAqIEBzZWUgVXBkYXRlUmVzdWx0IGh0dHBzOi8vbW9uZ29kYi5naXRodWIuaW8vbm9kZS1tb25nb2RiLW5hdGl2ZS80LjkvaW50ZXJmYWNlcy9VcGRhdGVSZXN1bHQuaHRtbFxuICogQHNlZSBNb25nb0RCIGRvY3MgaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvcmVmZXJlbmNlL2NvbW1hbmQvdXBkYXRlLyN1cGRhdGUtY29tbWFuZC1vdXRwdXRcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUXVlcnkucHJvdG90eXBlLnVwZGF0ZU1hbnkgPSBmdW5jdGlvbihjb25kaXRpb25zLCBkb2MsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIC8vIC51cGRhdGUoY29uZGl0aW9ucywgZG9jLCBjYWxsYmFjaylcbiAgICBjYWxsYmFjayA9IG9wdGlvbnM7XG4gICAgb3B0aW9ucyA9IG51bGw7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGRvYyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIC8vIC51cGRhdGUoZG9jLCBjYWxsYmFjayk7XG4gICAgY2FsbGJhY2sgPSBkb2M7XG4gICAgZG9jID0gY29uZGl0aW9ucztcbiAgICBjb25kaXRpb25zID0ge307XG4gICAgb3B0aW9ucyA9IG51bGw7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGNvbmRpdGlvbnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAvLyAudXBkYXRlKGNhbGxiYWNrKVxuICAgIGNhbGxiYWNrID0gY29uZGl0aW9ucztcbiAgICBjb25kaXRpb25zID0gdW5kZWZpbmVkO1xuICAgIGRvYyA9IHVuZGVmaW5lZDtcbiAgICBvcHRpb25zID0gdW5kZWZpbmVkO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBjb25kaXRpb25zID09PSAnb2JqZWN0JyAmJiAhZG9jICYmICFvcHRpb25zICYmICFjYWxsYmFjaykge1xuICAgIC8vIC51cGRhdGUoZG9jKVxuICAgIGRvYyA9IGNvbmRpdGlvbnM7XG4gICAgY29uZGl0aW9ucyA9IHVuZGVmaW5lZDtcbiAgICBvcHRpb25zID0gdW5kZWZpbmVkO1xuICAgIGNhbGxiYWNrID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgcmV0dXJuIF91cGRhdGUodGhpcywgJ3VwZGF0ZU1hbnknLCBjb25kaXRpb25zLCBkb2MsIG9wdGlvbnMsIGNhbGxiYWNrKTtcbn07XG5cbi8qKlxuICogRGVjbGFyZSBhbmQvb3IgZXhlY3V0ZSB0aGlzIHF1ZXJ5IGFzIGFuIHVwZGF0ZU9uZSgpIG9wZXJhdGlvbi5cbiAqIE1vbmdvREIgd2lsbCB1cGRhdGUgX29ubHlfIHRoZSBmaXJzdCBkb2N1bWVudCB0aGF0IG1hdGNoZXMgYGZpbHRlcmAuXG4gKlxuICogLSBVc2UgYHJlcGxhY2VPbmUoKWAgaWYgeW91IHdhbnQgdG8gb3ZlcndyaXRlIGFuIGVudGlyZSBkb2N1bWVudCByYXRoZXIgdGhhbiB1c2luZyBbYXRvbWljIG9wZXJhdG9yc10oaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvdHV0b3JpYWwvbW9kZWwtZGF0YS1mb3ItYXRvbWljLW9wZXJhdGlvbnMvI3BhdHRlcm4pIGxpa2UgYCRzZXRgLlxuICpcbiAqICoqTm90ZSoqIHVwZGF0ZU9uZSB3aWxsIF9ub3RfIGZpcmUgdXBkYXRlIG1pZGRsZXdhcmUuIFVzZSBgcHJlKCd1cGRhdGVPbmUnKWBcbiAqIGFuZCBgcG9zdCgndXBkYXRlT25lJylgIGluc3RlYWQuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBjb25zdCByZXMgPSBhd2FpdCBQZXJzb24udXBkYXRlT25lKHsgbmFtZTogJ0plYW4tTHVjIFBpY2FyZCcgfSwgeyBzaGlwOiAnVVNTIEVudGVycHJpc2UnIH0pO1xuICogICAgIHJlcy5hY2tub3dsZWRnZWQ7IC8vIEluZGljYXRlcyBpZiB0aGlzIHdyaXRlIHJlc3VsdCB3YXMgYWNrbm93bGVkZ2VkLiBJZiBub3QsIHRoZW4gYWxsIG90aGVyIG1lbWJlcnMgb2YgdGhpcyByZXN1bHQgd2lsbCBiZSB1bmRlZmluZWQuXG4gKiAgICAgcmVzLm1hdGNoZWRDb3VudDsgLy8gTnVtYmVyIG9mIGRvY3VtZW50cyB0aGF0IG1hdGNoZWQgdGhlIGZpbHRlclxuICogICAgIHJlcy5tb2RpZmllZENvdW50OyAvLyBOdW1iZXIgb2YgZG9jdW1lbnRzIHRoYXQgd2VyZSBtb2RpZmllZFxuICogICAgIHJlcy51cHNlcnRlZENvdW50OyAvLyBOdW1iZXIgb2YgZG9jdW1lbnRzIHRoYXQgd2VyZSB1cHNlcnRlZFxuICogICAgIHJlcy51cHNlcnRlZElkOyAvLyBJZGVudGlmaWVyIG9mIHRoZSBpbnNlcnRlZCBkb2N1bWVudCAoaWYgYW4gdXBzZXJ0IHRvb2sgcGxhY2UpXG4gKlxuICogVGhpcyBmdW5jdGlvbiB0cmlnZ2VycyB0aGUgZm9sbG93aW5nIG1pZGRsZXdhcmUuXG4gKlxuICogLSBgdXBkYXRlT25lKClgXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IFtmaWx0ZXJdXG4gKiBAcGFyYW0ge09iamVjdHxBcnJheX0gW3VwZGF0ZV0gdGhlIHVwZGF0ZSBjb21tYW5kXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLm11bHRpcGxlQ2FzdEVycm9yXSBieSBkZWZhdWx0LCBtb25nb29zZSBvbmx5IHJldHVybnMgdGhlIGZpcnN0IGVycm9yIHRoYXQgb2NjdXJyZWQgaW4gY2FzdGluZyB0aGUgcXVlcnkuIFR1cm4gb24gdGhpcyBvcHRpb24gdG8gYWdncmVnYXRlIGFsbCB0aGUgY2FzdCBlcnJvcnMuXG4gKiBAcGFyYW0ge0Jvb2xlYW58U3RyaW5nfSBbb3B0aW9ucy5zdHJpY3RdIG92ZXJ3cml0ZXMgdGhlIHNjaGVtYSdzIFtzdHJpY3QgbW9kZSBvcHRpb25dKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9ndWlkZS5odG1sI3N0cmljdClcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMudXBzZXJ0PWZhbHNlXSBpZiB0cnVlLCBhbmQgbm8gZG9jdW1lbnRzIGZvdW5kLCBpbnNlcnQgYSBuZXcgZG9jdW1lbnRcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy53cml0ZUNvbmNlcm49bnVsbF0gc2V0cyB0aGUgW3dyaXRlIGNvbmNlcm5dKGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvbWFudWFsL3JlZmVyZW5jZS93cml0ZS1jb25jZXJuLykgZm9yIHJlcGxpY2Egc2V0cy4gT3ZlcnJpZGVzIHRoZSBbc2NoZW1hLWxldmVsIHdyaXRlIGNvbmNlcm5dKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9ndWlkZS5odG1sI3dyaXRlQ29uY2VybilcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMudGltZXN0YW1wcz1udWxsXSBJZiBzZXQgdG8gYGZhbHNlYCBhbmQgW3NjaGVtYS1sZXZlbCB0aW1lc3RhbXBzXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvZ3VpZGUuaHRtbCN0aW1lc3RhbXBzKSBhcmUgZW5hYmxlZCwgc2tpcCB0aW1lc3RhbXBzIGZvciB0aGlzIHVwZGF0ZS4gTm90ZSB0aGF0IHRoaXMgYWxsb3dzIHlvdSB0byBvdmVyd3JpdGUgdGltZXN0YW1wcy4gRG9lcyBub3RoaW5nIGlmIHNjaGVtYS1sZXZlbCB0aW1lc3RhbXBzIGFyZSBub3Qgc2V0LlxuIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMudHJhbnNsYXRlQWxpYXNlcz1udWxsXSBJZiBzZXQgdG8gYHRydWVgLCB0cmFuc2xhdGVzIGFueSBzY2hlbWEtZGVmaW5lZCBhbGlhc2VzIGluIGBmaWx0ZXJgLCBgcHJvamVjdGlvbmAsIGB1cGRhdGVgLCBhbmQgYGRpc3RpbmN0YC4gVGhyb3dzIGFuIGVycm9yIGlmIHRoZXJlIGFyZSBhbnkgY29uZmxpY3RzIHdoZXJlIGJvdGggYWxpYXMgYW5kIHJhdyBwcm9wZXJ0eSBhcmUgZGVmaW5lZCBvbiB0aGUgc2FtZSBvYmplY3QuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIHBhcmFtcyBhcmUgKGVycm9yLCB3cml0ZU9wUmVzdWx0KVxuICogQHJldHVybiB7UXVlcnl9IHRoaXNcbiAqIEBzZWUgTW9kZWwudXBkYXRlIGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvbW9kZWwuaHRtbCNNb2RlbC51cGRhdGUoKVxuICogQHNlZSBRdWVyeSBkb2NzIGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9xdWVyaWVzLmh0bWxcbiAqIEBzZWUgdXBkYXRlIGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvbWFudWFsL3JlZmVyZW5jZS9tZXRob2QvZGIuY29sbGVjdGlvbi51cGRhdGUvXG4gKiBAc2VlIFVwZGF0ZVJlc3VsdCBodHRwczovL21vbmdvZGIuZ2l0aHViLmlvL25vZGUtbW9uZ29kYi1uYXRpdmUvNC45L2ludGVyZmFjZXMvVXBkYXRlUmVzdWx0Lmh0bWxcbiAqIEBzZWUgTW9uZ29EQiBkb2NzIGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvbWFudWFsL3JlZmVyZW5jZS9jb21tYW5kL3VwZGF0ZS8jdXBkYXRlLWNvbW1hbmQtb3V0cHV0XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblF1ZXJ5LnByb3RvdHlwZS51cGRhdGVPbmUgPSBmdW5jdGlvbihjb25kaXRpb25zLCBkb2MsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIC8vIC51cGRhdGUoY29uZGl0aW9ucywgZG9jLCBjYWxsYmFjaylcbiAgICBjYWxsYmFjayA9IG9wdGlvbnM7XG4gICAgb3B0aW9ucyA9IG51bGw7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGRvYyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIC8vIC51cGRhdGUoZG9jLCBjYWxsYmFjayk7XG4gICAgY2FsbGJhY2sgPSBkb2M7XG4gICAgZG9jID0gY29uZGl0aW9ucztcbiAgICBjb25kaXRpb25zID0ge307XG4gICAgb3B0aW9ucyA9IG51bGw7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGNvbmRpdGlvbnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAvLyAudXBkYXRlKGNhbGxiYWNrKVxuICAgIGNhbGxiYWNrID0gY29uZGl0aW9ucztcbiAgICBjb25kaXRpb25zID0gdW5kZWZpbmVkO1xuICAgIGRvYyA9IHVuZGVmaW5lZDtcbiAgICBvcHRpb25zID0gdW5kZWZpbmVkO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBjb25kaXRpb25zID09PSAnb2JqZWN0JyAmJiAhZG9jICYmICFvcHRpb25zICYmICFjYWxsYmFjaykge1xuICAgIC8vIC51cGRhdGUoZG9jKVxuICAgIGRvYyA9IGNvbmRpdGlvbnM7XG4gICAgY29uZGl0aW9ucyA9IHVuZGVmaW5lZDtcbiAgICBvcHRpb25zID0gdW5kZWZpbmVkO1xuICAgIGNhbGxiYWNrID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgcmV0dXJuIF91cGRhdGUodGhpcywgJ3VwZGF0ZU9uZScsIGNvbmRpdGlvbnMsIGRvYywgb3B0aW9ucywgY2FsbGJhY2spO1xufTtcblxuLyoqXG4gKiBEZWNsYXJlIGFuZC9vciBleGVjdXRlIHRoaXMgcXVlcnkgYXMgYSByZXBsYWNlT25lKCkgb3BlcmF0aW9uLlxuICogTW9uZ29EQiB3aWxsIHJlcGxhY2UgdGhlIGV4aXN0aW5nIGRvY3VtZW50IGFuZCB3aWxsIG5vdCBhY2NlcHQgYW55IFthdG9taWMgb3BlcmF0b3JzXShodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC90dXRvcmlhbC9tb2RlbC1kYXRhLWZvci1hdG9taWMtb3BlcmF0aW9ucy8jcGF0dGVybikgKGAkc2V0YCwgZXRjLilcbiAqXG4gKiAqKk5vdGUqKiByZXBsYWNlT25lIHdpbGwgX25vdF8gZmlyZSB1cGRhdGUgbWlkZGxld2FyZS4gVXNlIGBwcmUoJ3JlcGxhY2VPbmUnKWBcbiAqIGFuZCBgcG9zdCgncmVwbGFjZU9uZScpYCBpbnN0ZWFkLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgY29uc3QgcmVzID0gYXdhaXQgUGVyc29uLnJlcGxhY2VPbmUoeyBfaWQ6IDI0NjAxIH0sIHsgbmFtZTogJ0plYW4gVmFsamVhbicgfSk7XG4gKiAgICAgcmVzLmFja25vd2xlZGdlZDsgLy8gSW5kaWNhdGVzIGlmIHRoaXMgd3JpdGUgcmVzdWx0IHdhcyBhY2tub3dsZWRnZWQuIElmIG5vdCwgdGhlbiBhbGwgb3RoZXIgbWVtYmVycyBvZiB0aGlzIHJlc3VsdCB3aWxsIGJlIHVuZGVmaW5lZC5cbiAqICAgICByZXMubWF0Y2hlZENvdW50OyAvLyBOdW1iZXIgb2YgZG9jdW1lbnRzIHRoYXQgbWF0Y2hlZCB0aGUgZmlsdGVyXG4gKiAgICAgcmVzLm1vZGlmaWVkQ291bnQ7IC8vIE51bWJlciBvZiBkb2N1bWVudHMgdGhhdCB3ZXJlIG1vZGlmaWVkXG4gKiAgICAgcmVzLnVwc2VydGVkQ291bnQ7IC8vIE51bWJlciBvZiBkb2N1bWVudHMgdGhhdCB3ZXJlIHVwc2VydGVkXG4gKiAgICAgcmVzLnVwc2VydGVkSWQ7IC8vIElkZW50aWZpZXIgb2YgdGhlIGluc2VydGVkIGRvY3VtZW50IChpZiBhbiB1cHNlcnQgdG9vayBwbGFjZSlcbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIHRyaWdnZXJzIHRoZSBmb2xsb3dpbmcgbWlkZGxld2FyZS5cbiAqXG4gKiAtIGByZXBsYWNlT25lKClgXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IFtmaWx0ZXJdXG4gKiBAcGFyYW0ge09iamVjdH0gW2RvY10gdGhlIHVwZGF0ZSBjb21tYW5kXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLm11bHRpcGxlQ2FzdEVycm9yXSBieSBkZWZhdWx0LCBtb25nb29zZSBvbmx5IHJldHVybnMgdGhlIGZpcnN0IGVycm9yIHRoYXQgb2NjdXJyZWQgaW4gY2FzdGluZyB0aGUgcXVlcnkuIFR1cm4gb24gdGhpcyBvcHRpb24gdG8gYWdncmVnYXRlIGFsbCB0aGUgY2FzdCBlcnJvcnMuXG4gKiBAcGFyYW0ge0Jvb2xlYW58U3RyaW5nfSBbb3B0aW9ucy5zdHJpY3RdIG92ZXJ3cml0ZXMgdGhlIHNjaGVtYSdzIFtzdHJpY3QgbW9kZSBvcHRpb25dKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9ndWlkZS5odG1sI3N0cmljdClcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMudXBzZXJ0PWZhbHNlXSBpZiB0cnVlLCBhbmQgbm8gZG9jdW1lbnRzIGZvdW5kLCBpbnNlcnQgYSBuZXcgZG9jdW1lbnRcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy53cml0ZUNvbmNlcm49bnVsbF0gc2V0cyB0aGUgW3dyaXRlIGNvbmNlcm5dKGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvbWFudWFsL3JlZmVyZW5jZS93cml0ZS1jb25jZXJuLykgZm9yIHJlcGxpY2Egc2V0cy4gT3ZlcnJpZGVzIHRoZSBbc2NoZW1hLWxldmVsIHdyaXRlIGNvbmNlcm5dKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9ndWlkZS5odG1sI3dyaXRlQ29uY2VybilcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMudGltZXN0YW1wcz1udWxsXSBJZiBzZXQgdG8gYGZhbHNlYCBhbmQgW3NjaGVtYS1sZXZlbCB0aW1lc3RhbXBzXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvZ3VpZGUuaHRtbCN0aW1lc3RhbXBzKSBhcmUgZW5hYmxlZCwgc2tpcCB0aW1lc3RhbXBzIGZvciB0aGlzIHVwZGF0ZS4gRG9lcyBub3RoaW5nIGlmIHNjaGVtYS1sZXZlbCB0aW1lc3RhbXBzIGFyZSBub3Qgc2V0LlxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy50cmFuc2xhdGVBbGlhc2VzPW51bGxdIElmIHNldCB0byBgdHJ1ZWAsIHRyYW5zbGF0ZXMgYW55IHNjaGVtYS1kZWZpbmVkIGFsaWFzZXMgaW4gYGZpbHRlcmAsIGBwcm9qZWN0aW9uYCwgYHVwZGF0ZWAsIGFuZCBgZGlzdGluY3RgLiBUaHJvd3MgYW4gZXJyb3IgaWYgdGhlcmUgYXJlIGFueSBjb25mbGljdHMgd2hlcmUgYm90aCBhbGlhcyBhbmQgcmF3IHByb3BlcnR5IGFyZSBkZWZpbmVkIG9uIHRoZSBzYW1lIG9iamVjdC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gcGFyYW1zIGFyZSAoZXJyb3IsIHdyaXRlT3BSZXN1bHQpXG4gKiBAcmV0dXJuIHtRdWVyeX0gdGhpc1xuICogQHNlZSBNb2RlbC51cGRhdGUgaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2FwaS9tb2RlbC5odG1sI01vZGVsLnVwZGF0ZSgpXG4gKiBAc2VlIFF1ZXJ5IGRvY3MgaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL3F1ZXJpZXMuaHRtbFxuICogQHNlZSB1cGRhdGUgaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvcmVmZXJlbmNlL21ldGhvZC9kYi5jb2xsZWN0aW9uLnVwZGF0ZS9cbiAqIEBzZWUgVXBkYXRlUmVzdWx0IGh0dHBzOi8vbW9uZ29kYi5naXRodWIuaW8vbm9kZS1tb25nb2RiLW5hdGl2ZS80LjkvaW50ZXJmYWNlcy9VcGRhdGVSZXN1bHQuaHRtbFxuICogQHNlZSBNb25nb0RCIGRvY3MgaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvcmVmZXJlbmNlL2NvbW1hbmQvdXBkYXRlLyN1cGRhdGUtY29tbWFuZC1vdXRwdXRcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUXVlcnkucHJvdG90eXBlLnJlcGxhY2VPbmUgPSBmdW5jdGlvbihjb25kaXRpb25zLCBkb2MsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIC8vIC51cGRhdGUoY29uZGl0aW9ucywgZG9jLCBjYWxsYmFjaylcbiAgICBjYWxsYmFjayA9IG9wdGlvbnM7XG4gICAgb3B0aW9ucyA9IG51bGw7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGRvYyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIC8vIC51cGRhdGUoZG9jLCBjYWxsYmFjayk7XG4gICAgY2FsbGJhY2sgPSBkb2M7XG4gICAgZG9jID0gY29uZGl0aW9ucztcbiAgICBjb25kaXRpb25zID0ge307XG4gICAgb3B0aW9ucyA9IG51bGw7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGNvbmRpdGlvbnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAvLyAudXBkYXRlKGNhbGxiYWNrKVxuICAgIGNhbGxiYWNrID0gY29uZGl0aW9ucztcbiAgICBjb25kaXRpb25zID0gdW5kZWZpbmVkO1xuICAgIGRvYyA9IHVuZGVmaW5lZDtcbiAgICBvcHRpb25zID0gdW5kZWZpbmVkO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBjb25kaXRpb25zID09PSAnb2JqZWN0JyAmJiAhZG9jICYmICFvcHRpb25zICYmICFjYWxsYmFjaykge1xuICAgIC8vIC51cGRhdGUoZG9jKVxuICAgIGRvYyA9IGNvbmRpdGlvbnM7XG4gICAgY29uZGl0aW9ucyA9IHVuZGVmaW5lZDtcbiAgICBvcHRpb25zID0gdW5kZWZpbmVkO1xuICAgIGNhbGxiYWNrID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgcmV0dXJuIF91cGRhdGUodGhpcywgJ3JlcGxhY2VPbmUnLCBjb25kaXRpb25zLCBkb2MsIG9wdGlvbnMsIGNhbGxiYWNrKTtcbn07XG5cbi8qKlxuICogSW50ZXJuYWwgaGVscGVyIGZvciB1cGRhdGUsIHVwZGF0ZU1hbnksIHVwZGF0ZU9uZSwgcmVwbGFjZU9uZVxuICogQHBhcmFtIHtRdWVyeX0gcXVlcnlcbiAqIEBwYXJhbSB7U3RyaW5nfSBvcFxuICogQHBhcmFtIHtPYmplY3R9IGZpbHRlclxuICogQHBhcmFtIHtEb2N1bWVudH0gW2RvY11cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBfdXBkYXRlKHF1ZXJ5LCBvcCwgZmlsdGVyLCBkb2MsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gIC8vIG1ha2Ugc3VyZSB3ZSBkb24ndCBzZW5kIGluIHRoZSB3aG9sZSBEb2N1bWVudCB0byBtZXJnZSgpXG4gIHF1ZXJ5Lm9wID0gb3A7XG4gIHF1ZXJ5Ll92YWxpZGF0ZU9wKCk7XG4gIGRvYyA9IGRvYyB8fCB7fTtcblxuICAvLyBzdHJpY3QgaXMgYW4gb3B0aW9uIHVzZWQgaW4gdGhlIHVwZGF0ZSBjaGVja2luZywgbWFrZSBzdXJlIGl0IGdldHMgc2V0XG4gIGlmIChvcHRpb25zICE9IG51bGwpIHtcbiAgICBpZiAoJ3N0cmljdCcgaW4gb3B0aW9ucykge1xuICAgICAgcXVlcnkuX21vbmdvb3NlT3B0aW9ucy5zdHJpY3QgPSBvcHRpb25zLnN0cmljdDtcbiAgICB9XG4gIH1cblxuICBpZiAoIShmaWx0ZXIgaW5zdGFuY2VvZiBRdWVyeSkgJiZcbiAgICAgIGZpbHRlciAhPSBudWxsICYmXG4gICAgICBmaWx0ZXIudG9TdHJpbmcoKSAhPT0gJ1tvYmplY3QgT2JqZWN0XScpIHtcbiAgICBxdWVyeS5lcnJvcihuZXcgT2JqZWN0UGFyYW1ldGVyRXJyb3IoZmlsdGVyLCAnZmlsdGVyJywgb3ApKTtcbiAgfSBlbHNlIHtcbiAgICBxdWVyeS5tZXJnZShmaWx0ZXIpO1xuICB9XG5cbiAgaWYgKHV0aWxzLmlzT2JqZWN0KG9wdGlvbnMpKSB7XG4gICAgcXVlcnkuc2V0T3B0aW9ucyhvcHRpb25zKTtcbiAgfVxuXG4gIHF1ZXJ5Ll9tZXJnZVVwZGF0ZShkb2MpO1xuXG4gIC8vIEhvb2tzXG4gIGlmIChjYWxsYmFjaykge1xuICAgIHF1ZXJ5LmV4ZWMoY2FsbGJhY2spO1xuXG4gICAgcmV0dXJuIHF1ZXJ5O1xuICB9XG5cbiAgcmV0dXJuIHF1ZXJ5O1xufVxuXG4vKipcbiAqIFJ1bnMgYSBmdW5jdGlvbiBgZm5gIGFuZCB0cmVhdHMgdGhlIHJldHVybiB2YWx1ZSBvZiBgZm5gIGFzIHRoZSBuZXcgdmFsdWVcbiAqIGZvciB0aGUgcXVlcnkgdG8gcmVzb2x2ZSB0by5cbiAqXG4gKiBBbnkgZnVuY3Rpb25zIHlvdSBwYXNzIHRvIGB0cmFuc2Zvcm0oKWAgd2lsbCBydW4gKiphZnRlcioqIGFueSBwb3N0IGhvb2tzLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgY29uc3QgcmVzID0gYXdhaXQgTXlNb2RlbC5maW5kT25lKCkudHJhbnNmb3JtKHJlcyA9PiB7XG4gKiAgICAgICAvLyBTZXRzIGEgYGxvYWRlZEF0YCBwcm9wZXJ0eSBvbiB0aGUgZG9jIHRoYXQgdGVsbHMgeW91IHRoZSB0aW1lIHRoZVxuICogICAgICAgLy8gZG9jdW1lbnQgd2FzIGxvYWRlZC5cbiAqICAgICAgIHJldHVybiByZXMgPT0gbnVsbCA/XG4gKiAgICAgICAgIHJlcyA6XG4gKiAgICAgICAgIE9iamVjdC5hc3NpZ24ocmVzLCB7IGxvYWRlZEF0OiBuZXcgRGF0ZSgpIH0pO1xuICogICAgIH0pO1xuICpcbiAqIEBtZXRob2QgdHJhbnNmb3JtXG4gKiBAbWVtYmVyT2YgUXVlcnlcbiAqIEBpbnN0YW5jZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gZnVuY3Rpb24gdG8gcnVuIHRvIHRyYW5zZm9ybSB0aGUgcXVlcnkgcmVzdWx0XG4gKiBAcmV0dXJuIHtRdWVyeX0gdGhpc1xuICovXG5cblF1ZXJ5LnByb3RvdHlwZS50cmFuc2Zvcm0gPSBmdW5jdGlvbihmbikge1xuICB0aGlzLl90cmFuc2Zvcm1zLnB1c2goZm4pO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogTWFrZSB0aGlzIHF1ZXJ5IHRocm93IGFuIGVycm9yIGlmIG5vIGRvY3VtZW50cyBtYXRjaCB0aGUgZ2l2ZW4gYGZpbHRlcmAuXG4gKiBUaGlzIGlzIGhhbmR5IGZvciBpbnRlZ3JhdGluZyB3aXRoIGFzeW5jL2F3YWl0LCBiZWNhdXNlIGBvckZhaWwoKWAgc2F2ZXMgeW91XG4gKiBhbiBleHRyYSBgaWZgIHN0YXRlbWVudCB0byBjaGVjayBpZiBubyBkb2N1bWVudCB3YXMgZm91bmQuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICAvLyBUaHJvd3MgaWYgbm8gZG9jIHJldHVybmVkXG4gKiAgICAgYXdhaXQgTW9kZWwuZmluZE9uZSh7IGZvbzogJ2JhcicgfSkub3JGYWlsKCk7XG4gKlxuICogICAgIC8vIFRocm93cyBpZiBubyBkb2N1bWVudCB3YXMgdXBkYXRlZC4gTm90ZSB0aGF0IGBvckZhaWwoKWAgd2lsbCBzdGlsbFxuICogICAgIC8vIHRocm93IGlmIHRoZSBvbmx5IGRvY3VtZW50IHRoYXQgbWF0Y2hlcyBpcyBgeyBmb286ICdiYXInLCBuYW1lOiAndGVzdCcgfWAsXG4gKiAgICAgLy8gYmVjYXVzZSBgb3JGYWlsKClgIHdpbGwgdGhyb3cgaWYgbm8gZG9jdW1lbnQgd2FzIF91cGRhdGVkXywgbm90XG4gKiAgICAgLy8gaWYgbm8gZG9jdW1lbnQgd2FzIF9mb3VuZF8uXG4gKiAgICAgYXdhaXQgTW9kZWwudXBkYXRlT25lKHsgZm9vOiAnYmFyJyB9LCB7IG5hbWU6ICd0ZXN0JyB9KS5vckZhaWwoKTtcbiAqXG4gKiAgICAgLy8gVGhyb3dzIFwiTm8gZG9jcyBmb3VuZCFcIiBlcnJvciBpZiBubyBkb2NzIG1hdGNoIGB7IGZvbzogJ2JhcicgfWBcbiAqICAgICBhd2FpdCBNb2RlbC5maW5kKHsgZm9vOiAnYmFyJyB9KS5vckZhaWwobmV3IEVycm9yKCdObyBkb2NzIGZvdW5kIScpKTtcbiAqXG4gKiAgICAgLy8gVGhyb3dzIFwiTm90IGZvdW5kXCIgZXJyb3IgaWYgbm8gZG9jdW1lbnQgd2FzIGZvdW5kXG4gKiAgICAgYXdhaXQgTW9kZWwuZmluZE9uZUFuZFVwZGF0ZSh7IGZvbzogJ2JhcicgfSwgeyBuYW1lOiAndGVzdCcgfSkuXG4gKiAgICAgICBvckZhaWwoKCkgPT4gRXJyb3IoJ05vdCBmb3VuZCcpKTtcbiAqXG4gKiBAbWV0aG9kIG9yRmFpbFxuICogQG1lbWJlck9mIFF1ZXJ5XG4gKiBAaW5zdGFuY2VcbiAqIEBwYXJhbSB7RnVuY3Rpb258RXJyb3J9IFtlcnJdIG9wdGlvbmFsIGVycm9yIHRvIHRocm93IGlmIG5vIGRvY3MgbWF0Y2ggYGZpbHRlcmAuIElmIG5vdCBzcGVjaWZpZWQsIGBvckZhaWwoKWAgd2lsbCB0aHJvdyBhIGBEb2N1bWVudE5vdEZvdW5kRXJyb3JgXG4gKiBAcmV0dXJuIHtRdWVyeX0gdGhpc1xuICovXG5cblF1ZXJ5LnByb3RvdHlwZS5vckZhaWwgPSBmdW5jdGlvbihlcnIpIHtcbiAgdGhpcy50cmFuc2Zvcm0ocmVzID0+IHtcbiAgICBzd2l0Y2ggKHRoaXMub3ApIHtcbiAgICAgIGNhc2UgJ2ZpbmQnOlxuICAgICAgICBpZiAocmVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHRocm93IF9vckZhaWxFcnJvcihlcnIsIHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnZmluZE9uZSc6XG4gICAgICAgIGlmIChyZXMgPT0gbnVsbCkge1xuICAgICAgICAgIHRocm93IF9vckZhaWxFcnJvcihlcnIsIHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAncmVwbGFjZU9uZSc6XG4gICAgICBjYXNlICd1cGRhdGVNYW55JzpcbiAgICAgIGNhc2UgJ3VwZGF0ZU9uZSc6XG4gICAgICAgIGlmIChyZXMgJiYgcmVzLm1hdGNoZWRDb3VudCA9PT0gMCkge1xuICAgICAgICAgIHRocm93IF9vckZhaWxFcnJvcihlcnIsIHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnZmluZE9uZUFuZERlbGV0ZSc6XG4gICAgICBjYXNlICdmaW5kT25lQW5kVXBkYXRlJzpcbiAgICAgIGNhc2UgJ2ZpbmRPbmVBbmRSZXBsYWNlJzpcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5pbmNsdWRlUmVzdWx0TWV0YWRhdGEgJiYgcmVzICE9IG51bGwgJiYgcmVzLnZhbHVlID09IG51bGwpIHtcbiAgICAgICAgICB0aHJvdyBfb3JGYWlsRXJyb3IoZXJyLCB0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMub3B0aW9ucy5pbmNsdWRlUmVzdWx0TWV0YWRhdGEgJiYgcmVzID09IG51bGwpIHtcbiAgICAgICAgICB0aHJvdyBfb3JGYWlsRXJyb3IoZXJyLCB0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2RlbGV0ZU1hbnknOlxuICAgICAgY2FzZSAnZGVsZXRlT25lJzpcbiAgICAgICAgaWYgKHJlcy5kZWxldGVkQ291bnQgPT09IDApIHtcbiAgICAgICAgICB0aHJvdyBfb3JGYWlsRXJyb3IoZXJyLCB0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIHJldHVybiByZXM7XG4gIH0pO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogR2V0IHRoZSBlcnJvciB0byB0aHJvdyBmb3IgYG9yRmFpbCgpYFxuICogQHBhcmFtIHtFcnJvcnx1bmRlZmluZWR9IGVyclxuICogQHBhcmFtIHtRdWVyeX0gcXVlcnlcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIF9vckZhaWxFcnJvcihlcnIsIHF1ZXJ5KSB7XG4gIGlmICh0eXBlb2YgZXJyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgZXJyID0gZXJyLmNhbGwocXVlcnkpO1xuICB9XG5cbiAgaWYgKGVyciA9PSBudWxsKSB7XG4gICAgZXJyID0gbmV3IERvY3VtZW50Tm90Rm91bmRFcnJvcihxdWVyeS5nZXRRdWVyeSgpLCBxdWVyeS5tb2RlbC5tb2RlbE5hbWUpO1xuICB9XG5cbiAgcmV0dXJuIGVycjtcbn1cblxuLyoqXG4gKiBXcmFwcGVyIGZ1bmN0aW9uIHRvIGNhbGwgaXNQYXRoU2VsZWN0ZWRJbmNsdXNpdmUgb24gYSBxdWVyeS5cbiAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5RdWVyeS5wcm90b3R5cGUuaXNQYXRoU2VsZWN0ZWRJbmNsdXNpdmUgPSBmdW5jdGlvbihwYXRoKSB7XG4gIHJldHVybiBpc1BhdGhTZWxlY3RlZEluY2x1c2l2ZSh0aGlzLl9maWVsZHMsIHBhdGgpO1xufTtcblxuLyoqXG4gKiBFeGVjdXRlcyB0aGUgcXVlcnlcbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IHByb21pc2UgPSBxdWVyeS5leGVjKCk7XG4gKiAgICAgY29uc3QgcHJvbWlzZSA9IHF1ZXJ5LmV4ZWMoJ3VwZGF0ZScpO1xuICpcbiAqIEBwYXJhbSB7U3RyaW5nfEZ1bmN0aW9ufSBbb3BlcmF0aW9uXVxuICogQHJldHVybiB7UHJvbWlzZX1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUXVlcnkucHJvdG90eXBlLmV4ZWMgPSBhc3luYyBmdW5jdGlvbiBleGVjKG9wKSB7XG4gIGlmICh0eXBlb2Ygb3AgPT09ICdmdW5jdGlvbicgfHwgKGFyZ3VtZW50cy5sZW5ndGggPj0gMiAmJiB0eXBlb2YgYXJndW1lbnRzWzFdID09PSAnZnVuY3Rpb24nKSkge1xuICAgIHRocm93IG5ldyBNb25nb29zZUVycm9yKCdRdWVyeS5wcm90b3R5cGUuZXhlYygpIG5vIGxvbmdlciBhY2NlcHRzIGEgY2FsbGJhY2snKTtcbiAgfVxuXG4gIGlmICh0eXBlb2Ygb3AgPT09ICdzdHJpbmcnKSB7XG4gICAgdGhpcy5vcCA9IG9wO1xuICB9XG5cbiAgaWYgKHRoaXMub3AgPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBNb25nb29zZUVycm9yKCdRdWVyeSBtdXN0IGhhdmUgYG9wYCBiZWZvcmUgZXhlY3V0aW5nJyk7XG4gIH1cbiAgaWYgKHRoaXMubW9kZWwgPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBNb25nb29zZUVycm9yKCdRdWVyeSBtdXN0IGhhdmUgYW4gYXNzb2NpYXRlZCBtb2RlbCBiZWZvcmUgZXhlY3V0aW5nJyk7XG4gIH1cbiAgdGhpcy5fdmFsaWRhdGVPcCgpO1xuXG4gIGlmICghdGhpcy5vcCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmICh0aGlzLm9wdGlvbnMgJiYgdGhpcy5vcHRpb25zLnNvcnQpIHtcbiAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXModGhpcy5vcHRpb25zLnNvcnQpO1xuICAgIGlmIChrZXlzLmluY2x1ZGVzKCcnKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGZpZWxkIFwiXCIgcGFzc2VkIHRvIHNvcnQoKScpO1xuICAgIH1cbiAgfVxuXG4gIGxldCB0aHVuayA9ICdfJyArIHRoaXMub3A7XG4gIGlmICh0aGlzLm9wID09PSAnZGlzdGluY3QnKSB7XG4gICAgdGh1bmsgPSAnX19kaXN0aW5jdCc7XG4gIH1cblxuICBpZiAodGhpcy5fZXhlY3V0aW9uU3RhY2sgIT0gbnVsbCkge1xuICAgIGxldCBzdHIgPSB0aGlzLnRvU3RyaW5nKCk7XG4gICAgaWYgKHN0ci5sZW5ndGggPiA2MCkge1xuICAgICAgc3RyID0gc3RyLnNsaWNlKDAsIDYwKSArICcuLi4nO1xuICAgIH1cbiAgICBjb25zdCBlcnIgPSBuZXcgTW9uZ29vc2VFcnJvcignUXVlcnkgd2FzIGFscmVhZHkgZXhlY3V0ZWQ6ICcgKyBzdHIpO1xuICAgIGVyci5vcmlnaW5hbFN0YWNrID0gdGhpcy5fZXhlY3V0aW9uU3RhY2suc3RhY2s7XG4gICAgdGhyb3cgZXJyO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuX2V4ZWN1dGlvblN0YWNrID0gbmV3IEVycm9yKCk7XG4gIH1cblxuICBsZXQgc2tpcFdyYXBwZWRGdW5jdGlvbiA9IG51bGw7XG4gIHRyeSB7XG4gICAgYXdhaXQgX2V4ZWN1dGVQcmVFeGVjSG9va3ModGhpcyk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGlmIChlcnIgaW5zdGFuY2VvZiBLYXJlZW0uc2tpcFdyYXBwZWRGdW5jdGlvbikge1xuICAgICAgc2tpcFdyYXBwZWRGdW5jdGlvbiA9IGVycjtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgZXJyO1xuICAgIH1cbiAgfVxuXG4gIGxldCByZXM7XG5cbiAgbGV0IGVycm9yID0gbnVsbDtcbiAgdHJ5IHtcbiAgICBhd2FpdCBfZXhlY3V0ZVByZUhvb2tzKHRoaXMpO1xuICAgIHJlcyA9IHNraXBXcmFwcGVkRnVuY3Rpb24gPyBza2lwV3JhcHBlZEZ1bmN0aW9uLmFyZ3NbMF0gOiBhd2FpdCB0aGlzW3RodW5rXSgpO1xuXG4gICAgZm9yIChjb25zdCBmbiBvZiB0aGlzLl90cmFuc2Zvcm1zKSB7XG4gICAgICByZXMgPSBmbihyZXMpO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgaWYgKGVyciBpbnN0YW5jZW9mIEthcmVlbS5za2lwV3JhcHBlZEZ1bmN0aW9uKSB7XG4gICAgICByZXMgPSBlcnIuYXJnc1swXTtcbiAgICB9IGVsc2Uge1xuICAgICAgZXJyb3IgPSBlcnI7XG4gICAgfVxuICB9XG5cbiAgcmVzID0gYXdhaXQgX2V4ZWN1dGVQb3N0SG9va3ModGhpcywgcmVzLCBlcnJvcik7XG5cbiAgYXdhaXQgX2V4ZWN1dGVQb3N0RXhlY0hvb2tzKHRoaXMpO1xuXG4gIHJldHVybiByZXM7XG59O1xuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cbmZ1bmN0aW9uIF9leGVjdXRlUG9zdEV4ZWNIb29rcyhxdWVyeSkge1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIHF1ZXJ5Ll9ob29rcy5leGVjUG9zdCgnZXhlYycsIHF1ZXJ5LCBbXSwge30sIChlcnJvcikgPT4ge1xuICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgIHJldHVybiByZWplY3QoZXJyb3IpO1xuICAgICAgfVxuXG4gICAgICByZXNvbHZlKCk7XG4gICAgfSk7XG4gIH0pO1xufVxuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cbmZ1bmN0aW9uIF9leGVjdXRlUG9zdEhvb2tzKHF1ZXJ5LCByZXMsIGVycm9yLCBvcCkge1xuICBpZiAocXVlcnkuX3F1ZXJ5TWlkZGxld2FyZSA9PSBudWxsKSB7XG4gICAgaWYgKGVycm9yICE9IG51bGwpIHtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xuICB9XG5cbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBjb25zdCBvcHRzID0gZXJyb3IgPyB7IGVycm9yIH0gOiB7fTtcblxuICAgIHF1ZXJ5Ll9xdWVyeU1pZGRsZXdhcmUuZXhlY1Bvc3Qob3AgfHwgcXVlcnkub3AsIHF1ZXJ5LCBbcmVzXSwgb3B0cywgKGVycm9yLCByZXMpID0+IHtcbiAgICAgIGlmIChlcnJvcikge1xuICAgICAgICByZXR1cm4gcmVqZWN0KGVycm9yKTtcbiAgICAgIH1cblxuICAgICAgcmVzb2x2ZShyZXMpO1xuICAgIH0pO1xuICB9KTtcbn1cblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5mdW5jdGlvbiBfZXhlY3V0ZVByZUV4ZWNIb29rcyhxdWVyeSkge1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIHF1ZXJ5Ll9ob29rcy5leGVjUHJlKCdleGVjJywgcXVlcnksIFtdLCAoZXJyb3IpID0+IHtcbiAgICAgIGlmIChlcnJvciAhPSBudWxsKSB7XG4gICAgICAgIHJldHVybiByZWplY3QoZXJyb3IpO1xuICAgICAgfVxuICAgICAgcmVzb2x2ZSgpO1xuICAgIH0pO1xuICB9KTtcbn1cblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5mdW5jdGlvbiBfZXhlY3V0ZVByZUhvb2tzKHF1ZXJ5LCBvcCkge1xuICBpZiAocXVlcnkuX3F1ZXJ5TWlkZGxld2FyZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBxdWVyeS5fcXVlcnlNaWRkbGV3YXJlLmV4ZWNQcmUob3AgfHwgcXVlcnkub3AsIHF1ZXJ5LCBbXSwgKGVycm9yKSA9PiB7XG4gICAgICBpZiAoZXJyb3IgIT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gcmVqZWN0KGVycm9yKTtcbiAgICAgIH1cbiAgICAgIHJlc29sdmUoKTtcbiAgICB9KTtcbiAgfSk7XG59XG5cbi8qKlxuICogRXhlY3V0ZXMgdGhlIHF1ZXJ5IHJldHVybmluZyBhIGBQcm9taXNlYCB3aGljaCB3aWxsIGJlXG4gKiByZXNvbHZlZCB3aXRoIGVpdGhlciB0aGUgZG9jKHMpIG9yIHJlamVjdGVkIHdpdGggdGhlIGVycm9yLlxuICpcbiAqIE1vcmUgYWJvdXQgW2B0aGVuKClgIGluIEphdmFTY3JpcHRdKGh0dHBzOi8vbWFzdGVyaW5nanMuaW8vdHV0b3JpYWxzL2Z1bmRhbWVudGFscy90aGVuKS5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcmVzb2x2ZV1cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtyZWplY3RdXG4gKiBAcmV0dXJuIHtQcm9taXNlfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5RdWVyeS5wcm90b3R5cGUudGhlbiA9IGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICByZXR1cm4gdGhpcy5leGVjKCkudGhlbihyZXNvbHZlLCByZWplY3QpO1xufTtcblxuLyoqXG4gKiBFeGVjdXRlcyB0aGUgcXVlcnkgcmV0dXJuaW5nIGEgYFByb21pc2VgIHdoaWNoIHdpbGwgYmVcbiAqIHJlc29sdmVkIHdpdGggZWl0aGVyIHRoZSBkb2Mocykgb3IgcmVqZWN0ZWQgd2l0aCB0aGUgZXJyb3IuXG4gKiBMaWtlIGAudGhlbigpYCwgYnV0IG9ubHkgdGFrZXMgYSByZWplY3Rpb24gaGFuZGxlci5cbiAqXG4gKiBNb3JlIGFib3V0IFtQcm9taXNlIGBjYXRjaCgpYCBpbiBKYXZhU2NyaXB0XShodHRwczovL21hc3RlcmluZ2pzLmlvL3R1dG9yaWFscy9mdW5kYW1lbnRhbHMvY2F0Y2gpLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtyZWplY3RdXG4gKiBAcmV0dXJuIHtQcm9taXNlfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5RdWVyeS5wcm90b3R5cGUuY2F0Y2ggPSBmdW5jdGlvbihyZWplY3QpIHtcbiAgcmV0dXJuIHRoaXMuZXhlYygpLnRoZW4obnVsbCwgcmVqZWN0KTtcbn07XG5cbi8qKlxuICogRXhlY3V0ZXMgdGhlIHF1ZXJ5IHJldHVybmluZyBhIGBQcm9taXNlYCB3aGljaCB3aWxsIGJlXG4gKiByZXNvbHZlZCB3aXRoIGAuZmluYWxseSgpYCBjaGFpbmVkLlxuICpcbiAqIE1vcmUgYWJvdXQgW1Byb21pc2UgYGZpbmFsbHkoKWAgaW4gSmF2YVNjcmlwdF0oaHR0cHM6Ly90aGVjb2RlYmFyYmFyaWFuLmNvbS91c2luZy1wcm9taXNlLWZpbmFsbHktaW4tbm9kZS1qcy5odG1sKS5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb25GaW5hbGx5XVxuICogQHJldHVybiB7UHJvbWlzZX1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUXVlcnkucHJvdG90eXBlLmZpbmFsbHkgPSBmdW5jdGlvbihvbkZpbmFsbHkpIHtcbiAgcmV0dXJuIHRoaXMuZXhlYygpLmZpbmFsbHkob25GaW5hbGx5KTtcbn07XG5cbi8qKlxuICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIHF1ZXJ5LlxuICpcbiAqIE1vcmUgYWJvdXQgW2B0b1N0cmluZygpYCBpbiBKYXZhU2NyaXB0XShodHRwczovL21hc3RlcmluZ2pzLmlvL3R1dG9yaWFscy9mdW5kYW1lbnRhbHMvdG9zdHJpbmcpLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqICAgICBjb25zdCBxID0gTW9kZWwuZmluZCgpO1xuICogICAgIGNvbnNvbGUubG9nKHEpOyAvLyBQcmludHMgXCJRdWVyeSB7IGZpbmQgfVwiXG4gKlxuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwdWJsaWNcbiAqIEBtZXRob2QgW1N5bWJvbC50b1N0cmluZ1RhZ11cbiAqIEBtZW1iZXJPZiBRdWVyeVxuICovXG5cblF1ZXJ5LnByb3RvdHlwZVtTeW1ib2wudG9TdHJpbmdUYWddID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gIHJldHVybiBgUXVlcnkgeyAke3RoaXMub3B9IH1gO1xufTtcblxuLyoqXG4gKiBBZGQgcHJlIFttaWRkbGV3YXJlXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvbWlkZGxld2FyZS5odG1sKSB0byB0aGlzIHF1ZXJ5IGluc3RhbmNlLiBEb2Vzbid0IGFmZmVjdFxuICogb3RoZXIgcXVlcmllcy5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IHExID0gUXVlc3Rpb24uZmluZCh7IGFuc3dlcjogNDIgfSk7XG4gKiAgICAgcTEucHJlKGZ1bmN0aW9uIG1pZGRsZXdhcmUoKSB7XG4gKiAgICAgICBjb25zb2xlLmxvZyh0aGlzLmdldEZpbHRlcigpKTtcbiAqICAgICB9KTtcbiAqICAgICBhd2FpdCBxMS5leGVjKCk7IC8vIFByaW50cyBcInsgYW5zd2VyOiA0MiB9XCJcbiAqXG4gKiAgICAgLy8gRG9lc24ndCBwcmludCBhbnl0aGluZywgYmVjYXVzZSBgbWlkZGxld2FyZSgpYCBpcyBvbmx5XG4gKiAgICAgLy8gcmVnaXN0ZXJlZCBvbiBgcTFgLlxuICogICAgIGF3YWl0IFF1ZXN0aW9uLmZpbmQoeyBhbnN3ZXI6IDQyIH0pO1xuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKiBAcmV0dXJuIHtQcm9taXNlfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5RdWVyeS5wcm90b3R5cGUucHJlID0gZnVuY3Rpb24oZm4pIHtcbiAgdGhpcy5faG9va3MucHJlKCdleGVjJywgZm4pO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQWRkIHBvc3QgW21pZGRsZXdhcmVdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9taWRkbGV3YXJlLmh0bWwpIHRvIHRoaXMgcXVlcnkgaW5zdGFuY2UuIERvZXNuJ3QgYWZmZWN0XG4gKiBvdGhlciBxdWVyaWVzLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgY29uc3QgcTEgPSBRdWVzdGlvbi5maW5kKHsgYW5zd2VyOiA0MiB9KTtcbiAqICAgICBxMS5wb3N0KGZ1bmN0aW9uIG1pZGRsZXdhcmUoKSB7XG4gKiAgICAgICBjb25zb2xlLmxvZyh0aGlzLmdldEZpbHRlcigpKTtcbiAqICAgICB9KTtcbiAqICAgICBhd2FpdCBxMS5leGVjKCk7IC8vIFByaW50cyBcInsgYW5zd2VyOiA0MiB9XCJcbiAqXG4gKiAgICAgLy8gRG9lc24ndCBwcmludCBhbnl0aGluZywgYmVjYXVzZSBgbWlkZGxld2FyZSgpYCBpcyBvbmx5XG4gKiAgICAgLy8gcmVnaXN0ZXJlZCBvbiBgcTFgLlxuICogICAgIGF3YWl0IFF1ZXN0aW9uLmZpbmQoeyBhbnN3ZXI6IDQyIH0pO1xuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKiBAcmV0dXJuIHtQcm9taXNlfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5RdWVyeS5wcm90b3R5cGUucG9zdCA9IGZ1bmN0aW9uKGZuKSB7XG4gIHRoaXMuX2hvb2tzLnBvc3QoJ2V4ZWMnLCBmbik7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBDYXN0cyBvYmogZm9yIGFuIHVwZGF0ZSBjb21tYW5kLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAqIEByZXR1cm4ge09iamVjdH0gb2JqIGFmdGVyIGNhc3RpbmcgaXRzIHZhbHVlc1xuICogQG1ldGhvZCBfY2FzdFVwZGF0ZVxuICogQG1lbWJlck9mIFF1ZXJ5XG4gKiBAaW5zdGFuY2VcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblF1ZXJ5LnByb3RvdHlwZS5fY2FzdFVwZGF0ZSA9IGZ1bmN0aW9uIF9jYXN0VXBkYXRlKG9iaikge1xuICBsZXQgc2NoZW1hID0gdGhpcy5zY2hlbWE7XG5cbiAgY29uc3QgZGlzY3JpbWluYXRvcktleSA9IHNjaGVtYS5vcHRpb25zLmRpc2NyaW1pbmF0b3JLZXk7XG4gIGNvbnN0IGJhc2VTY2hlbWEgPSBzY2hlbWEuX2Jhc2VTY2hlbWEgPyBzY2hlbWEuX2Jhc2VTY2hlbWEgOiBzY2hlbWE7XG4gIGlmICh0aGlzLl9tb25nb29zZU9wdGlvbnMub3ZlcndyaXRlRGlzY3JpbWluYXRvcktleSAmJlxuICAgICAgb2JqW2Rpc2NyaW1pbmF0b3JLZXldICE9IG51bGwgJiZcbiAgICAgIGJhc2VTY2hlbWEuZGlzY3JpbWluYXRvcnMpIHtcbiAgICBjb25zdCBfc2NoZW1hID0gT2JqZWN0LnZhbHVlcyhiYXNlU2NoZW1hLmRpc2NyaW1pbmF0b3JzKS5maW5kKFxuICAgICAgZGlzY3JpbWluYXRvciA9PiBkaXNjcmltaW5hdG9yLmRpc2NyaW1pbmF0b3JNYXBwaW5nLnZhbHVlID09PSBvYmpbZGlzY3JpbWluYXRvcktleV1cbiAgICApO1xuICAgIGlmIChfc2NoZW1hICE9IG51bGwpIHtcbiAgICAgIHNjaGVtYSA9IF9zY2hlbWE7XG4gICAgfVxuICB9XG5cbiAgbGV0IHVwc2VydDtcbiAgaWYgKCd1cHNlcnQnIGluIHRoaXMub3B0aW9ucykge1xuICAgIHVwc2VydCA9IHRoaXMub3B0aW9ucy51cHNlcnQ7XG4gIH1cblxuICBjb25zdCBmaWx0ZXIgPSB0aGlzLl9jb25kaXRpb25zO1xuICBpZiAoc2NoZW1hICE9IG51bGwgJiZcbiAgICAgIHV0aWxzLmhhc1VzZXJEZWZpbmVkUHJvcGVydHkoZmlsdGVyLCBzY2hlbWEub3B0aW9ucy5kaXNjcmltaW5hdG9yS2V5KSAmJlxuICAgICAgdHlwZW9mIGZpbHRlcltzY2hlbWEub3B0aW9ucy5kaXNjcmltaW5hdG9yS2V5XSAhPT0gJ29iamVjdCcgJiZcbiAgICAgIHNjaGVtYS5kaXNjcmltaW5hdG9ycyAhPSBudWxsKSB7XG4gICAgY29uc3QgZGlzY3JpbWluYXRvclZhbHVlID0gZmlsdGVyW3NjaGVtYS5vcHRpb25zLmRpc2NyaW1pbmF0b3JLZXldO1xuICAgIGNvbnN0IGJ5VmFsdWUgPSBnZXREaXNjcmltaW5hdG9yQnlWYWx1ZSh0aGlzLm1vZGVsLmRpc2NyaW1pbmF0b3JzLCBkaXNjcmltaW5hdG9yVmFsdWUpO1xuICAgIHNjaGVtYSA9IHNjaGVtYS5kaXNjcmltaW5hdG9yc1tkaXNjcmltaW5hdG9yVmFsdWVdIHx8XG4gICAgICAoYnlWYWx1ZSAmJiBieVZhbHVlLnNjaGVtYSkgfHxcbiAgICAgIHNjaGVtYTtcbiAgfVxuXG4gIHJldHVybiBjYXN0VXBkYXRlKHNjaGVtYSwgb2JqLCB7XG4gICAgc3RyaWN0OiB0aGlzLl9tb25nb29zZU9wdGlvbnMuc3RyaWN0LFxuICAgIHVwc2VydDogdXBzZXJ0LFxuICAgIGFycmF5RmlsdGVyczogdGhpcy5vcHRpb25zLmFycmF5RmlsdGVycyxcbiAgICBvdmVyd3JpdGVEaXNjcmltaW5hdG9yS2V5OiB0aGlzLl9tb25nb29zZU9wdGlvbnMub3ZlcndyaXRlRGlzY3JpbWluYXRvcktleVxuICB9LCB0aGlzLCB0aGlzLl9jb25kaXRpb25zKTtcbn07XG5cbi8qKlxuICogU3BlY2lmaWVzIHBhdGhzIHdoaWNoIHNob3VsZCBiZSBwb3B1bGF0ZWQgd2l0aCBvdGhlciBkb2N1bWVudHMuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBsZXQgYm9vayA9IGF3YWl0IEJvb2suZmluZE9uZSgpLnBvcHVsYXRlKCdhdXRob3JzJyk7XG4gKiAgICAgYm9vay50aXRsZTsgLy8gJ05vZGUuanMgaW4gQWN0aW9uJ1xuICogICAgIGJvb2suYXV0aG9yc1swXS5uYW1lOyAvLyAnVEogSG9sb3dheWNodWsnXG4gKiAgICAgYm9vay5hdXRob3JzWzFdLm5hbWU7IC8vICdOYXRoYW4gUmFqbGljaCdcbiAqXG4gKiAgICAgbGV0IGJvb2tzID0gYXdhaXQgQm9vay5maW5kKCkucG9wdWxhdGUoe1xuICogICAgICAgcGF0aDogJ2F1dGhvcnMnLFxuICogICAgICAgLy8gYG1hdGNoYCBhbmQgYHNvcnRgIGFwcGx5IHRvIHRoZSBBdXRob3IgbW9kZWwsXG4gKiAgICAgICAvLyBub3QgdGhlIEJvb2sgbW9kZWwuIFRoZXNlIG9wdGlvbnMgZG8gbm90IGFmZmVjdFxuICogICAgICAgLy8gd2hpY2ggZG9jdW1lbnRzIGFyZSBpbiBgYm9va3NgLCBqdXN0IHRoZSBvcmRlciBhbmRcbiAqICAgICAgIC8vIGNvbnRlbnRzIG9mIGVhY2ggYm9vayBkb2N1bWVudCdzIGBhdXRob3JzYC5cbiAqICAgICAgIG1hdGNoOiB7IG5hbWU6IG5ldyBSZWdFeHAoJy4qaC4qJywgJ2knKSB9LFxuICogICAgICAgc29ydDogeyBuYW1lOiAtMSB9XG4gKiAgICAgfSk7XG4gKiAgICAgYm9va3NbMF0udGl0bGU7IC8vICdOb2RlLmpzIGluIEFjdGlvbidcbiAqICAgICAvLyBFYWNoIGJvb2sncyBgYXV0aG9yc2AgYXJlIHNvcnRlZCBieSBuYW1lLCBkZXNjZW5kaW5nLlxuICogICAgIGJvb2tzWzBdLmF1dGhvcnNbMF0ubmFtZTsgLy8gJ1RKIEhvbG93YXljaHVrJ1xuICogICAgIGJvb2tzWzBdLmF1dGhvcnNbMV0ubmFtZTsgLy8gJ01hcmMgSGFydGVyJ1xuICpcbiAqICAgICBib29rc1sxXS50aXRsZTsgLy8gJ1Byb2Zlc3Npb25hbCBBbmd1bGFySlMnXG4gKiAgICAgLy8gRW1wdHkgYXJyYXksIG5vIGF1dGhvcnMnIG5hbWUgaGFzIHRoZSBsZXR0ZXIgJ2gnXG4gKiAgICAgYm9va3NbMV0uYXV0aG9yczsgLy8gW11cbiAqXG4gKiBQYXRocyBhcmUgcG9wdWxhdGVkIGFmdGVyIHRoZSBxdWVyeSBleGVjdXRlcyBhbmQgYSByZXNwb25zZSBpcyByZWNlaXZlZC4gQVxuICogc2VwYXJhdGUgcXVlcnkgaXMgdGhlbiBleGVjdXRlZCBmb3IgZWFjaCBwYXRoIHNwZWNpZmllZCBmb3IgcG9wdWxhdGlvbi4gQWZ0ZXJcbiAqIGEgcmVzcG9uc2UgZm9yIGVhY2ggcXVlcnkgaGFzIGFsc28gYmVlbiByZXR1cm5lZCwgdGhlIHJlc3VsdHMgYXJlIHBhc3NlZCB0b1xuICogdGhlIGNhbGxiYWNrLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fFN0cmluZ3xTdHJpbmdbXX0gcGF0aCBlaXRoZXIgdGhlIHBhdGgocykgdG8gcG9wdWxhdGUgb3IgYW4gb2JqZWN0IHNwZWNpZnlpbmcgYWxsIHBhcmFtZXRlcnNcbiAqIEBwYXJhbSB7T2JqZWN0fFN0cmluZ30gW3NlbGVjdF0gRmllbGQgc2VsZWN0aW9uIGZvciB0aGUgcG9wdWxhdGlvbiBxdWVyeVxuICogQHBhcmFtIHtNb2RlbH0gW21vZGVsXSBUaGUgbW9kZWwgeW91IHdpc2ggdG8gdXNlIGZvciBwb3B1bGF0aW9uLiBJZiBub3Qgc3BlY2lmaWVkLCBwb3B1bGF0ZSB3aWxsIGxvb2sgdXAgdGhlIG1vZGVsIGJ5IHRoZSBuYW1lIGluIHRoZSBTY2hlbWEncyBgcmVmYCBmaWVsZC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbbWF0Y2hdIENvbmRpdGlvbnMgZm9yIHRoZSBwb3B1bGF0aW9uIHF1ZXJ5XG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgZm9yIHRoZSBwb3B1bGF0aW9uIHF1ZXJ5IChzb3J0LCBldGMpXG4gKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMucGF0aD1udWxsXSBUaGUgcGF0aCB0byBwb3B1bGF0ZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMucmV0YWluTnVsbFZhbHVlcz1mYWxzZV0gYnkgZGVmYXVsdCwgTW9uZ29vc2UgcmVtb3ZlcyBudWxsIGFuZCB1bmRlZmluZWQgdmFsdWVzIGZyb20gcG9wdWxhdGVkIGFycmF5cy4gVXNlIHRoaXMgb3B0aW9uIHRvIG1ha2UgYHBvcHVsYXRlKClgIHJldGFpbiBgbnVsbGAgYW5kIGB1bmRlZmluZWRgIGFycmF5IGVudHJpZXMuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmdldHRlcnM9ZmFsc2VdIGlmIHRydWUsIE1vbmdvb3NlIHdpbGwgY2FsbCBhbnkgZ2V0dGVycyBkZWZpbmVkIG9uIHRoZSBgbG9jYWxGaWVsZGAuIEJ5IGRlZmF1bHQsIE1vbmdvb3NlIGdldHMgdGhlIHJhdyB2YWx1ZSBvZiBgbG9jYWxGaWVsZGAuIEZvciBleGFtcGxlLCB5b3Ugd291bGQgbmVlZCB0byBzZXQgdGhpcyBvcHRpb24gdG8gYHRydWVgIGlmIHlvdSB3YW50ZWQgdG8gW2FkZCBhIGBsb3dlcmNhc2VgIGdldHRlciB0byB5b3VyIGBsb2NhbEZpZWxkYF0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL3NjaGVtYXR5cGVzLmh0bWwjc2NoZW1hdHlwZS1vcHRpb25zKS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuY2xvbmU9ZmFsc2VdIFdoZW4geW91IGRvIGBCbG9nUG9zdC5maW5kKCkucG9wdWxhdGUoJ2F1dGhvcicpYCwgYmxvZyBwb3N0cyB3aXRoIHRoZSBzYW1lIGF1dGhvciB3aWxsIHNoYXJlIDEgY29weSBvZiBhbiBgYXV0aG9yYCBkb2MuIEVuYWJsZSB0aGlzIG9wdGlvbiB0byBtYWtlIE1vbmdvb3NlIGNsb25lIHBvcHVsYXRlZCBkb2NzIGJlZm9yZSBhc3NpZ25pbmcgdGhlbS5cbiAqIEBwYXJhbSB7T2JqZWN0fEZ1bmN0aW9ufSBbb3B0aW9ucy5tYXRjaD1udWxsXSBBZGQgYW4gYWRkaXRpb25hbCBmaWx0ZXIgdG8gdGhlIHBvcHVsYXRlIHF1ZXJ5LiBDYW4gYmUgYSBmaWx0ZXIgb2JqZWN0IGNvbnRhaW5pbmcgW01vbmdvREIgcXVlcnkgc3ludGF4XShodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC90dXRvcmlhbC9xdWVyeS1kb2N1bWVudHMvKSwgb3IgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgYSBmaWx0ZXIgb2JqZWN0LlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMudHJhbnNmb3JtPW51bGxdIEZ1bmN0aW9uIHRoYXQgTW9uZ29vc2Ugd2lsbCBjYWxsIG9uIGV2ZXJ5IHBvcHVsYXRlZCBkb2N1bWVudCB0aGF0IGFsbG93cyB5b3UgdG8gdHJhbnNmb3JtIHRoZSBwb3B1bGF0ZWQgZG9jdW1lbnQuXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMub3B0aW9ucz1udWxsXSBBZGRpdGlvbmFsIG9wdGlvbnMgbGlrZSBgbGltaXRgIGFuZCBgbGVhbmAuXG4gKiBAc2VlIHBvcHVsYXRpb24gaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL3BvcHVsYXRlLmh0bWxcbiAqIEBzZWUgUXVlcnkjc2VsZWN0IGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvcXVlcnkuaHRtbCNRdWVyeS5wcm90b3R5cGUuc2VsZWN0KClcbiAqIEBzZWUgTW9kZWwucG9wdWxhdGUgaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2FwaS9tb2RlbC5odG1sI01vZGVsLnBvcHVsYXRlKClcbiAqIEByZXR1cm4ge1F1ZXJ5fSB0aGlzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblF1ZXJ5LnByb3RvdHlwZS5wb3B1bGF0ZSA9IGZ1bmN0aW9uKCkge1xuICAvLyBCYWlsIHdoZW4gZ2l2ZW4gbm8gdHJ1dGh5IGFyZ3VtZW50c1xuICBpZiAoIUFycmF5LmZyb20oYXJndW1lbnRzKS5zb21lKEJvb2xlYW4pKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBjb25zdCByZXMgPSB1dGlscy5wb3B1bGF0ZS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuXG4gIC8vIFByb3BhZ2F0ZSByZWFkQ29uY2VybiBhbmQgcmVhZFByZWZlcmVuY2UgYW5kIGxlYW4gZnJvbSBwYXJlbnQgcXVlcnksXG4gIC8vIHVubGVzcyBvbmUgYWxyZWFkeSBzcGVjaWZpZWRcbiAgaWYgKHRoaXMub3B0aW9ucyAhPSBudWxsKSB7XG4gICAgY29uc3QgcmVhZENvbmNlcm4gPSB0aGlzLm9wdGlvbnMucmVhZENvbmNlcm47XG4gICAgY29uc3QgcmVhZFByZWYgPSB0aGlzLm9wdGlvbnMucmVhZFByZWZlcmVuY2U7XG5cbiAgICBmb3IgKGNvbnN0IHBvcHVsYXRlT3B0aW9ucyBvZiByZXMpIHtcbiAgICAgIGlmIChyZWFkQ29uY2VybiAhPSBudWxsICYmIChwb3B1bGF0ZU9wdGlvbnMgJiYgcG9wdWxhdGVPcHRpb25zLm9wdGlvbnMgJiYgcG9wdWxhdGVPcHRpb25zLm9wdGlvbnMucmVhZENvbmNlcm4pID09IG51bGwpIHtcbiAgICAgICAgcG9wdWxhdGVPcHRpb25zLm9wdGlvbnMgPSBwb3B1bGF0ZU9wdGlvbnMub3B0aW9ucyB8fCB7fTtcbiAgICAgICAgcG9wdWxhdGVPcHRpb25zLm9wdGlvbnMucmVhZENvbmNlcm4gPSByZWFkQ29uY2VybjtcbiAgICAgIH1cbiAgICAgIGlmIChyZWFkUHJlZiAhPSBudWxsICYmIChwb3B1bGF0ZU9wdGlvbnMgJiYgcG9wdWxhdGVPcHRpb25zLm9wdGlvbnMgJiYgcG9wdWxhdGVPcHRpb25zLm9wdGlvbnMucmVhZFByZWZlcmVuY2UpID09IG51bGwpIHtcbiAgICAgICAgcG9wdWxhdGVPcHRpb25zLm9wdGlvbnMgPSBwb3B1bGF0ZU9wdGlvbnMub3B0aW9ucyB8fCB7fTtcbiAgICAgICAgcG9wdWxhdGVPcHRpb25zLm9wdGlvbnMucmVhZFByZWZlcmVuY2UgPSByZWFkUHJlZjtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBjb25zdCBvcHRzID0gdGhpcy5fbW9uZ29vc2VPcHRpb25zO1xuXG4gIGlmIChvcHRzLmxlYW4gIT0gbnVsbCkge1xuICAgIGNvbnN0IGxlYW4gPSBvcHRzLmxlYW47XG4gICAgZm9yIChjb25zdCBwb3B1bGF0ZU9wdGlvbnMgb2YgcmVzKSB7XG4gICAgICBpZiAoKHBvcHVsYXRlT3B0aW9ucyAmJiBwb3B1bGF0ZU9wdGlvbnMub3B0aW9ucyAmJiBwb3B1bGF0ZU9wdGlvbnMub3B0aW9ucy5sZWFuKSA9PSBudWxsKSB7XG4gICAgICAgIHBvcHVsYXRlT3B0aW9ucy5vcHRpb25zID0gcG9wdWxhdGVPcHRpb25zLm9wdGlvbnMgfHwge307XG4gICAgICAgIHBvcHVsYXRlT3B0aW9ucy5vcHRpb25zLmxlYW4gPSBsZWFuO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmICghdXRpbHMuaXNPYmplY3Qob3B0cy5wb3B1bGF0ZSkpIHtcbiAgICBvcHRzLnBvcHVsYXRlID0ge307XG4gIH1cblxuICBjb25zdCBwb3AgPSBvcHRzLnBvcHVsYXRlO1xuXG4gIGZvciAoY29uc3QgcG9wdWxhdGVPcHRpb25zIG9mIHJlcykge1xuICAgIGNvbnN0IHBhdGggPSBwb3B1bGF0ZU9wdGlvbnMucGF0aDtcbiAgICBpZiAocG9wW3BhdGhdICYmIHBvcFtwYXRoXS5wb3B1bGF0ZSAmJiBwb3B1bGF0ZU9wdGlvbnMucG9wdWxhdGUpIHtcbiAgICAgIHBvcHVsYXRlT3B0aW9ucy5wb3B1bGF0ZSA9IHBvcFtwYXRoXS5wb3B1bGF0ZS5jb25jYXQocG9wdWxhdGVPcHRpb25zLnBvcHVsYXRlKTtcbiAgICB9XG5cbiAgICBwb3BbcG9wdWxhdGVPcHRpb25zLnBhdGhdID0gcG9wdWxhdGVPcHRpb25zO1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBHZXRzIGEgbGlzdCBvZiBwYXRocyB0byBiZSBwb3B1bGF0ZWQgYnkgdGhpcyBxdWVyeVxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgIGJvb2tTY2hlbWEucHJlKCdmaW5kT25lJywgZnVuY3Rpb24oKSB7XG4gKiAgICAgICAgbGV0IGtleXMgPSB0aGlzLmdldFBvcHVsYXRlZFBhdGhzKCk7IC8vIFsnYXV0aG9yJ11cbiAqICAgICAgfSk7XG4gKiAgICAgIC4uLlxuICogICAgICBCb29rLmZpbmRPbmUoe30pLnBvcHVsYXRlKCdhdXRob3InKTtcbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgICAvLyBEZWVwIHBvcHVsYXRlXG4gKiAgICAgIGNvbnN0IHEgPSBMMS5maW5kKCkucG9wdWxhdGUoe1xuICogICAgICAgIHBhdGg6ICdsZXZlbDInLFxuICogICAgICAgIHBvcHVsYXRlOiB7IHBhdGg6ICdsZXZlbDMnIH1cbiAqICAgICAgfSk7XG4gKiAgICAgIHEuZ2V0UG9wdWxhdGVkUGF0aHMoKTsgLy8gWydsZXZlbDInLCAnbGV2ZWwyLmxldmVsMyddXG4gKlxuICogQHJldHVybiB7QXJyYXl9IGFuIGFycmF5IG9mIHN0cmluZ3MgcmVwcmVzZW50aW5nIHBvcHVsYXRlZCBwYXRoc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5RdWVyeS5wcm90b3R5cGUuZ2V0UG9wdWxhdGVkUGF0aHMgPSBmdW5jdGlvbiBnZXRQb3B1bGF0ZWRQYXRocygpIHtcbiAgY29uc3Qgb2JqID0gdGhpcy5fbW9uZ29vc2VPcHRpb25zLnBvcHVsYXRlIHx8IHt9O1xuICBjb25zdCByZXQgPSBPYmplY3Qua2V5cyhvYmopO1xuICBmb3IgKGNvbnN0IHBhdGggb2YgT2JqZWN0LmtleXMob2JqKSkge1xuICAgIGNvbnN0IHBvcCA9IG9ialtwYXRoXTtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkocG9wLnBvcHVsYXRlKSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIF9nZXRQb3B1bGF0ZWRQYXRocyhyZXQsIHBvcC5wb3B1bGF0ZSwgcGF0aCArICcuJyk7XG4gIH1cbiAgcmV0dXJuIHJldDtcbn07XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxuZnVuY3Rpb24gX2dldFBvcHVsYXRlZFBhdGhzKGxpc3QsIGFyciwgcHJlZml4KSB7XG4gIGZvciAoY29uc3QgcG9wIG9mIGFycikge1xuICAgIGxpc3QucHVzaChwcmVmaXggKyBwb3AucGF0aCk7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHBvcC5wb3B1bGF0ZSkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBfZ2V0UG9wdWxhdGVkUGF0aHMobGlzdCwgcG9wLnBvcHVsYXRlLCBwcmVmaXggKyBwb3AucGF0aCArICcuJyk7XG4gIH1cbn1cblxuLyoqXG4gKiBDYXN0cyB0aGlzIHF1ZXJ5IHRvIHRoZSBzY2hlbWEgb2YgYG1vZGVsYFxuICpcbiAqICMjIyMgTm90ZTpcbiAqXG4gKiBJZiBgb2JqYCBpcyBwcmVzZW50LCBpdCBpcyBjYXN0IGluc3RlYWQgb2YgdGhpcyBxdWVyeS5cbiAqXG4gKiBAcGFyYW0ge01vZGVsfSBbbW9kZWxdIHRoZSBtb2RlbCB0byBjYXN0IHRvLiBJZiBub3Qgc2V0LCBkZWZhdWx0cyB0byBgdGhpcy5tb2RlbGBcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqXVxuICogQHJldHVybiB7T2JqZWN0fVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5RdWVyeS5wcm90b3R5cGUuY2FzdCA9IGZ1bmN0aW9uKG1vZGVsLCBvYmopIHtcbiAgb2JqIHx8IChvYmogPSB0aGlzLl9jb25kaXRpb25zKTtcbiAgbW9kZWwgPSBtb2RlbCB8fCB0aGlzLm1vZGVsO1xuICBjb25zdCBkaXNjcmltaW5hdG9yS2V5ID0gbW9kZWwuc2NoZW1hLm9wdGlvbnMuZGlzY3JpbWluYXRvcktleTtcbiAgaWYgKG9iaiAhPSBudWxsICYmXG4gICAgICBvYmouaGFzT3duUHJvcGVydHkoZGlzY3JpbWluYXRvcktleSkpIHtcbiAgICBtb2RlbCA9IGdldERpc2NyaW1pbmF0b3JCeVZhbHVlKG1vZGVsLmRpc2NyaW1pbmF0b3JzLCBvYmpbZGlzY3JpbWluYXRvcktleV0pIHx8IG1vZGVsO1xuICB9XG5cbiAgY29uc3Qgb3B0cyA9IHsgdXBzZXJ0OiB0aGlzLm9wdGlvbnMgJiYgdGhpcy5vcHRpb25zLnVwc2VydCB9O1xuICBpZiAodGhpcy5vcHRpb25zKSB7XG4gICAgaWYgKCdzdHJpY3QnIGluIHRoaXMub3B0aW9ucykge1xuICAgICAgb3B0cy5zdHJpY3QgPSB0aGlzLm9wdGlvbnMuc3RyaWN0O1xuICAgIH1cbiAgICBpZiAoJ3N0cmljdFF1ZXJ5JyBpbiB0aGlzLm9wdGlvbnMpIHtcbiAgICAgIG9wdHMuc3RyaWN0UXVlcnkgPSB0aGlzLm9wdGlvbnMuc3RyaWN0UXVlcnk7XG4gICAgfVxuICB9XG5cbiAgdHJ5IHtcbiAgICByZXR1cm4gY2FzdChtb2RlbC5zY2hlbWEsIG9iaiwgb3B0cywgdGhpcyk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIC8vIENhc3RFcnJvciwgYXNzaWduIG1vZGVsXG4gICAgaWYgKHR5cGVvZiBlcnIuc2V0TW9kZWwgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGVyci5zZXRNb2RlbChtb2RlbCk7XG4gICAgfVxuICAgIHRocm93IGVycjtcbiAgfVxufTtcblxuLyoqXG4gKiBDYXN0cyBzZWxlY3RlZCBmaWVsZCBhcmd1bWVudHMgZm9yIGZpZWxkIHNlbGVjdGlvbiB3aXRoIG1vbmdvIDIuMlxuICpcbiAqICAgICBxdWVyeS5zZWxlY3QoeyBpZHM6IHsgJGVsZW1NYXRjaDogeyAkaW46IFtoZXhTdHJpbmddIH19KVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBmaWVsZHNcbiAqIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL0F1dG9tYXR0aWMvbW9uZ29vc2UvaXNzdWVzLzEwOTFcbiAqIEBzZWUgaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvcmVmZXJlbmNlL3Byb2plY3Rpb24vZWxlbU1hdGNoL1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuUXVlcnkucHJvdG90eXBlLl9jYXN0RmllbGRzID0gZnVuY3Rpb24gX2Nhc3RGaWVsZHMoZmllbGRzKSB7XG4gIGxldCBzZWxlY3RlZCxcbiAgICAgIGVsZW1NYXRjaEtleXMsXG4gICAgICBrZXlzLFxuICAgICAga2V5LFxuICAgICAgb3V0O1xuXG4gIGlmIChmaWVsZHMpIHtcbiAgICBrZXlzID0gT2JqZWN0LmtleXMoZmllbGRzKTtcbiAgICBlbGVtTWF0Y2hLZXlzID0gW107XG5cbiAgICAvLyBjb2xsZWN0ICRlbGVtTWF0Y2ggYXJnc1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSkge1xuICAgICAga2V5ID0ga2V5c1tpXTtcbiAgICAgIGlmIChmaWVsZHNba2V5XS4kZWxlbU1hdGNoKSB7XG4gICAgICAgIHNlbGVjdGVkIHx8IChzZWxlY3RlZCA9IHt9KTtcbiAgICAgICAgc2VsZWN0ZWRba2V5XSA9IGZpZWxkc1trZXldO1xuICAgICAgICBlbGVtTWF0Y2hLZXlzLnB1c2goa2V5KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoc2VsZWN0ZWQpIHtcbiAgICAvLyB0aGV5IHBhc3NlZCAkZWxlbU1hdGNoLCBjYXN0IGVtXG4gICAgdHJ5IHtcbiAgICAgIG91dCA9IHRoaXMuY2FzdCh0aGlzLm1vZGVsLCBzZWxlY3RlZCk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICByZXR1cm4gZXJyO1xuICAgIH1cblxuICAgIC8vIGFwcGx5IHRoZSBjYXN0ZWQgZmllbGQgYXJnc1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZWxlbU1hdGNoS2V5cy5sZW5ndGg7ICsraSkge1xuICAgICAga2V5ID0gZWxlbU1hdGNoS2V5c1tpXTtcbiAgICAgIGZpZWxkc1trZXldID0gb3V0W2tleV07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZpZWxkcztcbn07XG5cbi8qKlxuICogQXBwbGllcyBzY2hlbWF0eXBlIHNlbGVjdGVkIG9wdGlvbnMgdG8gdGhpcyBxdWVyeS5cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblF1ZXJ5LnByb3RvdHlwZS5fYXBwbHlQYXRocyA9IGZ1bmN0aW9uIGFwcGx5UGF0aHMoKSB7XG4gIGlmICghdGhpcy5tb2RlbCkge1xuICAgIHJldHVybjtcbiAgfVxuICB0aGlzLl9maWVsZHMgPSB0aGlzLl9maWVsZHMgfHwge307XG4gIGhlbHBlcnMuYXBwbHlQYXRocyh0aGlzLl9maWVsZHMsIHRoaXMubW9kZWwuc2NoZW1hKTtcblxuICBsZXQgX3NlbGVjdFBvcHVsYXRlZFBhdGhzID0gdHJ1ZTtcblxuICBpZiAoJ3NlbGVjdFBvcHVsYXRlZFBhdGhzJyBpbiB0aGlzLm1vZGVsLmJhc2Uub3B0aW9ucykge1xuICAgIF9zZWxlY3RQb3B1bGF0ZWRQYXRocyA9IHRoaXMubW9kZWwuYmFzZS5vcHRpb25zLnNlbGVjdFBvcHVsYXRlZFBhdGhzO1xuICB9XG4gIGlmICgnc2VsZWN0UG9wdWxhdGVkUGF0aHMnIGluIHRoaXMubW9kZWwuc2NoZW1hLm9wdGlvbnMpIHtcbiAgICBfc2VsZWN0UG9wdWxhdGVkUGF0aHMgPSB0aGlzLm1vZGVsLnNjaGVtYS5vcHRpb25zLnNlbGVjdFBvcHVsYXRlZFBhdGhzO1xuICB9XG5cbiAgaWYgKF9zZWxlY3RQb3B1bGF0ZWRQYXRocykge1xuICAgIHNlbGVjdFBvcHVsYXRlZEZpZWxkcyh0aGlzLl9maWVsZHMsIHRoaXMuX3VzZXJQcm92aWRlZEZpZWxkcywgdGhpcy5fbW9uZ29vc2VPcHRpb25zLnBvcHVsYXRlKTtcbiAgfVxufTtcblxuLyoqXG4gKiBSZXR1cm5zIGEgd3JhcHBlciBhcm91bmQgYSBbbW9uZ29kYiBkcml2ZXIgY3Vyc29yXShodHRwczovL21vbmdvZGIuZ2l0aHViLmlvL25vZGUtbW9uZ29kYi1uYXRpdmUvNC45L2NsYXNzZXMvRmluZEN1cnNvci5odG1sKS5cbiAqIEEgUXVlcnlDdXJzb3IgZXhwb3NlcyBhIFN0cmVhbXMzIGludGVyZmFjZSwgYXMgd2VsbCBhcyBhIGAubmV4dCgpYCBmdW5jdGlvbi5cbiAqXG4gKiBUaGUgYC5jdXJzb3IoKWAgZnVuY3Rpb24gdHJpZ2dlcnMgcHJlIGZpbmQgaG9va3MsIGJ1dCAqKm5vdCoqIHBvc3QgZmluZCBob29rcy5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIC8vIFRoZXJlIGFyZSAyIHdheXMgdG8gdXNlIGEgY3Vyc29yLiBGaXJzdCwgYXMgYSBzdHJlYW06XG4gKiAgICAgVGhpbmcuXG4gKiAgICAgICBmaW5kKHsgbmFtZTogL15oZWxsby8gfSkuXG4gKiAgICAgICBjdXJzb3IoKS5cbiAqICAgICAgIG9uKCdkYXRhJywgZnVuY3Rpb24oZG9jKSB7IGNvbnNvbGUubG9nKGRvYyk7IH0pLlxuICogICAgICAgb24oJ2VuZCcsIGZ1bmN0aW9uKCkgeyBjb25zb2xlLmxvZygnRG9uZSEnKTsgfSk7XG4gKlxuICogICAgIC8vIE9yIHlvdSBjYW4gdXNlIGAubmV4dCgpYCB0byBtYW51YWxseSBnZXQgdGhlIG5leHQgZG9jIGluIHRoZSBzdHJlYW0uXG4gKiAgICAgLy8gYC5uZXh0KClgIHJldHVybnMgYSBwcm9taXNlLCBzbyB5b3UgY2FuIHVzZSBwcm9taXNlcyBvciBjYWxsYmFja3MuXG4gKiAgICAgY29uc3QgY3Vyc29yID0gVGhpbmcuZmluZCh7IG5hbWU6IC9eaGVsbG8vIH0pLmN1cnNvcigpO1xuICogICAgIGN1cnNvci5uZXh0KGZ1bmN0aW9uKGVycm9yLCBkb2MpIHtcbiAqICAgICAgIGNvbnNvbGUubG9nKGRvYyk7XG4gKiAgICAgfSk7XG4gKlxuICogICAgIC8vIEJlY2F1c2UgYC5uZXh0KClgIHJldHVybnMgYSBwcm9taXNlLCB5b3UgY2FuIHVzZSBjb1xuICogICAgIC8vIHRvIGVhc2lseSBpdGVyYXRlIHRocm91Z2ggYWxsIGRvY3VtZW50cyB3aXRob3V0IGxvYWRpbmcgdGhlbVxuICogICAgIC8vIGFsbCBpbnRvIG1lbW9yeS5cbiAqICAgICBjb25zdCBjdXJzb3IgPSBUaGluZy5maW5kKHsgbmFtZTogL15oZWxsby8gfSkuY3Vyc29yKCk7XG4gKiAgICAgZm9yIChsZXQgZG9jID0gYXdhaXQgY3Vyc29yLm5leHQoKTsgZG9jICE9IG51bGw7IGRvYyA9IGF3YWl0IGN1cnNvci5uZXh0KCkpIHtcbiAqICAgICAgIGNvbnNvbGUubG9nKGRvYyk7XG4gKiAgICAgfVxuICpcbiAqICMjIyMgVmFsaWQgb3B0aW9uc1xuICpcbiAqICAgLSBgdHJhbnNmb3JtYDogb3B0aW9uYWwgZnVuY3Rpb24gd2hpY2ggYWNjZXB0cyBhIG1vbmdvb3NlIGRvY3VtZW50LiBUaGUgcmV0dXJuIHZhbHVlIG9mIHRoZSBmdW5jdGlvbiB3aWxsIGJlIGVtaXR0ZWQgb24gYGRhdGFgIGFuZCByZXR1cm5lZCBieSBgLm5leHQoKWAuXG4gKlxuICogQHJldHVybiB7UXVlcnlDdXJzb3J9XG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiBAc2VlIFF1ZXJ5Q3Vyc29yIGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvcXVlcnljdXJzb3IuaHRtbFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5RdWVyeS5wcm90b3R5cGUuY3Vyc29yID0gZnVuY3Rpb24gY3Vyc29yKG9wdHMpIHtcbiAgaWYgKG9wdHMpIHtcbiAgICB0aGlzLnNldE9wdGlvbnMob3B0cyk7XG4gIH1cblxuICB0cnkge1xuICAgIHRoaXMuY2FzdCh0aGlzLm1vZGVsKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgcmV0dXJuIChuZXcgUXVlcnlDdXJzb3IodGhpcykpLl9tYXJrRXJyb3IoZXJyKTtcbiAgfVxuXG4gIHJldHVybiBuZXcgUXVlcnlDdXJzb3IodGhpcyk7XG59O1xuXG4vLyB0aGUgcmVzdCBvZiB0aGVzZSBhcmUgYmFzaWNhbGx5IHRvIHN1cHBvcnQgb2xkZXIgTW9uZ29vc2Ugc3ludGF4IHdpdGggbXF1ZXJ5XG5cbi8qKlxuICogU2V0cyB0aGUgdGFpbGFibGUgb3B0aW9uIChmb3IgdXNlIHdpdGggY2FwcGVkIGNvbGxlY3Rpb25zKS5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIHF1ZXJ5LnRhaWxhYmxlKCk7IC8vIHRydWVcbiAqICAgICBxdWVyeS50YWlsYWJsZSh0cnVlKTtcbiAqICAgICBxdWVyeS50YWlsYWJsZShmYWxzZSk7XG4gKlxuICogICAgIC8vIFNldCBib3RoIGB0YWlsYWJsZWAgYW5kIGBhd2FpdERhdGFgIG9wdGlvbnNcbiAqICAgICBxdWVyeS50YWlsYWJsZSh7IGF3YWl0RGF0YTogdHJ1ZSB9KTtcbiAqXG4gKiAjIyMjIE5vdGU6XG4gKlxuICogQ2Fubm90IGJlIHVzZWQgd2l0aCBgZGlzdGluY3QoKWBcbiAqXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGJvb2wgZGVmYXVsdHMgdG8gdHJ1ZVxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRzXSBvcHRpb25zIHRvIHNldFxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0cy5hd2FpdERhdGFdIGZhbHNlIGJ5IGRlZmF1bHQuIFNldCB0byB0cnVlIHRvIGtlZXAgdGhlIGN1cnNvciBvcGVuIGV2ZW4gaWYgdGhlcmUncyBubyBkYXRhLlxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRzLm1heEF3YWl0VGltZU1TXSB0aGUgbWF4aW11bSBhbW91bnQgb2YgdGltZSBmb3IgdGhlIHNlcnZlciB0byB3YWl0IG9uIG5ldyBkb2N1bWVudHMgdG8gc2F0aXNmeSBhIHRhaWxhYmxlIGN1cnNvciBxdWVyeS4gUmVxdWlyZXMgYHRhaWxhYmxlYCBhbmQgYGF3YWl0RGF0YWAgdG8gYmUgdHJ1ZVxuICogQHNlZSB0YWlsYWJsZSBodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC90dXRvcmlhbC9jcmVhdGUtdGFpbGFibGUtY3Vyc29yL1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5RdWVyeS5wcm90b3R5cGUudGFpbGFibGUgPSBmdW5jdGlvbih2YWwsIG9wdHMpIHtcbiAgLy8gd2UgbmVlZCB0byBzdXBwb3J0IHRoZSB0YWlsYWJsZSh7IGF3YWl0RGF0YSA6IHRydWUgfSkgYXMgd2VsbCBhcyB0aGVcbiAgLy8gdGFpbGFibGUodHJ1ZSwge2F3YWl0RGF0YSA6dHJ1ZX0pIHN5bnRheCB0aGF0IG1xdWVyeSBkb2VzIG5vdCBzdXBwb3J0XG4gIGlmICh2YWwgIT0gbnVsbCAmJiB0eXBlb2YgdmFsLmNvbnN0cnVjdG9yID09PSAnZnVuY3Rpb24nICYmIHZhbC5jb25zdHJ1Y3Rvci5uYW1lID09PSAnT2JqZWN0Jykge1xuICAgIG9wdHMgPSB2YWw7XG4gICAgdmFsID0gdHJ1ZTtcbiAgfVxuXG4gIGlmICh2YWwgPT09IHVuZGVmaW5lZCkge1xuICAgIHZhbCA9IHRydWU7XG4gIH1cblxuICBpZiAob3B0cyAmJiB0eXBlb2Ygb3B0cyA9PT0gJ29iamVjdCcpIHtcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhvcHRzKSkge1xuICAgICAgaWYgKGtleSA9PT0gJ2F3YWl0RGF0YScgfHwga2V5ID09PSAnYXdhaXRkYXRhJykgeyAvLyBiYWNrd2FyZHMgY29tcGF0LCBzZWUgZ2gtMTA4NzVcbiAgICAgICAgLy8gRm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XG4gICAgICAgIHRoaXMub3B0aW9uc1snYXdhaXREYXRhJ10gPSAhIW9wdHNba2V5XTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMub3B0aW9uc1trZXldID0gb3B0c1trZXldO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHRoaXMub3B0aW9ucy50YWlsYWJsZSA9IGFyZ3VtZW50cy5sZW5ndGggPyAhIXZhbCA6IHRydWU7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIERlY2xhcmVzIGFuIGludGVyc2VjdHMgcXVlcnkgZm9yIGBnZW9tZXRyeSgpYC5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIHF1ZXJ5LndoZXJlKCdwYXRoJykuaW50ZXJzZWN0cygpLmdlb21ldHJ5KHtcbiAqICAgICAgIHR5cGU6ICdMaW5lU3RyaW5nJyxcbiAqICAgICAgIGNvb3JkaW5hdGVzOiBbWzE4MC4wLCAxMS4wXSwgWzE4MCwgOS4wXV1cbiAqICAgICB9KTtcbiAqXG4gKiAgICAgcXVlcnkud2hlcmUoJ3BhdGgnKS5pbnRlcnNlY3RzKHtcbiAqICAgICAgIHR5cGU6ICdMaW5lU3RyaW5nJyxcbiAqICAgICAgIGNvb3JkaW5hdGVzOiBbWzE4MC4wLCAxMS4wXSwgWzE4MCwgOS4wXV1cbiAqICAgICB9KTtcbiAqXG4gKiAjIyMjIE5vdGU6XG4gKlxuICogKipNVVNUKiogYmUgdXNlZCBhZnRlciBgd2hlcmUoKWAuXG4gKlxuICogIyMjIyBOb3RlOlxuICpcbiAqIEluIE1vbmdvb3NlIDMuNywgYGludGVyc2VjdHNgIGNoYW5nZWQgZnJvbSBhIGdldHRlciB0byBhIGZ1bmN0aW9uLiBJZiB5b3UgbmVlZCB0aGUgb2xkIHN5bnRheCwgdXNlIFt0aGlzXShodHRwczovL2dpdGh1Yi5jb20vZWJlbnNpbmcvbW9uZ29vc2Utd2l0aGluKS5cbiAqXG4gKiBAbWV0aG9kIGludGVyc2VjdHNcbiAqIEBtZW1iZXJPZiBRdWVyeVxuICogQGluc3RhbmNlXG4gKiBAcGFyYW0ge09iamVjdH0gW2FyZ11cbiAqIEByZXR1cm4ge1F1ZXJ5fSB0aGlzXG4gKiBAc2VlICRnZW9tZXRyeSBodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9yZWZlcmVuY2Uvb3BlcmF0b3IvZ2VvbWV0cnkvXG4gKiBAc2VlIGdlb0ludGVyc2VjdHMgaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvcmVmZXJlbmNlL29wZXJhdG9yL2dlb0ludGVyc2VjdHMvXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbi8qKlxuICogU3BlY2lmaWVzIGEgYCRnZW9tZXRyeWAgY29uZGl0aW9uXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBjb25zdCBwb2x5QSA9IFtbWyAxMCwgMjAgXSwgWyAxMCwgNDAgXSwgWyAzMCwgNDAgXSwgWyAzMCwgMjAgXV1dXG4gKiAgICAgcXVlcnkud2hlcmUoJ2xvYycpLndpdGhpbigpLmdlb21ldHJ5KHsgdHlwZTogJ1BvbHlnb24nLCBjb29yZGluYXRlczogcG9seUEgfSlcbiAqXG4gKiAgICAgLy8gb3JcbiAqICAgICBjb25zdCBwb2x5QiA9IFtbIDAsIDAgXSwgWyAxLCAxIF1dXG4gKiAgICAgcXVlcnkud2hlcmUoJ2xvYycpLndpdGhpbigpLmdlb21ldHJ5KHsgdHlwZTogJ0xpbmVTdHJpbmcnLCBjb29yZGluYXRlczogcG9seUIgfSlcbiAqXG4gKiAgICAgLy8gb3JcbiAqICAgICBjb25zdCBwb2x5QyA9IFsgMCwgMCBdXG4gKiAgICAgcXVlcnkud2hlcmUoJ2xvYycpLndpdGhpbigpLmdlb21ldHJ5KHsgdHlwZTogJ1BvaW50JywgY29vcmRpbmF0ZXM6IHBvbHlDIH0pXG4gKlxuICogICAgIC8vIG9yXG4gKiAgICAgcXVlcnkud2hlcmUoJ2xvYycpLmludGVyc2VjdHMoKS5nZW9tZXRyeSh7IHR5cGU6ICdQb2ludCcsIGNvb3JkaW5hdGVzOiBwb2x5QyB9KVxuICpcbiAqIFRoZSBhcmd1bWVudCBpcyBhc3NpZ25lZCB0byB0aGUgbW9zdCByZWNlbnQgcGF0aCBwYXNzZWQgdG8gYHdoZXJlKClgLlxuICpcbiAqICMjIyMgTm90ZTpcbiAqXG4gKiBgZ2VvbWV0cnkoKWAgKiptdXN0KiogY29tZSBhZnRlciBlaXRoZXIgYGludGVyc2VjdHMoKWAgb3IgYHdpdGhpbigpYC5cbiAqXG4gKiBUaGUgYG9iamVjdGAgYXJndW1lbnQgbXVzdCBjb250YWluIGB0eXBlYCBhbmQgYGNvb3JkaW5hdGVzYCBwcm9wZXJ0aWVzLlxuICogLSB0eXBlIHtTdHJpbmd9XG4gKiAtIGNvb3JkaW5hdGVzIHtBcnJheX1cbiAqXG4gKiBAbWV0aG9kIGdlb21ldHJ5XG4gKiBAbWVtYmVyT2YgUXVlcnlcbiAqIEBpbnN0YW5jZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBNdXN0IGNvbnRhaW4gYSBgdHlwZWAgcHJvcGVydHkgd2hpY2ggaXMgYSBTdHJpbmcgYW5kIGEgYGNvb3JkaW5hdGVzYCBwcm9wZXJ0eSB3aGljaCBpcyBhbiBBcnJheS4gU2VlIHRoZSBleGFtcGxlcy5cbiAqIEByZXR1cm4ge1F1ZXJ5fSB0aGlzXG4gKiBAc2VlICRnZW9tZXRyeSBodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9yZWZlcmVuY2Uvb3BlcmF0b3IvZ2VvbWV0cnkvXG4gKiBAc2VlIEdlb3NwYXRpYWwgU3VwcG9ydCBFbmhhbmNlbWVudHMgaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvcmVsZWFzZS1ub3Rlcy8yLjQvI2dlb3NwYXRpYWwtc3VwcG9ydC1lbmhhbmNlbWVudHNcbiAqIEBzZWUgTW9uZ29EQiBHZW9zcGF0aWFsIEluZGV4aW5nIGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvbWFudWFsL2NvcmUvZ2Vvc3BhdGlhbC1pbmRleGVzL1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG4vKipcbiAqIFNwZWNpZmllcyBhIGAkbmVhcmAgb3IgYCRuZWFyU3BoZXJlYCBjb25kaXRpb25cbiAqXG4gKiBUaGVzZSBvcGVyYXRvcnMgcmV0dXJuIGRvY3VtZW50cyBzb3J0ZWQgYnkgZGlzdGFuY2UuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBxdWVyeS53aGVyZSgnbG9jJykubmVhcih7IGNlbnRlcjogWzEwLCAxMF0gfSk7XG4gKiAgICAgcXVlcnkud2hlcmUoJ2xvYycpLm5lYXIoeyBjZW50ZXI6IFsxMCwgMTBdLCBtYXhEaXN0YW5jZTogNSB9KTtcbiAqICAgICBxdWVyeS53aGVyZSgnbG9jJykubmVhcih7IGNlbnRlcjogWzEwLCAxMF0sIG1heERpc3RhbmNlOiA1LCBzcGhlcmljYWw6IHRydWUgfSk7XG4gKiAgICAgcXVlcnkubmVhcignbG9jJywgeyBjZW50ZXI6IFsxMCwgMTBdLCBtYXhEaXN0YW5jZTogNSB9KTtcbiAqXG4gKiBAbWV0aG9kIG5lYXJcbiAqIEBtZW1iZXJPZiBRdWVyeVxuICogQGluc3RhbmNlXG4gKiBAcGFyYW0ge1N0cmluZ30gW3BhdGhdXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsXG4gKiBAcmV0dXJuIHtRdWVyeX0gdGhpc1xuICogQHNlZSAkbmVhciBodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9yZWZlcmVuY2Uvb3BlcmF0b3IvbmVhci9cbiAqIEBzZWUgJG5lYXJTcGhlcmUgaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvcmVmZXJlbmNlL29wZXJhdG9yL25lYXJTcGhlcmUvXG4gKiBAc2VlICRtYXhEaXN0YW5jZSBodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9yZWZlcmVuY2Uvb3BlcmF0b3IvbWF4RGlzdGFuY2UvXG4gKiBAc2VlIE1vbmdvREIgR2Vvc3BhdGlhbCBJbmRleGluZyBodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9jb3JlL2dlb3NwYXRpYWwtaW5kZXhlcy9cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuLyoqXG4gKiBPdmVyd3JpdGluZyBtcXVlcnkgaXMgbmVlZGVkIHRvIHN1cHBvcnQgYSBjb3VwbGUgZGlmZmVyZW50IG5lYXIoKSBmb3JtcyBmb3VuZCBpbiBvbGRlclxuICogdmVyc2lvbnMgb2YgbW9uZ29vc2VcbiAqIG5lYXIoWzEsMV0pXG4gKiBuZWFyKDEsMSlcbiAqIG5lYXIoZmllbGQsIFsxLDJdKVxuICogbmVhcihmaWVsZCwgMSwgMilcbiAqIEluIGFkZGl0aW9uIHRvIGFsbCBvZiB0aGUgbm9ybWFsIGZvcm1zIHN1cHBvcnRlZCBieSBtcXVlcnlcbiAqXG4gKiBAbWV0aG9kIG5lYXJcbiAqIEBtZW1iZXJPZiBRdWVyeVxuICogQGluc3RhbmNlXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5RdWVyeS5wcm90b3R5cGUubmVhciA9IGZ1bmN0aW9uKCkge1xuICBjb25zdCBwYXJhbXMgPSBbXTtcbiAgY29uc3Qgc3BoZXJlID0gdGhpcy5fbW9uZ29vc2VPcHRpb25zLm5lYXJTcGhlcmU7XG5cbiAgLy8gVE9ETyByZWZhY3RvclxuXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYXJndW1lbnRzWzBdKSkge1xuICAgICAgcGFyYW1zLnB1c2goeyBjZW50ZXI6IGFyZ3VtZW50c1swXSwgc3BoZXJpY2FsOiBzcGhlcmUgfSk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgYXJndW1lbnRzWzBdID09PSAnc3RyaW5nJykge1xuICAgICAgLy8ganVzdCBwYXNzaW5nIGEgcGF0aFxuICAgICAgcGFyYW1zLnB1c2goYXJndW1lbnRzWzBdKTtcbiAgICB9IGVsc2UgaWYgKHV0aWxzLmlzT2JqZWN0KGFyZ3VtZW50c1swXSkpIHtcbiAgICAgIGlmICh0eXBlb2YgYXJndW1lbnRzWzBdLnNwaGVyaWNhbCAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgIGFyZ3VtZW50c1swXS5zcGhlcmljYWwgPSBzcGhlcmU7XG4gICAgICB9XG4gICAgICBwYXJhbXMucHVzaChhcmd1bWVudHNbMF0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIGFyZ3VtZW50Jyk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICBpZiAodHlwZW9mIGFyZ3VtZW50c1swXSA9PT0gJ251bWJlcicgJiYgdHlwZW9mIGFyZ3VtZW50c1sxXSA9PT0gJ251bWJlcicpIHtcbiAgICAgIHBhcmFtcy5wdXNoKHsgY2VudGVyOiBbYXJndW1lbnRzWzBdLCBhcmd1bWVudHNbMV1dLCBzcGhlcmljYWw6IHNwaGVyZSB9KTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBhcmd1bWVudHNbMF0gPT09ICdzdHJpbmcnICYmIEFycmF5LmlzQXJyYXkoYXJndW1lbnRzWzFdKSkge1xuICAgICAgcGFyYW1zLnB1c2goYXJndW1lbnRzWzBdKTtcbiAgICAgIHBhcmFtcy5wdXNoKHsgY2VudGVyOiBhcmd1bWVudHNbMV0sIHNwaGVyaWNhbDogc3BoZXJlIH0pO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGFyZ3VtZW50c1swXSA9PT0gJ3N0cmluZycgJiYgdXRpbHMuaXNPYmplY3QoYXJndW1lbnRzWzFdKSkge1xuICAgICAgcGFyYW1zLnB1c2goYXJndW1lbnRzWzBdKTtcbiAgICAgIGlmICh0eXBlb2YgYXJndW1lbnRzWzFdLnNwaGVyaWNhbCAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgIGFyZ3VtZW50c1sxXS5zcGhlcmljYWwgPSBzcGhlcmU7XG4gICAgICB9XG4gICAgICBwYXJhbXMucHVzaChhcmd1bWVudHNbMV0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIGFyZ3VtZW50Jyk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDMpIHtcbiAgICBpZiAodHlwZW9mIGFyZ3VtZW50c1swXSA9PT0gJ3N0cmluZycgJiYgdHlwZW9mIGFyZ3VtZW50c1sxXSA9PT0gJ251bWJlcidcbiAgICAgICAgJiYgdHlwZW9mIGFyZ3VtZW50c1syXSA9PT0gJ251bWJlcicpIHtcbiAgICAgIHBhcmFtcy5wdXNoKGFyZ3VtZW50c1swXSk7XG4gICAgICBwYXJhbXMucHVzaCh7IGNlbnRlcjogW2FyZ3VtZW50c1sxXSwgYXJndW1lbnRzWzJdXSwgc3BoZXJpY2FsOiBzcGhlcmUgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgYXJndW1lbnQnKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCBhcmd1bWVudCcpO1xuICB9XG5cbiAgcmV0dXJuIFF1ZXJ5LmJhc2UubmVhci5hcHBseSh0aGlzLCBwYXJhbXMpO1xufTtcblxuLyoqXG4gKiBfREVQUkVDQVRFRF8gU3BlY2lmaWVzIGEgYCRuZWFyU3BoZXJlYCBjb25kaXRpb25cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIHF1ZXJ5LndoZXJlKCdsb2MnKS5uZWFyU3BoZXJlKHsgY2VudGVyOiBbMTAsIDEwXSwgbWF4RGlzdGFuY2U6IDUgfSk7XG4gKlxuICogKipEZXByZWNhdGVkLioqIFVzZSBgcXVlcnkubmVhcigpYCBpbnN0ZWFkIHdpdGggdGhlIGBzcGhlcmljYWxgIG9wdGlvbiBzZXQgdG8gYHRydWVgLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgcXVlcnkud2hlcmUoJ2xvYycpLm5lYXIoeyBjZW50ZXI6IFsxMCwgMTBdLCBzcGhlcmljYWw6IHRydWUgfSk7XG4gKlxuICogQGRlcHJlY2F0ZWRcbiAqIEBzZWUgbmVhcigpIGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvcXVlcnkuaHRtbCNRdWVyeS5wcm90b3R5cGUubmVhcigpXG4gKiBAc2VlICRuZWFyIGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvbWFudWFsL3JlZmVyZW5jZS9vcGVyYXRvci9uZWFyL1xuICogQHNlZSAkbmVhclNwaGVyZSBodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9yZWZlcmVuY2Uvb3BlcmF0b3IvbmVhclNwaGVyZS9cbiAqIEBzZWUgJG1heERpc3RhbmNlIGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvbWFudWFsL3JlZmVyZW5jZS9vcGVyYXRvci9tYXhEaXN0YW5jZS9cbiAqL1xuXG5RdWVyeS5wcm90b3R5cGUubmVhclNwaGVyZSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLl9tb25nb29zZU9wdGlvbnMubmVhclNwaGVyZSA9IHRydWU7XG4gIHRoaXMubmVhci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUmV0dXJucyBhbiBhc3luY0l0ZXJhdG9yIGZvciB1c2Ugd2l0aCBbYGZvci9hd2FpdC9vZmAgbG9vcHNdKGh0dHBzOi8vdGhlY29kZWJhcmJhcmlhbi5jb20vZ2V0dGluZy1zdGFydGVkLXdpdGgtYXN5bmMtaXRlcmF0b3JzLWluLW5vZGUtanMpXG4gKiBUaGlzIGZ1bmN0aW9uICpvbmx5KiB3b3JrcyBmb3IgYGZpbmQoKWAgcXVlcmllcy5cbiAqIFlvdSBkbyBub3QgbmVlZCB0byBjYWxsIHRoaXMgZnVuY3Rpb24gZXhwbGljaXRseSwgdGhlIEphdmFTY3JpcHQgcnVudGltZVxuICogd2lsbCBjYWxsIGl0IGZvciB5b3UuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBmb3IgYXdhaXQgKGNvbnN0IGRvYyBvZiBNb2RlbC5hZ2dyZWdhdGUoW3sgJHNvcnQ6IHsgbmFtZTogMSB9IH1dKSkge1xuICogICAgICAgY29uc29sZS5sb2coZG9jLm5hbWUpO1xuICogICAgIH1cbiAqXG4gKiBOb2RlLmpzIDEwLnggc3VwcG9ydHMgYXN5bmMgaXRlcmF0b3JzIG5hdGl2ZWx5IHdpdGhvdXQgYW55IGZsYWdzLiBZb3UgY2FuXG4gKiBlbmFibGUgYXN5bmMgaXRlcmF0b3JzIGluIE5vZGUuanMgOC54IHVzaW5nIHRoZSBbYC0taGFybW9ueV9hc3luY19pdGVyYXRpb25gIGZsYWddKGh0dHBzOi8vZ2l0aHViLmNvbS90YzM5L3Byb3Bvc2FsLWFzeW5jLWl0ZXJhdGlvbi9pc3N1ZXMvMTE3I2lzc3VlY29tbWVudC0zNDY2OTUxODcpLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIGZ1bmN0aW9uIGlzIG5vdCBpZiBgU3ltYm9sLmFzeW5jSXRlcmF0b3JgIGlzIHVuZGVmaW5lZC4gSWZcbiAqIGBTeW1ib2wuYXN5bmNJdGVyYXRvcmAgaXMgdW5kZWZpbmVkLCB0aGF0IG1lYW5zIHlvdXIgTm9kZS5qcyB2ZXJzaW9uIGRvZXMgbm90XG4gKiBzdXBwb3J0IGFzeW5jIGl0ZXJhdG9ycy5cbiAqXG4gKiBAbWV0aG9kIFtTeW1ib2wuYXN5bmNJdGVyYXRvcl1cbiAqIEBtZW1iZXJPZiBRdWVyeVxuICogQGluc3RhbmNlXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmlmIChTeW1ib2wuYXN5bmNJdGVyYXRvciAhPSBudWxsKSB7XG4gIFF1ZXJ5LnByb3RvdHlwZVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5jdXJzb3IoKS50cmFuc2Zvcm1OdWxsKCkuX3RyYW5zZm9ybUZvckFzeW5jSXRlcmF0b3IoKTtcbiAgfTtcbn1cblxuLyoqXG4gKiBTcGVjaWZpZXMgYSBgJHBvbHlnb25gIGNvbmRpdGlvblxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgcXVlcnkud2hlcmUoJ2xvYycpLndpdGhpbigpLnBvbHlnb24oWzEwLCAyMF0sIFsxMywgMjVdLCBbNywgMTVdKTtcbiAqICAgICBxdWVyeS5wb2x5Z29uKCdsb2MnLCBbMTAsIDIwXSwgWzEzLCAyNV0sIFs3LCAxNV0pO1xuICpcbiAqIEBtZXRob2QgcG9seWdvblxuICogQG1lbWJlck9mIFF1ZXJ5XG4gKiBAaW5zdGFuY2VcbiAqIEBwYXJhbSB7U3RyaW5nfEFycmF5fSBbcGF0aF1cbiAqIEBwYXJhbSB7Li4uQXJyYXl8T2JqZWN0fSBbY29vcmRpbmF0ZVBhaXJzXVxuICogQHJldHVybiB7UXVlcnl9IHRoaXNcbiAqIEBzZWUgJHBvbHlnb24gaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvcmVmZXJlbmNlL29wZXJhdG9yL3BvbHlnb24vXG4gKiBAc2VlIE1vbmdvREIgR2Vvc3BhdGlhbCBJbmRleGluZyBodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9jb3JlL2dlb3NwYXRpYWwtaW5kZXhlcy9cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuLyoqXG4gKiBTcGVjaWZpZXMgYSBgJGJveGAgY29uZGl0aW9uXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBjb25zdCBsb3dlckxlZnQgPSBbNDAuNzMwODMsIC03My45OTc1Nl1cbiAqICAgICBjb25zdCB1cHBlclJpZ2h0PSBbNDAuNzQxNDA0LCAgLTczLjk4ODEzNV1cbiAqXG4gKiAgICAgcXVlcnkud2hlcmUoJ2xvYycpLndpdGhpbigpLmJveChsb3dlckxlZnQsIHVwcGVyUmlnaHQpXG4gKiAgICAgcXVlcnkuYm94KHsgbGwgOiBsb3dlckxlZnQsIHVyIDogdXBwZXJSaWdodCB9KVxuICpcbiAqIEBtZXRob2QgYm94XG4gKiBAbWVtYmVyT2YgUXVlcnlcbiAqIEBpbnN0YW5jZVxuICogQHNlZSAkYm94IGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvbWFudWFsL3JlZmVyZW5jZS9vcGVyYXRvci9ib3gvXG4gKiBAc2VlIHdpdGhpbigpIFF1ZXJ5I3dpdGhpbiBodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvYXBpL3F1ZXJ5Lmh0bWwjUXVlcnkucHJvdG90eXBlLndpdGhpbigpXG4gKiBAc2VlIE1vbmdvREIgR2Vvc3BhdGlhbCBJbmRleGluZyBodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9jb3JlL2dlb3NwYXRpYWwtaW5kZXhlcy9cbiAqIEBwYXJhbSB7T2JqZWN0fEFycmF5PE51bWJlcj59IHZhbDEgTG93ZXIgTGVmdCBDb29yZGluYXRlcyBPUiBhIG9iamVjdCBvZiBsb3dlci1sZWZ0KGxsKSBhbmQgdXBwZXItcmlnaHQodXIpIENvb3JkaW5hdGVzXG4gKiBAcGFyYW0ge0FycmF5PE51bWJlcj59IFt2YWwyXSBVcHBlciBSaWdodCBDb29yZGluYXRlc1xuICogQHJldHVybiB7UXVlcnl9IHRoaXNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuLyoqXG4gKiB0aGlzIGlzIG5lZWRlZCB0byBzdXBwb3J0IHRoZSBtb25nb29zZSBzeW50YXggb2Y6XG4gKiBib3goZmllbGQsIHsgbGwgOiBbeCx5XSwgdXIgOiBbeDIseTJdIH0pXG4gKiBib3goeyBsbCA6IFt4LHldLCB1ciA6IFt4Mix5Ml0gfSlcbiAqXG4gKiBAbWV0aG9kIGJveFxuICogQG1lbWJlck9mIFF1ZXJ5XG4gKiBAaW5zdGFuY2VcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblF1ZXJ5LnByb3RvdHlwZS5ib3ggPSBmdW5jdGlvbihsbCwgdXIpIHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KGxsKSAmJiB1dGlscy5pc09iamVjdChsbCkpIHtcbiAgICB1ciA9IGxsLnVyO1xuICAgIGxsID0gbGwubGw7XG4gIH1cbiAgcmV0dXJuIFF1ZXJ5LmJhc2UuYm94LmNhbGwodGhpcywgbGwsIHVyKTtcbn07XG5cbi8qKlxuICogU3BlY2lmaWVzIGEgYCRjZW50ZXJgIG9yIGAkY2VudGVyU3BoZXJlYCBjb25kaXRpb24uXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBjb25zdCBhcmVhID0geyBjZW50ZXI6IFs1MCwgNTBdLCByYWRpdXM6IDEwLCB1bmlxdWU6IHRydWUgfVxuICogICAgIHF1ZXJ5LndoZXJlKCdsb2MnKS53aXRoaW4oKS5jaXJjbGUoYXJlYSlcbiAqICAgICAvLyBhbHRlcm5hdGl2ZWx5XG4gKiAgICAgcXVlcnkuY2lyY2xlKCdsb2MnLCBhcmVhKTtcbiAqXG4gKiAgICAgLy8gc3BoZXJpY2FsIGNhbGN1bGF0aW9uc1xuICogICAgIGNvbnN0IGFyZWEgPSB7IGNlbnRlcjogWzUwLCA1MF0sIHJhZGl1czogMTAsIHVuaXF1ZTogdHJ1ZSwgc3BoZXJpY2FsOiB0cnVlIH1cbiAqICAgICBxdWVyeS53aGVyZSgnbG9jJykud2l0aGluKCkuY2lyY2xlKGFyZWEpXG4gKiAgICAgLy8gYWx0ZXJuYXRpdmVseVxuICogICAgIHF1ZXJ5LmNpcmNsZSgnbG9jJywgYXJlYSk7XG4gKlxuICogQG1ldGhvZCBjaXJjbGVcbiAqIEBtZW1iZXJPZiBRdWVyeVxuICogQGluc3RhbmNlXG4gKiBAcGFyYW0ge1N0cmluZ30gW3BhdGhdXG4gKiBAcGFyYW0ge09iamVjdH0gYXJlYVxuICogQHJldHVybiB7UXVlcnl9IHRoaXNcbiAqIEBzZWUgJGNlbnRlciBodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9yZWZlcmVuY2Uvb3BlcmF0b3IvY2VudGVyL1xuICogQHNlZSAkY2VudGVyU3BoZXJlIGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvbWFudWFsL3JlZmVyZW5jZS9vcGVyYXRvci9jZW50ZXJTcGhlcmUvXG4gKiBAc2VlICRnZW9XaXRoaW4gaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvcmVmZXJlbmNlL29wZXJhdG9yL2dlb1dpdGhpbi9cbiAqIEBzZWUgTW9uZ29EQiBHZW9zcGF0aWFsIEluZGV4aW5nIGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvbWFudWFsL2NvcmUvZ2Vvc3BhdGlhbC1pbmRleGVzL1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG4vKipcbiAqIF9ERVBSRUNBVEVEXyBBbGlhcyBmb3IgW2NpcmNsZV0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2FwaS9xdWVyeS5odG1sI1F1ZXJ5LnByb3RvdHlwZS5jaXJjbGUoKSlcbiAqXG4gKiAqKkRlcHJlY2F0ZWQuKiogVXNlIFtjaXJjbGVdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvcXVlcnkuaHRtbCNRdWVyeS5wcm90b3R5cGUuY2lyY2xlKCkpIGluc3RlYWQuXG4gKlxuICogQGRlcHJlY2F0ZWRcbiAqIEBtZXRob2QgY2VudGVyXG4gKiBAbWVtYmVyT2YgUXVlcnlcbiAqIEBpbnN0YW5jZVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5RdWVyeS5wcm90b3R5cGUuY2VudGVyID0gUXVlcnkuYmFzZS5jaXJjbGU7XG5cbi8qKlxuICogX0RFUFJFQ0FURURfIFNwZWNpZmllcyBhIGAkY2VudGVyU3BoZXJlYCBjb25kaXRpb25cbiAqXG4gKiAqKkRlcHJlY2F0ZWQuKiogVXNlIFtjaXJjbGVdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvcXVlcnkuaHRtbCNRdWVyeS5wcm90b3R5cGUuY2lyY2xlKCkpIGluc3RlYWQuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBjb25zdCBhcmVhID0geyBjZW50ZXI6IFs1MCwgNTBdLCByYWRpdXM6IDEwIH07XG4gKiAgICAgcXVlcnkud2hlcmUoJ2xvYycpLndpdGhpbigpLmNlbnRlclNwaGVyZShhcmVhKTtcbiAqXG4gKiBAZGVwcmVjYXRlZFxuICogQHBhcmFtIHtTdHJpbmd9IFtwYXRoXVxuICogQHBhcmFtIHtPYmplY3R9IHZhbFxuICogQHJldHVybiB7UXVlcnl9IHRoaXNcbiAqIEBzZWUgTW9uZ29EQiBHZW9zcGF0aWFsIEluZGV4aW5nIGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvbWFudWFsL2NvcmUvZ2Vvc3BhdGlhbC1pbmRleGVzL1xuICogQHNlZSAkY2VudGVyU3BoZXJlIGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvbWFudWFsL3JlZmVyZW5jZS9vcGVyYXRvci9jZW50ZXJTcGhlcmUvXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblF1ZXJ5LnByb3RvdHlwZS5jZW50ZXJTcGhlcmUgPSBmdW5jdGlvbigpIHtcbiAgaWYgKGFyZ3VtZW50c1swXSAhPSBudWxsICYmIHR5cGVvZiBhcmd1bWVudHNbMF0uY29uc3RydWN0b3IgPT09ICdmdW5jdGlvbicgJiYgYXJndW1lbnRzWzBdLmNvbnN0cnVjdG9yLm5hbWUgPT09ICdPYmplY3QnKSB7XG4gICAgYXJndW1lbnRzWzBdLnNwaGVyaWNhbCA9IHRydWU7XG4gIH1cblxuICBpZiAoYXJndW1lbnRzWzFdICE9IG51bGwgJiYgdHlwZW9mIGFyZ3VtZW50c1sxXS5jb25zdHJ1Y3RvciA9PT0gJ2Z1bmN0aW9uJyAmJiBhcmd1bWVudHNbMV0uY29uc3RydWN0b3IubmFtZSA9PT0gJ09iamVjdCcpIHtcbiAgICBhcmd1bWVudHNbMV0uc3BoZXJpY2FsID0gdHJ1ZTtcbiAgfVxuXG4gIFF1ZXJ5LmJhc2UuY2lyY2xlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59O1xuXG4vKipcbiAqIERldGVybWluZXMgaWYgZmllbGQgc2VsZWN0aW9uIGhhcyBiZWVuIG1hZGUuXG4gKlxuICogQG1ldGhvZCBzZWxlY3RlZFxuICogQG1lbWJlck9mIFF1ZXJ5XG4gKiBAaW5zdGFuY2VcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbi8qKlxuICogRGV0ZXJtaW5lcyBpZiBpbmNsdXNpdmUgZmllbGQgc2VsZWN0aW9uIGhhcyBiZWVuIG1hZGUuXG4gKlxuICogICAgIHF1ZXJ5LnNlbGVjdGVkSW5jbHVzaXZlbHkoKTsgLy8gZmFsc2VcbiAqICAgICBxdWVyeS5zZWxlY3QoJ25hbWUnKTtcbiAqICAgICBxdWVyeS5zZWxlY3RlZEluY2x1c2l2ZWx5KCk7IC8vIHRydWVcbiAqXG4gKiBAbWV0aG9kIHNlbGVjdGVkSW5jbHVzaXZlbHlcbiAqIEBtZW1iZXJPZiBRdWVyeVxuICogQGluc3RhbmNlXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5RdWVyeS5wcm90b3R5cGUuc2VsZWN0ZWRJbmNsdXNpdmVseSA9IGZ1bmN0aW9uIHNlbGVjdGVkSW5jbHVzaXZlbHkoKSB7XG4gIHJldHVybiBpc0luY2x1c2l2ZSh0aGlzLl9maWVsZHMpO1xufTtcblxuLyoqXG4gKiBEZXRlcm1pbmVzIGlmIGV4Y2x1c2l2ZSBmaWVsZCBzZWxlY3Rpb24gaGFzIGJlZW4gbWFkZS5cbiAqXG4gKiAgICAgcXVlcnkuc2VsZWN0ZWRFeGNsdXNpdmVseSgpOyAvLyBmYWxzZVxuICogICAgIHF1ZXJ5LnNlbGVjdCgnLW5hbWUnKTtcbiAqICAgICBxdWVyeS5zZWxlY3RlZEV4Y2x1c2l2ZWx5KCk7IC8vIHRydWVcbiAqICAgICBxdWVyeS5zZWxlY3RlZEluY2x1c2l2ZWx5KCk7IC8vIGZhbHNlXG4gKlxuICogQG1ldGhvZCBzZWxlY3RlZEV4Y2x1c2l2ZWx5XG4gKiBAbWVtYmVyT2YgUXVlcnlcbiAqIEBpbnN0YW5jZVxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUXVlcnkucHJvdG90eXBlLnNlbGVjdGVkRXhjbHVzaXZlbHkgPSBmdW5jdGlvbiBzZWxlY3RlZEV4Y2x1c2l2ZWx5KCkge1xuICByZXR1cm4gaXNFeGNsdXNpdmUodGhpcy5fZmllbGRzKTtcbn07XG5cbi8qKlxuICogVGhlIG1vZGVsIHRoaXMgcXVlcnkgaXMgYXNzb2NpYXRlZCB3aXRoLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgY29uc3QgcSA9IE15TW9kZWwuZmluZCgpO1xuICogICAgIHEubW9kZWwgPT09IE15TW9kZWw7IC8vIHRydWVcbiAqXG4gKiBAYXBpIHB1YmxpY1xuICogQHByb3BlcnR5IG1vZGVsXG4gKiBAbWVtYmVyT2YgUXVlcnlcbiAqIEBpbnN0YW5jZVxuICovXG5cblF1ZXJ5LnByb3RvdHlwZS5tb2RlbDtcblxuLyohXG4gKiBFeHBvcnRcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IFF1ZXJ5O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../server/node_modules/mongoose/lib/query.js\n");

/***/ }),

/***/ "../server/node_modules/mongoose/lib/queryHelpers.js":
/*!***********************************************************!*\
  !*** ../server/node_modules/mongoose/lib/queryHelpers.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\n/*!\n * Module dependencies\n */\n\nconst checkEmbeddedDiscriminatorKeyProjection =\n  __webpack_require__(/*! ./helpers/discriminator/checkEmbeddedDiscriminatorKeyProjection */ \"../server/node_modules/mongoose/lib/helpers/discriminator/checkEmbeddedDiscriminatorKeyProjection.js\");\nconst get = __webpack_require__(/*! ./helpers/get */ \"../server/node_modules/mongoose/lib/helpers/get.js\");\nconst getDiscriminatorByValue =\n  __webpack_require__(/*! ./helpers/discriminator/getDiscriminatorByValue */ \"../server/node_modules/mongoose/lib/helpers/discriminator/getDiscriminatorByValue.js\");\nconst isDefiningProjection = __webpack_require__(/*! ./helpers/projection/isDefiningProjection */ \"../server/node_modules/mongoose/lib/helpers/projection/isDefiningProjection.js\");\nconst clone = __webpack_require__(/*! ./helpers/clone */ \"../server/node_modules/mongoose/lib/helpers/clone.js\");\nconst isPathSelectedInclusive = __webpack_require__(/*! ./helpers/projection/isPathSelectedInclusive */ \"../server/node_modules/mongoose/lib/helpers/projection/isPathSelectedInclusive.js\");\n\n/**\n * Prepare a set of path options for query population.\n *\n * @param {Query} query\n * @param {Object} options\n * @return {Array}\n */\n\nexports.preparePopulationOptions = function preparePopulationOptions(query, options) {\n  const _populate = query.options.populate;\n  const pop = Object.keys(_populate).reduce((vals, key) => vals.concat([_populate[key]]), []);\n\n  // lean options should trickle through all queries\n  if (options.lean != null) {\n    pop\n      .filter(p => (p && p.options && p.options.lean) == null)\n      .forEach(makeLean(options.lean));\n  }\n\n  pop.forEach(opts => {\n    opts._localModel = query.model;\n  });\n\n  return pop;\n};\n\n/**\n * Prepare a set of path options for query population. This is the MongooseQuery\n * version\n *\n * @param {Query} query\n * @param {Object} options\n * @return {Array}\n */\n\nexports.preparePopulationOptionsMQ = function preparePopulationOptionsMQ(query, options) {\n  const _populate = query._mongooseOptions.populate;\n  const pop = Object.keys(_populate).reduce((vals, key) => vals.concat([_populate[key]]), []);\n\n  // lean options should trickle through all queries\n  if (options.lean != null) {\n    pop\n      .filter(p => (p && p.options && p.options.lean) == null)\n      .forEach(makeLean(options.lean));\n  }\n\n  const session = query && query.options && query.options.session || null;\n  if (session != null) {\n    pop.forEach(path => {\n      if (path.options == null) {\n        path.options = { session: session };\n        return;\n      }\n      if (!('session' in path.options)) {\n        path.options.session = session;\n      }\n    });\n  }\n\n  const projection = query._fieldsForExec();\n  pop.forEach(p => {\n    p._queryProjection = projection;\n  });\n  pop.forEach(opts => {\n    opts._localModel = query.model;\n  });\n\n  return pop;\n};\n\n/**\n * If the document is a mapped discriminator type, it returns a model instance for that type, otherwise,\n * it returns an instance of the given model.\n *\n * @param {Model}  model\n * @param {Object} doc\n * @param {Object} fields\n *\n * @return {Document}\n */\nexports.createModel = function createModel(model, doc, fields, userProvidedFields, options) {\n  model.hooks.execPreSync('createModel', doc);\n  const discriminatorMapping = model.schema ?\n    model.schema.discriminatorMapping :\n    null;\n\n  const key = discriminatorMapping && discriminatorMapping.isRoot ?\n    discriminatorMapping.key :\n    null;\n\n  const value = doc[key];\n  if (key && value && model.discriminators) {\n    const discriminator = model.discriminators[value] || getDiscriminatorByValue(model.discriminators, value);\n    if (discriminator) {\n      const _fields = clone(userProvidedFields);\n      exports.applyPaths(_fields, discriminator.schema);\n      return new discriminator(undefined, _fields, true);\n    }\n  }\n\n  const _opts = {\n    skipId: true,\n    isNew: false,\n    willInit: true\n  };\n  if (options != null && 'defaults' in options) {\n    _opts.defaults = options.defaults;\n  }\n  return new model(undefined, fields, _opts);\n};\n\n/*!\n * ignore\n */\n\nexports.createModelAndInit = function createModelAndInit(model, doc, fields, userProvidedFields, options, populatedIds, callback) {\n  const initOpts = populatedIds ?\n    { populated: populatedIds } :\n    undefined;\n\n  const casted = exports.createModel(model, doc, fields, userProvidedFields, options);\n  try {\n    casted.$init(doc, initOpts, callback);\n  } catch (error) {\n    callback(error, casted);\n  }\n};\n\n/*!\n * ignore\n */\n\nexports.applyPaths = function applyPaths(fields, schema) {\n  // determine if query is selecting or excluding fields\n  let exclude;\n  let keys;\n  const minusPathsToSkip = new Set();\n\n  if (fields) {\n    keys = Object.keys(fields);\n\n    // Collapse minus paths\n    const minusPaths = [];\n    for (let i = 0; i < keys.length; ++i) {\n      const key = keys[i];\n      if (keys[i][0] !== '-') {\n        continue;\n      }\n\n      delete fields[key];\n      if (key === '-_id') {\n        fields['_id'] = 0;\n      } else {\n        minusPaths.push(key.slice(1));\n      }\n    }\n\n    keys = Object.keys(fields);\n    for (let keyIndex = 0; keyIndex < keys.length; ++keyIndex) {\n      if (keys[keyIndex][0] === '+') {\n        continue;\n      }\n      const field = fields[keys[keyIndex]];\n      // Skip `$meta` and `$slice`\n      if (!isDefiningProjection(field)) {\n        continue;\n      }\n      if (keys[keyIndex] === '_id' && keys.length > 1) {\n        continue;\n      }\n      if (keys[keyIndex] === schema.options.discriminatorKey && keys.length > 1 && field != null && !field) {\n        continue;\n      }\n      exclude = !field;\n      break;\n    }\n\n    // Potentially add back minus paths based on schema-level path config\n    // and whether the projection is inclusive\n    for (const path of minusPaths) {\n      const type = schema.path(path);\n      // If the path isn't selected by default or the projection is not\n      // inclusive, minus path is treated as equivalent to `key: 0`.\n      // But we also allow using `-name` to remove `name` from an inclusive\n      // projection if `name` has schema-level `select: true`.\n      if ((!type || !type.selected) || exclude !== false) {\n        fields[path] = 0;\n        exclude = true;\n      } else if (type && type.selected && exclude === false) {\n        // Make a note of minus paths that are overwriting paths that are\n        // included by default.\n        minusPathsToSkip.add(path);\n      }\n    }\n  }\n\n  // if selecting, apply default schematype select:true fields\n  // if excluding, apply schematype select:false fields\n  const selected = [];\n  const excluded = [];\n  const stack = [];\n\n  analyzeSchema(schema);\n  switch (exclude) {\n    case true:\n      for (const fieldName of excluded) {\n        fields[fieldName] = 0;\n      }\n      break;\n    case false:\n      if (schema &&\n          schema.paths['_id'] &&\n          schema.paths['_id'].options &&\n          schema.paths['_id'].options.select === false) {\n        fields._id = 0;\n      }\n\n      for (const fieldName of selected) {\n        if (minusPathsToSkip.has(fieldName)) {\n          continue;\n        }\n        if (isPathSelectedInclusive(fields, fieldName)) {\n          continue;\n        }\n        fields[fieldName] = fields[fieldName] || 1;\n      }\n      break;\n    case undefined:\n      if (fields == null) {\n        break;\n      }\n      // Any leftover plus paths must in the schema, so delete them (gh-7017)\n      for (const key of Object.keys(fields || {})) {\n        if (key.startsWith('+')) {\n          delete fields[key];\n        }\n      }\n\n      // user didn't specify fields, implies returning all fields.\n      // only need to apply excluded fields and delete any plus paths\n      for (const fieldName of excluded) {\n        if (fields[fieldName] != null) {\n          // Skip applying default projections to fields with non-defining\n          // projections, like `$slice`\n          continue;\n        }\n        fields[fieldName] = 0;\n      }\n      break;\n  }\n\n  function analyzeSchema(schema, prefix) {\n    prefix || (prefix = '');\n\n    // avoid recursion\n    if (stack.indexOf(schema) !== -1) {\n      return [];\n    }\n    stack.push(schema);\n\n    const addedPaths = [];\n    schema.eachPath(function(path, type) {\n      if (prefix) path = prefix + '.' + path;\n      if (type.$isSchemaMap || path.endsWith('.$*')) {\n        const plusPath = '+' + path;\n        const hasPlusPath = fields && plusPath in fields;\n        if (type.options && type.options.select === false && !hasPlusPath) {\n          excluded.push(path);\n        }\n        return;\n      }\n      let addedPath = analyzePath(path, type);\n      // arrays\n      if (addedPath == null && !Array.isArray(type) && type.$isMongooseArray && !type.$isMongooseDocumentArray) {\n        addedPath = analyzePath(path, type.caster);\n      }\n      if (addedPath != null) {\n        addedPaths.push(addedPath);\n      }\n\n      // nested schemas\n      if (type.schema) {\n        const _addedPaths = analyzeSchema(type.schema, path);\n\n        // Special case: if discriminator key is the only field that would\n        // be projected in, remove it.\n        if (exclude === false) {\n          checkEmbeddedDiscriminatorKeyProjection(fields, path, type.schema,\n            selected, _addedPaths);\n        }\n      }\n    });\n    stack.pop();\n    return addedPaths;\n  }\n\n  function analyzePath(path, type) {\n    if (fields == null) {\n      return;\n    }\n\n    // If schema-level selected not set, nothing to do\n    if (typeof type.selected !== 'boolean') {\n      return;\n    }\n\n    // User overwriting default exclusion\n    if (type.selected === false && fields[path]) {\n      return;\n    }\n\n    // If set to 0, we're explicitly excluding the discriminator key. Can't do this for all fields,\n    // because we have tests that assert that using `-path` to exclude schema-level `select: true`\n    // fields counts as an exclusive projection. See gh-11546\n    if (!exclude && type.selected && path === schema.options.discriminatorKey && fields[path] != null && !fields[path]) {\n      delete fields[path];\n      return;\n    }\n\n    if (exclude === false && type.selected && fields[path] != null && !fields[path]) {\n      delete fields[path];\n      return;\n    }\n\n    const plusPath = '+' + path;\n    const hasPlusPath = fields && plusPath in fields;\n    if (hasPlusPath) {\n      // forced inclusion\n      delete fields[plusPath];\n\n      // if there are other fields being included, add this one\n      // if no other included fields, leave this out (implied inclusion)\n      if (exclude === false && keys.length > 1 && !~keys.indexOf(path)) {\n        fields[path] = 1;\n      }\n\n      return;\n    }\n\n    // check for parent exclusions\n    const pieces = path.split('.');\n    let cur = '';\n    for (let i = 0; i < pieces.length; ++i) {\n      cur += cur.length ? '.' + pieces[i] : pieces[i];\n      if (excluded.indexOf(cur) !== -1) {\n        return;\n      }\n    }\n\n    // Special case: if user has included a parent path of a discriminator key,\n    // don't explicitly project in the discriminator key because that will\n    // project out everything else under the parent path\n    if (!exclude && (type && type.options && type.options.$skipDiscriminatorCheck || false)) {\n      let cur = '';\n      for (let i = 0; i < pieces.length; ++i) {\n        cur += (cur.length === 0 ? '' : '.') + pieces[i];\n        const projection = get(fields, cur, false) || get(fields, cur + '.$', false);\n        if (projection && typeof projection !== 'object') {\n          return;\n        }\n      }\n    }\n\n    (type.selected ? selected : excluded).push(path);\n    return path;\n  }\n};\n\n/**\n * Set each path query option to lean\n *\n * @param {Object} option\n */\n\nfunction makeLean(val) {\n  return function(option) {\n    option.options || (option.options = {});\n\n    if (val != null && Array.isArray(val.virtuals)) {\n      val = Object.assign({}, val);\n      val.virtuals = val.virtuals.\n        filter(path => typeof path === 'string' && path.startsWith(option.path + '.')).\n        map(path => path.slice(option.path.length + 1));\n    }\n\n    option.options.lean = val;\n  };\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvcXVlcnlIZWxwZXJzLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUUsbUJBQU8sQ0FBQyw2S0FBaUU7QUFDM0UsWUFBWSxtQkFBTyxDQUFDLHlFQUFlO0FBQ25DO0FBQ0EsRUFBRSxtQkFBTyxDQUFDLDZJQUFpRDtBQUMzRCw2QkFBNkIsbUJBQU8sQ0FBQyxpSUFBMkM7QUFDaEYsY0FBYyxtQkFBTyxDQUFDLDZFQUFpQjtBQUN2QyxnQ0FBZ0MsbUJBQU8sQ0FBQyx1SUFBOEM7O0FBRXRGO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLFFBQVE7QUFDbkIsWUFBWTtBQUNaOztBQUVBLGdDQUFnQztBQUNoQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsUUFBUTtBQUNuQixZQUFZO0FBQ1o7O0FBRUEsa0NBQWtDO0FBQ2xDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjtBQUNBLFlBQVk7QUFDWjtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSwwQkFBMEI7QUFDMUI7QUFDQSxNQUFNLDBCQUEwQjtBQUNoQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0JBQW9CLGlCQUFpQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMkJBQTJCLHdCQUF3QjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0Q7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixtQkFBbUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLG1CQUFtQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7O0FBRUE7QUFDQTtBQUNBLDBDQUEwQzs7QUFFMUM7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2xpZW50Ly4uL3NlcnZlci9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL3F1ZXJ5SGVscGVycy5qcz8yMDkyIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuLyohXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzXG4gKi9cblxuY29uc3QgY2hlY2tFbWJlZGRlZERpc2NyaW1pbmF0b3JLZXlQcm9qZWN0aW9uID1cbiAgcmVxdWlyZSgnLi9oZWxwZXJzL2Rpc2NyaW1pbmF0b3IvY2hlY2tFbWJlZGRlZERpc2NyaW1pbmF0b3JLZXlQcm9qZWN0aW9uJyk7XG5jb25zdCBnZXQgPSByZXF1aXJlKCcuL2hlbHBlcnMvZ2V0Jyk7XG5jb25zdCBnZXREaXNjcmltaW5hdG9yQnlWYWx1ZSA9XG4gIHJlcXVpcmUoJy4vaGVscGVycy9kaXNjcmltaW5hdG9yL2dldERpc2NyaW1pbmF0b3JCeVZhbHVlJyk7XG5jb25zdCBpc0RlZmluaW5nUHJvamVjdGlvbiA9IHJlcXVpcmUoJy4vaGVscGVycy9wcm9qZWN0aW9uL2lzRGVmaW5pbmdQcm9qZWN0aW9uJyk7XG5jb25zdCBjbG9uZSA9IHJlcXVpcmUoJy4vaGVscGVycy9jbG9uZScpO1xuY29uc3QgaXNQYXRoU2VsZWN0ZWRJbmNsdXNpdmUgPSByZXF1aXJlKCcuL2hlbHBlcnMvcHJvamVjdGlvbi9pc1BhdGhTZWxlY3RlZEluY2x1c2l2ZScpO1xuXG4vKipcbiAqIFByZXBhcmUgYSBzZXQgb2YgcGF0aCBvcHRpb25zIGZvciBxdWVyeSBwb3B1bGF0aW9uLlxuICpcbiAqIEBwYXJhbSB7UXVlcnl9IHF1ZXJ5XG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQHJldHVybiB7QXJyYXl9XG4gKi9cblxuZXhwb3J0cy5wcmVwYXJlUG9wdWxhdGlvbk9wdGlvbnMgPSBmdW5jdGlvbiBwcmVwYXJlUG9wdWxhdGlvbk9wdGlvbnMocXVlcnksIG9wdGlvbnMpIHtcbiAgY29uc3QgX3BvcHVsYXRlID0gcXVlcnkub3B0aW9ucy5wb3B1bGF0ZTtcbiAgY29uc3QgcG9wID0gT2JqZWN0LmtleXMoX3BvcHVsYXRlKS5yZWR1Y2UoKHZhbHMsIGtleSkgPT4gdmFscy5jb25jYXQoW19wb3B1bGF0ZVtrZXldXSksIFtdKTtcblxuICAvLyBsZWFuIG9wdGlvbnMgc2hvdWxkIHRyaWNrbGUgdGhyb3VnaCBhbGwgcXVlcmllc1xuICBpZiAob3B0aW9ucy5sZWFuICE9IG51bGwpIHtcbiAgICBwb3BcbiAgICAgIC5maWx0ZXIocCA9PiAocCAmJiBwLm9wdGlvbnMgJiYgcC5vcHRpb25zLmxlYW4pID09IG51bGwpXG4gICAgICAuZm9yRWFjaChtYWtlTGVhbihvcHRpb25zLmxlYW4pKTtcbiAgfVxuXG4gIHBvcC5mb3JFYWNoKG9wdHMgPT4ge1xuICAgIG9wdHMuX2xvY2FsTW9kZWwgPSBxdWVyeS5tb2RlbDtcbiAgfSk7XG5cbiAgcmV0dXJuIHBvcDtcbn07XG5cbi8qKlxuICogUHJlcGFyZSBhIHNldCBvZiBwYXRoIG9wdGlvbnMgZm9yIHF1ZXJ5IHBvcHVsYXRpb24uIFRoaXMgaXMgdGhlIE1vbmdvb3NlUXVlcnlcbiAqIHZlcnNpb25cbiAqXG4gKiBAcGFyYW0ge1F1ZXJ5fSBxdWVyeVxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEByZXR1cm4ge0FycmF5fVxuICovXG5cbmV4cG9ydHMucHJlcGFyZVBvcHVsYXRpb25PcHRpb25zTVEgPSBmdW5jdGlvbiBwcmVwYXJlUG9wdWxhdGlvbk9wdGlvbnNNUShxdWVyeSwgb3B0aW9ucykge1xuICBjb25zdCBfcG9wdWxhdGUgPSBxdWVyeS5fbW9uZ29vc2VPcHRpb25zLnBvcHVsYXRlO1xuICBjb25zdCBwb3AgPSBPYmplY3Qua2V5cyhfcG9wdWxhdGUpLnJlZHVjZSgodmFscywga2V5KSA9PiB2YWxzLmNvbmNhdChbX3BvcHVsYXRlW2tleV1dKSwgW10pO1xuXG4gIC8vIGxlYW4gb3B0aW9ucyBzaG91bGQgdHJpY2tsZSB0aHJvdWdoIGFsbCBxdWVyaWVzXG4gIGlmIChvcHRpb25zLmxlYW4gIT0gbnVsbCkge1xuICAgIHBvcFxuICAgICAgLmZpbHRlcihwID0+IChwICYmIHAub3B0aW9ucyAmJiBwLm9wdGlvbnMubGVhbikgPT0gbnVsbClcbiAgICAgIC5mb3JFYWNoKG1ha2VMZWFuKG9wdGlvbnMubGVhbikpO1xuICB9XG5cbiAgY29uc3Qgc2Vzc2lvbiA9IHF1ZXJ5ICYmIHF1ZXJ5Lm9wdGlvbnMgJiYgcXVlcnkub3B0aW9ucy5zZXNzaW9uIHx8IG51bGw7XG4gIGlmIChzZXNzaW9uICE9IG51bGwpIHtcbiAgICBwb3AuZm9yRWFjaChwYXRoID0+IHtcbiAgICAgIGlmIChwYXRoLm9wdGlvbnMgPT0gbnVsbCkge1xuICAgICAgICBwYXRoLm9wdGlvbnMgPSB7IHNlc3Npb246IHNlc3Npb24gfTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKCEoJ3Nlc3Npb24nIGluIHBhdGgub3B0aW9ucykpIHtcbiAgICAgICAgcGF0aC5vcHRpb25zLnNlc3Npb24gPSBzZXNzaW9uO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgY29uc3QgcHJvamVjdGlvbiA9IHF1ZXJ5Ll9maWVsZHNGb3JFeGVjKCk7XG4gIHBvcC5mb3JFYWNoKHAgPT4ge1xuICAgIHAuX3F1ZXJ5UHJvamVjdGlvbiA9IHByb2plY3Rpb247XG4gIH0pO1xuICBwb3AuZm9yRWFjaChvcHRzID0+IHtcbiAgICBvcHRzLl9sb2NhbE1vZGVsID0gcXVlcnkubW9kZWw7XG4gIH0pO1xuXG4gIHJldHVybiBwb3A7XG59O1xuXG4vKipcbiAqIElmIHRoZSBkb2N1bWVudCBpcyBhIG1hcHBlZCBkaXNjcmltaW5hdG9yIHR5cGUsIGl0IHJldHVybnMgYSBtb2RlbCBpbnN0YW5jZSBmb3IgdGhhdCB0eXBlLCBvdGhlcndpc2UsXG4gKiBpdCByZXR1cm5zIGFuIGluc3RhbmNlIG9mIHRoZSBnaXZlbiBtb2RlbC5cbiAqXG4gKiBAcGFyYW0ge01vZGVsfSAgbW9kZWxcbiAqIEBwYXJhbSB7T2JqZWN0fSBkb2NcbiAqIEBwYXJhbSB7T2JqZWN0fSBmaWVsZHNcbiAqXG4gKiBAcmV0dXJuIHtEb2N1bWVudH1cbiAqL1xuZXhwb3J0cy5jcmVhdGVNb2RlbCA9IGZ1bmN0aW9uIGNyZWF0ZU1vZGVsKG1vZGVsLCBkb2MsIGZpZWxkcywgdXNlclByb3ZpZGVkRmllbGRzLCBvcHRpb25zKSB7XG4gIG1vZGVsLmhvb2tzLmV4ZWNQcmVTeW5jKCdjcmVhdGVNb2RlbCcsIGRvYyk7XG4gIGNvbnN0IGRpc2NyaW1pbmF0b3JNYXBwaW5nID0gbW9kZWwuc2NoZW1hID9cbiAgICBtb2RlbC5zY2hlbWEuZGlzY3JpbWluYXRvck1hcHBpbmcgOlxuICAgIG51bGw7XG5cbiAgY29uc3Qga2V5ID0gZGlzY3JpbWluYXRvck1hcHBpbmcgJiYgZGlzY3JpbWluYXRvck1hcHBpbmcuaXNSb290ID9cbiAgICBkaXNjcmltaW5hdG9yTWFwcGluZy5rZXkgOlxuICAgIG51bGw7XG5cbiAgY29uc3QgdmFsdWUgPSBkb2Nba2V5XTtcbiAgaWYgKGtleSAmJiB2YWx1ZSAmJiBtb2RlbC5kaXNjcmltaW5hdG9ycykge1xuICAgIGNvbnN0IGRpc2NyaW1pbmF0b3IgPSBtb2RlbC5kaXNjcmltaW5hdG9yc1t2YWx1ZV0gfHwgZ2V0RGlzY3JpbWluYXRvckJ5VmFsdWUobW9kZWwuZGlzY3JpbWluYXRvcnMsIHZhbHVlKTtcbiAgICBpZiAoZGlzY3JpbWluYXRvcikge1xuICAgICAgY29uc3QgX2ZpZWxkcyA9IGNsb25lKHVzZXJQcm92aWRlZEZpZWxkcyk7XG4gICAgICBleHBvcnRzLmFwcGx5UGF0aHMoX2ZpZWxkcywgZGlzY3JpbWluYXRvci5zY2hlbWEpO1xuICAgICAgcmV0dXJuIG5ldyBkaXNjcmltaW5hdG9yKHVuZGVmaW5lZCwgX2ZpZWxkcywgdHJ1ZSk7XG4gICAgfVxuICB9XG5cbiAgY29uc3QgX29wdHMgPSB7XG4gICAgc2tpcElkOiB0cnVlLFxuICAgIGlzTmV3OiBmYWxzZSxcbiAgICB3aWxsSW5pdDogdHJ1ZVxuICB9O1xuICBpZiAob3B0aW9ucyAhPSBudWxsICYmICdkZWZhdWx0cycgaW4gb3B0aW9ucykge1xuICAgIF9vcHRzLmRlZmF1bHRzID0gb3B0aW9ucy5kZWZhdWx0cztcbiAgfVxuICByZXR1cm4gbmV3IG1vZGVsKHVuZGVmaW5lZCwgZmllbGRzLCBfb3B0cyk7XG59O1xuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cbmV4cG9ydHMuY3JlYXRlTW9kZWxBbmRJbml0ID0gZnVuY3Rpb24gY3JlYXRlTW9kZWxBbmRJbml0KG1vZGVsLCBkb2MsIGZpZWxkcywgdXNlclByb3ZpZGVkRmllbGRzLCBvcHRpb25zLCBwb3B1bGF0ZWRJZHMsIGNhbGxiYWNrKSB7XG4gIGNvbnN0IGluaXRPcHRzID0gcG9wdWxhdGVkSWRzID9cbiAgICB7IHBvcHVsYXRlZDogcG9wdWxhdGVkSWRzIH0gOlxuICAgIHVuZGVmaW5lZDtcblxuICBjb25zdCBjYXN0ZWQgPSBleHBvcnRzLmNyZWF0ZU1vZGVsKG1vZGVsLCBkb2MsIGZpZWxkcywgdXNlclByb3ZpZGVkRmllbGRzLCBvcHRpb25zKTtcbiAgdHJ5IHtcbiAgICBjYXN0ZWQuJGluaXQoZG9jLCBpbml0T3B0cywgY2FsbGJhY2spO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNhbGxiYWNrKGVycm9yLCBjYXN0ZWQpO1xuICB9XG59O1xuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cbmV4cG9ydHMuYXBwbHlQYXRocyA9IGZ1bmN0aW9uIGFwcGx5UGF0aHMoZmllbGRzLCBzY2hlbWEpIHtcbiAgLy8gZGV0ZXJtaW5lIGlmIHF1ZXJ5IGlzIHNlbGVjdGluZyBvciBleGNsdWRpbmcgZmllbGRzXG4gIGxldCBleGNsdWRlO1xuICBsZXQga2V5cztcbiAgY29uc3QgbWludXNQYXRoc1RvU2tpcCA9IG5ldyBTZXQoKTtcblxuICBpZiAoZmllbGRzKSB7XG4gICAga2V5cyA9IE9iamVjdC5rZXlzKGZpZWxkcyk7XG5cbiAgICAvLyBDb2xsYXBzZSBtaW51cyBwYXRoc1xuICAgIGNvbnN0IG1pbnVzUGF0aHMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpIHtcbiAgICAgIGNvbnN0IGtleSA9IGtleXNbaV07XG4gICAgICBpZiAoa2V5c1tpXVswXSAhPT0gJy0nKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBkZWxldGUgZmllbGRzW2tleV07XG4gICAgICBpZiAoa2V5ID09PSAnLV9pZCcpIHtcbiAgICAgICAgZmllbGRzWydfaWQnXSA9IDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtaW51c1BhdGhzLnB1c2goa2V5LnNsaWNlKDEpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBrZXlzID0gT2JqZWN0LmtleXMoZmllbGRzKTtcbiAgICBmb3IgKGxldCBrZXlJbmRleCA9IDA7IGtleUluZGV4IDwga2V5cy5sZW5ndGg7ICsra2V5SW5kZXgpIHtcbiAgICAgIGlmIChrZXlzW2tleUluZGV4XVswXSA9PT0gJysnKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgY29uc3QgZmllbGQgPSBmaWVsZHNba2V5c1trZXlJbmRleF1dO1xuICAgICAgLy8gU2tpcCBgJG1ldGFgIGFuZCBgJHNsaWNlYFxuICAgICAgaWYgKCFpc0RlZmluaW5nUHJvamVjdGlvbihmaWVsZCkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAoa2V5c1trZXlJbmRleF0gPT09ICdfaWQnICYmIGtleXMubGVuZ3RoID4gMSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmIChrZXlzW2tleUluZGV4XSA9PT0gc2NoZW1hLm9wdGlvbnMuZGlzY3JpbWluYXRvcktleSAmJiBrZXlzLmxlbmd0aCA+IDEgJiYgZmllbGQgIT0gbnVsbCAmJiAhZmllbGQpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBleGNsdWRlID0gIWZpZWxkO1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgLy8gUG90ZW50aWFsbHkgYWRkIGJhY2sgbWludXMgcGF0aHMgYmFzZWQgb24gc2NoZW1hLWxldmVsIHBhdGggY29uZmlnXG4gICAgLy8gYW5kIHdoZXRoZXIgdGhlIHByb2plY3Rpb24gaXMgaW5jbHVzaXZlXG4gICAgZm9yIChjb25zdCBwYXRoIG9mIG1pbnVzUGF0aHMpIHtcbiAgICAgIGNvbnN0IHR5cGUgPSBzY2hlbWEucGF0aChwYXRoKTtcbiAgICAgIC8vIElmIHRoZSBwYXRoIGlzbid0IHNlbGVjdGVkIGJ5IGRlZmF1bHQgb3IgdGhlIHByb2plY3Rpb24gaXMgbm90XG4gICAgICAvLyBpbmNsdXNpdmUsIG1pbnVzIHBhdGggaXMgdHJlYXRlZCBhcyBlcXVpdmFsZW50IHRvIGBrZXk6IDBgLlxuICAgICAgLy8gQnV0IHdlIGFsc28gYWxsb3cgdXNpbmcgYC1uYW1lYCB0byByZW1vdmUgYG5hbWVgIGZyb20gYW4gaW5jbHVzaXZlXG4gICAgICAvLyBwcm9qZWN0aW9uIGlmIGBuYW1lYCBoYXMgc2NoZW1hLWxldmVsIGBzZWxlY3Q6IHRydWVgLlxuICAgICAgaWYgKCghdHlwZSB8fCAhdHlwZS5zZWxlY3RlZCkgfHwgZXhjbHVkZSAhPT0gZmFsc2UpIHtcbiAgICAgICAgZmllbGRzW3BhdGhdID0gMDtcbiAgICAgICAgZXhjbHVkZSA9IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgJiYgdHlwZS5zZWxlY3RlZCAmJiBleGNsdWRlID09PSBmYWxzZSkge1xuICAgICAgICAvLyBNYWtlIGEgbm90ZSBvZiBtaW51cyBwYXRocyB0aGF0IGFyZSBvdmVyd3JpdGluZyBwYXRocyB0aGF0IGFyZVxuICAgICAgICAvLyBpbmNsdWRlZCBieSBkZWZhdWx0LlxuICAgICAgICBtaW51c1BhdGhzVG9Ta2lwLmFkZChwYXRoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBpZiBzZWxlY3RpbmcsIGFwcGx5IGRlZmF1bHQgc2NoZW1hdHlwZSBzZWxlY3Q6dHJ1ZSBmaWVsZHNcbiAgLy8gaWYgZXhjbHVkaW5nLCBhcHBseSBzY2hlbWF0eXBlIHNlbGVjdDpmYWxzZSBmaWVsZHNcbiAgY29uc3Qgc2VsZWN0ZWQgPSBbXTtcbiAgY29uc3QgZXhjbHVkZWQgPSBbXTtcbiAgY29uc3Qgc3RhY2sgPSBbXTtcblxuICBhbmFseXplU2NoZW1hKHNjaGVtYSk7XG4gIHN3aXRjaCAoZXhjbHVkZSkge1xuICAgIGNhc2UgdHJ1ZTpcbiAgICAgIGZvciAoY29uc3QgZmllbGROYW1lIG9mIGV4Y2x1ZGVkKSB7XG4gICAgICAgIGZpZWxkc1tmaWVsZE5hbWVdID0gMDtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgZmFsc2U6XG4gICAgICBpZiAoc2NoZW1hICYmXG4gICAgICAgICAgc2NoZW1hLnBhdGhzWydfaWQnXSAmJlxuICAgICAgICAgIHNjaGVtYS5wYXRoc1snX2lkJ10ub3B0aW9ucyAmJlxuICAgICAgICAgIHNjaGVtYS5wYXRoc1snX2lkJ10ub3B0aW9ucy5zZWxlY3QgPT09IGZhbHNlKSB7XG4gICAgICAgIGZpZWxkcy5faWQgPSAwO1xuICAgICAgfVxuXG4gICAgICBmb3IgKGNvbnN0IGZpZWxkTmFtZSBvZiBzZWxlY3RlZCkge1xuICAgICAgICBpZiAobWludXNQYXRoc1RvU2tpcC5oYXMoZmllbGROYW1lKSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc1BhdGhTZWxlY3RlZEluY2x1c2l2ZShmaWVsZHMsIGZpZWxkTmFtZSkpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBmaWVsZHNbZmllbGROYW1lXSA9IGZpZWxkc1tmaWVsZE5hbWVdIHx8IDE7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBjYXNlIHVuZGVmaW5lZDpcbiAgICAgIGlmIChmaWVsZHMgPT0gbnVsbCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIC8vIEFueSBsZWZ0b3ZlciBwbHVzIHBhdGhzIG11c3QgaW4gdGhlIHNjaGVtYSwgc28gZGVsZXRlIHRoZW0gKGdoLTcwMTcpXG4gICAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhmaWVsZHMgfHwge30pKSB7XG4gICAgICAgIGlmIChrZXkuc3RhcnRzV2l0aCgnKycpKSB7XG4gICAgICAgICAgZGVsZXRlIGZpZWxkc1trZXldO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIHVzZXIgZGlkbid0IHNwZWNpZnkgZmllbGRzLCBpbXBsaWVzIHJldHVybmluZyBhbGwgZmllbGRzLlxuICAgICAgLy8gb25seSBuZWVkIHRvIGFwcGx5IGV4Y2x1ZGVkIGZpZWxkcyBhbmQgZGVsZXRlIGFueSBwbHVzIHBhdGhzXG4gICAgICBmb3IgKGNvbnN0IGZpZWxkTmFtZSBvZiBleGNsdWRlZCkge1xuICAgICAgICBpZiAoZmllbGRzW2ZpZWxkTmFtZV0gIT0gbnVsbCkge1xuICAgICAgICAgIC8vIFNraXAgYXBwbHlpbmcgZGVmYXVsdCBwcm9qZWN0aW9ucyB0byBmaWVsZHMgd2l0aCBub24tZGVmaW5pbmdcbiAgICAgICAgICAvLyBwcm9qZWN0aW9ucywgbGlrZSBgJHNsaWNlYFxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGZpZWxkc1tmaWVsZE5hbWVdID0gMDtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICB9XG5cbiAgZnVuY3Rpb24gYW5hbHl6ZVNjaGVtYShzY2hlbWEsIHByZWZpeCkge1xuICAgIHByZWZpeCB8fCAocHJlZml4ID0gJycpO1xuXG4gICAgLy8gYXZvaWQgcmVjdXJzaW9uXG4gICAgaWYgKHN0YWNrLmluZGV4T2Yoc2NoZW1hKSAhPT0gLTEpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgc3RhY2sucHVzaChzY2hlbWEpO1xuXG4gICAgY29uc3QgYWRkZWRQYXRocyA9IFtdO1xuICAgIHNjaGVtYS5lYWNoUGF0aChmdW5jdGlvbihwYXRoLCB0eXBlKSB7XG4gICAgICBpZiAocHJlZml4KSBwYXRoID0gcHJlZml4ICsgJy4nICsgcGF0aDtcbiAgICAgIGlmICh0eXBlLiRpc1NjaGVtYU1hcCB8fCBwYXRoLmVuZHNXaXRoKCcuJConKSkge1xuICAgICAgICBjb25zdCBwbHVzUGF0aCA9ICcrJyArIHBhdGg7XG4gICAgICAgIGNvbnN0IGhhc1BsdXNQYXRoID0gZmllbGRzICYmIHBsdXNQYXRoIGluIGZpZWxkcztcbiAgICAgICAgaWYgKHR5cGUub3B0aW9ucyAmJiB0eXBlLm9wdGlvbnMuc2VsZWN0ID09PSBmYWxzZSAmJiAhaGFzUGx1c1BhdGgpIHtcbiAgICAgICAgICBleGNsdWRlZC5wdXNoKHBhdGgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGxldCBhZGRlZFBhdGggPSBhbmFseXplUGF0aChwYXRoLCB0eXBlKTtcbiAgICAgIC8vIGFycmF5c1xuICAgICAgaWYgKGFkZGVkUGF0aCA9PSBudWxsICYmICFBcnJheS5pc0FycmF5KHR5cGUpICYmIHR5cGUuJGlzTW9uZ29vc2VBcnJheSAmJiAhdHlwZS4kaXNNb25nb29zZURvY3VtZW50QXJyYXkpIHtcbiAgICAgICAgYWRkZWRQYXRoID0gYW5hbHl6ZVBhdGgocGF0aCwgdHlwZS5jYXN0ZXIpO1xuICAgICAgfVxuICAgICAgaWYgKGFkZGVkUGF0aCAhPSBudWxsKSB7XG4gICAgICAgIGFkZGVkUGF0aHMucHVzaChhZGRlZFBhdGgpO1xuICAgICAgfVxuXG4gICAgICAvLyBuZXN0ZWQgc2NoZW1hc1xuICAgICAgaWYgKHR5cGUuc2NoZW1hKSB7XG4gICAgICAgIGNvbnN0IF9hZGRlZFBhdGhzID0gYW5hbHl6ZVNjaGVtYSh0eXBlLnNjaGVtYSwgcGF0aCk7XG5cbiAgICAgICAgLy8gU3BlY2lhbCBjYXNlOiBpZiBkaXNjcmltaW5hdG9yIGtleSBpcyB0aGUgb25seSBmaWVsZCB0aGF0IHdvdWxkXG4gICAgICAgIC8vIGJlIHByb2plY3RlZCBpbiwgcmVtb3ZlIGl0LlxuICAgICAgICBpZiAoZXhjbHVkZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICBjaGVja0VtYmVkZGVkRGlzY3JpbWluYXRvcktleVByb2plY3Rpb24oZmllbGRzLCBwYXRoLCB0eXBlLnNjaGVtYSxcbiAgICAgICAgICAgIHNlbGVjdGVkLCBfYWRkZWRQYXRocyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgICBzdGFjay5wb3AoKTtcbiAgICByZXR1cm4gYWRkZWRQYXRocztcbiAgfVxuXG4gIGZ1bmN0aW9uIGFuYWx5emVQYXRoKHBhdGgsIHR5cGUpIHtcbiAgICBpZiAoZmllbGRzID09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBJZiBzY2hlbWEtbGV2ZWwgc2VsZWN0ZWQgbm90IHNldCwgbm90aGluZyB0byBkb1xuICAgIGlmICh0eXBlb2YgdHlwZS5zZWxlY3RlZCAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gVXNlciBvdmVyd3JpdGluZyBkZWZhdWx0IGV4Y2x1c2lvblxuICAgIGlmICh0eXBlLnNlbGVjdGVkID09PSBmYWxzZSAmJiBmaWVsZHNbcGF0aF0pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBJZiBzZXQgdG8gMCwgd2UncmUgZXhwbGljaXRseSBleGNsdWRpbmcgdGhlIGRpc2NyaW1pbmF0b3Iga2V5LiBDYW4ndCBkbyB0aGlzIGZvciBhbGwgZmllbGRzLFxuICAgIC8vIGJlY2F1c2Ugd2UgaGF2ZSB0ZXN0cyB0aGF0IGFzc2VydCB0aGF0IHVzaW5nIGAtcGF0aGAgdG8gZXhjbHVkZSBzY2hlbWEtbGV2ZWwgYHNlbGVjdDogdHJ1ZWBcbiAgICAvLyBmaWVsZHMgY291bnRzIGFzIGFuIGV4Y2x1c2l2ZSBwcm9qZWN0aW9uLiBTZWUgZ2gtMTE1NDZcbiAgICBpZiAoIWV4Y2x1ZGUgJiYgdHlwZS5zZWxlY3RlZCAmJiBwYXRoID09PSBzY2hlbWEub3B0aW9ucy5kaXNjcmltaW5hdG9yS2V5ICYmIGZpZWxkc1twYXRoXSAhPSBudWxsICYmICFmaWVsZHNbcGF0aF0pIHtcbiAgICAgIGRlbGV0ZSBmaWVsZHNbcGF0aF07XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGV4Y2x1ZGUgPT09IGZhbHNlICYmIHR5cGUuc2VsZWN0ZWQgJiYgZmllbGRzW3BhdGhdICE9IG51bGwgJiYgIWZpZWxkc1twYXRoXSkge1xuICAgICAgZGVsZXRlIGZpZWxkc1twYXRoXTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBwbHVzUGF0aCA9ICcrJyArIHBhdGg7XG4gICAgY29uc3QgaGFzUGx1c1BhdGggPSBmaWVsZHMgJiYgcGx1c1BhdGggaW4gZmllbGRzO1xuICAgIGlmIChoYXNQbHVzUGF0aCkge1xuICAgICAgLy8gZm9yY2VkIGluY2x1c2lvblxuICAgICAgZGVsZXRlIGZpZWxkc1twbHVzUGF0aF07XG5cbiAgICAgIC8vIGlmIHRoZXJlIGFyZSBvdGhlciBmaWVsZHMgYmVpbmcgaW5jbHVkZWQsIGFkZCB0aGlzIG9uZVxuICAgICAgLy8gaWYgbm8gb3RoZXIgaW5jbHVkZWQgZmllbGRzLCBsZWF2ZSB0aGlzIG91dCAoaW1wbGllZCBpbmNsdXNpb24pXG4gICAgICBpZiAoZXhjbHVkZSA9PT0gZmFsc2UgJiYga2V5cy5sZW5ndGggPiAxICYmICF+a2V5cy5pbmRleE9mKHBhdGgpKSB7XG4gICAgICAgIGZpZWxkc1twYXRoXSA9IDE7XG4gICAgICB9XG5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBjaGVjayBmb3IgcGFyZW50IGV4Y2x1c2lvbnNcbiAgICBjb25zdCBwaWVjZXMgPSBwYXRoLnNwbGl0KCcuJyk7XG4gICAgbGV0IGN1ciA9ICcnO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGllY2VzLmxlbmd0aDsgKytpKSB7XG4gICAgICBjdXIgKz0gY3VyLmxlbmd0aCA/ICcuJyArIHBpZWNlc1tpXSA6IHBpZWNlc1tpXTtcbiAgICAgIGlmIChleGNsdWRlZC5pbmRleE9mKGN1cikgIT09IC0xKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBTcGVjaWFsIGNhc2U6IGlmIHVzZXIgaGFzIGluY2x1ZGVkIGEgcGFyZW50IHBhdGggb2YgYSBkaXNjcmltaW5hdG9yIGtleSxcbiAgICAvLyBkb24ndCBleHBsaWNpdGx5IHByb2plY3QgaW4gdGhlIGRpc2NyaW1pbmF0b3Iga2V5IGJlY2F1c2UgdGhhdCB3aWxsXG4gICAgLy8gcHJvamVjdCBvdXQgZXZlcnl0aGluZyBlbHNlIHVuZGVyIHRoZSBwYXJlbnQgcGF0aFxuICAgIGlmICghZXhjbHVkZSAmJiAodHlwZSAmJiB0eXBlLm9wdGlvbnMgJiYgdHlwZS5vcHRpb25zLiRza2lwRGlzY3JpbWluYXRvckNoZWNrIHx8IGZhbHNlKSkge1xuICAgICAgbGV0IGN1ciA9ICcnO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwaWVjZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgY3VyICs9IChjdXIubGVuZ3RoID09PSAwID8gJycgOiAnLicpICsgcGllY2VzW2ldO1xuICAgICAgICBjb25zdCBwcm9qZWN0aW9uID0gZ2V0KGZpZWxkcywgY3VyLCBmYWxzZSkgfHwgZ2V0KGZpZWxkcywgY3VyICsgJy4kJywgZmFsc2UpO1xuICAgICAgICBpZiAocHJvamVjdGlvbiAmJiB0eXBlb2YgcHJvamVjdGlvbiAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAodHlwZS5zZWxlY3RlZCA/IHNlbGVjdGVkIDogZXhjbHVkZWQpLnB1c2gocGF0aCk7XG4gICAgcmV0dXJuIHBhdGg7XG4gIH1cbn07XG5cbi8qKlxuICogU2V0IGVhY2ggcGF0aCBxdWVyeSBvcHRpb24gdG8gbGVhblxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25cbiAqL1xuXG5mdW5jdGlvbiBtYWtlTGVhbih2YWwpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKG9wdGlvbikge1xuICAgIG9wdGlvbi5vcHRpb25zIHx8IChvcHRpb24ub3B0aW9ucyA9IHt9KTtcblxuICAgIGlmICh2YWwgIT0gbnVsbCAmJiBBcnJheS5pc0FycmF5KHZhbC52aXJ0dWFscykpIHtcbiAgICAgIHZhbCA9IE9iamVjdC5hc3NpZ24oe30sIHZhbCk7XG4gICAgICB2YWwudmlydHVhbHMgPSB2YWwudmlydHVhbHMuXG4gICAgICAgIGZpbHRlcihwYXRoID0+IHR5cGVvZiBwYXRoID09PSAnc3RyaW5nJyAmJiBwYXRoLnN0YXJ0c1dpdGgob3B0aW9uLnBhdGggKyAnLicpKS5cbiAgICAgICAgbWFwKHBhdGggPT4gcGF0aC5zbGljZShvcHRpb24ucGF0aC5sZW5ndGggKyAxKSk7XG4gICAgfVxuXG4gICAgb3B0aW9uLm9wdGlvbnMubGVhbiA9IHZhbDtcbiAgfTtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../server/node_modules/mongoose/lib/queryHelpers.js\n");

/***/ }),

/***/ "../server/node_modules/mongoose/lib/schema.js":
/*!*****************************************************!*\
  !*** ../server/node_modules/mongoose/lib/schema.js ***!
  \*****************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("\n\n/*!\n * Module dependencies.\n */\n\nconst EventEmitter = (__webpack_require__(/*! events */ \"events\").EventEmitter);\nconst Kareem = __webpack_require__(/*! kareem */ \"../server/node_modules/kareem/index.js\");\nconst MongooseError = __webpack_require__(/*! ./error/mongooseError */ \"../server/node_modules/mongoose/lib/error/mongooseError.js\");\nconst SchemaType = __webpack_require__(/*! ./schemaType */ \"../server/node_modules/mongoose/lib/schemaType.js\");\nconst SchemaTypeOptions = __webpack_require__(/*! ./options/schemaTypeOptions */ \"../server/node_modules/mongoose/lib/options/schemaTypeOptions.js\");\nconst VirtualOptions = __webpack_require__(/*! ./options/virtualOptions */ \"../server/node_modules/mongoose/lib/options/virtualOptions.js\");\nconst VirtualType = __webpack_require__(/*! ./virtualType */ \"../server/node_modules/mongoose/lib/virtualType.js\");\nconst addAutoId = __webpack_require__(/*! ./helpers/schema/addAutoId */ \"../server/node_modules/mongoose/lib/helpers/schema/addAutoId.js\");\nconst clone = __webpack_require__(/*! ./helpers/clone */ \"../server/node_modules/mongoose/lib/helpers/clone.js\");\nconst get = __webpack_require__(/*! ./helpers/get */ \"../server/node_modules/mongoose/lib/helpers/get.js\");\nconst getConstructorName = __webpack_require__(/*! ./helpers/getConstructorName */ \"../server/node_modules/mongoose/lib/helpers/getConstructorName.js\");\nconst getIndexes = __webpack_require__(/*! ./helpers/schema/getIndexes */ \"../server/node_modules/mongoose/lib/helpers/schema/getIndexes.js\");\nconst handleReadPreferenceAliases = __webpack_require__(/*! ./helpers/query/handleReadPreferenceAliases */ \"../server/node_modules/mongoose/lib/helpers/query/handleReadPreferenceAliases.js\");\nconst idGetter = __webpack_require__(/*! ./helpers/schema/idGetter */ \"../server/node_modules/mongoose/lib/helpers/schema/idGetter.js\");\nconst merge = __webpack_require__(/*! ./helpers/schema/merge */ \"../server/node_modules/mongoose/lib/helpers/schema/merge.js\");\nconst mpath = __webpack_require__(/*! mpath */ \"../server/node_modules/mpath/index.js\");\nconst setPopulatedVirtualValue = __webpack_require__(/*! ./helpers/populate/setPopulatedVirtualValue */ \"../server/node_modules/mongoose/lib/helpers/populate/setPopulatedVirtualValue.js\");\nconst setupTimestamps = __webpack_require__(/*! ./helpers/timestamps/setupTimestamps */ \"../server/node_modules/mongoose/lib/helpers/timestamps/setupTimestamps.js\");\nconst utils = __webpack_require__(/*! ./utils */ \"../server/node_modules/mongoose/lib/utils.js\");\nconst validateRef = __webpack_require__(/*! ./helpers/populate/validateRef */ \"../server/node_modules/mongoose/lib/helpers/populate/validateRef.js\");\nconst util = __webpack_require__(/*! util */ \"util\");\n\nconst hasNumericSubpathRegex = /\\.\\d+(\\.|$)/;\n\nlet MongooseTypes;\n\nconst queryHooks = (__webpack_require__(/*! ./constants */ \"../server/node_modules/mongoose/lib/constants.js\").queryMiddlewareFunctions);\nconst documentHooks = (__webpack_require__(/*! ./helpers/model/applyHooks */ \"../server/node_modules/mongoose/lib/helpers/model/applyHooks.js\").middlewareFunctions);\nconst hookNames = queryHooks.concat(documentHooks).\n  reduce((s, hook) => s.add(hook), new Set());\n\nconst isPOJO = utils.isPOJO;\n\nlet id = 0;\n\nconst numberRE = /^\\d+$/;\n\n/**\n * Schema constructor.\n *\n * #### Example:\n *\n *     const child = new Schema({ name: String });\n *     const schema = new Schema({ name: String, age: Number, children: [child] });\n *     const Tree = mongoose.model('Tree', schema);\n *\n *     // setting schema options\n *     new Schema({ name: String }, { id: false, autoIndex: false })\n *\n * #### Options:\n *\n * - [autoIndex](https://mongoosejs.com/docs/guide.html#autoIndex): bool - defaults to null (which means use the connection's autoIndex option)\n * - [autoCreate](https://mongoosejs.com/docs/guide.html#autoCreate): bool - defaults to null (which means use the connection's autoCreate option)\n * - [bufferCommands](https://mongoosejs.com/docs/guide.html#bufferCommands): bool - defaults to true\n * - [bufferTimeoutMS](https://mongoosejs.com/docs/guide.html#bufferTimeoutMS): number - defaults to 10000 (10 seconds). If `bufferCommands` is enabled, the amount of time Mongoose will wait for connectivity to be restablished before erroring out.\n * - [capped](https://mongoosejs.com/docs/guide.html#capped): bool | number | object - defaults to false\n * - [collection](https://mongoosejs.com/docs/guide.html#collection): string - no default\n * - [discriminatorKey](https://mongoosejs.com/docs/guide.html#discriminatorKey): string - defaults to `__t`\n * - [id](https://mongoosejs.com/docs/guide.html#id): bool - defaults to true\n * - [_id](https://mongoosejs.com/docs/guide.html#_id): bool - defaults to true\n * - [minimize](https://mongoosejs.com/docs/guide.html#minimize): bool - controls [document#toObject](https://mongoosejs.com/docs/api/document.html#Document.prototype.toObject()) behavior when called manually - defaults to true\n * - [read](https://mongoosejs.com/docs/guide.html#read): string\n * - [writeConcern](https://mongoosejs.com/docs/guide.html#writeConcern): object - defaults to null, use to override [the MongoDB server's default write concern settings](https://www.mongodb.com/docs/manual/reference/write-concern/)\n * - [shardKey](https://mongoosejs.com/docs/guide.html#shardKey): object - defaults to `null`\n * - [strict](https://mongoosejs.com/docs/guide.html#strict): bool - defaults to true\n * - [strictQuery](https://mongoosejs.com/docs/guide.html#strictQuery): bool - defaults to false\n * - [toJSON](https://mongoosejs.com/docs/guide.html#toJSON) - object - no default\n * - [toObject](https://mongoosejs.com/docs/guide.html#toObject) - object - no default\n * - [typeKey](https://mongoosejs.com/docs/guide.html#typeKey) - string - defaults to 'type'\n * - [validateBeforeSave](https://mongoosejs.com/docs/guide.html#validateBeforeSave) - bool - defaults to `true`\n * - [validateModifiedOnly](https://mongoosejs.com/docs/api/document.html#Document.prototype.validate()) - bool - defaults to `false`\n * - [versionKey](https://mongoosejs.com/docs/guide.html#versionKey): string or object - defaults to \"__v\"\n * - [optimisticConcurrency](https://mongoosejs.com/docs/guide.html#optimisticConcurrency): bool - defaults to false. Set to true to enable [optimistic concurrency](https://thecodebarbarian.com/whats-new-in-mongoose-5-10-optimistic-concurrency.html).\n * - [collation](https://mongoosejs.com/docs/guide.html#collation): object - defaults to null (which means use no collation)\n * - [timeseries](https://mongoosejs.com/docs/guide.html#timeseries): object - defaults to null (which means this schema's collection won't be a timeseries collection)\n * - [selectPopulatedPaths](https://mongoosejs.com/docs/guide.html#selectPopulatedPaths): boolean - defaults to `true`\n * - [skipVersioning](https://mongoosejs.com/docs/guide.html#skipVersioning): object - paths to exclude from versioning\n * - [timestamps](https://mongoosejs.com/docs/guide.html#timestamps): object or boolean - defaults to `false`. If true, Mongoose adds `createdAt` and `updatedAt` properties to your schema and manages those properties for you.\n * - [pluginTags](https://mongoosejs.com/docs/guide.html#pluginTags): array of strings - defaults to `undefined`. If set and plugin called with `tags` option, will only apply that plugin to schemas with a matching tag.\n * - [virtuals](https://mongoosejs.com/docs/tutorials/virtuals.html#virtuals-via-schema-options): object - virtuals to define, alias for [`.virtual`](https://mongoosejs.com/docs/api/schema.html#Schema.prototype.virtual())\n * - [collectionOptions]: object with options passed to [`createCollection()`](https://www.mongodb.com/docs/manual/reference/method/db.createCollection/) when calling `Model.createCollection()` or `autoCreate` set to true.\n *\n * #### Options for Nested Schemas:\n *\n * - `excludeIndexes`: bool - defaults to `false`. If `true`, skip building indexes on this schema's paths.\n *\n * #### Note:\n *\n * _When nesting schemas, (`children` in the example above), always declare the child schema first before passing it into its parent._\n *\n * @param {Object|Schema|Array} [definition] Can be one of: object describing schema paths, or schema to copy, or array of objects and schemas\n * @param {Object} [options]\n * @inherits NodeJS EventEmitter https://nodejs.org/api/events.html#class-eventemitter\n * @event `init`: Emitted after the schema is compiled into a `Model`.\n * @api public\n */\n\nfunction Schema(obj, options) {\n  if (!(this instanceof Schema)) {\n    return new Schema(obj, options);\n  }\n\n  this.obj = obj;\n  this.paths = {};\n  this.aliases = {};\n  this.subpaths = {};\n  this.virtuals = {};\n  this.singleNestedPaths = {};\n  this.nested = {};\n  this.inherits = {};\n  this.callQueue = [];\n  this._indexes = [];\n  this._searchIndexes = [];\n  this.methods = (options && options.methods) || {};\n  this.methodOptions = {};\n  this.statics = (options && options.statics) || {};\n  this.tree = {};\n  this.query = (options && options.query) || {};\n  this.childSchemas = [];\n  this.plugins = [];\n  // For internal debugging. Do not use this to try to save a schema in MDB.\n  this.$id = ++id;\n  this.mapPaths = [];\n\n  this.s = {\n    hooks: new Kareem()\n  };\n  this.options = this.defaultOptions(options);\n\n  // build paths\n  if (Array.isArray(obj)) {\n    for (const definition of obj) {\n      this.add(definition);\n    }\n  } else if (obj) {\n    this.add(obj);\n  }\n\n  // build virtual paths\n  if (options && options.virtuals) {\n    const virtuals = options.virtuals;\n    const pathNames = Object.keys(virtuals);\n    for (const pathName of pathNames) {\n      const pathOptions = virtuals[pathName].options ? virtuals[pathName].options : undefined;\n      const virtual = this.virtual(pathName, pathOptions);\n\n      if (virtuals[pathName].get) {\n        virtual.get(virtuals[pathName].get);\n      }\n\n      if (virtuals[pathName].set) {\n        virtual.set(virtuals[pathName].set);\n      }\n    }\n  }\n\n  // check if _id's value is a subdocument (gh-2276)\n  const _idSubDoc = obj && obj._id && utils.isObject(obj._id);\n\n  // ensure the documents get an auto _id unless disabled\n  const auto_id = !this.paths['_id'] &&\n      (this.options._id) && !_idSubDoc;\n\n  if (auto_id) {\n    addAutoId(this);\n  }\n\n  this.setupTimestamp(this.options.timestamps);\n}\n\n/**\n * Create virtual properties with alias field\n * @api private\n */\nfunction aliasFields(schema, paths) {\n  for (const path of Object.keys(paths)) {\n    let alias = null;\n    if (paths[path] != null) {\n      alias = paths[path];\n    } else {\n      const options = get(schema.paths[path], 'options');\n      if (options == null) {\n        continue;\n      }\n\n      alias = options.alias;\n    }\n\n    if (!alias) {\n      continue;\n    }\n\n    const prop = schema.paths[path].path;\n    if (Array.isArray(alias)) {\n      for (const a of alias) {\n        if (typeof a !== 'string') {\n          throw new Error('Invalid value for alias option on ' + prop + ', got ' + a);\n        }\n\n        schema.aliases[a] = prop;\n\n        schema.\n          virtual(a).\n          get((function(p) {\n            return function() {\n              if (typeof this.get === 'function') {\n                return this.get(p);\n              }\n              return this[p];\n            };\n          })(prop)).\n          set((function(p) {\n            return function(v) {\n              return this.$set(p, v);\n            };\n          })(prop));\n      }\n\n      continue;\n    }\n\n    if (typeof alias !== 'string') {\n      throw new Error('Invalid value for alias option on ' + prop + ', got ' + alias);\n    }\n\n    schema.aliases[alias] = prop;\n\n    schema.\n      virtual(alias).\n      get((function(p) {\n        return function() {\n          if (typeof this.get === 'function') {\n            return this.get(p);\n          }\n          return this[p];\n        };\n      })(prop)).\n      set((function(p) {\n        return function(v) {\n          return this.$set(p, v);\n        };\n      })(prop));\n  }\n}\n\n/*!\n * Inherit from EventEmitter.\n */\nSchema.prototype = Object.create(EventEmitter.prototype);\nSchema.prototype.constructor = Schema;\nSchema.prototype.instanceOfSchema = true;\n\n/*!\n * ignore\n */\n\nObject.defineProperty(Schema.prototype, '$schemaType', {\n  configurable: false,\n  enumerable: false,\n  writable: true\n});\n\n/**\n * Array of child schemas (from document arrays and single nested subdocs)\n * and their corresponding compiled models. Each element of the array is\n * an object with 2 properties: `schema` and `model`.\n *\n * This property is typically only useful for plugin authors and advanced users.\n * You do not need to interact with this property at all to use mongoose.\n *\n * @api public\n * @property childSchemas\n * @memberOf Schema\n * @instance\n */\n\nObject.defineProperty(Schema.prototype, 'childSchemas', {\n  configurable: false,\n  enumerable: true,\n  writable: true\n});\n\n/**\n * Object containing all virtuals defined on this schema.\n * The objects' keys are the virtual paths and values are instances of `VirtualType`.\n *\n * This property is typically only useful for plugin authors and advanced users.\n * You do not need to interact with this property at all to use mongoose.\n *\n * #### Example:\n *\n *     const schema = new Schema({});\n *     schema.virtual('answer').get(() => 42);\n *\n *     console.log(schema.virtuals); // { answer: VirtualType { path: 'answer', ... } }\n *     console.log(schema.virtuals['answer'].getters[0].call()); // 42\n *\n * @api public\n * @property virtuals\n * @memberOf Schema\n * @instance\n */\n\nObject.defineProperty(Schema.prototype, 'virtuals', {\n  configurable: false,\n  enumerable: true,\n  writable: true\n});\n\n/**\n * The original object passed to the schema constructor\n *\n * #### Example:\n *\n *     const schema = new Schema({ a: String }).add({ b: String });\n *     schema.obj; // { a: String }\n *\n * @api public\n * @property obj\n * @memberOf Schema\n * @instance\n */\n\nSchema.prototype.obj;\n\n/**\n * The paths defined on this schema. The keys are the top-level paths\n * in this schema, and the values are instances of the SchemaType class.\n *\n * #### Example:\n *\n *     const schema = new Schema({ name: String }, { _id: false });\n *     schema.paths; // { name: SchemaString { ... } }\n *\n *     schema.add({ age: Number });\n *     schema.paths; // { name: SchemaString { ... }, age: SchemaNumber { ... } }\n *\n * @api public\n * @property paths\n * @memberOf Schema\n * @instance\n */\n\nSchema.prototype.paths;\n\n/**\n * Schema as a tree\n *\n * #### Example:\n *\n *     {\n *         '_id'     : ObjectId\n *       , 'nested'  : {\n *             'key' : String\n *         }\n *     }\n *\n * @api private\n * @property tree\n * @memberOf Schema\n * @instance\n */\n\nSchema.prototype.tree;\n\n/**\n * Returns a deep copy of the schema\n *\n * #### Example:\n *\n *     const schema = new Schema({ name: String });\n *     const clone = schema.clone();\n *     clone === schema; // false\n *     clone.path('name'); // SchemaString { ... }\n *\n * @return {Schema} the cloned schema\n * @api public\n * @memberOf Schema\n * @instance\n */\n\nSchema.prototype.clone = function() {\n  const s = this._clone();\n\n  // Bubble up `init` for backwards compat\n  s.on('init', v => this.emit('init', v));\n\n  return s;\n};\n\n/*!\n * ignore\n */\n\nSchema.prototype._clone = function _clone(Constructor) {\n  Constructor = Constructor || (this.base == null ? Schema : this.base.Schema);\n\n  const s = new Constructor({}, this._userProvidedOptions);\n  s.base = this.base;\n  s.obj = this.obj;\n  s.options = clone(this.options);\n  s.callQueue = this.callQueue.map(function(f) { return f; });\n  s.methods = clone(this.methods);\n  s.methodOptions = clone(this.methodOptions);\n  s.statics = clone(this.statics);\n  s.query = clone(this.query);\n  s.plugins = Array.prototype.slice.call(this.plugins);\n  s._indexes = clone(this._indexes);\n  s._searchIndexes = clone(this._searchIndexes);\n  s.s.hooks = this.s.hooks.clone();\n\n  s.tree = clone(this.tree);\n  s.paths = Object.fromEntries(\n    Object.entries(this.paths).map(([key, value]) => ([key, value.clone()]))\n  );\n  s.nested = clone(this.nested);\n  s.subpaths = clone(this.subpaths);\n  for (const schemaType of Object.values(s.paths)) {\n    if (schemaType.$isSingleNested) {\n      const path = schemaType.path;\n      for (const key of Object.keys(schemaType.schema.paths)) {\n        s.singleNestedPaths[path + '.' + key] = schemaType.schema.paths[key];\n      }\n      for (const key of Object.keys(schemaType.schema.singleNestedPaths)) {\n        s.singleNestedPaths[path + '.' + key] =\n          schemaType.schema.singleNestedPaths[key];\n      }\n      for (const key of Object.keys(schemaType.schema.subpaths)) {\n        s.singleNestedPaths[path + '.' + key] =\n          schemaType.schema.subpaths[key];\n      }\n      for (const key of Object.keys(schemaType.schema.nested)) {\n        s.singleNestedPaths[path + '.' + key] = 'nested';\n      }\n    }\n  }\n  s.childSchemas = gatherChildSchemas(s);\n\n  s.virtuals = clone(this.virtuals);\n  s.$globalPluginsApplied = this.$globalPluginsApplied;\n  s.$isRootDiscriminator = this.$isRootDiscriminator;\n  s.$implicitlyCreated = this.$implicitlyCreated;\n  s.$id = ++id;\n  s.$originalSchemaId = this.$id;\n  s.mapPaths = [].concat(this.mapPaths);\n\n  if (this.discriminatorMapping != null) {\n    s.discriminatorMapping = Object.assign({}, this.discriminatorMapping);\n  }\n  if (this.discriminators != null) {\n    s.discriminators = Object.assign({}, this.discriminators);\n  }\n  if (this._applyDiscriminators != null) {\n    s._applyDiscriminators = new Map(this._applyDiscriminators);\n  }\n\n  s.aliases = Object.assign({}, this.aliases);\n\n  return s;\n};\n\n/**\n * Returns a new schema that has the picked `paths` from this schema.\n *\n * This method is analagous to [Lodash's `pick()` function](https://lodash.com/docs/4.17.15#pick) for Mongoose schemas.\n *\n * #### Example:\n *\n *     const schema = Schema({ name: String, age: Number });\n *     // Creates a new schema with the same `name` path as `schema`,\n *     // but no `age` path.\n *     const newSchema = schema.pick(['name']);\n *\n *     newSchema.path('name'); // SchemaString { ... }\n *     newSchema.path('age'); // undefined\n *\n * @param {String[]} paths List of Paths to pick for the new Schema\n * @param {Object} [options] Options to pass to the new Schema Constructor (same as `new Schema(.., Options)`). Defaults to `this.options` if not set.\n * @return {Schema}\n * @api public\n */\n\nSchema.prototype.pick = function(paths, options) {\n  const newSchema = new Schema({}, options || this.options);\n  if (!Array.isArray(paths)) {\n    throw new MongooseError('Schema#pick() only accepts an array argument, ' +\n      'got \"' + typeof paths + '\"');\n  }\n\n  for (const path of paths) {\n    if (this.nested[path]) {\n      newSchema.add({ [path]: get(this.tree, path) });\n    } else {\n      const schematype = this.path(path);\n      if (schematype == null) {\n        throw new MongooseError('Path `' + path + '` is not in the schema');\n      }\n      newSchema.add({ [path]: schematype });\n    }\n  }\n\n  return newSchema;\n};\n\n/**\n * Returns a new schema that has the `paths` from the original schema, minus the omitted ones.\n *\n * This method is analagous to [Lodash's `omit()` function](https://lodash.com/docs/#omit) for Mongoose schemas.\n *\n * #### Example:\n *\n *     const schema = Schema({ name: String, age: Number });\n *     // Creates a new schema omitting the `age` path\n *     const newSchema = schema.omit(['age']);\n *\n *     newSchema.path('name'); // SchemaString { ... }\n *     newSchema.path('age'); // undefined\n *\n * @param {String[]} paths List of Paths to omit for the new Schema\n * @param {Object} [options] Options to pass to the new Schema Constructor (same as `new Schema(.., Options)`). Defaults to `this.options` if not set.\n * @return {Schema}\n * @api public\n */\n\nSchema.prototype.omit = function(paths, options) {\n  const newSchema = new Schema(this, options || this.options);\n  if (!Array.isArray(paths)) {\n    throw new MongooseError(\n      'Schema#omit() only accepts an array argument, ' +\n        'got \"' +\n        typeof paths +\n        '\"'\n    );\n  }\n\n  newSchema.remove(paths);\n\n  for (const nested in newSchema.singleNestedPaths) {\n    if (paths.includes(nested)) {\n      delete newSchema.singleNestedPaths[nested];\n    }\n  }\n\n  return newSchema;\n};\n\n/**\n * Returns default options for this schema, merged with `options`.\n *\n * @param {Object} [options] Options to overwrite the default options\n * @return {Object} The merged options of `options` and the default options\n * @api private\n */\n\nSchema.prototype.defaultOptions = function(options) {\n  this._userProvidedOptions = options == null ? {} : clone(options);\n  const baseOptions = this.base && this.base.options || {};\n  const strict = 'strict' in baseOptions ? baseOptions.strict : true;\n  const strictQuery = 'strictQuery' in baseOptions ? baseOptions.strictQuery : false;\n  const id = 'id' in baseOptions ? baseOptions.id : true;\n  options = {\n    strict,\n    strictQuery,\n    bufferCommands: true,\n    capped: false, // { size, max, autoIndexId }\n    versionKey: '__v',\n    optimisticConcurrency: false,\n    minimize: true,\n    autoIndex: null,\n    discriminatorKey: '__t',\n    shardKey: null,\n    read: null,\n    validateBeforeSave: true,\n    validateModifiedOnly: false,\n    // the following are only applied at construction time\n    _id: true,\n    id: id,\n    typeKey: 'type',\n    ...options\n  };\n\n  if (options.versionKey && typeof options.versionKey !== 'string') {\n    throw new MongooseError('`versionKey` must be falsy or string, got `' + (typeof options.versionKey) + '`');\n  }\n\n  if (typeof options.read === 'string') {\n    options.read = handleReadPreferenceAliases(options.read);\n  } else if (Array.isArray(options.read) && typeof options.read[0] === 'string') {\n    options.read = {\n      mode: handleReadPreferenceAliases(options.read[0]),\n      tags: options.read[1]\n    };\n  }\n\n  if (options.optimisticConcurrency && !options.versionKey) {\n    throw new MongooseError('Must set `versionKey` if using `optimisticConcurrency`');\n  }\n\n  return options;\n};\n\n/**\n * Inherit a Schema by applying a discriminator on an existing Schema.\n *\n *\n * #### Example:\n *\n *     const eventSchema = new mongoose.Schema({ timestamp: Date }, { discriminatorKey: 'kind' });\n *\n *     const clickedEventSchema = new mongoose.Schema({ element: String }, { discriminatorKey: 'kind' });\n *     const ClickedModel = eventSchema.discriminator('clicked', clickedEventSchema);\n *\n *     const Event = mongoose.model('Event', eventSchema);\n *\n *     Event.discriminators['clicked']; // Model { clicked }\n *\n *     const doc = await Event.create({ kind: 'clicked', element: '#hero' });\n *     doc.element; // '#hero'\n *     doc instanceof ClickedModel; // true\n *\n * @param {String} name the name of the discriminator\n * @param {Schema} schema the discriminated Schema\n * @return {Schema} the Schema instance\n * @api public\n */\nSchema.prototype.discriminator = function(name, schema) {\n  this._applyDiscriminators = this._applyDiscriminators || new Map();\n  this._applyDiscriminators.set(name, schema);\n\n  return this;\n};\n\n/**\n * Adds key path / schema type pairs to this schema.\n *\n * #### Example:\n *\n *     const ToySchema = new Schema();\n *     ToySchema.add({ name: 'string', color: 'string', price: 'number' });\n *\n *     const TurboManSchema = new Schema();\n *     // You can also `add()` another schema and copy over all paths, virtuals,\n *     // getters, setters, indexes, methods, and statics.\n *     TurboManSchema.add(ToySchema).add({ year: Number });\n *\n * @param {Object|Schema} obj plain object with paths to add, or another schema\n * @param {String} [prefix] path to prefix the newly added paths with\n * @return {Schema} the Schema instance\n * @api public\n */\n\nSchema.prototype.add = function add(obj, prefix) {\n  if (obj instanceof Schema || (obj != null && obj.instanceOfSchema)) {\n    merge(this, obj);\n\n    return this;\n  }\n\n  // Special case: setting top-level `_id` to false should convert to disabling\n  // the `_id` option. This behavior never worked before 5.4.11 but numerous\n  // codebases use it (see gh-7516, gh-7512).\n  if (obj._id === false && prefix == null) {\n    this.options._id = false;\n  }\n\n  prefix = prefix || '';\n  // avoid prototype pollution\n  if (prefix === '__proto__.' || prefix === 'constructor.' || prefix === 'prototype.') {\n    return this;\n  }\n\n  const keys = Object.keys(obj);\n  const typeKey = this.options.typeKey;\n  for (const key of keys) {\n    if (utils.specialProperties.has(key)) {\n      continue;\n    }\n\n    const fullPath = prefix + key;\n    const val = obj[key];\n\n    if (val == null) {\n      throw new TypeError('Invalid value for schema path `' + fullPath +\n        '`, got value \"' + val + '\"');\n    }\n    // Retain `_id: false` but don't set it as a path, re: gh-8274.\n    if (key === '_id' && val === false) {\n      continue;\n    }\n    // Deprecate setting schema paths to primitive types (gh-7558)\n    let isMongooseTypeString = false;\n    if (typeof val === 'string') {\n      // Handle the case in which the type is specified as a string (eg. 'date', 'oid', ...)\n      const MongooseTypes = this.base != null ? this.base.Schema.Types : Schema.Types;\n      const upperVal = val.charAt(0).toUpperCase() + val.substring(1);\n      isMongooseTypeString = MongooseTypes[upperVal] != null;\n    }\n    if (\n      key !== '_id' &&\n      ((typeof val !== 'object' && typeof val !== 'function' && !isMongooseTypeString) ||\n      val == null)\n    ) {\n      throw new TypeError(`Invalid schema configuration: \\`${val}\\` is not ` +\n        `a valid type at path \\`${key}\\`. See ` +\n        'https://bit.ly/mongoose-schematypes for a list of valid schema types.');\n    }\n    if (val instanceof VirtualType || (val.constructor && val.constructor.name || null) === 'VirtualType') {\n      this.virtual(val);\n      continue;\n    }\n\n    if (Array.isArray(val) && val.length === 1 && val[0] == null) {\n      throw new TypeError('Invalid value for schema Array path `' + fullPath +\n        '`, got value \"' + val[0] + '\"');\n    }\n\n    if (!(isPOJO(val) || val instanceof SchemaTypeOptions)) {\n      // Special-case: Non-options definitely a path so leaf at this node\n      // Examples: Schema instances, SchemaType instances\n      if (prefix) {\n        this.nested[prefix.substring(0, prefix.length - 1)] = true;\n      }\n      this.path(prefix + key, val);\n      if (val[0] != null && !(val[0].instanceOfSchema) && utils.isPOJO(val[0].discriminators)) {\n        const schemaType = this.path(prefix + key);\n        for (const key in val[0].discriminators) {\n          schemaType.discriminator(key, val[0].discriminators[key]);\n        }\n      }\n    } else if (Object.keys(val).length < 1) {\n      // Special-case: {} always interpreted as Mixed path so leaf at this node\n      if (prefix) {\n        this.nested[prefix.substring(0, prefix.length - 1)] = true;\n      }\n      this.path(fullPath, val); // mixed type\n    } else if (!val[typeKey] || (typeKey === 'type' && isPOJO(val.type) && val.type.type)) {\n      // Special-case: POJO with no bona-fide type key - interpret as tree of deep paths so recurse\n      // nested object `{ last: { name: String } }`. Avoid functions with `.type` re: #10807 because\n      // NestJS sometimes adds `Date.type`.\n      this.nested[fullPath] = true;\n      this.add(val, fullPath + '.');\n    } else {\n      // There IS a bona-fide type key that may also be a POJO\n      const _typeDef = val[typeKey];\n      if (isPOJO(_typeDef) && Object.keys(_typeDef).length > 0) {\n        // If a POJO is the value of a type key, make it a subdocument\n        if (prefix) {\n          this.nested[prefix.substring(0, prefix.length - 1)] = true;\n        }\n\n        const childSchemaOptions = {};\n        if (this._userProvidedOptions.typeKey) {\n          childSchemaOptions.typeKey = this._userProvidedOptions.typeKey;\n        }\n        // propagate 'strict' option to child schema\n        if (this._userProvidedOptions.strict != null) {\n          childSchemaOptions.strict = this._userProvidedOptions.strict;\n        }\n        if (this._userProvidedOptions.toObject != null) {\n          childSchemaOptions.toObject = utils.omit(this._userProvidedOptions.toObject, ['transform']);\n        }\n        if (this._userProvidedOptions.toJSON != null) {\n          childSchemaOptions.toJSON = utils.omit(this._userProvidedOptions.toJSON, ['transform']);\n        }\n\n        const _schema = new Schema(_typeDef, childSchemaOptions);\n        _schema.$implicitlyCreated = true;\n        const schemaWrappedPath = Object.assign({}, val, { [typeKey]: _schema });\n        this.path(prefix + key, schemaWrappedPath);\n      } else {\n        // Either the type is non-POJO or we interpret it as Mixed anyway\n        if (prefix) {\n          this.nested[prefix.substring(0, prefix.length - 1)] = true;\n        }\n        this.path(prefix + key, val);\n        if (val != null && !(val.instanceOfSchema) && utils.isPOJO(val.discriminators)) {\n          const schemaType = this.path(prefix + key);\n          for (const key in val.discriminators) {\n            schemaType.discriminator(key, val.discriminators[key]);\n          }\n        }\n      }\n    }\n  }\n\n  const aliasObj = Object.fromEntries(\n    Object.entries(obj).map(([key]) => ([prefix + key, null]))\n  );\n  aliasFields(this, aliasObj);\n  return this;\n};\n\n/**\n * Add an alias for `path`. This means getting or setting the `alias`\n * is equivalent to getting or setting the `path`.\n *\n * #### Example:\n *\n *     const toySchema = new Schema({ n: String });\n *\n *     // Make 'name' an alias for 'n'\n *     toySchema.alias('n', 'name');\n *\n *     const Toy = mongoose.model('Toy', toySchema);\n *     const turboMan = new Toy({ n: 'Turbo Man' });\n *\n *     turboMan.name; // 'Turbo Man'\n *     turboMan.n; // 'Turbo Man'\n *\n *     turboMan.name = 'Turbo Man Action Figure';\n *     turboMan.n; // 'Turbo Man Action Figure'\n *\n *     await turboMan.save(); // Saves { _id: ..., n: 'Turbo Man Action Figure' }\n *\n *\n * @param {String} path real path to alias\n * @param {String|String[]} alias the path(s) to use as an alias for `path`\n * @return {Schema} the Schema instance\n * @api public\n */\n\nSchema.prototype.alias = function alias(path, alias) {\n  aliasFields(this, { [path]: alias });\n  return this;\n};\n\n/**\n * Remove an index by name or index specification.\n *\n * removeIndex only removes indexes from your schema object. Does **not** affect the indexes\n * in MongoDB.\n *\n * #### Example:\n *\n *     const ToySchema = new Schema({ name: String, color: String, price: Number });\n *\n *     // Add a new index on { name, color }\n *     ToySchema.index({ name: 1, color: 1 });\n *\n *     // Remove index on { name, color }\n *     // Keep in mind that order matters! `removeIndex({ color: 1, name: 1 })` won't remove the index\n *     ToySchema.removeIndex({ name: 1, color: 1 });\n *\n *     // Add an index with a custom name\n *     ToySchema.index({ color: 1 }, { name: 'my custom index name' });\n *     // Remove index by name\n *     ToySchema.removeIndex('my custom index name');\n *\n * @param {Object|string} index name or index specification\n * @return {Schema} the Schema instance\n * @api public\n */\n\nSchema.prototype.removeIndex = function removeIndex(index) {\n  if (arguments.length > 1) {\n    throw new Error('removeIndex() takes only 1 argument');\n  }\n\n  if (typeof index !== 'object' && typeof index !== 'string') {\n    throw new Error('removeIndex() may only take either an object or a string as an argument');\n  }\n\n  if (typeof index === 'object') {\n    for (let i = this._indexes.length - 1; i >= 0; --i) {\n      if (util.isDeepStrictEqual(this._indexes[i][0], index)) {\n        this._indexes.splice(i, 1);\n      }\n    }\n  } else {\n    for (let i = this._indexes.length - 1; i >= 0; --i) {\n      if (this._indexes[i][1] != null && this._indexes[i][1].name === index) {\n        this._indexes.splice(i, 1);\n      }\n    }\n  }\n\n  return this;\n};\n\n/**\n * Remove all indexes from this schema.\n *\n * clearIndexes only removes indexes from your schema object. Does **not** affect the indexes\n * in MongoDB.\n *\n * #### Example:\n *\n *     const ToySchema = new Schema({ name: String, color: String, price: Number });\n *     ToySchema.index({ name: 1 });\n *     ToySchema.index({ color: 1 });\n *\n *     // Remove all indexes on this schema\n *     ToySchema.clearIndexes();\n *\n *     ToySchema.indexes(); // []\n *\n * @return {Schema} the Schema instance\n * @api public\n */\n\nSchema.prototype.clearIndexes = function clearIndexes() {\n  this._indexes.length = 0;\n\n  return this;\n};\n\n/**\n * Add an [Atlas search index](https://www.mongodb.com/docs/atlas/atlas-search/create-index/) that Mongoose will create using `Model.createSearchIndex()`.\n * This function only works when connected to MongoDB Atlas.\n *\n * #### Example:\n *\n *     const ToySchema = new Schema({ name: String, color: String, price: Number });\n *     ToySchema.searchIndex({ name: 'test', definition: { mappings: { dynamic: true } } });\n *\n * @param {Object} description index options, including `name` and `definition`\n * @param {String} description.name\n * @param {Object} description.definition\n * @return {Schema} the Schema instance\n * @api public\n */\n\nSchema.prototype.searchIndex = function searchIndex(description) {\n  this._searchIndexes.push(description);\n\n  return this;\n};\n\n/**\n * Reserved document keys.\n *\n * Keys in this object are names that are warned in schema declarations\n * because they have the potential to break Mongoose/ Mongoose plugins functionality. If you create a schema\n * using `new Schema()` with one of these property names, Mongoose will log a warning.\n *\n * - _posts\n * - _pres\n * - collection\n  * - emit\n * - errors\n * - get\n * - init\n * - isModified\n * - isNew\n * - listeners\n * - modelName\n * - on\n * - once\n * - populated\n * - prototype\n * - remove\n * - removeListener\n * - save\n * - schema\n * - toObject\n * - validate\n *\n * _NOTE:_ Use of these terms as method names is permitted, but play at your own risk, as they may be existing mongoose document methods you are stomping on.\n *\n *      const schema = new Schema(..);\n *      schema.methods.init = function () {} // potentially breaking\n *\n * @property reserved\n * @memberOf Schema\n * @static\n */\n\nSchema.reserved = Object.create(null);\nSchema.prototype.reserved = Schema.reserved;\n\nconst reserved = Schema.reserved;\n// Core object\nreserved['prototype'] =\n// EventEmitter\nreserved.emit =\nreserved.listeners =\nreserved.removeListener =\n\n// document properties and functions\nreserved.collection =\nreserved.errors =\nreserved.get =\nreserved.init =\nreserved.isModified =\nreserved.isNew =\nreserved.populated =\nreserved.remove =\nreserved.save =\nreserved.toObject =\nreserved.validate = 1;\nreserved.collection = 1;\n\n/**\n * Gets/sets schema paths.\n *\n * Sets a path (if arity 2)\n * Gets a path (if arity 1)\n *\n * #### Example:\n *\n *     schema.path('name') // returns a SchemaType\n *     schema.path('name', Number) // changes the schemaType of `name` to Number\n *\n * @param {String} path The name of the Path to get / set\n * @param {Object} [obj] The Type to set the path to, if provided the path will be SET, otherwise the path will be GET\n * @api public\n */\n\nSchema.prototype.path = function(path, obj) {\n  if (obj === undefined) {\n    // Convert to '.$' to check subpaths re: gh-6405\n    const cleanPath = _pathToPositionalSyntax(path);\n    let schematype = _getPath(this, path, cleanPath);\n    if (schematype != null) {\n      return schematype;\n    }\n\n    // Look for maps\n    const mapPath = getMapPath(this, path);\n    if (mapPath != null) {\n      return mapPath;\n    }\n\n    // Look if a parent of this path is mixed\n    schematype = this.hasMixedParent(cleanPath);\n    if (schematype != null) {\n      return schematype;\n    }\n\n    // subpaths?\n    return hasNumericSubpathRegex.test(path)\n      ? getPositionalPath(this, path, cleanPath)\n      : undefined;\n  }\n\n  // some path names conflict with document methods\n  const firstPieceOfPath = path.split('.')[0];\n  if (reserved[firstPieceOfPath] && !this.options.suppressReservedKeysWarning) {\n    const errorMessage = `\\`${firstPieceOfPath}\\` is a reserved schema pathname and may break some functionality. ` +\n      'You are allowed to use it, but use at your own risk. ' +\n      'To disable this warning pass `suppressReservedKeysWarning` as a schema option.';\n\n    utils.warn(errorMessage);\n  }\n\n  if (typeof obj === 'object' && utils.hasUserDefinedProperty(obj, 'ref')) {\n    validateRef(obj.ref, path);\n  }\n\n  // update the tree\n  const subpaths = path.split(/\\./);\n  const last = subpaths.pop();\n  let branch = this.tree;\n  let fullPath = '';\n\n  for (const sub of subpaths) {\n    if (utils.specialProperties.has(sub)) {\n      throw new Error('Cannot set special property `' + sub + '` on a schema');\n    }\n    fullPath = fullPath += (fullPath.length > 0 ? '.' : '') + sub;\n    if (!branch[sub]) {\n      this.nested[fullPath] = true;\n      branch[sub] = {};\n    }\n    if (typeof branch[sub] !== 'object') {\n      const msg = 'Cannot set nested path `' + path + '`. '\n          + 'Parent path `'\n          + fullPath\n          + '` already set to type ' + branch[sub].name\n          + '.';\n      throw new Error(msg);\n    }\n    branch = branch[sub];\n  }\n\n  branch[last] = clone(obj);\n\n  this.paths[path] = this.interpretAsType(path, obj, this.options);\n  const schemaType = this.paths[path];\n\n  if (schemaType.$isSchemaMap) {\n    // Maps can have arbitrary keys, so `$*` is internal shorthand for \"any key\"\n    // The '$' is to imply this path should never be stored in MongoDB so we\n    // can easily build a regexp out of this path, and '*' to imply \"any key.\"\n    const mapPath = path + '.$*';\n\n    this.paths[mapPath] = schemaType.$__schemaType;\n    this.mapPaths.push(this.paths[mapPath]);\n  }\n\n  if (schemaType.$isSingleNested) {\n    for (const key of Object.keys(schemaType.schema.paths)) {\n      this.singleNestedPaths[path + '.' + key] = schemaType.schema.paths[key];\n    }\n    for (const key of Object.keys(schemaType.schema.singleNestedPaths)) {\n      this.singleNestedPaths[path + '.' + key] =\n        schemaType.schema.singleNestedPaths[key];\n    }\n    for (const key of Object.keys(schemaType.schema.subpaths)) {\n      this.singleNestedPaths[path + '.' + key] =\n        schemaType.schema.subpaths[key];\n    }\n    for (const key of Object.keys(schemaType.schema.nested)) {\n      this.singleNestedPaths[path + '.' + key] = 'nested';\n    }\n\n    Object.defineProperty(schemaType.schema, 'base', {\n      configurable: true,\n      enumerable: false,\n      writable: false,\n      value: this.base\n    });\n\n    schemaType.caster.base = this.base;\n    this.childSchemas.push({\n      schema: schemaType.schema,\n      model: schemaType.caster\n    });\n  } else if (schemaType.$isMongooseDocumentArray) {\n    Object.defineProperty(schemaType.schema, 'base', {\n      configurable: true,\n      enumerable: false,\n      writable: false,\n      value: this.base\n    });\n\n    schemaType.casterConstructor.base = this.base;\n    this.childSchemas.push({\n      schema: schemaType.schema,\n      model: schemaType.casterConstructor\n    });\n  }\n\n  if (schemaType.$isMongooseArray && schemaType.caster instanceof SchemaType) {\n    let arrayPath = path;\n    let _schemaType = schemaType;\n\n    const toAdd = [];\n    while (_schemaType.$isMongooseArray) {\n      arrayPath = arrayPath + '.$';\n\n      // Skip arrays of document arrays\n      if (_schemaType.$isMongooseDocumentArray) {\n        _schemaType.$embeddedSchemaType._arrayPath = arrayPath;\n        _schemaType.$embeddedSchemaType._arrayParentPath = path;\n        _schemaType = _schemaType.$embeddedSchemaType;\n      } else {\n        _schemaType.caster._arrayPath = arrayPath;\n        _schemaType.caster._arrayParentPath = path;\n        _schemaType = _schemaType.caster;\n      }\n\n      this.subpaths[arrayPath] = _schemaType;\n    }\n\n    for (const _schemaType of toAdd) {\n      this.subpaths[_schemaType.path] = _schemaType;\n    }\n  }\n\n  if (schemaType.$isMongooseDocumentArray) {\n    for (const key of Object.keys(schemaType.schema.paths)) {\n      const _schemaType = schemaType.schema.paths[key];\n      this.subpaths[path + '.' + key] = _schemaType;\n      if (typeof _schemaType === 'object' && _schemaType != null && _schemaType.$parentSchemaDocArray == null) {\n        _schemaType.$parentSchemaDocArray = schemaType;\n      }\n    }\n    for (const key of Object.keys(schemaType.schema.subpaths)) {\n      const _schemaType = schemaType.schema.subpaths[key];\n      this.subpaths[path + '.' + key] = _schemaType;\n      if (typeof _schemaType === 'object' && _schemaType != null && _schemaType.$parentSchemaDocArray == null) {\n        _schemaType.$parentSchemaDocArray = schemaType;\n      }\n    }\n    for (const key of Object.keys(schemaType.schema.singleNestedPaths)) {\n      const _schemaType = schemaType.schema.singleNestedPaths[key];\n      this.subpaths[path + '.' + key] = _schemaType;\n      if (typeof _schemaType === 'object' && _schemaType != null && _schemaType.$parentSchemaDocArray == null) {\n        _schemaType.$parentSchemaDocArray = schemaType;\n      }\n    }\n  }\n\n  return this;\n};\n\n/*!\n * ignore\n */\n\nfunction gatherChildSchemas(schema) {\n  const childSchemas = [];\n\n  for (const path of Object.keys(schema.paths)) {\n    const schematype = schema.paths[path];\n    if (schematype.$isMongooseDocumentArray || schematype.$isSingleNested) {\n      childSchemas.push({ schema: schematype.schema, model: schematype.caster });\n    }\n  }\n\n  return childSchemas;\n}\n\n/*!\n * ignore\n */\n\nfunction _getPath(schema, path, cleanPath) {\n  if (schema.paths.hasOwnProperty(path)) {\n    return schema.paths[path];\n  }\n  if (schema.subpaths.hasOwnProperty(cleanPath)) {\n    return schema.subpaths[cleanPath];\n  }\n  if (schema.singleNestedPaths.hasOwnProperty(cleanPath) && typeof schema.singleNestedPaths[cleanPath] === 'object') {\n    return schema.singleNestedPaths[cleanPath];\n  }\n\n  return null;\n}\n\n/*!\n * ignore\n */\n\nfunction _pathToPositionalSyntax(path) {\n  if (!/\\.\\d+/.test(path)) {\n    return path;\n  }\n  return path.replace(/\\.\\d+\\./g, '.$.').replace(/\\.\\d+$/, '.$');\n}\n\n/*!\n * ignore\n */\n\nfunction getMapPath(schema, path) {\n  if (schema.mapPaths.length === 0) {\n    return null;\n  }\n  for (const val of schema.mapPaths) {\n    const _path = val.path;\n    const re = new RegExp('^' + _path.replace(/\\.\\$\\*/g, '\\\\.[^.]+') + '$');\n    if (re.test(path)) {\n      return schema.paths[_path];\n    }\n  }\n\n  return null;\n}\n\n/**\n * The Mongoose instance this schema is associated with\n *\n * @property base\n * @api private\n */\n\nObject.defineProperty(Schema.prototype, 'base', {\n  configurable: true,\n  enumerable: false,\n  writable: true,\n  value: null\n});\n\n/**\n * Converts type arguments into Mongoose Types.\n *\n * @param {String} path\n * @param {Object} obj constructor\n * @param {Object} options\n * @api private\n */\n\nSchema.prototype.interpretAsType = function(path, obj, options) {\n  if (obj instanceof SchemaType) {\n    if (obj.path === path) {\n      return obj;\n    }\n    const clone = obj.clone();\n    clone.path = path;\n    return clone;\n  }\n\n  // If this schema has an associated Mongoose object, use the Mongoose object's\n  // copy of SchemaTypes re: gh-7158 gh-6933\n  const MongooseTypes = this.base != null ? this.base.Schema.Types : Schema.Types;\n  const Types = this.base != null ? this.base.Types : __webpack_require__(/*! ./types */ \"../server/node_modules/mongoose/lib/types/index.js\");\n\n  if (!utils.isPOJO(obj) && !(obj instanceof SchemaTypeOptions)) {\n    const constructorName = utils.getFunctionName(obj.constructor);\n    if (constructorName !== 'Object') {\n      const oldObj = obj;\n      obj = {};\n      obj[options.typeKey] = oldObj;\n    }\n  }\n\n  // Get the type making sure to allow keys named \"type\"\n  // and default to mixed if not specified.\n  // { type: { type: String, default: 'freshcut' } }\n  let type = obj[options.typeKey] && (obj[options.typeKey] instanceof Function || options.typeKey !== 'type' || !obj.type.type)\n    ? obj[options.typeKey]\n    : {};\n  let name;\n\n  if (utils.isPOJO(type) || type === 'mixed') {\n    return new MongooseTypes.Mixed(path, obj);\n  }\n\n  if (Array.isArray(type) || type === Array || type === 'array' || type === MongooseTypes.Array) {\n    // if it was specified through { type } look for `cast`\n    let cast = (type === Array || type === 'array')\n      ? obj.cast || obj.of\n      : type[0];\n\n    // new Schema({ path: [new Schema({ ... })] })\n    if (cast && cast.instanceOfSchema) {\n      if (!(cast instanceof Schema)) {\n        if (this.options._isMerging) {\n          cast = new Schema(cast);\n        } else {\n          throw new TypeError('Schema for array path `' + path +\n            '` is from a different copy of the Mongoose module. ' +\n            'Please make sure you\\'re using the same version ' +\n            'of Mongoose everywhere with `npm list mongoose`. If you are still ' +\n            'getting this error, please add `new Schema()` around the path: ' +\n            `${path}: new Schema(...)`);\n        }\n      }\n      return new MongooseTypes.DocumentArray(path, cast, obj);\n    }\n    if (cast &&\n        cast[options.typeKey] &&\n        cast[options.typeKey].instanceOfSchema) {\n      if (!(cast[options.typeKey] instanceof Schema)) {\n        if (this.options._isMerging) {\n          cast[options.typeKey] = new Schema(cast[options.typeKey]);\n        } else {\n          throw new TypeError('Schema for array path `' + path +\n            '` is from a different copy of the Mongoose module. ' +\n            'Please make sure you\\'re using the same version ' +\n            'of Mongoose everywhere with `npm list mongoose`. If you are still ' +\n            'getting this error, please add `new Schema()` around the path: ' +\n            `${path}: new Schema(...)`);\n        }\n      }\n      return new MongooseTypes.DocumentArray(path, cast[options.typeKey], obj, cast);\n    }\n\n    if (Array.isArray(cast)) {\n      return new MongooseTypes.Array(path, this.interpretAsType(path, cast, options), obj);\n    }\n\n    // Handle both `new Schema({ arr: [{ subpath: String }] })` and `new Schema({ arr: [{ type: { subpath: string } }] })`\n    const castFromTypeKey = (cast != null && cast[options.typeKey] && (options.typeKey !== 'type' || !cast.type.type)) ?\n      cast[options.typeKey] :\n      cast;\n    if (typeof cast === 'string') {\n      cast = MongooseTypes[cast.charAt(0).toUpperCase() + cast.substring(1)];\n    } else if (utils.isPOJO(castFromTypeKey)) {\n      if (Object.keys(castFromTypeKey).length) {\n        // The `minimize` and `typeKey` options propagate to child schemas\n        // declared inline, like `{ arr: [{ val: { $type: String } }] }`.\n        // See gh-3560\n        const childSchemaOptions = { minimize: options.minimize };\n        if (options.typeKey) {\n          childSchemaOptions.typeKey = options.typeKey;\n        }\n        // propagate 'strict' option to child schema\n        if (options.hasOwnProperty('strict')) {\n          childSchemaOptions.strict = options.strict;\n        }\n        if (options.hasOwnProperty('strictQuery')) {\n          childSchemaOptions.strictQuery = options.strictQuery;\n        }\n        if (options.hasOwnProperty('toObject')) {\n          childSchemaOptions.toObject = utils.omit(options.toObject, ['transform']);\n        }\n        if (options.hasOwnProperty('toJSON')) {\n          childSchemaOptions.toJSON = utils.omit(options.toJSON, ['transform']);\n        }\n\n        if (this._userProvidedOptions.hasOwnProperty('_id')) {\n          childSchemaOptions._id = this._userProvidedOptions._id;\n        } else if (Schema.Types.DocumentArray.defaultOptions._id != null) {\n          childSchemaOptions._id = Schema.Types.DocumentArray.defaultOptions._id;\n        }\n\n        const childSchema = new Schema(castFromTypeKey, childSchemaOptions);\n        childSchema.$implicitlyCreated = true;\n        return new MongooseTypes.DocumentArray(path, childSchema, obj);\n      } else {\n        // Special case: empty object becomes mixed\n        return new MongooseTypes.Array(path, MongooseTypes.Mixed, obj);\n      }\n    }\n\n    if (cast) {\n      type = cast[options.typeKey] && (options.typeKey !== 'type' || !cast.type.type)\n        ? cast[options.typeKey]\n        : cast;\n\n      if (Array.isArray(type)) {\n        return new MongooseTypes.Array(path, this.interpretAsType(path, type, options), obj);\n      }\n\n      name = typeof type === 'string'\n        ? type\n        : type.schemaName || utils.getFunctionName(type);\n\n      // For Jest 26+, see #10296\n      if (name === 'ClockDate') {\n        name = 'Date';\n      }\n\n      if (name === void 0) {\n        throw new TypeError('Invalid schema configuration: ' +\n          `Could not determine the embedded type for array \\`${path}\\`. ` +\n          'See https://mongoosejs.com/docs/guide.html#definition for more info on supported schema syntaxes.');\n      }\n      if (!MongooseTypes.hasOwnProperty(name)) {\n        throw new TypeError('Invalid schema configuration: ' +\n          `\\`${name}\\` is not a valid type within the array \\`${path}\\`.` +\n          'See https://bit.ly/mongoose-schematypes for a list of valid schema types.');\n      }\n    }\n\n    return new MongooseTypes.Array(path, cast || MongooseTypes.Mixed, obj, options);\n  }\n\n  if (type && type.instanceOfSchema) {\n    return new MongooseTypes.Subdocument(type, path, obj);\n  }\n\n  if (Buffer.isBuffer(type)) {\n    name = 'Buffer';\n  } else if (typeof type === 'function' || typeof type === 'object') {\n    name = type.schemaName || utils.getFunctionName(type);\n  } else if (type === Types.ObjectId) {\n    name = 'ObjectId';\n  } else if (type === Types.Decimal128) {\n    name = 'Decimal128';\n  } else {\n    name = type == null ? '' + type : type.toString();\n  }\n\n  if (name) {\n    name = name.charAt(0).toUpperCase() + name.substring(1);\n  }\n  // Special case re: gh-7049 because the bson `ObjectID` class' capitalization\n  // doesn't line up with Mongoose's.\n  if (name === 'ObjectID') {\n    name = 'ObjectId';\n  }\n  // For Jest 26+, see #10296\n  if (name === 'ClockDate') {\n    name = 'Date';\n  }\n\n  if (name === void 0) {\n    throw new TypeError(`Invalid schema configuration: \\`${path}\\` schematype definition is ` +\n      'invalid. See ' +\n      'https://mongoosejs.com/docs/guide.html#definition for more info on supported schema syntaxes.');\n  }\n  if (MongooseTypes[name] == null) {\n    throw new TypeError(`Invalid schema configuration: \\`${name}\\` is not ` +\n      `a valid type at path \\`${path}\\`. See ` +\n      'https://bit.ly/mongoose-schematypes for a list of valid schema types.');\n  }\n\n  const schemaType = new MongooseTypes[name](path, obj);\n\n  if (schemaType.$isSchemaMap) {\n    createMapNestedSchemaType(this, schemaType, path, obj, options);\n  }\n\n  return schemaType;\n};\n\n/*!\n * ignore\n */\n\nfunction createMapNestedSchemaType(schema, schemaType, path, obj, options) {\n  const mapPath = path + '.$*';\n  let _mapType = { type: {} };\n  if (utils.hasUserDefinedProperty(obj, 'of')) {\n    const isInlineSchema = utils.isPOJO(obj.of) &&\n      Object.keys(obj.of).length > 0 &&\n      !utils.hasUserDefinedProperty(obj.of, schema.options.typeKey);\n    if (isInlineSchema) {\n      _mapType = { [schema.options.typeKey]: new Schema(obj.of) };\n    } else if (utils.isPOJO(obj.of)) {\n      _mapType = Object.assign({}, obj.of);\n    } else {\n      _mapType = { [schema.options.typeKey]: obj.of };\n    }\n\n    if (_mapType[schema.options.typeKey] && _mapType[schema.options.typeKey].instanceOfSchema) {\n      const subdocumentSchema = _mapType[schema.options.typeKey];\n      subdocumentSchema.eachPath((subpath, type) => {\n        if (type.options.select === true || type.options.select === false) {\n          throw new MongooseError('Cannot use schema-level projections (`select: true` or `select: false`) within maps at path \"' + path + '.' + subpath + '\"');\n        }\n      });\n    }\n\n    if (utils.hasUserDefinedProperty(obj, 'ref')) {\n      _mapType.ref = obj.ref;\n    }\n  }\n  schemaType.$__schemaType = schema.interpretAsType(mapPath, _mapType, options);\n}\n\n/**\n * Iterates the schemas paths similar to Array#forEach.\n *\n * The callback is passed the pathname and the schemaType instance.\n *\n * #### Example:\n *\n *     const userSchema = new Schema({ name: String, registeredAt: Date });\n *     userSchema.eachPath((pathname, schematype) => {\n *       // Prints twice:\n *       // name SchemaString { ... }\n *       // registeredAt SchemaDate { ... }\n *       console.log(pathname, schematype);\n *     });\n *\n * @param {Function} fn callback function\n * @return {Schema} this\n * @api public\n */\n\nSchema.prototype.eachPath = function(fn) {\n  const keys = Object.keys(this.paths);\n  const len = keys.length;\n\n  for (let i = 0; i < len; ++i) {\n    fn(keys[i], this.paths[keys[i]]);\n  }\n\n  return this;\n};\n\n/**\n * Returns an Array of path strings that are required by this schema.\n *\n * #### Example:\n *\n *     const s = new Schema({\n *       name: { type: String, required: true },\n *       age: { type: String, required: true },\n *       notes: String\n *     });\n *     s.requiredPaths(); // [ 'age', 'name' ]\n *\n * @api public\n * @param {Boolean} invalidate Refresh the cache\n * @return {Array}\n */\n\nSchema.prototype.requiredPaths = function requiredPaths(invalidate) {\n  if (this._requiredpaths && !invalidate) {\n    return this._requiredpaths;\n  }\n\n  const paths = Object.keys(this.paths);\n  let i = paths.length;\n  const ret = [];\n\n  while (i--) {\n    const path = paths[i];\n    if (this.paths[path].isRequired) {\n      ret.push(path);\n    }\n  }\n  this._requiredpaths = ret;\n  return this._requiredpaths;\n};\n\n/**\n * Returns indexes from fields and schema-level indexes (cached).\n *\n * @api private\n * @return {Array}\n */\n\nSchema.prototype.indexedPaths = function indexedPaths() {\n  if (this._indexedpaths) {\n    return this._indexedpaths;\n  }\n  this._indexedpaths = this.indexes();\n  return this._indexedpaths;\n};\n\n/**\n * Returns the pathType of `path` for this schema.\n *\n * Given a path, returns whether it is a real, virtual, nested, or ad-hoc/undefined path.\n *\n * #### Example:\n *\n *     const s = new Schema({ name: String, nested: { foo: String } });\n *     s.virtual('foo').get(() => 42);\n *     s.pathType('name'); // \"real\"\n *     s.pathType('nested'); // \"nested\"\n *     s.pathType('foo'); // \"virtual\"\n *     s.pathType('fail'); // \"adhocOrUndefined\"\n *\n * @param {String} path\n * @return {String}\n * @api public\n */\n\nSchema.prototype.pathType = function(path) {\n  if (this.paths.hasOwnProperty(path)) {\n    return 'real';\n  }\n  if (this.virtuals.hasOwnProperty(path)) {\n    return 'virtual';\n  }\n  if (this.nested.hasOwnProperty(path)) {\n    return 'nested';\n  }\n\n  // Convert to '.$' to check subpaths re: gh-6405\n  const cleanPath = _pathToPositionalSyntax(path);\n\n  if (this.subpaths.hasOwnProperty(cleanPath) || this.subpaths.hasOwnProperty(path)) {\n    return 'real';\n  }\n\n  const singleNestedPath = this.singleNestedPaths.hasOwnProperty(cleanPath) || this.singleNestedPaths.hasOwnProperty(path);\n  if (singleNestedPath) {\n    return singleNestedPath === 'nested' ? 'nested' : 'real';\n  }\n\n  // Look for maps\n  const mapPath = getMapPath(this, path);\n  if (mapPath != null) {\n    return 'real';\n  }\n\n  if (/\\.\\d+\\.|\\.\\d+$/.test(path)) {\n    return getPositionalPathType(this, path, cleanPath);\n  }\n  return 'adhocOrUndefined';\n};\n\n/**\n * Returns true iff this path is a child of a mixed schema.\n *\n * @param {String} path\n * @return {Boolean}\n * @api private\n */\n\nSchema.prototype.hasMixedParent = function(path) {\n  const subpaths = path.split(/\\./g);\n  path = '';\n  for (let i = 0; i < subpaths.length; ++i) {\n    path = i > 0 ? path + '.' + subpaths[i] : subpaths[i];\n    if (this.paths.hasOwnProperty(path) &&\n        this.paths[path] instanceof MongooseTypes.Mixed) {\n      return this.paths[path];\n    }\n  }\n\n  return null;\n};\n\n/**\n * Setup updatedAt and createdAt timestamps to documents if enabled\n *\n * @param {Boolean|Object} timestamps timestamps options\n * @api private\n */\nSchema.prototype.setupTimestamp = function(timestamps) {\n  return setupTimestamps(this, timestamps);\n};\n\n/**\n * ignore. Deprecated re: #6405\n * @param {Any} self\n * @param {String} path\n * @api private\n */\n\nfunction getPositionalPathType(self, path, cleanPath) {\n  const subpaths = path.split(/\\.(\\d+)\\.|\\.(\\d+)$/).filter(Boolean);\n  if (subpaths.length < 2) {\n    return self.paths.hasOwnProperty(subpaths[0]) ?\n      self.paths[subpaths[0]] :\n      'adhocOrUndefined';\n  }\n\n  let val = self.path(subpaths[0]);\n  let isNested = false;\n  if (!val) {\n    return 'adhocOrUndefined';\n  }\n\n  const last = subpaths.length - 1;\n\n  for (let i = 1; i < subpaths.length; ++i) {\n    isNested = false;\n    const subpath = subpaths[i];\n\n    if (i === last && val && !/\\D/.test(subpath)) {\n      if (val.$isMongooseDocumentArray) {\n        val = val.$embeddedSchemaType;\n      } else if (val instanceof MongooseTypes.Array) {\n        // StringSchema, NumberSchema, etc\n        val = val.caster;\n      } else {\n        val = undefined;\n      }\n      break;\n    }\n\n    // ignore if its just a position segment: path.0.subpath\n    if (!/\\D/.test(subpath)) {\n      // Nested array\n      if (val instanceof MongooseTypes.Array && i !== last) {\n        val = val.caster;\n      }\n      continue;\n    }\n\n    if (!(val && val.schema)) {\n      val = undefined;\n      break;\n    }\n\n    const type = val.schema.pathType(subpath);\n    isNested = (type === 'nested');\n    val = val.schema.path(subpath);\n  }\n\n  self.subpaths[cleanPath] = val;\n  if (val) {\n    return 'real';\n  }\n  if (isNested) {\n    return 'nested';\n  }\n  return 'adhocOrUndefined';\n}\n\n\n/*!\n * ignore\n */\n\nfunction getPositionalPath(self, path, cleanPath) {\n  getPositionalPathType(self, path, cleanPath);\n  return self.subpaths[cleanPath];\n}\n\n/**\n * Adds a method call to the queue.\n *\n * #### Example:\n *\n *     schema.methods.print = function() { console.log(this); };\n *     schema.queue('print', []); // Print the doc every one is instantiated\n *\n *     const Model = mongoose.model('Test', schema);\n *     new Model({ name: 'test' }); // Prints '{\"_id\": ..., \"name\": \"test\" }'\n *\n * @param {String} name name of the document method to call later\n * @param {Array} args arguments to pass to the method\n * @api public\n */\n\nSchema.prototype.queue = function(name, args) {\n  this.callQueue.push([name, args]);\n  return this;\n};\n\n/**\n * Defines a pre hook for the model.\n *\n * #### Example:\n *\n *     const toySchema = new Schema({ name: String, created: Date });\n *\n *     toySchema.pre('save', function(next) {\n *       if (!this.created) this.created = new Date;\n *       next();\n *     });\n *\n *     toySchema.pre('validate', function(next) {\n *       if (this.name !== 'Woody') this.name = 'Woody';\n *       next();\n *     });\n *\n *     // Equivalent to calling `pre()` on `find`, `findOne`, `findOneAndUpdate`.\n *     toySchema.pre(/^find/, function(next) {\n *       console.log(this.getFilter());\n *     });\n *\n *     // Equivalent to calling `pre()` on `updateOne`, `findOneAndUpdate`.\n *     toySchema.pre(['updateOne', 'findOneAndUpdate'], function(next) {\n *       console.log(this.getFilter());\n *     });\n *\n *     toySchema.pre('deleteOne', function() {\n *       // Runs when you call `Toy.deleteOne()`\n *     });\n *\n *     toySchema.pre('deleteOne', { document: true }, function() {\n *       // Runs when you call `doc.deleteOne()`\n *     });\n *\n * @param {String|RegExp|String[]} methodName The method name or regular expression to match method name\n * @param {Object} [options]\n * @param {Boolean} [options.document] If `name` is a hook for both document and query middleware, set to `true` to run on document middleware. For example, set `options.document` to `true` to apply this hook to `Document#deleteOne()` rather than `Query#deleteOne()`.\n * @param {Boolean} [options.query] If `name` is a hook for both document and query middleware, set to `true` to run on query middleware.\n * @param {Function} callback\n * @api public\n */\n\nSchema.prototype.pre = function(name) {\n  if (name instanceof RegExp) {\n    const remainingArgs = Array.prototype.slice.call(arguments, 1);\n    for (const fn of hookNames) {\n      if (name.test(fn)) {\n        this.pre.apply(this, [fn].concat(remainingArgs));\n      }\n    }\n    return this;\n  }\n  if (Array.isArray(name)) {\n    const remainingArgs = Array.prototype.slice.call(arguments, 1);\n    for (const el of name) {\n      this.pre.apply(this, [el].concat(remainingArgs));\n    }\n    return this;\n  }\n  this.s.hooks.pre.apply(this.s.hooks, arguments);\n  return this;\n};\n\n/**\n * Defines a post hook for the document\n *\n *     const schema = new Schema(..);\n *     schema.post('save', function (doc) {\n *       console.log('this fired after a document was saved');\n *     });\n *\n *     schema.post('find', function(docs) {\n *       console.log('this fired after you ran a find query');\n *     });\n *\n *     schema.post(/Many$/, function(res) {\n *       console.log('this fired after you ran `updateMany()` or `deleteMany()`');\n *     });\n *\n *     const Model = mongoose.model('Model', schema);\n *\n *     const m = new Model(..);\n *     m.save(function(err) {\n *       console.log('this fires after the `post` hook');\n *     });\n *\n *     m.find(function(err, docs) {\n *       console.log('this fires after the post find hook');\n *     });\n *\n * @param {String|RegExp|String[]} methodName The method name or regular expression to match method name\n * @param {Object} [options]\n * @param {Boolean} [options.document] If `name` is a hook for both document and query middleware, set to `true` to run on document middleware.\n * @param {Boolean} [options.query] If `name` is a hook for both document and query middleware, set to `true` to run on query middleware.\n * @param {Function} fn callback\n * @see middleware https://mongoosejs.com/docs/middleware.html\n * @see kareem https://npmjs.org/package/kareem\n * @api public\n */\n\nSchema.prototype.post = function(name) {\n  if (name instanceof RegExp) {\n    const remainingArgs = Array.prototype.slice.call(arguments, 1);\n    for (const fn of hookNames) {\n      if (name.test(fn)) {\n        this.post.apply(this, [fn].concat(remainingArgs));\n      }\n    }\n    return this;\n  }\n  if (Array.isArray(name)) {\n    const remainingArgs = Array.prototype.slice.call(arguments, 1);\n    for (const el of name) {\n      this.post.apply(this, [el].concat(remainingArgs));\n    }\n    return this;\n  }\n  this.s.hooks.post.apply(this.s.hooks, arguments);\n  return this;\n};\n\n/**\n * Registers a plugin for this schema.\n *\n * #### Example:\n *\n *     const s = new Schema({ name: String });\n *     s.plugin(schema => console.log(schema.path('name').path));\n *     mongoose.model('Test', s); // Prints 'name'\n *\n * Or with Options:\n *\n *     const s = new Schema({ name: String });\n *     s.plugin((schema, opts) => console.log(opts.text, schema.path('name').path), { text: \"Schema Path Name:\" });\n *     mongoose.model('Test', s); // Prints 'Schema Path Name: name'\n *\n * @param {Function} plugin The Plugin's callback\n * @param {Object} [opts] Options to pass to the plugin\n * @param {Boolean} [opts.deduplicate=false] If true, ignore duplicate plugins (same `fn` argument using `===`)\n * @see plugins https://mongoosejs.com/docs/plugins.html\n * @api public\n */\n\nSchema.prototype.plugin = function(fn, opts) {\n  if (typeof fn !== 'function') {\n    throw new Error('First param to `schema.plugin()` must be a function, ' +\n      'got \"' + (typeof fn) + '\"');\n  }\n\n  if (opts && opts.deduplicate) {\n    for (const plugin of this.plugins) {\n      if (plugin.fn === fn) {\n        return this;\n      }\n    }\n  }\n  this.plugins.push({ fn: fn, opts: opts });\n\n  fn(this, opts);\n  return this;\n};\n\n/**\n * Adds an instance method to documents constructed from Models compiled from this schema.\n *\n * #### Example:\n *\n *     const schema = kittySchema = new Schema(..);\n *\n *     schema.method('meow', function () {\n *       console.log('meeeeeoooooooooooow');\n *     })\n *\n *     const Kitty = mongoose.model('Kitty', schema);\n *\n *     const fizz = new Kitty;\n *     fizz.meow(); // meeeeeooooooooooooow\n *\n * If a hash of name/fn pairs is passed as the only argument, each name/fn pair will be added as methods.\n *\n *     schema.method({\n *         purr: function () {}\n *       , scratch: function () {}\n *     });\n *\n *     // later\n *     const fizz = new Kitty;\n *     fizz.purr();\n *     fizz.scratch();\n *\n * NOTE: `Schema.method()` adds instance methods to the `Schema.methods` object. You can also add instance methods directly to the `Schema.methods` object as seen in the [guide](https://mongoosejs.com/docs/guide.html#methods)\n *\n * @param {String|Object} name The Method Name for a single function, or a Object of \"string-function\" pairs.\n * @param {Function} [fn] The Function in a single-function definition.\n * @api public\n */\n\nSchema.prototype.method = function(name, fn, options) {\n  if (typeof name !== 'string') {\n    for (const i in name) {\n      this.methods[i] = name[i];\n      this.methodOptions[i] = clone(options);\n    }\n  } else {\n    this.methods[name] = fn;\n    this.methodOptions[name] = clone(options);\n  }\n  return this;\n};\n\n/**\n * Adds static \"class\" methods to Models compiled from this schema.\n *\n * #### Example:\n *\n *     const schema = new Schema(..);\n *     // Equivalent to `schema.statics.findByName = function(name) {}`;\n *     schema.static('findByName', function(name) {\n *       return this.find({ name: name });\n *     });\n *\n *     const Drink = mongoose.model('Drink', schema);\n *     await Drink.findByName('LaCroix');\n *\n * If a hash of name/fn pairs is passed as the only argument, each name/fn pair will be added as methods.\n *\n *     schema.static({\n *         findByName: function () {..}\n *       , findByCost: function () {..}\n *     });\n *\n *     const Drink = mongoose.model('Drink', schema);\n *     await Drink.findByName('LaCroix');\n *     await Drink.findByCost(3);\n *\n * If a hash of name/fn pairs is passed as the only argument, each name/fn pair will be added as statics.\n *\n * @param {String|Object} name The Method Name for a single function, or a Object of \"string-function\" pairs.\n * @param {Function} [fn] The Function in a single-function definition.\n * @api public\n * @see Statics https://mongoosejs.com/docs/guide.html#statics\n */\n\nSchema.prototype.static = function(name, fn) {\n  if (typeof name !== 'string') {\n    for (const i in name) {\n      this.statics[i] = name[i];\n    }\n  } else {\n    this.statics[name] = fn;\n  }\n  return this;\n};\n\n/**\n * Defines an index (most likely compound) for this schema.\n *\n * #### Example:\n *\n *     schema.index({ first: 1, last: -1 })\n *\n * @param {Object} fields The Fields to index, with the order, available values: `1 | -1 | '2d' | '2dsphere' | 'geoHaystack' | 'hashed' | 'text'`\n * @param {Object} [options] Options to pass to [MongoDB driver's `createIndex()` function](https://mongodb.github.io/node-mongodb-native/4.9/classes/Collection.html#createIndex)\n * @param {String | number} [options.expires=null] Mongoose-specific syntactic sugar, uses [ms](https://www.npmjs.com/package/ms) to convert `expires` option into seconds for the `expireAfterSeconds` in the above link.\n * @param {String} [options.language_override=null] Tells mongodb to use the specified field instead of `language` for parsing text indexes.\n * @api public\n */\n\nSchema.prototype.index = function(fields, options) {\n  fields || (fields = {});\n  options || (options = {});\n\n  if (options.expires) {\n    utils.expires(options);\n  }\n  for (const key in fields) {\n    if (this.aliases[key]) {\n      fields = utils.renameObjKey(fields, key, this.aliases[key]);\n    }\n  }\n  for (const field of Object.keys(fields)) {\n    if (fields[field] === 'ascending' || fields[field] === 'asc') {\n      fields[field] = 1;\n    } else if (fields[field] === 'descending' || fields[field] === 'desc') {\n      fields[field] = -1;\n    }\n  }\n\n  this._indexes.push([fields, options]);\n  return this;\n};\n\n/**\n * Sets a schema option.\n *\n * #### Example:\n *\n *     schema.set('strict'); // 'true' by default\n *     schema.set('strict', false); // Sets 'strict' to false\n *     schema.set('strict'); // 'false'\n *\n * @param {String} key The name of the option to set the value to\n * @param {Object} [value] The value to set the option to, if not passed, the option will be reset to default\n * @param {Array<string>} [tags] tags to add to read preference if key === 'read'\n * @see Schema https://mongoosejs.com/docs/api/schema.html#Schema()\n * @api public\n */\n\nSchema.prototype.set = function(key, value, tags) {\n  if (arguments.length === 1) {\n    return this.options[key];\n  }\n\n  switch (key) {\n    case 'read':\n      if (typeof value === 'string') {\n        this.options[key] = { mode: handleReadPreferenceAliases(value), tags };\n      } else if (Array.isArray(value) && typeof value[0] === 'string') {\n        this.options[key] = {\n          mode: handleReadPreferenceAliases(value[0]),\n          tags: value[1]\n        };\n      } else {\n        this.options[key] = value;\n      }\n      this._userProvidedOptions[key] = this.options[key];\n      break;\n    case 'timestamps':\n      this.setupTimestamp(value);\n      this.options[key] = value;\n      this._userProvidedOptions[key] = this.options[key];\n      break;\n    case '_id':\n      this.options[key] = value;\n      this._userProvidedOptions[key] = this.options[key];\n\n      if (value && !this.paths['_id']) {\n        addAutoId(this);\n      } else if (!value && this.paths['_id'] != null && this.paths['_id'].auto) {\n        this.remove('_id');\n      }\n      break;\n    default:\n      this.options[key] = value;\n      this._userProvidedOptions[key] = this.options[key];\n      break;\n  }\n\n  // Propagate `strict` and `strictQuery` changes down to implicitly created schemas\n  if (key === 'strict') {\n    _propagateOptionsToImplicitlyCreatedSchemas(this, { strict: value });\n  }\n  if (key === 'strictQuery') {\n    _propagateOptionsToImplicitlyCreatedSchemas(this, { strictQuery: value });\n  }\n  if (key === 'toObject') {\n    value = { ...value };\n    // Avoid propagating transform to implicitly created schemas re: gh-3279\n    delete value.transform;\n    _propagateOptionsToImplicitlyCreatedSchemas(this, { toObject: value });\n  }\n  if (key === 'toJSON') {\n    value = { ...value };\n    // Avoid propagating transform to implicitly created schemas re: gh-3279\n    delete value.transform;\n    _propagateOptionsToImplicitlyCreatedSchemas(this, { toJSON: value });\n  }\n\n  return this;\n};\n\n/*!\n * Recursively set options on implicitly created schemas\n */\n\nfunction _propagateOptionsToImplicitlyCreatedSchemas(baseSchema, options) {\n  for (const { schema } of baseSchema.childSchemas) {\n    if (!schema.$implicitlyCreated) {\n      continue;\n    }\n    Object.assign(schema.options, options);\n    _propagateOptionsToImplicitlyCreatedSchemas(schema, options);\n  }\n}\n\n/**\n * Gets a schema option.\n *\n * #### Example:\n *\n *     schema.get('strict'); // true\n *     schema.set('strict', false);\n *     schema.get('strict'); // false\n *\n * @param {String} key The name of the Option to get the current value for\n * @api public\n * @return {Any} the option's value\n */\n\nSchema.prototype.get = function(key) {\n  return this.options[key];\n};\n\nconst indexTypes = '2d 2dsphere hashed text'.split(' ');\n\n/**\n * The allowed index types\n *\n * @property {String[]} indexTypes\n * @memberOf Schema\n * @static\n * @api public\n */\n\nObject.defineProperty(Schema, 'indexTypes', {\n  get: function() {\n    return indexTypes;\n  },\n  set: function() {\n    throw new Error('Cannot overwrite Schema.indexTypes');\n  }\n});\n\n/**\n * Returns a list of indexes that this schema declares, via `schema.index()` or by `index: true` in a path's options.\n * Indexes are expressed as an array `[spec, options]`.\n *\n * #### Example:\n *\n *     const userSchema = new Schema({\n *       email: { type: String, required: true, unique: true },\n *       registeredAt: { type: Date, index: true }\n *     });\n *\n *     // [ [ { email: 1 }, { unique: true, background: true } ],\n *     //   [ { registeredAt: 1 }, { background: true } ] ]\n *     userSchema.indexes();\n *\n * [Plugins](https://mongoosejs.com/docs/plugins.html) can use the return value of this function to modify a schema's indexes.\n * For example, the below plugin makes every index unique by default.\n *\n *     function myPlugin(schema) {\n *       for (const index of schema.indexes()) {\n *         if (index[1].unique === undefined) {\n *           index[1].unique = true;\n *         }\n *       }\n *     }\n *\n * @api public\n * @return {Array} list of indexes defined in the schema\n */\n\nSchema.prototype.indexes = function() {\n  return getIndexes(this);\n};\n\n/**\n * Creates a virtual type with the given name.\n *\n * @param {String} name The name of the Virtual\n * @param {Object} [options]\n * @param {String|Model} [options.ref] model name or model instance. Marks this as a [populate virtual](https://mongoosejs.com/docs/populate.html#populate-virtuals).\n * @param {String|Function} [options.localField] Required for populate virtuals. See [populate virtual docs](https://mongoosejs.com/docs/populate.html#populate-virtuals) for more information.\n * @param {String|Function} [options.foreignField] Required for populate virtuals. See [populate virtual docs](https://mongoosejs.com/docs/populate.html#populate-virtuals) for more information.\n * @param {Boolean|Function} [options.justOne=false] Only works with populate virtuals. If [truthy](https://masteringjs.io/tutorials/fundamentals/truthy), will be a single doc or `null`. Otherwise, the populate virtual will be an array.\n * @param {Boolean} [options.count=false] Only works with populate virtuals. If [truthy](https://masteringjs.io/tutorials/fundamentals/truthy), this populate virtual will contain the number of documents rather than the documents themselves when you `populate()`.\n * @param {Function|null} [options.get=null] Adds a [getter](https://mongoosejs.com/docs/tutorials/getters-setters.html) to this virtual to transform the populated doc.\n * @param {Object|Function} [options.match=null] Apply a default [`match` option to populate](https://mongoosejs.com/docs/populate.html#match), adding an additional filter to the populate query.\n * @return {VirtualType}\n */\n\nSchema.prototype.virtual = function(name, options) {\n  if (name instanceof VirtualType || getConstructorName(name) === 'VirtualType') {\n    return this.virtual(name.path, name.options);\n  }\n  options = new VirtualOptions(options);\n\n  if (utils.hasUserDefinedProperty(options, ['ref', 'refPath'])) {\n    if (options.localField == null) {\n      throw new Error('Reference virtuals require `localField` option');\n    }\n\n    if (options.foreignField == null) {\n      throw new Error('Reference virtuals require `foreignField` option');\n    }\n\n    this.pre('init', function virtualPreInit(obj) {\n      if (mpath.has(name, obj)) {\n        const _v = mpath.get(name, obj);\n        if (!this.$$populatedVirtuals) {\n          this.$$populatedVirtuals = {};\n        }\n\n        if (options.justOne || options.count) {\n          this.$$populatedVirtuals[name] = Array.isArray(_v) ?\n            _v[0] :\n            _v;\n        } else {\n          this.$$populatedVirtuals[name] = Array.isArray(_v) ?\n            _v :\n            _v == null ? [] : [_v];\n        }\n\n        mpath.unset(name, obj);\n      }\n    });\n\n    const virtual = this.virtual(name);\n    virtual.options = options;\n\n    virtual.\n      set(function(v) {\n        if (!this.$$populatedVirtuals) {\n          this.$$populatedVirtuals = {};\n        }\n\n        return setPopulatedVirtualValue(\n          this.$$populatedVirtuals,\n          name,\n          v,\n          options\n        );\n      });\n\n    if (typeof options.get === 'function') {\n      virtual.get(options.get);\n    }\n\n    // Workaround for gh-8198: if virtual is under document array, make a fake\n    // virtual. See gh-8210, gh-13189\n    const parts = name.split('.');\n    let cur = parts[0];\n    for (let i = 0; i < parts.length - 1; ++i) {\n      if (this.paths[cur] == null) {\n        continue;\n      }\n\n      if (this.paths[cur].$isMongooseDocumentArray || this.paths[cur].$isSingleNested) {\n        const remnant = parts.slice(i + 1).join('.');\n        this.paths[cur].schema.virtual(remnant, options);\n        break;\n      }\n\n      cur += '.' + parts[i + 1];\n    }\n\n    return virtual;\n  }\n\n  const virtuals = this.virtuals;\n  const parts = name.split('.');\n\n  if (this.pathType(name) === 'real') {\n    throw new Error('Virtual path \"' + name + '\"' +\n      ' conflicts with a real path in the schema');\n  }\n\n  virtuals[name] = parts.reduce(function(mem, part, i) {\n    mem[part] || (mem[part] = (i === parts.length - 1)\n      ? new VirtualType(options, name)\n      : {});\n    return mem[part];\n  }, this.tree);\n\n  return virtuals[name];\n};\n\n/**\n * Returns the virtual type with the given `name`.\n *\n * @param {String} name The name of the Virtual to get\n * @return {VirtualType|null}\n */\n\nSchema.prototype.virtualpath = function(name) {\n  return this.virtuals.hasOwnProperty(name) ? this.virtuals[name] : null;\n};\n\n/**\n * Removes the given `path` (or [`paths`]).\n *\n * #### Example:\n *\n *     const schema = new Schema({ name: String, age: Number });\n *     schema.remove('name');\n *     schema.path('name'); // Undefined\n *     schema.path('age'); // SchemaNumber { ... }\n *\n * Or as a Array:\n *\n *     schema.remove(['name', 'age']);\n *     schema.path('name'); // Undefined\n *     schema.path('age'); // Undefined\n *\n * @param {String|Array} path The Path(s) to remove\n * @return {Schema} the Schema instance\n * @api public\n */\nSchema.prototype.remove = function(path) {\n  if (typeof path === 'string') {\n    path = [path];\n  }\n  if (Array.isArray(path)) {\n    path.forEach(function(name) {\n      if (this.path(name) == null && !this.nested[name]) {\n        return;\n      }\n      if (this.nested[name]) {\n        const allKeys = Object.keys(this.paths).\n          concat(Object.keys(this.nested));\n        for (const path of allKeys) {\n          if (path.startsWith(name + '.')) {\n            delete this.paths[path];\n            delete this.nested[path];\n            _deletePath(this, path);\n          }\n        }\n\n        delete this.nested[name];\n        _deletePath(this, name);\n        return;\n      }\n\n      delete this.paths[name];\n      _deletePath(this, name);\n    }, this);\n  }\n  return this;\n};\n\n/*!\n * ignore\n */\n\nfunction _deletePath(schema, name) {\n  const pieces = name.split('.');\n  const last = pieces.pop();\n\n  let branch = schema.tree;\n\n  for (const piece of pieces) {\n    branch = branch[piece];\n  }\n\n  delete branch[last];\n}\n\n/**\n * Removes the given virtual or virtuals from the schema.\n *\n * @param {String|Array} path The virutal path(s) to remove.\n * @returns {Schema} the Schema instance, or a mongoose error if the virtual does not exist.\n * @api public\n */\n\nSchema.prototype.removeVirtual = function(path) {\n  if (typeof path === 'string') {\n    path = [path];\n  }\n  if (Array.isArray(path)) {\n    for (const virtual of path) {\n      if (this.virtuals[virtual] == null) {\n        throw new MongooseError(`Attempting to remove virtual \"${virtual}\" that does not exist.`);\n      }\n    }\n\n    for (const virtual of path) {\n      delete this.paths[virtual];\n      delete this.virtuals[virtual];\n      if (virtual.indexOf('.') !== -1) {\n        mpath.unset(virtual, this.tree);\n      } else {\n        delete this.tree[virtual];\n      }\n    }\n  }\n  return this;\n};\n\n/**\n * Loads an ES6 class into a schema. Maps [setters](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/set) + [getters](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/get), [static methods](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes/static),\n * and [instance methods](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes#Class_body_and_method_definitions)\n * to schema [virtuals](https://mongoosejs.com/docs/guide.html#virtuals),\n * [statics](https://mongoosejs.com/docs/guide.html#statics), and\n * [methods](https://mongoosejs.com/docs/guide.html#methods).\n *\n * #### Example:\n *\n * ```javascript\n * const md5 = require('md5');\n * const userSchema = new Schema({ email: String });\n * class UserClass {\n *   // `gravatarImage` becomes a virtual\n *   get gravatarImage() {\n *     const hash = md5(this.email.toLowerCase());\n *     return `https://www.gravatar.com/avatar/${hash}`;\n *   }\n *\n *   // `getProfileUrl()` becomes a document method\n *   getProfileUrl() {\n *     return `https://mysite.com/${this.email}`;\n *   }\n *\n *   // `findByEmail()` becomes a static\n *   static findByEmail(email) {\n *     return this.findOne({ email });\n *   }\n * }\n *\n * // `schema` will now have a `gravatarImage` virtual, a `getProfileUrl()` method,\n * // and a `findByEmail()` static\n * userSchema.loadClass(UserClass);\n * ```\n *\n * @param {Function} model The Class to load\n * @param {Boolean} [virtualsOnly] if truthy, only pulls virtuals from the class, not methods or statics\n */\nSchema.prototype.loadClass = function(model, virtualsOnly) {\n  // Stop copying when hit certain base classes\n  if (model === Object.prototype ||\n      model === Function.prototype ||\n      model.prototype.hasOwnProperty('$isMongooseModelPrototype') ||\n      model.prototype.hasOwnProperty('$isMongooseDocumentPrototype')) {\n    return this;\n  }\n\n  this.loadClass(Object.getPrototypeOf(model), virtualsOnly);\n\n  // Add static methods\n  if (!virtualsOnly) {\n    Object.getOwnPropertyNames(model).forEach(function(name) {\n      if (name.match(/^(length|name|prototype|constructor|__proto__)$/)) {\n        return;\n      }\n      const prop = Object.getOwnPropertyDescriptor(model, name);\n      if (prop.hasOwnProperty('value')) {\n        this.static(name, prop.value);\n      }\n    }, this);\n  }\n\n  // Add methods and virtuals\n  Object.getOwnPropertyNames(model.prototype).forEach(function(name) {\n    if (name.match(/^(constructor)$/)) {\n      return;\n    }\n    const method = Object.getOwnPropertyDescriptor(model.prototype, name);\n    if (!virtualsOnly) {\n      if (typeof method.value === 'function') {\n        this.method(name, method.value);\n      }\n    }\n    if (typeof method.get === 'function') {\n      if (this.virtuals[name]) {\n        this.virtuals[name].getters = [];\n      }\n      this.virtual(name).get(method.get);\n    }\n    if (typeof method.set === 'function') {\n      if (this.virtuals[name]) {\n        this.virtuals[name].setters = [];\n      }\n      this.virtual(name).set(method.set);\n    }\n  }, this);\n\n  return this;\n};\n\n/*!\n * ignore\n */\n\nSchema.prototype._getSchema = function(path) {\n  const _this = this;\n  const pathschema = _this.path(path);\n  const resultPath = [];\n\n  if (pathschema) {\n    pathschema.$fullPath = path;\n    return pathschema;\n  }\n\n  function search(parts, schema) {\n    let p = parts.length + 1;\n    let foundschema;\n    let trypath;\n\n    while (p--) {\n      trypath = parts.slice(0, p).join('.');\n      foundschema = schema.path(trypath);\n      if (foundschema) {\n        resultPath.push(trypath);\n\n        if (foundschema.caster) {\n          // array of Mixed?\n          if (foundschema.caster instanceof MongooseTypes.Mixed) {\n            foundschema.caster.$fullPath = resultPath.join('.');\n            return foundschema.caster;\n          }\n\n          // Now that we found the array, we need to check if there\n          // are remaining document paths to look up for casting.\n          // Also we need to handle array.$.path since schema.path\n          // doesn't work for that.\n          // If there is no foundschema.schema we are dealing with\n          // a path like array.$\n          if (p !== parts.length) {\n            if (foundschema.schema) {\n              let ret;\n              if (parts[p] === '$' || isArrayFilter(parts[p])) {\n                if (p + 1 === parts.length) {\n                  // comments.$\n                  return foundschema.$embeddedSchemaType;\n                }\n                // comments.$.comments.$.title\n                ret = search(parts.slice(p + 1), foundschema.schema);\n                if (ret) {\n                  ret.$parentSchemaDocArray = ret.$parentSchemaDocArray ||\n                    (foundschema.schema.$isSingleNested ? null : foundschema);\n                }\n                return ret;\n              }\n              // this is the last path of the selector\n              ret = search(parts.slice(p), foundschema.schema);\n              if (ret) {\n                ret.$parentSchemaDocArray = ret.$parentSchemaDocArray ||\n                  (foundschema.schema.$isSingleNested ? null : foundschema);\n              }\n              return ret;\n            }\n          }\n        } else if (foundschema.$isSchemaMap) {\n          if (p >= parts.length) {\n            return foundschema;\n          }\n          // Any path in the map will be an instance of the map's embedded schematype\n          if (p + 1 >= parts.length) {\n            return foundschema.$__schemaType;\n          }\n\n          if (foundschema.$__schemaType instanceof MongooseTypes.Mixed) {\n            return foundschema.$__schemaType;\n          }\n          if (foundschema.$__schemaType.schema != null) {\n            // Map of docs\n            const ret = search(parts.slice(p + 1), foundschema.$__schemaType.schema);\n            return ret;\n          }\n        }\n\n        foundschema.$fullPath = resultPath.join('.');\n\n        return foundschema;\n      }\n    }\n  }\n\n  // look for arrays\n  const parts = path.split('.');\n  for (let i = 0; i < parts.length; ++i) {\n    if (parts[i] === '$' || isArrayFilter(parts[i])) {\n      // Re: gh-5628, because `schema.path()` doesn't take $ into account.\n      parts[i] = '0';\n    }\n    if (numberRE.test(parts[i])) {\n      parts[i] = '$';\n    }\n  }\n  return search(parts, _this);\n};\n\n/*!\n * ignore\n */\n\nSchema.prototype._getPathType = function(path) {\n  const _this = this;\n  const pathschema = _this.path(path);\n\n  if (pathschema) {\n    return 'real';\n  }\n\n  function search(parts, schema) {\n    let p = parts.length + 1,\n        foundschema,\n        trypath;\n\n    while (p--) {\n      trypath = parts.slice(0, p).join('.');\n      foundschema = schema.path(trypath);\n      if (foundschema) {\n        if (foundschema.caster) {\n          // array of Mixed?\n          if (foundschema.caster instanceof MongooseTypes.Mixed) {\n            return { schema: foundschema, pathType: 'mixed' };\n          }\n\n          // Now that we found the array, we need to check if there\n          // are remaining document paths to look up for casting.\n          // Also we need to handle array.$.path since schema.path\n          // doesn't work for that.\n          // If there is no foundschema.schema we are dealing with\n          // a path like array.$\n          if (p !== parts.length && foundschema.schema) {\n            if (parts[p] === '$' || isArrayFilter(parts[p])) {\n              if (p === parts.length - 1) {\n                return { schema: foundschema, pathType: 'nested' };\n              }\n              // comments.$.comments.$.title\n              return search(parts.slice(p + 1), foundschema.schema);\n            }\n            // this is the last path of the selector\n            return search(parts.slice(p), foundschema.schema);\n          }\n          return {\n            schema: foundschema,\n            pathType: foundschema.$isSingleNested ? 'nested' : 'array'\n          };\n        }\n        return { schema: foundschema, pathType: 'real' };\n      } else if (p === parts.length && schema.nested[trypath]) {\n        return { schema: schema, pathType: 'nested' };\n      }\n    }\n    return { schema: foundschema || schema, pathType: 'undefined' };\n  }\n\n  // look for arrays\n  return search(path.split('.'), _this);\n};\n\n/*!\n * ignore\n */\n\nfunction isArrayFilter(piece) {\n  return piece.startsWith('$[') && piece.endsWith(']');\n}\n\n/**\n * Called by `compile()` _right before_ compiling. Good for making any changes to\n * the schema that should respect options set by plugins, like `id`\n * @method _preCompile\n * @memberOf Schema\n * @instance\n * @api private\n */\n\nSchema.prototype._preCompile = function _preCompile() {\n  idGetter(this);\n};\n\n/*!\n * Module exports.\n */\n\nmodule.exports = exports = Schema;\n\n// require down here because of reference issues\n\n/**\n * The various built-in Mongoose Schema Types.\n *\n * #### Example:\n *\n *     const mongoose = require('mongoose');\n *     const ObjectId = mongoose.Schema.Types.ObjectId;\n *\n * #### Types:\n *\n * - [String](https://mongoosejs.com/docs/schematypes.html#strings)\n * - [Number](https://mongoosejs.com/docs/schematypes.html#numbers)\n * - [Boolean](https://mongoosejs.com/docs/schematypes.html#booleans) | Bool\n * - [Array](https://mongoosejs.com/docs/schematypes.html#arrays)\n * - [Buffer](https://mongoosejs.com/docs/schematypes.html#buffers)\n * - [Date](https://mongoosejs.com/docs/schematypes.html#dates)\n * - [ObjectId](https://mongoosejs.com/docs/schematypes.html#objectids) | Oid\n * - [Mixed](https://mongoosejs.com/docs/schematypes.html#mixed)\n * - [UUID](https://mongoosejs.com/docs/schematypes.html#uuid)\n * - [BigInt](https://mongoosejs.com/docs/schematypes.html#bigint)\n *\n * Using this exposed access to the `Mixed` SchemaType, we can use them in our schema.\n *\n *     const Mixed = mongoose.Schema.Types.Mixed;\n *     new mongoose.Schema({ _user: Mixed })\n *\n * @api public\n */\n\nSchema.Types = MongooseTypes = __webpack_require__(/*! ./schema/index */ \"../server/node_modules/mongoose/lib/schema/index.js\");\n\n/*!\n * ignore\n */\n\nexports.ObjectId = MongooseTypes.ObjectId;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvc2NoZW1hLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0E7QUFDQTs7QUFFQSxxQkFBcUIsMERBQThCO0FBQ25ELGVBQWUsbUJBQU8sQ0FBQyxzREFBUTtBQUMvQixzQkFBc0IsbUJBQU8sQ0FBQyx5RkFBdUI7QUFDckQsbUJBQW1CLG1CQUFPLENBQUMsdUVBQWM7QUFDekMsMEJBQTBCLG1CQUFPLENBQUMscUdBQTZCO0FBQy9ELHVCQUF1QixtQkFBTyxDQUFDLCtGQUEwQjtBQUN6RCxvQkFBb0IsbUJBQU8sQ0FBQyx5RUFBZTtBQUMzQyxrQkFBa0IsbUJBQU8sQ0FBQyxtR0FBNEI7QUFDdEQsY0FBYyxtQkFBTyxDQUFDLDZFQUFpQjtBQUN2QyxZQUFZLG1CQUFPLENBQUMseUVBQWU7QUFDbkMsMkJBQTJCLG1CQUFPLENBQUMsdUdBQThCO0FBQ2pFLG1CQUFtQixtQkFBTyxDQUFDLHFHQUE2QjtBQUN4RCxvQ0FBb0MsbUJBQU8sQ0FBQyxxSUFBNkM7QUFDekYsaUJBQWlCLG1CQUFPLENBQUMsaUdBQTJCO0FBQ3BELGNBQWMsbUJBQU8sQ0FBQywyRkFBd0I7QUFDOUMsY0FBYyxtQkFBTyxDQUFDLG9EQUFPO0FBQzdCLGlDQUFpQyxtQkFBTyxDQUFDLHFJQUE2QztBQUN0Rix3QkFBd0IsbUJBQU8sQ0FBQyx1SEFBc0M7QUFDdEUsY0FBYyxtQkFBTyxDQUFDLDZEQUFTO0FBQy9CLG9CQUFvQixtQkFBTyxDQUFDLDJHQUFnQztBQUM1RCxhQUFhLG1CQUFPLENBQUMsa0JBQU07O0FBRTNCOztBQUVBOztBQUVBLG1CQUFtQixxSEFBK0M7QUFDbEUsc0JBQXNCLDhJQUF5RDtBQUMvRTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsY0FBYztBQUNoRCxtQ0FBbUMsOENBQThDO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixjQUFjLElBQUksNkJBQTZCO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcscUJBQXFCO0FBQ2hDLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBLHFDQUFxQyxLQUFLLHNCQUFzQjtBQUNoRSxpRUFBaUU7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLFdBQVcsUUFBUSxXQUFXO0FBQ2pFLG1CQUFtQixLQUFLO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsY0FBYyxJQUFJLFlBQVk7QUFDakUscUJBQXFCLEtBQUsscUJBQXFCO0FBQy9DO0FBQ0Esb0JBQW9CLGFBQWE7QUFDakMscUJBQXFCLEtBQUsscUJBQXFCLEtBQUssc0JBQXNCO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsY0FBYztBQUNqRDtBQUNBLHlCQUF5QjtBQUN6QiwyQkFBMkIsa0JBQWtCO0FBQzdDO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsV0FBVztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTs7QUFFQSw4QkFBOEI7O0FBRTlCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsMkJBQTJCO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLGtCQUFrQjtBQUNqRCw4QkFBOEI7QUFDOUI7QUFDQSxXQUFXLFVBQVU7QUFDckIsV0FBVyxRQUFRO0FBQ25CLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxzQkFBc0IsOEJBQThCO0FBQ3BELE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixvQkFBb0I7QUFDMUM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLDJCQUEyQjtBQUMxRDtBQUNBO0FBQ0E7QUFDQSwrQkFBK0Isa0JBQWtCO0FBQ2pELDhCQUE4QjtBQUM5QjtBQUNBLFdBQVcsVUFBVTtBQUNyQixXQUFXLFFBQVE7QUFDbkIsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZLFFBQVE7QUFDcEI7QUFDQTs7QUFFQTtBQUNBLG1EQUFtRDtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxpQkFBaUIsSUFBSSwwQkFBMEI7QUFDaEc7QUFDQSx3REFBd0QsaUJBQWlCLElBQUksMEJBQTBCO0FBQ3ZHO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLFdBQVc7QUFDbkQ7QUFDQSx3Q0FBd0MsbUNBQW1DO0FBQzNFLG9CQUFvQjtBQUNwQixvQ0FBb0M7QUFDcEM7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGtEQUFrRDtBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxjQUFjO0FBQ3pEO0FBQ0EsV0FBVyxlQUFlO0FBQzFCLFdBQVcsUUFBUTtBQUNuQixZQUFZLFFBQVE7QUFDcEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQsSUFBSTtBQUNqRSxrQ0FBa0MsSUFBSTtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQyxNQUFNO0FBQ047QUFDQSwwQkFBMEIsUUFBUSxnQkFBZ0I7QUFDbEQ7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtEQUFrRCxTQUFTLG9CQUFvQjtBQUMvRTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsV0FBVztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLGdCQUFnQjtBQUNsRDtBQUNBLHNCQUFzQjtBQUN0QixtQkFBbUI7QUFDbkI7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBLDhCQUE4QixXQUFXO0FBQ3pDO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxpQkFBaUI7QUFDNUIsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7O0FBRUE7QUFDQSxzQkFBc0IsZUFBZTtBQUNyQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsNENBQTRDO0FBQ2xGO0FBQ0EsK0JBQStCO0FBQy9CLHlCQUF5QixtQkFBbUI7QUFDNUM7QUFDQSw0QkFBNEI7QUFDNUIsMERBQTBELG1CQUFtQjtBQUM3RSwrQkFBK0IsbUJBQW1CO0FBQ2xEO0FBQ0E7QUFDQSx5QkFBeUIsVUFBVSxJQUFJLDhCQUE4QjtBQUNyRTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGVBQWU7QUFDMUIsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMkNBQTJDLFFBQVE7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osMkNBQTJDLFFBQVE7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsNENBQTRDO0FBQ2xGLHlCQUF5QixTQUFTO0FBQ2xDLHlCQUF5QixVQUFVO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyw0Q0FBNEM7QUFDbEYsK0JBQStCLDRCQUE0QixZQUFZLG1CQUFtQjtBQUMxRjtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFlBQVksUUFBUTtBQUNwQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGlCQUFpQjtBQUMvQztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNM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QUFDQTtBQUNBLDZCQUE2QixPQUFPO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFVBQVU7QUFDckIsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQixrQkFBa0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixRQUFRO0FBQ1IsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixjQUFjO0FBQzNDO0FBQ0E7QUFDQTs7QUFFQSwrQkFBK0IsbUJBQU8sQ0FBQywyRUFBZ0I7O0FBRXZEO0FBQ0E7QUFDQTs7QUFFQSxnQkFBZ0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbGllbnQvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvc2NoZW1hLmpzP2E3ZjEiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG4vKiFcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxuY29uc3QgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyO1xuY29uc3QgS2FyZWVtID0gcmVxdWlyZSgna2FyZWVtJyk7XG5jb25zdCBNb25nb29zZUVycm9yID0gcmVxdWlyZSgnLi9lcnJvci9tb25nb29zZUVycm9yJyk7XG5jb25zdCBTY2hlbWFUeXBlID0gcmVxdWlyZSgnLi9zY2hlbWFUeXBlJyk7XG5jb25zdCBTY2hlbWFUeXBlT3B0aW9ucyA9IHJlcXVpcmUoJy4vb3B0aW9ucy9zY2hlbWFUeXBlT3B0aW9ucycpO1xuY29uc3QgVmlydHVhbE9wdGlvbnMgPSByZXF1aXJlKCcuL29wdGlvbnMvdmlydHVhbE9wdGlvbnMnKTtcbmNvbnN0IFZpcnR1YWxUeXBlID0gcmVxdWlyZSgnLi92aXJ0dWFsVHlwZScpO1xuY29uc3QgYWRkQXV0b0lkID0gcmVxdWlyZSgnLi9oZWxwZXJzL3NjaGVtYS9hZGRBdXRvSWQnKTtcbmNvbnN0IGNsb25lID0gcmVxdWlyZSgnLi9oZWxwZXJzL2Nsb25lJyk7XG5jb25zdCBnZXQgPSByZXF1aXJlKCcuL2hlbHBlcnMvZ2V0Jyk7XG5jb25zdCBnZXRDb25zdHJ1Y3Rvck5hbWUgPSByZXF1aXJlKCcuL2hlbHBlcnMvZ2V0Q29uc3RydWN0b3JOYW1lJyk7XG5jb25zdCBnZXRJbmRleGVzID0gcmVxdWlyZSgnLi9oZWxwZXJzL3NjaGVtYS9nZXRJbmRleGVzJyk7XG5jb25zdCBoYW5kbGVSZWFkUHJlZmVyZW5jZUFsaWFzZXMgPSByZXF1aXJlKCcuL2hlbHBlcnMvcXVlcnkvaGFuZGxlUmVhZFByZWZlcmVuY2VBbGlhc2VzJyk7XG5jb25zdCBpZEdldHRlciA9IHJlcXVpcmUoJy4vaGVscGVycy9zY2hlbWEvaWRHZXR0ZXInKTtcbmNvbnN0IG1lcmdlID0gcmVxdWlyZSgnLi9oZWxwZXJzL3NjaGVtYS9tZXJnZScpO1xuY29uc3QgbXBhdGggPSByZXF1aXJlKCdtcGF0aCcpO1xuY29uc3Qgc2V0UG9wdWxhdGVkVmlydHVhbFZhbHVlID0gcmVxdWlyZSgnLi9oZWxwZXJzL3BvcHVsYXRlL3NldFBvcHVsYXRlZFZpcnR1YWxWYWx1ZScpO1xuY29uc3Qgc2V0dXBUaW1lc3RhbXBzID0gcmVxdWlyZSgnLi9oZWxwZXJzL3RpbWVzdGFtcHMvc2V0dXBUaW1lc3RhbXBzJyk7XG5jb25zdCB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcbmNvbnN0IHZhbGlkYXRlUmVmID0gcmVxdWlyZSgnLi9oZWxwZXJzL3BvcHVsYXRlL3ZhbGlkYXRlUmVmJyk7XG5jb25zdCB1dGlsID0gcmVxdWlyZSgndXRpbCcpO1xuXG5jb25zdCBoYXNOdW1lcmljU3VicGF0aFJlZ2V4ID0gL1xcLlxcZCsoXFwufCQpLztcblxubGV0IE1vbmdvb3NlVHlwZXM7XG5cbmNvbnN0IHF1ZXJ5SG9va3MgPSByZXF1aXJlKCcuL2NvbnN0YW50cycpLnF1ZXJ5TWlkZGxld2FyZUZ1bmN0aW9ucztcbmNvbnN0IGRvY3VtZW50SG9va3MgPSByZXF1aXJlKCcuL2hlbHBlcnMvbW9kZWwvYXBwbHlIb29rcycpLm1pZGRsZXdhcmVGdW5jdGlvbnM7XG5jb25zdCBob29rTmFtZXMgPSBxdWVyeUhvb2tzLmNvbmNhdChkb2N1bWVudEhvb2tzKS5cbiAgcmVkdWNlKChzLCBob29rKSA9PiBzLmFkZChob29rKSwgbmV3IFNldCgpKTtcblxuY29uc3QgaXNQT0pPID0gdXRpbHMuaXNQT0pPO1xuXG5sZXQgaWQgPSAwO1xuXG5jb25zdCBudW1iZXJSRSA9IC9eXFxkKyQvO1xuXG4vKipcbiAqIFNjaGVtYSBjb25zdHJ1Y3Rvci5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IGNoaWxkID0gbmV3IFNjaGVtYSh7IG5hbWU6IFN0cmluZyB9KTtcbiAqICAgICBjb25zdCBzY2hlbWEgPSBuZXcgU2NoZW1hKHsgbmFtZTogU3RyaW5nLCBhZ2U6IE51bWJlciwgY2hpbGRyZW46IFtjaGlsZF0gfSk7XG4gKiAgICAgY29uc3QgVHJlZSA9IG1vbmdvb3NlLm1vZGVsKCdUcmVlJywgc2NoZW1hKTtcbiAqXG4gKiAgICAgLy8gc2V0dGluZyBzY2hlbWEgb3B0aW9uc1xuICogICAgIG5ldyBTY2hlbWEoeyBuYW1lOiBTdHJpbmcgfSwgeyBpZDogZmFsc2UsIGF1dG9JbmRleDogZmFsc2UgfSlcbiAqXG4gKiAjIyMjIE9wdGlvbnM6XG4gKlxuICogLSBbYXV0b0luZGV4XShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvZ3VpZGUuaHRtbCNhdXRvSW5kZXgpOiBib29sIC0gZGVmYXVsdHMgdG8gbnVsbCAod2hpY2ggbWVhbnMgdXNlIHRoZSBjb25uZWN0aW9uJ3MgYXV0b0luZGV4IG9wdGlvbilcbiAqIC0gW2F1dG9DcmVhdGVdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9ndWlkZS5odG1sI2F1dG9DcmVhdGUpOiBib29sIC0gZGVmYXVsdHMgdG8gbnVsbCAod2hpY2ggbWVhbnMgdXNlIHRoZSBjb25uZWN0aW9uJ3MgYXV0b0NyZWF0ZSBvcHRpb24pXG4gKiAtIFtidWZmZXJDb21tYW5kc10oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2d1aWRlLmh0bWwjYnVmZmVyQ29tbWFuZHMpOiBib29sIC0gZGVmYXVsdHMgdG8gdHJ1ZVxuICogLSBbYnVmZmVyVGltZW91dE1TXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvZ3VpZGUuaHRtbCNidWZmZXJUaW1lb3V0TVMpOiBudW1iZXIgLSBkZWZhdWx0cyB0byAxMDAwMCAoMTAgc2Vjb25kcykuIElmIGBidWZmZXJDb21tYW5kc2AgaXMgZW5hYmxlZCwgdGhlIGFtb3VudCBvZiB0aW1lIE1vbmdvb3NlIHdpbGwgd2FpdCBmb3IgY29ubmVjdGl2aXR5IHRvIGJlIHJlc3RhYmxpc2hlZCBiZWZvcmUgZXJyb3Jpbmcgb3V0LlxuICogLSBbY2FwcGVkXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvZ3VpZGUuaHRtbCNjYXBwZWQpOiBib29sIHwgbnVtYmVyIHwgb2JqZWN0IC0gZGVmYXVsdHMgdG8gZmFsc2VcbiAqIC0gW2NvbGxlY3Rpb25dKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9ndWlkZS5odG1sI2NvbGxlY3Rpb24pOiBzdHJpbmcgLSBubyBkZWZhdWx0XG4gKiAtIFtkaXNjcmltaW5hdG9yS2V5XShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvZ3VpZGUuaHRtbCNkaXNjcmltaW5hdG9yS2V5KTogc3RyaW5nIC0gZGVmYXVsdHMgdG8gYF9fdGBcbiAqIC0gW2lkXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvZ3VpZGUuaHRtbCNpZCk6IGJvb2wgLSBkZWZhdWx0cyB0byB0cnVlXG4gKiAtIFtfaWRdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9ndWlkZS5odG1sI19pZCk6IGJvb2wgLSBkZWZhdWx0cyB0byB0cnVlXG4gKiAtIFttaW5pbWl6ZV0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2d1aWRlLmh0bWwjbWluaW1pemUpOiBib29sIC0gY29udHJvbHMgW2RvY3VtZW50I3RvT2JqZWN0XShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvYXBpL2RvY3VtZW50Lmh0bWwjRG9jdW1lbnQucHJvdG90eXBlLnRvT2JqZWN0KCkpIGJlaGF2aW9yIHdoZW4gY2FsbGVkIG1hbnVhbGx5IC0gZGVmYXVsdHMgdG8gdHJ1ZVxuICogLSBbcmVhZF0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2d1aWRlLmh0bWwjcmVhZCk6IHN0cmluZ1xuICogLSBbd3JpdGVDb25jZXJuXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvZ3VpZGUuaHRtbCN3cml0ZUNvbmNlcm4pOiBvYmplY3QgLSBkZWZhdWx0cyB0byBudWxsLCB1c2UgdG8gb3ZlcnJpZGUgW3RoZSBNb25nb0RCIHNlcnZlcidzIGRlZmF1bHQgd3JpdGUgY29uY2VybiBzZXR0aW5nc10oaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvcmVmZXJlbmNlL3dyaXRlLWNvbmNlcm4vKVxuICogLSBbc2hhcmRLZXldKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9ndWlkZS5odG1sI3NoYXJkS2V5KTogb2JqZWN0IC0gZGVmYXVsdHMgdG8gYG51bGxgXG4gKiAtIFtzdHJpY3RdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9ndWlkZS5odG1sI3N0cmljdCk6IGJvb2wgLSBkZWZhdWx0cyB0byB0cnVlXG4gKiAtIFtzdHJpY3RRdWVyeV0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2d1aWRlLmh0bWwjc3RyaWN0UXVlcnkpOiBib29sIC0gZGVmYXVsdHMgdG8gZmFsc2VcbiAqIC0gW3RvSlNPTl0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2d1aWRlLmh0bWwjdG9KU09OKSAtIG9iamVjdCAtIG5vIGRlZmF1bHRcbiAqIC0gW3RvT2JqZWN0XShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvZ3VpZGUuaHRtbCN0b09iamVjdCkgLSBvYmplY3QgLSBubyBkZWZhdWx0XG4gKiAtIFt0eXBlS2V5XShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvZ3VpZGUuaHRtbCN0eXBlS2V5KSAtIHN0cmluZyAtIGRlZmF1bHRzIHRvICd0eXBlJ1xuICogLSBbdmFsaWRhdGVCZWZvcmVTYXZlXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvZ3VpZGUuaHRtbCN2YWxpZGF0ZUJlZm9yZVNhdmUpIC0gYm9vbCAtIGRlZmF1bHRzIHRvIGB0cnVlYFxuICogLSBbdmFsaWRhdGVNb2RpZmllZE9ubHldKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvZG9jdW1lbnQuaHRtbCNEb2N1bWVudC5wcm90b3R5cGUudmFsaWRhdGUoKSkgLSBib29sIC0gZGVmYXVsdHMgdG8gYGZhbHNlYFxuICogLSBbdmVyc2lvbktleV0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2d1aWRlLmh0bWwjdmVyc2lvbktleSk6IHN0cmluZyBvciBvYmplY3QgLSBkZWZhdWx0cyB0byBcIl9fdlwiXG4gKiAtIFtvcHRpbWlzdGljQ29uY3VycmVuY3ldKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9ndWlkZS5odG1sI29wdGltaXN0aWNDb25jdXJyZW5jeSk6IGJvb2wgLSBkZWZhdWx0cyB0byBmYWxzZS4gU2V0IHRvIHRydWUgdG8gZW5hYmxlIFtvcHRpbWlzdGljIGNvbmN1cnJlbmN5XShodHRwczovL3RoZWNvZGViYXJiYXJpYW4uY29tL3doYXRzLW5ldy1pbi1tb25nb29zZS01LTEwLW9wdGltaXN0aWMtY29uY3VycmVuY3kuaHRtbCkuXG4gKiAtIFtjb2xsYXRpb25dKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9ndWlkZS5odG1sI2NvbGxhdGlvbik6IG9iamVjdCAtIGRlZmF1bHRzIHRvIG51bGwgKHdoaWNoIG1lYW5zIHVzZSBubyBjb2xsYXRpb24pXG4gKiAtIFt0aW1lc2VyaWVzXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvZ3VpZGUuaHRtbCN0aW1lc2VyaWVzKTogb2JqZWN0IC0gZGVmYXVsdHMgdG8gbnVsbCAod2hpY2ggbWVhbnMgdGhpcyBzY2hlbWEncyBjb2xsZWN0aW9uIHdvbid0IGJlIGEgdGltZXNlcmllcyBjb2xsZWN0aW9uKVxuICogLSBbc2VsZWN0UG9wdWxhdGVkUGF0aHNdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9ndWlkZS5odG1sI3NlbGVjdFBvcHVsYXRlZFBhdGhzKTogYm9vbGVhbiAtIGRlZmF1bHRzIHRvIGB0cnVlYFxuICogLSBbc2tpcFZlcnNpb25pbmddKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9ndWlkZS5odG1sI3NraXBWZXJzaW9uaW5nKTogb2JqZWN0IC0gcGF0aHMgdG8gZXhjbHVkZSBmcm9tIHZlcnNpb25pbmdcbiAqIC0gW3RpbWVzdGFtcHNdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9ndWlkZS5odG1sI3RpbWVzdGFtcHMpOiBvYmplY3Qgb3IgYm9vbGVhbiAtIGRlZmF1bHRzIHRvIGBmYWxzZWAuIElmIHRydWUsIE1vbmdvb3NlIGFkZHMgYGNyZWF0ZWRBdGAgYW5kIGB1cGRhdGVkQXRgIHByb3BlcnRpZXMgdG8geW91ciBzY2hlbWEgYW5kIG1hbmFnZXMgdGhvc2UgcHJvcGVydGllcyBmb3IgeW91LlxuICogLSBbcGx1Z2luVGFnc10oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2d1aWRlLmh0bWwjcGx1Z2luVGFncyk6IGFycmF5IG9mIHN0cmluZ3MgLSBkZWZhdWx0cyB0byBgdW5kZWZpbmVkYC4gSWYgc2V0IGFuZCBwbHVnaW4gY2FsbGVkIHdpdGggYHRhZ3NgIG9wdGlvbiwgd2lsbCBvbmx5IGFwcGx5IHRoYXQgcGx1Z2luIHRvIHNjaGVtYXMgd2l0aCBhIG1hdGNoaW5nIHRhZy5cbiAqIC0gW3ZpcnR1YWxzXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvdHV0b3JpYWxzL3ZpcnR1YWxzLmh0bWwjdmlydHVhbHMtdmlhLXNjaGVtYS1vcHRpb25zKTogb2JqZWN0IC0gdmlydHVhbHMgdG8gZGVmaW5lLCBhbGlhcyBmb3IgW2AudmlydHVhbGBdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvc2NoZW1hLmh0bWwjU2NoZW1hLnByb3RvdHlwZS52aXJ0dWFsKCkpXG4gKiAtIFtjb2xsZWN0aW9uT3B0aW9uc106IG9iamVjdCB3aXRoIG9wdGlvbnMgcGFzc2VkIHRvIFtgY3JlYXRlQ29sbGVjdGlvbigpYF0oaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvcmVmZXJlbmNlL21ldGhvZC9kYi5jcmVhdGVDb2xsZWN0aW9uLykgd2hlbiBjYWxsaW5nIGBNb2RlbC5jcmVhdGVDb2xsZWN0aW9uKClgIG9yIGBhdXRvQ3JlYXRlYCBzZXQgdG8gdHJ1ZS5cbiAqXG4gKiAjIyMjIE9wdGlvbnMgZm9yIE5lc3RlZCBTY2hlbWFzOlxuICpcbiAqIC0gYGV4Y2x1ZGVJbmRleGVzYDogYm9vbCAtIGRlZmF1bHRzIHRvIGBmYWxzZWAuIElmIGB0cnVlYCwgc2tpcCBidWlsZGluZyBpbmRleGVzIG9uIHRoaXMgc2NoZW1hJ3MgcGF0aHMuXG4gKlxuICogIyMjIyBOb3RlOlxuICpcbiAqIF9XaGVuIG5lc3Rpbmcgc2NoZW1hcywgKGBjaGlsZHJlbmAgaW4gdGhlIGV4YW1wbGUgYWJvdmUpLCBhbHdheXMgZGVjbGFyZSB0aGUgY2hpbGQgc2NoZW1hIGZpcnN0IGJlZm9yZSBwYXNzaW5nIGl0IGludG8gaXRzIHBhcmVudC5fXG4gKlxuICogQHBhcmFtIHtPYmplY3R8U2NoZW1hfEFycmF5fSBbZGVmaW5pdGlvbl0gQ2FuIGJlIG9uZSBvZjogb2JqZWN0IGRlc2NyaWJpbmcgc2NoZW1hIHBhdGhzLCBvciBzY2hlbWEgdG8gY29weSwgb3IgYXJyYXkgb2Ygb2JqZWN0cyBhbmQgc2NoZW1hc1xuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQGluaGVyaXRzIE5vZGVKUyBFdmVudEVtaXR0ZXIgaHR0cHM6Ly9ub2RlanMub3JnL2FwaS9ldmVudHMuaHRtbCNjbGFzcy1ldmVudGVtaXR0ZXJcbiAqIEBldmVudCBgaW5pdGA6IEVtaXR0ZWQgYWZ0ZXIgdGhlIHNjaGVtYSBpcyBjb21waWxlZCBpbnRvIGEgYE1vZGVsYC5cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gU2NoZW1hKG9iaiwgb3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgU2NoZW1hKSkge1xuICAgIHJldHVybiBuZXcgU2NoZW1hKG9iaiwgb3B0aW9ucyk7XG4gIH1cblxuICB0aGlzLm9iaiA9IG9iajtcbiAgdGhpcy5wYXRocyA9IHt9O1xuICB0aGlzLmFsaWFzZXMgPSB7fTtcbiAgdGhpcy5zdWJwYXRocyA9IHt9O1xuICB0aGlzLnZpcnR1YWxzID0ge307XG4gIHRoaXMuc2luZ2xlTmVzdGVkUGF0aHMgPSB7fTtcbiAgdGhpcy5uZXN0ZWQgPSB7fTtcbiAgdGhpcy5pbmhlcml0cyA9IHt9O1xuICB0aGlzLmNhbGxRdWV1ZSA9IFtdO1xuICB0aGlzLl9pbmRleGVzID0gW107XG4gIHRoaXMuX3NlYXJjaEluZGV4ZXMgPSBbXTtcbiAgdGhpcy5tZXRob2RzID0gKG9wdGlvbnMgJiYgb3B0aW9ucy5tZXRob2RzKSB8fCB7fTtcbiAgdGhpcy5tZXRob2RPcHRpb25zID0ge307XG4gIHRoaXMuc3RhdGljcyA9IChvcHRpb25zICYmIG9wdGlvbnMuc3RhdGljcykgfHwge307XG4gIHRoaXMudHJlZSA9IHt9O1xuICB0aGlzLnF1ZXJ5ID0gKG9wdGlvbnMgJiYgb3B0aW9ucy5xdWVyeSkgfHwge307XG4gIHRoaXMuY2hpbGRTY2hlbWFzID0gW107XG4gIHRoaXMucGx1Z2lucyA9IFtdO1xuICAvLyBGb3IgaW50ZXJuYWwgZGVidWdnaW5nLiBEbyBub3QgdXNlIHRoaXMgdG8gdHJ5IHRvIHNhdmUgYSBzY2hlbWEgaW4gTURCLlxuICB0aGlzLiRpZCA9ICsraWQ7XG4gIHRoaXMubWFwUGF0aHMgPSBbXTtcblxuICB0aGlzLnMgPSB7XG4gICAgaG9va3M6IG5ldyBLYXJlZW0oKVxuICB9O1xuICB0aGlzLm9wdGlvbnMgPSB0aGlzLmRlZmF1bHRPcHRpb25zKG9wdGlvbnMpO1xuXG4gIC8vIGJ1aWxkIHBhdGhzXG4gIGlmIChBcnJheS5pc0FycmF5KG9iaikpIHtcbiAgICBmb3IgKGNvbnN0IGRlZmluaXRpb24gb2Ygb2JqKSB7XG4gICAgICB0aGlzLmFkZChkZWZpbml0aW9uKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAob2JqKSB7XG4gICAgdGhpcy5hZGQob2JqKTtcbiAgfVxuXG4gIC8vIGJ1aWxkIHZpcnR1YWwgcGF0aHNcbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy52aXJ0dWFscykge1xuICAgIGNvbnN0IHZpcnR1YWxzID0gb3B0aW9ucy52aXJ0dWFscztcbiAgICBjb25zdCBwYXRoTmFtZXMgPSBPYmplY3Qua2V5cyh2aXJ0dWFscyk7XG4gICAgZm9yIChjb25zdCBwYXRoTmFtZSBvZiBwYXRoTmFtZXMpIHtcbiAgICAgIGNvbnN0IHBhdGhPcHRpb25zID0gdmlydHVhbHNbcGF0aE5hbWVdLm9wdGlvbnMgPyB2aXJ0dWFsc1twYXRoTmFtZV0ub3B0aW9ucyA6IHVuZGVmaW5lZDtcbiAgICAgIGNvbnN0IHZpcnR1YWwgPSB0aGlzLnZpcnR1YWwocGF0aE5hbWUsIHBhdGhPcHRpb25zKTtcblxuICAgICAgaWYgKHZpcnR1YWxzW3BhdGhOYW1lXS5nZXQpIHtcbiAgICAgICAgdmlydHVhbC5nZXQodmlydHVhbHNbcGF0aE5hbWVdLmdldCk7XG4gICAgICB9XG5cbiAgICAgIGlmICh2aXJ0dWFsc1twYXRoTmFtZV0uc2V0KSB7XG4gICAgICAgIHZpcnR1YWwuc2V0KHZpcnR1YWxzW3BhdGhOYW1lXS5zZXQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIGNoZWNrIGlmIF9pZCdzIHZhbHVlIGlzIGEgc3ViZG9jdW1lbnQgKGdoLTIyNzYpXG4gIGNvbnN0IF9pZFN1YkRvYyA9IG9iaiAmJiBvYmouX2lkICYmIHV0aWxzLmlzT2JqZWN0KG9iai5faWQpO1xuXG4gIC8vIGVuc3VyZSB0aGUgZG9jdW1lbnRzIGdldCBhbiBhdXRvIF9pZCB1bmxlc3MgZGlzYWJsZWRcbiAgY29uc3QgYXV0b19pZCA9ICF0aGlzLnBhdGhzWydfaWQnXSAmJlxuICAgICAgKHRoaXMub3B0aW9ucy5faWQpICYmICFfaWRTdWJEb2M7XG5cbiAgaWYgKGF1dG9faWQpIHtcbiAgICBhZGRBdXRvSWQodGhpcyk7XG4gIH1cblxuICB0aGlzLnNldHVwVGltZXN0YW1wKHRoaXMub3B0aW9ucy50aW1lc3RhbXBzKTtcbn1cblxuLyoqXG4gKiBDcmVhdGUgdmlydHVhbCBwcm9wZXJ0aWVzIHdpdGggYWxpYXMgZmllbGRcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBhbGlhc0ZpZWxkcyhzY2hlbWEsIHBhdGhzKSB7XG4gIGZvciAoY29uc3QgcGF0aCBvZiBPYmplY3Qua2V5cyhwYXRocykpIHtcbiAgICBsZXQgYWxpYXMgPSBudWxsO1xuICAgIGlmIChwYXRoc1twYXRoXSAhPSBudWxsKSB7XG4gICAgICBhbGlhcyA9IHBhdGhzW3BhdGhdO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBvcHRpb25zID0gZ2V0KHNjaGVtYS5wYXRoc1twYXRoXSwgJ29wdGlvbnMnKTtcbiAgICAgIGlmIChvcHRpb25zID09IG51bGwpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGFsaWFzID0gb3B0aW9ucy5hbGlhcztcbiAgICB9XG5cbiAgICBpZiAoIWFsaWFzKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBjb25zdCBwcm9wID0gc2NoZW1hLnBhdGhzW3BhdGhdLnBhdGg7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYWxpYXMpKSB7XG4gICAgICBmb3IgKGNvbnN0IGEgb2YgYWxpYXMpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBhICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCB2YWx1ZSBmb3IgYWxpYXMgb3B0aW9uIG9uICcgKyBwcm9wICsgJywgZ290ICcgKyBhKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHNjaGVtYS5hbGlhc2VzW2FdID0gcHJvcDtcblxuICAgICAgICBzY2hlbWEuXG4gICAgICAgICAgdmlydHVhbChhKS5cbiAgICAgICAgICBnZXQoKGZ1bmN0aW9uKHApIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiB0aGlzLmdldCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmdldChwKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gdGhpc1twXTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSkocHJvcCkpLlxuICAgICAgICAgIHNldCgoZnVuY3Rpb24ocCkge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJHNldChwLCB2KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSkocHJvcCkpO1xuICAgICAgfVxuXG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGFsaWFzICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHZhbHVlIGZvciBhbGlhcyBvcHRpb24gb24gJyArIHByb3AgKyAnLCBnb3QgJyArIGFsaWFzKTtcbiAgICB9XG5cbiAgICBzY2hlbWEuYWxpYXNlc1thbGlhc10gPSBwcm9wO1xuXG4gICAgc2NoZW1hLlxuICAgICAgdmlydHVhbChhbGlhcykuXG4gICAgICBnZXQoKGZ1bmN0aW9uKHApIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGlmICh0eXBlb2YgdGhpcy5nZXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldChwKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRoaXNbcF07XG4gICAgICAgIH07XG4gICAgICB9KShwcm9wKSkuXG4gICAgICBzZXQoKGZ1bmN0aW9uKHApIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy4kc2V0KHAsIHYpO1xuICAgICAgICB9O1xuICAgICAgfSkocHJvcCkpO1xuICB9XG59XG5cbi8qIVxuICogSW5oZXJpdCBmcm9tIEV2ZW50RW1pdHRlci5cbiAqL1xuU2NoZW1hLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRXZlbnRFbWl0dGVyLnByb3RvdHlwZSk7XG5TY2hlbWEucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gU2NoZW1hO1xuU2NoZW1hLnByb3RvdHlwZS5pbnN0YW5jZU9mU2NoZW1hID0gdHJ1ZTtcblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoU2NoZW1hLnByb3RvdHlwZSwgJyRzY2hlbWFUeXBlJywge1xuICBjb25maWd1cmFibGU6IGZhbHNlLFxuICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgd3JpdGFibGU6IHRydWVcbn0pO1xuXG4vKipcbiAqIEFycmF5IG9mIGNoaWxkIHNjaGVtYXMgKGZyb20gZG9jdW1lbnQgYXJyYXlzIGFuZCBzaW5nbGUgbmVzdGVkIHN1YmRvY3MpXG4gKiBhbmQgdGhlaXIgY29ycmVzcG9uZGluZyBjb21waWxlZCBtb2RlbHMuIEVhY2ggZWxlbWVudCBvZiB0aGUgYXJyYXkgaXNcbiAqIGFuIG9iamVjdCB3aXRoIDIgcHJvcGVydGllczogYHNjaGVtYWAgYW5kIGBtb2RlbGAuXG4gKlxuICogVGhpcyBwcm9wZXJ0eSBpcyB0eXBpY2FsbHkgb25seSB1c2VmdWwgZm9yIHBsdWdpbiBhdXRob3JzIGFuZCBhZHZhbmNlZCB1c2Vycy5cbiAqIFlvdSBkbyBub3QgbmVlZCB0byBpbnRlcmFjdCB3aXRoIHRoaXMgcHJvcGVydHkgYXQgYWxsIHRvIHVzZSBtb25nb29zZS5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICogQHByb3BlcnR5IGNoaWxkU2NoZW1hc1xuICogQG1lbWJlck9mIFNjaGVtYVxuICogQGluc3RhbmNlXG4gKi9cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFNjaGVtYS5wcm90b3R5cGUsICdjaGlsZFNjaGVtYXMnLCB7XG4gIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gIGVudW1lcmFibGU6IHRydWUsXG4gIHdyaXRhYmxlOiB0cnVlXG59KTtcblxuLyoqXG4gKiBPYmplY3QgY29udGFpbmluZyBhbGwgdmlydHVhbHMgZGVmaW5lZCBvbiB0aGlzIHNjaGVtYS5cbiAqIFRoZSBvYmplY3RzJyBrZXlzIGFyZSB0aGUgdmlydHVhbCBwYXRocyBhbmQgdmFsdWVzIGFyZSBpbnN0YW5jZXMgb2YgYFZpcnR1YWxUeXBlYC5cbiAqXG4gKiBUaGlzIHByb3BlcnR5IGlzIHR5cGljYWxseSBvbmx5IHVzZWZ1bCBmb3IgcGx1Z2luIGF1dGhvcnMgYW5kIGFkdmFuY2VkIHVzZXJzLlxuICogWW91IGRvIG5vdCBuZWVkIHRvIGludGVyYWN0IHdpdGggdGhpcyBwcm9wZXJ0eSBhdCBhbGwgdG8gdXNlIG1vbmdvb3NlLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgY29uc3Qgc2NoZW1hID0gbmV3IFNjaGVtYSh7fSk7XG4gKiAgICAgc2NoZW1hLnZpcnR1YWwoJ2Fuc3dlcicpLmdldCgoKSA9PiA0Mik7XG4gKlxuICogICAgIGNvbnNvbGUubG9nKHNjaGVtYS52aXJ0dWFscyk7IC8vIHsgYW5zd2VyOiBWaXJ0dWFsVHlwZSB7IHBhdGg6ICdhbnN3ZXInLCAuLi4gfSB9XG4gKiAgICAgY29uc29sZS5sb2coc2NoZW1hLnZpcnR1YWxzWydhbnN3ZXInXS5nZXR0ZXJzWzBdLmNhbGwoKSk7IC8vIDQyXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqIEBwcm9wZXJ0eSB2aXJ0dWFsc1xuICogQG1lbWJlck9mIFNjaGVtYVxuICogQGluc3RhbmNlXG4gKi9cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFNjaGVtYS5wcm90b3R5cGUsICd2aXJ0dWFscycsIHtcbiAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgd3JpdGFibGU6IHRydWVcbn0pO1xuXG4vKipcbiAqIFRoZSBvcmlnaW5hbCBvYmplY3QgcGFzc2VkIHRvIHRoZSBzY2hlbWEgY29uc3RydWN0b3JcbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IHNjaGVtYSA9IG5ldyBTY2hlbWEoeyBhOiBTdHJpbmcgfSkuYWRkKHsgYjogU3RyaW5nIH0pO1xuICogICAgIHNjaGVtYS5vYmo7IC8vIHsgYTogU3RyaW5nIH1cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICogQHByb3BlcnR5IG9ialxuICogQG1lbWJlck9mIFNjaGVtYVxuICogQGluc3RhbmNlXG4gKi9cblxuU2NoZW1hLnByb3RvdHlwZS5vYmo7XG5cbi8qKlxuICogVGhlIHBhdGhzIGRlZmluZWQgb24gdGhpcyBzY2hlbWEuIFRoZSBrZXlzIGFyZSB0aGUgdG9wLWxldmVsIHBhdGhzXG4gKiBpbiB0aGlzIHNjaGVtYSwgYW5kIHRoZSB2YWx1ZXMgYXJlIGluc3RhbmNlcyBvZiB0aGUgU2NoZW1hVHlwZSBjbGFzcy5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IHNjaGVtYSA9IG5ldyBTY2hlbWEoeyBuYW1lOiBTdHJpbmcgfSwgeyBfaWQ6IGZhbHNlIH0pO1xuICogICAgIHNjaGVtYS5wYXRoczsgLy8geyBuYW1lOiBTY2hlbWFTdHJpbmcgeyAuLi4gfSB9XG4gKlxuICogICAgIHNjaGVtYS5hZGQoeyBhZ2U6IE51bWJlciB9KTtcbiAqICAgICBzY2hlbWEucGF0aHM7IC8vIHsgbmFtZTogU2NoZW1hU3RyaW5nIHsgLi4uIH0sIGFnZTogU2NoZW1hTnVtYmVyIHsgLi4uIH0gfVxuICpcbiAqIEBhcGkgcHVibGljXG4gKiBAcHJvcGVydHkgcGF0aHNcbiAqIEBtZW1iZXJPZiBTY2hlbWFcbiAqIEBpbnN0YW5jZVxuICovXG5cblNjaGVtYS5wcm90b3R5cGUucGF0aHM7XG5cbi8qKlxuICogU2NoZW1hIGFzIGEgdHJlZVxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAge1xuICogICAgICAgICAnX2lkJyAgICAgOiBPYmplY3RJZFxuICogICAgICAgLCAnbmVzdGVkJyAgOiB7XG4gKiAgICAgICAgICAgICAna2V5JyA6IFN0cmluZ1xuICogICAgICAgICB9XG4gKiAgICAgfVxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICogQHByb3BlcnR5IHRyZWVcbiAqIEBtZW1iZXJPZiBTY2hlbWFcbiAqIEBpbnN0YW5jZVxuICovXG5cblNjaGVtYS5wcm90b3R5cGUudHJlZTtcblxuLyoqXG4gKiBSZXR1cm5zIGEgZGVlcCBjb3B5IG9mIHRoZSBzY2hlbWFcbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IHNjaGVtYSA9IG5ldyBTY2hlbWEoeyBuYW1lOiBTdHJpbmcgfSk7XG4gKiAgICAgY29uc3QgY2xvbmUgPSBzY2hlbWEuY2xvbmUoKTtcbiAqICAgICBjbG9uZSA9PT0gc2NoZW1hOyAvLyBmYWxzZVxuICogICAgIGNsb25lLnBhdGgoJ25hbWUnKTsgLy8gU2NoZW1hU3RyaW5nIHsgLi4uIH1cbiAqXG4gKiBAcmV0dXJuIHtTY2hlbWF9IHRoZSBjbG9uZWQgc2NoZW1hXG4gKiBAYXBpIHB1YmxpY1xuICogQG1lbWJlck9mIFNjaGVtYVxuICogQGluc3RhbmNlXG4gKi9cblxuU2NoZW1hLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uKCkge1xuICBjb25zdCBzID0gdGhpcy5fY2xvbmUoKTtcblxuICAvLyBCdWJibGUgdXAgYGluaXRgIGZvciBiYWNrd2FyZHMgY29tcGF0XG4gIHMub24oJ2luaXQnLCB2ID0+IHRoaXMuZW1pdCgnaW5pdCcsIHYpKTtcblxuICByZXR1cm4gcztcbn07XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxuU2NoZW1hLnByb3RvdHlwZS5fY2xvbmUgPSBmdW5jdGlvbiBfY2xvbmUoQ29uc3RydWN0b3IpIHtcbiAgQ29uc3RydWN0b3IgPSBDb25zdHJ1Y3RvciB8fCAodGhpcy5iYXNlID09IG51bGwgPyBTY2hlbWEgOiB0aGlzLmJhc2UuU2NoZW1hKTtcblxuICBjb25zdCBzID0gbmV3IENvbnN0cnVjdG9yKHt9LCB0aGlzLl91c2VyUHJvdmlkZWRPcHRpb25zKTtcbiAgcy5iYXNlID0gdGhpcy5iYXNlO1xuICBzLm9iaiA9IHRoaXMub2JqO1xuICBzLm9wdGlvbnMgPSBjbG9uZSh0aGlzLm9wdGlvbnMpO1xuICBzLmNhbGxRdWV1ZSA9IHRoaXMuY2FsbFF1ZXVlLm1hcChmdW5jdGlvbihmKSB7IHJldHVybiBmOyB9KTtcbiAgcy5tZXRob2RzID0gY2xvbmUodGhpcy5tZXRob2RzKTtcbiAgcy5tZXRob2RPcHRpb25zID0gY2xvbmUodGhpcy5tZXRob2RPcHRpb25zKTtcbiAgcy5zdGF0aWNzID0gY2xvbmUodGhpcy5zdGF0aWNzKTtcbiAgcy5xdWVyeSA9IGNsb25lKHRoaXMucXVlcnkpO1xuICBzLnBsdWdpbnMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCh0aGlzLnBsdWdpbnMpO1xuICBzLl9pbmRleGVzID0gY2xvbmUodGhpcy5faW5kZXhlcyk7XG4gIHMuX3NlYXJjaEluZGV4ZXMgPSBjbG9uZSh0aGlzLl9zZWFyY2hJbmRleGVzKTtcbiAgcy5zLmhvb2tzID0gdGhpcy5zLmhvb2tzLmNsb25lKCk7XG5cbiAgcy50cmVlID0gY2xvbmUodGhpcy50cmVlKTtcbiAgcy5wYXRocyA9IE9iamVjdC5mcm9tRW50cmllcyhcbiAgICBPYmplY3QuZW50cmllcyh0aGlzLnBhdGhzKS5tYXAoKFtrZXksIHZhbHVlXSkgPT4gKFtrZXksIHZhbHVlLmNsb25lKCldKSlcbiAgKTtcbiAgcy5uZXN0ZWQgPSBjbG9uZSh0aGlzLm5lc3RlZCk7XG4gIHMuc3VicGF0aHMgPSBjbG9uZSh0aGlzLnN1YnBhdGhzKTtcbiAgZm9yIChjb25zdCBzY2hlbWFUeXBlIG9mIE9iamVjdC52YWx1ZXMocy5wYXRocykpIHtcbiAgICBpZiAoc2NoZW1hVHlwZS4kaXNTaW5nbGVOZXN0ZWQpIHtcbiAgICAgIGNvbnN0IHBhdGggPSBzY2hlbWFUeXBlLnBhdGg7XG4gICAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhzY2hlbWFUeXBlLnNjaGVtYS5wYXRocykpIHtcbiAgICAgICAgcy5zaW5nbGVOZXN0ZWRQYXRoc1twYXRoICsgJy4nICsga2V5XSA9IHNjaGVtYVR5cGUuc2NoZW1hLnBhdGhzW2tleV07XG4gICAgICB9XG4gICAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhzY2hlbWFUeXBlLnNjaGVtYS5zaW5nbGVOZXN0ZWRQYXRocykpIHtcbiAgICAgICAgcy5zaW5nbGVOZXN0ZWRQYXRoc1twYXRoICsgJy4nICsga2V5XSA9XG4gICAgICAgICAgc2NoZW1hVHlwZS5zY2hlbWEuc2luZ2xlTmVzdGVkUGF0aHNba2V5XTtcbiAgICAgIH1cbiAgICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKHNjaGVtYVR5cGUuc2NoZW1hLnN1YnBhdGhzKSkge1xuICAgICAgICBzLnNpbmdsZU5lc3RlZFBhdGhzW3BhdGggKyAnLicgKyBrZXldID1cbiAgICAgICAgICBzY2hlbWFUeXBlLnNjaGVtYS5zdWJwYXRoc1trZXldO1xuICAgICAgfVxuICAgICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMoc2NoZW1hVHlwZS5zY2hlbWEubmVzdGVkKSkge1xuICAgICAgICBzLnNpbmdsZU5lc3RlZFBhdGhzW3BhdGggKyAnLicgKyBrZXldID0gJ25lc3RlZCc7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHMuY2hpbGRTY2hlbWFzID0gZ2F0aGVyQ2hpbGRTY2hlbWFzKHMpO1xuXG4gIHMudmlydHVhbHMgPSBjbG9uZSh0aGlzLnZpcnR1YWxzKTtcbiAgcy4kZ2xvYmFsUGx1Z2luc0FwcGxpZWQgPSB0aGlzLiRnbG9iYWxQbHVnaW5zQXBwbGllZDtcbiAgcy4kaXNSb290RGlzY3JpbWluYXRvciA9IHRoaXMuJGlzUm9vdERpc2NyaW1pbmF0b3I7XG4gIHMuJGltcGxpY2l0bHlDcmVhdGVkID0gdGhpcy4kaW1wbGljaXRseUNyZWF0ZWQ7XG4gIHMuJGlkID0gKytpZDtcbiAgcy4kb3JpZ2luYWxTY2hlbWFJZCA9IHRoaXMuJGlkO1xuICBzLm1hcFBhdGhzID0gW10uY29uY2F0KHRoaXMubWFwUGF0aHMpO1xuXG4gIGlmICh0aGlzLmRpc2NyaW1pbmF0b3JNYXBwaW5nICE9IG51bGwpIHtcbiAgICBzLmRpc2NyaW1pbmF0b3JNYXBwaW5nID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5kaXNjcmltaW5hdG9yTWFwcGluZyk7XG4gIH1cbiAgaWYgKHRoaXMuZGlzY3JpbWluYXRvcnMgIT0gbnVsbCkge1xuICAgIHMuZGlzY3JpbWluYXRvcnMgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLmRpc2NyaW1pbmF0b3JzKTtcbiAgfVxuICBpZiAodGhpcy5fYXBwbHlEaXNjcmltaW5hdG9ycyAhPSBudWxsKSB7XG4gICAgcy5fYXBwbHlEaXNjcmltaW5hdG9ycyA9IG5ldyBNYXAodGhpcy5fYXBwbHlEaXNjcmltaW5hdG9ycyk7XG4gIH1cblxuICBzLmFsaWFzZXMgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLmFsaWFzZXMpO1xuXG4gIHJldHVybiBzO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIGEgbmV3IHNjaGVtYSB0aGF0IGhhcyB0aGUgcGlja2VkIGBwYXRoc2AgZnJvbSB0aGlzIHNjaGVtYS5cbiAqXG4gKiBUaGlzIG1ldGhvZCBpcyBhbmFsYWdvdXMgdG8gW0xvZGFzaCdzIGBwaWNrKClgIGZ1bmN0aW9uXShodHRwczovL2xvZGFzaC5jb20vZG9jcy80LjE3LjE1I3BpY2spIGZvciBNb25nb29zZSBzY2hlbWFzLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgY29uc3Qgc2NoZW1hID0gU2NoZW1hKHsgbmFtZTogU3RyaW5nLCBhZ2U6IE51bWJlciB9KTtcbiAqICAgICAvLyBDcmVhdGVzIGEgbmV3IHNjaGVtYSB3aXRoIHRoZSBzYW1lIGBuYW1lYCBwYXRoIGFzIGBzY2hlbWFgLFxuICogICAgIC8vIGJ1dCBubyBgYWdlYCBwYXRoLlxuICogICAgIGNvbnN0IG5ld1NjaGVtYSA9IHNjaGVtYS5waWNrKFsnbmFtZSddKTtcbiAqXG4gKiAgICAgbmV3U2NoZW1hLnBhdGgoJ25hbWUnKTsgLy8gU2NoZW1hU3RyaW5nIHsgLi4uIH1cbiAqICAgICBuZXdTY2hlbWEucGF0aCgnYWdlJyk7IC8vIHVuZGVmaW5lZFxuICpcbiAqIEBwYXJhbSB7U3RyaW5nW119IHBhdGhzIExpc3Qgb2YgUGF0aHMgdG8gcGljayBmb3IgdGhlIG5ldyBTY2hlbWFcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyB0byBwYXNzIHRvIHRoZSBuZXcgU2NoZW1hIENvbnN0cnVjdG9yIChzYW1lIGFzIGBuZXcgU2NoZW1hKC4uLCBPcHRpb25zKWApLiBEZWZhdWx0cyB0byBgdGhpcy5vcHRpb25zYCBpZiBub3Qgc2V0LlxuICogQHJldHVybiB7U2NoZW1hfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5TY2hlbWEucHJvdG90eXBlLnBpY2sgPSBmdW5jdGlvbihwYXRocywgb3B0aW9ucykge1xuICBjb25zdCBuZXdTY2hlbWEgPSBuZXcgU2NoZW1hKHt9LCBvcHRpb25zIHx8IHRoaXMub3B0aW9ucyk7XG4gIGlmICghQXJyYXkuaXNBcnJheShwYXRocykpIHtcbiAgICB0aHJvdyBuZXcgTW9uZ29vc2VFcnJvcignU2NoZW1hI3BpY2soKSBvbmx5IGFjY2VwdHMgYW4gYXJyYXkgYXJndW1lbnQsICcgK1xuICAgICAgJ2dvdCBcIicgKyB0eXBlb2YgcGF0aHMgKyAnXCInKTtcbiAgfVxuXG4gIGZvciAoY29uc3QgcGF0aCBvZiBwYXRocykge1xuICAgIGlmICh0aGlzLm5lc3RlZFtwYXRoXSkge1xuICAgICAgbmV3U2NoZW1hLmFkZCh7IFtwYXRoXTogZ2V0KHRoaXMudHJlZSwgcGF0aCkgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHNjaGVtYXR5cGUgPSB0aGlzLnBhdGgocGF0aCk7XG4gICAgICBpZiAoc2NoZW1hdHlwZSA9PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBNb25nb29zZUVycm9yKCdQYXRoIGAnICsgcGF0aCArICdgIGlzIG5vdCBpbiB0aGUgc2NoZW1hJyk7XG4gICAgICB9XG4gICAgICBuZXdTY2hlbWEuYWRkKHsgW3BhdGhdOiBzY2hlbWF0eXBlIH0pO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuZXdTY2hlbWE7XG59O1xuXG4vKipcbiAqIFJldHVybnMgYSBuZXcgc2NoZW1hIHRoYXQgaGFzIHRoZSBgcGF0aHNgIGZyb20gdGhlIG9yaWdpbmFsIHNjaGVtYSwgbWludXMgdGhlIG9taXR0ZWQgb25lcy5cbiAqXG4gKiBUaGlzIG1ldGhvZCBpcyBhbmFsYWdvdXMgdG8gW0xvZGFzaCdzIGBvbWl0KClgIGZ1bmN0aW9uXShodHRwczovL2xvZGFzaC5jb20vZG9jcy8jb21pdCkgZm9yIE1vbmdvb3NlIHNjaGVtYXMuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBjb25zdCBzY2hlbWEgPSBTY2hlbWEoeyBuYW1lOiBTdHJpbmcsIGFnZTogTnVtYmVyIH0pO1xuICogICAgIC8vIENyZWF0ZXMgYSBuZXcgc2NoZW1hIG9taXR0aW5nIHRoZSBgYWdlYCBwYXRoXG4gKiAgICAgY29uc3QgbmV3U2NoZW1hID0gc2NoZW1hLm9taXQoWydhZ2UnXSk7XG4gKlxuICogICAgIG5ld1NjaGVtYS5wYXRoKCduYW1lJyk7IC8vIFNjaGVtYVN0cmluZyB7IC4uLiB9XG4gKiAgICAgbmV3U2NoZW1hLnBhdGgoJ2FnZScpOyAvLyB1bmRlZmluZWRcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ1tdfSBwYXRocyBMaXN0IG9mIFBhdGhzIHRvIG9taXQgZm9yIHRoZSBuZXcgU2NoZW1hXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgdG8gcGFzcyB0byB0aGUgbmV3IFNjaGVtYSBDb25zdHJ1Y3RvciAoc2FtZSBhcyBgbmV3IFNjaGVtYSguLiwgT3B0aW9ucylgKS4gRGVmYXVsdHMgdG8gYHRoaXMub3B0aW9uc2AgaWYgbm90IHNldC5cbiAqIEByZXR1cm4ge1NjaGVtYX1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuU2NoZW1hLnByb3RvdHlwZS5vbWl0ID0gZnVuY3Rpb24ocGF0aHMsIG9wdGlvbnMpIHtcbiAgY29uc3QgbmV3U2NoZW1hID0gbmV3IFNjaGVtYSh0aGlzLCBvcHRpb25zIHx8IHRoaXMub3B0aW9ucyk7XG4gIGlmICghQXJyYXkuaXNBcnJheShwYXRocykpIHtcbiAgICB0aHJvdyBuZXcgTW9uZ29vc2VFcnJvcihcbiAgICAgICdTY2hlbWEjb21pdCgpIG9ubHkgYWNjZXB0cyBhbiBhcnJheSBhcmd1bWVudCwgJyArXG4gICAgICAgICdnb3QgXCInICtcbiAgICAgICAgdHlwZW9mIHBhdGhzICtcbiAgICAgICAgJ1wiJ1xuICAgICk7XG4gIH1cblxuICBuZXdTY2hlbWEucmVtb3ZlKHBhdGhzKTtcblxuICBmb3IgKGNvbnN0IG5lc3RlZCBpbiBuZXdTY2hlbWEuc2luZ2xlTmVzdGVkUGF0aHMpIHtcbiAgICBpZiAocGF0aHMuaW5jbHVkZXMobmVzdGVkKSkge1xuICAgICAgZGVsZXRlIG5ld1NjaGVtYS5zaW5nbGVOZXN0ZWRQYXRoc1tuZXN0ZWRdO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuZXdTY2hlbWE7XG59O1xuXG4vKipcbiAqIFJldHVybnMgZGVmYXVsdCBvcHRpb25zIGZvciB0aGlzIHNjaGVtYSwgbWVyZ2VkIHdpdGggYG9wdGlvbnNgLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyB0byBvdmVyd3JpdGUgdGhlIGRlZmF1bHQgb3B0aW9uc1xuICogQHJldHVybiB7T2JqZWN0fSBUaGUgbWVyZ2VkIG9wdGlvbnMgb2YgYG9wdGlvbnNgIGFuZCB0aGUgZGVmYXVsdCBvcHRpb25zXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5TY2hlbWEucHJvdG90eXBlLmRlZmF1bHRPcHRpb25zID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICB0aGlzLl91c2VyUHJvdmlkZWRPcHRpb25zID0gb3B0aW9ucyA9PSBudWxsID8ge30gOiBjbG9uZShvcHRpb25zKTtcbiAgY29uc3QgYmFzZU9wdGlvbnMgPSB0aGlzLmJhc2UgJiYgdGhpcy5iYXNlLm9wdGlvbnMgfHwge307XG4gIGNvbnN0IHN0cmljdCA9ICdzdHJpY3QnIGluIGJhc2VPcHRpb25zID8gYmFzZU9wdGlvbnMuc3RyaWN0IDogdHJ1ZTtcbiAgY29uc3Qgc3RyaWN0UXVlcnkgPSAnc3RyaWN0UXVlcnknIGluIGJhc2VPcHRpb25zID8gYmFzZU9wdGlvbnMuc3RyaWN0UXVlcnkgOiBmYWxzZTtcbiAgY29uc3QgaWQgPSAnaWQnIGluIGJhc2VPcHRpb25zID8gYmFzZU9wdGlvbnMuaWQgOiB0cnVlO1xuICBvcHRpb25zID0ge1xuICAgIHN0cmljdCxcbiAgICBzdHJpY3RRdWVyeSxcbiAgICBidWZmZXJDb21tYW5kczogdHJ1ZSxcbiAgICBjYXBwZWQ6IGZhbHNlLCAvLyB7IHNpemUsIG1heCwgYXV0b0luZGV4SWQgfVxuICAgIHZlcnNpb25LZXk6ICdfX3YnLFxuICAgIG9wdGltaXN0aWNDb25jdXJyZW5jeTogZmFsc2UsXG4gICAgbWluaW1pemU6IHRydWUsXG4gICAgYXV0b0luZGV4OiBudWxsLFxuICAgIGRpc2NyaW1pbmF0b3JLZXk6ICdfX3QnLFxuICAgIHNoYXJkS2V5OiBudWxsLFxuICAgIHJlYWQ6IG51bGwsXG4gICAgdmFsaWRhdGVCZWZvcmVTYXZlOiB0cnVlLFxuICAgIHZhbGlkYXRlTW9kaWZpZWRPbmx5OiBmYWxzZSxcbiAgICAvLyB0aGUgZm9sbG93aW5nIGFyZSBvbmx5IGFwcGxpZWQgYXQgY29uc3RydWN0aW9uIHRpbWVcbiAgICBfaWQ6IHRydWUsXG4gICAgaWQ6IGlkLFxuICAgIHR5cGVLZXk6ICd0eXBlJyxcbiAgICAuLi5vcHRpb25zXG4gIH07XG5cbiAgaWYgKG9wdGlvbnMudmVyc2lvbktleSAmJiB0eXBlb2Ygb3B0aW9ucy52ZXJzaW9uS2V5ICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBNb25nb29zZUVycm9yKCdgdmVyc2lvbktleWAgbXVzdCBiZSBmYWxzeSBvciBzdHJpbmcsIGdvdCBgJyArICh0eXBlb2Ygb3B0aW9ucy52ZXJzaW9uS2V5KSArICdgJyk7XG4gIH1cblxuICBpZiAodHlwZW9mIG9wdGlvbnMucmVhZCA9PT0gJ3N0cmluZycpIHtcbiAgICBvcHRpb25zLnJlYWQgPSBoYW5kbGVSZWFkUHJlZmVyZW5jZUFsaWFzZXMob3B0aW9ucy5yZWFkKTtcbiAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KG9wdGlvbnMucmVhZCkgJiYgdHlwZW9mIG9wdGlvbnMucmVhZFswXSA9PT0gJ3N0cmluZycpIHtcbiAgICBvcHRpb25zLnJlYWQgPSB7XG4gICAgICBtb2RlOiBoYW5kbGVSZWFkUHJlZmVyZW5jZUFsaWFzZXMob3B0aW9ucy5yZWFkWzBdKSxcbiAgICAgIHRhZ3M6IG9wdGlvbnMucmVhZFsxXVxuICAgIH07XG4gIH1cblxuICBpZiAob3B0aW9ucy5vcHRpbWlzdGljQ29uY3VycmVuY3kgJiYgIW9wdGlvbnMudmVyc2lvbktleSkge1xuICAgIHRocm93IG5ldyBNb25nb29zZUVycm9yKCdNdXN0IHNldCBgdmVyc2lvbktleWAgaWYgdXNpbmcgYG9wdGltaXN0aWNDb25jdXJyZW5jeWAnKTtcbiAgfVxuXG4gIHJldHVybiBvcHRpb25zO1xufTtcblxuLyoqXG4gKiBJbmhlcml0IGEgU2NoZW1hIGJ5IGFwcGx5aW5nIGEgZGlzY3JpbWluYXRvciBvbiBhbiBleGlzdGluZyBTY2hlbWEuXG4gKlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgY29uc3QgZXZlbnRTY2hlbWEgPSBuZXcgbW9uZ29vc2UuU2NoZW1hKHsgdGltZXN0YW1wOiBEYXRlIH0sIHsgZGlzY3JpbWluYXRvcktleTogJ2tpbmQnIH0pO1xuICpcbiAqICAgICBjb25zdCBjbGlja2VkRXZlbnRTY2hlbWEgPSBuZXcgbW9uZ29vc2UuU2NoZW1hKHsgZWxlbWVudDogU3RyaW5nIH0sIHsgZGlzY3JpbWluYXRvcktleTogJ2tpbmQnIH0pO1xuICogICAgIGNvbnN0IENsaWNrZWRNb2RlbCA9IGV2ZW50U2NoZW1hLmRpc2NyaW1pbmF0b3IoJ2NsaWNrZWQnLCBjbGlja2VkRXZlbnRTY2hlbWEpO1xuICpcbiAqICAgICBjb25zdCBFdmVudCA9IG1vbmdvb3NlLm1vZGVsKCdFdmVudCcsIGV2ZW50U2NoZW1hKTtcbiAqXG4gKiAgICAgRXZlbnQuZGlzY3JpbWluYXRvcnNbJ2NsaWNrZWQnXTsgLy8gTW9kZWwgeyBjbGlja2VkIH1cbiAqXG4gKiAgICAgY29uc3QgZG9jID0gYXdhaXQgRXZlbnQuY3JlYXRlKHsga2luZDogJ2NsaWNrZWQnLCBlbGVtZW50OiAnI2hlcm8nIH0pO1xuICogICAgIGRvYy5lbGVtZW50OyAvLyAnI2hlcm8nXG4gKiAgICAgZG9jIGluc3RhbmNlb2YgQ2xpY2tlZE1vZGVsOyAvLyB0cnVlXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgdGhlIG5hbWUgb2YgdGhlIGRpc2NyaW1pbmF0b3JcbiAqIEBwYXJhbSB7U2NoZW1hfSBzY2hlbWEgdGhlIGRpc2NyaW1pbmF0ZWQgU2NoZW1hXG4gKiBAcmV0dXJuIHtTY2hlbWF9IHRoZSBTY2hlbWEgaW5zdGFuY2VcbiAqIEBhcGkgcHVibGljXG4gKi9cblNjaGVtYS5wcm90b3R5cGUuZGlzY3JpbWluYXRvciA9IGZ1bmN0aW9uKG5hbWUsIHNjaGVtYSkge1xuICB0aGlzLl9hcHBseURpc2NyaW1pbmF0b3JzID0gdGhpcy5fYXBwbHlEaXNjcmltaW5hdG9ycyB8fCBuZXcgTWFwKCk7XG4gIHRoaXMuX2FwcGx5RGlzY3JpbWluYXRvcnMuc2V0KG5hbWUsIHNjaGVtYSk7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEFkZHMga2V5IHBhdGggLyBzY2hlbWEgdHlwZSBwYWlycyB0byB0aGlzIHNjaGVtYS5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IFRveVNjaGVtYSA9IG5ldyBTY2hlbWEoKTtcbiAqICAgICBUb3lTY2hlbWEuYWRkKHsgbmFtZTogJ3N0cmluZycsIGNvbG9yOiAnc3RyaW5nJywgcHJpY2U6ICdudW1iZXInIH0pO1xuICpcbiAqICAgICBjb25zdCBUdXJib01hblNjaGVtYSA9IG5ldyBTY2hlbWEoKTtcbiAqICAgICAvLyBZb3UgY2FuIGFsc28gYGFkZCgpYCBhbm90aGVyIHNjaGVtYSBhbmQgY29weSBvdmVyIGFsbCBwYXRocywgdmlydHVhbHMsXG4gKiAgICAgLy8gZ2V0dGVycywgc2V0dGVycywgaW5kZXhlcywgbWV0aG9kcywgYW5kIHN0YXRpY3MuXG4gKiAgICAgVHVyYm9NYW5TY2hlbWEuYWRkKFRveVNjaGVtYSkuYWRkKHsgeWVhcjogTnVtYmVyIH0pO1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fFNjaGVtYX0gb2JqIHBsYWluIG9iamVjdCB3aXRoIHBhdGhzIHRvIGFkZCwgb3IgYW5vdGhlciBzY2hlbWFcbiAqIEBwYXJhbSB7U3RyaW5nfSBbcHJlZml4XSBwYXRoIHRvIHByZWZpeCB0aGUgbmV3bHkgYWRkZWQgcGF0aHMgd2l0aFxuICogQHJldHVybiB7U2NoZW1hfSB0aGUgU2NoZW1hIGluc3RhbmNlXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblNjaGVtYS5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gYWRkKG9iaiwgcHJlZml4KSB7XG4gIGlmIChvYmogaW5zdGFuY2VvZiBTY2hlbWEgfHwgKG9iaiAhPSBudWxsICYmIG9iai5pbnN0YW5jZU9mU2NoZW1hKSkge1xuICAgIG1lcmdlKHRoaXMsIG9iaik7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIFNwZWNpYWwgY2FzZTogc2V0dGluZyB0b3AtbGV2ZWwgYF9pZGAgdG8gZmFsc2Ugc2hvdWxkIGNvbnZlcnQgdG8gZGlzYWJsaW5nXG4gIC8vIHRoZSBgX2lkYCBvcHRpb24uIFRoaXMgYmVoYXZpb3IgbmV2ZXIgd29ya2VkIGJlZm9yZSA1LjQuMTEgYnV0IG51bWVyb3VzXG4gIC8vIGNvZGViYXNlcyB1c2UgaXQgKHNlZSBnaC03NTE2LCBnaC03NTEyKS5cbiAgaWYgKG9iai5faWQgPT09IGZhbHNlICYmIHByZWZpeCA9PSBudWxsKSB7XG4gICAgdGhpcy5vcHRpb25zLl9pZCA9IGZhbHNlO1xuICB9XG5cbiAgcHJlZml4ID0gcHJlZml4IHx8ICcnO1xuICAvLyBhdm9pZCBwcm90b3R5cGUgcG9sbHV0aW9uXG4gIGlmIChwcmVmaXggPT09ICdfX3Byb3RvX18uJyB8fCBwcmVmaXggPT09ICdjb25zdHJ1Y3Rvci4nIHx8IHByZWZpeCA9PT0gJ3Byb3RvdHlwZS4nKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMob2JqKTtcbiAgY29uc3QgdHlwZUtleSA9IHRoaXMub3B0aW9ucy50eXBlS2V5O1xuICBmb3IgKGNvbnN0IGtleSBvZiBrZXlzKSB7XG4gICAgaWYgKHV0aWxzLnNwZWNpYWxQcm9wZXJ0aWVzLmhhcyhrZXkpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBjb25zdCBmdWxsUGF0aCA9IHByZWZpeCArIGtleTtcbiAgICBjb25zdCB2YWwgPSBvYmpba2V5XTtcblxuICAgIGlmICh2YWwgPT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCB2YWx1ZSBmb3Igc2NoZW1hIHBhdGggYCcgKyBmdWxsUGF0aCArXG4gICAgICAgICdgLCBnb3QgdmFsdWUgXCInICsgdmFsICsgJ1wiJyk7XG4gICAgfVxuICAgIC8vIFJldGFpbiBgX2lkOiBmYWxzZWAgYnV0IGRvbid0IHNldCBpdCBhcyBhIHBhdGgsIHJlOiBnaC04Mjc0LlxuICAgIGlmIChrZXkgPT09ICdfaWQnICYmIHZhbCA9PT0gZmFsc2UpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICAvLyBEZXByZWNhdGUgc2V0dGluZyBzY2hlbWEgcGF0aHMgdG8gcHJpbWl0aXZlIHR5cGVzIChnaC03NTU4KVxuICAgIGxldCBpc01vbmdvb3NlVHlwZVN0cmluZyA9IGZhbHNlO1xuICAgIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgICAgLy8gSGFuZGxlIHRoZSBjYXNlIGluIHdoaWNoIHRoZSB0eXBlIGlzIHNwZWNpZmllZCBhcyBhIHN0cmluZyAoZWcuICdkYXRlJywgJ29pZCcsIC4uLilcbiAgICAgIGNvbnN0IE1vbmdvb3NlVHlwZXMgPSB0aGlzLmJhc2UgIT0gbnVsbCA/IHRoaXMuYmFzZS5TY2hlbWEuVHlwZXMgOiBTY2hlbWEuVHlwZXM7XG4gICAgICBjb25zdCB1cHBlclZhbCA9IHZhbC5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHZhbC5zdWJzdHJpbmcoMSk7XG4gICAgICBpc01vbmdvb3NlVHlwZVN0cmluZyA9IE1vbmdvb3NlVHlwZXNbdXBwZXJWYWxdICE9IG51bGw7XG4gICAgfVxuICAgIGlmIChcbiAgICAgIGtleSAhPT0gJ19pZCcgJiZcbiAgICAgICgodHlwZW9mIHZhbCAhPT0gJ29iamVjdCcgJiYgdHlwZW9mIHZhbCAhPT0gJ2Z1bmN0aW9uJyAmJiAhaXNNb25nb29zZVR5cGVTdHJpbmcpIHx8XG4gICAgICB2YWwgPT0gbnVsbClcbiAgICApIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYEludmFsaWQgc2NoZW1hIGNvbmZpZ3VyYXRpb246IFxcYCR7dmFsfVxcYCBpcyBub3QgYCArXG4gICAgICAgIGBhIHZhbGlkIHR5cGUgYXQgcGF0aCBcXGAke2tleX1cXGAuIFNlZSBgICtcbiAgICAgICAgJ2h0dHBzOi8vYml0Lmx5L21vbmdvb3NlLXNjaGVtYXR5cGVzIGZvciBhIGxpc3Qgb2YgdmFsaWQgc2NoZW1hIHR5cGVzLicpO1xuICAgIH1cbiAgICBpZiAodmFsIGluc3RhbmNlb2YgVmlydHVhbFR5cGUgfHwgKHZhbC5jb25zdHJ1Y3RvciAmJiB2YWwuY29uc3RydWN0b3IubmFtZSB8fCBudWxsKSA9PT0gJ1ZpcnR1YWxUeXBlJykge1xuICAgICAgdGhpcy52aXJ0dWFsKHZhbCk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWwpICYmIHZhbC5sZW5ndGggPT09IDEgJiYgdmFsWzBdID09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgdmFsdWUgZm9yIHNjaGVtYSBBcnJheSBwYXRoIGAnICsgZnVsbFBhdGggK1xuICAgICAgICAnYCwgZ290IHZhbHVlIFwiJyArIHZhbFswXSArICdcIicpO1xuICAgIH1cblxuICAgIGlmICghKGlzUE9KTyh2YWwpIHx8IHZhbCBpbnN0YW5jZW9mIFNjaGVtYVR5cGVPcHRpb25zKSkge1xuICAgICAgLy8gU3BlY2lhbC1jYXNlOiBOb24tb3B0aW9ucyBkZWZpbml0ZWx5IGEgcGF0aCBzbyBsZWFmIGF0IHRoaXMgbm9kZVxuICAgICAgLy8gRXhhbXBsZXM6IFNjaGVtYSBpbnN0YW5jZXMsIFNjaGVtYVR5cGUgaW5zdGFuY2VzXG4gICAgICBpZiAocHJlZml4KSB7XG4gICAgICAgIHRoaXMubmVzdGVkW3ByZWZpeC5zdWJzdHJpbmcoMCwgcHJlZml4Lmxlbmd0aCAtIDEpXSA9IHRydWU7XG4gICAgICB9XG4gICAgICB0aGlzLnBhdGgocHJlZml4ICsga2V5LCB2YWwpO1xuICAgICAgaWYgKHZhbFswXSAhPSBudWxsICYmICEodmFsWzBdLmluc3RhbmNlT2ZTY2hlbWEpICYmIHV0aWxzLmlzUE9KTyh2YWxbMF0uZGlzY3JpbWluYXRvcnMpKSB7XG4gICAgICAgIGNvbnN0IHNjaGVtYVR5cGUgPSB0aGlzLnBhdGgocHJlZml4ICsga2V5KTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gdmFsWzBdLmRpc2NyaW1pbmF0b3JzKSB7XG4gICAgICAgICAgc2NoZW1hVHlwZS5kaXNjcmltaW5hdG9yKGtleSwgdmFsWzBdLmRpc2NyaW1pbmF0b3JzW2tleV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChPYmplY3Qua2V5cyh2YWwpLmxlbmd0aCA8IDEpIHtcbiAgICAgIC8vIFNwZWNpYWwtY2FzZToge30gYWx3YXlzIGludGVycHJldGVkIGFzIE1peGVkIHBhdGggc28gbGVhZiBhdCB0aGlzIG5vZGVcbiAgICAgIGlmIChwcmVmaXgpIHtcbiAgICAgICAgdGhpcy5uZXN0ZWRbcHJlZml4LnN1YnN0cmluZygwLCBwcmVmaXgubGVuZ3RoIC0gMSldID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHRoaXMucGF0aChmdWxsUGF0aCwgdmFsKTsgLy8gbWl4ZWQgdHlwZVxuICAgIH0gZWxzZSBpZiAoIXZhbFt0eXBlS2V5XSB8fCAodHlwZUtleSA9PT0gJ3R5cGUnICYmIGlzUE9KTyh2YWwudHlwZSkgJiYgdmFsLnR5cGUudHlwZSkpIHtcbiAgICAgIC8vIFNwZWNpYWwtY2FzZTogUE9KTyB3aXRoIG5vIGJvbmEtZmlkZSB0eXBlIGtleSAtIGludGVycHJldCBhcyB0cmVlIG9mIGRlZXAgcGF0aHMgc28gcmVjdXJzZVxuICAgICAgLy8gbmVzdGVkIG9iamVjdCBgeyBsYXN0OiB7IG5hbWU6IFN0cmluZyB9IH1gLiBBdm9pZCBmdW5jdGlvbnMgd2l0aCBgLnR5cGVgIHJlOiAjMTA4MDcgYmVjYXVzZVxuICAgICAgLy8gTmVzdEpTIHNvbWV0aW1lcyBhZGRzIGBEYXRlLnR5cGVgLlxuICAgICAgdGhpcy5uZXN0ZWRbZnVsbFBhdGhdID0gdHJ1ZTtcbiAgICAgIHRoaXMuYWRkKHZhbCwgZnVsbFBhdGggKyAnLicpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUaGVyZSBJUyBhIGJvbmEtZmlkZSB0eXBlIGtleSB0aGF0IG1heSBhbHNvIGJlIGEgUE9KT1xuICAgICAgY29uc3QgX3R5cGVEZWYgPSB2YWxbdHlwZUtleV07XG4gICAgICBpZiAoaXNQT0pPKF90eXBlRGVmKSAmJiBPYmplY3Qua2V5cyhfdHlwZURlZikubGVuZ3RoID4gMCkge1xuICAgICAgICAvLyBJZiBhIFBPSk8gaXMgdGhlIHZhbHVlIG9mIGEgdHlwZSBrZXksIG1ha2UgaXQgYSBzdWJkb2N1bWVudFxuICAgICAgICBpZiAocHJlZml4KSB7XG4gICAgICAgICAgdGhpcy5uZXN0ZWRbcHJlZml4LnN1YnN0cmluZygwLCBwcmVmaXgubGVuZ3RoIC0gMSldID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGNoaWxkU2NoZW1hT3B0aW9ucyA9IHt9O1xuICAgICAgICBpZiAodGhpcy5fdXNlclByb3ZpZGVkT3B0aW9ucy50eXBlS2V5KSB7XG4gICAgICAgICAgY2hpbGRTY2hlbWFPcHRpb25zLnR5cGVLZXkgPSB0aGlzLl91c2VyUHJvdmlkZWRPcHRpb25zLnR5cGVLZXk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gcHJvcGFnYXRlICdzdHJpY3QnIG9wdGlvbiB0byBjaGlsZCBzY2hlbWFcbiAgICAgICAgaWYgKHRoaXMuX3VzZXJQcm92aWRlZE9wdGlvbnMuc3RyaWN0ICE9IG51bGwpIHtcbiAgICAgICAgICBjaGlsZFNjaGVtYU9wdGlvbnMuc3RyaWN0ID0gdGhpcy5fdXNlclByb3ZpZGVkT3B0aW9ucy5zdHJpY3Q7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX3VzZXJQcm92aWRlZE9wdGlvbnMudG9PYmplY3QgIT0gbnVsbCkge1xuICAgICAgICAgIGNoaWxkU2NoZW1hT3B0aW9ucy50b09iamVjdCA9IHV0aWxzLm9taXQodGhpcy5fdXNlclByb3ZpZGVkT3B0aW9ucy50b09iamVjdCwgWyd0cmFuc2Zvcm0nXSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX3VzZXJQcm92aWRlZE9wdGlvbnMudG9KU09OICE9IG51bGwpIHtcbiAgICAgICAgICBjaGlsZFNjaGVtYU9wdGlvbnMudG9KU09OID0gdXRpbHMub21pdCh0aGlzLl91c2VyUHJvdmlkZWRPcHRpb25zLnRvSlNPTiwgWyd0cmFuc2Zvcm0nXSk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBfc2NoZW1hID0gbmV3IFNjaGVtYShfdHlwZURlZiwgY2hpbGRTY2hlbWFPcHRpb25zKTtcbiAgICAgICAgX3NjaGVtYS4kaW1wbGljaXRseUNyZWF0ZWQgPSB0cnVlO1xuICAgICAgICBjb25zdCBzY2hlbWFXcmFwcGVkUGF0aCA9IE9iamVjdC5hc3NpZ24oe30sIHZhbCwgeyBbdHlwZUtleV06IF9zY2hlbWEgfSk7XG4gICAgICAgIHRoaXMucGF0aChwcmVmaXggKyBrZXksIHNjaGVtYVdyYXBwZWRQYXRoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEVpdGhlciB0aGUgdHlwZSBpcyBub24tUE9KTyBvciB3ZSBpbnRlcnByZXQgaXQgYXMgTWl4ZWQgYW55d2F5XG4gICAgICAgIGlmIChwcmVmaXgpIHtcbiAgICAgICAgICB0aGlzLm5lc3RlZFtwcmVmaXguc3Vic3RyaW5nKDAsIHByZWZpeC5sZW5ndGggLSAxKV0gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucGF0aChwcmVmaXggKyBrZXksIHZhbCk7XG4gICAgICAgIGlmICh2YWwgIT0gbnVsbCAmJiAhKHZhbC5pbnN0YW5jZU9mU2NoZW1hKSAmJiB1dGlscy5pc1BPSk8odmFsLmRpc2NyaW1pbmF0b3JzKSkge1xuICAgICAgICAgIGNvbnN0IHNjaGVtYVR5cGUgPSB0aGlzLnBhdGgocHJlZml4ICsga2V5KTtcbiAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiB2YWwuZGlzY3JpbWluYXRvcnMpIHtcbiAgICAgICAgICAgIHNjaGVtYVR5cGUuZGlzY3JpbWluYXRvcihrZXksIHZhbC5kaXNjcmltaW5hdG9yc1trZXldKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBjb25zdCBhbGlhc09iaiA9IE9iamVjdC5mcm9tRW50cmllcyhcbiAgICBPYmplY3QuZW50cmllcyhvYmopLm1hcCgoW2tleV0pID0+IChbcHJlZml4ICsga2V5LCBudWxsXSkpXG4gICk7XG4gIGFsaWFzRmllbGRzKHRoaXMsIGFsaWFzT2JqKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEFkZCBhbiBhbGlhcyBmb3IgYHBhdGhgLiBUaGlzIG1lYW5zIGdldHRpbmcgb3Igc2V0dGluZyB0aGUgYGFsaWFzYFxuICogaXMgZXF1aXZhbGVudCB0byBnZXR0aW5nIG9yIHNldHRpbmcgdGhlIGBwYXRoYC5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IHRveVNjaGVtYSA9IG5ldyBTY2hlbWEoeyBuOiBTdHJpbmcgfSk7XG4gKlxuICogICAgIC8vIE1ha2UgJ25hbWUnIGFuIGFsaWFzIGZvciAnbidcbiAqICAgICB0b3lTY2hlbWEuYWxpYXMoJ24nLCAnbmFtZScpO1xuICpcbiAqICAgICBjb25zdCBUb3kgPSBtb25nb29zZS5tb2RlbCgnVG95JywgdG95U2NoZW1hKTtcbiAqICAgICBjb25zdCB0dXJib01hbiA9IG5ldyBUb3koeyBuOiAnVHVyYm8gTWFuJyB9KTtcbiAqXG4gKiAgICAgdHVyYm9NYW4ubmFtZTsgLy8gJ1R1cmJvIE1hbidcbiAqICAgICB0dXJib01hbi5uOyAvLyAnVHVyYm8gTWFuJ1xuICpcbiAqICAgICB0dXJib01hbi5uYW1lID0gJ1R1cmJvIE1hbiBBY3Rpb24gRmlndXJlJztcbiAqICAgICB0dXJib01hbi5uOyAvLyAnVHVyYm8gTWFuIEFjdGlvbiBGaWd1cmUnXG4gKlxuICogICAgIGF3YWl0IHR1cmJvTWFuLnNhdmUoKTsgLy8gU2F2ZXMgeyBfaWQ6IC4uLiwgbjogJ1R1cmJvIE1hbiBBY3Rpb24gRmlndXJlJyB9XG4gKlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoIHJlYWwgcGF0aCB0byBhbGlhc1xuICogQHBhcmFtIHtTdHJpbmd8U3RyaW5nW119IGFsaWFzIHRoZSBwYXRoKHMpIHRvIHVzZSBhcyBhbiBhbGlhcyBmb3IgYHBhdGhgXG4gKiBAcmV0dXJuIHtTY2hlbWF9IHRoZSBTY2hlbWEgaW5zdGFuY2VcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuU2NoZW1hLnByb3RvdHlwZS5hbGlhcyA9IGZ1bmN0aW9uIGFsaWFzKHBhdGgsIGFsaWFzKSB7XG4gIGFsaWFzRmllbGRzKHRoaXMsIHsgW3BhdGhdOiBhbGlhcyB9KTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFJlbW92ZSBhbiBpbmRleCBieSBuYW1lIG9yIGluZGV4IHNwZWNpZmljYXRpb24uXG4gKlxuICogcmVtb3ZlSW5kZXggb25seSByZW1vdmVzIGluZGV4ZXMgZnJvbSB5b3VyIHNjaGVtYSBvYmplY3QuIERvZXMgKipub3QqKiBhZmZlY3QgdGhlIGluZGV4ZXNcbiAqIGluIE1vbmdvREIuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBjb25zdCBUb3lTY2hlbWEgPSBuZXcgU2NoZW1hKHsgbmFtZTogU3RyaW5nLCBjb2xvcjogU3RyaW5nLCBwcmljZTogTnVtYmVyIH0pO1xuICpcbiAqICAgICAvLyBBZGQgYSBuZXcgaW5kZXggb24geyBuYW1lLCBjb2xvciB9XG4gKiAgICAgVG95U2NoZW1hLmluZGV4KHsgbmFtZTogMSwgY29sb3I6IDEgfSk7XG4gKlxuICogICAgIC8vIFJlbW92ZSBpbmRleCBvbiB7IG5hbWUsIGNvbG9yIH1cbiAqICAgICAvLyBLZWVwIGluIG1pbmQgdGhhdCBvcmRlciBtYXR0ZXJzISBgcmVtb3ZlSW5kZXgoeyBjb2xvcjogMSwgbmFtZTogMSB9KWAgd29uJ3QgcmVtb3ZlIHRoZSBpbmRleFxuICogICAgIFRveVNjaGVtYS5yZW1vdmVJbmRleCh7IG5hbWU6IDEsIGNvbG9yOiAxIH0pO1xuICpcbiAqICAgICAvLyBBZGQgYW4gaW5kZXggd2l0aCBhIGN1c3RvbSBuYW1lXG4gKiAgICAgVG95U2NoZW1hLmluZGV4KHsgY29sb3I6IDEgfSwgeyBuYW1lOiAnbXkgY3VzdG9tIGluZGV4IG5hbWUnIH0pO1xuICogICAgIC8vIFJlbW92ZSBpbmRleCBieSBuYW1lXG4gKiAgICAgVG95U2NoZW1hLnJlbW92ZUluZGV4KCdteSBjdXN0b20gaW5kZXggbmFtZScpO1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fHN0cmluZ30gaW5kZXggbmFtZSBvciBpbmRleCBzcGVjaWZpY2F0aW9uXG4gKiBAcmV0dXJuIHtTY2hlbWF9IHRoZSBTY2hlbWEgaW5zdGFuY2VcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuU2NoZW1hLnByb3RvdHlwZS5yZW1vdmVJbmRleCA9IGZ1bmN0aW9uIHJlbW92ZUluZGV4KGluZGV4KSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncmVtb3ZlSW5kZXgoKSB0YWtlcyBvbmx5IDEgYXJndW1lbnQnKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgaW5kZXggIT09ICdvYmplY3QnICYmIHR5cGVvZiBpbmRleCAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3JlbW92ZUluZGV4KCkgbWF5IG9ubHkgdGFrZSBlaXRoZXIgYW4gb2JqZWN0IG9yIGEgc3RyaW5nIGFzIGFuIGFyZ3VtZW50Jyk7XG4gIH1cblxuICBpZiAodHlwZW9mIGluZGV4ID09PSAnb2JqZWN0Jykge1xuICAgIGZvciAobGV0IGkgPSB0aGlzLl9pbmRleGVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICBpZiAodXRpbC5pc0RlZXBTdHJpY3RFcXVhbCh0aGlzLl9pbmRleGVzW2ldWzBdLCBpbmRleCkpIHtcbiAgICAgICAgdGhpcy5faW5kZXhlcy5zcGxpY2UoaSwgMSk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGZvciAobGV0IGkgPSB0aGlzLl9pbmRleGVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICBpZiAodGhpcy5faW5kZXhlc1tpXVsxXSAhPSBudWxsICYmIHRoaXMuX2luZGV4ZXNbaV1bMV0ubmFtZSA9PT0gaW5kZXgpIHtcbiAgICAgICAgdGhpcy5faW5kZXhlcy5zcGxpY2UoaSwgMSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFJlbW92ZSBhbGwgaW5kZXhlcyBmcm9tIHRoaXMgc2NoZW1hLlxuICpcbiAqIGNsZWFySW5kZXhlcyBvbmx5IHJlbW92ZXMgaW5kZXhlcyBmcm9tIHlvdXIgc2NoZW1hIG9iamVjdC4gRG9lcyAqKm5vdCoqIGFmZmVjdCB0aGUgaW5kZXhlc1xuICogaW4gTW9uZ29EQi5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IFRveVNjaGVtYSA9IG5ldyBTY2hlbWEoeyBuYW1lOiBTdHJpbmcsIGNvbG9yOiBTdHJpbmcsIHByaWNlOiBOdW1iZXIgfSk7XG4gKiAgICAgVG95U2NoZW1hLmluZGV4KHsgbmFtZTogMSB9KTtcbiAqICAgICBUb3lTY2hlbWEuaW5kZXgoeyBjb2xvcjogMSB9KTtcbiAqXG4gKiAgICAgLy8gUmVtb3ZlIGFsbCBpbmRleGVzIG9uIHRoaXMgc2NoZW1hXG4gKiAgICAgVG95U2NoZW1hLmNsZWFySW5kZXhlcygpO1xuICpcbiAqICAgICBUb3lTY2hlbWEuaW5kZXhlcygpOyAvLyBbXVxuICpcbiAqIEByZXR1cm4ge1NjaGVtYX0gdGhlIFNjaGVtYSBpbnN0YW5jZVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5TY2hlbWEucHJvdG90eXBlLmNsZWFySW5kZXhlcyA9IGZ1bmN0aW9uIGNsZWFySW5kZXhlcygpIHtcbiAgdGhpcy5faW5kZXhlcy5sZW5ndGggPSAwO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBBZGQgYW4gW0F0bGFzIHNlYXJjaCBpbmRleF0oaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9hdGxhcy9hdGxhcy1zZWFyY2gvY3JlYXRlLWluZGV4LykgdGhhdCBNb25nb29zZSB3aWxsIGNyZWF0ZSB1c2luZyBgTW9kZWwuY3JlYXRlU2VhcmNoSW5kZXgoKWAuXG4gKiBUaGlzIGZ1bmN0aW9uIG9ubHkgd29ya3Mgd2hlbiBjb25uZWN0ZWQgdG8gTW9uZ29EQiBBdGxhcy5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IFRveVNjaGVtYSA9IG5ldyBTY2hlbWEoeyBuYW1lOiBTdHJpbmcsIGNvbG9yOiBTdHJpbmcsIHByaWNlOiBOdW1iZXIgfSk7XG4gKiAgICAgVG95U2NoZW1hLnNlYXJjaEluZGV4KHsgbmFtZTogJ3Rlc3QnLCBkZWZpbml0aW9uOiB7IG1hcHBpbmdzOiB7IGR5bmFtaWM6IHRydWUgfSB9IH0pO1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBkZXNjcmlwdGlvbiBpbmRleCBvcHRpb25zLCBpbmNsdWRpbmcgYG5hbWVgIGFuZCBgZGVmaW5pdGlvbmBcbiAqIEBwYXJhbSB7U3RyaW5nfSBkZXNjcmlwdGlvbi5uYW1lXG4gKiBAcGFyYW0ge09iamVjdH0gZGVzY3JpcHRpb24uZGVmaW5pdGlvblxuICogQHJldHVybiB7U2NoZW1hfSB0aGUgU2NoZW1hIGluc3RhbmNlXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblNjaGVtYS5wcm90b3R5cGUuc2VhcmNoSW5kZXggPSBmdW5jdGlvbiBzZWFyY2hJbmRleChkZXNjcmlwdGlvbikge1xuICB0aGlzLl9zZWFyY2hJbmRleGVzLnB1c2goZGVzY3JpcHRpb24pO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBSZXNlcnZlZCBkb2N1bWVudCBrZXlzLlxuICpcbiAqIEtleXMgaW4gdGhpcyBvYmplY3QgYXJlIG5hbWVzIHRoYXQgYXJlIHdhcm5lZCBpbiBzY2hlbWEgZGVjbGFyYXRpb25zXG4gKiBiZWNhdXNlIHRoZXkgaGF2ZSB0aGUgcG90ZW50aWFsIHRvIGJyZWFrIE1vbmdvb3NlLyBNb25nb29zZSBwbHVnaW5zIGZ1bmN0aW9uYWxpdHkuIElmIHlvdSBjcmVhdGUgYSBzY2hlbWFcbiAqIHVzaW5nIGBuZXcgU2NoZW1hKClgIHdpdGggb25lIG9mIHRoZXNlIHByb3BlcnR5IG5hbWVzLCBNb25nb29zZSB3aWxsIGxvZyBhIHdhcm5pbmcuXG4gKlxuICogLSBfcG9zdHNcbiAqIC0gX3ByZXNcbiAqIC0gY29sbGVjdGlvblxuICAqIC0gZW1pdFxuICogLSBlcnJvcnNcbiAqIC0gZ2V0XG4gKiAtIGluaXRcbiAqIC0gaXNNb2RpZmllZFxuICogLSBpc05ld1xuICogLSBsaXN0ZW5lcnNcbiAqIC0gbW9kZWxOYW1lXG4gKiAtIG9uXG4gKiAtIG9uY2VcbiAqIC0gcG9wdWxhdGVkXG4gKiAtIHByb3RvdHlwZVxuICogLSByZW1vdmVcbiAqIC0gcmVtb3ZlTGlzdGVuZXJcbiAqIC0gc2F2ZVxuICogLSBzY2hlbWFcbiAqIC0gdG9PYmplY3RcbiAqIC0gdmFsaWRhdGVcbiAqXG4gKiBfTk9URTpfIFVzZSBvZiB0aGVzZSB0ZXJtcyBhcyBtZXRob2QgbmFtZXMgaXMgcGVybWl0dGVkLCBidXQgcGxheSBhdCB5b3VyIG93biByaXNrLCBhcyB0aGV5IG1heSBiZSBleGlzdGluZyBtb25nb29zZSBkb2N1bWVudCBtZXRob2RzIHlvdSBhcmUgc3RvbXBpbmcgb24uXG4gKlxuICogICAgICBjb25zdCBzY2hlbWEgPSBuZXcgU2NoZW1hKC4uKTtcbiAqICAgICAgc2NoZW1hLm1ldGhvZHMuaW5pdCA9IGZ1bmN0aW9uICgpIHt9IC8vIHBvdGVudGlhbGx5IGJyZWFraW5nXG4gKlxuICogQHByb3BlcnR5IHJlc2VydmVkXG4gKiBAbWVtYmVyT2YgU2NoZW1hXG4gKiBAc3RhdGljXG4gKi9cblxuU2NoZW1hLnJlc2VydmVkID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblNjaGVtYS5wcm90b3R5cGUucmVzZXJ2ZWQgPSBTY2hlbWEucmVzZXJ2ZWQ7XG5cbmNvbnN0IHJlc2VydmVkID0gU2NoZW1hLnJlc2VydmVkO1xuLy8gQ29yZSBvYmplY3RcbnJlc2VydmVkWydwcm90b3R5cGUnXSA9XG4vLyBFdmVudEVtaXR0ZXJcbnJlc2VydmVkLmVtaXQgPVxucmVzZXJ2ZWQubGlzdGVuZXJzID1cbnJlc2VydmVkLnJlbW92ZUxpc3RlbmVyID1cblxuLy8gZG9jdW1lbnQgcHJvcGVydGllcyBhbmQgZnVuY3Rpb25zXG5yZXNlcnZlZC5jb2xsZWN0aW9uID1cbnJlc2VydmVkLmVycm9ycyA9XG5yZXNlcnZlZC5nZXQgPVxucmVzZXJ2ZWQuaW5pdCA9XG5yZXNlcnZlZC5pc01vZGlmaWVkID1cbnJlc2VydmVkLmlzTmV3ID1cbnJlc2VydmVkLnBvcHVsYXRlZCA9XG5yZXNlcnZlZC5yZW1vdmUgPVxucmVzZXJ2ZWQuc2F2ZSA9XG5yZXNlcnZlZC50b09iamVjdCA9XG5yZXNlcnZlZC52YWxpZGF0ZSA9IDE7XG5yZXNlcnZlZC5jb2xsZWN0aW9uID0gMTtcblxuLyoqXG4gKiBHZXRzL3NldHMgc2NoZW1hIHBhdGhzLlxuICpcbiAqIFNldHMgYSBwYXRoIChpZiBhcml0eSAyKVxuICogR2V0cyBhIHBhdGggKGlmIGFyaXR5IDEpXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBzY2hlbWEucGF0aCgnbmFtZScpIC8vIHJldHVybnMgYSBTY2hlbWFUeXBlXG4gKiAgICAgc2NoZW1hLnBhdGgoJ25hbWUnLCBOdW1iZXIpIC8vIGNoYW5nZXMgdGhlIHNjaGVtYVR5cGUgb2YgYG5hbWVgIHRvIE51bWJlclxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoIFRoZSBuYW1lIG9mIHRoZSBQYXRoIHRvIGdldCAvIHNldFxuICogQHBhcmFtIHtPYmplY3R9IFtvYmpdIFRoZSBUeXBlIHRvIHNldCB0aGUgcGF0aCB0bywgaWYgcHJvdmlkZWQgdGhlIHBhdGggd2lsbCBiZSBTRVQsIG90aGVyd2lzZSB0aGUgcGF0aCB3aWxsIGJlIEdFVFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5TY2hlbWEucHJvdG90eXBlLnBhdGggPSBmdW5jdGlvbihwYXRoLCBvYmopIHtcbiAgaWYgKG9iaiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gQ29udmVydCB0byAnLiQnIHRvIGNoZWNrIHN1YnBhdGhzIHJlOiBnaC02NDA1XG4gICAgY29uc3QgY2xlYW5QYXRoID0gX3BhdGhUb1Bvc2l0aW9uYWxTeW50YXgocGF0aCk7XG4gICAgbGV0IHNjaGVtYXR5cGUgPSBfZ2V0UGF0aCh0aGlzLCBwYXRoLCBjbGVhblBhdGgpO1xuICAgIGlmIChzY2hlbWF0eXBlICE9IG51bGwpIHtcbiAgICAgIHJldHVybiBzY2hlbWF0eXBlO1xuICAgIH1cblxuICAgIC8vIExvb2sgZm9yIG1hcHNcbiAgICBjb25zdCBtYXBQYXRoID0gZ2V0TWFwUGF0aCh0aGlzLCBwYXRoKTtcbiAgICBpZiAobWFwUGF0aCAhPSBudWxsKSB7XG4gICAgICByZXR1cm4gbWFwUGF0aDtcbiAgICB9XG5cbiAgICAvLyBMb29rIGlmIGEgcGFyZW50IG9mIHRoaXMgcGF0aCBpcyBtaXhlZFxuICAgIHNjaGVtYXR5cGUgPSB0aGlzLmhhc01peGVkUGFyZW50KGNsZWFuUGF0aCk7XG4gICAgaWYgKHNjaGVtYXR5cGUgIT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHNjaGVtYXR5cGU7XG4gICAgfVxuXG4gICAgLy8gc3VicGF0aHM/XG4gICAgcmV0dXJuIGhhc051bWVyaWNTdWJwYXRoUmVnZXgudGVzdChwYXRoKVxuICAgICAgPyBnZXRQb3NpdGlvbmFsUGF0aCh0aGlzLCBwYXRoLCBjbGVhblBhdGgpXG4gICAgICA6IHVuZGVmaW5lZDtcbiAgfVxuXG4gIC8vIHNvbWUgcGF0aCBuYW1lcyBjb25mbGljdCB3aXRoIGRvY3VtZW50IG1ldGhvZHNcbiAgY29uc3QgZmlyc3RQaWVjZU9mUGF0aCA9IHBhdGguc3BsaXQoJy4nKVswXTtcbiAgaWYgKHJlc2VydmVkW2ZpcnN0UGllY2VPZlBhdGhdICYmICF0aGlzLm9wdGlvbnMuc3VwcHJlc3NSZXNlcnZlZEtleXNXYXJuaW5nKSB7XG4gICAgY29uc3QgZXJyb3JNZXNzYWdlID0gYFxcYCR7Zmlyc3RQaWVjZU9mUGF0aH1cXGAgaXMgYSByZXNlcnZlZCBzY2hlbWEgcGF0aG5hbWUgYW5kIG1heSBicmVhayBzb21lIGZ1bmN0aW9uYWxpdHkuIGAgK1xuICAgICAgJ1lvdSBhcmUgYWxsb3dlZCB0byB1c2UgaXQsIGJ1dCB1c2UgYXQgeW91ciBvd24gcmlzay4gJyArXG4gICAgICAnVG8gZGlzYWJsZSB0aGlzIHdhcm5pbmcgcGFzcyBgc3VwcHJlc3NSZXNlcnZlZEtleXNXYXJuaW5nYCBhcyBhIHNjaGVtYSBvcHRpb24uJztcblxuICAgIHV0aWxzLndhcm4oZXJyb3JNZXNzYWdlKTtcbiAgfVxuXG4gIGlmICh0eXBlb2Ygb2JqID09PSAnb2JqZWN0JyAmJiB1dGlscy5oYXNVc2VyRGVmaW5lZFByb3BlcnR5KG9iaiwgJ3JlZicpKSB7XG4gICAgdmFsaWRhdGVSZWYob2JqLnJlZiwgcGF0aCk7XG4gIH1cblxuICAvLyB1cGRhdGUgdGhlIHRyZWVcbiAgY29uc3Qgc3VicGF0aHMgPSBwYXRoLnNwbGl0KC9cXC4vKTtcbiAgY29uc3QgbGFzdCA9IHN1YnBhdGhzLnBvcCgpO1xuICBsZXQgYnJhbmNoID0gdGhpcy50cmVlO1xuICBsZXQgZnVsbFBhdGggPSAnJztcblxuICBmb3IgKGNvbnN0IHN1YiBvZiBzdWJwYXRocykge1xuICAgIGlmICh1dGlscy5zcGVjaWFsUHJvcGVydGllcy5oYXMoc3ViKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3Qgc2V0IHNwZWNpYWwgcHJvcGVydHkgYCcgKyBzdWIgKyAnYCBvbiBhIHNjaGVtYScpO1xuICAgIH1cbiAgICBmdWxsUGF0aCA9IGZ1bGxQYXRoICs9IChmdWxsUGF0aC5sZW5ndGggPiAwID8gJy4nIDogJycpICsgc3ViO1xuICAgIGlmICghYnJhbmNoW3N1Yl0pIHtcbiAgICAgIHRoaXMubmVzdGVkW2Z1bGxQYXRoXSA9IHRydWU7XG4gICAgICBicmFuY2hbc3ViXSA9IHt9O1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGJyYW5jaFtzdWJdICE9PSAnb2JqZWN0Jykge1xuICAgICAgY29uc3QgbXNnID0gJ0Nhbm5vdCBzZXQgbmVzdGVkIHBhdGggYCcgKyBwYXRoICsgJ2AuICdcbiAgICAgICAgICArICdQYXJlbnQgcGF0aCBgJ1xuICAgICAgICAgICsgZnVsbFBhdGhcbiAgICAgICAgICArICdgIGFscmVhZHkgc2V0IHRvIHR5cGUgJyArIGJyYW5jaFtzdWJdLm5hbWVcbiAgICAgICAgICArICcuJztcbiAgICAgIHRocm93IG5ldyBFcnJvcihtc2cpO1xuICAgIH1cbiAgICBicmFuY2ggPSBicmFuY2hbc3ViXTtcbiAgfVxuXG4gIGJyYW5jaFtsYXN0XSA9IGNsb25lKG9iaik7XG5cbiAgdGhpcy5wYXRoc1twYXRoXSA9IHRoaXMuaW50ZXJwcmV0QXNUeXBlKHBhdGgsIG9iaiwgdGhpcy5vcHRpb25zKTtcbiAgY29uc3Qgc2NoZW1hVHlwZSA9IHRoaXMucGF0aHNbcGF0aF07XG5cbiAgaWYgKHNjaGVtYVR5cGUuJGlzU2NoZW1hTWFwKSB7XG4gICAgLy8gTWFwcyBjYW4gaGF2ZSBhcmJpdHJhcnkga2V5cywgc28gYCQqYCBpcyBpbnRlcm5hbCBzaG9ydGhhbmQgZm9yIFwiYW55IGtleVwiXG4gICAgLy8gVGhlICckJyBpcyB0byBpbXBseSB0aGlzIHBhdGggc2hvdWxkIG5ldmVyIGJlIHN0b3JlZCBpbiBNb25nb0RCIHNvIHdlXG4gICAgLy8gY2FuIGVhc2lseSBidWlsZCBhIHJlZ2V4cCBvdXQgb2YgdGhpcyBwYXRoLCBhbmQgJyonIHRvIGltcGx5IFwiYW55IGtleS5cIlxuICAgIGNvbnN0IG1hcFBhdGggPSBwYXRoICsgJy4kKic7XG5cbiAgICB0aGlzLnBhdGhzW21hcFBhdGhdID0gc2NoZW1hVHlwZS4kX19zY2hlbWFUeXBlO1xuICAgIHRoaXMubWFwUGF0aHMucHVzaCh0aGlzLnBhdGhzW21hcFBhdGhdKTtcbiAgfVxuXG4gIGlmIChzY2hlbWFUeXBlLiRpc1NpbmdsZU5lc3RlZCkge1xuICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKHNjaGVtYVR5cGUuc2NoZW1hLnBhdGhzKSkge1xuICAgICAgdGhpcy5zaW5nbGVOZXN0ZWRQYXRoc1twYXRoICsgJy4nICsga2V5XSA9IHNjaGVtYVR5cGUuc2NoZW1hLnBhdGhzW2tleV07XG4gICAgfVxuICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKHNjaGVtYVR5cGUuc2NoZW1hLnNpbmdsZU5lc3RlZFBhdGhzKSkge1xuICAgICAgdGhpcy5zaW5nbGVOZXN0ZWRQYXRoc1twYXRoICsgJy4nICsga2V5XSA9XG4gICAgICAgIHNjaGVtYVR5cGUuc2NoZW1hLnNpbmdsZU5lc3RlZFBhdGhzW2tleV07XG4gICAgfVxuICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKHNjaGVtYVR5cGUuc2NoZW1hLnN1YnBhdGhzKSkge1xuICAgICAgdGhpcy5zaW5nbGVOZXN0ZWRQYXRoc1twYXRoICsgJy4nICsga2V5XSA9XG4gICAgICAgIHNjaGVtYVR5cGUuc2NoZW1hLnN1YnBhdGhzW2tleV07XG4gICAgfVxuICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKHNjaGVtYVR5cGUuc2NoZW1hLm5lc3RlZCkpIHtcbiAgICAgIHRoaXMuc2luZ2xlTmVzdGVkUGF0aHNbcGF0aCArICcuJyArIGtleV0gPSAnbmVzdGVkJztcbiAgICB9XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoc2NoZW1hVHlwZS5zY2hlbWEsICdiYXNlJywge1xuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICB2YWx1ZTogdGhpcy5iYXNlXG4gICAgfSk7XG5cbiAgICBzY2hlbWFUeXBlLmNhc3Rlci5iYXNlID0gdGhpcy5iYXNlO1xuICAgIHRoaXMuY2hpbGRTY2hlbWFzLnB1c2goe1xuICAgICAgc2NoZW1hOiBzY2hlbWFUeXBlLnNjaGVtYSxcbiAgICAgIG1vZGVsOiBzY2hlbWFUeXBlLmNhc3RlclxuICAgIH0pO1xuICB9IGVsc2UgaWYgKHNjaGVtYVR5cGUuJGlzTW9uZ29vc2VEb2N1bWVudEFycmF5KSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHNjaGVtYVR5cGUuc2NoZW1hLCAnYmFzZScsIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgdmFsdWU6IHRoaXMuYmFzZVxuICAgIH0pO1xuXG4gICAgc2NoZW1hVHlwZS5jYXN0ZXJDb25zdHJ1Y3Rvci5iYXNlID0gdGhpcy5iYXNlO1xuICAgIHRoaXMuY2hpbGRTY2hlbWFzLnB1c2goe1xuICAgICAgc2NoZW1hOiBzY2hlbWFUeXBlLnNjaGVtYSxcbiAgICAgIG1vZGVsOiBzY2hlbWFUeXBlLmNhc3RlckNvbnN0cnVjdG9yXG4gICAgfSk7XG4gIH1cblxuICBpZiAoc2NoZW1hVHlwZS4kaXNNb25nb29zZUFycmF5ICYmIHNjaGVtYVR5cGUuY2FzdGVyIGluc3RhbmNlb2YgU2NoZW1hVHlwZSkge1xuICAgIGxldCBhcnJheVBhdGggPSBwYXRoO1xuICAgIGxldCBfc2NoZW1hVHlwZSA9IHNjaGVtYVR5cGU7XG5cbiAgICBjb25zdCB0b0FkZCA9IFtdO1xuICAgIHdoaWxlIChfc2NoZW1hVHlwZS4kaXNNb25nb29zZUFycmF5KSB7XG4gICAgICBhcnJheVBhdGggPSBhcnJheVBhdGggKyAnLiQnO1xuXG4gICAgICAvLyBTa2lwIGFycmF5cyBvZiBkb2N1bWVudCBhcnJheXNcbiAgICAgIGlmIChfc2NoZW1hVHlwZS4kaXNNb25nb29zZURvY3VtZW50QXJyYXkpIHtcbiAgICAgICAgX3NjaGVtYVR5cGUuJGVtYmVkZGVkU2NoZW1hVHlwZS5fYXJyYXlQYXRoID0gYXJyYXlQYXRoO1xuICAgICAgICBfc2NoZW1hVHlwZS4kZW1iZWRkZWRTY2hlbWFUeXBlLl9hcnJheVBhcmVudFBhdGggPSBwYXRoO1xuICAgICAgICBfc2NoZW1hVHlwZSA9IF9zY2hlbWFUeXBlLiRlbWJlZGRlZFNjaGVtYVR5cGU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfc2NoZW1hVHlwZS5jYXN0ZXIuX2FycmF5UGF0aCA9IGFycmF5UGF0aDtcbiAgICAgICAgX3NjaGVtYVR5cGUuY2FzdGVyLl9hcnJheVBhcmVudFBhdGggPSBwYXRoO1xuICAgICAgICBfc2NoZW1hVHlwZSA9IF9zY2hlbWFUeXBlLmNhc3RlcjtcbiAgICAgIH1cblxuICAgICAgdGhpcy5zdWJwYXRoc1thcnJheVBhdGhdID0gX3NjaGVtYVR5cGU7XG4gICAgfVxuXG4gICAgZm9yIChjb25zdCBfc2NoZW1hVHlwZSBvZiB0b0FkZCkge1xuICAgICAgdGhpcy5zdWJwYXRoc1tfc2NoZW1hVHlwZS5wYXRoXSA9IF9zY2hlbWFUeXBlO1xuICAgIH1cbiAgfVxuXG4gIGlmIChzY2hlbWFUeXBlLiRpc01vbmdvb3NlRG9jdW1lbnRBcnJheSkge1xuICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKHNjaGVtYVR5cGUuc2NoZW1hLnBhdGhzKSkge1xuICAgICAgY29uc3QgX3NjaGVtYVR5cGUgPSBzY2hlbWFUeXBlLnNjaGVtYS5wYXRoc1trZXldO1xuICAgICAgdGhpcy5zdWJwYXRoc1twYXRoICsgJy4nICsga2V5XSA9IF9zY2hlbWFUeXBlO1xuICAgICAgaWYgKHR5cGVvZiBfc2NoZW1hVHlwZSA9PT0gJ29iamVjdCcgJiYgX3NjaGVtYVR5cGUgIT0gbnVsbCAmJiBfc2NoZW1hVHlwZS4kcGFyZW50U2NoZW1hRG9jQXJyYXkgPT0gbnVsbCkge1xuICAgICAgICBfc2NoZW1hVHlwZS4kcGFyZW50U2NoZW1hRG9jQXJyYXkgPSBzY2hlbWFUeXBlO1xuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhzY2hlbWFUeXBlLnNjaGVtYS5zdWJwYXRocykpIHtcbiAgICAgIGNvbnN0IF9zY2hlbWFUeXBlID0gc2NoZW1hVHlwZS5zY2hlbWEuc3VicGF0aHNba2V5XTtcbiAgICAgIHRoaXMuc3VicGF0aHNbcGF0aCArICcuJyArIGtleV0gPSBfc2NoZW1hVHlwZTtcbiAgICAgIGlmICh0eXBlb2YgX3NjaGVtYVR5cGUgPT09ICdvYmplY3QnICYmIF9zY2hlbWFUeXBlICE9IG51bGwgJiYgX3NjaGVtYVR5cGUuJHBhcmVudFNjaGVtYURvY0FycmF5ID09IG51bGwpIHtcbiAgICAgICAgX3NjaGVtYVR5cGUuJHBhcmVudFNjaGVtYURvY0FycmF5ID0gc2NoZW1hVHlwZTtcbiAgICAgIH1cbiAgICB9XG4gICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMoc2NoZW1hVHlwZS5zY2hlbWEuc2luZ2xlTmVzdGVkUGF0aHMpKSB7XG4gICAgICBjb25zdCBfc2NoZW1hVHlwZSA9IHNjaGVtYVR5cGUuc2NoZW1hLnNpbmdsZU5lc3RlZFBhdGhzW2tleV07XG4gICAgICB0aGlzLnN1YnBhdGhzW3BhdGggKyAnLicgKyBrZXldID0gX3NjaGVtYVR5cGU7XG4gICAgICBpZiAodHlwZW9mIF9zY2hlbWFUeXBlID09PSAnb2JqZWN0JyAmJiBfc2NoZW1hVHlwZSAhPSBudWxsICYmIF9zY2hlbWFUeXBlLiRwYXJlbnRTY2hlbWFEb2NBcnJheSA9PSBudWxsKSB7XG4gICAgICAgIF9zY2hlbWFUeXBlLiRwYXJlbnRTY2hlbWFEb2NBcnJheSA9IHNjaGVtYVR5cGU7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cbmZ1bmN0aW9uIGdhdGhlckNoaWxkU2NoZW1hcyhzY2hlbWEpIHtcbiAgY29uc3QgY2hpbGRTY2hlbWFzID0gW107XG5cbiAgZm9yIChjb25zdCBwYXRoIG9mIE9iamVjdC5rZXlzKHNjaGVtYS5wYXRocykpIHtcbiAgICBjb25zdCBzY2hlbWF0eXBlID0gc2NoZW1hLnBhdGhzW3BhdGhdO1xuICAgIGlmIChzY2hlbWF0eXBlLiRpc01vbmdvb3NlRG9jdW1lbnRBcnJheSB8fCBzY2hlbWF0eXBlLiRpc1NpbmdsZU5lc3RlZCkge1xuICAgICAgY2hpbGRTY2hlbWFzLnB1c2goeyBzY2hlbWE6IHNjaGVtYXR5cGUuc2NoZW1hLCBtb2RlbDogc2NoZW1hdHlwZS5jYXN0ZXIgfSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGNoaWxkU2NoZW1hcztcbn1cblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5mdW5jdGlvbiBfZ2V0UGF0aChzY2hlbWEsIHBhdGgsIGNsZWFuUGF0aCkge1xuICBpZiAoc2NoZW1hLnBhdGhzLmhhc093blByb3BlcnR5KHBhdGgpKSB7XG4gICAgcmV0dXJuIHNjaGVtYS5wYXRoc1twYXRoXTtcbiAgfVxuICBpZiAoc2NoZW1hLnN1YnBhdGhzLmhhc093blByb3BlcnR5KGNsZWFuUGF0aCkpIHtcbiAgICByZXR1cm4gc2NoZW1hLnN1YnBhdGhzW2NsZWFuUGF0aF07XG4gIH1cbiAgaWYgKHNjaGVtYS5zaW5nbGVOZXN0ZWRQYXRocy5oYXNPd25Qcm9wZXJ0eShjbGVhblBhdGgpICYmIHR5cGVvZiBzY2hlbWEuc2luZ2xlTmVzdGVkUGF0aHNbY2xlYW5QYXRoXSA9PT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gc2NoZW1hLnNpbmdsZU5lc3RlZFBhdGhzW2NsZWFuUGF0aF07XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5mdW5jdGlvbiBfcGF0aFRvUG9zaXRpb25hbFN5bnRheChwYXRoKSB7XG4gIGlmICghL1xcLlxcZCsvLnRlc3QocGF0aCkpIHtcbiAgICByZXR1cm4gcGF0aDtcbiAgfVxuICByZXR1cm4gcGF0aC5yZXBsYWNlKC9cXC5cXGQrXFwuL2csICcuJC4nKS5yZXBsYWNlKC9cXC5cXGQrJC8sICcuJCcpO1xufVxuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cbmZ1bmN0aW9uIGdldE1hcFBhdGgoc2NoZW1hLCBwYXRoKSB7XG4gIGlmIChzY2hlbWEubWFwUGF0aHMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgZm9yIChjb25zdCB2YWwgb2Ygc2NoZW1hLm1hcFBhdGhzKSB7XG4gICAgY29uc3QgX3BhdGggPSB2YWwucGF0aDtcbiAgICBjb25zdCByZSA9IG5ldyBSZWdFeHAoJ14nICsgX3BhdGgucmVwbGFjZSgvXFwuXFwkXFwqL2csICdcXFxcLlteLl0rJykgKyAnJCcpO1xuICAgIGlmIChyZS50ZXN0KHBhdGgpKSB7XG4gICAgICByZXR1cm4gc2NoZW1hLnBhdGhzW19wYXRoXTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxuLyoqXG4gKiBUaGUgTW9uZ29vc2UgaW5zdGFuY2UgdGhpcyBzY2hlbWEgaXMgYXNzb2NpYXRlZCB3aXRoXG4gKlxuICogQHByb3BlcnR5IGJhc2VcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShTY2hlbWEucHJvdG90eXBlLCAnYmFzZScsIHtcbiAgY29uZmlndXJhYmxlOiB0cnVlLFxuICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgd3JpdGFibGU6IHRydWUsXG4gIHZhbHVlOiBudWxsXG59KTtcblxuLyoqXG4gKiBDb252ZXJ0cyB0eXBlIGFyZ3VtZW50cyBpbnRvIE1vbmdvb3NlIFR5cGVzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqIGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU2NoZW1hLnByb3RvdHlwZS5pbnRlcnByZXRBc1R5cGUgPSBmdW5jdGlvbihwYXRoLCBvYmosIG9wdGlvbnMpIHtcbiAgaWYgKG9iaiBpbnN0YW5jZW9mIFNjaGVtYVR5cGUpIHtcbiAgICBpZiAob2JqLnBhdGggPT09IHBhdGgpIHtcbiAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuICAgIGNvbnN0IGNsb25lID0gb2JqLmNsb25lKCk7XG4gICAgY2xvbmUucGF0aCA9IHBhdGg7XG4gICAgcmV0dXJuIGNsb25lO1xuICB9XG5cbiAgLy8gSWYgdGhpcyBzY2hlbWEgaGFzIGFuIGFzc29jaWF0ZWQgTW9uZ29vc2Ugb2JqZWN0LCB1c2UgdGhlIE1vbmdvb3NlIG9iamVjdCdzXG4gIC8vIGNvcHkgb2YgU2NoZW1hVHlwZXMgcmU6IGdoLTcxNTggZ2gtNjkzM1xuICBjb25zdCBNb25nb29zZVR5cGVzID0gdGhpcy5iYXNlICE9IG51bGwgPyB0aGlzLmJhc2UuU2NoZW1hLlR5cGVzIDogU2NoZW1hLlR5cGVzO1xuICBjb25zdCBUeXBlcyA9IHRoaXMuYmFzZSAhPSBudWxsID8gdGhpcy5iYXNlLlR5cGVzIDogcmVxdWlyZSgnLi90eXBlcycpO1xuXG4gIGlmICghdXRpbHMuaXNQT0pPKG9iaikgJiYgIShvYmogaW5zdGFuY2VvZiBTY2hlbWFUeXBlT3B0aW9ucykpIHtcbiAgICBjb25zdCBjb25zdHJ1Y3Rvck5hbWUgPSB1dGlscy5nZXRGdW5jdGlvbk5hbWUob2JqLmNvbnN0cnVjdG9yKTtcbiAgICBpZiAoY29uc3RydWN0b3JOYW1lICE9PSAnT2JqZWN0Jykge1xuICAgICAgY29uc3Qgb2xkT2JqID0gb2JqO1xuICAgICAgb2JqID0ge307XG4gICAgICBvYmpbb3B0aW9ucy50eXBlS2V5XSA9IG9sZE9iajtcbiAgICB9XG4gIH1cblxuICAvLyBHZXQgdGhlIHR5cGUgbWFraW5nIHN1cmUgdG8gYWxsb3cga2V5cyBuYW1lZCBcInR5cGVcIlxuICAvLyBhbmQgZGVmYXVsdCB0byBtaXhlZCBpZiBub3Qgc3BlY2lmaWVkLlxuICAvLyB7IHR5cGU6IHsgdHlwZTogU3RyaW5nLCBkZWZhdWx0OiAnZnJlc2hjdXQnIH0gfVxuICBsZXQgdHlwZSA9IG9ialtvcHRpb25zLnR5cGVLZXldICYmIChvYmpbb3B0aW9ucy50eXBlS2V5XSBpbnN0YW5jZW9mIEZ1bmN0aW9uIHx8IG9wdGlvbnMudHlwZUtleSAhPT0gJ3R5cGUnIHx8ICFvYmoudHlwZS50eXBlKVxuICAgID8gb2JqW29wdGlvbnMudHlwZUtleV1cbiAgICA6IHt9O1xuICBsZXQgbmFtZTtcblxuICBpZiAodXRpbHMuaXNQT0pPKHR5cGUpIHx8IHR5cGUgPT09ICdtaXhlZCcpIHtcbiAgICByZXR1cm4gbmV3IE1vbmdvb3NlVHlwZXMuTWl4ZWQocGF0aCwgb2JqKTtcbiAgfVxuXG4gIGlmIChBcnJheS5pc0FycmF5KHR5cGUpIHx8IHR5cGUgPT09IEFycmF5IHx8IHR5cGUgPT09ICdhcnJheScgfHwgdHlwZSA9PT0gTW9uZ29vc2VUeXBlcy5BcnJheSkge1xuICAgIC8vIGlmIGl0IHdhcyBzcGVjaWZpZWQgdGhyb3VnaCB7IHR5cGUgfSBsb29rIGZvciBgY2FzdGBcbiAgICBsZXQgY2FzdCA9ICh0eXBlID09PSBBcnJheSB8fCB0eXBlID09PSAnYXJyYXknKVxuICAgICAgPyBvYmouY2FzdCB8fCBvYmoub2ZcbiAgICAgIDogdHlwZVswXTtcblxuICAgIC8vIG5ldyBTY2hlbWEoeyBwYXRoOiBbbmV3IFNjaGVtYSh7IC4uLiB9KV0gfSlcbiAgICBpZiAoY2FzdCAmJiBjYXN0Lmluc3RhbmNlT2ZTY2hlbWEpIHtcbiAgICAgIGlmICghKGNhc3QgaW5zdGFuY2VvZiBTY2hlbWEpKSB7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuX2lzTWVyZ2luZykge1xuICAgICAgICAgIGNhc3QgPSBuZXcgU2NoZW1hKGNhc3QpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1NjaGVtYSBmb3IgYXJyYXkgcGF0aCBgJyArIHBhdGggK1xuICAgICAgICAgICAgJ2AgaXMgZnJvbSBhIGRpZmZlcmVudCBjb3B5IG9mIHRoZSBNb25nb29zZSBtb2R1bGUuICcgK1xuICAgICAgICAgICAgJ1BsZWFzZSBtYWtlIHN1cmUgeW91XFwncmUgdXNpbmcgdGhlIHNhbWUgdmVyc2lvbiAnICtcbiAgICAgICAgICAgICdvZiBNb25nb29zZSBldmVyeXdoZXJlIHdpdGggYG5wbSBsaXN0IG1vbmdvb3NlYC4gSWYgeW91IGFyZSBzdGlsbCAnICtcbiAgICAgICAgICAgICdnZXR0aW5nIHRoaXMgZXJyb3IsIHBsZWFzZSBhZGQgYG5ldyBTY2hlbWEoKWAgYXJvdW5kIHRoZSBwYXRoOiAnICtcbiAgICAgICAgICAgIGAke3BhdGh9OiBuZXcgU2NoZW1hKC4uLilgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyBNb25nb29zZVR5cGVzLkRvY3VtZW50QXJyYXkocGF0aCwgY2FzdCwgb2JqKTtcbiAgICB9XG4gICAgaWYgKGNhc3QgJiZcbiAgICAgICAgY2FzdFtvcHRpb25zLnR5cGVLZXldICYmXG4gICAgICAgIGNhc3Rbb3B0aW9ucy50eXBlS2V5XS5pbnN0YW5jZU9mU2NoZW1hKSB7XG4gICAgICBpZiAoIShjYXN0W29wdGlvbnMudHlwZUtleV0gaW5zdGFuY2VvZiBTY2hlbWEpKSB7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuX2lzTWVyZ2luZykge1xuICAgICAgICAgIGNhc3Rbb3B0aW9ucy50eXBlS2V5XSA9IG5ldyBTY2hlbWEoY2FzdFtvcHRpb25zLnR5cGVLZXldKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdTY2hlbWEgZm9yIGFycmF5IHBhdGggYCcgKyBwYXRoICtcbiAgICAgICAgICAgICdgIGlzIGZyb20gYSBkaWZmZXJlbnQgY29weSBvZiB0aGUgTW9uZ29vc2UgbW9kdWxlLiAnICtcbiAgICAgICAgICAgICdQbGVhc2UgbWFrZSBzdXJlIHlvdVxcJ3JlIHVzaW5nIHRoZSBzYW1lIHZlcnNpb24gJyArXG4gICAgICAgICAgICAnb2YgTW9uZ29vc2UgZXZlcnl3aGVyZSB3aXRoIGBucG0gbGlzdCBtb25nb29zZWAuIElmIHlvdSBhcmUgc3RpbGwgJyArXG4gICAgICAgICAgICAnZ2V0dGluZyB0aGlzIGVycm9yLCBwbGVhc2UgYWRkIGBuZXcgU2NoZW1hKClgIGFyb3VuZCB0aGUgcGF0aDogJyArXG4gICAgICAgICAgICBgJHtwYXRofTogbmV3IFNjaGVtYSguLi4pYCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgTW9uZ29vc2VUeXBlcy5Eb2N1bWVudEFycmF5KHBhdGgsIGNhc3Rbb3B0aW9ucy50eXBlS2V5XSwgb2JqLCBjYXN0KTtcbiAgICB9XG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheShjYXN0KSkge1xuICAgICAgcmV0dXJuIG5ldyBNb25nb29zZVR5cGVzLkFycmF5KHBhdGgsIHRoaXMuaW50ZXJwcmV0QXNUeXBlKHBhdGgsIGNhc3QsIG9wdGlvbnMpLCBvYmopO1xuICAgIH1cblxuICAgIC8vIEhhbmRsZSBib3RoIGBuZXcgU2NoZW1hKHsgYXJyOiBbeyBzdWJwYXRoOiBTdHJpbmcgfV0gfSlgIGFuZCBgbmV3IFNjaGVtYSh7IGFycjogW3sgdHlwZTogeyBzdWJwYXRoOiBzdHJpbmcgfSB9XSB9KWBcbiAgICBjb25zdCBjYXN0RnJvbVR5cGVLZXkgPSAoY2FzdCAhPSBudWxsICYmIGNhc3Rbb3B0aW9ucy50eXBlS2V5XSAmJiAob3B0aW9ucy50eXBlS2V5ICE9PSAndHlwZScgfHwgIWNhc3QudHlwZS50eXBlKSkgP1xuICAgICAgY2FzdFtvcHRpb25zLnR5cGVLZXldIDpcbiAgICAgIGNhc3Q7XG4gICAgaWYgKHR5cGVvZiBjYXN0ID09PSAnc3RyaW5nJykge1xuICAgICAgY2FzdCA9IE1vbmdvb3NlVHlwZXNbY2FzdC5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIGNhc3Quc3Vic3RyaW5nKDEpXTtcbiAgICB9IGVsc2UgaWYgKHV0aWxzLmlzUE9KTyhjYXN0RnJvbVR5cGVLZXkpKSB7XG4gICAgICBpZiAoT2JqZWN0LmtleXMoY2FzdEZyb21UeXBlS2V5KS5sZW5ndGgpIHtcbiAgICAgICAgLy8gVGhlIGBtaW5pbWl6ZWAgYW5kIGB0eXBlS2V5YCBvcHRpb25zIHByb3BhZ2F0ZSB0byBjaGlsZCBzY2hlbWFzXG4gICAgICAgIC8vIGRlY2xhcmVkIGlubGluZSwgbGlrZSBgeyBhcnI6IFt7IHZhbDogeyAkdHlwZTogU3RyaW5nIH0gfV0gfWAuXG4gICAgICAgIC8vIFNlZSBnaC0zNTYwXG4gICAgICAgIGNvbnN0IGNoaWxkU2NoZW1hT3B0aW9ucyA9IHsgbWluaW1pemU6IG9wdGlvbnMubWluaW1pemUgfTtcbiAgICAgICAgaWYgKG9wdGlvbnMudHlwZUtleSkge1xuICAgICAgICAgIGNoaWxkU2NoZW1hT3B0aW9ucy50eXBlS2V5ID0gb3B0aW9ucy50eXBlS2V5O1xuICAgICAgICB9XG4gICAgICAgIC8vIHByb3BhZ2F0ZSAnc3RyaWN0JyBvcHRpb24gdG8gY2hpbGQgc2NoZW1hXG4gICAgICAgIGlmIChvcHRpb25zLmhhc093blByb3BlcnR5KCdzdHJpY3QnKSkge1xuICAgICAgICAgIGNoaWxkU2NoZW1hT3B0aW9ucy5zdHJpY3QgPSBvcHRpb25zLnN0cmljdDtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5oYXNPd25Qcm9wZXJ0eSgnc3RyaWN0UXVlcnknKSkge1xuICAgICAgICAgIGNoaWxkU2NoZW1hT3B0aW9ucy5zdHJpY3RRdWVyeSA9IG9wdGlvbnMuc3RyaWN0UXVlcnk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMuaGFzT3duUHJvcGVydHkoJ3RvT2JqZWN0JykpIHtcbiAgICAgICAgICBjaGlsZFNjaGVtYU9wdGlvbnMudG9PYmplY3QgPSB1dGlscy5vbWl0KG9wdGlvbnMudG9PYmplY3QsIFsndHJhbnNmb3JtJ10pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLmhhc093blByb3BlcnR5KCd0b0pTT04nKSkge1xuICAgICAgICAgIGNoaWxkU2NoZW1hT3B0aW9ucy50b0pTT04gPSB1dGlscy5vbWl0KG9wdGlvbnMudG9KU09OLCBbJ3RyYW5zZm9ybSddKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLl91c2VyUHJvdmlkZWRPcHRpb25zLmhhc093blByb3BlcnR5KCdfaWQnKSkge1xuICAgICAgICAgIGNoaWxkU2NoZW1hT3B0aW9ucy5faWQgPSB0aGlzLl91c2VyUHJvdmlkZWRPcHRpb25zLl9pZDtcbiAgICAgICAgfSBlbHNlIGlmIChTY2hlbWEuVHlwZXMuRG9jdW1lbnRBcnJheS5kZWZhdWx0T3B0aW9ucy5faWQgIT0gbnVsbCkge1xuICAgICAgICAgIGNoaWxkU2NoZW1hT3B0aW9ucy5faWQgPSBTY2hlbWEuVHlwZXMuRG9jdW1lbnRBcnJheS5kZWZhdWx0T3B0aW9ucy5faWQ7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBjaGlsZFNjaGVtYSA9IG5ldyBTY2hlbWEoY2FzdEZyb21UeXBlS2V5LCBjaGlsZFNjaGVtYU9wdGlvbnMpO1xuICAgICAgICBjaGlsZFNjaGVtYS4kaW1wbGljaXRseUNyZWF0ZWQgPSB0cnVlO1xuICAgICAgICByZXR1cm4gbmV3IE1vbmdvb3NlVHlwZXMuRG9jdW1lbnRBcnJheShwYXRoLCBjaGlsZFNjaGVtYSwgb2JqKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFNwZWNpYWwgY2FzZTogZW1wdHkgb2JqZWN0IGJlY29tZXMgbWl4ZWRcbiAgICAgICAgcmV0dXJuIG5ldyBNb25nb29zZVR5cGVzLkFycmF5KHBhdGgsIE1vbmdvb3NlVHlwZXMuTWl4ZWQsIG9iaik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGNhc3QpIHtcbiAgICAgIHR5cGUgPSBjYXN0W29wdGlvbnMudHlwZUtleV0gJiYgKG9wdGlvbnMudHlwZUtleSAhPT0gJ3R5cGUnIHx8ICFjYXN0LnR5cGUudHlwZSlcbiAgICAgICAgPyBjYXN0W29wdGlvbnMudHlwZUtleV1cbiAgICAgICAgOiBjYXN0O1xuXG4gICAgICBpZiAoQXJyYXkuaXNBcnJheSh0eXBlKSkge1xuICAgICAgICByZXR1cm4gbmV3IE1vbmdvb3NlVHlwZXMuQXJyYXkocGF0aCwgdGhpcy5pbnRlcnByZXRBc1R5cGUocGF0aCwgdHlwZSwgb3B0aW9ucyksIG9iaik7XG4gICAgICB9XG5cbiAgICAgIG5hbWUgPSB0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZydcbiAgICAgICAgPyB0eXBlXG4gICAgICAgIDogdHlwZS5zY2hlbWFOYW1lIHx8IHV0aWxzLmdldEZ1bmN0aW9uTmFtZSh0eXBlKTtcblxuICAgICAgLy8gRm9yIEplc3QgMjYrLCBzZWUgIzEwMjk2XG4gICAgICBpZiAobmFtZSA9PT0gJ0Nsb2NrRGF0ZScpIHtcbiAgICAgICAgbmFtZSA9ICdEYXRlJztcbiAgICAgIH1cblxuICAgICAgaWYgKG5hbWUgPT09IHZvaWQgMCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIHNjaGVtYSBjb25maWd1cmF0aW9uOiAnICtcbiAgICAgICAgICBgQ291bGQgbm90IGRldGVybWluZSB0aGUgZW1iZWRkZWQgdHlwZSBmb3IgYXJyYXkgXFxgJHtwYXRofVxcYC4gYCArXG4gICAgICAgICAgJ1NlZSBodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvZ3VpZGUuaHRtbCNkZWZpbml0aW9uIGZvciBtb3JlIGluZm8gb24gc3VwcG9ydGVkIHNjaGVtYSBzeW50YXhlcy4nKTtcbiAgICAgIH1cbiAgICAgIGlmICghTW9uZ29vc2VUeXBlcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIHNjaGVtYSBjb25maWd1cmF0aW9uOiAnICtcbiAgICAgICAgICBgXFxgJHtuYW1lfVxcYCBpcyBub3QgYSB2YWxpZCB0eXBlIHdpdGhpbiB0aGUgYXJyYXkgXFxgJHtwYXRofVxcYC5gICtcbiAgICAgICAgICAnU2VlIGh0dHBzOi8vYml0Lmx5L21vbmdvb3NlLXNjaGVtYXR5cGVzIGZvciBhIGxpc3Qgb2YgdmFsaWQgc2NoZW1hIHR5cGVzLicpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBuZXcgTW9uZ29vc2VUeXBlcy5BcnJheShwYXRoLCBjYXN0IHx8IE1vbmdvb3NlVHlwZXMuTWl4ZWQsIG9iaiwgb3B0aW9ucyk7XG4gIH1cblxuICBpZiAodHlwZSAmJiB0eXBlLmluc3RhbmNlT2ZTY2hlbWEpIHtcbiAgICByZXR1cm4gbmV3IE1vbmdvb3NlVHlwZXMuU3ViZG9jdW1lbnQodHlwZSwgcGF0aCwgb2JqKTtcbiAgfVxuXG4gIGlmIChCdWZmZXIuaXNCdWZmZXIodHlwZSkpIHtcbiAgICBuYW1lID0gJ0J1ZmZlcic7XG4gIH0gZWxzZSBpZiAodHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIHR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgbmFtZSA9IHR5cGUuc2NoZW1hTmFtZSB8fCB1dGlscy5nZXRGdW5jdGlvbk5hbWUodHlwZSk7XG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gVHlwZXMuT2JqZWN0SWQpIHtcbiAgICBuYW1lID0gJ09iamVjdElkJztcbiAgfSBlbHNlIGlmICh0eXBlID09PSBUeXBlcy5EZWNpbWFsMTI4KSB7XG4gICAgbmFtZSA9ICdEZWNpbWFsMTI4JztcbiAgfSBlbHNlIHtcbiAgICBuYW1lID0gdHlwZSA9PSBudWxsID8gJycgKyB0eXBlIDogdHlwZS50b1N0cmluZygpO1xuICB9XG5cbiAgaWYgKG5hbWUpIHtcbiAgICBuYW1lID0gbmFtZS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIG5hbWUuc3Vic3RyaW5nKDEpO1xuICB9XG4gIC8vIFNwZWNpYWwgY2FzZSByZTogZ2gtNzA0OSBiZWNhdXNlIHRoZSBic29uIGBPYmplY3RJRGAgY2xhc3MnIGNhcGl0YWxpemF0aW9uXG4gIC8vIGRvZXNuJ3QgbGluZSB1cCB3aXRoIE1vbmdvb3NlJ3MuXG4gIGlmIChuYW1lID09PSAnT2JqZWN0SUQnKSB7XG4gICAgbmFtZSA9ICdPYmplY3RJZCc7XG4gIH1cbiAgLy8gRm9yIEplc3QgMjYrLCBzZWUgIzEwMjk2XG4gIGlmIChuYW1lID09PSAnQ2xvY2tEYXRlJykge1xuICAgIG5hbWUgPSAnRGF0ZSc7XG4gIH1cblxuICBpZiAobmFtZSA9PT0gdm9pZCAwKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgSW52YWxpZCBzY2hlbWEgY29uZmlndXJhdGlvbjogXFxgJHtwYXRofVxcYCBzY2hlbWF0eXBlIGRlZmluaXRpb24gaXMgYCArXG4gICAgICAnaW52YWxpZC4gU2VlICcgK1xuICAgICAgJ2h0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9ndWlkZS5odG1sI2RlZmluaXRpb24gZm9yIG1vcmUgaW5mbyBvbiBzdXBwb3J0ZWQgc2NoZW1hIHN5bnRheGVzLicpO1xuICB9XG4gIGlmIChNb25nb29zZVR5cGVzW25hbWVdID09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBJbnZhbGlkIHNjaGVtYSBjb25maWd1cmF0aW9uOiBcXGAke25hbWV9XFxgIGlzIG5vdCBgICtcbiAgICAgIGBhIHZhbGlkIHR5cGUgYXQgcGF0aCBcXGAke3BhdGh9XFxgLiBTZWUgYCArXG4gICAgICAnaHR0cHM6Ly9iaXQubHkvbW9uZ29vc2Utc2NoZW1hdHlwZXMgZm9yIGEgbGlzdCBvZiB2YWxpZCBzY2hlbWEgdHlwZXMuJyk7XG4gIH1cblxuICBjb25zdCBzY2hlbWFUeXBlID0gbmV3IE1vbmdvb3NlVHlwZXNbbmFtZV0ocGF0aCwgb2JqKTtcblxuICBpZiAoc2NoZW1hVHlwZS4kaXNTY2hlbWFNYXApIHtcbiAgICBjcmVhdGVNYXBOZXN0ZWRTY2hlbWFUeXBlKHRoaXMsIHNjaGVtYVR5cGUsIHBhdGgsIG9iaiwgb3B0aW9ucyk7XG4gIH1cblxuICByZXR1cm4gc2NoZW1hVHlwZTtcbn07XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxuZnVuY3Rpb24gY3JlYXRlTWFwTmVzdGVkU2NoZW1hVHlwZShzY2hlbWEsIHNjaGVtYVR5cGUsIHBhdGgsIG9iaiwgb3B0aW9ucykge1xuICBjb25zdCBtYXBQYXRoID0gcGF0aCArICcuJConO1xuICBsZXQgX21hcFR5cGUgPSB7IHR5cGU6IHt9IH07XG4gIGlmICh1dGlscy5oYXNVc2VyRGVmaW5lZFByb3BlcnR5KG9iaiwgJ29mJykpIHtcbiAgICBjb25zdCBpc0lubGluZVNjaGVtYSA9IHV0aWxzLmlzUE9KTyhvYmoub2YpICYmXG4gICAgICBPYmplY3Qua2V5cyhvYmoub2YpLmxlbmd0aCA+IDAgJiZcbiAgICAgICF1dGlscy5oYXNVc2VyRGVmaW5lZFByb3BlcnR5KG9iai5vZiwgc2NoZW1hLm9wdGlvbnMudHlwZUtleSk7XG4gICAgaWYgKGlzSW5saW5lU2NoZW1hKSB7XG4gICAgICBfbWFwVHlwZSA9IHsgW3NjaGVtYS5vcHRpb25zLnR5cGVLZXldOiBuZXcgU2NoZW1hKG9iai5vZikgfTtcbiAgICB9IGVsc2UgaWYgKHV0aWxzLmlzUE9KTyhvYmoub2YpKSB7XG4gICAgICBfbWFwVHlwZSA9IE9iamVjdC5hc3NpZ24oe30sIG9iai5vZik7XG4gICAgfSBlbHNlIHtcbiAgICAgIF9tYXBUeXBlID0geyBbc2NoZW1hLm9wdGlvbnMudHlwZUtleV06IG9iai5vZiB9O1xuICAgIH1cblxuICAgIGlmIChfbWFwVHlwZVtzY2hlbWEub3B0aW9ucy50eXBlS2V5XSAmJiBfbWFwVHlwZVtzY2hlbWEub3B0aW9ucy50eXBlS2V5XS5pbnN0YW5jZU9mU2NoZW1hKSB7XG4gICAgICBjb25zdCBzdWJkb2N1bWVudFNjaGVtYSA9IF9tYXBUeXBlW3NjaGVtYS5vcHRpb25zLnR5cGVLZXldO1xuICAgICAgc3ViZG9jdW1lbnRTY2hlbWEuZWFjaFBhdGgoKHN1YnBhdGgsIHR5cGUpID0+IHtcbiAgICAgICAgaWYgKHR5cGUub3B0aW9ucy5zZWxlY3QgPT09IHRydWUgfHwgdHlwZS5vcHRpb25zLnNlbGVjdCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgTW9uZ29vc2VFcnJvcignQ2Fubm90IHVzZSBzY2hlbWEtbGV2ZWwgcHJvamVjdGlvbnMgKGBzZWxlY3Q6IHRydWVgIG9yIGBzZWxlY3Q6IGZhbHNlYCkgd2l0aGluIG1hcHMgYXQgcGF0aCBcIicgKyBwYXRoICsgJy4nICsgc3VicGF0aCArICdcIicpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAodXRpbHMuaGFzVXNlckRlZmluZWRQcm9wZXJ0eShvYmosICdyZWYnKSkge1xuICAgICAgX21hcFR5cGUucmVmID0gb2JqLnJlZjtcbiAgICB9XG4gIH1cbiAgc2NoZW1hVHlwZS4kX19zY2hlbWFUeXBlID0gc2NoZW1hLmludGVycHJldEFzVHlwZShtYXBQYXRoLCBfbWFwVHlwZSwgb3B0aW9ucyk7XG59XG5cbi8qKlxuICogSXRlcmF0ZXMgdGhlIHNjaGVtYXMgcGF0aHMgc2ltaWxhciB0byBBcnJheSNmb3JFYWNoLlxuICpcbiAqIFRoZSBjYWxsYmFjayBpcyBwYXNzZWQgdGhlIHBhdGhuYW1lIGFuZCB0aGUgc2NoZW1hVHlwZSBpbnN0YW5jZS5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IHVzZXJTY2hlbWEgPSBuZXcgU2NoZW1hKHsgbmFtZTogU3RyaW5nLCByZWdpc3RlcmVkQXQ6IERhdGUgfSk7XG4gKiAgICAgdXNlclNjaGVtYS5lYWNoUGF0aCgocGF0aG5hbWUsIHNjaGVtYXR5cGUpID0+IHtcbiAqICAgICAgIC8vIFByaW50cyB0d2ljZTpcbiAqICAgICAgIC8vIG5hbWUgU2NoZW1hU3RyaW5nIHsgLi4uIH1cbiAqICAgICAgIC8vIHJlZ2lzdGVyZWRBdCBTY2hlbWFEYXRlIHsgLi4uIH1cbiAqICAgICAgIGNvbnNvbGUubG9nKHBhdGhuYW1lLCBzY2hlbWF0eXBlKTtcbiAqICAgICB9KTtcbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBjYWxsYmFjayBmdW5jdGlvblxuICogQHJldHVybiB7U2NoZW1hfSB0aGlzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblNjaGVtYS5wcm90b3R5cGUuZWFjaFBhdGggPSBmdW5jdGlvbihmbikge1xuICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXModGhpcy5wYXRocyk7XG4gIGNvbnN0IGxlbiA9IGtleXMubGVuZ3RoO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICBmbihrZXlzW2ldLCB0aGlzLnBhdGhzW2tleXNbaV1dKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIGFuIEFycmF5IG9mIHBhdGggc3RyaW5ncyB0aGF0IGFyZSByZXF1aXJlZCBieSB0aGlzIHNjaGVtYS5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IHMgPSBuZXcgU2NoZW1hKHtcbiAqICAgICAgIG5hbWU6IHsgdHlwZTogU3RyaW5nLCByZXF1aXJlZDogdHJ1ZSB9LFxuICogICAgICAgYWdlOiB7IHR5cGU6IFN0cmluZywgcmVxdWlyZWQ6IHRydWUgfSxcbiAqICAgICAgIG5vdGVzOiBTdHJpbmdcbiAqICAgICB9KTtcbiAqICAgICBzLnJlcXVpcmVkUGF0aHMoKTsgLy8gWyAnYWdlJywgJ25hbWUnIF1cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICogQHBhcmFtIHtCb29sZWFufSBpbnZhbGlkYXRlIFJlZnJlc2ggdGhlIGNhY2hlXG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqL1xuXG5TY2hlbWEucHJvdG90eXBlLnJlcXVpcmVkUGF0aHMgPSBmdW5jdGlvbiByZXF1aXJlZFBhdGhzKGludmFsaWRhdGUpIHtcbiAgaWYgKHRoaXMuX3JlcXVpcmVkcGF0aHMgJiYgIWludmFsaWRhdGUpIHtcbiAgICByZXR1cm4gdGhpcy5fcmVxdWlyZWRwYXRocztcbiAgfVxuXG4gIGNvbnN0IHBhdGhzID0gT2JqZWN0LmtleXModGhpcy5wYXRocyk7XG4gIGxldCBpID0gcGF0aHMubGVuZ3RoO1xuICBjb25zdCByZXQgPSBbXTtcblxuICB3aGlsZSAoaS0tKSB7XG4gICAgY29uc3QgcGF0aCA9IHBhdGhzW2ldO1xuICAgIGlmICh0aGlzLnBhdGhzW3BhdGhdLmlzUmVxdWlyZWQpIHtcbiAgICAgIHJldC5wdXNoKHBhdGgpO1xuICAgIH1cbiAgfVxuICB0aGlzLl9yZXF1aXJlZHBhdGhzID0gcmV0O1xuICByZXR1cm4gdGhpcy5fcmVxdWlyZWRwYXRocztcbn07XG5cbi8qKlxuICogUmV0dXJucyBpbmRleGVzIGZyb20gZmllbGRzIGFuZCBzY2hlbWEtbGV2ZWwgaW5kZXhlcyAoY2FjaGVkKS5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqIEByZXR1cm4ge0FycmF5fVxuICovXG5cblNjaGVtYS5wcm90b3R5cGUuaW5kZXhlZFBhdGhzID0gZnVuY3Rpb24gaW5kZXhlZFBhdGhzKCkge1xuICBpZiAodGhpcy5faW5kZXhlZHBhdGhzKSB7XG4gICAgcmV0dXJuIHRoaXMuX2luZGV4ZWRwYXRocztcbiAgfVxuICB0aGlzLl9pbmRleGVkcGF0aHMgPSB0aGlzLmluZGV4ZXMoKTtcbiAgcmV0dXJuIHRoaXMuX2luZGV4ZWRwYXRocztcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgcGF0aFR5cGUgb2YgYHBhdGhgIGZvciB0aGlzIHNjaGVtYS5cbiAqXG4gKiBHaXZlbiBhIHBhdGgsIHJldHVybnMgd2hldGhlciBpdCBpcyBhIHJlYWwsIHZpcnR1YWwsIG5lc3RlZCwgb3IgYWQtaG9jL3VuZGVmaW5lZCBwYXRoLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgY29uc3QgcyA9IG5ldyBTY2hlbWEoeyBuYW1lOiBTdHJpbmcsIG5lc3RlZDogeyBmb286IFN0cmluZyB9IH0pO1xuICogICAgIHMudmlydHVhbCgnZm9vJykuZ2V0KCgpID0+IDQyKTtcbiAqICAgICBzLnBhdGhUeXBlKCduYW1lJyk7IC8vIFwicmVhbFwiXG4gKiAgICAgcy5wYXRoVHlwZSgnbmVzdGVkJyk7IC8vIFwibmVzdGVkXCJcbiAqICAgICBzLnBhdGhUeXBlKCdmb28nKTsgLy8gXCJ2aXJ0dWFsXCJcbiAqICAgICBzLnBhdGhUeXBlKCdmYWlsJyk7IC8vIFwiYWRob2NPclVuZGVmaW5lZFwiXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHBhdGhcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuU2NoZW1hLnByb3RvdHlwZS5wYXRoVHlwZSA9IGZ1bmN0aW9uKHBhdGgpIHtcbiAgaWYgKHRoaXMucGF0aHMuaGFzT3duUHJvcGVydHkocGF0aCkpIHtcbiAgICByZXR1cm4gJ3JlYWwnO1xuICB9XG4gIGlmICh0aGlzLnZpcnR1YWxzLmhhc093blByb3BlcnR5KHBhdGgpKSB7XG4gICAgcmV0dXJuICd2aXJ0dWFsJztcbiAgfVxuICBpZiAodGhpcy5uZXN0ZWQuaGFzT3duUHJvcGVydHkocGF0aCkpIHtcbiAgICByZXR1cm4gJ25lc3RlZCc7XG4gIH1cblxuICAvLyBDb252ZXJ0IHRvICcuJCcgdG8gY2hlY2sgc3VicGF0aHMgcmU6IGdoLTY0MDVcbiAgY29uc3QgY2xlYW5QYXRoID0gX3BhdGhUb1Bvc2l0aW9uYWxTeW50YXgocGF0aCk7XG5cbiAgaWYgKHRoaXMuc3VicGF0aHMuaGFzT3duUHJvcGVydHkoY2xlYW5QYXRoKSB8fCB0aGlzLnN1YnBhdGhzLmhhc093blByb3BlcnR5KHBhdGgpKSB7XG4gICAgcmV0dXJuICdyZWFsJztcbiAgfVxuXG4gIGNvbnN0IHNpbmdsZU5lc3RlZFBhdGggPSB0aGlzLnNpbmdsZU5lc3RlZFBhdGhzLmhhc093blByb3BlcnR5KGNsZWFuUGF0aCkgfHwgdGhpcy5zaW5nbGVOZXN0ZWRQYXRocy5oYXNPd25Qcm9wZXJ0eShwYXRoKTtcbiAgaWYgKHNpbmdsZU5lc3RlZFBhdGgpIHtcbiAgICByZXR1cm4gc2luZ2xlTmVzdGVkUGF0aCA9PT0gJ25lc3RlZCcgPyAnbmVzdGVkJyA6ICdyZWFsJztcbiAgfVxuXG4gIC8vIExvb2sgZm9yIG1hcHNcbiAgY29uc3QgbWFwUGF0aCA9IGdldE1hcFBhdGgodGhpcywgcGF0aCk7XG4gIGlmIChtYXBQYXRoICE9IG51bGwpIHtcbiAgICByZXR1cm4gJ3JlYWwnO1xuICB9XG5cbiAgaWYgKC9cXC5cXGQrXFwufFxcLlxcZCskLy50ZXN0KHBhdGgpKSB7XG4gICAgcmV0dXJuIGdldFBvc2l0aW9uYWxQYXRoVHlwZSh0aGlzLCBwYXRoLCBjbGVhblBhdGgpO1xuICB9XG4gIHJldHVybiAnYWRob2NPclVuZGVmaW5lZCc7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZmYgdGhpcyBwYXRoIGlzIGEgY2hpbGQgb2YgYSBtaXhlZCBzY2hlbWEuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHBhdGhcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5TY2hlbWEucHJvdG90eXBlLmhhc01peGVkUGFyZW50ID0gZnVuY3Rpb24ocGF0aCkge1xuICBjb25zdCBzdWJwYXRocyA9IHBhdGguc3BsaXQoL1xcLi9nKTtcbiAgcGF0aCA9ICcnO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHN1YnBhdGhzLmxlbmd0aDsgKytpKSB7XG4gICAgcGF0aCA9IGkgPiAwID8gcGF0aCArICcuJyArIHN1YnBhdGhzW2ldIDogc3VicGF0aHNbaV07XG4gICAgaWYgKHRoaXMucGF0aHMuaGFzT3duUHJvcGVydHkocGF0aCkgJiZcbiAgICAgICAgdGhpcy5wYXRoc1twYXRoXSBpbnN0YW5jZW9mIE1vbmdvb3NlVHlwZXMuTWl4ZWQpIHtcbiAgICAgIHJldHVybiB0aGlzLnBhdGhzW3BhdGhdO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBudWxsO1xufTtcblxuLyoqXG4gKiBTZXR1cCB1cGRhdGVkQXQgYW5kIGNyZWF0ZWRBdCB0aW1lc3RhbXBzIHRvIGRvY3VtZW50cyBpZiBlbmFibGVkXG4gKlxuICogQHBhcmFtIHtCb29sZWFufE9iamVjdH0gdGltZXN0YW1wcyB0aW1lc3RhbXBzIG9wdGlvbnNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5TY2hlbWEucHJvdG90eXBlLnNldHVwVGltZXN0YW1wID0gZnVuY3Rpb24odGltZXN0YW1wcykge1xuICByZXR1cm4gc2V0dXBUaW1lc3RhbXBzKHRoaXMsIHRpbWVzdGFtcHMpO1xufTtcblxuLyoqXG4gKiBpZ25vcmUuIERlcHJlY2F0ZWQgcmU6ICM2NDA1XG4gKiBAcGFyYW0ge0FueX0gc2VsZlxuICogQHBhcmFtIHtTdHJpbmd9IHBhdGhcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGdldFBvc2l0aW9uYWxQYXRoVHlwZShzZWxmLCBwYXRoLCBjbGVhblBhdGgpIHtcbiAgY29uc3Qgc3VicGF0aHMgPSBwYXRoLnNwbGl0KC9cXC4oXFxkKylcXC58XFwuKFxcZCspJC8pLmZpbHRlcihCb29sZWFuKTtcbiAgaWYgKHN1YnBhdGhzLmxlbmd0aCA8IDIpIHtcbiAgICByZXR1cm4gc2VsZi5wYXRocy5oYXNPd25Qcm9wZXJ0eShzdWJwYXRoc1swXSkgP1xuICAgICAgc2VsZi5wYXRoc1tzdWJwYXRoc1swXV0gOlxuICAgICAgJ2FkaG9jT3JVbmRlZmluZWQnO1xuICB9XG5cbiAgbGV0IHZhbCA9IHNlbGYucGF0aChzdWJwYXRoc1swXSk7XG4gIGxldCBpc05lc3RlZCA9IGZhbHNlO1xuICBpZiAoIXZhbCkge1xuICAgIHJldHVybiAnYWRob2NPclVuZGVmaW5lZCc7XG4gIH1cblxuICBjb25zdCBsYXN0ID0gc3VicGF0aHMubGVuZ3RoIC0gMTtcblxuICBmb3IgKGxldCBpID0gMTsgaSA8IHN1YnBhdGhzLmxlbmd0aDsgKytpKSB7XG4gICAgaXNOZXN0ZWQgPSBmYWxzZTtcbiAgICBjb25zdCBzdWJwYXRoID0gc3VicGF0aHNbaV07XG5cbiAgICBpZiAoaSA9PT0gbGFzdCAmJiB2YWwgJiYgIS9cXEQvLnRlc3Qoc3VicGF0aCkpIHtcbiAgICAgIGlmICh2YWwuJGlzTW9uZ29vc2VEb2N1bWVudEFycmF5KSB7XG4gICAgICAgIHZhbCA9IHZhbC4kZW1iZWRkZWRTY2hlbWFUeXBlO1xuICAgICAgfSBlbHNlIGlmICh2YWwgaW5zdGFuY2VvZiBNb25nb29zZVR5cGVzLkFycmF5KSB7XG4gICAgICAgIC8vIFN0cmluZ1NjaGVtYSwgTnVtYmVyU2NoZW1hLCBldGNcbiAgICAgICAgdmFsID0gdmFsLmNhc3RlcjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhbCA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIC8vIGlnbm9yZSBpZiBpdHMganVzdCBhIHBvc2l0aW9uIHNlZ21lbnQ6IHBhdGguMC5zdWJwYXRoXG4gICAgaWYgKCEvXFxELy50ZXN0KHN1YnBhdGgpKSB7XG4gICAgICAvLyBOZXN0ZWQgYXJyYXlcbiAgICAgIGlmICh2YWwgaW5zdGFuY2VvZiBNb25nb29zZVR5cGVzLkFycmF5ICYmIGkgIT09IGxhc3QpIHtcbiAgICAgICAgdmFsID0gdmFsLmNhc3RlcjtcbiAgICAgIH1cbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGlmICghKHZhbCAmJiB2YWwuc2NoZW1hKSkge1xuICAgICAgdmFsID0gdW5kZWZpbmVkO1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgY29uc3QgdHlwZSA9IHZhbC5zY2hlbWEucGF0aFR5cGUoc3VicGF0aCk7XG4gICAgaXNOZXN0ZWQgPSAodHlwZSA9PT0gJ25lc3RlZCcpO1xuICAgIHZhbCA9IHZhbC5zY2hlbWEucGF0aChzdWJwYXRoKTtcbiAgfVxuXG4gIHNlbGYuc3VicGF0aHNbY2xlYW5QYXRoXSA9IHZhbDtcbiAgaWYgKHZhbCkge1xuICAgIHJldHVybiAncmVhbCc7XG4gIH1cbiAgaWYgKGlzTmVzdGVkKSB7XG4gICAgcmV0dXJuICduZXN0ZWQnO1xuICB9XG4gIHJldHVybiAnYWRob2NPclVuZGVmaW5lZCc7XG59XG5cblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5mdW5jdGlvbiBnZXRQb3NpdGlvbmFsUGF0aChzZWxmLCBwYXRoLCBjbGVhblBhdGgpIHtcbiAgZ2V0UG9zaXRpb25hbFBhdGhUeXBlKHNlbGYsIHBhdGgsIGNsZWFuUGF0aCk7XG4gIHJldHVybiBzZWxmLnN1YnBhdGhzW2NsZWFuUGF0aF07XG59XG5cbi8qKlxuICogQWRkcyBhIG1ldGhvZCBjYWxsIHRvIHRoZSBxdWV1ZS5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIHNjaGVtYS5tZXRob2RzLnByaW50ID0gZnVuY3Rpb24oKSB7IGNvbnNvbGUubG9nKHRoaXMpOyB9O1xuICogICAgIHNjaGVtYS5xdWV1ZSgncHJpbnQnLCBbXSk7IC8vIFByaW50IHRoZSBkb2MgZXZlcnkgb25lIGlzIGluc3RhbnRpYXRlZFxuICpcbiAqICAgICBjb25zdCBNb2RlbCA9IG1vbmdvb3NlLm1vZGVsKCdUZXN0Jywgc2NoZW1hKTtcbiAqICAgICBuZXcgTW9kZWwoeyBuYW1lOiAndGVzdCcgfSk7IC8vIFByaW50cyAne1wiX2lkXCI6IC4uLiwgXCJuYW1lXCI6IFwidGVzdFwiIH0nXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgbmFtZSBvZiB0aGUgZG9jdW1lbnQgbWV0aG9kIHRvIGNhbGwgbGF0ZXJcbiAqIEBwYXJhbSB7QXJyYXl9IGFyZ3MgYXJndW1lbnRzIHRvIHBhc3MgdG8gdGhlIG1ldGhvZFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5TY2hlbWEucHJvdG90eXBlLnF1ZXVlID0gZnVuY3Rpb24obmFtZSwgYXJncykge1xuICB0aGlzLmNhbGxRdWV1ZS5wdXNoKFtuYW1lLCBhcmdzXSk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBEZWZpbmVzIGEgcHJlIGhvb2sgZm9yIHRoZSBtb2RlbC5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IHRveVNjaGVtYSA9IG5ldyBTY2hlbWEoeyBuYW1lOiBTdHJpbmcsIGNyZWF0ZWQ6IERhdGUgfSk7XG4gKlxuICogICAgIHRveVNjaGVtYS5wcmUoJ3NhdmUnLCBmdW5jdGlvbihuZXh0KSB7XG4gKiAgICAgICBpZiAoIXRoaXMuY3JlYXRlZCkgdGhpcy5jcmVhdGVkID0gbmV3IERhdGU7XG4gKiAgICAgICBuZXh0KCk7XG4gKiAgICAgfSk7XG4gKlxuICogICAgIHRveVNjaGVtYS5wcmUoJ3ZhbGlkYXRlJywgZnVuY3Rpb24obmV4dCkge1xuICogICAgICAgaWYgKHRoaXMubmFtZSAhPT0gJ1dvb2R5JykgdGhpcy5uYW1lID0gJ1dvb2R5JztcbiAqICAgICAgIG5leHQoKTtcbiAqICAgICB9KTtcbiAqXG4gKiAgICAgLy8gRXF1aXZhbGVudCB0byBjYWxsaW5nIGBwcmUoKWAgb24gYGZpbmRgLCBgZmluZE9uZWAsIGBmaW5kT25lQW5kVXBkYXRlYC5cbiAqICAgICB0b3lTY2hlbWEucHJlKC9eZmluZC8sIGZ1bmN0aW9uKG5leHQpIHtcbiAqICAgICAgIGNvbnNvbGUubG9nKHRoaXMuZ2V0RmlsdGVyKCkpO1xuICogICAgIH0pO1xuICpcbiAqICAgICAvLyBFcXVpdmFsZW50IHRvIGNhbGxpbmcgYHByZSgpYCBvbiBgdXBkYXRlT25lYCwgYGZpbmRPbmVBbmRVcGRhdGVgLlxuICogICAgIHRveVNjaGVtYS5wcmUoWyd1cGRhdGVPbmUnLCAnZmluZE9uZUFuZFVwZGF0ZSddLCBmdW5jdGlvbihuZXh0KSB7XG4gKiAgICAgICBjb25zb2xlLmxvZyh0aGlzLmdldEZpbHRlcigpKTtcbiAqICAgICB9KTtcbiAqXG4gKiAgICAgdG95U2NoZW1hLnByZSgnZGVsZXRlT25lJywgZnVuY3Rpb24oKSB7XG4gKiAgICAgICAvLyBSdW5zIHdoZW4geW91IGNhbGwgYFRveS5kZWxldGVPbmUoKWBcbiAqICAgICB9KTtcbiAqXG4gKiAgICAgdG95U2NoZW1hLnByZSgnZGVsZXRlT25lJywgeyBkb2N1bWVudDogdHJ1ZSB9LCBmdW5jdGlvbigpIHtcbiAqICAgICAgIC8vIFJ1bnMgd2hlbiB5b3UgY2FsbCBgZG9jLmRlbGV0ZU9uZSgpYFxuICogICAgIH0pO1xuICpcbiAqIEBwYXJhbSB7U3RyaW5nfFJlZ0V4cHxTdHJpbmdbXX0gbWV0aG9kTmFtZSBUaGUgbWV0aG9kIG5hbWUgb3IgcmVndWxhciBleHByZXNzaW9uIHRvIG1hdGNoIG1ldGhvZCBuYW1lXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmRvY3VtZW50XSBJZiBgbmFtZWAgaXMgYSBob29rIGZvciBib3RoIGRvY3VtZW50IGFuZCBxdWVyeSBtaWRkbGV3YXJlLCBzZXQgdG8gYHRydWVgIHRvIHJ1biBvbiBkb2N1bWVudCBtaWRkbGV3YXJlLiBGb3IgZXhhbXBsZSwgc2V0IGBvcHRpb25zLmRvY3VtZW50YCB0byBgdHJ1ZWAgdG8gYXBwbHkgdGhpcyBob29rIHRvIGBEb2N1bWVudCNkZWxldGVPbmUoKWAgcmF0aGVyIHRoYW4gYFF1ZXJ5I2RlbGV0ZU9uZSgpYC5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMucXVlcnldIElmIGBuYW1lYCBpcyBhIGhvb2sgZm9yIGJvdGggZG9jdW1lbnQgYW5kIHF1ZXJ5IG1pZGRsZXdhcmUsIHNldCB0byBgdHJ1ZWAgdG8gcnVuIG9uIHF1ZXJ5IG1pZGRsZXdhcmUuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5TY2hlbWEucHJvdG90eXBlLnByZSA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgaWYgKG5hbWUgaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICBjb25zdCByZW1haW5pbmdBcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICBmb3IgKGNvbnN0IGZuIG9mIGhvb2tOYW1lcykge1xuICAgICAgaWYgKG5hbWUudGVzdChmbikpIHtcbiAgICAgICAgdGhpcy5wcmUuYXBwbHkodGhpcywgW2ZuXS5jb25jYXQocmVtYWluaW5nQXJncykpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBpZiAoQXJyYXkuaXNBcnJheShuYW1lKSkge1xuICAgIGNvbnN0IHJlbWFpbmluZ0FyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgIGZvciAoY29uc3QgZWwgb2YgbmFtZSkge1xuICAgICAgdGhpcy5wcmUuYXBwbHkodGhpcywgW2VsXS5jb25jYXQocmVtYWluaW5nQXJncykpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICB0aGlzLnMuaG9va3MucHJlLmFwcGx5KHRoaXMucy5ob29rcywgYXJndW1lbnRzKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIERlZmluZXMgYSBwb3N0IGhvb2sgZm9yIHRoZSBkb2N1bWVudFxuICpcbiAqICAgICBjb25zdCBzY2hlbWEgPSBuZXcgU2NoZW1hKC4uKTtcbiAqICAgICBzY2hlbWEucG9zdCgnc2F2ZScsIGZ1bmN0aW9uIChkb2MpIHtcbiAqICAgICAgIGNvbnNvbGUubG9nKCd0aGlzIGZpcmVkIGFmdGVyIGEgZG9jdW1lbnQgd2FzIHNhdmVkJyk7XG4gKiAgICAgfSk7XG4gKlxuICogICAgIHNjaGVtYS5wb3N0KCdmaW5kJywgZnVuY3Rpb24oZG9jcykge1xuICogICAgICAgY29uc29sZS5sb2coJ3RoaXMgZmlyZWQgYWZ0ZXIgeW91IHJhbiBhIGZpbmQgcXVlcnknKTtcbiAqICAgICB9KTtcbiAqXG4gKiAgICAgc2NoZW1hLnBvc3QoL01hbnkkLywgZnVuY3Rpb24ocmVzKSB7XG4gKiAgICAgICBjb25zb2xlLmxvZygndGhpcyBmaXJlZCBhZnRlciB5b3UgcmFuIGB1cGRhdGVNYW55KClgIG9yIGBkZWxldGVNYW55KClgJyk7XG4gKiAgICAgfSk7XG4gKlxuICogICAgIGNvbnN0IE1vZGVsID0gbW9uZ29vc2UubW9kZWwoJ01vZGVsJywgc2NoZW1hKTtcbiAqXG4gKiAgICAgY29uc3QgbSA9IG5ldyBNb2RlbCguLik7XG4gKiAgICAgbS5zYXZlKGZ1bmN0aW9uKGVycikge1xuICogICAgICAgY29uc29sZS5sb2coJ3RoaXMgZmlyZXMgYWZ0ZXIgdGhlIGBwb3N0YCBob29rJyk7XG4gKiAgICAgfSk7XG4gKlxuICogICAgIG0uZmluZChmdW5jdGlvbihlcnIsIGRvY3MpIHtcbiAqICAgICAgIGNvbnNvbGUubG9nKCd0aGlzIGZpcmVzIGFmdGVyIHRoZSBwb3N0IGZpbmQgaG9vaycpO1xuICogICAgIH0pO1xuICpcbiAqIEBwYXJhbSB7U3RyaW5nfFJlZ0V4cHxTdHJpbmdbXX0gbWV0aG9kTmFtZSBUaGUgbWV0aG9kIG5hbWUgb3IgcmVndWxhciBleHByZXNzaW9uIHRvIG1hdGNoIG1ldGhvZCBuYW1lXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmRvY3VtZW50XSBJZiBgbmFtZWAgaXMgYSBob29rIGZvciBib3RoIGRvY3VtZW50IGFuZCBxdWVyeSBtaWRkbGV3YXJlLCBzZXQgdG8gYHRydWVgIHRvIHJ1biBvbiBkb2N1bWVudCBtaWRkbGV3YXJlLlxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5xdWVyeV0gSWYgYG5hbWVgIGlzIGEgaG9vayBmb3IgYm90aCBkb2N1bWVudCBhbmQgcXVlcnkgbWlkZGxld2FyZSwgc2V0IHRvIGB0cnVlYCB0byBydW4gb24gcXVlcnkgbWlkZGxld2FyZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIGNhbGxiYWNrXG4gKiBAc2VlIG1pZGRsZXdhcmUgaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL21pZGRsZXdhcmUuaHRtbFxuICogQHNlZSBrYXJlZW0gaHR0cHM6Ly9ucG1qcy5vcmcvcGFja2FnZS9rYXJlZW1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuU2NoZW1hLnByb3RvdHlwZS5wb3N0ID0gZnVuY3Rpb24obmFtZSkge1xuICBpZiAobmFtZSBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgIGNvbnN0IHJlbWFpbmluZ0FyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgIGZvciAoY29uc3QgZm4gb2YgaG9va05hbWVzKSB7XG4gICAgICBpZiAobmFtZS50ZXN0KGZuKSkge1xuICAgICAgICB0aGlzLnBvc3QuYXBwbHkodGhpcywgW2ZuXS5jb25jYXQocmVtYWluaW5nQXJncykpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBpZiAoQXJyYXkuaXNBcnJheShuYW1lKSkge1xuICAgIGNvbnN0IHJlbWFpbmluZ0FyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgIGZvciAoY29uc3QgZWwgb2YgbmFtZSkge1xuICAgICAgdGhpcy5wb3N0LmFwcGx5KHRoaXMsIFtlbF0uY29uY2F0KHJlbWFpbmluZ0FyZ3MpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgdGhpcy5zLmhvb2tzLnBvc3QuYXBwbHkodGhpcy5zLmhvb2tzLCBhcmd1bWVudHMpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUmVnaXN0ZXJzIGEgcGx1Z2luIGZvciB0aGlzIHNjaGVtYS5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IHMgPSBuZXcgU2NoZW1hKHsgbmFtZTogU3RyaW5nIH0pO1xuICogICAgIHMucGx1Z2luKHNjaGVtYSA9PiBjb25zb2xlLmxvZyhzY2hlbWEucGF0aCgnbmFtZScpLnBhdGgpKTtcbiAqICAgICBtb25nb29zZS5tb2RlbCgnVGVzdCcsIHMpOyAvLyBQcmludHMgJ25hbWUnXG4gKlxuICogT3Igd2l0aCBPcHRpb25zOlxuICpcbiAqICAgICBjb25zdCBzID0gbmV3IFNjaGVtYSh7IG5hbWU6IFN0cmluZyB9KTtcbiAqICAgICBzLnBsdWdpbigoc2NoZW1hLCBvcHRzKSA9PiBjb25zb2xlLmxvZyhvcHRzLnRleHQsIHNjaGVtYS5wYXRoKCduYW1lJykucGF0aCksIHsgdGV4dDogXCJTY2hlbWEgUGF0aCBOYW1lOlwiIH0pO1xuICogICAgIG1vbmdvb3NlLm1vZGVsKCdUZXN0Jywgcyk7IC8vIFByaW50cyAnU2NoZW1hIFBhdGggTmFtZTogbmFtZSdcbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBwbHVnaW4gVGhlIFBsdWdpbidzIGNhbGxiYWNrXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdHNdIE9wdGlvbnMgdG8gcGFzcyB0byB0aGUgcGx1Z2luXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRzLmRlZHVwbGljYXRlPWZhbHNlXSBJZiB0cnVlLCBpZ25vcmUgZHVwbGljYXRlIHBsdWdpbnMgKHNhbWUgYGZuYCBhcmd1bWVudCB1c2luZyBgPT09YClcbiAqIEBzZWUgcGx1Z2lucyBodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvcGx1Z2lucy5odG1sXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblNjaGVtYS5wcm90b3R5cGUucGx1Z2luID0gZnVuY3Rpb24oZm4sIG9wdHMpIHtcbiAgaWYgKHR5cGVvZiBmbiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBFcnJvcignRmlyc3QgcGFyYW0gdG8gYHNjaGVtYS5wbHVnaW4oKWAgbXVzdCBiZSBhIGZ1bmN0aW9uLCAnICtcbiAgICAgICdnb3QgXCInICsgKHR5cGVvZiBmbikgKyAnXCInKTtcbiAgfVxuXG4gIGlmIChvcHRzICYmIG9wdHMuZGVkdXBsaWNhdGUpIHtcbiAgICBmb3IgKGNvbnN0IHBsdWdpbiBvZiB0aGlzLnBsdWdpbnMpIHtcbiAgICAgIGlmIChwbHVnaW4uZm4gPT09IGZuKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICB0aGlzLnBsdWdpbnMucHVzaCh7IGZuOiBmbiwgb3B0czogb3B0cyB9KTtcblxuICBmbih0aGlzLCBvcHRzKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEFkZHMgYW4gaW5zdGFuY2UgbWV0aG9kIHRvIGRvY3VtZW50cyBjb25zdHJ1Y3RlZCBmcm9tIE1vZGVscyBjb21waWxlZCBmcm9tIHRoaXMgc2NoZW1hLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgY29uc3Qgc2NoZW1hID0ga2l0dHlTY2hlbWEgPSBuZXcgU2NoZW1hKC4uKTtcbiAqXG4gKiAgICAgc2NoZW1hLm1ldGhvZCgnbWVvdycsIGZ1bmN0aW9uICgpIHtcbiAqICAgICAgIGNvbnNvbGUubG9nKCdtZWVlZWVvb29vb29vb29vb293Jyk7XG4gKiAgICAgfSlcbiAqXG4gKiAgICAgY29uc3QgS2l0dHkgPSBtb25nb29zZS5tb2RlbCgnS2l0dHknLCBzY2hlbWEpO1xuICpcbiAqICAgICBjb25zdCBmaXp6ID0gbmV3IEtpdHR5O1xuICogICAgIGZpenoubWVvdygpOyAvLyBtZWVlZWVvb29vb29vb29vb29vd1xuICpcbiAqIElmIGEgaGFzaCBvZiBuYW1lL2ZuIHBhaXJzIGlzIHBhc3NlZCBhcyB0aGUgb25seSBhcmd1bWVudCwgZWFjaCBuYW1lL2ZuIHBhaXIgd2lsbCBiZSBhZGRlZCBhcyBtZXRob2RzLlxuICpcbiAqICAgICBzY2hlbWEubWV0aG9kKHtcbiAqICAgICAgICAgcHVycjogZnVuY3Rpb24gKCkge31cbiAqICAgICAgICwgc2NyYXRjaDogZnVuY3Rpb24gKCkge31cbiAqICAgICB9KTtcbiAqXG4gKiAgICAgLy8gbGF0ZXJcbiAqICAgICBjb25zdCBmaXp6ID0gbmV3IEtpdHR5O1xuICogICAgIGZpenoucHVycigpO1xuICogICAgIGZpenouc2NyYXRjaCgpO1xuICpcbiAqIE5PVEU6IGBTY2hlbWEubWV0aG9kKClgIGFkZHMgaW5zdGFuY2UgbWV0aG9kcyB0byB0aGUgYFNjaGVtYS5tZXRob2RzYCBvYmplY3QuIFlvdSBjYW4gYWxzbyBhZGQgaW5zdGFuY2UgbWV0aG9kcyBkaXJlY3RseSB0byB0aGUgYFNjaGVtYS5tZXRob2RzYCBvYmplY3QgYXMgc2VlbiBpbiB0aGUgW2d1aWRlXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvZ3VpZGUuaHRtbCNtZXRob2RzKVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfE9iamVjdH0gbmFtZSBUaGUgTWV0aG9kIE5hbWUgZm9yIGEgc2luZ2xlIGZ1bmN0aW9uLCBvciBhIE9iamVjdCBvZiBcInN0cmluZy1mdW5jdGlvblwiIHBhaXJzLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2ZuXSBUaGUgRnVuY3Rpb24gaW4gYSBzaW5nbGUtZnVuY3Rpb24gZGVmaW5pdGlvbi5cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuU2NoZW1hLnByb3RvdHlwZS5tZXRob2QgPSBmdW5jdGlvbihuYW1lLCBmbiwgb3B0aW9ucykge1xuICBpZiAodHlwZW9mIG5hbWUgIT09ICdzdHJpbmcnKSB7XG4gICAgZm9yIChjb25zdCBpIGluIG5hbWUpIHtcbiAgICAgIHRoaXMubWV0aG9kc1tpXSA9IG5hbWVbaV07XG4gICAgICB0aGlzLm1ldGhvZE9wdGlvbnNbaV0gPSBjbG9uZShvcHRpb25zKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5tZXRob2RzW25hbWVdID0gZm47XG4gICAgdGhpcy5tZXRob2RPcHRpb25zW25hbWVdID0gY2xvbmUob3B0aW9ucyk7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEFkZHMgc3RhdGljIFwiY2xhc3NcIiBtZXRob2RzIHRvIE1vZGVscyBjb21waWxlZCBmcm9tIHRoaXMgc2NoZW1hLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgY29uc3Qgc2NoZW1hID0gbmV3IFNjaGVtYSguLik7XG4gKiAgICAgLy8gRXF1aXZhbGVudCB0byBgc2NoZW1hLnN0YXRpY3MuZmluZEJ5TmFtZSA9IGZ1bmN0aW9uKG5hbWUpIHt9YDtcbiAqICAgICBzY2hlbWEuc3RhdGljKCdmaW5kQnlOYW1lJywgZnVuY3Rpb24obmFtZSkge1xuICogICAgICAgcmV0dXJuIHRoaXMuZmluZCh7IG5hbWU6IG5hbWUgfSk7XG4gKiAgICAgfSk7XG4gKlxuICogICAgIGNvbnN0IERyaW5rID0gbW9uZ29vc2UubW9kZWwoJ0RyaW5rJywgc2NoZW1hKTtcbiAqICAgICBhd2FpdCBEcmluay5maW5kQnlOYW1lKCdMYUNyb2l4Jyk7XG4gKlxuICogSWYgYSBoYXNoIG9mIG5hbWUvZm4gcGFpcnMgaXMgcGFzc2VkIGFzIHRoZSBvbmx5IGFyZ3VtZW50LCBlYWNoIG5hbWUvZm4gcGFpciB3aWxsIGJlIGFkZGVkIGFzIG1ldGhvZHMuXG4gKlxuICogICAgIHNjaGVtYS5zdGF0aWMoe1xuICogICAgICAgICBmaW5kQnlOYW1lOiBmdW5jdGlvbiAoKSB7Li59XG4gKiAgICAgICAsIGZpbmRCeUNvc3Q6IGZ1bmN0aW9uICgpIHsuLn1cbiAqICAgICB9KTtcbiAqXG4gKiAgICAgY29uc3QgRHJpbmsgPSBtb25nb29zZS5tb2RlbCgnRHJpbmsnLCBzY2hlbWEpO1xuICogICAgIGF3YWl0IERyaW5rLmZpbmRCeU5hbWUoJ0xhQ3JvaXgnKTtcbiAqICAgICBhd2FpdCBEcmluay5maW5kQnlDb3N0KDMpO1xuICpcbiAqIElmIGEgaGFzaCBvZiBuYW1lL2ZuIHBhaXJzIGlzIHBhc3NlZCBhcyB0aGUgb25seSBhcmd1bWVudCwgZWFjaCBuYW1lL2ZuIHBhaXIgd2lsbCBiZSBhZGRlZCBhcyBzdGF0aWNzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfE9iamVjdH0gbmFtZSBUaGUgTWV0aG9kIE5hbWUgZm9yIGEgc2luZ2xlIGZ1bmN0aW9uLCBvciBhIE9iamVjdCBvZiBcInN0cmluZy1mdW5jdGlvblwiIHBhaXJzLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2ZuXSBUaGUgRnVuY3Rpb24gaW4gYSBzaW5nbGUtZnVuY3Rpb24gZGVmaW5pdGlvbi5cbiAqIEBhcGkgcHVibGljXG4gKiBAc2VlIFN0YXRpY3MgaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2d1aWRlLmh0bWwjc3RhdGljc1xuICovXG5cblNjaGVtYS5wcm90b3R5cGUuc3RhdGljID0gZnVuY3Rpb24obmFtZSwgZm4pIHtcbiAgaWYgKHR5cGVvZiBuYW1lICE9PSAnc3RyaW5nJykge1xuICAgIGZvciAoY29uc3QgaSBpbiBuYW1lKSB7XG4gICAgICB0aGlzLnN0YXRpY3NbaV0gPSBuYW1lW2ldO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0aGlzLnN0YXRpY3NbbmFtZV0gPSBmbjtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogRGVmaW5lcyBhbiBpbmRleCAobW9zdCBsaWtlbHkgY29tcG91bmQpIGZvciB0aGlzIHNjaGVtYS5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIHNjaGVtYS5pbmRleCh7IGZpcnN0OiAxLCBsYXN0OiAtMSB9KVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBmaWVsZHMgVGhlIEZpZWxkcyB0byBpbmRleCwgd2l0aCB0aGUgb3JkZXIsIGF2YWlsYWJsZSB2YWx1ZXM6IGAxIHwgLTEgfCAnMmQnIHwgJzJkc3BoZXJlJyB8ICdnZW9IYXlzdGFjaycgfCAnaGFzaGVkJyB8ICd0ZXh0J2BcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyB0byBwYXNzIHRvIFtNb25nb0RCIGRyaXZlcidzIGBjcmVhdGVJbmRleCgpYCBmdW5jdGlvbl0oaHR0cHM6Ly9tb25nb2RiLmdpdGh1Yi5pby9ub2RlLW1vbmdvZGItbmF0aXZlLzQuOS9jbGFzc2VzL0NvbGxlY3Rpb24uaHRtbCNjcmVhdGVJbmRleClcbiAqIEBwYXJhbSB7U3RyaW5nIHwgbnVtYmVyfSBbb3B0aW9ucy5leHBpcmVzPW51bGxdIE1vbmdvb3NlLXNwZWNpZmljIHN5bnRhY3RpYyBzdWdhciwgdXNlcyBbbXNdKGh0dHBzOi8vd3d3Lm5wbWpzLmNvbS9wYWNrYWdlL21zKSB0byBjb252ZXJ0IGBleHBpcmVzYCBvcHRpb24gaW50byBzZWNvbmRzIGZvciB0aGUgYGV4cGlyZUFmdGVyU2Vjb25kc2AgaW4gdGhlIGFib3ZlIGxpbmsuXG4gKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMubGFuZ3VhZ2Vfb3ZlcnJpZGU9bnVsbF0gVGVsbHMgbW9uZ29kYiB0byB1c2UgdGhlIHNwZWNpZmllZCBmaWVsZCBpbnN0ZWFkIG9mIGBsYW5ndWFnZWAgZm9yIHBhcnNpbmcgdGV4dCBpbmRleGVzLlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5TY2hlbWEucHJvdG90eXBlLmluZGV4ID0gZnVuY3Rpb24oZmllbGRzLCBvcHRpb25zKSB7XG4gIGZpZWxkcyB8fCAoZmllbGRzID0ge30pO1xuICBvcHRpb25zIHx8IChvcHRpb25zID0ge30pO1xuXG4gIGlmIChvcHRpb25zLmV4cGlyZXMpIHtcbiAgICB1dGlscy5leHBpcmVzKG9wdGlvbnMpO1xuICB9XG4gIGZvciAoY29uc3Qga2V5IGluIGZpZWxkcykge1xuICAgIGlmICh0aGlzLmFsaWFzZXNba2V5XSkge1xuICAgICAgZmllbGRzID0gdXRpbHMucmVuYW1lT2JqS2V5KGZpZWxkcywga2V5LCB0aGlzLmFsaWFzZXNba2V5XSk7XG4gICAgfVxuICB9XG4gIGZvciAoY29uc3QgZmllbGQgb2YgT2JqZWN0LmtleXMoZmllbGRzKSkge1xuICAgIGlmIChmaWVsZHNbZmllbGRdID09PSAnYXNjZW5kaW5nJyB8fCBmaWVsZHNbZmllbGRdID09PSAnYXNjJykge1xuICAgICAgZmllbGRzW2ZpZWxkXSA9IDE7XG4gICAgfSBlbHNlIGlmIChmaWVsZHNbZmllbGRdID09PSAnZGVzY2VuZGluZycgfHwgZmllbGRzW2ZpZWxkXSA9PT0gJ2Rlc2MnKSB7XG4gICAgICBmaWVsZHNbZmllbGRdID0gLTE7XG4gICAgfVxuICB9XG5cbiAgdGhpcy5faW5kZXhlcy5wdXNoKFtmaWVsZHMsIG9wdGlvbnNdKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNldHMgYSBzY2hlbWEgb3B0aW9uLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgc2NoZW1hLnNldCgnc3RyaWN0Jyk7IC8vICd0cnVlJyBieSBkZWZhdWx0XG4gKiAgICAgc2NoZW1hLnNldCgnc3RyaWN0JywgZmFsc2UpOyAvLyBTZXRzICdzdHJpY3QnIHRvIGZhbHNlXG4gKiAgICAgc2NoZW1hLnNldCgnc3RyaWN0Jyk7IC8vICdmYWxzZSdcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30ga2V5IFRoZSBuYW1lIG9mIHRoZSBvcHRpb24gdG8gc2V0IHRoZSB2YWx1ZSB0b1xuICogQHBhcmFtIHtPYmplY3R9IFt2YWx1ZV0gVGhlIHZhbHVlIHRvIHNldCB0aGUgb3B0aW9uIHRvLCBpZiBub3QgcGFzc2VkLCB0aGUgb3B0aW9uIHdpbGwgYmUgcmVzZXQgdG8gZGVmYXVsdFxuICogQHBhcmFtIHtBcnJheTxzdHJpbmc+fSBbdGFnc10gdGFncyB0byBhZGQgdG8gcmVhZCBwcmVmZXJlbmNlIGlmIGtleSA9PT0gJ3JlYWQnXG4gKiBAc2VlIFNjaGVtYSBodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvYXBpL3NjaGVtYS5odG1sI1NjaGVtYSgpXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblNjaGVtYS5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24oa2V5LCB2YWx1ZSwgdGFncykge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgIHJldHVybiB0aGlzLm9wdGlvbnNba2V5XTtcbiAgfVxuXG4gIHN3aXRjaCAoa2V5KSB7XG4gICAgY2FzZSAncmVhZCc6XG4gICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICB0aGlzLm9wdGlvbnNba2V5XSA9IHsgbW9kZTogaGFuZGxlUmVhZFByZWZlcmVuY2VBbGlhc2VzKHZhbHVlKSwgdGFncyB9O1xuICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSAmJiB0eXBlb2YgdmFsdWVbMF0gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRoaXMub3B0aW9uc1trZXldID0ge1xuICAgICAgICAgIG1vZGU6IGhhbmRsZVJlYWRQcmVmZXJlbmNlQWxpYXNlcyh2YWx1ZVswXSksXG4gICAgICAgICAgdGFnczogdmFsdWVbMV1cbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMub3B0aW9uc1trZXldID0gdmFsdWU7XG4gICAgICB9XG4gICAgICB0aGlzLl91c2VyUHJvdmlkZWRPcHRpb25zW2tleV0gPSB0aGlzLm9wdGlvbnNba2V5XTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3RpbWVzdGFtcHMnOlxuICAgICAgdGhpcy5zZXR1cFRpbWVzdGFtcCh2YWx1ZSk7XG4gICAgICB0aGlzLm9wdGlvbnNba2V5XSA9IHZhbHVlO1xuICAgICAgdGhpcy5fdXNlclByb3ZpZGVkT3B0aW9uc1trZXldID0gdGhpcy5vcHRpb25zW2tleV07XG4gICAgICBicmVhaztcbiAgICBjYXNlICdfaWQnOlxuICAgICAgdGhpcy5vcHRpb25zW2tleV0gPSB2YWx1ZTtcbiAgICAgIHRoaXMuX3VzZXJQcm92aWRlZE9wdGlvbnNba2V5XSA9IHRoaXMub3B0aW9uc1trZXldO1xuXG4gICAgICBpZiAodmFsdWUgJiYgIXRoaXMucGF0aHNbJ19pZCddKSB7XG4gICAgICAgIGFkZEF1dG9JZCh0aGlzKTtcbiAgICAgIH0gZWxzZSBpZiAoIXZhbHVlICYmIHRoaXMucGF0aHNbJ19pZCddICE9IG51bGwgJiYgdGhpcy5wYXRoc1snX2lkJ10uYXV0bykge1xuICAgICAgICB0aGlzLnJlbW92ZSgnX2lkJyk7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgdGhpcy5vcHRpb25zW2tleV0gPSB2YWx1ZTtcbiAgICAgIHRoaXMuX3VzZXJQcm92aWRlZE9wdGlvbnNba2V5XSA9IHRoaXMub3B0aW9uc1trZXldO1xuICAgICAgYnJlYWs7XG4gIH1cblxuICAvLyBQcm9wYWdhdGUgYHN0cmljdGAgYW5kIGBzdHJpY3RRdWVyeWAgY2hhbmdlcyBkb3duIHRvIGltcGxpY2l0bHkgY3JlYXRlZCBzY2hlbWFzXG4gIGlmIChrZXkgPT09ICdzdHJpY3QnKSB7XG4gICAgX3Byb3BhZ2F0ZU9wdGlvbnNUb0ltcGxpY2l0bHlDcmVhdGVkU2NoZW1hcyh0aGlzLCB7IHN0cmljdDogdmFsdWUgfSk7XG4gIH1cbiAgaWYgKGtleSA9PT0gJ3N0cmljdFF1ZXJ5Jykge1xuICAgIF9wcm9wYWdhdGVPcHRpb25zVG9JbXBsaWNpdGx5Q3JlYXRlZFNjaGVtYXModGhpcywgeyBzdHJpY3RRdWVyeTogdmFsdWUgfSk7XG4gIH1cbiAgaWYgKGtleSA9PT0gJ3RvT2JqZWN0Jykge1xuICAgIHZhbHVlID0geyAuLi52YWx1ZSB9O1xuICAgIC8vIEF2b2lkIHByb3BhZ2F0aW5nIHRyYW5zZm9ybSB0byBpbXBsaWNpdGx5IGNyZWF0ZWQgc2NoZW1hcyByZTogZ2gtMzI3OVxuICAgIGRlbGV0ZSB2YWx1ZS50cmFuc2Zvcm07XG4gICAgX3Byb3BhZ2F0ZU9wdGlvbnNUb0ltcGxpY2l0bHlDcmVhdGVkU2NoZW1hcyh0aGlzLCB7IHRvT2JqZWN0OiB2YWx1ZSB9KTtcbiAgfVxuICBpZiAoa2V5ID09PSAndG9KU09OJykge1xuICAgIHZhbHVlID0geyAuLi52YWx1ZSB9O1xuICAgIC8vIEF2b2lkIHByb3BhZ2F0aW5nIHRyYW5zZm9ybSB0byBpbXBsaWNpdGx5IGNyZWF0ZWQgc2NoZW1hcyByZTogZ2gtMzI3OVxuICAgIGRlbGV0ZSB2YWx1ZS50cmFuc2Zvcm07XG4gICAgX3Byb3BhZ2F0ZU9wdGlvbnNUb0ltcGxpY2l0bHlDcmVhdGVkU2NoZW1hcyh0aGlzLCB7IHRvSlNPTjogdmFsdWUgfSk7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qIVxuICogUmVjdXJzaXZlbHkgc2V0IG9wdGlvbnMgb24gaW1wbGljaXRseSBjcmVhdGVkIHNjaGVtYXNcbiAqL1xuXG5mdW5jdGlvbiBfcHJvcGFnYXRlT3B0aW9uc1RvSW1wbGljaXRseUNyZWF0ZWRTY2hlbWFzKGJhc2VTY2hlbWEsIG9wdGlvbnMpIHtcbiAgZm9yIChjb25zdCB7IHNjaGVtYSB9IG9mIGJhc2VTY2hlbWEuY2hpbGRTY2hlbWFzKSB7XG4gICAgaWYgKCFzY2hlbWEuJGltcGxpY2l0bHlDcmVhdGVkKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgT2JqZWN0LmFzc2lnbihzY2hlbWEub3B0aW9ucywgb3B0aW9ucyk7XG4gICAgX3Byb3BhZ2F0ZU9wdGlvbnNUb0ltcGxpY2l0bHlDcmVhdGVkU2NoZW1hcyhzY2hlbWEsIG9wdGlvbnMpO1xuICB9XG59XG5cbi8qKlxuICogR2V0cyBhIHNjaGVtYSBvcHRpb24uXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBzY2hlbWEuZ2V0KCdzdHJpY3QnKTsgLy8gdHJ1ZVxuICogICAgIHNjaGVtYS5zZXQoJ3N0cmljdCcsIGZhbHNlKTtcbiAqICAgICBzY2hlbWEuZ2V0KCdzdHJpY3QnKTsgLy8gZmFsc2VcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30ga2V5IFRoZSBuYW1lIG9mIHRoZSBPcHRpb24gdG8gZ2V0IHRoZSBjdXJyZW50IHZhbHVlIGZvclxuICogQGFwaSBwdWJsaWNcbiAqIEByZXR1cm4ge0FueX0gdGhlIG9wdGlvbidzIHZhbHVlXG4gKi9cblxuU2NoZW1hLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbihrZXkpIHtcbiAgcmV0dXJuIHRoaXMub3B0aW9uc1trZXldO1xufTtcblxuY29uc3QgaW5kZXhUeXBlcyA9ICcyZCAyZHNwaGVyZSBoYXNoZWQgdGV4dCcuc3BsaXQoJyAnKTtcblxuLyoqXG4gKiBUaGUgYWxsb3dlZCBpbmRleCB0eXBlc1xuICpcbiAqIEBwcm9wZXJ0eSB7U3RyaW5nW119IGluZGV4VHlwZXNcbiAqIEBtZW1iZXJPZiBTY2hlbWFcbiAqIEBzdGF0aWNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFNjaGVtYSwgJ2luZGV4VHlwZXMnLCB7XG4gIGdldDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGluZGV4VHlwZXM7XG4gIH0sXG4gIHNldDogZnVuY3Rpb24oKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3Qgb3ZlcndyaXRlIFNjaGVtYS5pbmRleFR5cGVzJyk7XG4gIH1cbn0pO1xuXG4vKipcbiAqIFJldHVybnMgYSBsaXN0IG9mIGluZGV4ZXMgdGhhdCB0aGlzIHNjaGVtYSBkZWNsYXJlcywgdmlhIGBzY2hlbWEuaW5kZXgoKWAgb3IgYnkgYGluZGV4OiB0cnVlYCBpbiBhIHBhdGgncyBvcHRpb25zLlxuICogSW5kZXhlcyBhcmUgZXhwcmVzc2VkIGFzIGFuIGFycmF5IGBbc3BlYywgb3B0aW9uc11gLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgY29uc3QgdXNlclNjaGVtYSA9IG5ldyBTY2hlbWEoe1xuICogICAgICAgZW1haWw6IHsgdHlwZTogU3RyaW5nLCByZXF1aXJlZDogdHJ1ZSwgdW5pcXVlOiB0cnVlIH0sXG4gKiAgICAgICByZWdpc3RlcmVkQXQ6IHsgdHlwZTogRGF0ZSwgaW5kZXg6IHRydWUgfVxuICogICAgIH0pO1xuICpcbiAqICAgICAvLyBbIFsgeyBlbWFpbDogMSB9LCB7IHVuaXF1ZTogdHJ1ZSwgYmFja2dyb3VuZDogdHJ1ZSB9IF0sXG4gKiAgICAgLy8gICBbIHsgcmVnaXN0ZXJlZEF0OiAxIH0sIHsgYmFja2dyb3VuZDogdHJ1ZSB9IF0gXVxuICogICAgIHVzZXJTY2hlbWEuaW5kZXhlcygpO1xuICpcbiAqIFtQbHVnaW5zXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvcGx1Z2lucy5odG1sKSBjYW4gdXNlIHRoZSByZXR1cm4gdmFsdWUgb2YgdGhpcyBmdW5jdGlvbiB0byBtb2RpZnkgYSBzY2hlbWEncyBpbmRleGVzLlxuICogRm9yIGV4YW1wbGUsIHRoZSBiZWxvdyBwbHVnaW4gbWFrZXMgZXZlcnkgaW5kZXggdW5pcXVlIGJ5IGRlZmF1bHQuXG4gKlxuICogICAgIGZ1bmN0aW9uIG15UGx1Z2luKHNjaGVtYSkge1xuICogICAgICAgZm9yIChjb25zdCBpbmRleCBvZiBzY2hlbWEuaW5kZXhlcygpKSB7XG4gKiAgICAgICAgIGlmIChpbmRleFsxXS51bmlxdWUgPT09IHVuZGVmaW5lZCkge1xuICogICAgICAgICAgIGluZGV4WzFdLnVuaXF1ZSA9IHRydWU7XG4gKiAgICAgICAgIH1cbiAqICAgICAgIH1cbiAqICAgICB9XG4gKlxuICogQGFwaSBwdWJsaWNcbiAqIEByZXR1cm4ge0FycmF5fSBsaXN0IG9mIGluZGV4ZXMgZGVmaW5lZCBpbiB0aGUgc2NoZW1hXG4gKi9cblxuU2NoZW1hLnByb3RvdHlwZS5pbmRleGVzID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBnZXRJbmRleGVzKHRoaXMpO1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgdmlydHVhbCB0eXBlIHdpdGggdGhlIGdpdmVuIG5hbWUuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgVGhlIG5hbWUgb2YgdGhlIFZpcnR1YWxcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEBwYXJhbSB7U3RyaW5nfE1vZGVsfSBbb3B0aW9ucy5yZWZdIG1vZGVsIG5hbWUgb3IgbW9kZWwgaW5zdGFuY2UuIE1hcmtzIHRoaXMgYXMgYSBbcG9wdWxhdGUgdmlydHVhbF0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL3BvcHVsYXRlLmh0bWwjcG9wdWxhdGUtdmlydHVhbHMpLlxuICogQHBhcmFtIHtTdHJpbmd8RnVuY3Rpb259IFtvcHRpb25zLmxvY2FsRmllbGRdIFJlcXVpcmVkIGZvciBwb3B1bGF0ZSB2aXJ0dWFscy4gU2VlIFtwb3B1bGF0ZSB2aXJ0dWFsIGRvY3NdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9wb3B1bGF0ZS5odG1sI3BvcHVsYXRlLXZpcnR1YWxzKSBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiAqIEBwYXJhbSB7U3RyaW5nfEZ1bmN0aW9ufSBbb3B0aW9ucy5mb3JlaWduRmllbGRdIFJlcXVpcmVkIGZvciBwb3B1bGF0ZSB2aXJ0dWFscy4gU2VlIFtwb3B1bGF0ZSB2aXJ0dWFsIGRvY3NdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9wb3B1bGF0ZS5odG1sI3BvcHVsYXRlLXZpcnR1YWxzKSBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiAqIEBwYXJhbSB7Qm9vbGVhbnxGdW5jdGlvbn0gW29wdGlvbnMuanVzdE9uZT1mYWxzZV0gT25seSB3b3JrcyB3aXRoIHBvcHVsYXRlIHZpcnR1YWxzLiBJZiBbdHJ1dGh5XShodHRwczovL21hc3RlcmluZ2pzLmlvL3R1dG9yaWFscy9mdW5kYW1lbnRhbHMvdHJ1dGh5KSwgd2lsbCBiZSBhIHNpbmdsZSBkb2Mgb3IgYG51bGxgLiBPdGhlcndpc2UsIHRoZSBwb3B1bGF0ZSB2aXJ0dWFsIHdpbGwgYmUgYW4gYXJyYXkuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmNvdW50PWZhbHNlXSBPbmx5IHdvcmtzIHdpdGggcG9wdWxhdGUgdmlydHVhbHMuIElmIFt0cnV0aHldKGh0dHBzOi8vbWFzdGVyaW5nanMuaW8vdHV0b3JpYWxzL2Z1bmRhbWVudGFscy90cnV0aHkpLCB0aGlzIHBvcHVsYXRlIHZpcnR1YWwgd2lsbCBjb250YWluIHRoZSBudW1iZXIgb2YgZG9jdW1lbnRzIHJhdGhlciB0aGFuIHRoZSBkb2N1bWVudHMgdGhlbXNlbHZlcyB3aGVuIHlvdSBgcG9wdWxhdGUoKWAuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufG51bGx9IFtvcHRpb25zLmdldD1udWxsXSBBZGRzIGEgW2dldHRlcl0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL3R1dG9yaWFscy9nZXR0ZXJzLXNldHRlcnMuaHRtbCkgdG8gdGhpcyB2aXJ0dWFsIHRvIHRyYW5zZm9ybSB0aGUgcG9wdWxhdGVkIGRvYy5cbiAqIEBwYXJhbSB7T2JqZWN0fEZ1bmN0aW9ufSBbb3B0aW9ucy5tYXRjaD1udWxsXSBBcHBseSBhIGRlZmF1bHQgW2BtYXRjaGAgb3B0aW9uIHRvIHBvcHVsYXRlXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvcG9wdWxhdGUuaHRtbCNtYXRjaCksIGFkZGluZyBhbiBhZGRpdGlvbmFsIGZpbHRlciB0byB0aGUgcG9wdWxhdGUgcXVlcnkuXG4gKiBAcmV0dXJuIHtWaXJ0dWFsVHlwZX1cbiAqL1xuXG5TY2hlbWEucHJvdG90eXBlLnZpcnR1YWwgPSBmdW5jdGlvbihuYW1lLCBvcHRpb25zKSB7XG4gIGlmIChuYW1lIGluc3RhbmNlb2YgVmlydHVhbFR5cGUgfHwgZ2V0Q29uc3RydWN0b3JOYW1lKG5hbWUpID09PSAnVmlydHVhbFR5cGUnKSB7XG4gICAgcmV0dXJuIHRoaXMudmlydHVhbChuYW1lLnBhdGgsIG5hbWUub3B0aW9ucyk7XG4gIH1cbiAgb3B0aW9ucyA9IG5ldyBWaXJ0dWFsT3B0aW9ucyhvcHRpb25zKTtcblxuICBpZiAodXRpbHMuaGFzVXNlckRlZmluZWRQcm9wZXJ0eShvcHRpb25zLCBbJ3JlZicsICdyZWZQYXRoJ10pKSB7XG4gICAgaWYgKG9wdGlvbnMubG9jYWxGaWVsZCA9PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1JlZmVyZW5jZSB2aXJ0dWFscyByZXF1aXJlIGBsb2NhbEZpZWxkYCBvcHRpb24nKTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5mb3JlaWduRmllbGQgPT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdSZWZlcmVuY2UgdmlydHVhbHMgcmVxdWlyZSBgZm9yZWlnbkZpZWxkYCBvcHRpb24nKTtcbiAgICB9XG5cbiAgICB0aGlzLnByZSgnaW5pdCcsIGZ1bmN0aW9uIHZpcnR1YWxQcmVJbml0KG9iaikge1xuICAgICAgaWYgKG1wYXRoLmhhcyhuYW1lLCBvYmopKSB7XG4gICAgICAgIGNvbnN0IF92ID0gbXBhdGguZ2V0KG5hbWUsIG9iaik7XG4gICAgICAgIGlmICghdGhpcy4kJHBvcHVsYXRlZFZpcnR1YWxzKSB7XG4gICAgICAgICAgdGhpcy4kJHBvcHVsYXRlZFZpcnR1YWxzID0ge307XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob3B0aW9ucy5qdXN0T25lIHx8IG9wdGlvbnMuY291bnQpIHtcbiAgICAgICAgICB0aGlzLiQkcG9wdWxhdGVkVmlydHVhbHNbbmFtZV0gPSBBcnJheS5pc0FycmF5KF92KSA/XG4gICAgICAgICAgICBfdlswXSA6XG4gICAgICAgICAgICBfdjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLiQkcG9wdWxhdGVkVmlydHVhbHNbbmFtZV0gPSBBcnJheS5pc0FycmF5KF92KSA/XG4gICAgICAgICAgICBfdiA6XG4gICAgICAgICAgICBfdiA9PSBudWxsID8gW10gOiBbX3ZdO1xuICAgICAgICB9XG5cbiAgICAgICAgbXBhdGgudW5zZXQobmFtZSwgb2JqKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGNvbnN0IHZpcnR1YWwgPSB0aGlzLnZpcnR1YWwobmFtZSk7XG4gICAgdmlydHVhbC5vcHRpb25zID0gb3B0aW9ucztcblxuICAgIHZpcnR1YWwuXG4gICAgICBzZXQoZnVuY3Rpb24odikge1xuICAgICAgICBpZiAoIXRoaXMuJCRwb3B1bGF0ZWRWaXJ0dWFscykge1xuICAgICAgICAgIHRoaXMuJCRwb3B1bGF0ZWRWaXJ0dWFscyA9IHt9O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHNldFBvcHVsYXRlZFZpcnR1YWxWYWx1ZShcbiAgICAgICAgICB0aGlzLiQkcG9wdWxhdGVkVmlydHVhbHMsXG4gICAgICAgICAgbmFtZSxcbiAgICAgICAgICB2LFxuICAgICAgICAgIG9wdGlvbnNcbiAgICAgICAgKTtcbiAgICAgIH0pO1xuXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmdldCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdmlydHVhbC5nZXQob3B0aW9ucy5nZXQpO1xuICAgIH1cblxuICAgIC8vIFdvcmthcm91bmQgZm9yIGdoLTgxOTg6IGlmIHZpcnR1YWwgaXMgdW5kZXIgZG9jdW1lbnQgYXJyYXksIG1ha2UgYSBmYWtlXG4gICAgLy8gdmlydHVhbC4gU2VlIGdoLTgyMTAsIGdoLTEzMTg5XG4gICAgY29uc3QgcGFydHMgPSBuYW1lLnNwbGl0KCcuJyk7XG4gICAgbGV0IGN1ciA9IHBhcnRzWzBdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFydHMubGVuZ3RoIC0gMTsgKytpKSB7XG4gICAgICBpZiAodGhpcy5wYXRoc1tjdXJdID09IG51bGwpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLnBhdGhzW2N1cl0uJGlzTW9uZ29vc2VEb2N1bWVudEFycmF5IHx8IHRoaXMucGF0aHNbY3VyXS4kaXNTaW5nbGVOZXN0ZWQpIHtcbiAgICAgICAgY29uc3QgcmVtbmFudCA9IHBhcnRzLnNsaWNlKGkgKyAxKS5qb2luKCcuJyk7XG4gICAgICAgIHRoaXMucGF0aHNbY3VyXS5zY2hlbWEudmlydHVhbChyZW1uYW50LCBvcHRpb25zKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGN1ciArPSAnLicgKyBwYXJ0c1tpICsgMV07XG4gICAgfVxuXG4gICAgcmV0dXJuIHZpcnR1YWw7XG4gIH1cblxuICBjb25zdCB2aXJ0dWFscyA9IHRoaXMudmlydHVhbHM7XG4gIGNvbnN0IHBhcnRzID0gbmFtZS5zcGxpdCgnLicpO1xuXG4gIGlmICh0aGlzLnBhdGhUeXBlKG5hbWUpID09PSAncmVhbCcpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1ZpcnR1YWwgcGF0aCBcIicgKyBuYW1lICsgJ1wiJyArXG4gICAgICAnIGNvbmZsaWN0cyB3aXRoIGEgcmVhbCBwYXRoIGluIHRoZSBzY2hlbWEnKTtcbiAgfVxuXG4gIHZpcnR1YWxzW25hbWVdID0gcGFydHMucmVkdWNlKGZ1bmN0aW9uKG1lbSwgcGFydCwgaSkge1xuICAgIG1lbVtwYXJ0XSB8fCAobWVtW3BhcnRdID0gKGkgPT09IHBhcnRzLmxlbmd0aCAtIDEpXG4gICAgICA/IG5ldyBWaXJ0dWFsVHlwZShvcHRpb25zLCBuYW1lKVxuICAgICAgOiB7fSk7XG4gICAgcmV0dXJuIG1lbVtwYXJ0XTtcbiAgfSwgdGhpcy50cmVlKTtcblxuICByZXR1cm4gdmlydHVhbHNbbmFtZV07XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIHZpcnR1YWwgdHlwZSB3aXRoIHRoZSBnaXZlbiBgbmFtZWAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgVGhlIG5hbWUgb2YgdGhlIFZpcnR1YWwgdG8gZ2V0XG4gKiBAcmV0dXJuIHtWaXJ0dWFsVHlwZXxudWxsfVxuICovXG5cblNjaGVtYS5wcm90b3R5cGUudmlydHVhbHBhdGggPSBmdW5jdGlvbihuYW1lKSB7XG4gIHJldHVybiB0aGlzLnZpcnR1YWxzLmhhc093blByb3BlcnR5KG5hbWUpID8gdGhpcy52aXJ0dWFsc1tuYW1lXSA6IG51bGw7XG59O1xuXG4vKipcbiAqIFJlbW92ZXMgdGhlIGdpdmVuIGBwYXRoYCAob3IgW2BwYXRoc2BdKS5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IHNjaGVtYSA9IG5ldyBTY2hlbWEoeyBuYW1lOiBTdHJpbmcsIGFnZTogTnVtYmVyIH0pO1xuICogICAgIHNjaGVtYS5yZW1vdmUoJ25hbWUnKTtcbiAqICAgICBzY2hlbWEucGF0aCgnbmFtZScpOyAvLyBVbmRlZmluZWRcbiAqICAgICBzY2hlbWEucGF0aCgnYWdlJyk7IC8vIFNjaGVtYU51bWJlciB7IC4uLiB9XG4gKlxuICogT3IgYXMgYSBBcnJheTpcbiAqXG4gKiAgICAgc2NoZW1hLnJlbW92ZShbJ25hbWUnLCAnYWdlJ10pO1xuICogICAgIHNjaGVtYS5wYXRoKCduYW1lJyk7IC8vIFVuZGVmaW5lZFxuICogICAgIHNjaGVtYS5wYXRoKCdhZ2UnKTsgLy8gVW5kZWZpbmVkXG4gKlxuICogQHBhcmFtIHtTdHJpbmd8QXJyYXl9IHBhdGggVGhlIFBhdGgocykgdG8gcmVtb3ZlXG4gKiBAcmV0dXJuIHtTY2hlbWF9IHRoZSBTY2hlbWEgaW5zdGFuY2VcbiAqIEBhcGkgcHVibGljXG4gKi9cblNjaGVtYS5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24ocGF0aCkge1xuICBpZiAodHlwZW9mIHBhdGggPT09ICdzdHJpbmcnKSB7XG4gICAgcGF0aCA9IFtwYXRoXTtcbiAgfVxuICBpZiAoQXJyYXkuaXNBcnJheShwYXRoKSkge1xuICAgIHBhdGguZm9yRWFjaChmdW5jdGlvbihuYW1lKSB7XG4gICAgICBpZiAodGhpcy5wYXRoKG5hbWUpID09IG51bGwgJiYgIXRoaXMubmVzdGVkW25hbWVdKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLm5lc3RlZFtuYW1lXSkge1xuICAgICAgICBjb25zdCBhbGxLZXlzID0gT2JqZWN0LmtleXModGhpcy5wYXRocykuXG4gICAgICAgICAgY29uY2F0KE9iamVjdC5rZXlzKHRoaXMubmVzdGVkKSk7XG4gICAgICAgIGZvciAoY29uc3QgcGF0aCBvZiBhbGxLZXlzKSB7XG4gICAgICAgICAgaWYgKHBhdGguc3RhcnRzV2l0aChuYW1lICsgJy4nKSkge1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMucGF0aHNbcGF0aF07XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5uZXN0ZWRbcGF0aF07XG4gICAgICAgICAgICBfZGVsZXRlUGF0aCh0aGlzLCBwYXRoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBkZWxldGUgdGhpcy5uZXN0ZWRbbmFtZV07XG4gICAgICAgIF9kZWxldGVQYXRoKHRoaXMsIG5hbWUpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGRlbGV0ZSB0aGlzLnBhdGhzW25hbWVdO1xuICAgICAgX2RlbGV0ZVBhdGgodGhpcywgbmFtZSk7XG4gICAgfSwgdGhpcyk7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cbmZ1bmN0aW9uIF9kZWxldGVQYXRoKHNjaGVtYSwgbmFtZSkge1xuICBjb25zdCBwaWVjZXMgPSBuYW1lLnNwbGl0KCcuJyk7XG4gIGNvbnN0IGxhc3QgPSBwaWVjZXMucG9wKCk7XG5cbiAgbGV0IGJyYW5jaCA9IHNjaGVtYS50cmVlO1xuXG4gIGZvciAoY29uc3QgcGllY2Ugb2YgcGllY2VzKSB7XG4gICAgYnJhbmNoID0gYnJhbmNoW3BpZWNlXTtcbiAgfVxuXG4gIGRlbGV0ZSBicmFuY2hbbGFzdF07XG59XG5cbi8qKlxuICogUmVtb3ZlcyB0aGUgZ2l2ZW4gdmlydHVhbCBvciB2aXJ0dWFscyBmcm9tIHRoZSBzY2hlbWEuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd8QXJyYXl9IHBhdGggVGhlIHZpcnV0YWwgcGF0aChzKSB0byByZW1vdmUuXG4gKiBAcmV0dXJucyB7U2NoZW1hfSB0aGUgU2NoZW1hIGluc3RhbmNlLCBvciBhIG1vbmdvb3NlIGVycm9yIGlmIHRoZSB2aXJ0dWFsIGRvZXMgbm90IGV4aXN0LlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5TY2hlbWEucHJvdG90eXBlLnJlbW92ZVZpcnR1YWwgPSBmdW5jdGlvbihwYXRoKSB7XG4gIGlmICh0eXBlb2YgcGF0aCA9PT0gJ3N0cmluZycpIHtcbiAgICBwYXRoID0gW3BhdGhdO1xuICB9XG4gIGlmIChBcnJheS5pc0FycmF5KHBhdGgpKSB7XG4gICAgZm9yIChjb25zdCB2aXJ0dWFsIG9mIHBhdGgpIHtcbiAgICAgIGlmICh0aGlzLnZpcnR1YWxzW3ZpcnR1YWxdID09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IE1vbmdvb3NlRXJyb3IoYEF0dGVtcHRpbmcgdG8gcmVtb3ZlIHZpcnR1YWwgXCIke3ZpcnR1YWx9XCIgdGhhdCBkb2VzIG5vdCBleGlzdC5gKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKGNvbnN0IHZpcnR1YWwgb2YgcGF0aCkge1xuICAgICAgZGVsZXRlIHRoaXMucGF0aHNbdmlydHVhbF07XG4gICAgICBkZWxldGUgdGhpcy52aXJ0dWFsc1t2aXJ0dWFsXTtcbiAgICAgIGlmICh2aXJ0dWFsLmluZGV4T2YoJy4nKSAhPT0gLTEpIHtcbiAgICAgICAgbXBhdGgudW5zZXQodmlydHVhbCwgdGhpcy50cmVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzLnRyZWVbdmlydHVhbF07XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBMb2FkcyBhbiBFUzYgY2xhc3MgaW50byBhIHNjaGVtYS4gTWFwcyBbc2V0dGVyc10oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvRnVuY3Rpb25zL3NldCkgKyBbZ2V0dGVyc10oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvRnVuY3Rpb25zL2dldCksIFtzdGF0aWMgbWV0aG9kc10oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvQ2xhc3Nlcy9zdGF0aWMpLFxuICogYW5kIFtpbnN0YW5jZSBtZXRob2RzXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9DbGFzc2VzI0NsYXNzX2JvZHlfYW5kX21ldGhvZF9kZWZpbml0aW9ucylcbiAqIHRvIHNjaGVtYSBbdmlydHVhbHNdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9ndWlkZS5odG1sI3ZpcnR1YWxzKSxcbiAqIFtzdGF0aWNzXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvZ3VpZGUuaHRtbCNzdGF0aWNzKSwgYW5kXG4gKiBbbWV0aG9kc10oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2d1aWRlLmh0bWwjbWV0aG9kcykuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqIGBgYGphdmFzY3JpcHRcbiAqIGNvbnN0IG1kNSA9IHJlcXVpcmUoJ21kNScpO1xuICogY29uc3QgdXNlclNjaGVtYSA9IG5ldyBTY2hlbWEoeyBlbWFpbDogU3RyaW5nIH0pO1xuICogY2xhc3MgVXNlckNsYXNzIHtcbiAqICAgLy8gYGdyYXZhdGFySW1hZ2VgIGJlY29tZXMgYSB2aXJ0dWFsXG4gKiAgIGdldCBncmF2YXRhckltYWdlKCkge1xuICogICAgIGNvbnN0IGhhc2ggPSBtZDUodGhpcy5lbWFpbC50b0xvd2VyQ2FzZSgpKTtcbiAqICAgICByZXR1cm4gYGh0dHBzOi8vd3d3LmdyYXZhdGFyLmNvbS9hdmF0YXIvJHtoYXNofWA7XG4gKiAgIH1cbiAqXG4gKiAgIC8vIGBnZXRQcm9maWxlVXJsKClgIGJlY29tZXMgYSBkb2N1bWVudCBtZXRob2RcbiAqICAgZ2V0UHJvZmlsZVVybCgpIHtcbiAqICAgICByZXR1cm4gYGh0dHBzOi8vbXlzaXRlLmNvbS8ke3RoaXMuZW1haWx9YDtcbiAqICAgfVxuICpcbiAqICAgLy8gYGZpbmRCeUVtYWlsKClgIGJlY29tZXMgYSBzdGF0aWNcbiAqICAgc3RhdGljIGZpbmRCeUVtYWlsKGVtYWlsKSB7XG4gKiAgICAgcmV0dXJuIHRoaXMuZmluZE9uZSh7IGVtYWlsIH0pO1xuICogICB9XG4gKiB9XG4gKlxuICogLy8gYHNjaGVtYWAgd2lsbCBub3cgaGF2ZSBhIGBncmF2YXRhckltYWdlYCB2aXJ0dWFsLCBhIGBnZXRQcm9maWxlVXJsKClgIG1ldGhvZCxcbiAqIC8vIGFuZCBhIGBmaW5kQnlFbWFpbCgpYCBzdGF0aWNcbiAqIHVzZXJTY2hlbWEubG9hZENsYXNzKFVzZXJDbGFzcyk7XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBtb2RlbCBUaGUgQ2xhc3MgdG8gbG9hZFxuICogQHBhcmFtIHtCb29sZWFufSBbdmlydHVhbHNPbmx5XSBpZiB0cnV0aHksIG9ubHkgcHVsbHMgdmlydHVhbHMgZnJvbSB0aGUgY2xhc3MsIG5vdCBtZXRob2RzIG9yIHN0YXRpY3NcbiAqL1xuU2NoZW1hLnByb3RvdHlwZS5sb2FkQ2xhc3MgPSBmdW5jdGlvbihtb2RlbCwgdmlydHVhbHNPbmx5KSB7XG4gIC8vIFN0b3AgY29weWluZyB3aGVuIGhpdCBjZXJ0YWluIGJhc2UgY2xhc3Nlc1xuICBpZiAobW9kZWwgPT09IE9iamVjdC5wcm90b3R5cGUgfHxcbiAgICAgIG1vZGVsID09PSBGdW5jdGlvbi5wcm90b3R5cGUgfHxcbiAgICAgIG1vZGVsLnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSgnJGlzTW9uZ29vc2VNb2RlbFByb3RvdHlwZScpIHx8XG4gICAgICBtb2RlbC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkoJyRpc01vbmdvb3NlRG9jdW1lbnRQcm90b3R5cGUnKSkge1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgdGhpcy5sb2FkQ2xhc3MoT2JqZWN0LmdldFByb3RvdHlwZU9mKG1vZGVsKSwgdmlydHVhbHNPbmx5KTtcblxuICAvLyBBZGQgc3RhdGljIG1ldGhvZHNcbiAgaWYgKCF2aXJ0dWFsc09ubHkpIHtcbiAgICBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhtb2RlbCkuZm9yRWFjaChmdW5jdGlvbihuYW1lKSB7XG4gICAgICBpZiAobmFtZS5tYXRjaCgvXihsZW5ndGh8bmFtZXxwcm90b3R5cGV8Y29uc3RydWN0b3J8X19wcm90b19fKSQvKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBwcm9wID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtb2RlbCwgbmFtZSk7XG4gICAgICBpZiAocHJvcC5oYXNPd25Qcm9wZXJ0eSgndmFsdWUnKSkge1xuICAgICAgICB0aGlzLnN0YXRpYyhuYW1lLCBwcm9wLnZhbHVlKTtcbiAgICAgIH1cbiAgICB9LCB0aGlzKTtcbiAgfVxuXG4gIC8vIEFkZCBtZXRob2RzIGFuZCB2aXJ0dWFsc1xuICBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhtb2RlbC5wcm90b3R5cGUpLmZvckVhY2goZnVuY3Rpb24obmFtZSkge1xuICAgIGlmIChuYW1lLm1hdGNoKC9eKGNvbnN0cnVjdG9yKSQvKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBtZXRob2QgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG1vZGVsLnByb3RvdHlwZSwgbmFtZSk7XG4gICAgaWYgKCF2aXJ0dWFsc09ubHkpIHtcbiAgICAgIGlmICh0eXBlb2YgbWV0aG9kLnZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRoaXMubWV0aG9kKG5hbWUsIG1ldGhvZC52YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0eXBlb2YgbWV0aG9kLmdldCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaWYgKHRoaXMudmlydHVhbHNbbmFtZV0pIHtcbiAgICAgICAgdGhpcy52aXJ0dWFsc1tuYW1lXS5nZXR0ZXJzID0gW107XG4gICAgICB9XG4gICAgICB0aGlzLnZpcnR1YWwobmFtZSkuZ2V0KG1ldGhvZC5nZXQpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG1ldGhvZC5zZXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGlmICh0aGlzLnZpcnR1YWxzW25hbWVdKSB7XG4gICAgICAgIHRoaXMudmlydHVhbHNbbmFtZV0uc2V0dGVycyA9IFtdO1xuICAgICAgfVxuICAgICAgdGhpcy52aXJ0dWFsKG5hbWUpLnNldChtZXRob2Quc2V0KTtcbiAgICB9XG4gIH0sIHRoaXMpO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5TY2hlbWEucHJvdG90eXBlLl9nZXRTY2hlbWEgPSBmdW5jdGlvbihwYXRoKSB7XG4gIGNvbnN0IF90aGlzID0gdGhpcztcbiAgY29uc3QgcGF0aHNjaGVtYSA9IF90aGlzLnBhdGgocGF0aCk7XG4gIGNvbnN0IHJlc3VsdFBhdGggPSBbXTtcblxuICBpZiAocGF0aHNjaGVtYSkge1xuICAgIHBhdGhzY2hlbWEuJGZ1bGxQYXRoID0gcGF0aDtcbiAgICByZXR1cm4gcGF0aHNjaGVtYTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNlYXJjaChwYXJ0cywgc2NoZW1hKSB7XG4gICAgbGV0IHAgPSBwYXJ0cy5sZW5ndGggKyAxO1xuICAgIGxldCBmb3VuZHNjaGVtYTtcbiAgICBsZXQgdHJ5cGF0aDtcblxuICAgIHdoaWxlIChwLS0pIHtcbiAgICAgIHRyeXBhdGggPSBwYXJ0cy5zbGljZSgwLCBwKS5qb2luKCcuJyk7XG4gICAgICBmb3VuZHNjaGVtYSA9IHNjaGVtYS5wYXRoKHRyeXBhdGgpO1xuICAgICAgaWYgKGZvdW5kc2NoZW1hKSB7XG4gICAgICAgIHJlc3VsdFBhdGgucHVzaCh0cnlwYXRoKTtcblxuICAgICAgICBpZiAoZm91bmRzY2hlbWEuY2FzdGVyKSB7XG4gICAgICAgICAgLy8gYXJyYXkgb2YgTWl4ZWQ/XG4gICAgICAgICAgaWYgKGZvdW5kc2NoZW1hLmNhc3RlciBpbnN0YW5jZW9mIE1vbmdvb3NlVHlwZXMuTWl4ZWQpIHtcbiAgICAgICAgICAgIGZvdW5kc2NoZW1hLmNhc3Rlci4kZnVsbFBhdGggPSByZXN1bHRQYXRoLmpvaW4oJy4nKTtcbiAgICAgICAgICAgIHJldHVybiBmb3VuZHNjaGVtYS5jYXN0ZXI7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gTm93IHRoYXQgd2UgZm91bmQgdGhlIGFycmF5LCB3ZSBuZWVkIHRvIGNoZWNrIGlmIHRoZXJlXG4gICAgICAgICAgLy8gYXJlIHJlbWFpbmluZyBkb2N1bWVudCBwYXRocyB0byBsb29rIHVwIGZvciBjYXN0aW5nLlxuICAgICAgICAgIC8vIEFsc28gd2UgbmVlZCB0byBoYW5kbGUgYXJyYXkuJC5wYXRoIHNpbmNlIHNjaGVtYS5wYXRoXG4gICAgICAgICAgLy8gZG9lc24ndCB3b3JrIGZvciB0aGF0LlxuICAgICAgICAgIC8vIElmIHRoZXJlIGlzIG5vIGZvdW5kc2NoZW1hLnNjaGVtYSB3ZSBhcmUgZGVhbGluZyB3aXRoXG4gICAgICAgICAgLy8gYSBwYXRoIGxpa2UgYXJyYXkuJFxuICAgICAgICAgIGlmIChwICE9PSBwYXJ0cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmIChmb3VuZHNjaGVtYS5zY2hlbWEpIHtcbiAgICAgICAgICAgICAgbGV0IHJldDtcbiAgICAgICAgICAgICAgaWYgKHBhcnRzW3BdID09PSAnJCcgfHwgaXNBcnJheUZpbHRlcihwYXJ0c1twXSkpIHtcbiAgICAgICAgICAgICAgICBpZiAocCArIDEgPT09IHBhcnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgLy8gY29tbWVudHMuJFxuICAgICAgICAgICAgICAgICAgcmV0dXJuIGZvdW5kc2NoZW1hLiRlbWJlZGRlZFNjaGVtYVR5cGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGNvbW1lbnRzLiQuY29tbWVudHMuJC50aXRsZVxuICAgICAgICAgICAgICAgIHJldCA9IHNlYXJjaChwYXJ0cy5zbGljZShwICsgMSksIGZvdW5kc2NoZW1hLnNjaGVtYSk7XG4gICAgICAgICAgICAgICAgaWYgKHJldCkge1xuICAgICAgICAgICAgICAgICAgcmV0LiRwYXJlbnRTY2hlbWFEb2NBcnJheSA9IHJldC4kcGFyZW50U2NoZW1hRG9jQXJyYXkgfHxcbiAgICAgICAgICAgICAgICAgICAgKGZvdW5kc2NoZW1hLnNjaGVtYS4kaXNTaW5nbGVOZXN0ZWQgPyBudWxsIDogZm91bmRzY2hlbWEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8vIHRoaXMgaXMgdGhlIGxhc3QgcGF0aCBvZiB0aGUgc2VsZWN0b3JcbiAgICAgICAgICAgICAgcmV0ID0gc2VhcmNoKHBhcnRzLnNsaWNlKHApLCBmb3VuZHNjaGVtYS5zY2hlbWEpO1xuICAgICAgICAgICAgICBpZiAocmV0KSB7XG4gICAgICAgICAgICAgICAgcmV0LiRwYXJlbnRTY2hlbWFEb2NBcnJheSA9IHJldC4kcGFyZW50U2NoZW1hRG9jQXJyYXkgfHxcbiAgICAgICAgICAgICAgICAgIChmb3VuZHNjaGVtYS5zY2hlbWEuJGlzU2luZ2xlTmVzdGVkID8gbnVsbCA6IGZvdW5kc2NoZW1hKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChmb3VuZHNjaGVtYS4kaXNTY2hlbWFNYXApIHtcbiAgICAgICAgICBpZiAocCA+PSBwYXJ0cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBmb3VuZHNjaGVtYTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gQW55IHBhdGggaW4gdGhlIG1hcCB3aWxsIGJlIGFuIGluc3RhbmNlIG9mIHRoZSBtYXAncyBlbWJlZGRlZCBzY2hlbWF0eXBlXG4gICAgICAgICAgaWYgKHAgKyAxID49IHBhcnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIGZvdW5kc2NoZW1hLiRfX3NjaGVtYVR5cGU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGZvdW5kc2NoZW1hLiRfX3NjaGVtYVR5cGUgaW5zdGFuY2VvZiBNb25nb29zZVR5cGVzLk1peGVkKSB7XG4gICAgICAgICAgICByZXR1cm4gZm91bmRzY2hlbWEuJF9fc2NoZW1hVHlwZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGZvdW5kc2NoZW1hLiRfX3NjaGVtYVR5cGUuc2NoZW1hICE9IG51bGwpIHtcbiAgICAgICAgICAgIC8vIE1hcCBvZiBkb2NzXG4gICAgICAgICAgICBjb25zdCByZXQgPSBzZWFyY2gocGFydHMuc2xpY2UocCArIDEpLCBmb3VuZHNjaGVtYS4kX19zY2hlbWFUeXBlLnNjaGVtYSk7XG4gICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZvdW5kc2NoZW1hLiRmdWxsUGF0aCA9IHJlc3VsdFBhdGguam9pbignLicpO1xuXG4gICAgICAgIHJldHVybiBmb3VuZHNjaGVtYTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBsb29rIGZvciBhcnJheXNcbiAgY29uc3QgcGFydHMgPSBwYXRoLnNwbGl0KCcuJyk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcGFydHMubGVuZ3RoOyArK2kpIHtcbiAgICBpZiAocGFydHNbaV0gPT09ICckJyB8fCBpc0FycmF5RmlsdGVyKHBhcnRzW2ldKSkge1xuICAgICAgLy8gUmU6IGdoLTU2MjgsIGJlY2F1c2UgYHNjaGVtYS5wYXRoKClgIGRvZXNuJ3QgdGFrZSAkIGludG8gYWNjb3VudC5cbiAgICAgIHBhcnRzW2ldID0gJzAnO1xuICAgIH1cbiAgICBpZiAobnVtYmVyUkUudGVzdChwYXJ0c1tpXSkpIHtcbiAgICAgIHBhcnRzW2ldID0gJyQnO1xuICAgIH1cbiAgfVxuICByZXR1cm4gc2VhcmNoKHBhcnRzLCBfdGhpcyk7XG59O1xuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cblNjaGVtYS5wcm90b3R5cGUuX2dldFBhdGhUeXBlID0gZnVuY3Rpb24ocGF0aCkge1xuICBjb25zdCBfdGhpcyA9IHRoaXM7XG4gIGNvbnN0IHBhdGhzY2hlbWEgPSBfdGhpcy5wYXRoKHBhdGgpO1xuXG4gIGlmIChwYXRoc2NoZW1hKSB7XG4gICAgcmV0dXJuICdyZWFsJztcbiAgfVxuXG4gIGZ1bmN0aW9uIHNlYXJjaChwYXJ0cywgc2NoZW1hKSB7XG4gICAgbGV0IHAgPSBwYXJ0cy5sZW5ndGggKyAxLFxuICAgICAgICBmb3VuZHNjaGVtYSxcbiAgICAgICAgdHJ5cGF0aDtcblxuICAgIHdoaWxlIChwLS0pIHtcbiAgICAgIHRyeXBhdGggPSBwYXJ0cy5zbGljZSgwLCBwKS5qb2luKCcuJyk7XG4gICAgICBmb3VuZHNjaGVtYSA9IHNjaGVtYS5wYXRoKHRyeXBhdGgpO1xuICAgICAgaWYgKGZvdW5kc2NoZW1hKSB7XG4gICAgICAgIGlmIChmb3VuZHNjaGVtYS5jYXN0ZXIpIHtcbiAgICAgICAgICAvLyBhcnJheSBvZiBNaXhlZD9cbiAgICAgICAgICBpZiAoZm91bmRzY2hlbWEuY2FzdGVyIGluc3RhbmNlb2YgTW9uZ29vc2VUeXBlcy5NaXhlZCkge1xuICAgICAgICAgICAgcmV0dXJuIHsgc2NoZW1hOiBmb3VuZHNjaGVtYSwgcGF0aFR5cGU6ICdtaXhlZCcgfTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBOb3cgdGhhdCB3ZSBmb3VuZCB0aGUgYXJyYXksIHdlIG5lZWQgdG8gY2hlY2sgaWYgdGhlcmVcbiAgICAgICAgICAvLyBhcmUgcmVtYWluaW5nIGRvY3VtZW50IHBhdGhzIHRvIGxvb2sgdXAgZm9yIGNhc3RpbmcuXG4gICAgICAgICAgLy8gQWxzbyB3ZSBuZWVkIHRvIGhhbmRsZSBhcnJheS4kLnBhdGggc2luY2Ugc2NoZW1hLnBhdGhcbiAgICAgICAgICAvLyBkb2Vzbid0IHdvcmsgZm9yIHRoYXQuXG4gICAgICAgICAgLy8gSWYgdGhlcmUgaXMgbm8gZm91bmRzY2hlbWEuc2NoZW1hIHdlIGFyZSBkZWFsaW5nIHdpdGhcbiAgICAgICAgICAvLyBhIHBhdGggbGlrZSBhcnJheS4kXG4gICAgICAgICAgaWYgKHAgIT09IHBhcnRzLmxlbmd0aCAmJiBmb3VuZHNjaGVtYS5zY2hlbWEpIHtcbiAgICAgICAgICAgIGlmIChwYXJ0c1twXSA9PT0gJyQnIHx8IGlzQXJyYXlGaWx0ZXIocGFydHNbcF0pKSB7XG4gICAgICAgICAgICAgIGlmIChwID09PSBwYXJ0cy5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgc2NoZW1hOiBmb3VuZHNjaGVtYSwgcGF0aFR5cGU6ICduZXN0ZWQnIH07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLy8gY29tbWVudHMuJC5jb21tZW50cy4kLnRpdGxlXG4gICAgICAgICAgICAgIHJldHVybiBzZWFyY2gocGFydHMuc2xpY2UocCArIDEpLCBmb3VuZHNjaGVtYS5zY2hlbWEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gdGhpcyBpcyB0aGUgbGFzdCBwYXRoIG9mIHRoZSBzZWxlY3RvclxuICAgICAgICAgICAgcmV0dXJuIHNlYXJjaChwYXJ0cy5zbGljZShwKSwgZm91bmRzY2hlbWEuc2NoZW1hKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHNjaGVtYTogZm91bmRzY2hlbWEsXG4gICAgICAgICAgICBwYXRoVHlwZTogZm91bmRzY2hlbWEuJGlzU2luZ2xlTmVzdGVkID8gJ25lc3RlZCcgOiAnYXJyYXknXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBzY2hlbWE6IGZvdW5kc2NoZW1hLCBwYXRoVHlwZTogJ3JlYWwnIH07XG4gICAgICB9IGVsc2UgaWYgKHAgPT09IHBhcnRzLmxlbmd0aCAmJiBzY2hlbWEubmVzdGVkW3RyeXBhdGhdKSB7XG4gICAgICAgIHJldHVybiB7IHNjaGVtYTogc2NoZW1hLCBwYXRoVHlwZTogJ25lc3RlZCcgfTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHsgc2NoZW1hOiBmb3VuZHNjaGVtYSB8fCBzY2hlbWEsIHBhdGhUeXBlOiAndW5kZWZpbmVkJyB9O1xuICB9XG5cbiAgLy8gbG9vayBmb3IgYXJyYXlzXG4gIHJldHVybiBzZWFyY2gocGF0aC5zcGxpdCgnLicpLCBfdGhpcyk7XG59O1xuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cbmZ1bmN0aW9uIGlzQXJyYXlGaWx0ZXIocGllY2UpIHtcbiAgcmV0dXJuIHBpZWNlLnN0YXJ0c1dpdGgoJyRbJykgJiYgcGllY2UuZW5kc1dpdGgoJ10nKTtcbn1cblxuLyoqXG4gKiBDYWxsZWQgYnkgYGNvbXBpbGUoKWAgX3JpZ2h0IGJlZm9yZV8gY29tcGlsaW5nLiBHb29kIGZvciBtYWtpbmcgYW55IGNoYW5nZXMgdG9cbiAqIHRoZSBzY2hlbWEgdGhhdCBzaG91bGQgcmVzcGVjdCBvcHRpb25zIHNldCBieSBwbHVnaW5zLCBsaWtlIGBpZGBcbiAqIEBtZXRob2QgX3ByZUNvbXBpbGVcbiAqIEBtZW1iZXJPZiBTY2hlbWFcbiAqIEBpbnN0YW5jZVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU2NoZW1hLnByb3RvdHlwZS5fcHJlQ29tcGlsZSA9IGZ1bmN0aW9uIF9wcmVDb21waWxlKCkge1xuICBpZEdldHRlcih0aGlzKTtcbn07XG5cbi8qIVxuICogTW9kdWxlIGV4cG9ydHMuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gU2NoZW1hO1xuXG4vLyByZXF1aXJlIGRvd24gaGVyZSBiZWNhdXNlIG9mIHJlZmVyZW5jZSBpc3N1ZXNcblxuLyoqXG4gKiBUaGUgdmFyaW91cyBidWlsdC1pbiBNb25nb29zZSBTY2hlbWEgVHlwZXMuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBjb25zdCBtb25nb29zZSA9IHJlcXVpcmUoJ21vbmdvb3NlJyk7XG4gKiAgICAgY29uc3QgT2JqZWN0SWQgPSBtb25nb29zZS5TY2hlbWEuVHlwZXMuT2JqZWN0SWQ7XG4gKlxuICogIyMjIyBUeXBlczpcbiAqXG4gKiAtIFtTdHJpbmddKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9zY2hlbWF0eXBlcy5odG1sI3N0cmluZ3MpXG4gKiAtIFtOdW1iZXJdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9zY2hlbWF0eXBlcy5odG1sI251bWJlcnMpXG4gKiAtIFtCb29sZWFuXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3Mvc2NoZW1hdHlwZXMuaHRtbCNib29sZWFucykgfCBCb29sXG4gKiAtIFtBcnJheV0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL3NjaGVtYXR5cGVzLmh0bWwjYXJyYXlzKVxuICogLSBbQnVmZmVyXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3Mvc2NoZW1hdHlwZXMuaHRtbCNidWZmZXJzKVxuICogLSBbRGF0ZV0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL3NjaGVtYXR5cGVzLmh0bWwjZGF0ZXMpXG4gKiAtIFtPYmplY3RJZF0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL3NjaGVtYXR5cGVzLmh0bWwjb2JqZWN0aWRzKSB8IE9pZFxuICogLSBbTWl4ZWRdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9zY2hlbWF0eXBlcy5odG1sI21peGVkKVxuICogLSBbVVVJRF0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL3NjaGVtYXR5cGVzLmh0bWwjdXVpZClcbiAqIC0gW0JpZ0ludF0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL3NjaGVtYXR5cGVzLmh0bWwjYmlnaW50KVxuICpcbiAqIFVzaW5nIHRoaXMgZXhwb3NlZCBhY2Nlc3MgdG8gdGhlIGBNaXhlZGAgU2NoZW1hVHlwZSwgd2UgY2FuIHVzZSB0aGVtIGluIG91ciBzY2hlbWEuXG4gKlxuICogICAgIGNvbnN0IE1peGVkID0gbW9uZ29vc2UuU2NoZW1hLlR5cGVzLk1peGVkO1xuICogICAgIG5ldyBtb25nb29zZS5TY2hlbWEoeyBfdXNlcjogTWl4ZWQgfSlcbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblNjaGVtYS5UeXBlcyA9IE1vbmdvb3NlVHlwZXMgPSByZXF1aXJlKCcuL3NjaGVtYS9pbmRleCcpO1xuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cbmV4cG9ydHMuT2JqZWN0SWQgPSBNb25nb29zZVR5cGVzLk9iamVjdElkO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../server/node_modules/mongoose/lib/schema.js\n");

/***/ }),

/***/ "../server/node_modules/mongoose/lib/schema/array.js":
/*!***********************************************************!*\
  !*** ../server/node_modules/mongoose/lib/schema/array.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\n/*!\n * Module dependencies.\n */\n\nconst $exists = __webpack_require__(/*! ./operators/exists */ \"../server/node_modules/mongoose/lib/schema/operators/exists.js\");\nconst $type = __webpack_require__(/*! ./operators/type */ \"../server/node_modules/mongoose/lib/schema/operators/type.js\");\nconst MongooseError = __webpack_require__(/*! ../error/mongooseError */ \"../server/node_modules/mongoose/lib/error/mongooseError.js\");\nconst SchemaArrayOptions = __webpack_require__(/*! ../options/schemaArrayOptions */ \"../server/node_modules/mongoose/lib/options/schemaArrayOptions.js\");\nconst SchemaType = __webpack_require__(/*! ../schemaType */ \"../server/node_modules/mongoose/lib/schemaType.js\");\nconst CastError = SchemaType.CastError;\nconst Mixed = __webpack_require__(/*! ./mixed */ \"../server/node_modules/mongoose/lib/schema/mixed.js\");\nconst arrayDepth = __webpack_require__(/*! ../helpers/arrayDepth */ \"../server/node_modules/mongoose/lib/helpers/arrayDepth.js\");\nconst cast = __webpack_require__(/*! ../cast */ \"../server/node_modules/mongoose/lib/cast.js\");\nconst clone = __webpack_require__(/*! ../helpers/clone */ \"../server/node_modules/mongoose/lib/helpers/clone.js\");\nconst isOperator = __webpack_require__(/*! ../helpers/query/isOperator */ \"../server/node_modules/mongoose/lib/helpers/query/isOperator.js\");\nconst util = __webpack_require__(/*! util */ \"util\");\nconst utils = __webpack_require__(/*! ../utils */ \"../server/node_modules/mongoose/lib/utils.js\");\nconst castToNumber = (__webpack_require__(/*! ./operators/helpers */ \"../server/node_modules/mongoose/lib/schema/operators/helpers.js\").castToNumber);\nconst geospatial = __webpack_require__(/*! ./operators/geospatial */ \"../server/node_modules/mongoose/lib/schema/operators/geospatial.js\");\nconst getDiscriminatorByValue = __webpack_require__(/*! ../helpers/discriminator/getDiscriminatorByValue */ \"../server/node_modules/mongoose/lib/helpers/discriminator/getDiscriminatorByValue.js\");\n\nlet MongooseArray;\nlet EmbeddedDoc;\n\nconst isNestedArraySymbol = Symbol('mongoose#isNestedArray');\nconst emptyOpts = Object.freeze({});\n\n/**\n * Array SchemaType constructor\n *\n * @param {String} key\n * @param {SchemaType} cast\n * @param {Object} options\n * @param {Object} schemaOptions\n * @inherits SchemaType\n * @api public\n */\n\nfunction SchemaArray(key, cast, options, schemaOptions) {\n  // lazy load\n  EmbeddedDoc || (EmbeddedDoc = (__webpack_require__(/*! ../types */ \"../server/node_modules/mongoose/lib/types/index.js\").Embedded));\n\n  let typeKey = 'type';\n  if (schemaOptions && schemaOptions.typeKey) {\n    typeKey = schemaOptions.typeKey;\n  }\n  this.schemaOptions = schemaOptions;\n\n  if (cast) {\n    let castOptions = {};\n\n    if (utils.isPOJO(cast)) {\n      if (cast[typeKey]) {\n        // support { type: Woot }\n        castOptions = clone(cast); // do not alter user arguments\n        delete castOptions[typeKey];\n        cast = cast[typeKey];\n      } else {\n        cast = Mixed;\n      }\n    }\n\n    if (options != null && options.ref != null && castOptions.ref == null) {\n      castOptions.ref = options.ref;\n    }\n\n    if (cast === Object) {\n      cast = Mixed;\n    }\n\n    // support { type: 'String' }\n    const name = typeof cast === 'string'\n      ? cast\n      : utils.getFunctionName(cast);\n\n    const Types = __webpack_require__(/*! ./index.js */ \"../server/node_modules/mongoose/lib/schema/index.js\");\n    const caster = Types.hasOwnProperty(name) ? Types[name] : cast;\n\n    this.casterConstructor = caster;\n\n    if (this.casterConstructor instanceof SchemaArray) {\n      this.casterConstructor[isNestedArraySymbol] = true;\n    }\n\n    if (typeof caster === 'function' &&\n        !caster.$isArraySubdocument &&\n        !caster.$isSchemaMap) {\n      const path = this.caster instanceof EmbeddedDoc ? null : key;\n      this.caster = new caster(path, castOptions);\n    } else {\n      this.caster = caster;\n      if (!(this.caster instanceof EmbeddedDoc)) {\n        this.caster.path = key;\n      }\n    }\n\n    this.$embeddedSchemaType = this.caster;\n  }\n\n  this.$isMongooseArray = true;\n\n  SchemaType.call(this, key, options, 'Array');\n\n  let defaultArr;\n  let fn;\n\n  if (this.defaultValue != null) {\n    defaultArr = this.defaultValue;\n    fn = typeof defaultArr === 'function';\n  }\n\n  if (!('defaultValue' in this) || this.defaultValue !== void 0) {\n    const defaultFn = function() {\n      // Leave it up to `cast()` to convert the array\n      return fn\n        ? defaultArr.call(this)\n        : defaultArr != null\n          ? [].concat(defaultArr)\n          : [];\n    };\n    defaultFn.$runBeforeSetters = !fn;\n    this.default(defaultFn);\n  }\n}\n\n/**\n * This schema type's name, to defend against minifiers that mangle\n * function names.\n *\n * @api public\n */\nSchemaArray.schemaName = 'Array';\n\n\n/**\n * Options for all arrays.\n *\n * - `castNonArrays`: `true` by default. If `false`, Mongoose will throw a CastError when a value isn't an array. If `true`, Mongoose will wrap the provided value in an array before casting.\n *\n * @static\n * @api public\n */\n\nSchemaArray.options = { castNonArrays: true };\n\n/*!\n * ignore\n */\n\nSchemaArray.defaultOptions = {};\n\n/**\n * Sets a default option for all Array instances.\n *\n * #### Example:\n *\n *     // Make all Array instances have `required` of true by default.\n *     mongoose.Schema.Array.set('required', true);\n *\n *     const User = mongoose.model('User', new Schema({ test: Array }));\n *     new User({ }).validateSync().errors.test.message; // Path `test` is required.\n *\n * @param {String} option The option you'd like to set the value for\n * @param {Any} value value for option\n * @return {undefined}\n * @function set\n * @api public\n */\nSchemaArray.set = SchemaType.set;\n\nSchemaArray.setters = [];\n\n/**\n * Attaches a getter for all Array instances\n *\n * @param {Function} getter\n * @return {this}\n * @function get\n * @static\n * @api public\n */\n\nSchemaArray.get = SchemaType.get;\n\n/*!\n * Inherits from SchemaType.\n */\nSchemaArray.prototype = Object.create(SchemaType.prototype);\nSchemaArray.prototype.constructor = SchemaArray;\nSchemaArray.prototype.OptionsConstructor = SchemaArrayOptions;\n\n/*!\n * ignore\n */\n\nSchemaArray._checkRequired = SchemaType.prototype.checkRequired;\n\n/**\n * Override the function the required validator uses to check whether an array\n * passes the `required` check.\n *\n * #### Example:\n *\n *     // Require non-empty array to pass `required` check\n *     mongoose.Schema.Types.Array.checkRequired(v => Array.isArray(v) && v.length);\n *\n *     const M = mongoose.model({ arr: { type: Array, required: true } });\n *     new M({ arr: [] }).validateSync(); // `null`, validation fails!\n *\n * @param {Function} fn\n * @return {Function}\n * @function checkRequired\n * @api public\n */\n\nSchemaArray.checkRequired = SchemaType.checkRequired;\n\n/**\n * Check if the given value satisfies the `required` validator.\n *\n * @param {Any} value\n * @param {Document} doc\n * @return {Boolean}\n * @api public\n */\n\nSchemaArray.prototype.checkRequired = function checkRequired(value, doc) {\n  if (typeof value === 'object' && SchemaType._isRef(this, value, doc, true)) {\n    return !!value;\n  }\n\n  // `require('util').inherits()` does **not** copy static properties, and\n  // plugins like mongoose-float use `inherits()` for pre-ES6.\n  const _checkRequired = typeof this.constructor.checkRequired === 'function' ?\n    this.constructor.checkRequired() :\n    SchemaArray.checkRequired();\n\n  return _checkRequired(value);\n};\n\n/**\n * Adds an enum validator if this is an array of strings or numbers. Equivalent to\n * `SchemaString.prototype.enum()` or `SchemaNumber.prototype.enum()`\n *\n * @param {...String|Object} [args] enumeration values\n * @return {SchemaArray} this\n */\n\nSchemaArray.prototype.enum = function() {\n  let arr = this;\n  while (true) {\n    const instance = arr &&\n    arr.caster &&\n    arr.caster.instance;\n    if (instance === 'Array') {\n      arr = arr.caster;\n      continue;\n    }\n    if (instance !== 'String' && instance !== 'Number') {\n      throw new Error('`enum` can only be set on an array of strings or numbers ' +\n        ', not ' + instance);\n    }\n    break;\n  }\n\n  let enumArray = arguments;\n  if (!Array.isArray(arguments) && utils.isObject(arguments)) {\n    enumArray = utils.object.vals(enumArray);\n  }\n\n  arr.caster.enum.apply(arr.caster, enumArray);\n  return this;\n};\n\n/**\n * Overrides the getters application for the population special-case\n *\n * @param {Object} value\n * @param {Object} scope\n * @api private\n */\n\nSchemaArray.prototype.applyGetters = function(value, scope) {\n  if (scope != null && scope.$__ != null && scope.$populated(this.path)) {\n    // means the object id was populated\n    return value;\n  }\n\n  const ret = SchemaType.prototype.applyGetters.call(this, value, scope);\n  return ret;\n};\n\nSchemaArray.prototype._applySetters = function(value, scope, init, priorVal) {\n  if (this.casterConstructor.$isMongooseArray &&\n      SchemaArray.options.castNonArrays &&\n      !this[isNestedArraySymbol]) {\n    // Check nesting levels and wrap in array if necessary\n    let depth = 0;\n    let arr = this;\n    while (arr != null &&\n      arr.$isMongooseArray &&\n      !arr.$isMongooseDocumentArray) {\n      ++depth;\n      arr = arr.casterConstructor;\n    }\n\n    // No need to wrap empty arrays\n    if (value != null && value.length !== 0) {\n      const valueDepth = arrayDepth(value);\n      if (valueDepth.min === valueDepth.max && valueDepth.max < depth && valueDepth.containsNonArrayItem) {\n        for (let i = valueDepth.max; i < depth; ++i) {\n          value = [value];\n        }\n      }\n    }\n  }\n\n  return SchemaType.prototype._applySetters.call(this, value, scope, init, priorVal);\n};\n\n/**\n * Casts values for set().\n *\n * @param {Object} value\n * @param {Document} doc document that triggers the casting\n * @param {Boolean} init whether this is an initialization cast\n * @api private\n */\n\nSchemaArray.prototype.cast = function(value, doc, init, prev, options) {\n  // lazy load\n  MongooseArray || (MongooseArray = (__webpack_require__(/*! ../types */ \"../server/node_modules/mongoose/lib/types/index.js\").Array));\n\n  let i;\n  let l;\n\n  if (Array.isArray(value)) {\n    const len = value.length;\n    if (!len && doc) {\n      const indexes = doc.schema.indexedPaths();\n\n      const arrayPath = this.path;\n      for (i = 0, l = indexes.length; i < l; ++i) {\n        const pathIndex = indexes[i][0][arrayPath];\n        if (pathIndex === '2dsphere' || pathIndex === '2d') {\n          return;\n        }\n      }\n\n      // Special case: if this index is on the parent of what looks like\n      // GeoJSON, skip setting the default to empty array re: #1668, #3233\n      const arrayGeojsonPath = this.path.endsWith('.coordinates') ?\n        this.path.substring(0, this.path.lastIndexOf('.')) : null;\n      if (arrayGeojsonPath != null) {\n        for (i = 0, l = indexes.length; i < l; ++i) {\n          const pathIndex = indexes[i][0][arrayGeojsonPath];\n          if (pathIndex === '2dsphere') {\n            return;\n          }\n        }\n      }\n    }\n\n    options = options || emptyOpts;\n\n    let rawValue = utils.isMongooseArray(value) ? value.__array : value;\n    let path = options.path || this.path;\n    if (options.arrayPathIndex != null) {\n      path += '.' + options.arrayPathIndex;\n    }\n    value = MongooseArray(rawValue, path, doc, this);\n    rawValue = value.__array;\n\n    if (init && doc != null && doc.$__ != null && doc.$populated(this.path)) {\n      return value;\n    }\n\n    const caster = this.caster;\n    const isMongooseArray = caster.$isMongooseArray;\n    if (caster && this.casterConstructor !== Mixed) {\n      try {\n        const len = rawValue.length;\n        for (i = 0; i < len; i++) {\n          const opts = {};\n          // Perf: creating `arrayPath` is expensive for large arrays.\n          // We only need `arrayPath` if this is a nested array, so\n          // skip if possible.\n          if (isMongooseArray) {\n            if (options.arrayPath != null) {\n              opts.arrayPathIndex = i;\n            } else if (caster._arrayParentPath != null) {\n              opts.arrayPathIndex = i;\n            }\n          }\n          rawValue[i] = caster.applySetters(rawValue[i], doc, init, void 0, opts);\n        }\n      } catch (e) {\n        // rethrow\n        throw new CastError('[' + e.kind + ']', util.inspect(value), this.path + '.' + i, e, this);\n      }\n    }\n\n    return value;\n  }\n\n  const castNonArraysOption = this.options.castNonArrays != null ? this.options.castNonArrays : SchemaArray.options.castNonArrays;\n  if (init || castNonArraysOption) {\n    // gh-2442: if we're loading this from the db and its not an array, mark\n    // the whole array as modified.\n    if (!!doc && !!init) {\n      doc.markModified(this.path);\n    }\n    return this.cast([value], doc, init);\n  }\n\n  throw new CastError('Array', util.inspect(value), this.path, null, this);\n};\n\n/*!\n * ignore\n */\n\nSchemaArray.prototype._castForPopulate = function _castForPopulate(value, doc) {\n  // lazy load\n  MongooseArray || (MongooseArray = (__webpack_require__(/*! ../types */ \"../server/node_modules/mongoose/lib/types/index.js\").Array));\n\n  if (Array.isArray(value)) {\n    let i;\n    const rawValue = value.__array ? value.__array : value;\n    const len = rawValue.length;\n\n    const caster = this.caster;\n    if (caster && this.casterConstructor !== Mixed) {\n      try {\n        for (i = 0; i < len; i++) {\n          const opts = {};\n          // Perf: creating `arrayPath` is expensive for large arrays.\n          // We only need `arrayPath` if this is a nested array, so\n          // skip if possible.\n          if (caster.$isMongooseArray && caster._arrayParentPath != null) {\n            opts.arrayPathIndex = i;\n          }\n\n          rawValue[i] = caster.cast(rawValue[i], doc, false, void 0, opts);\n        }\n      } catch (e) {\n        // rethrow\n        throw new CastError('[' + e.kind + ']', util.inspect(value), this.path + '.' + i, e, this);\n      }\n    }\n\n    return value;\n  }\n\n  throw new CastError('Array', util.inspect(value), this.path, null, this);\n};\n\nSchemaArray.prototype.$toObject = SchemaArray.prototype.toObject;\n\n/*!\n * ignore\n */\n\nSchemaArray.prototype.discriminator = function(...args) {\n  let arr = this;\n  while (arr.$isMongooseArray && !arr.$isMongooseDocumentArray) {\n    arr = arr.casterConstructor;\n    if (arr == null || typeof arr === 'function') {\n      throw new MongooseError('You can only add an embedded discriminator on ' +\n        'a document array, ' + this.path + ' is a plain array');\n    }\n  }\n  return arr.discriminator(...args);\n};\n\n/*!\n * ignore\n */\n\nSchemaArray.prototype.clone = function() {\n  const options = Object.assign({}, this.options);\n  const schematype = new this.constructor(this.path, this.caster, options, this.schemaOptions);\n  schematype.validators = this.validators.slice();\n  if (this.requiredValidator !== undefined) {\n    schematype.requiredValidator = this.requiredValidator;\n  }\n  return schematype;\n};\n\nSchemaArray.prototype._castForQuery = function(val, context) {\n  let Constructor = this.casterConstructor;\n\n  if (val &&\n      Constructor.discriminators &&\n      Constructor.schema &&\n      Constructor.schema.options &&\n      Constructor.schema.options.discriminatorKey) {\n    if (typeof val[Constructor.schema.options.discriminatorKey] === 'string' &&\n        Constructor.discriminators[val[Constructor.schema.options.discriminatorKey]]) {\n      Constructor = Constructor.discriminators[val[Constructor.schema.options.discriminatorKey]];\n    } else {\n      const constructorByValue = getDiscriminatorByValue(Constructor.discriminators, val[Constructor.schema.options.discriminatorKey]);\n      if (constructorByValue) {\n        Constructor = constructorByValue;\n      }\n    }\n  }\n\n  const proto = this.casterConstructor.prototype;\n  const protoCastForQuery = proto && proto.castForQuery;\n  const protoCast = proto && proto.cast;\n  const constructorCastForQuery = Constructor.castForQuery;\n  const caster = this.caster;\n\n  if (Array.isArray(val)) {\n    this.setters.reverse().forEach(setter => {\n      val = setter.call(this, val, this);\n    });\n    val = val.map(function(v) {\n      if (utils.isObject(v) && v.$elemMatch) {\n        return v;\n      }\n      if (protoCastForQuery) {\n        v = protoCastForQuery.call(caster, null, v, context);\n        return v;\n      } else if (protoCast) {\n        v = protoCast.call(caster, v);\n        return v;\n      } else if (constructorCastForQuery) {\n        v = constructorCastForQuery.call(caster, null, v, context);\n        return v;\n      }\n      if (v != null) {\n        v = new Constructor(v);\n        return v;\n      }\n      return v;\n    });\n  } else if (protoCastForQuery) {\n    val = protoCastForQuery.call(caster, null, val, context);\n  } else if (protoCast) {\n    val = protoCast.call(caster, val);\n  } else if (constructorCastForQuery) {\n    val = constructorCastForQuery.call(caster, null, val, context);\n  } else if (val != null) {\n    val = new Constructor(val);\n  }\n\n  return val;\n};\n\n/**\n * Casts values for queries.\n *\n * @param {String} $conditional\n * @param {any} [value]\n * @api private\n */\n\nSchemaArray.prototype.castForQuery = function($conditional, val, context) {\n  let handler;\n\n  if ($conditional != null) {\n    handler = this.$conditionalHandlers[$conditional];\n\n    if (!handler) {\n      throw new Error('Can\\'t use ' + $conditional + ' with Array.');\n    }\n\n    return handler.call(this, val, context);\n  } else {\n    return this._castForQuery(val, context);\n  }\n};\n\nfunction cast$all(val, context) {\n  if (!Array.isArray(val)) {\n    val = [val];\n  }\n\n  val = val.map((v) => {\n    if (!utils.isObject(v)) {\n      return v;\n    }\n    if (v.$elemMatch != null) {\n      return { $elemMatch: cast(this.casterConstructor.schema, v.$elemMatch, null, this && this.$$context) };\n    }\n\n    const o = {};\n    o[this.path] = v;\n    return cast(this.casterConstructor.schema, o, null, this && this.$$context)[this.path];\n  }, this);\n\n  return this.castForQuery(null, val, context);\n}\n\nfunction cast$elemMatch(val, context) {\n  const keys = Object.keys(val);\n  const numKeys = keys.length;\n  for (let i = 0; i < numKeys; ++i) {\n    const key = keys[i];\n    const value = val[key];\n    if (isOperator(key) && value != null) {\n      val[key] = this.castForQuery(key, value, context);\n    }\n  }\n\n  // Is this an embedded discriminator and is the discriminator key set?\n  // If so, use the discriminator schema. See gh-7449\n  const discriminatorKey = this &&\n    this.casterConstructor &&\n    this.casterConstructor.schema &&\n    this.casterConstructor.schema.options &&\n    this.casterConstructor.schema.options.discriminatorKey;\n  const discriminators = this &&\n  this.casterConstructor &&\n  this.casterConstructor.schema &&\n  this.casterConstructor.schema.discriminators || {};\n  if (discriminatorKey != null &&\n      val[discriminatorKey] != null &&\n      discriminators[val[discriminatorKey]] != null) {\n    return cast(discriminators[val[discriminatorKey]], val, null, this && this.$$context);\n  }\n  const schema = this.casterConstructor.schema ?? context.schema;\n  return cast(schema, val, null, this && this.$$context);\n}\n\nconst handle = SchemaArray.prototype.$conditionalHandlers = {};\n\nhandle.$all = cast$all;\nhandle.$options = String;\nhandle.$elemMatch = cast$elemMatch;\nhandle.$geoIntersects = geospatial.cast$geoIntersects;\nhandle.$or = createLogicalQueryOperatorHandler('$or');\nhandle.$and = createLogicalQueryOperatorHandler('$and');\nhandle.$nor = createLogicalQueryOperatorHandler('$nor');\n\nfunction createLogicalQueryOperatorHandler(op) {\n  return function logicalQueryOperatorHandler(val, context) {\n    if (!Array.isArray(val)) {\n      throw new TypeError('conditional ' + op + ' requires an array');\n    }\n\n    const ret = [];\n    for (const obj of val) {\n      ret.push(cast(this.casterConstructor.schema ?? context.schema, obj, null, this && this.$$context));\n    }\n\n    return ret;\n  };\n}\n\nhandle.$near =\nhandle.$nearSphere = geospatial.cast$near;\n\nhandle.$within =\nhandle.$geoWithin = geospatial.cast$within;\n\nhandle.$size =\nhandle.$minDistance =\nhandle.$maxDistance = castToNumber;\n\nhandle.$exists = $exists;\nhandle.$type = $type;\n\nhandle.$eq =\nhandle.$gt =\nhandle.$gte =\nhandle.$lt =\nhandle.$lte =\nhandle.$not =\nhandle.$regex =\nhandle.$ne = SchemaArray.prototype._castForQuery;\n\n// `$in` is special because you can also include an empty array in the query\n// like `$in: [1, []]`, see gh-5913\nhandle.$nin = SchemaType.prototype.$conditionalHandlers.$nin;\nhandle.$in = SchemaType.prototype.$conditionalHandlers.$in;\n\n/*!\n * Module exports.\n */\n\nmodule.exports = SchemaArray;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvc2NoZW1hL2FycmF5LmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0E7QUFDQTs7QUFFQSxnQkFBZ0IsbUJBQU8sQ0FBQywwRkFBb0I7QUFDNUMsY0FBYyxtQkFBTyxDQUFDLHNGQUFrQjtBQUN4QyxzQkFBc0IsbUJBQU8sQ0FBQywwRkFBd0I7QUFDdEQsMkJBQTJCLG1CQUFPLENBQUMsd0dBQStCO0FBQ2xFLG1CQUFtQixtQkFBTyxDQUFDLHdFQUFlO0FBQzFDO0FBQ0EsY0FBYyxtQkFBTyxDQUFDLG9FQUFTO0FBQy9CLG1CQUFtQixtQkFBTyxDQUFDLHdGQUF1QjtBQUNsRCxhQUFhLG1CQUFPLENBQUMsNERBQVM7QUFDOUIsY0FBYyxtQkFBTyxDQUFDLDhFQUFrQjtBQUN4QyxtQkFBbUIsbUJBQU8sQ0FBQyxvR0FBNkI7QUFDeEQsYUFBYSxtQkFBTyxDQUFDLGtCQUFNO0FBQzNCLGNBQWMsbUJBQU8sQ0FBQyw4REFBVTtBQUNoQyxxQkFBcUIsZ0lBQTJDO0FBQ2hFLG1CQUFtQixtQkFBTyxDQUFDLGtHQUF3QjtBQUNuRCxnQ0FBZ0MsbUJBQU8sQ0FBQyw4SUFBa0Q7O0FBRTFGO0FBQ0E7O0FBRUE7QUFDQSxrQ0FBa0M7O0FBRWxDO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFlBQVk7QUFDdkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdDQUFnQyxvR0FBNEI7O0FBRTVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLG1DQUFtQztBQUNuQztBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLG1CQUFPLENBQUMs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OztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsYUFBYTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2xpZW50Ly4uL3NlcnZlci9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL3NjaGVtYS9hcnJheS5qcz84MDE1Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuLyohXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbmNvbnN0ICRleGlzdHMgPSByZXF1aXJlKCcuL29wZXJhdG9ycy9leGlzdHMnKTtcbmNvbnN0ICR0eXBlID0gcmVxdWlyZSgnLi9vcGVyYXRvcnMvdHlwZScpO1xuY29uc3QgTW9uZ29vc2VFcnJvciA9IHJlcXVpcmUoJy4uL2Vycm9yL21vbmdvb3NlRXJyb3InKTtcbmNvbnN0IFNjaGVtYUFycmF5T3B0aW9ucyA9IHJlcXVpcmUoJy4uL29wdGlvbnMvc2NoZW1hQXJyYXlPcHRpb25zJyk7XG5jb25zdCBTY2hlbWFUeXBlID0gcmVxdWlyZSgnLi4vc2NoZW1hVHlwZScpO1xuY29uc3QgQ2FzdEVycm9yID0gU2NoZW1hVHlwZS5DYXN0RXJyb3I7XG5jb25zdCBNaXhlZCA9IHJlcXVpcmUoJy4vbWl4ZWQnKTtcbmNvbnN0IGFycmF5RGVwdGggPSByZXF1aXJlKCcuLi9oZWxwZXJzL2FycmF5RGVwdGgnKTtcbmNvbnN0IGNhc3QgPSByZXF1aXJlKCcuLi9jYXN0Jyk7XG5jb25zdCBjbG9uZSA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvY2xvbmUnKTtcbmNvbnN0IGlzT3BlcmF0b3IgPSByZXF1aXJlKCcuLi9oZWxwZXJzL3F1ZXJ5L2lzT3BlcmF0b3InKTtcbmNvbnN0IHV0aWwgPSByZXF1aXJlKCd1dGlsJyk7XG5jb25zdCB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzJyk7XG5jb25zdCBjYXN0VG9OdW1iZXIgPSByZXF1aXJlKCcuL29wZXJhdG9ycy9oZWxwZXJzJykuY2FzdFRvTnVtYmVyO1xuY29uc3QgZ2Vvc3BhdGlhbCA9IHJlcXVpcmUoJy4vb3BlcmF0b3JzL2dlb3NwYXRpYWwnKTtcbmNvbnN0IGdldERpc2NyaW1pbmF0b3JCeVZhbHVlID0gcmVxdWlyZSgnLi4vaGVscGVycy9kaXNjcmltaW5hdG9yL2dldERpc2NyaW1pbmF0b3JCeVZhbHVlJyk7XG5cbmxldCBNb25nb29zZUFycmF5O1xubGV0IEVtYmVkZGVkRG9jO1xuXG5jb25zdCBpc05lc3RlZEFycmF5U3ltYm9sID0gU3ltYm9sKCdtb25nb29zZSNpc05lc3RlZEFycmF5Jyk7XG5jb25zdCBlbXB0eU9wdHMgPSBPYmplY3QuZnJlZXplKHt9KTtcblxuLyoqXG4gKiBBcnJheSBTY2hlbWFUeXBlIGNvbnN0cnVjdG9yXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGtleVxuICogQHBhcmFtIHtTY2hlbWFUeXBlfSBjYXN0XG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQHBhcmFtIHtPYmplY3R9IHNjaGVtYU9wdGlvbnNcbiAqIEBpbmhlcml0cyBTY2hlbWFUeXBlXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIFNjaGVtYUFycmF5KGtleSwgY2FzdCwgb3B0aW9ucywgc2NoZW1hT3B0aW9ucykge1xuICAvLyBsYXp5IGxvYWRcbiAgRW1iZWRkZWREb2MgfHwgKEVtYmVkZGVkRG9jID0gcmVxdWlyZSgnLi4vdHlwZXMnKS5FbWJlZGRlZCk7XG5cbiAgbGV0IHR5cGVLZXkgPSAndHlwZSc7XG4gIGlmIChzY2hlbWFPcHRpb25zICYmIHNjaGVtYU9wdGlvbnMudHlwZUtleSkge1xuICAgIHR5cGVLZXkgPSBzY2hlbWFPcHRpb25zLnR5cGVLZXk7XG4gIH1cbiAgdGhpcy5zY2hlbWFPcHRpb25zID0gc2NoZW1hT3B0aW9ucztcblxuICBpZiAoY2FzdCkge1xuICAgIGxldCBjYXN0T3B0aW9ucyA9IHt9O1xuXG4gICAgaWYgKHV0aWxzLmlzUE9KTyhjYXN0KSkge1xuICAgICAgaWYgKGNhc3RbdHlwZUtleV0pIHtcbiAgICAgICAgLy8gc3VwcG9ydCB7IHR5cGU6IFdvb3QgfVxuICAgICAgICBjYXN0T3B0aW9ucyA9IGNsb25lKGNhc3QpOyAvLyBkbyBub3QgYWx0ZXIgdXNlciBhcmd1bWVudHNcbiAgICAgICAgZGVsZXRlIGNhc3RPcHRpb25zW3R5cGVLZXldO1xuICAgICAgICBjYXN0ID0gY2FzdFt0eXBlS2V5XTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNhc3QgPSBNaXhlZDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucyAhPSBudWxsICYmIG9wdGlvbnMucmVmICE9IG51bGwgJiYgY2FzdE9wdGlvbnMucmVmID09IG51bGwpIHtcbiAgICAgIGNhc3RPcHRpb25zLnJlZiA9IG9wdGlvbnMucmVmO1xuICAgIH1cblxuICAgIGlmIChjYXN0ID09PSBPYmplY3QpIHtcbiAgICAgIGNhc3QgPSBNaXhlZDtcbiAgICB9XG5cbiAgICAvLyBzdXBwb3J0IHsgdHlwZTogJ1N0cmluZycgfVxuICAgIGNvbnN0IG5hbWUgPSB0eXBlb2YgY2FzdCA9PT0gJ3N0cmluZydcbiAgICAgID8gY2FzdFxuICAgICAgOiB1dGlscy5nZXRGdW5jdGlvbk5hbWUoY2FzdCk7XG5cbiAgICBjb25zdCBUeXBlcyA9IHJlcXVpcmUoJy4vaW5kZXguanMnKTtcbiAgICBjb25zdCBjYXN0ZXIgPSBUeXBlcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSA/IFR5cGVzW25hbWVdIDogY2FzdDtcblxuICAgIHRoaXMuY2FzdGVyQ29uc3RydWN0b3IgPSBjYXN0ZXI7XG5cbiAgICBpZiAodGhpcy5jYXN0ZXJDb25zdHJ1Y3RvciBpbnN0YW5jZW9mIFNjaGVtYUFycmF5KSB7XG4gICAgICB0aGlzLmNhc3RlckNvbnN0cnVjdG9yW2lzTmVzdGVkQXJyYXlTeW1ib2xdID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGNhc3RlciA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgICAgICAhY2FzdGVyLiRpc0FycmF5U3ViZG9jdW1lbnQgJiZcbiAgICAgICAgIWNhc3Rlci4kaXNTY2hlbWFNYXApIHtcbiAgICAgIGNvbnN0IHBhdGggPSB0aGlzLmNhc3RlciBpbnN0YW5jZW9mIEVtYmVkZGVkRG9jID8gbnVsbCA6IGtleTtcbiAgICAgIHRoaXMuY2FzdGVyID0gbmV3IGNhc3RlcihwYXRoLCBjYXN0T3B0aW9ucyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuY2FzdGVyID0gY2FzdGVyO1xuICAgICAgaWYgKCEodGhpcy5jYXN0ZXIgaW5zdGFuY2VvZiBFbWJlZGRlZERvYykpIHtcbiAgICAgICAgdGhpcy5jYXN0ZXIucGF0aCA9IGtleTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLiRlbWJlZGRlZFNjaGVtYVR5cGUgPSB0aGlzLmNhc3RlcjtcbiAgfVxuXG4gIHRoaXMuJGlzTW9uZ29vc2VBcnJheSA9IHRydWU7XG5cbiAgU2NoZW1hVHlwZS5jYWxsKHRoaXMsIGtleSwgb3B0aW9ucywgJ0FycmF5Jyk7XG5cbiAgbGV0IGRlZmF1bHRBcnI7XG4gIGxldCBmbjtcblxuICBpZiAodGhpcy5kZWZhdWx0VmFsdWUgIT0gbnVsbCkge1xuICAgIGRlZmF1bHRBcnIgPSB0aGlzLmRlZmF1bHRWYWx1ZTtcbiAgICBmbiA9IHR5cGVvZiBkZWZhdWx0QXJyID09PSAnZnVuY3Rpb24nO1xuICB9XG5cbiAgaWYgKCEoJ2RlZmF1bHRWYWx1ZScgaW4gdGhpcykgfHwgdGhpcy5kZWZhdWx0VmFsdWUgIT09IHZvaWQgMCkge1xuICAgIGNvbnN0IGRlZmF1bHRGbiA9IGZ1bmN0aW9uKCkge1xuICAgICAgLy8gTGVhdmUgaXQgdXAgdG8gYGNhc3QoKWAgdG8gY29udmVydCB0aGUgYXJyYXlcbiAgICAgIHJldHVybiBmblxuICAgICAgICA/IGRlZmF1bHRBcnIuY2FsbCh0aGlzKVxuICAgICAgICA6IGRlZmF1bHRBcnIgIT0gbnVsbFxuICAgICAgICAgID8gW10uY29uY2F0KGRlZmF1bHRBcnIpXG4gICAgICAgICAgOiBbXTtcbiAgICB9O1xuICAgIGRlZmF1bHRGbi4kcnVuQmVmb3JlU2V0dGVycyA9ICFmbjtcbiAgICB0aGlzLmRlZmF1bHQoZGVmYXVsdEZuKTtcbiAgfVxufVxuXG4vKipcbiAqIFRoaXMgc2NoZW1hIHR5cGUncyBuYW1lLCB0byBkZWZlbmQgYWdhaW5zdCBtaW5pZmllcnMgdGhhdCBtYW5nbGVcbiAqIGZ1bmN0aW9uIG5hbWVzLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblNjaGVtYUFycmF5LnNjaGVtYU5hbWUgPSAnQXJyYXknO1xuXG5cbi8qKlxuICogT3B0aW9ucyBmb3IgYWxsIGFycmF5cy5cbiAqXG4gKiAtIGBjYXN0Tm9uQXJyYXlzYDogYHRydWVgIGJ5IGRlZmF1bHQuIElmIGBmYWxzZWAsIE1vbmdvb3NlIHdpbGwgdGhyb3cgYSBDYXN0RXJyb3Igd2hlbiBhIHZhbHVlIGlzbid0IGFuIGFycmF5LiBJZiBgdHJ1ZWAsIE1vbmdvb3NlIHdpbGwgd3JhcCB0aGUgcHJvdmlkZWQgdmFsdWUgaW4gYW4gYXJyYXkgYmVmb3JlIGNhc3RpbmcuXG4gKlxuICogQHN0YXRpY1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5TY2hlbWFBcnJheS5vcHRpb25zID0geyBjYXN0Tm9uQXJyYXlzOiB0cnVlIH07XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxuU2NoZW1hQXJyYXkuZGVmYXVsdE9wdGlvbnMgPSB7fTtcblxuLyoqXG4gKiBTZXRzIGEgZGVmYXVsdCBvcHRpb24gZm9yIGFsbCBBcnJheSBpbnN0YW5jZXMuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICAvLyBNYWtlIGFsbCBBcnJheSBpbnN0YW5jZXMgaGF2ZSBgcmVxdWlyZWRgIG9mIHRydWUgYnkgZGVmYXVsdC5cbiAqICAgICBtb25nb29zZS5TY2hlbWEuQXJyYXkuc2V0KCdyZXF1aXJlZCcsIHRydWUpO1xuICpcbiAqICAgICBjb25zdCBVc2VyID0gbW9uZ29vc2UubW9kZWwoJ1VzZXInLCBuZXcgU2NoZW1hKHsgdGVzdDogQXJyYXkgfSkpO1xuICogICAgIG5ldyBVc2VyKHsgfSkudmFsaWRhdGVTeW5jKCkuZXJyb3JzLnRlc3QubWVzc2FnZTsgLy8gUGF0aCBgdGVzdGAgaXMgcmVxdWlyZWQuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG9wdGlvbiBUaGUgb3B0aW9uIHlvdSdkIGxpa2UgdG8gc2V0IHRoZSB2YWx1ZSBmb3JcbiAqIEBwYXJhbSB7QW55fSB2YWx1ZSB2YWx1ZSBmb3Igb3B0aW9uXG4gKiBAcmV0dXJuIHt1bmRlZmluZWR9XG4gKiBAZnVuY3Rpb24gc2V0XG4gKiBAYXBpIHB1YmxpY1xuICovXG5TY2hlbWFBcnJheS5zZXQgPSBTY2hlbWFUeXBlLnNldDtcblxuU2NoZW1hQXJyYXkuc2V0dGVycyA9IFtdO1xuXG4vKipcbiAqIEF0dGFjaGVzIGEgZ2V0dGVyIGZvciBhbGwgQXJyYXkgaW5zdGFuY2VzXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZ2V0dGVyXG4gKiBAcmV0dXJuIHt0aGlzfVxuICogQGZ1bmN0aW9uIGdldFxuICogQHN0YXRpY1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5TY2hlbWFBcnJheS5nZXQgPSBTY2hlbWFUeXBlLmdldDtcblxuLyohXG4gKiBJbmhlcml0cyBmcm9tIFNjaGVtYVR5cGUuXG4gKi9cblNjaGVtYUFycmF5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoU2NoZW1hVHlwZS5wcm90b3R5cGUpO1xuU2NoZW1hQXJyYXkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gU2NoZW1hQXJyYXk7XG5TY2hlbWFBcnJheS5wcm90b3R5cGUuT3B0aW9uc0NvbnN0cnVjdG9yID0gU2NoZW1hQXJyYXlPcHRpb25zO1xuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cblNjaGVtYUFycmF5Ll9jaGVja1JlcXVpcmVkID0gU2NoZW1hVHlwZS5wcm90b3R5cGUuY2hlY2tSZXF1aXJlZDtcblxuLyoqXG4gKiBPdmVycmlkZSB0aGUgZnVuY3Rpb24gdGhlIHJlcXVpcmVkIHZhbGlkYXRvciB1c2VzIHRvIGNoZWNrIHdoZXRoZXIgYW4gYXJyYXlcbiAqIHBhc3NlcyB0aGUgYHJlcXVpcmVkYCBjaGVjay5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIC8vIFJlcXVpcmUgbm9uLWVtcHR5IGFycmF5IHRvIHBhc3MgYHJlcXVpcmVkYCBjaGVja1xuICogICAgIG1vbmdvb3NlLlNjaGVtYS5UeXBlcy5BcnJheS5jaGVja1JlcXVpcmVkKHYgPT4gQXJyYXkuaXNBcnJheSh2KSAmJiB2Lmxlbmd0aCk7XG4gKlxuICogICAgIGNvbnN0IE0gPSBtb25nb29zZS5tb2RlbCh7IGFycjogeyB0eXBlOiBBcnJheSwgcmVxdWlyZWQ6IHRydWUgfSB9KTtcbiAqICAgICBuZXcgTSh7IGFycjogW10gfSkudmFsaWRhdGVTeW5jKCk7IC8vIGBudWxsYCwgdmFsaWRhdGlvbiBmYWlscyFcbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICogQHJldHVybiB7RnVuY3Rpb259XG4gKiBAZnVuY3Rpb24gY2hlY2tSZXF1aXJlZFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5TY2hlbWFBcnJheS5jaGVja1JlcXVpcmVkID0gU2NoZW1hVHlwZS5jaGVja1JlcXVpcmVkO1xuXG4vKipcbiAqIENoZWNrIGlmIHRoZSBnaXZlbiB2YWx1ZSBzYXRpc2ZpZXMgdGhlIGByZXF1aXJlZGAgdmFsaWRhdG9yLlxuICpcbiAqIEBwYXJhbSB7QW55fSB2YWx1ZVxuICogQHBhcmFtIHtEb2N1bWVudH0gZG9jXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5TY2hlbWFBcnJheS5wcm90b3R5cGUuY2hlY2tSZXF1aXJlZCA9IGZ1bmN0aW9uIGNoZWNrUmVxdWlyZWQodmFsdWUsIGRvYykge1xuICBpZiAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiBTY2hlbWFUeXBlLl9pc1JlZih0aGlzLCB2YWx1ZSwgZG9jLCB0cnVlKSkge1xuICAgIHJldHVybiAhIXZhbHVlO1xuICB9XG5cbiAgLy8gYHJlcXVpcmUoJ3V0aWwnKS5pbmhlcml0cygpYCBkb2VzICoqbm90KiogY29weSBzdGF0aWMgcHJvcGVydGllcywgYW5kXG4gIC8vIHBsdWdpbnMgbGlrZSBtb25nb29zZS1mbG9hdCB1c2UgYGluaGVyaXRzKClgIGZvciBwcmUtRVM2LlxuICBjb25zdCBfY2hlY2tSZXF1aXJlZCA9IHR5cGVvZiB0aGlzLmNvbnN0cnVjdG9yLmNoZWNrUmVxdWlyZWQgPT09ICdmdW5jdGlvbicgP1xuICAgIHRoaXMuY29uc3RydWN0b3IuY2hlY2tSZXF1aXJlZCgpIDpcbiAgICBTY2hlbWFBcnJheS5jaGVja1JlcXVpcmVkKCk7XG5cbiAgcmV0dXJuIF9jaGVja1JlcXVpcmVkKHZhbHVlKTtcbn07XG5cbi8qKlxuICogQWRkcyBhbiBlbnVtIHZhbGlkYXRvciBpZiB0aGlzIGlzIGFuIGFycmF5IG9mIHN0cmluZ3Mgb3IgbnVtYmVycy4gRXF1aXZhbGVudCB0b1xuICogYFNjaGVtYVN0cmluZy5wcm90b3R5cGUuZW51bSgpYCBvciBgU2NoZW1hTnVtYmVyLnByb3RvdHlwZS5lbnVtKClgXG4gKlxuICogQHBhcmFtIHsuLi5TdHJpbmd8T2JqZWN0fSBbYXJnc10gZW51bWVyYXRpb24gdmFsdWVzXG4gKiBAcmV0dXJuIHtTY2hlbWFBcnJheX0gdGhpc1xuICovXG5cblNjaGVtYUFycmF5LnByb3RvdHlwZS5lbnVtID0gZnVuY3Rpb24oKSB7XG4gIGxldCBhcnIgPSB0aGlzO1xuICB3aGlsZSAodHJ1ZSkge1xuICAgIGNvbnN0IGluc3RhbmNlID0gYXJyICYmXG4gICAgYXJyLmNhc3RlciAmJlxuICAgIGFyci5jYXN0ZXIuaW5zdGFuY2U7XG4gICAgaWYgKGluc3RhbmNlID09PSAnQXJyYXknKSB7XG4gICAgICBhcnIgPSBhcnIuY2FzdGVyO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChpbnN0YW5jZSAhPT0gJ1N0cmluZycgJiYgaW5zdGFuY2UgIT09ICdOdW1iZXInKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2BlbnVtYCBjYW4gb25seSBiZSBzZXQgb24gYW4gYXJyYXkgb2Ygc3RyaW5ncyBvciBudW1iZXJzICcgK1xuICAgICAgICAnLCBub3QgJyArIGluc3RhbmNlKTtcbiAgICB9XG4gICAgYnJlYWs7XG4gIH1cblxuICBsZXQgZW51bUFycmF5ID0gYXJndW1lbnRzO1xuICBpZiAoIUFycmF5LmlzQXJyYXkoYXJndW1lbnRzKSAmJiB1dGlscy5pc09iamVjdChhcmd1bWVudHMpKSB7XG4gICAgZW51bUFycmF5ID0gdXRpbHMub2JqZWN0LnZhbHMoZW51bUFycmF5KTtcbiAgfVxuXG4gIGFyci5jYXN0ZXIuZW51bS5hcHBseShhcnIuY2FzdGVyLCBlbnVtQXJyYXkpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogT3ZlcnJpZGVzIHRoZSBnZXR0ZXJzIGFwcGxpY2F0aW9uIGZvciB0aGUgcG9wdWxhdGlvbiBzcGVjaWFsLWNhc2VcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsdWVcbiAqIEBwYXJhbSB7T2JqZWN0fSBzY29wZVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU2NoZW1hQXJyYXkucHJvdG90eXBlLmFwcGx5R2V0dGVycyA9IGZ1bmN0aW9uKHZhbHVlLCBzY29wZSkge1xuICBpZiAoc2NvcGUgIT0gbnVsbCAmJiBzY29wZS4kX18gIT0gbnVsbCAmJiBzY29wZS4kcG9wdWxhdGVkKHRoaXMucGF0aCkpIHtcbiAgICAvLyBtZWFucyB0aGUgb2JqZWN0IGlkIHdhcyBwb3B1bGF0ZWRcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cblxuICBjb25zdCByZXQgPSBTY2hlbWFUeXBlLnByb3RvdHlwZS5hcHBseUdldHRlcnMuY2FsbCh0aGlzLCB2YWx1ZSwgc2NvcGUpO1xuICByZXR1cm4gcmV0O1xufTtcblxuU2NoZW1hQXJyYXkucHJvdG90eXBlLl9hcHBseVNldHRlcnMgPSBmdW5jdGlvbih2YWx1ZSwgc2NvcGUsIGluaXQsIHByaW9yVmFsKSB7XG4gIGlmICh0aGlzLmNhc3RlckNvbnN0cnVjdG9yLiRpc01vbmdvb3NlQXJyYXkgJiZcbiAgICAgIFNjaGVtYUFycmF5Lm9wdGlvbnMuY2FzdE5vbkFycmF5cyAmJlxuICAgICAgIXRoaXNbaXNOZXN0ZWRBcnJheVN5bWJvbF0pIHtcbiAgICAvLyBDaGVjayBuZXN0aW5nIGxldmVscyBhbmQgd3JhcCBpbiBhcnJheSBpZiBuZWNlc3NhcnlcbiAgICBsZXQgZGVwdGggPSAwO1xuICAgIGxldCBhcnIgPSB0aGlzO1xuICAgIHdoaWxlIChhcnIgIT0gbnVsbCAmJlxuICAgICAgYXJyLiRpc01vbmdvb3NlQXJyYXkgJiZcbiAgICAgICFhcnIuJGlzTW9uZ29vc2VEb2N1bWVudEFycmF5KSB7XG4gICAgICArK2RlcHRoO1xuICAgICAgYXJyID0gYXJyLmNhc3RlckNvbnN0cnVjdG9yO1xuICAgIH1cblxuICAgIC8vIE5vIG5lZWQgdG8gd3JhcCBlbXB0eSBhcnJheXNcbiAgICBpZiAodmFsdWUgIT0gbnVsbCAmJiB2YWx1ZS5sZW5ndGggIT09IDApIHtcbiAgICAgIGNvbnN0IHZhbHVlRGVwdGggPSBhcnJheURlcHRoKHZhbHVlKTtcbiAgICAgIGlmICh2YWx1ZURlcHRoLm1pbiA9PT0gdmFsdWVEZXB0aC5tYXggJiYgdmFsdWVEZXB0aC5tYXggPCBkZXB0aCAmJiB2YWx1ZURlcHRoLmNvbnRhaW5zTm9uQXJyYXlJdGVtKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSB2YWx1ZURlcHRoLm1heDsgaSA8IGRlcHRoOyArK2kpIHtcbiAgICAgICAgICB2YWx1ZSA9IFt2YWx1ZV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gU2NoZW1hVHlwZS5wcm90b3R5cGUuX2FwcGx5U2V0dGVycy5jYWxsKHRoaXMsIHZhbHVlLCBzY29wZSwgaW5pdCwgcHJpb3JWYWwpO1xufTtcblxuLyoqXG4gKiBDYXN0cyB2YWx1ZXMgZm9yIHNldCgpLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWx1ZVxuICogQHBhcmFtIHtEb2N1bWVudH0gZG9jIGRvY3VtZW50IHRoYXQgdHJpZ2dlcnMgdGhlIGNhc3RpbmdcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gaW5pdCB3aGV0aGVyIHRoaXMgaXMgYW4gaW5pdGlhbGl6YXRpb24gY2FzdFxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU2NoZW1hQXJyYXkucHJvdG90eXBlLmNhc3QgPSBmdW5jdGlvbih2YWx1ZSwgZG9jLCBpbml0LCBwcmV2LCBvcHRpb25zKSB7XG4gIC8vIGxhenkgbG9hZFxuICBNb25nb29zZUFycmF5IHx8IChNb25nb29zZUFycmF5ID0gcmVxdWlyZSgnLi4vdHlwZXMnKS5BcnJheSk7XG5cbiAgbGV0IGk7XG4gIGxldCBsO1xuXG4gIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgIGNvbnN0IGxlbiA9IHZhbHVlLmxlbmd0aDtcbiAgICBpZiAoIWxlbiAmJiBkb2MpIHtcbiAgICAgIGNvbnN0IGluZGV4ZXMgPSBkb2Muc2NoZW1hLmluZGV4ZWRQYXRocygpO1xuXG4gICAgICBjb25zdCBhcnJheVBhdGggPSB0aGlzLnBhdGg7XG4gICAgICBmb3IgKGkgPSAwLCBsID0gaW5kZXhlcy5sZW5ndGg7IGkgPCBsOyArK2kpIHtcbiAgICAgICAgY29uc3QgcGF0aEluZGV4ID0gaW5kZXhlc1tpXVswXVthcnJheVBhdGhdO1xuICAgICAgICBpZiAocGF0aEluZGV4ID09PSAnMmRzcGhlcmUnIHx8IHBhdGhJbmRleCA9PT0gJzJkJykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBTcGVjaWFsIGNhc2U6IGlmIHRoaXMgaW5kZXggaXMgb24gdGhlIHBhcmVudCBvZiB3aGF0IGxvb2tzIGxpa2VcbiAgICAgIC8vIEdlb0pTT04sIHNraXAgc2V0dGluZyB0aGUgZGVmYXVsdCB0byBlbXB0eSBhcnJheSByZTogIzE2NjgsICMzMjMzXG4gICAgICBjb25zdCBhcnJheUdlb2pzb25QYXRoID0gdGhpcy5wYXRoLmVuZHNXaXRoKCcuY29vcmRpbmF0ZXMnKSA/XG4gICAgICAgIHRoaXMucGF0aC5zdWJzdHJpbmcoMCwgdGhpcy5wYXRoLmxhc3RJbmRleE9mKCcuJykpIDogbnVsbDtcbiAgICAgIGlmIChhcnJheUdlb2pzb25QYXRoICE9IG51bGwpIHtcbiAgICAgICAgZm9yIChpID0gMCwgbCA9IGluZGV4ZXMubGVuZ3RoOyBpIDwgbDsgKytpKSB7XG4gICAgICAgICAgY29uc3QgcGF0aEluZGV4ID0gaW5kZXhlc1tpXVswXVthcnJheUdlb2pzb25QYXRoXTtcbiAgICAgICAgICBpZiAocGF0aEluZGV4ID09PSAnMmRzcGhlcmUnKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwgZW1wdHlPcHRzO1xuXG4gICAgbGV0IHJhd1ZhbHVlID0gdXRpbHMuaXNNb25nb29zZUFycmF5KHZhbHVlKSA/IHZhbHVlLl9fYXJyYXkgOiB2YWx1ZTtcbiAgICBsZXQgcGF0aCA9IG9wdGlvbnMucGF0aCB8fCB0aGlzLnBhdGg7XG4gICAgaWYgKG9wdGlvbnMuYXJyYXlQYXRoSW5kZXggIT0gbnVsbCkge1xuICAgICAgcGF0aCArPSAnLicgKyBvcHRpb25zLmFycmF5UGF0aEluZGV4O1xuICAgIH1cbiAgICB2YWx1ZSA9IE1vbmdvb3NlQXJyYXkocmF3VmFsdWUsIHBhdGgsIGRvYywgdGhpcyk7XG4gICAgcmF3VmFsdWUgPSB2YWx1ZS5fX2FycmF5O1xuXG4gICAgaWYgKGluaXQgJiYgZG9jICE9IG51bGwgJiYgZG9jLiRfXyAhPSBudWxsICYmIGRvYy4kcG9wdWxhdGVkKHRoaXMucGF0aCkpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgICBjb25zdCBjYXN0ZXIgPSB0aGlzLmNhc3RlcjtcbiAgICBjb25zdCBpc01vbmdvb3NlQXJyYXkgPSBjYXN0ZXIuJGlzTW9uZ29vc2VBcnJheTtcbiAgICBpZiAoY2FzdGVyICYmIHRoaXMuY2FzdGVyQ29uc3RydWN0b3IgIT09IE1peGVkKSB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBsZW4gPSByYXdWYWx1ZS5sZW5ndGg7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgIGNvbnN0IG9wdHMgPSB7fTtcbiAgICAgICAgICAvLyBQZXJmOiBjcmVhdGluZyBgYXJyYXlQYXRoYCBpcyBleHBlbnNpdmUgZm9yIGxhcmdlIGFycmF5cy5cbiAgICAgICAgICAvLyBXZSBvbmx5IG5lZWQgYGFycmF5UGF0aGAgaWYgdGhpcyBpcyBhIG5lc3RlZCBhcnJheSwgc29cbiAgICAgICAgICAvLyBza2lwIGlmIHBvc3NpYmxlLlxuICAgICAgICAgIGlmIChpc01vbmdvb3NlQXJyYXkpIHtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmFycmF5UGF0aCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgIG9wdHMuYXJyYXlQYXRoSW5kZXggPSBpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChjYXN0ZXIuX2FycmF5UGFyZW50UGF0aCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgIG9wdHMuYXJyYXlQYXRoSW5kZXggPSBpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByYXdWYWx1ZVtpXSA9IGNhc3Rlci5hcHBseVNldHRlcnMocmF3VmFsdWVbaV0sIGRvYywgaW5pdCwgdm9pZCAwLCBvcHRzKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAvLyByZXRocm93XG4gICAgICAgIHRocm93IG5ldyBDYXN0RXJyb3IoJ1snICsgZS5raW5kICsgJ10nLCB1dGlsLmluc3BlY3QodmFsdWUpLCB0aGlzLnBhdGggKyAnLicgKyBpLCBlLCB0aGlzKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cblxuICBjb25zdCBjYXN0Tm9uQXJyYXlzT3B0aW9uID0gdGhpcy5vcHRpb25zLmNhc3ROb25BcnJheXMgIT0gbnVsbCA/IHRoaXMub3B0aW9ucy5jYXN0Tm9uQXJyYXlzIDogU2NoZW1hQXJyYXkub3B0aW9ucy5jYXN0Tm9uQXJyYXlzO1xuICBpZiAoaW5pdCB8fCBjYXN0Tm9uQXJyYXlzT3B0aW9uKSB7XG4gICAgLy8gZ2gtMjQ0MjogaWYgd2UncmUgbG9hZGluZyB0aGlzIGZyb20gdGhlIGRiIGFuZCBpdHMgbm90IGFuIGFycmF5LCBtYXJrXG4gICAgLy8gdGhlIHdob2xlIGFycmF5IGFzIG1vZGlmaWVkLlxuICAgIGlmICghIWRvYyAmJiAhIWluaXQpIHtcbiAgICAgIGRvYy5tYXJrTW9kaWZpZWQodGhpcy5wYXRoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuY2FzdChbdmFsdWVdLCBkb2MsIGluaXQpO1xuICB9XG5cbiAgdGhyb3cgbmV3IENhc3RFcnJvcignQXJyYXknLCB1dGlsLmluc3BlY3QodmFsdWUpLCB0aGlzLnBhdGgsIG51bGwsIHRoaXMpO1xufTtcblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5TY2hlbWFBcnJheS5wcm90b3R5cGUuX2Nhc3RGb3JQb3B1bGF0ZSA9IGZ1bmN0aW9uIF9jYXN0Rm9yUG9wdWxhdGUodmFsdWUsIGRvYykge1xuICAvLyBsYXp5IGxvYWRcbiAgTW9uZ29vc2VBcnJheSB8fCAoTW9uZ29vc2VBcnJheSA9IHJlcXVpcmUoJy4uL3R5cGVzJykuQXJyYXkpO1xuXG4gIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgIGxldCBpO1xuICAgIGNvbnN0IHJhd1ZhbHVlID0gdmFsdWUuX19hcnJheSA/IHZhbHVlLl9fYXJyYXkgOiB2YWx1ZTtcbiAgICBjb25zdCBsZW4gPSByYXdWYWx1ZS5sZW5ndGg7XG5cbiAgICBjb25zdCBjYXN0ZXIgPSB0aGlzLmNhc3RlcjtcbiAgICBpZiAoY2FzdGVyICYmIHRoaXMuY2FzdGVyQ29uc3RydWN0b3IgIT09IE1peGVkKSB7XG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICBjb25zdCBvcHRzID0ge307XG4gICAgICAgICAgLy8gUGVyZjogY3JlYXRpbmcgYGFycmF5UGF0aGAgaXMgZXhwZW5zaXZlIGZvciBsYXJnZSBhcnJheXMuXG4gICAgICAgICAgLy8gV2Ugb25seSBuZWVkIGBhcnJheVBhdGhgIGlmIHRoaXMgaXMgYSBuZXN0ZWQgYXJyYXksIHNvXG4gICAgICAgICAgLy8gc2tpcCBpZiBwb3NzaWJsZS5cbiAgICAgICAgICBpZiAoY2FzdGVyLiRpc01vbmdvb3NlQXJyYXkgJiYgY2FzdGVyLl9hcnJheVBhcmVudFBhdGggIT0gbnVsbCkge1xuICAgICAgICAgICAgb3B0cy5hcnJheVBhdGhJbmRleCA9IGk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmF3VmFsdWVbaV0gPSBjYXN0ZXIuY2FzdChyYXdWYWx1ZVtpXSwgZG9jLCBmYWxzZSwgdm9pZCAwLCBvcHRzKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAvLyByZXRocm93XG4gICAgICAgIHRocm93IG5ldyBDYXN0RXJyb3IoJ1snICsgZS5raW5kICsgJ10nLCB1dGlsLmluc3BlY3QodmFsdWUpLCB0aGlzLnBhdGggKyAnLicgKyBpLCBlLCB0aGlzKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cblxuICB0aHJvdyBuZXcgQ2FzdEVycm9yKCdBcnJheScsIHV0aWwuaW5zcGVjdCh2YWx1ZSksIHRoaXMucGF0aCwgbnVsbCwgdGhpcyk7XG59O1xuXG5TY2hlbWFBcnJheS5wcm90b3R5cGUuJHRvT2JqZWN0ID0gU2NoZW1hQXJyYXkucHJvdG90eXBlLnRvT2JqZWN0O1xuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cblNjaGVtYUFycmF5LnByb3RvdHlwZS5kaXNjcmltaW5hdG9yID0gZnVuY3Rpb24oLi4uYXJncykge1xuICBsZXQgYXJyID0gdGhpcztcbiAgd2hpbGUgKGFyci4kaXNNb25nb29zZUFycmF5ICYmICFhcnIuJGlzTW9uZ29vc2VEb2N1bWVudEFycmF5KSB7XG4gICAgYXJyID0gYXJyLmNhc3RlckNvbnN0cnVjdG9yO1xuICAgIGlmIChhcnIgPT0gbnVsbCB8fCB0eXBlb2YgYXJyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBuZXcgTW9uZ29vc2VFcnJvcignWW91IGNhbiBvbmx5IGFkZCBhbiBlbWJlZGRlZCBkaXNjcmltaW5hdG9yIG9uICcgK1xuICAgICAgICAnYSBkb2N1bWVudCBhcnJheSwgJyArIHRoaXMucGF0aCArICcgaXMgYSBwbGFpbiBhcnJheScpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gYXJyLmRpc2NyaW1pbmF0b3IoLi4uYXJncyk7XG59O1xuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cblNjaGVtYUFycmF5LnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uKCkge1xuICBjb25zdCBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5vcHRpb25zKTtcbiAgY29uc3Qgc2NoZW1hdHlwZSA9IG5ldyB0aGlzLmNvbnN0cnVjdG9yKHRoaXMucGF0aCwgdGhpcy5jYXN0ZXIsIG9wdGlvbnMsIHRoaXMuc2NoZW1hT3B0aW9ucyk7XG4gIHNjaGVtYXR5cGUudmFsaWRhdG9ycyA9IHRoaXMudmFsaWRhdG9ycy5zbGljZSgpO1xuICBpZiAodGhpcy5yZXF1aXJlZFZhbGlkYXRvciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgc2NoZW1hdHlwZS5yZXF1aXJlZFZhbGlkYXRvciA9IHRoaXMucmVxdWlyZWRWYWxpZGF0b3I7XG4gIH1cbiAgcmV0dXJuIHNjaGVtYXR5cGU7XG59O1xuXG5TY2hlbWFBcnJheS5wcm90b3R5cGUuX2Nhc3RGb3JRdWVyeSA9IGZ1bmN0aW9uKHZhbCwgY29udGV4dCkge1xuICBsZXQgQ29uc3RydWN0b3IgPSB0aGlzLmNhc3RlckNvbnN0cnVjdG9yO1xuXG4gIGlmICh2YWwgJiZcbiAgICAgIENvbnN0cnVjdG9yLmRpc2NyaW1pbmF0b3JzICYmXG4gICAgICBDb25zdHJ1Y3Rvci5zY2hlbWEgJiZcbiAgICAgIENvbnN0cnVjdG9yLnNjaGVtYS5vcHRpb25zICYmXG4gICAgICBDb25zdHJ1Y3Rvci5zY2hlbWEub3B0aW9ucy5kaXNjcmltaW5hdG9yS2V5KSB7XG4gICAgaWYgKHR5cGVvZiB2YWxbQ29uc3RydWN0b3Iuc2NoZW1hLm9wdGlvbnMuZGlzY3JpbWluYXRvcktleV0gPT09ICdzdHJpbmcnICYmXG4gICAgICAgIENvbnN0cnVjdG9yLmRpc2NyaW1pbmF0b3JzW3ZhbFtDb25zdHJ1Y3Rvci5zY2hlbWEub3B0aW9ucy5kaXNjcmltaW5hdG9yS2V5XV0pIHtcbiAgICAgIENvbnN0cnVjdG9yID0gQ29uc3RydWN0b3IuZGlzY3JpbWluYXRvcnNbdmFsW0NvbnN0cnVjdG9yLnNjaGVtYS5vcHRpb25zLmRpc2NyaW1pbmF0b3JLZXldXTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgY29uc3RydWN0b3JCeVZhbHVlID0gZ2V0RGlzY3JpbWluYXRvckJ5VmFsdWUoQ29uc3RydWN0b3IuZGlzY3JpbWluYXRvcnMsIHZhbFtDb25zdHJ1Y3Rvci5zY2hlbWEub3B0aW9ucy5kaXNjcmltaW5hdG9yS2V5XSk7XG4gICAgICBpZiAoY29uc3RydWN0b3JCeVZhbHVlKSB7XG4gICAgICAgIENvbnN0cnVjdG9yID0gY29uc3RydWN0b3JCeVZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGNvbnN0IHByb3RvID0gdGhpcy5jYXN0ZXJDb25zdHJ1Y3Rvci5wcm90b3R5cGU7XG4gIGNvbnN0IHByb3RvQ2FzdEZvclF1ZXJ5ID0gcHJvdG8gJiYgcHJvdG8uY2FzdEZvclF1ZXJ5O1xuICBjb25zdCBwcm90b0Nhc3QgPSBwcm90byAmJiBwcm90by5jYXN0O1xuICBjb25zdCBjb25zdHJ1Y3RvckNhc3RGb3JRdWVyeSA9IENvbnN0cnVjdG9yLmNhc3RGb3JRdWVyeTtcbiAgY29uc3QgY2FzdGVyID0gdGhpcy5jYXN0ZXI7XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsKSkge1xuICAgIHRoaXMuc2V0dGVycy5yZXZlcnNlKCkuZm9yRWFjaChzZXR0ZXIgPT4ge1xuICAgICAgdmFsID0gc2V0dGVyLmNhbGwodGhpcywgdmFsLCB0aGlzKTtcbiAgICB9KTtcbiAgICB2YWwgPSB2YWwubWFwKGZ1bmN0aW9uKHYpIHtcbiAgICAgIGlmICh1dGlscy5pc09iamVjdCh2KSAmJiB2LiRlbGVtTWF0Y2gpIHtcbiAgICAgICAgcmV0dXJuIHY7XG4gICAgICB9XG4gICAgICBpZiAocHJvdG9DYXN0Rm9yUXVlcnkpIHtcbiAgICAgICAgdiA9IHByb3RvQ2FzdEZvclF1ZXJ5LmNhbGwoY2FzdGVyLCBudWxsLCB2LCBjb250ZXh0KTtcbiAgICAgICAgcmV0dXJuIHY7XG4gICAgICB9IGVsc2UgaWYgKHByb3RvQ2FzdCkge1xuICAgICAgICB2ID0gcHJvdG9DYXN0LmNhbGwoY2FzdGVyLCB2KTtcbiAgICAgICAgcmV0dXJuIHY7XG4gICAgICB9IGVsc2UgaWYgKGNvbnN0cnVjdG9yQ2FzdEZvclF1ZXJ5KSB7XG4gICAgICAgIHYgPSBjb25zdHJ1Y3RvckNhc3RGb3JRdWVyeS5jYWxsKGNhc3RlciwgbnVsbCwgdiwgY29udGV4dCk7XG4gICAgICAgIHJldHVybiB2O1xuICAgICAgfVxuICAgICAgaWYgKHYgIT0gbnVsbCkge1xuICAgICAgICB2ID0gbmV3IENvbnN0cnVjdG9yKHYpO1xuICAgICAgICByZXR1cm4gdjtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2O1xuICAgIH0pO1xuICB9IGVsc2UgaWYgKHByb3RvQ2FzdEZvclF1ZXJ5KSB7XG4gICAgdmFsID0gcHJvdG9DYXN0Rm9yUXVlcnkuY2FsbChjYXN0ZXIsIG51bGwsIHZhbCwgY29udGV4dCk7XG4gIH0gZWxzZSBpZiAocHJvdG9DYXN0KSB7XG4gICAgdmFsID0gcHJvdG9DYXN0LmNhbGwoY2FzdGVyLCB2YWwpO1xuICB9IGVsc2UgaWYgKGNvbnN0cnVjdG9yQ2FzdEZvclF1ZXJ5KSB7XG4gICAgdmFsID0gY29uc3RydWN0b3JDYXN0Rm9yUXVlcnkuY2FsbChjYXN0ZXIsIG51bGwsIHZhbCwgY29udGV4dCk7XG4gIH0gZWxzZSBpZiAodmFsICE9IG51bGwpIHtcbiAgICB2YWwgPSBuZXcgQ29uc3RydWN0b3IodmFsKTtcbiAgfVxuXG4gIHJldHVybiB2YWw7XG59O1xuXG4vKipcbiAqIENhc3RzIHZhbHVlcyBmb3IgcXVlcmllcy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gJGNvbmRpdGlvbmFsXG4gKiBAcGFyYW0ge2FueX0gW3ZhbHVlXVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU2NoZW1hQXJyYXkucHJvdG90eXBlLmNhc3RGb3JRdWVyeSA9IGZ1bmN0aW9uKCRjb25kaXRpb25hbCwgdmFsLCBjb250ZXh0KSB7XG4gIGxldCBoYW5kbGVyO1xuXG4gIGlmICgkY29uZGl0aW9uYWwgIT0gbnVsbCkge1xuICAgIGhhbmRsZXIgPSB0aGlzLiRjb25kaXRpb25hbEhhbmRsZXJzWyRjb25kaXRpb25hbF07XG5cbiAgICBpZiAoIWhhbmRsZXIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ2FuXFwndCB1c2UgJyArICRjb25kaXRpb25hbCArICcgd2l0aCBBcnJheS4nKTtcbiAgICB9XG5cbiAgICByZXR1cm4gaGFuZGxlci5jYWxsKHRoaXMsIHZhbCwgY29udGV4dCk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHRoaXMuX2Nhc3RGb3JRdWVyeSh2YWwsIGNvbnRleHQpO1xuICB9XG59O1xuXG5mdW5jdGlvbiBjYXN0JGFsbCh2YWwsIGNvbnRleHQpIHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KHZhbCkpIHtcbiAgICB2YWwgPSBbdmFsXTtcbiAgfVxuXG4gIHZhbCA9IHZhbC5tYXAoKHYpID0+IHtcbiAgICBpZiAoIXV0aWxzLmlzT2JqZWN0KHYpKSB7XG4gICAgICByZXR1cm4gdjtcbiAgICB9XG4gICAgaWYgKHYuJGVsZW1NYXRjaCAhPSBudWxsKSB7XG4gICAgICByZXR1cm4geyAkZWxlbU1hdGNoOiBjYXN0KHRoaXMuY2FzdGVyQ29uc3RydWN0b3Iuc2NoZW1hLCB2LiRlbGVtTWF0Y2gsIG51bGwsIHRoaXMgJiYgdGhpcy4kJGNvbnRleHQpIH07XG4gICAgfVxuXG4gICAgY29uc3QgbyA9IHt9O1xuICAgIG9bdGhpcy5wYXRoXSA9IHY7XG4gICAgcmV0dXJuIGNhc3QodGhpcy5jYXN0ZXJDb25zdHJ1Y3Rvci5zY2hlbWEsIG8sIG51bGwsIHRoaXMgJiYgdGhpcy4kJGNvbnRleHQpW3RoaXMucGF0aF07XG4gIH0sIHRoaXMpO1xuXG4gIHJldHVybiB0aGlzLmNhc3RGb3JRdWVyeShudWxsLCB2YWwsIGNvbnRleHQpO1xufVxuXG5mdW5jdGlvbiBjYXN0JGVsZW1NYXRjaCh2YWwsIGNvbnRleHQpIHtcbiAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHZhbCk7XG4gIGNvbnN0IG51bUtleXMgPSBrZXlzLmxlbmd0aDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1LZXlzOyArK2kpIHtcbiAgICBjb25zdCBrZXkgPSBrZXlzW2ldO1xuICAgIGNvbnN0IHZhbHVlID0gdmFsW2tleV07XG4gICAgaWYgKGlzT3BlcmF0b3Ioa2V5KSAmJiB2YWx1ZSAhPSBudWxsKSB7XG4gICAgICB2YWxba2V5XSA9IHRoaXMuY2FzdEZvclF1ZXJ5KGtleSwgdmFsdWUsIGNvbnRleHQpO1xuICAgIH1cbiAgfVxuXG4gIC8vIElzIHRoaXMgYW4gZW1iZWRkZWQgZGlzY3JpbWluYXRvciBhbmQgaXMgdGhlIGRpc2NyaW1pbmF0b3Iga2V5IHNldD9cbiAgLy8gSWYgc28sIHVzZSB0aGUgZGlzY3JpbWluYXRvciBzY2hlbWEuIFNlZSBnaC03NDQ5XG4gIGNvbnN0IGRpc2NyaW1pbmF0b3JLZXkgPSB0aGlzICYmXG4gICAgdGhpcy5jYXN0ZXJDb25zdHJ1Y3RvciAmJlxuICAgIHRoaXMuY2FzdGVyQ29uc3RydWN0b3Iuc2NoZW1hICYmXG4gICAgdGhpcy5jYXN0ZXJDb25zdHJ1Y3Rvci5zY2hlbWEub3B0aW9ucyAmJlxuICAgIHRoaXMuY2FzdGVyQ29uc3RydWN0b3Iuc2NoZW1hLm9wdGlvbnMuZGlzY3JpbWluYXRvcktleTtcbiAgY29uc3QgZGlzY3JpbWluYXRvcnMgPSB0aGlzICYmXG4gIHRoaXMuY2FzdGVyQ29uc3RydWN0b3IgJiZcbiAgdGhpcy5jYXN0ZXJDb25zdHJ1Y3Rvci5zY2hlbWEgJiZcbiAgdGhpcy5jYXN0ZXJDb25zdHJ1Y3Rvci5zY2hlbWEuZGlzY3JpbWluYXRvcnMgfHwge307XG4gIGlmIChkaXNjcmltaW5hdG9yS2V5ICE9IG51bGwgJiZcbiAgICAgIHZhbFtkaXNjcmltaW5hdG9yS2V5XSAhPSBudWxsICYmXG4gICAgICBkaXNjcmltaW5hdG9yc1t2YWxbZGlzY3JpbWluYXRvcktleV1dICE9IG51bGwpIHtcbiAgICByZXR1cm4gY2FzdChkaXNjcmltaW5hdG9yc1t2YWxbZGlzY3JpbWluYXRvcktleV1dLCB2YWwsIG51bGwsIHRoaXMgJiYgdGhpcy4kJGNvbnRleHQpO1xuICB9XG4gIGNvbnN0IHNjaGVtYSA9IHRoaXMuY2FzdGVyQ29uc3RydWN0b3Iuc2NoZW1hID8/IGNvbnRleHQuc2NoZW1hO1xuICByZXR1cm4gY2FzdChzY2hlbWEsIHZhbCwgbnVsbCwgdGhpcyAmJiB0aGlzLiQkY29udGV4dCk7XG59XG5cbmNvbnN0IGhhbmRsZSA9IFNjaGVtYUFycmF5LnByb3RvdHlwZS4kY29uZGl0aW9uYWxIYW5kbGVycyA9IHt9O1xuXG5oYW5kbGUuJGFsbCA9IGNhc3QkYWxsO1xuaGFuZGxlLiRvcHRpb25zID0gU3RyaW5nO1xuaGFuZGxlLiRlbGVtTWF0Y2ggPSBjYXN0JGVsZW1NYXRjaDtcbmhhbmRsZS4kZ2VvSW50ZXJzZWN0cyA9IGdlb3NwYXRpYWwuY2FzdCRnZW9JbnRlcnNlY3RzO1xuaGFuZGxlLiRvciA9IGNyZWF0ZUxvZ2ljYWxRdWVyeU9wZXJhdG9ySGFuZGxlcignJG9yJyk7XG5oYW5kbGUuJGFuZCA9IGNyZWF0ZUxvZ2ljYWxRdWVyeU9wZXJhdG9ySGFuZGxlcignJGFuZCcpO1xuaGFuZGxlLiRub3IgPSBjcmVhdGVMb2dpY2FsUXVlcnlPcGVyYXRvckhhbmRsZXIoJyRub3InKTtcblxuZnVuY3Rpb24gY3JlYXRlTG9naWNhbFF1ZXJ5T3BlcmF0b3JIYW5kbGVyKG9wKSB7XG4gIHJldHVybiBmdW5jdGlvbiBsb2dpY2FsUXVlcnlPcGVyYXRvckhhbmRsZXIodmFsLCBjb250ZXh0KSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHZhbCkpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2NvbmRpdGlvbmFsICcgKyBvcCArICcgcmVxdWlyZXMgYW4gYXJyYXknKTtcbiAgICB9XG5cbiAgICBjb25zdCByZXQgPSBbXTtcbiAgICBmb3IgKGNvbnN0IG9iaiBvZiB2YWwpIHtcbiAgICAgIHJldC5wdXNoKGNhc3QodGhpcy5jYXN0ZXJDb25zdHJ1Y3Rvci5zY2hlbWEgPz8gY29udGV4dC5zY2hlbWEsIG9iaiwgbnVsbCwgdGhpcyAmJiB0aGlzLiQkY29udGV4dCkpO1xuICAgIH1cblxuICAgIHJldHVybiByZXQ7XG4gIH07XG59XG5cbmhhbmRsZS4kbmVhciA9XG5oYW5kbGUuJG5lYXJTcGhlcmUgPSBnZW9zcGF0aWFsLmNhc3QkbmVhcjtcblxuaGFuZGxlLiR3aXRoaW4gPVxuaGFuZGxlLiRnZW9XaXRoaW4gPSBnZW9zcGF0aWFsLmNhc3Qkd2l0aGluO1xuXG5oYW5kbGUuJHNpemUgPVxuaGFuZGxlLiRtaW5EaXN0YW5jZSA9XG5oYW5kbGUuJG1heERpc3RhbmNlID0gY2FzdFRvTnVtYmVyO1xuXG5oYW5kbGUuJGV4aXN0cyA9ICRleGlzdHM7XG5oYW5kbGUuJHR5cGUgPSAkdHlwZTtcblxuaGFuZGxlLiRlcSA9XG5oYW5kbGUuJGd0ID1cbmhhbmRsZS4kZ3RlID1cbmhhbmRsZS4kbHQgPVxuaGFuZGxlLiRsdGUgPVxuaGFuZGxlLiRub3QgPVxuaGFuZGxlLiRyZWdleCA9XG5oYW5kbGUuJG5lID0gU2NoZW1hQXJyYXkucHJvdG90eXBlLl9jYXN0Rm9yUXVlcnk7XG5cbi8vIGAkaW5gIGlzIHNwZWNpYWwgYmVjYXVzZSB5b3UgY2FuIGFsc28gaW5jbHVkZSBhbiBlbXB0eSBhcnJheSBpbiB0aGUgcXVlcnlcbi8vIGxpa2UgYCRpbjogWzEsIFtdXWAsIHNlZSBnaC01OTEzXG5oYW5kbGUuJG5pbiA9IFNjaGVtYVR5cGUucHJvdG90eXBlLiRjb25kaXRpb25hbEhhbmRsZXJzLiRuaW47XG5oYW5kbGUuJGluID0gU2NoZW1hVHlwZS5wcm90b3R5cGUuJGNvbmRpdGlvbmFsSGFuZGxlcnMuJGluO1xuXG4vKiFcbiAqIE1vZHVsZSBleHBvcnRzLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gU2NoZW1hQXJyYXk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../server/node_modules/mongoose/lib/schema/array.js\n");

/***/ }),

/***/ "../server/node_modules/mongoose/lib/schema/bigint.js":
/*!************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/schema/bigint.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\n/*!\n * Module dependencies.\n */\n\nconst CastError = __webpack_require__(/*! ../error/cast */ \"../server/node_modules/mongoose/lib/error/cast.js\");\nconst SchemaType = __webpack_require__(/*! ../schemaType */ \"../server/node_modules/mongoose/lib/schemaType.js\");\nconst castBigInt = __webpack_require__(/*! ../cast/bigint */ \"../server/node_modules/mongoose/lib/cast/bigint.js\");\n\n/**\n * BigInt SchemaType constructor.\n *\n * @param {String} path\n * @param {Object} options\n * @inherits SchemaType\n * @api public\n */\n\nfunction SchemaBigInt(path, options) {\n  SchemaType.call(this, path, options, 'BigInt');\n}\n\n/**\n * This schema type's name, to defend against minifiers that mangle\n * function names.\n *\n * @api public\n */\nSchemaBigInt.schemaName = 'BigInt';\n\nSchemaBigInt.defaultOptions = {};\n\n/*!\n * Inherits from SchemaType.\n */\nSchemaBigInt.prototype = Object.create(SchemaType.prototype);\nSchemaBigInt.prototype.constructor = SchemaBigInt;\n\n/*!\n * ignore\n */\n\nSchemaBigInt._cast = castBigInt;\n\n/**\n * Sets a default option for all BigInt instances.\n *\n * #### Example:\n *\n *     // Make all bigints required by default\n *     mongoose.Schema.BigInt.set('required', true);\n *\n * @param {String} option The option you'd like to set the value for\n * @param {Any} value value for option\n * @return {undefined}\n * @function set\n * @static\n * @api public\n */\n\nSchemaBigInt.set = SchemaType.set;\n\nSchemaBigInt.setters = [];\n\n/**\n * Attaches a getter for all BigInt instances\n *\n * #### Example:\n *\n *     // Convert bigints to numbers\n *     mongoose.Schema.BigInt.get(v => v == null ? v : Number(v));\n *\n * @param {Function} getter\n * @return {this}\n * @function get\n * @static\n * @api public\n */\n\nSchemaBigInt.get = SchemaType.get;\n\n/**\n * Get/set the function used to cast arbitrary values to booleans.\n *\n * #### Example:\n *\n *     // Make Mongoose cast empty string '' to false.\n *     const original = mongoose.Schema.BigInt.cast();\n *     mongoose.Schema.BigInt.cast(v => {\n *       if (v === '') {\n *         return false;\n *       }\n *       return original(v);\n *     });\n *\n *     // Or disable casting entirely\n *     mongoose.Schema.BigInt.cast(false);\n *\n * @param {Function} caster\n * @return {Function}\n * @function get\n * @static\n * @api public\n */\n\nSchemaBigInt.cast = function cast(caster) {\n  if (arguments.length === 0) {\n    return this._cast;\n  }\n  if (caster === false) {\n    caster = this._defaultCaster;\n  }\n  this._cast = caster;\n\n  return this._cast;\n};\n\n/*!\n * ignore\n */\n\nSchemaBigInt._checkRequired = v => v != null;\n\n/**\n * Override the function the required validator uses to check whether a value\n * passes the `required` check.\n *\n * @param {Function} fn\n * @return {Function}\n * @function checkRequired\n * @static\n * @api public\n */\n\nSchemaBigInt.checkRequired = SchemaType.checkRequired;\n\n/**\n * Check if the given value satisfies a required validator.\n *\n * @param {Any} value\n * @return {Boolean}\n * @api public\n */\n\nSchemaBigInt.prototype.checkRequired = function(value) {\n  return this.constructor._checkRequired(value);\n};\n\n/**\n * Casts to bigint\n *\n * @param {Object} value\n * @param {Object} model this value is optional\n * @api private\n */\n\nSchemaBigInt.prototype.cast = function(value) {\n  let castBigInt;\n  if (typeof this._castFunction === 'function') {\n    castBigInt = this._castFunction;\n  } else if (typeof this.constructor.cast === 'function') {\n    castBigInt = this.constructor.cast();\n  } else {\n    castBigInt = SchemaBigInt.cast();\n  }\n\n  try {\n    return castBigInt(value);\n  } catch (error) {\n    throw new CastError('BigInt', value, this.path, error, this);\n  }\n};\n\n/*!\n * ignore\n */\n\nSchemaBigInt.$conditionalHandlers = {\n  ...SchemaType.prototype.$conditionalHandlers,\n  $gt: handleSingle,\n  $gte: handleSingle,\n  $lt: handleSingle,\n  $lte: handleSingle\n};\n\n/*!\n * ignore\n */\n\nfunction handleSingle(val, context) {\n  return this.castForQuery(null, val, context);\n}\n\n/**\n * Casts contents for queries.\n *\n * @param {String} $conditional\n * @param {any} val\n * @api private\n */\n\nSchemaBigInt.prototype.castForQuery = function($conditional, val, context) {\n  let handler;\n  if ($conditional != null) {\n    handler = SchemaBigInt.$conditionalHandlers[$conditional];\n\n    if (handler) {\n      return handler.call(this, val);\n    }\n\n    return this.applySetters(null, val, context);\n  }\n\n  try {\n    return this.applySetters(val, context);\n  } catch (err) {\n    if (err instanceof CastError && err.path === this.path && this.$fullPath != null) {\n      err.path = this.$fullPath;\n    }\n    throw err;\n  }\n};\n\n/**\n *\n * @api private\n */\n\nSchemaBigInt.prototype._castNullish = function _castNullish(v) {\n  if (typeof v === 'undefined') {\n    return v;\n  }\n  const castBigInt = typeof this.constructor.cast === 'function' ?\n    this.constructor.cast() :\n    SchemaBigInt.cast();\n  if (castBigInt == null) {\n    return v;\n  }\n  return v;\n};\n\n/*!\n * Module exports.\n */\n\nmodule.exports = SchemaBigInt;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvc2NoZW1hL2JpZ2ludC5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLG1CQUFPLENBQUMsd0VBQWU7QUFDekMsbUJBQW1CLG1CQUFPLENBQUMsd0VBQWU7QUFDMUMsbUJBQW1CLG1CQUFPLENBQUMsMEVBQWdCOztBQUUzQztBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLEtBQUs7QUFDaEIsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFVBQVU7QUFDckIsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsVUFBVTtBQUNyQixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsVUFBVTtBQUNyQixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxLQUFLO0FBQ2hCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL2NsaWVudC8uLi9zZXJ2ZXIvbm9kZV9tb2R1bGVzL21vbmdvb3NlL2xpYi9zY2hlbWEvYmlnaW50LmpzPzg0ZGIiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG4vKiFcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxuY29uc3QgQ2FzdEVycm9yID0gcmVxdWlyZSgnLi4vZXJyb3IvY2FzdCcpO1xuY29uc3QgU2NoZW1hVHlwZSA9IHJlcXVpcmUoJy4uL3NjaGVtYVR5cGUnKTtcbmNvbnN0IGNhc3RCaWdJbnQgPSByZXF1aXJlKCcuLi9jYXN0L2JpZ2ludCcpO1xuXG4vKipcbiAqIEJpZ0ludCBTY2hlbWFUeXBlIGNvbnN0cnVjdG9yLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQGluaGVyaXRzIFNjaGVtYVR5cGVcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gU2NoZW1hQmlnSW50KHBhdGgsIG9wdGlvbnMpIHtcbiAgU2NoZW1hVHlwZS5jYWxsKHRoaXMsIHBhdGgsIG9wdGlvbnMsICdCaWdJbnQnKTtcbn1cblxuLyoqXG4gKiBUaGlzIHNjaGVtYSB0eXBlJ3MgbmFtZSwgdG8gZGVmZW5kIGFnYWluc3QgbWluaWZpZXJzIHRoYXQgbWFuZ2xlXG4gKiBmdW5jdGlvbiBuYW1lcy5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5TY2hlbWFCaWdJbnQuc2NoZW1hTmFtZSA9ICdCaWdJbnQnO1xuXG5TY2hlbWFCaWdJbnQuZGVmYXVsdE9wdGlvbnMgPSB7fTtcblxuLyohXG4gKiBJbmhlcml0cyBmcm9tIFNjaGVtYVR5cGUuXG4gKi9cblNjaGVtYUJpZ0ludC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFNjaGVtYVR5cGUucHJvdG90eXBlKTtcblNjaGVtYUJpZ0ludC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBTY2hlbWFCaWdJbnQ7XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxuU2NoZW1hQmlnSW50Ll9jYXN0ID0gY2FzdEJpZ0ludDtcblxuLyoqXG4gKiBTZXRzIGEgZGVmYXVsdCBvcHRpb24gZm9yIGFsbCBCaWdJbnQgaW5zdGFuY2VzLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgLy8gTWFrZSBhbGwgYmlnaW50cyByZXF1aXJlZCBieSBkZWZhdWx0XG4gKiAgICAgbW9uZ29vc2UuU2NoZW1hLkJpZ0ludC5zZXQoJ3JlcXVpcmVkJywgdHJ1ZSk7XG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG9wdGlvbiBUaGUgb3B0aW9uIHlvdSdkIGxpa2UgdG8gc2V0IHRoZSB2YWx1ZSBmb3JcbiAqIEBwYXJhbSB7QW55fSB2YWx1ZSB2YWx1ZSBmb3Igb3B0aW9uXG4gKiBAcmV0dXJuIHt1bmRlZmluZWR9XG4gKiBAZnVuY3Rpb24gc2V0XG4gKiBAc3RhdGljXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblNjaGVtYUJpZ0ludC5zZXQgPSBTY2hlbWFUeXBlLnNldDtcblxuU2NoZW1hQmlnSW50LnNldHRlcnMgPSBbXTtcblxuLyoqXG4gKiBBdHRhY2hlcyBhIGdldHRlciBmb3IgYWxsIEJpZ0ludCBpbnN0YW5jZXNcbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIC8vIENvbnZlcnQgYmlnaW50cyB0byBudW1iZXJzXG4gKiAgICAgbW9uZ29vc2UuU2NoZW1hLkJpZ0ludC5nZXQodiA9PiB2ID09IG51bGwgPyB2IDogTnVtYmVyKHYpKTtcbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBnZXR0ZXJcbiAqIEByZXR1cm4ge3RoaXN9XG4gKiBAZnVuY3Rpb24gZ2V0XG4gKiBAc3RhdGljXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblNjaGVtYUJpZ0ludC5nZXQgPSBTY2hlbWFUeXBlLmdldDtcblxuLyoqXG4gKiBHZXQvc2V0IHRoZSBmdW5jdGlvbiB1c2VkIHRvIGNhc3QgYXJiaXRyYXJ5IHZhbHVlcyB0byBib29sZWFucy5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIC8vIE1ha2UgTW9uZ29vc2UgY2FzdCBlbXB0eSBzdHJpbmcgJycgdG8gZmFsc2UuXG4gKiAgICAgY29uc3Qgb3JpZ2luYWwgPSBtb25nb29zZS5TY2hlbWEuQmlnSW50LmNhc3QoKTtcbiAqICAgICBtb25nb29zZS5TY2hlbWEuQmlnSW50LmNhc3QodiA9PiB7XG4gKiAgICAgICBpZiAodiA9PT0gJycpIHtcbiAqICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICogICAgICAgfVxuICogICAgICAgcmV0dXJuIG9yaWdpbmFsKHYpO1xuICogICAgIH0pO1xuICpcbiAqICAgICAvLyBPciBkaXNhYmxlIGNhc3RpbmcgZW50aXJlbHlcbiAqICAgICBtb25nb29zZS5TY2hlbWEuQmlnSW50LmNhc3QoZmFsc2UpO1xuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhc3RlclxuICogQHJldHVybiB7RnVuY3Rpb259XG4gKiBAZnVuY3Rpb24gZ2V0XG4gKiBAc3RhdGljXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblNjaGVtYUJpZ0ludC5jYXN0ID0gZnVuY3Rpb24gY2FzdChjYXN0ZXIpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gdGhpcy5fY2FzdDtcbiAgfVxuICBpZiAoY2FzdGVyID09PSBmYWxzZSkge1xuICAgIGNhc3RlciA9IHRoaXMuX2RlZmF1bHRDYXN0ZXI7XG4gIH1cbiAgdGhpcy5fY2FzdCA9IGNhc3RlcjtcblxuICByZXR1cm4gdGhpcy5fY2FzdDtcbn07XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxuU2NoZW1hQmlnSW50Ll9jaGVja1JlcXVpcmVkID0gdiA9PiB2ICE9IG51bGw7XG5cbi8qKlxuICogT3ZlcnJpZGUgdGhlIGZ1bmN0aW9uIHRoZSByZXF1aXJlZCB2YWxpZGF0b3IgdXNlcyB0byBjaGVjayB3aGV0aGVyIGEgdmFsdWVcbiAqIHBhc3NlcyB0aGUgYHJlcXVpcmVkYCBjaGVjay5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICogQHJldHVybiB7RnVuY3Rpb259XG4gKiBAZnVuY3Rpb24gY2hlY2tSZXF1aXJlZFxuICogQHN0YXRpY1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5TY2hlbWFCaWdJbnQuY2hlY2tSZXF1aXJlZCA9IFNjaGVtYVR5cGUuY2hlY2tSZXF1aXJlZDtcblxuLyoqXG4gKiBDaGVjayBpZiB0aGUgZ2l2ZW4gdmFsdWUgc2F0aXNmaWVzIGEgcmVxdWlyZWQgdmFsaWRhdG9yLlxuICpcbiAqIEBwYXJhbSB7QW55fSB2YWx1ZVxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuU2NoZW1hQmlnSW50LnByb3RvdHlwZS5jaGVja1JlcXVpcmVkID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgcmV0dXJuIHRoaXMuY29uc3RydWN0b3IuX2NoZWNrUmVxdWlyZWQodmFsdWUpO1xufTtcblxuLyoqXG4gKiBDYXN0cyB0byBiaWdpbnRcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsdWVcbiAqIEBwYXJhbSB7T2JqZWN0fSBtb2RlbCB0aGlzIHZhbHVlIGlzIG9wdGlvbmFsXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5TY2hlbWFCaWdJbnQucHJvdG90eXBlLmNhc3QgPSBmdW5jdGlvbih2YWx1ZSkge1xuICBsZXQgY2FzdEJpZ0ludDtcbiAgaWYgKHR5cGVvZiB0aGlzLl9jYXN0RnVuY3Rpb24gPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYXN0QmlnSW50ID0gdGhpcy5fY2FzdEZ1bmN0aW9uO1xuICB9IGVsc2UgaWYgKHR5cGVvZiB0aGlzLmNvbnN0cnVjdG9yLmNhc3QgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYXN0QmlnSW50ID0gdGhpcy5jb25zdHJ1Y3Rvci5jYXN0KCk7XG4gIH0gZWxzZSB7XG4gICAgY2FzdEJpZ0ludCA9IFNjaGVtYUJpZ0ludC5jYXN0KCk7XG4gIH1cblxuICB0cnkge1xuICAgIHJldHVybiBjYXN0QmlnSW50KHZhbHVlKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICB0aHJvdyBuZXcgQ2FzdEVycm9yKCdCaWdJbnQnLCB2YWx1ZSwgdGhpcy5wYXRoLCBlcnJvciwgdGhpcyk7XG4gIH1cbn07XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxuU2NoZW1hQmlnSW50LiRjb25kaXRpb25hbEhhbmRsZXJzID0ge1xuICAuLi5TY2hlbWFUeXBlLnByb3RvdHlwZS4kY29uZGl0aW9uYWxIYW5kbGVycyxcbiAgJGd0OiBoYW5kbGVTaW5nbGUsXG4gICRndGU6IGhhbmRsZVNpbmdsZSxcbiAgJGx0OiBoYW5kbGVTaW5nbGUsXG4gICRsdGU6IGhhbmRsZVNpbmdsZVxufTtcblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5mdW5jdGlvbiBoYW5kbGVTaW5nbGUodmFsLCBjb250ZXh0KSB7XG4gIHJldHVybiB0aGlzLmNhc3RGb3JRdWVyeShudWxsLCB2YWwsIGNvbnRleHQpO1xufVxuXG4vKipcbiAqIENhc3RzIGNvbnRlbnRzIGZvciBxdWVyaWVzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSAkY29uZGl0aW9uYWxcbiAqIEBwYXJhbSB7YW55fSB2YWxcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNjaGVtYUJpZ0ludC5wcm90b3R5cGUuY2FzdEZvclF1ZXJ5ID0gZnVuY3Rpb24oJGNvbmRpdGlvbmFsLCB2YWwsIGNvbnRleHQpIHtcbiAgbGV0IGhhbmRsZXI7XG4gIGlmICgkY29uZGl0aW9uYWwgIT0gbnVsbCkge1xuICAgIGhhbmRsZXIgPSBTY2hlbWFCaWdJbnQuJGNvbmRpdGlvbmFsSGFuZGxlcnNbJGNvbmRpdGlvbmFsXTtcblxuICAgIGlmIChoYW5kbGVyKSB7XG4gICAgICByZXR1cm4gaGFuZGxlci5jYWxsKHRoaXMsIHZhbCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuYXBwbHlTZXR0ZXJzKG51bGwsIHZhbCwgY29udGV4dCk7XG4gIH1cblxuICB0cnkge1xuICAgIHJldHVybiB0aGlzLmFwcGx5U2V0dGVycyh2YWwsIGNvbnRleHQpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBpZiAoZXJyIGluc3RhbmNlb2YgQ2FzdEVycm9yICYmIGVyci5wYXRoID09PSB0aGlzLnBhdGggJiYgdGhpcy4kZnVsbFBhdGggIT0gbnVsbCkge1xuICAgICAgZXJyLnBhdGggPSB0aGlzLiRmdWxsUGF0aDtcbiAgICB9XG4gICAgdGhyb3cgZXJyO1xuICB9XG59O1xuXG4vKipcbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5TY2hlbWFCaWdJbnQucHJvdG90eXBlLl9jYXN0TnVsbGlzaCA9IGZ1bmN0aW9uIF9jYXN0TnVsbGlzaCh2KSB7XG4gIGlmICh0eXBlb2YgdiA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gdjtcbiAgfVxuICBjb25zdCBjYXN0QmlnSW50ID0gdHlwZW9mIHRoaXMuY29uc3RydWN0b3IuY2FzdCA9PT0gJ2Z1bmN0aW9uJyA/XG4gICAgdGhpcy5jb25zdHJ1Y3Rvci5jYXN0KCkgOlxuICAgIFNjaGVtYUJpZ0ludC5jYXN0KCk7XG4gIGlmIChjYXN0QmlnSW50ID09IG51bGwpIHtcbiAgICByZXR1cm4gdjtcbiAgfVxuICByZXR1cm4gdjtcbn07XG5cbi8qIVxuICogTW9kdWxlIGV4cG9ydHMuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBTY2hlbWFCaWdJbnQ7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../server/node_modules/mongoose/lib/schema/bigint.js\n");

/***/ }),

/***/ "../server/node_modules/mongoose/lib/schema/boolean.js":
/*!*************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/schema/boolean.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\n/*!\n * Module dependencies.\n */\n\nconst CastError = __webpack_require__(/*! ../error/cast */ \"../server/node_modules/mongoose/lib/error/cast.js\");\nconst SchemaType = __webpack_require__(/*! ../schemaType */ \"../server/node_modules/mongoose/lib/schemaType.js\");\nconst castBoolean = __webpack_require__(/*! ../cast/boolean */ \"../server/node_modules/mongoose/lib/cast/boolean.js\");\n\n/**\n * Boolean SchemaType constructor.\n *\n * @param {String} path\n * @param {Object} options\n * @inherits SchemaType\n * @api public\n */\n\nfunction SchemaBoolean(path, options) {\n  SchemaType.call(this, path, options, 'Boolean');\n}\n\n/**\n * This schema type's name, to defend against minifiers that mangle\n * function names.\n *\n * @api public\n */\nSchemaBoolean.schemaName = 'Boolean';\n\nSchemaBoolean.defaultOptions = {};\n\n/*!\n * Inherits from SchemaType.\n */\nSchemaBoolean.prototype = Object.create(SchemaType.prototype);\nSchemaBoolean.prototype.constructor = SchemaBoolean;\n\n/*!\n * ignore\n */\n\nSchemaBoolean._cast = castBoolean;\n\n/**\n * Sets a default option for all Boolean instances.\n *\n * #### Example:\n *\n *     // Make all booleans have `default` of false.\n *     mongoose.Schema.Boolean.set('default', false);\n *\n *     const Order = mongoose.model('Order', new Schema({ isPaid: Boolean }));\n *     new Order({ }).isPaid; // false\n *\n * @param {String} option The option you'd like to set the value for\n * @param {Any} value value for option\n * @return {undefined}\n * @function set\n * @static\n * @api public\n */\n\nSchemaBoolean.set = SchemaType.set;\n\nSchemaBoolean.setters = [];\n\n/**\n * Attaches a getter for all Boolean instances\n *\n * #### Example:\n *\n *     mongoose.Schema.Boolean.get(v => v === true ? 'yes' : 'no');\n *\n *     const Order = mongoose.model('Order', new Schema({ isPaid: Boolean }));\n *     new Order({ isPaid: false }).isPaid; // 'no'\n *\n * @param {Function} getter\n * @return {this}\n * @function get\n * @static\n * @api public\n */\n\nSchemaBoolean.get = SchemaType.get;\n\n/**\n * Get/set the function used to cast arbitrary values to booleans.\n *\n * #### Example:\n *\n *     // Make Mongoose cast empty string '' to false.\n *     const original = mongoose.Schema.Boolean.cast();\n *     mongoose.Schema.Boolean.cast(v => {\n *       if (v === '') {\n *         return false;\n *       }\n *       return original(v);\n *     });\n *\n *     // Or disable casting entirely\n *     mongoose.Schema.Boolean.cast(false);\n *\n * @param {Function} caster\n * @return {Function}\n * @function get\n * @static\n * @api public\n */\n\nSchemaBoolean.cast = function cast(caster) {\n  if (arguments.length === 0) {\n    return this._cast;\n  }\n  if (caster === false) {\n    caster = this._defaultCaster;\n  }\n  this._cast = caster;\n\n  return this._cast;\n};\n\n/*!\n * ignore\n */\n\nSchemaBoolean._defaultCaster = v => {\n  if (v != null && typeof v !== 'boolean') {\n    throw new Error();\n  }\n  return v;\n};\n\n/*!\n * ignore\n */\n\nSchemaBoolean._checkRequired = v => v === true || v === false;\n\n/**\n * Override the function the required validator uses to check whether a boolean\n * passes the `required` check.\n *\n * @param {Function} fn\n * @return {Function}\n * @function checkRequired\n * @static\n * @api public\n */\n\nSchemaBoolean.checkRequired = SchemaType.checkRequired;\n\n/**\n * Check if the given value satisfies a required validator. For a boolean\n * to satisfy a required validator, it must be strictly equal to true or to\n * false.\n *\n * @param {Any} value\n * @return {Boolean}\n * @api public\n */\n\nSchemaBoolean.prototype.checkRequired = function(value) {\n  return this.constructor._checkRequired(value);\n};\n\n/**\n * Configure which values get casted to `true`.\n *\n * #### Example:\n *\n *     const M = mongoose.model('Test', new Schema({ b: Boolean }));\n *     new M({ b: 'affirmative' }).b; // undefined\n *     mongoose.Schema.Boolean.convertToTrue.add('affirmative');\n *     new M({ b: 'affirmative' }).b; // true\n *\n * @property convertToTrue\n * @static\n * @memberOf SchemaBoolean\n * @type {Set}\n * @api public\n */\n\nObject.defineProperty(SchemaBoolean, 'convertToTrue', {\n  get: () => castBoolean.convertToTrue,\n  set: v => { castBoolean.convertToTrue = v; }\n});\n\n/**\n * Configure which values get casted to `false`.\n *\n * #### Example:\n *\n *     const M = mongoose.model('Test', new Schema({ b: Boolean }));\n *     new M({ b: 'nay' }).b; // undefined\n *     mongoose.Schema.Types.Boolean.convertToFalse.add('nay');\n *     new M({ b: 'nay' }).b; // false\n *\n * @property convertToFalse\n * @static\n * @memberOf SchemaBoolean\n * @type {Set}\n * @api public\n */\n\nObject.defineProperty(SchemaBoolean, 'convertToFalse', {\n  get: () => castBoolean.convertToFalse,\n  set: v => { castBoolean.convertToFalse = v; }\n});\n\n/**\n * Casts to boolean\n *\n * @param {Object} value\n * @param {Object} model this value is optional\n * @api private\n */\n\nSchemaBoolean.prototype.cast = function(value) {\n  let castBoolean;\n  if (typeof this._castFunction === 'function') {\n    castBoolean = this._castFunction;\n  } else if (typeof this.constructor.cast === 'function') {\n    castBoolean = this.constructor.cast();\n  } else {\n    castBoolean = SchemaBoolean.cast();\n  }\n\n  try {\n    return castBoolean(value);\n  } catch (error) {\n    throw new CastError('Boolean', value, this.path, error, this);\n  }\n};\n\nSchemaBoolean.$conditionalHandlers = { ...SchemaType.prototype.$conditionalHandlers };\n\n/**\n * Casts contents for queries.\n *\n * @param {String} $conditional\n * @param {any} val\n * @api private\n */\n\nSchemaBoolean.prototype.castForQuery = function($conditional, val, context) {\n  let handler;\n  if ($conditional != null) {\n    handler = SchemaBoolean.$conditionalHandlers[$conditional];\n\n    if (handler) {\n      return handler.call(this, val);\n    }\n\n    return this.applySetters(null, val, context);\n  }\n\n  try {\n    return this.applySetters(val, context);\n  } catch (err) {\n    if (err instanceof CastError && err.path === this.path && this.$fullPath != null) {\n      err.path = this.$fullPath;\n    }\n    throw err;\n  }\n};\n\n/**\n *\n * @api private\n */\n\nSchemaBoolean.prototype._castNullish = function _castNullish(v) {\n  if (typeof v === 'undefined') {\n    return v;\n  }\n  const castBoolean = typeof this.constructor.cast === 'function' ?\n    this.constructor.cast() :\n    SchemaBoolean.cast();\n  if (castBoolean == null) {\n    return v;\n  }\n  if (castBoolean.convertToFalse instanceof Set && castBoolean.convertToFalse.has(v)) {\n    return false;\n  }\n  if (castBoolean.convertToTrue instanceof Set && castBoolean.convertToTrue.has(v)) {\n    return true;\n  }\n  return v;\n};\n\n/*!\n * Module exports.\n */\n\nmodule.exports = SchemaBoolean;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvc2NoZW1hL2Jvb2xlYW4uanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7QUFDQTtBQUNBOztBQUVBLGtCQUFrQixtQkFBTyxDQUFDLHdFQUFlO0FBQ3pDLG1CQUFtQixtQkFBTyxDQUFDLHdFQUFlO0FBQzFDLG9CQUFvQixtQkFBTyxDQUFDLDRFQUFpQjs7QUFFN0M7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQsaUJBQWlCO0FBQzNFLG9CQUFvQixVQUFVO0FBQzlCO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsS0FBSztBQUNoQixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQsaUJBQWlCO0FBQzNFLG1CQUFtQixlQUFlLFVBQVU7QUFDNUM7QUFDQSxXQUFXLFVBQVU7QUFDckIsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsVUFBVTtBQUNyQixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELFlBQVk7QUFDakUsZUFBZSxrQkFBa0IsS0FBSztBQUN0QztBQUNBLGVBQWUsa0JBQWtCLEtBQUs7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCxZQUFZO0FBQ2pFLGVBQWUsVUFBVSxLQUFLO0FBQzlCO0FBQ0EsZUFBZSxVQUFVLEtBQUs7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUEsdUNBQXVDOztBQUV2QztBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxLQUFLO0FBQ2hCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL2NsaWVudC8uLi9zZXJ2ZXIvbm9kZV9tb2R1bGVzL21vbmdvb3NlL2xpYi9zY2hlbWEvYm9vbGVhbi5qcz8xZjU4Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuLyohXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbmNvbnN0IENhc3RFcnJvciA9IHJlcXVpcmUoJy4uL2Vycm9yL2Nhc3QnKTtcbmNvbnN0IFNjaGVtYVR5cGUgPSByZXF1aXJlKCcuLi9zY2hlbWFUeXBlJyk7XG5jb25zdCBjYXN0Qm9vbGVhbiA9IHJlcXVpcmUoJy4uL2Nhc3QvYm9vbGVhbicpO1xuXG4vKipcbiAqIEJvb2xlYW4gU2NoZW1hVHlwZSBjb25zdHJ1Y3Rvci5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcGF0aFxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEBpbmhlcml0cyBTY2hlbWFUeXBlXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIFNjaGVtYUJvb2xlYW4ocGF0aCwgb3B0aW9ucykge1xuICBTY2hlbWFUeXBlLmNhbGwodGhpcywgcGF0aCwgb3B0aW9ucywgJ0Jvb2xlYW4nKTtcbn1cblxuLyoqXG4gKiBUaGlzIHNjaGVtYSB0eXBlJ3MgbmFtZSwgdG8gZGVmZW5kIGFnYWluc3QgbWluaWZpZXJzIHRoYXQgbWFuZ2xlXG4gKiBmdW5jdGlvbiBuYW1lcy5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5TY2hlbWFCb29sZWFuLnNjaGVtYU5hbWUgPSAnQm9vbGVhbic7XG5cblNjaGVtYUJvb2xlYW4uZGVmYXVsdE9wdGlvbnMgPSB7fTtcblxuLyohXG4gKiBJbmhlcml0cyBmcm9tIFNjaGVtYVR5cGUuXG4gKi9cblNjaGVtYUJvb2xlYW4ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShTY2hlbWFUeXBlLnByb3RvdHlwZSk7XG5TY2hlbWFCb29sZWFuLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFNjaGVtYUJvb2xlYW47XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxuU2NoZW1hQm9vbGVhbi5fY2FzdCA9IGNhc3RCb29sZWFuO1xuXG4vKipcbiAqIFNldHMgYSBkZWZhdWx0IG9wdGlvbiBmb3IgYWxsIEJvb2xlYW4gaW5zdGFuY2VzLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgLy8gTWFrZSBhbGwgYm9vbGVhbnMgaGF2ZSBgZGVmYXVsdGAgb2YgZmFsc2UuXG4gKiAgICAgbW9uZ29vc2UuU2NoZW1hLkJvb2xlYW4uc2V0KCdkZWZhdWx0JywgZmFsc2UpO1xuICpcbiAqICAgICBjb25zdCBPcmRlciA9IG1vbmdvb3NlLm1vZGVsKCdPcmRlcicsIG5ldyBTY2hlbWEoeyBpc1BhaWQ6IEJvb2xlYW4gfSkpO1xuICogICAgIG5ldyBPcmRlcih7IH0pLmlzUGFpZDsgLy8gZmFsc2VcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gb3B0aW9uIFRoZSBvcHRpb24geW91J2QgbGlrZSB0byBzZXQgdGhlIHZhbHVlIGZvclxuICogQHBhcmFtIHtBbnl9IHZhbHVlIHZhbHVlIGZvciBvcHRpb25cbiAqIEByZXR1cm4ge3VuZGVmaW5lZH1cbiAqIEBmdW5jdGlvbiBzZXRcbiAqIEBzdGF0aWNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuU2NoZW1hQm9vbGVhbi5zZXQgPSBTY2hlbWFUeXBlLnNldDtcblxuU2NoZW1hQm9vbGVhbi5zZXR0ZXJzID0gW107XG5cbi8qKlxuICogQXR0YWNoZXMgYSBnZXR0ZXIgZm9yIGFsbCBCb29sZWFuIGluc3RhbmNlc1xuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgbW9uZ29vc2UuU2NoZW1hLkJvb2xlYW4uZ2V0KHYgPT4gdiA9PT0gdHJ1ZSA/ICd5ZXMnIDogJ25vJyk7XG4gKlxuICogICAgIGNvbnN0IE9yZGVyID0gbW9uZ29vc2UubW9kZWwoJ09yZGVyJywgbmV3IFNjaGVtYSh7IGlzUGFpZDogQm9vbGVhbiB9KSk7XG4gKiAgICAgbmV3IE9yZGVyKHsgaXNQYWlkOiBmYWxzZSB9KS5pc1BhaWQ7IC8vICdubydcbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBnZXR0ZXJcbiAqIEByZXR1cm4ge3RoaXN9XG4gKiBAZnVuY3Rpb24gZ2V0XG4gKiBAc3RhdGljXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblNjaGVtYUJvb2xlYW4uZ2V0ID0gU2NoZW1hVHlwZS5nZXQ7XG5cbi8qKlxuICogR2V0L3NldCB0aGUgZnVuY3Rpb24gdXNlZCB0byBjYXN0IGFyYml0cmFyeSB2YWx1ZXMgdG8gYm9vbGVhbnMuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICAvLyBNYWtlIE1vbmdvb3NlIGNhc3QgZW1wdHkgc3RyaW5nICcnIHRvIGZhbHNlLlxuICogICAgIGNvbnN0IG9yaWdpbmFsID0gbW9uZ29vc2UuU2NoZW1hLkJvb2xlYW4uY2FzdCgpO1xuICogICAgIG1vbmdvb3NlLlNjaGVtYS5Cb29sZWFuLmNhc3QodiA9PiB7XG4gKiAgICAgICBpZiAodiA9PT0gJycpIHtcbiAqICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICogICAgICAgfVxuICogICAgICAgcmV0dXJuIG9yaWdpbmFsKHYpO1xuICogICAgIH0pO1xuICpcbiAqICAgICAvLyBPciBkaXNhYmxlIGNhc3RpbmcgZW50aXJlbHlcbiAqICAgICBtb25nb29zZS5TY2hlbWEuQm9vbGVhbi5jYXN0KGZhbHNlKTtcbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYXN0ZXJcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICogQGZ1bmN0aW9uIGdldFxuICogQHN0YXRpY1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5TY2hlbWFCb29sZWFuLmNhc3QgPSBmdW5jdGlvbiBjYXN0KGNhc3Rlcikge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiB0aGlzLl9jYXN0O1xuICB9XG4gIGlmIChjYXN0ZXIgPT09IGZhbHNlKSB7XG4gICAgY2FzdGVyID0gdGhpcy5fZGVmYXVsdENhc3RlcjtcbiAgfVxuICB0aGlzLl9jYXN0ID0gY2FzdGVyO1xuXG4gIHJldHVybiB0aGlzLl9jYXN0O1xufTtcblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5TY2hlbWFCb29sZWFuLl9kZWZhdWx0Q2FzdGVyID0gdiA9PiB7XG4gIGlmICh2ICE9IG51bGwgJiYgdHlwZW9mIHYgIT09ICdib29sZWFuJykge1xuICAgIHRocm93IG5ldyBFcnJvcigpO1xuICB9XG4gIHJldHVybiB2O1xufTtcblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5TY2hlbWFCb29sZWFuLl9jaGVja1JlcXVpcmVkID0gdiA9PiB2ID09PSB0cnVlIHx8IHYgPT09IGZhbHNlO1xuXG4vKipcbiAqIE92ZXJyaWRlIHRoZSBmdW5jdGlvbiB0aGUgcmVxdWlyZWQgdmFsaWRhdG9yIHVzZXMgdG8gY2hlY2sgd2hldGhlciBhIGJvb2xlYW5cbiAqIHBhc3NlcyB0aGUgYHJlcXVpcmVkYCBjaGVjay5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICogQHJldHVybiB7RnVuY3Rpb259XG4gKiBAZnVuY3Rpb24gY2hlY2tSZXF1aXJlZFxuICogQHN0YXRpY1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5TY2hlbWFCb29sZWFuLmNoZWNrUmVxdWlyZWQgPSBTY2hlbWFUeXBlLmNoZWNrUmVxdWlyZWQ7XG5cbi8qKlxuICogQ2hlY2sgaWYgdGhlIGdpdmVuIHZhbHVlIHNhdGlzZmllcyBhIHJlcXVpcmVkIHZhbGlkYXRvci4gRm9yIGEgYm9vbGVhblxuICogdG8gc2F0aXNmeSBhIHJlcXVpcmVkIHZhbGlkYXRvciwgaXQgbXVzdCBiZSBzdHJpY3RseSBlcXVhbCB0byB0cnVlIG9yIHRvXG4gKiBmYWxzZS5cbiAqXG4gKiBAcGFyYW0ge0FueX0gdmFsdWVcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblNjaGVtYUJvb2xlYW4ucHJvdG90eXBlLmNoZWNrUmVxdWlyZWQgPSBmdW5jdGlvbih2YWx1ZSkge1xuICByZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci5fY2hlY2tSZXF1aXJlZCh2YWx1ZSk7XG59O1xuXG4vKipcbiAqIENvbmZpZ3VyZSB3aGljaCB2YWx1ZXMgZ2V0IGNhc3RlZCB0byBgdHJ1ZWAuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBjb25zdCBNID0gbW9uZ29vc2UubW9kZWwoJ1Rlc3QnLCBuZXcgU2NoZW1hKHsgYjogQm9vbGVhbiB9KSk7XG4gKiAgICAgbmV3IE0oeyBiOiAnYWZmaXJtYXRpdmUnIH0pLmI7IC8vIHVuZGVmaW5lZFxuICogICAgIG1vbmdvb3NlLlNjaGVtYS5Cb29sZWFuLmNvbnZlcnRUb1RydWUuYWRkKCdhZmZpcm1hdGl2ZScpO1xuICogICAgIG5ldyBNKHsgYjogJ2FmZmlybWF0aXZlJyB9KS5iOyAvLyB0cnVlXG4gKlxuICogQHByb3BlcnR5IGNvbnZlcnRUb1RydWVcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBTY2hlbWFCb29sZWFuXG4gKiBAdHlwZSB7U2V0fVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoU2NoZW1hQm9vbGVhbiwgJ2NvbnZlcnRUb1RydWUnLCB7XG4gIGdldDogKCkgPT4gY2FzdEJvb2xlYW4uY29udmVydFRvVHJ1ZSxcbiAgc2V0OiB2ID0+IHsgY2FzdEJvb2xlYW4uY29udmVydFRvVHJ1ZSA9IHY7IH1cbn0pO1xuXG4vKipcbiAqIENvbmZpZ3VyZSB3aGljaCB2YWx1ZXMgZ2V0IGNhc3RlZCB0byBgZmFsc2VgLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgY29uc3QgTSA9IG1vbmdvb3NlLm1vZGVsKCdUZXN0JywgbmV3IFNjaGVtYSh7IGI6IEJvb2xlYW4gfSkpO1xuICogICAgIG5ldyBNKHsgYjogJ25heScgfSkuYjsgLy8gdW5kZWZpbmVkXG4gKiAgICAgbW9uZ29vc2UuU2NoZW1hLlR5cGVzLkJvb2xlYW4uY29udmVydFRvRmFsc2UuYWRkKCduYXknKTtcbiAqICAgICBuZXcgTSh7IGI6ICduYXknIH0pLmI7IC8vIGZhbHNlXG4gKlxuICogQHByb3BlcnR5IGNvbnZlcnRUb0ZhbHNlXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgU2NoZW1hQm9vbGVhblxuICogQHR5cGUge1NldH1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFNjaGVtYUJvb2xlYW4sICdjb252ZXJ0VG9GYWxzZScsIHtcbiAgZ2V0OiAoKSA9PiBjYXN0Qm9vbGVhbi5jb252ZXJ0VG9GYWxzZSxcbiAgc2V0OiB2ID0+IHsgY2FzdEJvb2xlYW4uY29udmVydFRvRmFsc2UgPSB2OyB9XG59KTtcblxuLyoqXG4gKiBDYXN0cyB0byBib29sZWFuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbHVlXG4gKiBAcGFyYW0ge09iamVjdH0gbW9kZWwgdGhpcyB2YWx1ZSBpcyBvcHRpb25hbFxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU2NoZW1hQm9vbGVhbi5wcm90b3R5cGUuY2FzdCA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gIGxldCBjYXN0Qm9vbGVhbjtcbiAgaWYgKHR5cGVvZiB0aGlzLl9jYXN0RnVuY3Rpb24gPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYXN0Qm9vbGVhbiA9IHRoaXMuX2Nhc3RGdW5jdGlvbjtcbiAgfSBlbHNlIGlmICh0eXBlb2YgdGhpcy5jb25zdHJ1Y3Rvci5jYXN0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FzdEJvb2xlYW4gPSB0aGlzLmNvbnN0cnVjdG9yLmNhc3QoKTtcbiAgfSBlbHNlIHtcbiAgICBjYXN0Qm9vbGVhbiA9IFNjaGVtYUJvb2xlYW4uY2FzdCgpO1xuICB9XG5cbiAgdHJ5IHtcbiAgICByZXR1cm4gY2FzdEJvb2xlYW4odmFsdWUpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHRocm93IG5ldyBDYXN0RXJyb3IoJ0Jvb2xlYW4nLCB2YWx1ZSwgdGhpcy5wYXRoLCBlcnJvciwgdGhpcyk7XG4gIH1cbn07XG5cblNjaGVtYUJvb2xlYW4uJGNvbmRpdGlvbmFsSGFuZGxlcnMgPSB7IC4uLlNjaGVtYVR5cGUucHJvdG90eXBlLiRjb25kaXRpb25hbEhhbmRsZXJzIH07XG5cbi8qKlxuICogQ2FzdHMgY29udGVudHMgZm9yIHF1ZXJpZXMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9ICRjb25kaXRpb25hbFxuICogQHBhcmFtIHthbnl9IHZhbFxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU2NoZW1hQm9vbGVhbi5wcm90b3R5cGUuY2FzdEZvclF1ZXJ5ID0gZnVuY3Rpb24oJGNvbmRpdGlvbmFsLCB2YWwsIGNvbnRleHQpIHtcbiAgbGV0IGhhbmRsZXI7XG4gIGlmICgkY29uZGl0aW9uYWwgIT0gbnVsbCkge1xuICAgIGhhbmRsZXIgPSBTY2hlbWFCb29sZWFuLiRjb25kaXRpb25hbEhhbmRsZXJzWyRjb25kaXRpb25hbF07XG5cbiAgICBpZiAoaGFuZGxlcikge1xuICAgICAgcmV0dXJuIGhhbmRsZXIuY2FsbCh0aGlzLCB2YWwpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmFwcGx5U2V0dGVycyhudWxsLCB2YWwsIGNvbnRleHQpO1xuICB9XG5cbiAgdHJ5IHtcbiAgICByZXR1cm4gdGhpcy5hcHBseVNldHRlcnModmFsLCBjb250ZXh0KTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgaWYgKGVyciBpbnN0YW5jZW9mIENhc3RFcnJvciAmJiBlcnIucGF0aCA9PT0gdGhpcy5wYXRoICYmIHRoaXMuJGZ1bGxQYXRoICE9IG51bGwpIHtcbiAgICAgIGVyci5wYXRoID0gdGhpcy4kZnVsbFBhdGg7XG4gICAgfVxuICAgIHRocm93IGVycjtcbiAgfVxufTtcblxuLyoqXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU2NoZW1hQm9vbGVhbi5wcm90b3R5cGUuX2Nhc3ROdWxsaXNoID0gZnVuY3Rpb24gX2Nhc3ROdWxsaXNoKHYpIHtcbiAgaWYgKHR5cGVvZiB2ID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiB2O1xuICB9XG4gIGNvbnN0IGNhc3RCb29sZWFuID0gdHlwZW9mIHRoaXMuY29uc3RydWN0b3IuY2FzdCA9PT0gJ2Z1bmN0aW9uJyA/XG4gICAgdGhpcy5jb25zdHJ1Y3Rvci5jYXN0KCkgOlxuICAgIFNjaGVtYUJvb2xlYW4uY2FzdCgpO1xuICBpZiAoY2FzdEJvb2xlYW4gPT0gbnVsbCkge1xuICAgIHJldHVybiB2O1xuICB9XG4gIGlmIChjYXN0Qm9vbGVhbi5jb252ZXJ0VG9GYWxzZSBpbnN0YW5jZW9mIFNldCAmJiBjYXN0Qm9vbGVhbi5jb252ZXJ0VG9GYWxzZS5oYXModikpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKGNhc3RCb29sZWFuLmNvbnZlcnRUb1RydWUgaW5zdGFuY2VvZiBTZXQgJiYgY2FzdEJvb2xlYW4uY29udmVydFRvVHJ1ZS5oYXModikpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gdjtcbn07XG5cbi8qIVxuICogTW9kdWxlIGV4cG9ydHMuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBTY2hlbWFCb29sZWFuO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../server/node_modules/mongoose/lib/schema/boolean.js\n");

/***/ }),

/***/ "../server/node_modules/mongoose/lib/schema/buffer.js":
/*!************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/schema/buffer.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*!\n * Module dependencies.\n */\n\n\n\nconst MongooseBuffer = __webpack_require__(/*! ../types/buffer */ \"../server/node_modules/mongoose/lib/types/buffer.js\");\nconst SchemaBufferOptions = __webpack_require__(/*! ../options/schemaBufferOptions */ \"../server/node_modules/mongoose/lib/options/schemaBufferOptions.js\");\nconst SchemaType = __webpack_require__(/*! ../schemaType */ \"../server/node_modules/mongoose/lib/schemaType.js\");\nconst handleBitwiseOperator = __webpack_require__(/*! ./operators/bitwise */ \"../server/node_modules/mongoose/lib/schema/operators/bitwise.js\");\nconst utils = __webpack_require__(/*! ../utils */ \"../server/node_modules/mongoose/lib/utils.js\");\n\nconst Binary = MongooseBuffer.Binary;\nconst CastError = SchemaType.CastError;\n\n/**\n * Buffer SchemaType constructor\n *\n * @param {String} key\n * @param {Object} options\n * @inherits SchemaType\n * @api public\n */\n\nfunction SchemaBuffer(key, options) {\n  SchemaType.call(this, key, options, 'Buffer');\n}\n\n/**\n * This schema type's name, to defend against minifiers that mangle\n * function names.\n *\n * @api public\n */\nSchemaBuffer.schemaName = 'Buffer';\n\nSchemaBuffer.defaultOptions = {};\n\n/*!\n * Inherits from SchemaType.\n */\nSchemaBuffer.prototype = Object.create(SchemaType.prototype);\nSchemaBuffer.prototype.constructor = SchemaBuffer;\nSchemaBuffer.prototype.OptionsConstructor = SchemaBufferOptions;\n\n/*!\n * ignore\n */\n\nSchemaBuffer._checkRequired = v => !!(v && v.length);\n\n/**\n * Sets a default option for all Buffer instances.\n *\n * #### Example:\n *\n *     // Make all buffers have `required` of true by default.\n *     mongoose.Schema.Buffer.set('required', true);\n *\n *     const User = mongoose.model('User', new Schema({ test: Buffer }));\n *     new User({ }).validateSync().errors.test.message; // Path `test` is required.\n *\n * @param {String} option The option you'd like to set the value for\n * @param {Any} value value for option\n * @return {undefined}\n * @function set\n * @static\n * @api public\n */\n\nSchemaBuffer.set = SchemaType.set;\n\nSchemaBuffer.setters = [];\n\n/**\n * Attaches a getter for all Buffer instances\n *\n * #### Example:\n *\n *     // Always convert to string when getting an ObjectId\n *     mongoose.Schema.Types.Buffer.get(v => v.toString('hex'));\n *\n *     const Model = mongoose.model('Test', new Schema({ buf: Buffer } }));\n *     typeof (new Model({ buf: Buffer.fromString('hello') }).buf); // 'string'\n *\n * @param {Function} getter\n * @return {this}\n * @function get\n * @static\n * @api public\n */\n\nSchemaBuffer.get = SchemaType.get;\n\n/**\n * Override the function the required validator uses to check whether a string\n * passes the `required` check.\n *\n * #### Example:\n *\n *     // Allow empty strings to pass `required` check\n *     mongoose.Schema.Types.String.checkRequired(v => v != null);\n *\n *     const M = mongoose.model({ buf: { type: Buffer, required: true } });\n *     new M({ buf: Buffer.from('') }).validateSync(); // validation passes!\n *\n * @param {Function} fn\n * @return {Function}\n * @function checkRequired\n * @static\n * @api public\n */\n\nSchemaBuffer.checkRequired = SchemaType.checkRequired;\n\n/**\n * Check if the given value satisfies a required validator. To satisfy a\n * required validator, a buffer must not be null or undefined and have\n * non-zero length.\n *\n * @param {Any} value\n * @param {Document} doc\n * @return {Boolean}\n * @api public\n */\n\nSchemaBuffer.prototype.checkRequired = function(value, doc) {\n  if (SchemaType._isRef(this, value, doc, true)) {\n    return !!value;\n  }\n  return this.constructor._checkRequired(value);\n};\n\n/**\n * Casts contents\n *\n * @param {Object} value\n * @param {Document} doc document that triggers the casting\n * @param {Boolean} init\n * @api private\n */\n\nSchemaBuffer.prototype.cast = function(value, doc, init) {\n  let ret;\n  if (SchemaType._isRef(this, value, doc, init)) {\n    if (value && value.isMongooseBuffer) {\n      return value;\n    }\n\n    if (Buffer.isBuffer(value)) {\n      if (!value || !value.isMongooseBuffer) {\n        value = new MongooseBuffer(value, [this.path, doc]);\n        if (this.options.subtype != null) {\n          value._subtype = this.options.subtype;\n        }\n      }\n      return value;\n    }\n\n    if (value instanceof Binary) {\n      ret = new MongooseBuffer(value.value(true), [this.path, doc]);\n      if (typeof value.sub_type !== 'number') {\n        throw new CastError('Buffer', value, this.path, null, this);\n      }\n      ret._subtype = value.sub_type;\n      return ret;\n    }\n\n    if (value == null || utils.isNonBuiltinObject(value)) {\n      return this._castRef(value, doc, init);\n    }\n  }\n\n  // documents\n  if (value && value._id) {\n    value = value._id;\n  }\n\n  if (value && value.isMongooseBuffer) {\n    return value;\n  }\n\n  if (Buffer.isBuffer(value)) {\n    if (!value || !value.isMongooseBuffer) {\n      value = new MongooseBuffer(value, [this.path, doc]);\n      if (this.options.subtype != null) {\n        value._subtype = this.options.subtype;\n      }\n    }\n    return value;\n  }\n\n  if (value instanceof Binary) {\n    ret = new MongooseBuffer(value.value(true), [this.path, doc]);\n    if (typeof value.sub_type !== 'number') {\n      throw new CastError('Buffer', value, this.path, null, this);\n    }\n    ret._subtype = value.sub_type;\n    return ret;\n  }\n\n  if (value === null) {\n    return value;\n  }\n\n\n  const type = typeof value;\n  if (\n    type === 'string' || type === 'number' || Array.isArray(value) ||\n    (type === 'object' && value.type === 'Buffer' && Array.isArray(value.data)) // gh-6863\n  ) {\n    if (type === 'number') {\n      value = [value];\n    }\n    ret = new MongooseBuffer(value, [this.path, doc]);\n    if (this.options.subtype != null) {\n      ret._subtype = this.options.subtype;\n    }\n    return ret;\n  }\n\n  throw new CastError('Buffer', value, this.path, null, this);\n};\n\n/**\n * Sets the default [subtype](https://studio3t.com/whats-new/best-practices-uuid-mongodb/)\n * for this buffer. You can find a [list of allowed subtypes here](https://api.mongodb.com/python/current/api/bson/binary.html).\n *\n * #### Example:\n *\n *     const s = new Schema({ uuid: { type: Buffer, subtype: 4 });\n *     const M = db.model('M', s);\n *     const m = new M({ uuid: 'test string' });\n *     m.uuid._subtype; // 4\n *\n * @param {Number} subtype the default subtype\n * @return {SchemaType} this\n * @api public\n */\n\nSchemaBuffer.prototype.subtype = function(subtype) {\n  this.options.subtype = subtype;\n  return this;\n};\n\n/*!\n * ignore\n */\nfunction handleSingle(val, context) {\n  return this.castForQuery(null, val, context);\n}\n\nSchemaBuffer.prototype.$conditionalHandlers = {\n  ...SchemaType.prototype.$conditionalHandlers,\n  $bitsAllClear: handleBitwiseOperator,\n  $bitsAnyClear: handleBitwiseOperator,\n  $bitsAllSet: handleBitwiseOperator,\n  $bitsAnySet: handleBitwiseOperator,\n  $gt: handleSingle,\n  $gte: handleSingle,\n  $lt: handleSingle,\n  $lte: handleSingle\n};\n\n/**\n * Casts contents for queries.\n *\n * @param {String} $conditional\n * @param {any} [value]\n * @api private\n */\n\nSchemaBuffer.prototype.castForQuery = function($conditional, val, context) {\n  let handler;\n  if ($conditional != null) {\n    handler = this.$conditionalHandlers[$conditional];\n    if (!handler) {\n      throw new Error('Can\\'t use ' + $conditional + ' with Buffer.');\n    }\n    return handler.call(this, val);\n  }\n\n  let casted;\n  try {\n    casted = this.applySetters(val, context);\n  } catch (err) {\n    if (err instanceof CastError && err.path === this.path && this.$fullPath != null) {\n      err.path = this.$fullPath;\n    }\n    throw err;\n  }\n  return casted ? casted.toObject({ transform: false, virtuals: false }) : casted;\n};\n\n/*!\n * Module exports.\n */\n\nmodule.exports = SchemaBuffer;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvc2NoZW1hL2J1ZmZlci5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7O0FBRWE7O0FBRWIsdUJBQXVCLG1CQUFPLENBQUMsNEVBQWlCO0FBQ2hELDRCQUE0QixtQkFBTyxDQUFDLDBHQUFnQztBQUNwRSxtQkFBbUIsbUJBQU8sQ0FBQyx3RUFBZTtBQUMxQyw4QkFBOEIsbUJBQU8sQ0FBQyw0RkFBcUI7QUFDM0QsY0FBYyxtQkFBTyxDQUFDLDhEQUFVOztBQUVoQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0QsY0FBYztBQUN0RSxtQkFBbUIsc0NBQXNDO0FBQ3pEO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsS0FBSztBQUNoQixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCxlQUFlO0FBQ3hFLDJCQUEyQixpQ0FBaUMsUUFBUTtBQUNwRTtBQUNBLFdBQVcsVUFBVTtBQUNyQixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLE9BQU8sZ0NBQWdDO0FBQ3pFLGVBQWUsc0JBQXNCLGtCQUFrQjtBQUN2RDtBQUNBLFdBQVcsVUFBVTtBQUNyQixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLFVBQVU7QUFDckIsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFVBQVU7QUFDckIsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsUUFBUSwwQkFBMEI7QUFDaEU7QUFDQSx5QkFBeUIscUJBQXFCO0FBQzlDLHdCQUF3QjtBQUN4QjtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZLFlBQVk7QUFDeEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxLQUFLO0FBQ2hCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLG1DQUFtQztBQUN2RTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbGllbnQvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvc2NoZW1hL2J1ZmZlci5qcz9mYzQ3Il0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbmNvbnN0IE1vbmdvb3NlQnVmZmVyID0gcmVxdWlyZSgnLi4vdHlwZXMvYnVmZmVyJyk7XG5jb25zdCBTY2hlbWFCdWZmZXJPcHRpb25zID0gcmVxdWlyZSgnLi4vb3B0aW9ucy9zY2hlbWFCdWZmZXJPcHRpb25zJyk7XG5jb25zdCBTY2hlbWFUeXBlID0gcmVxdWlyZSgnLi4vc2NoZW1hVHlwZScpO1xuY29uc3QgaGFuZGxlQml0d2lzZU9wZXJhdG9yID0gcmVxdWlyZSgnLi9vcGVyYXRvcnMvYml0d2lzZScpO1xuY29uc3QgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscycpO1xuXG5jb25zdCBCaW5hcnkgPSBNb25nb29zZUJ1ZmZlci5CaW5hcnk7XG5jb25zdCBDYXN0RXJyb3IgPSBTY2hlbWFUeXBlLkNhc3RFcnJvcjtcblxuLyoqXG4gKiBCdWZmZXIgU2NoZW1hVHlwZSBjb25zdHJ1Y3RvclxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBrZXlcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAaW5oZXJpdHMgU2NoZW1hVHlwZVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBTY2hlbWFCdWZmZXIoa2V5LCBvcHRpb25zKSB7XG4gIFNjaGVtYVR5cGUuY2FsbCh0aGlzLCBrZXksIG9wdGlvbnMsICdCdWZmZXInKTtcbn1cblxuLyoqXG4gKiBUaGlzIHNjaGVtYSB0eXBlJ3MgbmFtZSwgdG8gZGVmZW5kIGFnYWluc3QgbWluaWZpZXJzIHRoYXQgbWFuZ2xlXG4gKiBmdW5jdGlvbiBuYW1lcy5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5TY2hlbWFCdWZmZXIuc2NoZW1hTmFtZSA9ICdCdWZmZXInO1xuXG5TY2hlbWFCdWZmZXIuZGVmYXVsdE9wdGlvbnMgPSB7fTtcblxuLyohXG4gKiBJbmhlcml0cyBmcm9tIFNjaGVtYVR5cGUuXG4gKi9cblNjaGVtYUJ1ZmZlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFNjaGVtYVR5cGUucHJvdG90eXBlKTtcblNjaGVtYUJ1ZmZlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBTY2hlbWFCdWZmZXI7XG5TY2hlbWFCdWZmZXIucHJvdG90eXBlLk9wdGlvbnNDb25zdHJ1Y3RvciA9IFNjaGVtYUJ1ZmZlck9wdGlvbnM7XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxuU2NoZW1hQnVmZmVyLl9jaGVja1JlcXVpcmVkID0gdiA9PiAhISh2ICYmIHYubGVuZ3RoKTtcblxuLyoqXG4gKiBTZXRzIGEgZGVmYXVsdCBvcHRpb24gZm9yIGFsbCBCdWZmZXIgaW5zdGFuY2VzLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgLy8gTWFrZSBhbGwgYnVmZmVycyBoYXZlIGByZXF1aXJlZGAgb2YgdHJ1ZSBieSBkZWZhdWx0LlxuICogICAgIG1vbmdvb3NlLlNjaGVtYS5CdWZmZXIuc2V0KCdyZXF1aXJlZCcsIHRydWUpO1xuICpcbiAqICAgICBjb25zdCBVc2VyID0gbW9uZ29vc2UubW9kZWwoJ1VzZXInLCBuZXcgU2NoZW1hKHsgdGVzdDogQnVmZmVyIH0pKTtcbiAqICAgICBuZXcgVXNlcih7IH0pLnZhbGlkYXRlU3luYygpLmVycm9ycy50ZXN0Lm1lc3NhZ2U7IC8vIFBhdGggYHRlc3RgIGlzIHJlcXVpcmVkLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBvcHRpb24gVGhlIG9wdGlvbiB5b3UnZCBsaWtlIHRvIHNldCB0aGUgdmFsdWUgZm9yXG4gKiBAcGFyYW0ge0FueX0gdmFsdWUgdmFsdWUgZm9yIG9wdGlvblxuICogQHJldHVybiB7dW5kZWZpbmVkfVxuICogQGZ1bmN0aW9uIHNldFxuICogQHN0YXRpY1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5TY2hlbWFCdWZmZXIuc2V0ID0gU2NoZW1hVHlwZS5zZXQ7XG5cblNjaGVtYUJ1ZmZlci5zZXR0ZXJzID0gW107XG5cbi8qKlxuICogQXR0YWNoZXMgYSBnZXR0ZXIgZm9yIGFsbCBCdWZmZXIgaW5zdGFuY2VzXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICAvLyBBbHdheXMgY29udmVydCB0byBzdHJpbmcgd2hlbiBnZXR0aW5nIGFuIE9iamVjdElkXG4gKiAgICAgbW9uZ29vc2UuU2NoZW1hLlR5cGVzLkJ1ZmZlci5nZXQodiA9PiB2LnRvU3RyaW5nKCdoZXgnKSk7XG4gKlxuICogICAgIGNvbnN0IE1vZGVsID0gbW9uZ29vc2UubW9kZWwoJ1Rlc3QnLCBuZXcgU2NoZW1hKHsgYnVmOiBCdWZmZXIgfSB9KSk7XG4gKiAgICAgdHlwZW9mIChuZXcgTW9kZWwoeyBidWY6IEJ1ZmZlci5mcm9tU3RyaW5nKCdoZWxsbycpIH0pLmJ1Zik7IC8vICdzdHJpbmcnXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZ2V0dGVyXG4gKiBAcmV0dXJuIHt0aGlzfVxuICogQGZ1bmN0aW9uIGdldFxuICogQHN0YXRpY1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5TY2hlbWFCdWZmZXIuZ2V0ID0gU2NoZW1hVHlwZS5nZXQ7XG5cbi8qKlxuICogT3ZlcnJpZGUgdGhlIGZ1bmN0aW9uIHRoZSByZXF1aXJlZCB2YWxpZGF0b3IgdXNlcyB0byBjaGVjayB3aGV0aGVyIGEgc3RyaW5nXG4gKiBwYXNzZXMgdGhlIGByZXF1aXJlZGAgY2hlY2suXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICAvLyBBbGxvdyBlbXB0eSBzdHJpbmdzIHRvIHBhc3MgYHJlcXVpcmVkYCBjaGVja1xuICogICAgIG1vbmdvb3NlLlNjaGVtYS5UeXBlcy5TdHJpbmcuY2hlY2tSZXF1aXJlZCh2ID0+IHYgIT0gbnVsbCk7XG4gKlxuICogICAgIGNvbnN0IE0gPSBtb25nb29zZS5tb2RlbCh7IGJ1ZjogeyB0eXBlOiBCdWZmZXIsIHJlcXVpcmVkOiB0cnVlIH0gfSk7XG4gKiAgICAgbmV3IE0oeyBidWY6IEJ1ZmZlci5mcm9tKCcnKSB9KS52YWxpZGF0ZVN5bmMoKTsgLy8gdmFsaWRhdGlvbiBwYXNzZXMhXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICogQGZ1bmN0aW9uIGNoZWNrUmVxdWlyZWRcbiAqIEBzdGF0aWNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuU2NoZW1hQnVmZmVyLmNoZWNrUmVxdWlyZWQgPSBTY2hlbWFUeXBlLmNoZWNrUmVxdWlyZWQ7XG5cbi8qKlxuICogQ2hlY2sgaWYgdGhlIGdpdmVuIHZhbHVlIHNhdGlzZmllcyBhIHJlcXVpcmVkIHZhbGlkYXRvci4gVG8gc2F0aXNmeSBhXG4gKiByZXF1aXJlZCB2YWxpZGF0b3IsIGEgYnVmZmVyIG11c3Qgbm90IGJlIG51bGwgb3IgdW5kZWZpbmVkIGFuZCBoYXZlXG4gKiBub24temVybyBsZW5ndGguXG4gKlxuICogQHBhcmFtIHtBbnl9IHZhbHVlXG4gKiBAcGFyYW0ge0RvY3VtZW50fSBkb2NcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblNjaGVtYUJ1ZmZlci5wcm90b3R5cGUuY2hlY2tSZXF1aXJlZCA9IGZ1bmN0aW9uKHZhbHVlLCBkb2MpIHtcbiAgaWYgKFNjaGVtYVR5cGUuX2lzUmVmKHRoaXMsIHZhbHVlLCBkb2MsIHRydWUpKSB7XG4gICAgcmV0dXJuICEhdmFsdWU7XG4gIH1cbiAgcmV0dXJuIHRoaXMuY29uc3RydWN0b3IuX2NoZWNrUmVxdWlyZWQodmFsdWUpO1xufTtcblxuLyoqXG4gKiBDYXN0cyBjb250ZW50c1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWx1ZVxuICogQHBhcmFtIHtEb2N1bWVudH0gZG9jIGRvY3VtZW50IHRoYXQgdHJpZ2dlcnMgdGhlIGNhc3RpbmdcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gaW5pdFxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU2NoZW1hQnVmZmVyLnByb3RvdHlwZS5jYXN0ID0gZnVuY3Rpb24odmFsdWUsIGRvYywgaW5pdCkge1xuICBsZXQgcmV0O1xuICBpZiAoU2NoZW1hVHlwZS5faXNSZWYodGhpcywgdmFsdWUsIGRvYywgaW5pdCkpIHtcbiAgICBpZiAodmFsdWUgJiYgdmFsdWUuaXNNb25nb29zZUJ1ZmZlcikge1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuICAgIGlmIChCdWZmZXIuaXNCdWZmZXIodmFsdWUpKSB7XG4gICAgICBpZiAoIXZhbHVlIHx8ICF2YWx1ZS5pc01vbmdvb3NlQnVmZmVyKSB7XG4gICAgICAgIHZhbHVlID0gbmV3IE1vbmdvb3NlQnVmZmVyKHZhbHVlLCBbdGhpcy5wYXRoLCBkb2NdKTtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5zdWJ0eXBlICE9IG51bGwpIHtcbiAgICAgICAgICB2YWx1ZS5fc3VidHlwZSA9IHRoaXMub3B0aW9ucy5zdWJ0eXBlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgQmluYXJ5KSB7XG4gICAgICByZXQgPSBuZXcgTW9uZ29vc2VCdWZmZXIodmFsdWUudmFsdWUodHJ1ZSksIFt0aGlzLnBhdGgsIGRvY10pO1xuICAgICAgaWYgKHR5cGVvZiB2YWx1ZS5zdWJfdHlwZSAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgdGhyb3cgbmV3IENhc3RFcnJvcignQnVmZmVyJywgdmFsdWUsIHRoaXMucGF0aCwgbnVsbCwgdGhpcyk7XG4gICAgICB9XG4gICAgICByZXQuX3N1YnR5cGUgPSB2YWx1ZS5zdWJfdHlwZTtcbiAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuXG4gICAgaWYgKHZhbHVlID09IG51bGwgfHwgdXRpbHMuaXNOb25CdWlsdGluT2JqZWN0KHZhbHVlKSkge1xuICAgICAgcmV0dXJuIHRoaXMuX2Nhc3RSZWYodmFsdWUsIGRvYywgaW5pdCk7XG4gICAgfVxuICB9XG5cbiAgLy8gZG9jdW1lbnRzXG4gIGlmICh2YWx1ZSAmJiB2YWx1ZS5faWQpIHtcbiAgICB2YWx1ZSA9IHZhbHVlLl9pZDtcbiAgfVxuXG4gIGlmICh2YWx1ZSAmJiB2YWx1ZS5pc01vbmdvb3NlQnVmZmVyKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG5cbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcih2YWx1ZSkpIHtcbiAgICBpZiAoIXZhbHVlIHx8ICF2YWx1ZS5pc01vbmdvb3NlQnVmZmVyKSB7XG4gICAgICB2YWx1ZSA9IG5ldyBNb25nb29zZUJ1ZmZlcih2YWx1ZSwgW3RoaXMucGF0aCwgZG9jXSk7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLnN1YnR5cGUgIT0gbnVsbCkge1xuICAgICAgICB2YWx1ZS5fc3VidHlwZSA9IHRoaXMub3B0aW9ucy5zdWJ0eXBlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cblxuICBpZiAodmFsdWUgaW5zdGFuY2VvZiBCaW5hcnkpIHtcbiAgICByZXQgPSBuZXcgTW9uZ29vc2VCdWZmZXIodmFsdWUudmFsdWUodHJ1ZSksIFt0aGlzLnBhdGgsIGRvY10pO1xuICAgIGlmICh0eXBlb2YgdmFsdWUuc3ViX3R5cGUgIT09ICdudW1iZXInKSB7XG4gICAgICB0aHJvdyBuZXcgQ2FzdEVycm9yKCdCdWZmZXInLCB2YWx1ZSwgdGhpcy5wYXRoLCBudWxsLCB0aGlzKTtcbiAgICB9XG4gICAgcmV0Ll9zdWJ0eXBlID0gdmFsdWUuc3ViX3R5cGU7XG4gICAgcmV0dXJuIHJldDtcbiAgfVxuXG4gIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuXG5cbiAgY29uc3QgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgaWYgKFxuICAgIHR5cGUgPT09ICdzdHJpbmcnIHx8IHR5cGUgPT09ICdudW1iZXInIHx8IEFycmF5LmlzQXJyYXkodmFsdWUpIHx8XG4gICAgKHR5cGUgPT09ICdvYmplY3QnICYmIHZhbHVlLnR5cGUgPT09ICdCdWZmZXInICYmIEFycmF5LmlzQXJyYXkodmFsdWUuZGF0YSkpIC8vIGdoLTY4NjNcbiAgKSB7XG4gICAgaWYgKHR5cGUgPT09ICdudW1iZXInKSB7XG4gICAgICB2YWx1ZSA9IFt2YWx1ZV07XG4gICAgfVxuICAgIHJldCA9IG5ldyBNb25nb29zZUJ1ZmZlcih2YWx1ZSwgW3RoaXMucGF0aCwgZG9jXSk7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5zdWJ0eXBlICE9IG51bGwpIHtcbiAgICAgIHJldC5fc3VidHlwZSA9IHRoaXMub3B0aW9ucy5zdWJ0eXBlO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xuICB9XG5cbiAgdGhyb3cgbmV3IENhc3RFcnJvcignQnVmZmVyJywgdmFsdWUsIHRoaXMucGF0aCwgbnVsbCwgdGhpcyk7XG59O1xuXG4vKipcbiAqIFNldHMgdGhlIGRlZmF1bHQgW3N1YnR5cGVdKGh0dHBzOi8vc3R1ZGlvM3QuY29tL3doYXRzLW5ldy9iZXN0LXByYWN0aWNlcy11dWlkLW1vbmdvZGIvKVxuICogZm9yIHRoaXMgYnVmZmVyLiBZb3UgY2FuIGZpbmQgYSBbbGlzdCBvZiBhbGxvd2VkIHN1YnR5cGVzIGhlcmVdKGh0dHBzOi8vYXBpLm1vbmdvZGIuY29tL3B5dGhvbi9jdXJyZW50L2FwaS9ic29uL2JpbmFyeS5odG1sKS5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IHMgPSBuZXcgU2NoZW1hKHsgdXVpZDogeyB0eXBlOiBCdWZmZXIsIHN1YnR5cGU6IDQgfSk7XG4gKiAgICAgY29uc3QgTSA9IGRiLm1vZGVsKCdNJywgcyk7XG4gKiAgICAgY29uc3QgbSA9IG5ldyBNKHsgdXVpZDogJ3Rlc3Qgc3RyaW5nJyB9KTtcbiAqICAgICBtLnV1aWQuX3N1YnR5cGU7IC8vIDRcbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gc3VidHlwZSB0aGUgZGVmYXVsdCBzdWJ0eXBlXG4gKiBAcmV0dXJuIHtTY2hlbWFUeXBlfSB0aGlzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblNjaGVtYUJ1ZmZlci5wcm90b3R5cGUuc3VidHlwZSA9IGZ1bmN0aW9uKHN1YnR5cGUpIHtcbiAgdGhpcy5vcHRpb25zLnN1YnR5cGUgPSBzdWJ0eXBlO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qIVxuICogaWdub3JlXG4gKi9cbmZ1bmN0aW9uIGhhbmRsZVNpbmdsZSh2YWwsIGNvbnRleHQpIHtcbiAgcmV0dXJuIHRoaXMuY2FzdEZvclF1ZXJ5KG51bGwsIHZhbCwgY29udGV4dCk7XG59XG5cblNjaGVtYUJ1ZmZlci5wcm90b3R5cGUuJGNvbmRpdGlvbmFsSGFuZGxlcnMgPSB7XG4gIC4uLlNjaGVtYVR5cGUucHJvdG90eXBlLiRjb25kaXRpb25hbEhhbmRsZXJzLFxuICAkYml0c0FsbENsZWFyOiBoYW5kbGVCaXR3aXNlT3BlcmF0b3IsXG4gICRiaXRzQW55Q2xlYXI6IGhhbmRsZUJpdHdpc2VPcGVyYXRvcixcbiAgJGJpdHNBbGxTZXQ6IGhhbmRsZUJpdHdpc2VPcGVyYXRvcixcbiAgJGJpdHNBbnlTZXQ6IGhhbmRsZUJpdHdpc2VPcGVyYXRvcixcbiAgJGd0OiBoYW5kbGVTaW5nbGUsXG4gICRndGU6IGhhbmRsZVNpbmdsZSxcbiAgJGx0OiBoYW5kbGVTaW5nbGUsXG4gICRsdGU6IGhhbmRsZVNpbmdsZVxufTtcblxuLyoqXG4gKiBDYXN0cyBjb250ZW50cyBmb3IgcXVlcmllcy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gJGNvbmRpdGlvbmFsXG4gKiBAcGFyYW0ge2FueX0gW3ZhbHVlXVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU2NoZW1hQnVmZmVyLnByb3RvdHlwZS5jYXN0Rm9yUXVlcnkgPSBmdW5jdGlvbigkY29uZGl0aW9uYWwsIHZhbCwgY29udGV4dCkge1xuICBsZXQgaGFuZGxlcjtcbiAgaWYgKCRjb25kaXRpb25hbCAhPSBudWxsKSB7XG4gICAgaGFuZGxlciA9IHRoaXMuJGNvbmRpdGlvbmFsSGFuZGxlcnNbJGNvbmRpdGlvbmFsXTtcbiAgICBpZiAoIWhhbmRsZXIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ2FuXFwndCB1c2UgJyArICRjb25kaXRpb25hbCArICcgd2l0aCBCdWZmZXIuJyk7XG4gICAgfVxuICAgIHJldHVybiBoYW5kbGVyLmNhbGwodGhpcywgdmFsKTtcbiAgfVxuXG4gIGxldCBjYXN0ZWQ7XG4gIHRyeSB7XG4gICAgY2FzdGVkID0gdGhpcy5hcHBseVNldHRlcnModmFsLCBjb250ZXh0KTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgaWYgKGVyciBpbnN0YW5jZW9mIENhc3RFcnJvciAmJiBlcnIucGF0aCA9PT0gdGhpcy5wYXRoICYmIHRoaXMuJGZ1bGxQYXRoICE9IG51bGwpIHtcbiAgICAgIGVyci5wYXRoID0gdGhpcy4kZnVsbFBhdGg7XG4gICAgfVxuICAgIHRocm93IGVycjtcbiAgfVxuICByZXR1cm4gY2FzdGVkID8gY2FzdGVkLnRvT2JqZWN0KHsgdHJhbnNmb3JtOiBmYWxzZSwgdmlydHVhbHM6IGZhbHNlIH0pIDogY2FzdGVkO1xufTtcblxuLyohXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNjaGVtYUJ1ZmZlcjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../server/node_modules/mongoose/lib/schema/buffer.js\n");

/***/ }),

/***/ "../server/node_modules/mongoose/lib/schema/date.js":
/*!**********************************************************!*\
  !*** ../server/node_modules/mongoose/lib/schema/date.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*!\n * Module requirements.\n */\n\n\n\nconst MongooseError = __webpack_require__(/*! ../error/index */ \"../server/node_modules/mongoose/lib/error/index.js\");\nconst SchemaDateOptions = __webpack_require__(/*! ../options/schemaDateOptions */ \"../server/node_modules/mongoose/lib/options/schemaDateOptions.js\");\nconst SchemaType = __webpack_require__(/*! ../schemaType */ \"../server/node_modules/mongoose/lib/schemaType.js\");\nconst castDate = __webpack_require__(/*! ../cast/date */ \"../server/node_modules/mongoose/lib/cast/date.js\");\nconst getConstructorName = __webpack_require__(/*! ../helpers/getConstructorName */ \"../server/node_modules/mongoose/lib/helpers/getConstructorName.js\");\nconst utils = __webpack_require__(/*! ../utils */ \"../server/node_modules/mongoose/lib/utils.js\");\n\nconst CastError = SchemaType.CastError;\n\n/**\n * Date SchemaType constructor.\n *\n * @param {String} key\n * @param {Object} options\n * @inherits SchemaType\n * @api public\n */\n\nfunction SchemaDate(key, options) {\n  SchemaType.call(this, key, options, 'Date');\n}\n\n/**\n * This schema type's name, to defend against minifiers that mangle\n * function names.\n *\n * @api public\n */\nSchemaDate.schemaName = 'Date';\n\nSchemaDate.defaultOptions = {};\n\n/*!\n * Inherits from SchemaType.\n */\nSchemaDate.prototype = Object.create(SchemaType.prototype);\nSchemaDate.prototype.constructor = SchemaDate;\nSchemaDate.prototype.OptionsConstructor = SchemaDateOptions;\n\n/*!\n * ignore\n */\n\nSchemaDate._cast = castDate;\n\n/**\n * Sets a default option for all Date instances.\n *\n * #### Example:\n *\n *     // Make all dates have `required` of true by default.\n *     mongoose.Schema.Date.set('required', true);\n *\n *     const User = mongoose.model('User', new Schema({ test: Date }));\n *     new User({ }).validateSync().errors.test.message; // Path `test` is required.\n *\n * @param {String} option The option you'd like to set the value for\n * @param {Any} value value for option\n * @return {undefined}\n * @function set\n * @static\n * @api public\n */\n\nSchemaDate.set = SchemaType.set;\n\nSchemaDate.setters = [];\n\n/**\n * Attaches a getter for all Date instances\n *\n * #### Example:\n *\n *     // Always convert Dates to string\n *     mongoose.Date.get(v => v.toString());\n *\n *     const Model = mongoose.model('Test', new Schema({ date: { type: Date, default: () => new Date() } }));\n *     typeof (new Model({}).date); // 'string'\n *\n * @param {Function} getter\n * @return {this}\n * @function get\n * @static\n * @api public\n */\n\nSchemaDate.get = SchemaType.get;\n\n/**\n * Get/set the function used to cast arbitrary values to dates.\n *\n * #### Example:\n *\n *     // Mongoose converts empty string '' into `null` for date types. You\n *     // can create a custom caster to disable it.\n *     const original = mongoose.Schema.Types.Date.cast();\n *     mongoose.Schema.Types.Date.cast(v => {\n *       assert.ok(v !== '');\n *       return original(v);\n *     });\n *\n *     // Or disable casting entirely\n *     mongoose.Schema.Types.Date.cast(false);\n *\n * @param {Function} caster\n * @return {Function}\n * @function get\n * @static\n * @api public\n */\n\nSchemaDate.cast = function cast(caster) {\n  if (arguments.length === 0) {\n    return this._cast;\n  }\n  if (caster === false) {\n    caster = this._defaultCaster;\n  }\n  this._cast = caster;\n\n  return this._cast;\n};\n\n/*!\n * ignore\n */\n\nSchemaDate._defaultCaster = v => {\n  if (v != null && !(v instanceof Date)) {\n    throw new Error();\n  }\n  return v;\n};\n\n/**\n * Declares a TTL index (rounded to the nearest second) for _Date_ types only.\n *\n * This sets the `expireAfterSeconds` index option available in MongoDB >= 2.1.2.\n * This index type is only compatible with Date types.\n *\n * #### Example:\n *\n *     // expire in 24 hours\n *     new Schema({ createdAt: { type: Date, expires: 60*60*24 }});\n *\n * `expires` utilizes the `ms` module from [guille](https://github.com/guille/) allowing us to use a friendlier syntax:\n *\n * #### Example:\n *\n *     // expire in 24 hours\n *     new Schema({ createdAt: { type: Date, expires: '24h' }});\n *\n *     // expire in 1.5 hours\n *     new Schema({ createdAt: { type: Date, expires: '1.5h' }});\n *\n *     // expire in 7 days\n *     const schema = new Schema({ createdAt: Date });\n *     schema.path('createdAt').expires('7d');\n *\n * @param {Number|String} when\n * @added 3.0.0\n * @return {SchemaType} this\n * @api public\n */\n\nSchemaDate.prototype.expires = function(when) {\n  if (getConstructorName(this._index) !== 'Object') {\n    this._index = {};\n  }\n\n  this._index.expires = when;\n  utils.expires(this._index);\n  return this;\n};\n\n/*!\n * ignore\n */\n\nSchemaDate._checkRequired = v => v instanceof Date;\n\n/**\n * Override the function the required validator uses to check whether a string\n * passes the `required` check.\n *\n * #### Example:\n *\n *     // Allow empty strings to pass `required` check\n *     mongoose.Schema.Types.String.checkRequired(v => v != null);\n *\n *     const M = mongoose.model({ str: { type: String, required: true } });\n *     new M({ str: '' }).validateSync(); // `null`, validation passes!\n *\n * @param {Function} fn\n * @return {Function}\n * @function checkRequired\n * @static\n * @api public\n */\n\nSchemaDate.checkRequired = SchemaType.checkRequired;\n\n/**\n * Check if the given value satisfies a required validator. To satisfy\n * a required validator, the given value must be an instance of `Date`.\n *\n * @param {Any} value\n * @param {Document} doc\n * @return {Boolean}\n * @api public\n */\n\nSchemaDate.prototype.checkRequired = function(value, doc) {\n  if (typeof value === 'object' && SchemaType._isRef(this, value, doc, true)) {\n    return value != null;\n  }\n\n  // `require('util').inherits()` does **not** copy static properties, and\n  // plugins like mongoose-float use `inherits()` for pre-ES6.\n  const _checkRequired = typeof this.constructor.checkRequired === 'function' ?\n    this.constructor.checkRequired() :\n    SchemaDate.checkRequired();\n  return _checkRequired(value);\n};\n\n/**\n * Sets a minimum date validator.\n *\n * #### Example:\n *\n *     const s = new Schema({ d: { type: Date, min: Date('1970-01-01') })\n *     const M = db.model('M', s)\n *     const m = new M({ d: Date('1969-12-31') })\n *     m.save(function (err) {\n *       console.error(err) // validator error\n *       m.d = Date('2014-12-08');\n *       m.save() // success\n *     })\n *\n *     // custom error messages\n *     // We can also use the special {MIN} token which will be replaced with the invalid value\n *     const min = [Date('1970-01-01'), 'The value of path `{PATH}` ({VALUE}) is beneath the limit ({MIN}).'];\n *     const schema = new Schema({ d: { type: Date, min: min })\n *     const M = mongoose.model('M', schema);\n *     const s= new M({ d: Date('1969-12-31') });\n *     s.validate(function (err) {\n *       console.log(String(err)) // ValidationError: The value of path `d` (1969-12-31) is before the limit (1970-01-01).\n *     })\n *\n * @param {Date} value minimum date\n * @param {String} [message] optional custom error message\n * @return {SchemaType} this\n * @see Customized Error Messages https://mongoosejs.com/docs/api/error.html#Error.messages\n * @api public\n */\n\nSchemaDate.prototype.min = function(value, message) {\n  if (this.minValidator) {\n    this.validators = this.validators.filter(function(v) {\n      return v.validator !== this.minValidator;\n    }, this);\n  }\n\n  if (value) {\n    let msg = message || MongooseError.messages.Date.min;\n    if (typeof msg === 'string') {\n      msg = msg.replace(/{MIN}/, (value === Date.now ? 'Date.now()' : value.toString()));\n    }\n    const _this = this;\n    this.validators.push({\n      validator: this.minValidator = function(val) {\n        let _value = value;\n        if (typeof value === 'function' && value !== Date.now) {\n          _value = _value.call(this);\n        }\n        const min = (_value === Date.now ? _value() : _this.cast(_value));\n        return val === null || val.valueOf() >= min.valueOf();\n      },\n      message: msg,\n      type: 'min',\n      min: value\n    });\n  }\n\n  return this;\n};\n\n/**\n * Sets a maximum date validator.\n *\n * #### Example:\n *\n *     const s = new Schema({ d: { type: Date, max: Date('2014-01-01') })\n *     const M = db.model('M', s)\n *     const m = new M({ d: Date('2014-12-08') })\n *     m.save(function (err) {\n *       console.error(err) // validator error\n *       m.d = Date('2013-12-31');\n *       m.save() // success\n *     })\n *\n *     // custom error messages\n *     // We can also use the special {MAX} token which will be replaced with the invalid value\n *     const max = [Date('2014-01-01'), 'The value of path `{PATH}` ({VALUE}) exceeds the limit ({MAX}).'];\n *     const schema = new Schema({ d: { type: Date, max: max })\n *     const M = mongoose.model('M', schema);\n *     const s= new M({ d: Date('2014-12-08') });\n *     s.validate(function (err) {\n *       console.log(String(err)) // ValidationError: The value of path `d` (2014-12-08) exceeds the limit (2014-01-01).\n *     })\n *\n * @param {Date} maximum date\n * @param {String} [message] optional custom error message\n * @return {SchemaType} this\n * @see Customized Error Messages https://mongoosejs.com/docs/api/error.html#Error.messages\n * @api public\n */\n\nSchemaDate.prototype.max = function(value, message) {\n  if (this.maxValidator) {\n    this.validators = this.validators.filter(function(v) {\n      return v.validator !== this.maxValidator;\n    }, this);\n  }\n\n  if (value) {\n    let msg = message || MongooseError.messages.Date.max;\n    if (typeof msg === 'string') {\n      msg = msg.replace(/{MAX}/, (value === Date.now ? 'Date.now()' : value.toString()));\n    }\n    const _this = this;\n    this.validators.push({\n      validator: this.maxValidator = function(val) {\n        let _value = value;\n        if (typeof _value === 'function' && _value !== Date.now) {\n          _value = _value.call(this);\n        }\n        const max = (_value === Date.now ? _value() : _this.cast(_value));\n        return val === null || val.valueOf() <= max.valueOf();\n      },\n      message: msg,\n      type: 'max',\n      max: value\n    });\n  }\n\n  return this;\n};\n\n/**\n * Casts to date\n *\n * @param {Object} value to cast\n * @api private\n */\n\nSchemaDate.prototype.cast = function(value) {\n  let castDate;\n  if (typeof this._castFunction === 'function') {\n    castDate = this._castFunction;\n  } else if (typeof this.constructor.cast === 'function') {\n    castDate = this.constructor.cast();\n  } else {\n    castDate = SchemaDate.cast();\n  }\n\n  try {\n    return castDate(value);\n  } catch (error) {\n    throw new CastError('date', value, this.path, error, this);\n  }\n};\n\n/**\n * Date Query casting.\n *\n * @param {Any} val\n * @api private\n */\n\nfunction handleSingle(val) {\n  return this.cast(val);\n}\n\nSchemaDate.prototype.$conditionalHandlers = {\n  ...SchemaType.prototype.$conditionalHandlers,\n  $gt: handleSingle,\n  $gte: handleSingle,\n  $lt: handleSingle,\n  $lte: handleSingle\n};\n\n\n/**\n * Casts contents for queries.\n *\n * @param {String} $conditional\n * @param {any} [value]\n * @api private\n */\n\nSchemaDate.prototype.castForQuery = function($conditional, val, context) {\n  if ($conditional == null) {\n    try {\n      return this.applySetters(val, context);\n    } catch (err) {\n      if (err instanceof CastError && err.path === this.path && this.$fullPath != null) {\n        err.path = this.$fullPath;\n      }\n      throw err;\n    }\n  }\n\n  const handler = this.$conditionalHandlers[$conditional];\n\n  if (!handler) {\n    throw new Error('Can\\'t use ' + $conditional + ' with Date.');\n  }\n\n  return handler.call(this, val);\n};\n\n/*!\n * Module exports.\n */\n\nmodule.exports = SchemaDate;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvc2NoZW1hL2RhdGUuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBOztBQUVhOztBQUViLHNCQUFzQixtQkFBTyxDQUFDLDBFQUFnQjtBQUM5QywwQkFBMEIsbUJBQU8sQ0FBQyxzR0FBOEI7QUFDaEUsbUJBQW1CLG1CQUFPLENBQUMsd0VBQWU7QUFDMUMsaUJBQWlCLG1CQUFPLENBQUMsc0VBQWM7QUFDdkMsMkJBQTJCLG1CQUFPLENBQUMsd0dBQStCO0FBQ2xFLGNBQWMsbUJBQU8sQ0FBQyw4REFBVTs7QUFFaEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCxZQUFZO0FBQ3BFLG1CQUFtQixzQ0FBc0M7QUFDekQ7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxLQUFLO0FBQ2hCLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlELFFBQVEseUNBQXlDO0FBQzFHLDJCQUEyQixTQUFTO0FBQ3BDO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7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QTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxLQUFLO0FBQ2hCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL2NsaWVudC8uLi9zZXJ2ZXIvbm9kZV9tb2R1bGVzL21vbmdvb3NlL2xpYi9zY2hlbWEvZGF0ZS5qcz9iYmY5Il0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogTW9kdWxlIHJlcXVpcmVtZW50cy5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbmNvbnN0IE1vbmdvb3NlRXJyb3IgPSByZXF1aXJlKCcuLi9lcnJvci9pbmRleCcpO1xuY29uc3QgU2NoZW1hRGF0ZU9wdGlvbnMgPSByZXF1aXJlKCcuLi9vcHRpb25zL3NjaGVtYURhdGVPcHRpb25zJyk7XG5jb25zdCBTY2hlbWFUeXBlID0gcmVxdWlyZSgnLi4vc2NoZW1hVHlwZScpO1xuY29uc3QgY2FzdERhdGUgPSByZXF1aXJlKCcuLi9jYXN0L2RhdGUnKTtcbmNvbnN0IGdldENvbnN0cnVjdG9yTmFtZSA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvZ2V0Q29uc3RydWN0b3JOYW1lJyk7XG5jb25zdCB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzJyk7XG5cbmNvbnN0IENhc3RFcnJvciA9IFNjaGVtYVR5cGUuQ2FzdEVycm9yO1xuXG4vKipcbiAqIERhdGUgU2NoZW1hVHlwZSBjb25zdHJ1Y3Rvci5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30ga2V5XG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQGluaGVyaXRzIFNjaGVtYVR5cGVcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gU2NoZW1hRGF0ZShrZXksIG9wdGlvbnMpIHtcbiAgU2NoZW1hVHlwZS5jYWxsKHRoaXMsIGtleSwgb3B0aW9ucywgJ0RhdGUnKTtcbn1cblxuLyoqXG4gKiBUaGlzIHNjaGVtYSB0eXBlJ3MgbmFtZSwgdG8gZGVmZW5kIGFnYWluc3QgbWluaWZpZXJzIHRoYXQgbWFuZ2xlXG4gKiBmdW5jdGlvbiBuYW1lcy5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5TY2hlbWFEYXRlLnNjaGVtYU5hbWUgPSAnRGF0ZSc7XG5cblNjaGVtYURhdGUuZGVmYXVsdE9wdGlvbnMgPSB7fTtcblxuLyohXG4gKiBJbmhlcml0cyBmcm9tIFNjaGVtYVR5cGUuXG4gKi9cblNjaGVtYURhdGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShTY2hlbWFUeXBlLnByb3RvdHlwZSk7XG5TY2hlbWFEYXRlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFNjaGVtYURhdGU7XG5TY2hlbWFEYXRlLnByb3RvdHlwZS5PcHRpb25zQ29uc3RydWN0b3IgPSBTY2hlbWFEYXRlT3B0aW9ucztcblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5TY2hlbWFEYXRlLl9jYXN0ID0gY2FzdERhdGU7XG5cbi8qKlxuICogU2V0cyBhIGRlZmF1bHQgb3B0aW9uIGZvciBhbGwgRGF0ZSBpbnN0YW5jZXMuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICAvLyBNYWtlIGFsbCBkYXRlcyBoYXZlIGByZXF1aXJlZGAgb2YgdHJ1ZSBieSBkZWZhdWx0LlxuICogICAgIG1vbmdvb3NlLlNjaGVtYS5EYXRlLnNldCgncmVxdWlyZWQnLCB0cnVlKTtcbiAqXG4gKiAgICAgY29uc3QgVXNlciA9IG1vbmdvb3NlLm1vZGVsKCdVc2VyJywgbmV3IFNjaGVtYSh7IHRlc3Q6IERhdGUgfSkpO1xuICogICAgIG5ldyBVc2VyKHsgfSkudmFsaWRhdGVTeW5jKCkuZXJyb3JzLnRlc3QubWVzc2FnZTsgLy8gUGF0aCBgdGVzdGAgaXMgcmVxdWlyZWQuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG9wdGlvbiBUaGUgb3B0aW9uIHlvdSdkIGxpa2UgdG8gc2V0IHRoZSB2YWx1ZSBmb3JcbiAqIEBwYXJhbSB7QW55fSB2YWx1ZSB2YWx1ZSBmb3Igb3B0aW9uXG4gKiBAcmV0dXJuIHt1bmRlZmluZWR9XG4gKiBAZnVuY3Rpb24gc2V0XG4gKiBAc3RhdGljXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblNjaGVtYURhdGUuc2V0ID0gU2NoZW1hVHlwZS5zZXQ7XG5cblNjaGVtYURhdGUuc2V0dGVycyA9IFtdO1xuXG4vKipcbiAqIEF0dGFjaGVzIGEgZ2V0dGVyIGZvciBhbGwgRGF0ZSBpbnN0YW5jZXNcbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIC8vIEFsd2F5cyBjb252ZXJ0IERhdGVzIHRvIHN0cmluZ1xuICogICAgIG1vbmdvb3NlLkRhdGUuZ2V0KHYgPT4gdi50b1N0cmluZygpKTtcbiAqXG4gKiAgICAgY29uc3QgTW9kZWwgPSBtb25nb29zZS5tb2RlbCgnVGVzdCcsIG5ldyBTY2hlbWEoeyBkYXRlOiB7IHR5cGU6IERhdGUsIGRlZmF1bHQ6ICgpID0+IG5ldyBEYXRlKCkgfSB9KSk7XG4gKiAgICAgdHlwZW9mIChuZXcgTW9kZWwoe30pLmRhdGUpOyAvLyAnc3RyaW5nJ1xuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGdldHRlclxuICogQHJldHVybiB7dGhpc31cbiAqIEBmdW5jdGlvbiBnZXRcbiAqIEBzdGF0aWNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuU2NoZW1hRGF0ZS5nZXQgPSBTY2hlbWFUeXBlLmdldDtcblxuLyoqXG4gKiBHZXQvc2V0IHRoZSBmdW5jdGlvbiB1c2VkIHRvIGNhc3QgYXJiaXRyYXJ5IHZhbHVlcyB0byBkYXRlcy5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIC8vIE1vbmdvb3NlIGNvbnZlcnRzIGVtcHR5IHN0cmluZyAnJyBpbnRvIGBudWxsYCBmb3IgZGF0ZSB0eXBlcy4gWW91XG4gKiAgICAgLy8gY2FuIGNyZWF0ZSBhIGN1c3RvbSBjYXN0ZXIgdG8gZGlzYWJsZSBpdC5cbiAqICAgICBjb25zdCBvcmlnaW5hbCA9IG1vbmdvb3NlLlNjaGVtYS5UeXBlcy5EYXRlLmNhc3QoKTtcbiAqICAgICBtb25nb29zZS5TY2hlbWEuVHlwZXMuRGF0ZS5jYXN0KHYgPT4ge1xuICogICAgICAgYXNzZXJ0Lm9rKHYgIT09ICcnKTtcbiAqICAgICAgIHJldHVybiBvcmlnaW5hbCh2KTtcbiAqICAgICB9KTtcbiAqXG4gKiAgICAgLy8gT3IgZGlzYWJsZSBjYXN0aW5nIGVudGlyZWx5XG4gKiAgICAgbW9uZ29vc2UuU2NoZW1hLlR5cGVzLkRhdGUuY2FzdChmYWxzZSk7XG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FzdGVyXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAqIEBmdW5jdGlvbiBnZXRcbiAqIEBzdGF0aWNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuU2NoZW1hRGF0ZS5jYXN0ID0gZnVuY3Rpb24gY2FzdChjYXN0ZXIpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gdGhpcy5fY2FzdDtcbiAgfVxuICBpZiAoY2FzdGVyID09PSBmYWxzZSkge1xuICAgIGNhc3RlciA9IHRoaXMuX2RlZmF1bHRDYXN0ZXI7XG4gIH1cbiAgdGhpcy5fY2FzdCA9IGNhc3RlcjtcblxuICByZXR1cm4gdGhpcy5fY2FzdDtcbn07XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxuU2NoZW1hRGF0ZS5fZGVmYXVsdENhc3RlciA9IHYgPT4ge1xuICBpZiAodiAhPSBudWxsICYmICEodiBpbnN0YW5jZW9mIERhdGUpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCk7XG4gIH1cbiAgcmV0dXJuIHY7XG59O1xuXG4vKipcbiAqIERlY2xhcmVzIGEgVFRMIGluZGV4IChyb3VuZGVkIHRvIHRoZSBuZWFyZXN0IHNlY29uZCkgZm9yIF9EYXRlXyB0eXBlcyBvbmx5LlxuICpcbiAqIFRoaXMgc2V0cyB0aGUgYGV4cGlyZUFmdGVyU2Vjb25kc2AgaW5kZXggb3B0aW9uIGF2YWlsYWJsZSBpbiBNb25nb0RCID49IDIuMS4yLlxuICogVGhpcyBpbmRleCB0eXBlIGlzIG9ubHkgY29tcGF0aWJsZSB3aXRoIERhdGUgdHlwZXMuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICAvLyBleHBpcmUgaW4gMjQgaG91cnNcbiAqICAgICBuZXcgU2NoZW1hKHsgY3JlYXRlZEF0OiB7IHR5cGU6IERhdGUsIGV4cGlyZXM6IDYwKjYwKjI0IH19KTtcbiAqXG4gKiBgZXhwaXJlc2AgdXRpbGl6ZXMgdGhlIGBtc2AgbW9kdWxlIGZyb20gW2d1aWxsZV0oaHR0cHM6Ly9naXRodWIuY29tL2d1aWxsZS8pIGFsbG93aW5nIHVzIHRvIHVzZSBhIGZyaWVuZGxpZXIgc3ludGF4OlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgLy8gZXhwaXJlIGluIDI0IGhvdXJzXG4gKiAgICAgbmV3IFNjaGVtYSh7IGNyZWF0ZWRBdDogeyB0eXBlOiBEYXRlLCBleHBpcmVzOiAnMjRoJyB9fSk7XG4gKlxuICogICAgIC8vIGV4cGlyZSBpbiAxLjUgaG91cnNcbiAqICAgICBuZXcgU2NoZW1hKHsgY3JlYXRlZEF0OiB7IHR5cGU6IERhdGUsIGV4cGlyZXM6ICcxLjVoJyB9fSk7XG4gKlxuICogICAgIC8vIGV4cGlyZSBpbiA3IGRheXNcbiAqICAgICBjb25zdCBzY2hlbWEgPSBuZXcgU2NoZW1hKHsgY3JlYXRlZEF0OiBEYXRlIH0pO1xuICogICAgIHNjaGVtYS5wYXRoKCdjcmVhdGVkQXQnKS5leHBpcmVzKCc3ZCcpO1xuICpcbiAqIEBwYXJhbSB7TnVtYmVyfFN0cmluZ30gd2hlblxuICogQGFkZGVkIDMuMC4wXG4gKiBAcmV0dXJuIHtTY2hlbWFUeXBlfSB0aGlzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblNjaGVtYURhdGUucHJvdG90eXBlLmV4cGlyZXMgPSBmdW5jdGlvbih3aGVuKSB7XG4gIGlmIChnZXRDb25zdHJ1Y3Rvck5hbWUodGhpcy5faW5kZXgpICE9PSAnT2JqZWN0Jykge1xuICAgIHRoaXMuX2luZGV4ID0ge307XG4gIH1cblxuICB0aGlzLl9pbmRleC5leHBpcmVzID0gd2hlbjtcbiAgdXRpbHMuZXhwaXJlcyh0aGlzLl9pbmRleCk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5TY2hlbWFEYXRlLl9jaGVja1JlcXVpcmVkID0gdiA9PiB2IGluc3RhbmNlb2YgRGF0ZTtcblxuLyoqXG4gKiBPdmVycmlkZSB0aGUgZnVuY3Rpb24gdGhlIHJlcXVpcmVkIHZhbGlkYXRvciB1c2VzIHRvIGNoZWNrIHdoZXRoZXIgYSBzdHJpbmdcbiAqIHBhc3NlcyB0aGUgYHJlcXVpcmVkYCBjaGVjay5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIC8vIEFsbG93IGVtcHR5IHN0cmluZ3MgdG8gcGFzcyBgcmVxdWlyZWRgIGNoZWNrXG4gKiAgICAgbW9uZ29vc2UuU2NoZW1hLlR5cGVzLlN0cmluZy5jaGVja1JlcXVpcmVkKHYgPT4gdiAhPSBudWxsKTtcbiAqXG4gKiAgICAgY29uc3QgTSA9IG1vbmdvb3NlLm1vZGVsKHsgc3RyOiB7IHR5cGU6IFN0cmluZywgcmVxdWlyZWQ6IHRydWUgfSB9KTtcbiAqICAgICBuZXcgTSh7IHN0cjogJycgfSkudmFsaWRhdGVTeW5jKCk7IC8vIGBudWxsYCwgdmFsaWRhdGlvbiBwYXNzZXMhXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICogQGZ1bmN0aW9uIGNoZWNrUmVxdWlyZWRcbiAqIEBzdGF0aWNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuU2NoZW1hRGF0ZS5jaGVja1JlcXVpcmVkID0gU2NoZW1hVHlwZS5jaGVja1JlcXVpcmVkO1xuXG4vKipcbiAqIENoZWNrIGlmIHRoZSBnaXZlbiB2YWx1ZSBzYXRpc2ZpZXMgYSByZXF1aXJlZCB2YWxpZGF0b3IuIFRvIHNhdGlzZnlcbiAqIGEgcmVxdWlyZWQgdmFsaWRhdG9yLCB0aGUgZ2l2ZW4gdmFsdWUgbXVzdCBiZSBhbiBpbnN0YW5jZSBvZiBgRGF0ZWAuXG4gKlxuICogQHBhcmFtIHtBbnl9IHZhbHVlXG4gKiBAcGFyYW0ge0RvY3VtZW50fSBkb2NcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblNjaGVtYURhdGUucHJvdG90eXBlLmNoZWNrUmVxdWlyZWQgPSBmdW5jdGlvbih2YWx1ZSwgZG9jKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIFNjaGVtYVR5cGUuX2lzUmVmKHRoaXMsIHZhbHVlLCBkb2MsIHRydWUpKSB7XG4gICAgcmV0dXJuIHZhbHVlICE9IG51bGw7XG4gIH1cblxuICAvLyBgcmVxdWlyZSgndXRpbCcpLmluaGVyaXRzKClgIGRvZXMgKipub3QqKiBjb3B5IHN0YXRpYyBwcm9wZXJ0aWVzLCBhbmRcbiAgLy8gcGx1Z2lucyBsaWtlIG1vbmdvb3NlLWZsb2F0IHVzZSBgaW5oZXJpdHMoKWAgZm9yIHByZS1FUzYuXG4gIGNvbnN0IF9jaGVja1JlcXVpcmVkID0gdHlwZW9mIHRoaXMuY29uc3RydWN0b3IuY2hlY2tSZXF1aXJlZCA9PT0gJ2Z1bmN0aW9uJyA/XG4gICAgdGhpcy5jb25zdHJ1Y3Rvci5jaGVja1JlcXVpcmVkKCkgOlxuICAgIFNjaGVtYURhdGUuY2hlY2tSZXF1aXJlZCgpO1xuICByZXR1cm4gX2NoZWNrUmVxdWlyZWQodmFsdWUpO1xufTtcblxuLyoqXG4gKiBTZXRzIGEgbWluaW11bSBkYXRlIHZhbGlkYXRvci5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IHMgPSBuZXcgU2NoZW1hKHsgZDogeyB0eXBlOiBEYXRlLCBtaW46IERhdGUoJzE5NzAtMDEtMDEnKSB9KVxuICogICAgIGNvbnN0IE0gPSBkYi5tb2RlbCgnTScsIHMpXG4gKiAgICAgY29uc3QgbSA9IG5ldyBNKHsgZDogRGF0ZSgnMTk2OS0xMi0zMScpIH0pXG4gKiAgICAgbS5zYXZlKGZ1bmN0aW9uIChlcnIpIHtcbiAqICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyKSAvLyB2YWxpZGF0b3IgZXJyb3JcbiAqICAgICAgIG0uZCA9IERhdGUoJzIwMTQtMTItMDgnKTtcbiAqICAgICAgIG0uc2F2ZSgpIC8vIHN1Y2Nlc3NcbiAqICAgICB9KVxuICpcbiAqICAgICAvLyBjdXN0b20gZXJyb3IgbWVzc2FnZXNcbiAqICAgICAvLyBXZSBjYW4gYWxzbyB1c2UgdGhlIHNwZWNpYWwge01JTn0gdG9rZW4gd2hpY2ggd2lsbCBiZSByZXBsYWNlZCB3aXRoIHRoZSBpbnZhbGlkIHZhbHVlXG4gKiAgICAgY29uc3QgbWluID0gW0RhdGUoJzE5NzAtMDEtMDEnKSwgJ1RoZSB2YWx1ZSBvZiBwYXRoIGB7UEFUSH1gICh7VkFMVUV9KSBpcyBiZW5lYXRoIHRoZSBsaW1pdCAoe01JTn0pLiddO1xuICogICAgIGNvbnN0IHNjaGVtYSA9IG5ldyBTY2hlbWEoeyBkOiB7IHR5cGU6IERhdGUsIG1pbjogbWluIH0pXG4gKiAgICAgY29uc3QgTSA9IG1vbmdvb3NlLm1vZGVsKCdNJywgc2NoZW1hKTtcbiAqICAgICBjb25zdCBzPSBuZXcgTSh7IGQ6IERhdGUoJzE5NjktMTItMzEnKSB9KTtcbiAqICAgICBzLnZhbGlkYXRlKGZ1bmN0aW9uIChlcnIpIHtcbiAqICAgICAgIGNvbnNvbGUubG9nKFN0cmluZyhlcnIpKSAvLyBWYWxpZGF0aW9uRXJyb3I6IFRoZSB2YWx1ZSBvZiBwYXRoIGBkYCAoMTk2OS0xMi0zMSkgaXMgYmVmb3JlIHRoZSBsaW1pdCAoMTk3MC0wMS0wMSkuXG4gKiAgICAgfSlcbiAqXG4gKiBAcGFyYW0ge0RhdGV9IHZhbHVlIG1pbmltdW0gZGF0ZVxuICogQHBhcmFtIHtTdHJpbmd9IFttZXNzYWdlXSBvcHRpb25hbCBjdXN0b20gZXJyb3IgbWVzc2FnZVxuICogQHJldHVybiB7U2NoZW1hVHlwZX0gdGhpc1xuICogQHNlZSBDdXN0b21pemVkIEVycm9yIE1lc3NhZ2VzIGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvZXJyb3IuaHRtbCNFcnJvci5tZXNzYWdlc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5TY2hlbWFEYXRlLnByb3RvdHlwZS5taW4gPSBmdW5jdGlvbih2YWx1ZSwgbWVzc2FnZSkge1xuICBpZiAodGhpcy5taW5WYWxpZGF0b3IpIHtcbiAgICB0aGlzLnZhbGlkYXRvcnMgPSB0aGlzLnZhbGlkYXRvcnMuZmlsdGVyKGZ1bmN0aW9uKHYpIHtcbiAgICAgIHJldHVybiB2LnZhbGlkYXRvciAhPT0gdGhpcy5taW5WYWxpZGF0b3I7XG4gICAgfSwgdGhpcyk7XG4gIH1cblxuICBpZiAodmFsdWUpIHtcbiAgICBsZXQgbXNnID0gbWVzc2FnZSB8fCBNb25nb29zZUVycm9yLm1lc3NhZ2VzLkRhdGUubWluO1xuICAgIGlmICh0eXBlb2YgbXNnID09PSAnc3RyaW5nJykge1xuICAgICAgbXNnID0gbXNnLnJlcGxhY2UoL3tNSU59LywgKHZhbHVlID09PSBEYXRlLm5vdyA/ICdEYXRlLm5vdygpJyA6IHZhbHVlLnRvU3RyaW5nKCkpKTtcbiAgICB9XG4gICAgY29uc3QgX3RoaXMgPSB0aGlzO1xuICAgIHRoaXMudmFsaWRhdG9ycy5wdXNoKHtcbiAgICAgIHZhbGlkYXRvcjogdGhpcy5taW5WYWxpZGF0b3IgPSBmdW5jdGlvbih2YWwpIHtcbiAgICAgICAgbGV0IF92YWx1ZSA9IHZhbHVlO1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nICYmIHZhbHVlICE9PSBEYXRlLm5vdykge1xuICAgICAgICAgIF92YWx1ZSA9IF92YWx1ZS5jYWxsKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1pbiA9IChfdmFsdWUgPT09IERhdGUubm93ID8gX3ZhbHVlKCkgOiBfdGhpcy5jYXN0KF92YWx1ZSkpO1xuICAgICAgICByZXR1cm4gdmFsID09PSBudWxsIHx8IHZhbC52YWx1ZU9mKCkgPj0gbWluLnZhbHVlT2YoKTtcbiAgICAgIH0sXG4gICAgICBtZXNzYWdlOiBtc2csXG4gICAgICB0eXBlOiAnbWluJyxcbiAgICAgIG1pbjogdmFsdWVcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZXRzIGEgbWF4aW11bSBkYXRlIHZhbGlkYXRvci5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IHMgPSBuZXcgU2NoZW1hKHsgZDogeyB0eXBlOiBEYXRlLCBtYXg6IERhdGUoJzIwMTQtMDEtMDEnKSB9KVxuICogICAgIGNvbnN0IE0gPSBkYi5tb2RlbCgnTScsIHMpXG4gKiAgICAgY29uc3QgbSA9IG5ldyBNKHsgZDogRGF0ZSgnMjAxNC0xMi0wOCcpIH0pXG4gKiAgICAgbS5zYXZlKGZ1bmN0aW9uIChlcnIpIHtcbiAqICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyKSAvLyB2YWxpZGF0b3IgZXJyb3JcbiAqICAgICAgIG0uZCA9IERhdGUoJzIwMTMtMTItMzEnKTtcbiAqICAgICAgIG0uc2F2ZSgpIC8vIHN1Y2Nlc3NcbiAqICAgICB9KVxuICpcbiAqICAgICAvLyBjdXN0b20gZXJyb3IgbWVzc2FnZXNcbiAqICAgICAvLyBXZSBjYW4gYWxzbyB1c2UgdGhlIHNwZWNpYWwge01BWH0gdG9rZW4gd2hpY2ggd2lsbCBiZSByZXBsYWNlZCB3aXRoIHRoZSBpbnZhbGlkIHZhbHVlXG4gKiAgICAgY29uc3QgbWF4ID0gW0RhdGUoJzIwMTQtMDEtMDEnKSwgJ1RoZSB2YWx1ZSBvZiBwYXRoIGB7UEFUSH1gICh7VkFMVUV9KSBleGNlZWRzIHRoZSBsaW1pdCAoe01BWH0pLiddO1xuICogICAgIGNvbnN0IHNjaGVtYSA9IG5ldyBTY2hlbWEoeyBkOiB7IHR5cGU6IERhdGUsIG1heDogbWF4IH0pXG4gKiAgICAgY29uc3QgTSA9IG1vbmdvb3NlLm1vZGVsKCdNJywgc2NoZW1hKTtcbiAqICAgICBjb25zdCBzPSBuZXcgTSh7IGQ6IERhdGUoJzIwMTQtMTItMDgnKSB9KTtcbiAqICAgICBzLnZhbGlkYXRlKGZ1bmN0aW9uIChlcnIpIHtcbiAqICAgICAgIGNvbnNvbGUubG9nKFN0cmluZyhlcnIpKSAvLyBWYWxpZGF0aW9uRXJyb3I6IFRoZSB2YWx1ZSBvZiBwYXRoIGBkYCAoMjAxNC0xMi0wOCkgZXhjZWVkcyB0aGUgbGltaXQgKDIwMTQtMDEtMDEpLlxuICogICAgIH0pXG4gKlxuICogQHBhcmFtIHtEYXRlfSBtYXhpbXVtIGRhdGVcbiAqIEBwYXJhbSB7U3RyaW5nfSBbbWVzc2FnZV0gb3B0aW9uYWwgY3VzdG9tIGVycm9yIG1lc3NhZ2VcbiAqIEByZXR1cm4ge1NjaGVtYVR5cGV9IHRoaXNcbiAqIEBzZWUgQ3VzdG9taXplZCBFcnJvciBNZXNzYWdlcyBodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvYXBpL2Vycm9yLmh0bWwjRXJyb3IubWVzc2FnZXNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuU2NoZW1hRGF0ZS5wcm90b3R5cGUubWF4ID0gZnVuY3Rpb24odmFsdWUsIG1lc3NhZ2UpIHtcbiAgaWYgKHRoaXMubWF4VmFsaWRhdG9yKSB7XG4gICAgdGhpcy52YWxpZGF0b3JzID0gdGhpcy52YWxpZGF0b3JzLmZpbHRlcihmdW5jdGlvbih2KSB7XG4gICAgICByZXR1cm4gdi52YWxpZGF0b3IgIT09IHRoaXMubWF4VmFsaWRhdG9yO1xuICAgIH0sIHRoaXMpO1xuICB9XG5cbiAgaWYgKHZhbHVlKSB7XG4gICAgbGV0IG1zZyA9IG1lc3NhZ2UgfHwgTW9uZ29vc2VFcnJvci5tZXNzYWdlcy5EYXRlLm1heDtcbiAgICBpZiAodHlwZW9mIG1zZyA9PT0gJ3N0cmluZycpIHtcbiAgICAgIG1zZyA9IG1zZy5yZXBsYWNlKC97TUFYfS8sICh2YWx1ZSA9PT0gRGF0ZS5ub3cgPyAnRGF0ZS5ub3coKScgOiB2YWx1ZS50b1N0cmluZygpKSk7XG4gICAgfVxuICAgIGNvbnN0IF90aGlzID0gdGhpcztcbiAgICB0aGlzLnZhbGlkYXRvcnMucHVzaCh7XG4gICAgICB2YWxpZGF0b3I6IHRoaXMubWF4VmFsaWRhdG9yID0gZnVuY3Rpb24odmFsKSB7XG4gICAgICAgIGxldCBfdmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgaWYgKHR5cGVvZiBfdmFsdWUgPT09ICdmdW5jdGlvbicgJiYgX3ZhbHVlICE9PSBEYXRlLm5vdykge1xuICAgICAgICAgIF92YWx1ZSA9IF92YWx1ZS5jYWxsKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1heCA9IChfdmFsdWUgPT09IERhdGUubm93ID8gX3ZhbHVlKCkgOiBfdGhpcy5jYXN0KF92YWx1ZSkpO1xuICAgICAgICByZXR1cm4gdmFsID09PSBudWxsIHx8IHZhbC52YWx1ZU9mKCkgPD0gbWF4LnZhbHVlT2YoKTtcbiAgICAgIH0sXG4gICAgICBtZXNzYWdlOiBtc2csXG4gICAgICB0eXBlOiAnbWF4JyxcbiAgICAgIG1heDogdmFsdWVcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBDYXN0cyB0byBkYXRlXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbHVlIHRvIGNhc3RcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNjaGVtYURhdGUucHJvdG90eXBlLmNhc3QgPSBmdW5jdGlvbih2YWx1ZSkge1xuICBsZXQgY2FzdERhdGU7XG4gIGlmICh0eXBlb2YgdGhpcy5fY2FzdEZ1bmN0aW9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FzdERhdGUgPSB0aGlzLl9jYXN0RnVuY3Rpb247XG4gIH0gZWxzZSBpZiAodHlwZW9mIHRoaXMuY29uc3RydWN0b3IuY2FzdCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNhc3REYXRlID0gdGhpcy5jb25zdHJ1Y3Rvci5jYXN0KCk7XG4gIH0gZWxzZSB7XG4gICAgY2FzdERhdGUgPSBTY2hlbWFEYXRlLmNhc3QoKTtcbiAgfVxuXG4gIHRyeSB7XG4gICAgcmV0dXJuIGNhc3REYXRlKHZhbHVlKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICB0aHJvdyBuZXcgQ2FzdEVycm9yKCdkYXRlJywgdmFsdWUsIHRoaXMucGF0aCwgZXJyb3IsIHRoaXMpO1xuICB9XG59O1xuXG4vKipcbiAqIERhdGUgUXVlcnkgY2FzdGluZy5cbiAqXG4gKiBAcGFyYW0ge0FueX0gdmFsXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBoYW5kbGVTaW5nbGUodmFsKSB7XG4gIHJldHVybiB0aGlzLmNhc3QodmFsKTtcbn1cblxuU2NoZW1hRGF0ZS5wcm90b3R5cGUuJGNvbmRpdGlvbmFsSGFuZGxlcnMgPSB7XG4gIC4uLlNjaGVtYVR5cGUucHJvdG90eXBlLiRjb25kaXRpb25hbEhhbmRsZXJzLFxuICAkZ3Q6IGhhbmRsZVNpbmdsZSxcbiAgJGd0ZTogaGFuZGxlU2luZ2xlLFxuICAkbHQ6IGhhbmRsZVNpbmdsZSxcbiAgJGx0ZTogaGFuZGxlU2luZ2xlXG59O1xuXG5cbi8qKlxuICogQ2FzdHMgY29udGVudHMgZm9yIHF1ZXJpZXMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9ICRjb25kaXRpb25hbFxuICogQHBhcmFtIHthbnl9IFt2YWx1ZV1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNjaGVtYURhdGUucHJvdG90eXBlLmNhc3RGb3JRdWVyeSA9IGZ1bmN0aW9uKCRjb25kaXRpb25hbCwgdmFsLCBjb250ZXh0KSB7XG4gIGlmICgkY29uZGl0aW9uYWwgPT0gbnVsbCkge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gdGhpcy5hcHBseVNldHRlcnModmFsLCBjb250ZXh0KTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGlmIChlcnIgaW5zdGFuY2VvZiBDYXN0RXJyb3IgJiYgZXJyLnBhdGggPT09IHRoaXMucGF0aCAmJiB0aGlzLiRmdWxsUGF0aCAhPSBudWxsKSB7XG4gICAgICAgIGVyci5wYXRoID0gdGhpcy4kZnVsbFBhdGg7XG4gICAgICB9XG4gICAgICB0aHJvdyBlcnI7XG4gICAgfVxuICB9XG5cbiAgY29uc3QgaGFuZGxlciA9IHRoaXMuJGNvbmRpdGlvbmFsSGFuZGxlcnNbJGNvbmRpdGlvbmFsXTtcblxuICBpZiAoIWhhbmRsZXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0NhblxcJ3QgdXNlICcgKyAkY29uZGl0aW9uYWwgKyAnIHdpdGggRGF0ZS4nKTtcbiAgfVxuXG4gIHJldHVybiBoYW5kbGVyLmNhbGwodGhpcywgdmFsKTtcbn07XG5cbi8qIVxuICogTW9kdWxlIGV4cG9ydHMuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBTY2hlbWFEYXRlO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../server/node_modules/mongoose/lib/schema/date.js\n");

/***/ }),

/***/ "../server/node_modules/mongoose/lib/schema/decimal128.js":
/*!****************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/schema/decimal128.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*!\n * Module dependencies.\n */\n\n\n\nconst SchemaType = __webpack_require__(/*! ../schemaType */ \"../server/node_modules/mongoose/lib/schemaType.js\");\nconst CastError = SchemaType.CastError;\nconst castDecimal128 = __webpack_require__(/*! ../cast/decimal128 */ \"../server/node_modules/mongoose/lib/cast/decimal128.js\");\nconst isBsonType = __webpack_require__(/*! ../helpers/isBsonType */ \"../server/node_modules/mongoose/lib/helpers/isBsonType.js\");\n\n/**\n * Decimal128 SchemaType constructor.\n *\n * @param {String} key\n * @param {Object} options\n * @inherits SchemaType\n * @api public\n */\n\nfunction SchemaDecimal128(key, options) {\n  SchemaType.call(this, key, options, 'Decimal128');\n}\n\n/**\n * This schema type's name, to defend against minifiers that mangle\n * function names.\n *\n * @api public\n */\nSchemaDecimal128.schemaName = 'Decimal128';\n\nSchemaDecimal128.defaultOptions = {};\n\n/*!\n * Inherits from SchemaType.\n */\nSchemaDecimal128.prototype = Object.create(SchemaType.prototype);\nSchemaDecimal128.prototype.constructor = SchemaDecimal128;\n\n/*!\n * ignore\n */\n\nSchemaDecimal128._cast = castDecimal128;\n\n/**\n * Sets a default option for all Decimal128 instances.\n *\n * #### Example:\n *\n *     // Make all decimal 128s have `required` of true by default.\n *     mongoose.Schema.Decimal128.set('required', true);\n *\n *     const User = mongoose.model('User', new Schema({ test: mongoose.Decimal128 }));\n *     new User({ }).validateSync().errors.test.message; // Path `test` is required.\n *\n * @param {String} option The option you'd like to set the value for\n * @param {Any} value value for option\n * @return {undefined}\n * @function set\n * @static\n * @api public\n */\n\nSchemaDecimal128.set = SchemaType.set;\n\nSchemaDecimal128.setters = [];\n\n/**\n * Attaches a getter for all Decimal128 instances\n *\n * #### Example:\n *\n *     // Automatically convert Decimal128s to Numbers\n *     mongoose.Schema.Decimal128.get(v => v == null ? v : Number(v));\n *\n * @param {Function} getter\n * @return {this}\n * @function get\n * @static\n * @api public\n */\n\nSchemaDecimal128.get = SchemaType.get;\n\n/**\n * Get/set the function used to cast arbitrary values to decimals.\n *\n * #### Example:\n *\n *     // Make Mongoose only refuse to cast numbers as decimal128\n *     const original = mongoose.Schema.Types.Decimal128.cast();\n *     mongoose.Decimal128.cast(v => {\n *       assert.ok(typeof v !== 'number');\n *       return original(v);\n *     });\n *\n *     // Or disable casting entirely\n *     mongoose.Decimal128.cast(false);\n *\n * @param {Function} [caster]\n * @return {Function}\n * @function get\n * @static\n * @api public\n */\n\nSchemaDecimal128.cast = function cast(caster) {\n  if (arguments.length === 0) {\n    return this._cast;\n  }\n  if (caster === false) {\n    caster = this._defaultCaster;\n  }\n  this._cast = caster;\n\n  return this._cast;\n};\n\n/*!\n * ignore\n */\n\nSchemaDecimal128._defaultCaster = v => {\n  if (v != null && !isBsonType(v, 'Decimal128')) {\n    throw new Error();\n  }\n  return v;\n};\n\n/*!\n * ignore\n */\n\nSchemaDecimal128._checkRequired = v => isBsonType(v, 'Decimal128');\n\n/**\n * Override the function the required validator uses to check whether a string\n * passes the `required` check.\n *\n * @param {Function} fn\n * @return {Function}\n * @function checkRequired\n * @static\n * @api public\n */\n\nSchemaDecimal128.checkRequired = SchemaType.checkRequired;\n\n/**\n * Check if the given value satisfies a required validator.\n *\n * @param {Any} value\n * @param {Document} doc\n * @return {Boolean}\n * @api public\n */\n\nSchemaDecimal128.prototype.checkRequired = function checkRequired(value, doc) {\n  if (SchemaType._isRef(this, value, doc, true)) {\n    return !!value;\n  }\n\n  // `require('util').inherits()` does **not** copy static properties, and\n  // plugins like mongoose-float use `inherits()` for pre-ES6.\n  const _checkRequired = typeof this.constructor.checkRequired === 'function' ?\n    this.constructor.checkRequired() :\n    SchemaDecimal128.checkRequired();\n\n  return _checkRequired(value);\n};\n\n/**\n * Casts to Decimal128\n *\n * @param {Object} value\n * @param {Object} doc\n * @param {Boolean} init whether this is an initialization cast\n * @api private\n */\n\nSchemaDecimal128.prototype.cast = function(value, doc, init) {\n  if (SchemaType._isRef(this, value, doc, init)) {\n    if (isBsonType(value, 'Decimal128')) {\n      return value;\n    }\n\n    return this._castRef(value, doc, init);\n  }\n\n  let castDecimal128;\n  if (typeof this._castFunction === 'function') {\n    castDecimal128 = this._castFunction;\n  } else if (typeof this.constructor.cast === 'function') {\n    castDecimal128 = this.constructor.cast();\n  } else {\n    castDecimal128 = SchemaDecimal128.cast();\n  }\n\n  try {\n    return castDecimal128(value);\n  } catch (error) {\n    throw new CastError('Decimal128', value, this.path, error, this);\n  }\n};\n\n/*!\n * ignore\n */\n\nfunction handleSingle(val) {\n  return this.cast(val);\n}\n\nSchemaDecimal128.prototype.$conditionalHandlers = {\n  ...SchemaType.prototype.$conditionalHandlers,\n  $gt: handleSingle,\n  $gte: handleSingle,\n  $lt: handleSingle,\n  $lte: handleSingle\n};\n\n/*!\n * Module exports.\n */\n\nmodule.exports = SchemaDecimal128;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvc2NoZW1hL2RlY2ltYWwxMjguanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBOztBQUVhOztBQUViLG1CQUFtQixtQkFBTyxDQUFDLHdFQUFlO0FBQzFDO0FBQ0EsdUJBQXVCLG1CQUFPLENBQUMsa0ZBQW9CO0FBQ25ELG1CQUFtQixtQkFBTyxDQUFDLHdGQUF1Qjs7QUFFbEQ7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0QsMkJBQTJCO0FBQ25GLG1CQUFtQixzQ0FBc0M7QUFDekQ7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxLQUFLO0FBQ2hCLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsVUFBVTtBQUNyQixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxVQUFVO0FBQ3JCLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsU0FBUztBQUNwQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL2NsaWVudC8uLi9zZXJ2ZXIvbm9kZV9tb2R1bGVzL21vbmdvb3NlL2xpYi9zY2hlbWEvZGVjaW1hbDEyOC5qcz9kYzNmIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbmNvbnN0IFNjaGVtYVR5cGUgPSByZXF1aXJlKCcuLi9zY2hlbWFUeXBlJyk7XG5jb25zdCBDYXN0RXJyb3IgPSBTY2hlbWFUeXBlLkNhc3RFcnJvcjtcbmNvbnN0IGNhc3REZWNpbWFsMTI4ID0gcmVxdWlyZSgnLi4vY2FzdC9kZWNpbWFsMTI4Jyk7XG5jb25zdCBpc0Jzb25UeXBlID0gcmVxdWlyZSgnLi4vaGVscGVycy9pc0Jzb25UeXBlJyk7XG5cbi8qKlxuICogRGVjaW1hbDEyOCBTY2hlbWFUeXBlIGNvbnN0cnVjdG9yLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBrZXlcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAaW5oZXJpdHMgU2NoZW1hVHlwZVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBTY2hlbWFEZWNpbWFsMTI4KGtleSwgb3B0aW9ucykge1xuICBTY2hlbWFUeXBlLmNhbGwodGhpcywga2V5LCBvcHRpb25zLCAnRGVjaW1hbDEyOCcpO1xufVxuXG4vKipcbiAqIFRoaXMgc2NoZW1hIHR5cGUncyBuYW1lLCB0byBkZWZlbmQgYWdhaW5zdCBtaW5pZmllcnMgdGhhdCBtYW5nbGVcbiAqIGZ1bmN0aW9uIG5hbWVzLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblNjaGVtYURlY2ltYWwxMjguc2NoZW1hTmFtZSA9ICdEZWNpbWFsMTI4JztcblxuU2NoZW1hRGVjaW1hbDEyOC5kZWZhdWx0T3B0aW9ucyA9IHt9O1xuXG4vKiFcbiAqIEluaGVyaXRzIGZyb20gU2NoZW1hVHlwZS5cbiAqL1xuU2NoZW1hRGVjaW1hbDEyOC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFNjaGVtYVR5cGUucHJvdG90eXBlKTtcblNjaGVtYURlY2ltYWwxMjgucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gU2NoZW1hRGVjaW1hbDEyODtcblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5TY2hlbWFEZWNpbWFsMTI4Ll9jYXN0ID0gY2FzdERlY2ltYWwxMjg7XG5cbi8qKlxuICogU2V0cyBhIGRlZmF1bHQgb3B0aW9uIGZvciBhbGwgRGVjaW1hbDEyOCBpbnN0YW5jZXMuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICAvLyBNYWtlIGFsbCBkZWNpbWFsIDEyOHMgaGF2ZSBgcmVxdWlyZWRgIG9mIHRydWUgYnkgZGVmYXVsdC5cbiAqICAgICBtb25nb29zZS5TY2hlbWEuRGVjaW1hbDEyOC5zZXQoJ3JlcXVpcmVkJywgdHJ1ZSk7XG4gKlxuICogICAgIGNvbnN0IFVzZXIgPSBtb25nb29zZS5tb2RlbCgnVXNlcicsIG5ldyBTY2hlbWEoeyB0ZXN0OiBtb25nb29zZS5EZWNpbWFsMTI4IH0pKTtcbiAqICAgICBuZXcgVXNlcih7IH0pLnZhbGlkYXRlU3luYygpLmVycm9ycy50ZXN0Lm1lc3NhZ2U7IC8vIFBhdGggYHRlc3RgIGlzIHJlcXVpcmVkLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBvcHRpb24gVGhlIG9wdGlvbiB5b3UnZCBsaWtlIHRvIHNldCB0aGUgdmFsdWUgZm9yXG4gKiBAcGFyYW0ge0FueX0gdmFsdWUgdmFsdWUgZm9yIG9wdGlvblxuICogQHJldHVybiB7dW5kZWZpbmVkfVxuICogQGZ1bmN0aW9uIHNldFxuICogQHN0YXRpY1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5TY2hlbWFEZWNpbWFsMTI4LnNldCA9IFNjaGVtYVR5cGUuc2V0O1xuXG5TY2hlbWFEZWNpbWFsMTI4LnNldHRlcnMgPSBbXTtcblxuLyoqXG4gKiBBdHRhY2hlcyBhIGdldHRlciBmb3IgYWxsIERlY2ltYWwxMjggaW5zdGFuY2VzXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICAvLyBBdXRvbWF0aWNhbGx5IGNvbnZlcnQgRGVjaW1hbDEyOHMgdG8gTnVtYmVyc1xuICogICAgIG1vbmdvb3NlLlNjaGVtYS5EZWNpbWFsMTI4LmdldCh2ID0+IHYgPT0gbnVsbCA/IHYgOiBOdW1iZXIodikpO1xuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGdldHRlclxuICogQHJldHVybiB7dGhpc31cbiAqIEBmdW5jdGlvbiBnZXRcbiAqIEBzdGF0aWNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuU2NoZW1hRGVjaW1hbDEyOC5nZXQgPSBTY2hlbWFUeXBlLmdldDtcblxuLyoqXG4gKiBHZXQvc2V0IHRoZSBmdW5jdGlvbiB1c2VkIHRvIGNhc3QgYXJiaXRyYXJ5IHZhbHVlcyB0byBkZWNpbWFscy5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIC8vIE1ha2UgTW9uZ29vc2Ugb25seSByZWZ1c2UgdG8gY2FzdCBudW1iZXJzIGFzIGRlY2ltYWwxMjhcbiAqICAgICBjb25zdCBvcmlnaW5hbCA9IG1vbmdvb3NlLlNjaGVtYS5UeXBlcy5EZWNpbWFsMTI4LmNhc3QoKTtcbiAqICAgICBtb25nb29zZS5EZWNpbWFsMTI4LmNhc3QodiA9PiB7XG4gKiAgICAgICBhc3NlcnQub2sodHlwZW9mIHYgIT09ICdudW1iZXInKTtcbiAqICAgICAgIHJldHVybiBvcmlnaW5hbCh2KTtcbiAqICAgICB9KTtcbiAqXG4gKiAgICAgLy8gT3IgZGlzYWJsZSBjYXN0aW5nIGVudGlyZWx5XG4gKiAgICAgbW9uZ29vc2UuRGVjaW1hbDEyOC5jYXN0KGZhbHNlKTtcbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FzdGVyXVxuICogQHJldHVybiB7RnVuY3Rpb259XG4gKiBAZnVuY3Rpb24gZ2V0XG4gKiBAc3RhdGljXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblNjaGVtYURlY2ltYWwxMjguY2FzdCA9IGZ1bmN0aW9uIGNhc3QoY2FzdGVyKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIHRoaXMuX2Nhc3Q7XG4gIH1cbiAgaWYgKGNhc3RlciA9PT0gZmFsc2UpIHtcbiAgICBjYXN0ZXIgPSB0aGlzLl9kZWZhdWx0Q2FzdGVyO1xuICB9XG4gIHRoaXMuX2Nhc3QgPSBjYXN0ZXI7XG5cbiAgcmV0dXJuIHRoaXMuX2Nhc3Q7XG59O1xuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cblNjaGVtYURlY2ltYWwxMjguX2RlZmF1bHRDYXN0ZXIgPSB2ID0+IHtcbiAgaWYgKHYgIT0gbnVsbCAmJiAhaXNCc29uVHlwZSh2LCAnRGVjaW1hbDEyOCcpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCk7XG4gIH1cbiAgcmV0dXJuIHY7XG59O1xuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cblNjaGVtYURlY2ltYWwxMjguX2NoZWNrUmVxdWlyZWQgPSB2ID0+IGlzQnNvblR5cGUodiwgJ0RlY2ltYWwxMjgnKTtcblxuLyoqXG4gKiBPdmVycmlkZSB0aGUgZnVuY3Rpb24gdGhlIHJlcXVpcmVkIHZhbGlkYXRvciB1c2VzIHRvIGNoZWNrIHdoZXRoZXIgYSBzdHJpbmdcbiAqIHBhc3NlcyB0aGUgYHJlcXVpcmVkYCBjaGVjay5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICogQHJldHVybiB7RnVuY3Rpb259XG4gKiBAZnVuY3Rpb24gY2hlY2tSZXF1aXJlZFxuICogQHN0YXRpY1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5TY2hlbWFEZWNpbWFsMTI4LmNoZWNrUmVxdWlyZWQgPSBTY2hlbWFUeXBlLmNoZWNrUmVxdWlyZWQ7XG5cbi8qKlxuICogQ2hlY2sgaWYgdGhlIGdpdmVuIHZhbHVlIHNhdGlzZmllcyBhIHJlcXVpcmVkIHZhbGlkYXRvci5cbiAqXG4gKiBAcGFyYW0ge0FueX0gdmFsdWVcbiAqIEBwYXJhbSB7RG9jdW1lbnR9IGRvY1xuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuU2NoZW1hRGVjaW1hbDEyOC5wcm90b3R5cGUuY2hlY2tSZXF1aXJlZCA9IGZ1bmN0aW9uIGNoZWNrUmVxdWlyZWQodmFsdWUsIGRvYykge1xuICBpZiAoU2NoZW1hVHlwZS5faXNSZWYodGhpcywgdmFsdWUsIGRvYywgdHJ1ZSkpIHtcbiAgICByZXR1cm4gISF2YWx1ZTtcbiAgfVxuXG4gIC8vIGByZXF1aXJlKCd1dGlsJykuaW5oZXJpdHMoKWAgZG9lcyAqKm5vdCoqIGNvcHkgc3RhdGljIHByb3BlcnRpZXMsIGFuZFxuICAvLyBwbHVnaW5zIGxpa2UgbW9uZ29vc2UtZmxvYXQgdXNlIGBpbmhlcml0cygpYCBmb3IgcHJlLUVTNi5cbiAgY29uc3QgX2NoZWNrUmVxdWlyZWQgPSB0eXBlb2YgdGhpcy5jb25zdHJ1Y3Rvci5jaGVja1JlcXVpcmVkID09PSAnZnVuY3Rpb24nID9cbiAgICB0aGlzLmNvbnN0cnVjdG9yLmNoZWNrUmVxdWlyZWQoKSA6XG4gICAgU2NoZW1hRGVjaW1hbDEyOC5jaGVja1JlcXVpcmVkKCk7XG5cbiAgcmV0dXJuIF9jaGVja1JlcXVpcmVkKHZhbHVlKTtcbn07XG5cbi8qKlxuICogQ2FzdHMgdG8gRGVjaW1hbDEyOFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWx1ZVxuICogQHBhcmFtIHtPYmplY3R9IGRvY1xuICogQHBhcmFtIHtCb29sZWFufSBpbml0IHdoZXRoZXIgdGhpcyBpcyBhbiBpbml0aWFsaXphdGlvbiBjYXN0XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5TY2hlbWFEZWNpbWFsMTI4LnByb3RvdHlwZS5jYXN0ID0gZnVuY3Rpb24odmFsdWUsIGRvYywgaW5pdCkge1xuICBpZiAoU2NoZW1hVHlwZS5faXNSZWYodGhpcywgdmFsdWUsIGRvYywgaW5pdCkpIHtcbiAgICBpZiAoaXNCc29uVHlwZSh2YWx1ZSwgJ0RlY2ltYWwxMjgnKSkge1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl9jYXN0UmVmKHZhbHVlLCBkb2MsIGluaXQpO1xuICB9XG5cbiAgbGV0IGNhc3REZWNpbWFsMTI4O1xuICBpZiAodHlwZW9mIHRoaXMuX2Nhc3RGdW5jdGlvbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNhc3REZWNpbWFsMTI4ID0gdGhpcy5fY2FzdEZ1bmN0aW9uO1xuICB9IGVsc2UgaWYgKHR5cGVvZiB0aGlzLmNvbnN0cnVjdG9yLmNhc3QgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYXN0RGVjaW1hbDEyOCA9IHRoaXMuY29uc3RydWN0b3IuY2FzdCgpO1xuICB9IGVsc2Uge1xuICAgIGNhc3REZWNpbWFsMTI4ID0gU2NoZW1hRGVjaW1hbDEyOC5jYXN0KCk7XG4gIH1cblxuICB0cnkge1xuICAgIHJldHVybiBjYXN0RGVjaW1hbDEyOCh2YWx1ZSk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgdGhyb3cgbmV3IENhc3RFcnJvcignRGVjaW1hbDEyOCcsIHZhbHVlLCB0aGlzLnBhdGgsIGVycm9yLCB0aGlzKTtcbiAgfVxufTtcblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5mdW5jdGlvbiBoYW5kbGVTaW5nbGUodmFsKSB7XG4gIHJldHVybiB0aGlzLmNhc3QodmFsKTtcbn1cblxuU2NoZW1hRGVjaW1hbDEyOC5wcm90b3R5cGUuJGNvbmRpdGlvbmFsSGFuZGxlcnMgPSB7XG4gIC4uLlNjaGVtYVR5cGUucHJvdG90eXBlLiRjb25kaXRpb25hbEhhbmRsZXJzLFxuICAkZ3Q6IGhhbmRsZVNpbmdsZSxcbiAgJGd0ZTogaGFuZGxlU2luZ2xlLFxuICAkbHQ6IGhhbmRsZVNpbmdsZSxcbiAgJGx0ZTogaGFuZGxlU2luZ2xlXG59O1xuXG4vKiFcbiAqIE1vZHVsZSBleHBvcnRzLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gU2NoZW1hRGVjaW1hbDEyODtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../server/node_modules/mongoose/lib/schema/decimal128.js\n");

/***/ }),

/***/ "../server/node_modules/mongoose/lib/schema/documentArray.js":
/*!*******************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/schema/documentArray.js ***!
  \*******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\n/*!\n * Module dependencies.\n */\n\nconst CastError = __webpack_require__(/*! ../error/cast */ \"../server/node_modules/mongoose/lib/error/cast.js\");\nconst DocumentArrayElement = __webpack_require__(/*! ./documentArrayElement */ \"../server/node_modules/mongoose/lib/schema/documentArrayElement.js\");\nconst EventEmitter = (__webpack_require__(/*! events */ \"events\").EventEmitter);\nconst SchemaArray = __webpack_require__(/*! ./array */ \"../server/node_modules/mongoose/lib/schema/array.js\");\nconst SchemaDocumentArrayOptions =\n  __webpack_require__(/*! ../options/schemaDocumentArrayOptions */ \"../server/node_modules/mongoose/lib/options/schemaDocumentArrayOptions.js\");\nconst SchemaType = __webpack_require__(/*! ../schemaType */ \"../server/node_modules/mongoose/lib/schemaType.js\");\nconst discriminator = __webpack_require__(/*! ../helpers/model/discriminator */ \"../server/node_modules/mongoose/lib/helpers/model/discriminator.js\");\nconst handleIdOption = __webpack_require__(/*! ../helpers/schema/handleIdOption */ \"../server/node_modules/mongoose/lib/helpers/schema/handleIdOption.js\");\nconst handleSpreadDoc = __webpack_require__(/*! ../helpers/document/handleSpreadDoc */ \"../server/node_modules/mongoose/lib/helpers/document/handleSpreadDoc.js\");\nconst utils = __webpack_require__(/*! ../utils */ \"../server/node_modules/mongoose/lib/utils.js\");\nconst getConstructor = __webpack_require__(/*! ../helpers/discriminator/getConstructor */ \"../server/node_modules/mongoose/lib/helpers/discriminator/getConstructor.js\");\nconst InvalidSchemaOptionError = __webpack_require__(/*! ../error/invalidSchemaOption */ \"../server/node_modules/mongoose/lib/error/invalidSchemaOption.js\");\n\nconst arrayAtomicsSymbol = (__webpack_require__(/*! ../helpers/symbols */ \"../server/node_modules/mongoose/lib/helpers/symbols.js\").arrayAtomicsSymbol);\nconst arrayPathSymbol = (__webpack_require__(/*! ../helpers/symbols */ \"../server/node_modules/mongoose/lib/helpers/symbols.js\").arrayPathSymbol);\nconst documentArrayParent = (__webpack_require__(/*! ../helpers/symbols */ \"../server/node_modules/mongoose/lib/helpers/symbols.js\").documentArrayParent);\n\nlet MongooseDocumentArray;\nlet Subdocument;\n\n/**\n * SubdocsArray SchemaType constructor\n *\n * @param {String} key\n * @param {Schema} schema\n * @param {Object} options\n * @param {Object} schemaOptions\n * @inherits SchemaArray\n * @api public\n */\n\nfunction SchemaDocumentArray(key, schema, options, schemaOptions) {\n  if (schema.options && schema.options.timeseries) {\n    throw new InvalidSchemaOptionError(key, 'timeseries');\n  }\n  const schemaTypeIdOption = SchemaDocumentArray.defaultOptions &&\n    SchemaDocumentArray.defaultOptions._id;\n  if (schemaTypeIdOption != null) {\n    schemaOptions = schemaOptions || {};\n    schemaOptions._id = schemaTypeIdOption;\n  }\n\n  if (schemaOptions != null && schemaOptions._id != null) {\n    schema = handleIdOption(schema, schemaOptions);\n  } else if (options != null && options._id != null) {\n    schema = handleIdOption(schema, options);\n  }\n\n  const EmbeddedDocument = _createConstructor(schema, options);\n  EmbeddedDocument.prototype.$basePath = key;\n\n  SchemaArray.call(this, key, EmbeddedDocument, options);\n\n  this.schema = schema;\n  this.schemaOptions = schemaOptions || {};\n  this.$isMongooseDocumentArray = true;\n  this.Constructor = EmbeddedDocument;\n\n  EmbeddedDocument.base = schema.base;\n\n  const fn = this.defaultValue;\n\n  if (!('defaultValue' in this) || fn !== void 0) {\n    this.default(function() {\n      let arr = fn.call(this);\n      if (arr != null && !Array.isArray(arr)) {\n        arr = [arr];\n      }\n      // Leave it up to `cast()` to convert this to a documentarray\n      return arr;\n    });\n  }\n\n  const $parentSchemaType = this;\n  this.$embeddedSchemaType = new DocumentArrayElement(key + '.$', {\n    required: this &&\n      this.schemaOptions &&\n      this.schemaOptions.required || false,\n    $parentSchemaType\n  });\n\n  this.$embeddedSchemaType.caster = this.Constructor;\n  this.$embeddedSchemaType.schema = this.schema;\n}\n\n/**\n * This schema type's name, to defend against minifiers that mangle\n * function names.\n *\n * @api public\n */\nSchemaDocumentArray.schemaName = 'DocumentArray';\n\n/**\n * Options for all document arrays.\n *\n * - `castNonArrays`: `true` by default. If `false`, Mongoose will throw a CastError when a value isn't an array. If `true`, Mongoose will wrap the provided value in an array before casting.\n *\n * @api public\n */\n\nSchemaDocumentArray.options = { castNonArrays: true };\n\n/*!\n * Inherits from SchemaArray.\n */\nSchemaDocumentArray.prototype = Object.create(SchemaArray.prototype);\nSchemaDocumentArray.prototype.constructor = SchemaDocumentArray;\nSchemaDocumentArray.prototype.OptionsConstructor = SchemaDocumentArrayOptions;\n\n/*!\n * ignore\n */\n\nfunction _createConstructor(schema, options, baseClass) {\n  Subdocument || (Subdocument = __webpack_require__(/*! ../types/arraySubdocument */ \"../server/node_modules/mongoose/lib/types/arraySubdocument.js\"));\n\n  // compile an embedded document for this schema\n  function EmbeddedDocument() {\n    Subdocument.apply(this, arguments);\n    if (this.__parentArray == null || this.__parentArray.getArrayParent() == null) {\n      return;\n    }\n    this.$session(this.__parentArray.getArrayParent().$session());\n  }\n\n  schema._preCompile();\n\n  const proto = baseClass != null ? baseClass.prototype : Subdocument.prototype;\n  EmbeddedDocument.prototype = Object.create(proto);\n  EmbeddedDocument.prototype.$__setSchema(schema);\n  EmbeddedDocument.schema = schema;\n  EmbeddedDocument.prototype.constructor = EmbeddedDocument;\n  EmbeddedDocument.$isArraySubdocument = true;\n  EmbeddedDocument.events = new EventEmitter();\n  EmbeddedDocument.base = schema.base;\n\n  // apply methods\n  for (const i in schema.methods) {\n    EmbeddedDocument.prototype[i] = schema.methods[i];\n  }\n\n  // apply statics\n  for (const i in schema.statics) {\n    EmbeddedDocument[i] = schema.statics[i];\n  }\n\n  for (const i in EventEmitter.prototype) {\n    EmbeddedDocument[i] = EventEmitter.prototype[i];\n  }\n\n  EmbeddedDocument.options = options;\n\n  return EmbeddedDocument;\n}\n\n/**\n * Adds a discriminator to this document array.\n *\n * #### Example:\n *\n *     const shapeSchema = Schema({ name: String }, { discriminatorKey: 'kind' });\n *     const schema = Schema({ shapes: [shapeSchema] });\n *\n *     const docArrayPath = parentSchema.path('shapes');\n *     docArrayPath.discriminator('Circle', Schema({ radius: Number }));\n *\n * @param {String} name\n * @param {Schema} schema fields to add to the schema for instances of this sub-class\n * @param {Object|string} [options] If string, same as `options.value`.\n * @param {String} [options.value] the string stored in the `discriminatorKey` property. If not specified, Mongoose uses the `name` parameter.\n * @param {Boolean} [options.clone=true] By default, `discriminator()` clones the given `schema`. Set to `false` to skip cloning.\n * @see discriminators https://mongoosejs.com/docs/discriminators.html\n * @return {Function} the constructor Mongoose will use for creating instances of this discriminator model\n * @api public\n */\n\nSchemaDocumentArray.prototype.discriminator = function(name, schema, options) {\n  if (typeof name === 'function') {\n    name = utils.getFunctionName(name);\n  }\n\n  options = options || {};\n  const tiedValue = utils.isPOJO(options) ? options.value : options;\n  const clone = typeof options.clone === 'boolean' ? options.clone : true;\n\n  if (schema.instanceOfSchema && clone) {\n    schema = schema.clone();\n  }\n\n  schema = discriminator(this.casterConstructor, name, schema, tiedValue);\n\n  const EmbeddedDocument = _createConstructor(schema, null, this.casterConstructor);\n  EmbeddedDocument.baseCasterConstructor = this.casterConstructor;\n\n  try {\n    Object.defineProperty(EmbeddedDocument, 'name', {\n      value: name\n    });\n  } catch (error) {\n    // Ignore error, only happens on old versions of node\n  }\n\n  this.casterConstructor.discriminators[name] = EmbeddedDocument;\n\n  return this.casterConstructor.discriminators[name];\n};\n\n/**\n * Performs local validations first, then validations on each embedded doc\n *\n * @api private\n */\n\nSchemaDocumentArray.prototype.doValidate = function(array, fn, scope, options) {\n  // lazy load\n  MongooseDocumentArray || (MongooseDocumentArray = __webpack_require__(/*! ../types/documentArray */ \"../server/node_modules/mongoose/lib/types/documentArray/index.js\"));\n\n  const _this = this;\n  try {\n    SchemaType.prototype.doValidate.call(this, array, cb, scope);\n  } catch (err) {\n    return fn(err);\n  }\n\n  function cb(err) {\n    if (err) {\n      return fn(err);\n    }\n\n    let count = array && array.length;\n    let error;\n\n    if (!count) {\n      return fn();\n    }\n    if (options && options.updateValidator) {\n      return fn();\n    }\n    if (!utils.isMongooseDocumentArray(array)) {\n      array = new MongooseDocumentArray(array, _this.path, scope);\n    }\n\n    // handle sparse arrays, do not use array.forEach which does not\n    // iterate over sparse elements yet reports array.length including\n    // them :(\n\n    function callback(err) {\n      if (err != null) {\n        error = err;\n      }\n      --count || fn(error);\n    }\n\n    for (let i = 0, len = count; i < len; ++i) {\n      // sidestep sparse entries\n      let doc = array[i];\n      if (doc == null) {\n        --count || fn(error);\n        continue;\n      }\n\n      // If you set the array index directly, the doc might not yet be\n      // a full fledged mongoose subdoc, so make it into one.\n      if (!(doc instanceof Subdocument)) {\n        const Constructor = getConstructor(_this.casterConstructor, array[i]);\n        doc = array[i] = new Constructor(doc, array, undefined, undefined, i);\n      }\n\n      if (options != null && options.validateModifiedOnly && !doc.$isModified()) {\n        --count || fn(error);\n        continue;\n      }\n\n      doc.$__validate(callback);\n    }\n  }\n};\n\n/**\n * Performs local validations first, then validations on each embedded doc.\n *\n * #### Note:\n *\n * This method ignores the asynchronous validators.\n *\n * @return {MongooseError|undefined}\n * @api private\n */\n\nSchemaDocumentArray.prototype.doValidateSync = function(array, scope, options) {\n  const schemaTypeError = SchemaType.prototype.doValidateSync.call(this, array, scope);\n  if (schemaTypeError != null) {\n    return schemaTypeError;\n  }\n\n  const count = array && array.length;\n  let resultError = null;\n\n  if (!count) {\n    return;\n  }\n\n  // handle sparse arrays, do not use array.forEach which does not\n  // iterate over sparse elements yet reports array.length including\n  // them :(\n\n  for (let i = 0, len = count; i < len; ++i) {\n    // sidestep sparse entries\n    let doc = array[i];\n    if (!doc) {\n      continue;\n    }\n\n    // If you set the array index directly, the doc might not yet be\n    // a full fledged mongoose subdoc, so make it into one.\n    if (!(doc instanceof Subdocument)) {\n      const Constructor = getConstructor(this.casterConstructor, array[i]);\n      doc = array[i] = new Constructor(doc, array, undefined, undefined, i);\n    }\n\n    if (options != null && options.validateModifiedOnly && !doc.$isModified()) {\n      continue;\n    }\n\n    const subdocValidateError = doc.validateSync();\n\n    if (subdocValidateError && resultError == null) {\n      resultError = subdocValidateError;\n    }\n  }\n\n  return resultError;\n};\n\n/*!\n * ignore\n */\n\nSchemaDocumentArray.prototype.getDefault = function(scope, init, options) {\n  let ret = typeof this.defaultValue === 'function'\n    ? this.defaultValue.call(scope)\n    : this.defaultValue;\n\n  if (ret == null) {\n    return ret;\n  }\n\n  if (options && options.skipCast) {\n    return ret;\n  }\n\n  // lazy load\n  MongooseDocumentArray || (MongooseDocumentArray = __webpack_require__(/*! ../types/documentArray */ \"../server/node_modules/mongoose/lib/types/documentArray/index.js\"));\n\n  if (!Array.isArray(ret)) {\n    ret = [ret];\n  }\n\n  ret = new MongooseDocumentArray(ret, this.path, scope);\n\n  for (let i = 0; i < ret.length; ++i) {\n    const Constructor = getConstructor(this.casterConstructor, ret[i]);\n    const _subdoc = new Constructor({}, ret, undefined,\n      undefined, i);\n    _subdoc.$init(ret[i]);\n    _subdoc.isNew = true;\n\n    // Make sure all paths in the subdoc are set to `default` instead\n    // of `init` since we used `init`.\n    Object.assign(_subdoc.$__.activePaths.default, _subdoc.$__.activePaths.init);\n    _subdoc.$__.activePaths.init = {};\n\n    ret[i] = _subdoc;\n  }\n\n  return ret;\n};\n\nconst _toObjectOptions = Object.freeze({ transform: false, virtuals: false });\nconst initDocumentOptions = Object.freeze({ skipId: false, willInit: true });\n\n/**\n * Casts contents\n *\n * @param {Object} value\n * @param {Document} document that triggers the casting\n * @api private\n */\n\nSchemaDocumentArray.prototype.cast = function(value, doc, init, prev, options) {\n  // lazy load\n  MongooseDocumentArray || (MongooseDocumentArray = __webpack_require__(/*! ../types/documentArray */ \"../server/node_modules/mongoose/lib/types/documentArray/index.js\"));\n\n  // Skip casting if `value` is the same as the previous value, no need to cast. See gh-9266\n  if (value != null && value[arrayPathSymbol] != null && value === prev) {\n    return value;\n  }\n\n  let selected;\n  let subdoc;\n\n  options = options || {};\n\n  const path = options.path || this.path;\n\n  if (!Array.isArray(value)) {\n    if (!init && !SchemaDocumentArray.options.castNonArrays) {\n      throw new CastError('DocumentArray', value, this.path, null, this);\n    }\n    // gh-2442 mark whole array as modified if we're initializing a doc from\n    // the db and the path isn't an array in the document\n    if (!!doc && init) {\n      doc.markModified(path);\n    }\n    return this.cast([value], doc, init, prev, options);\n  }\n\n  // We need to create a new array, otherwise change tracking will\n  // update the old doc (gh-4449)\n  if (!options.skipDocumentArrayCast || utils.isMongooseDocumentArray(value)) {\n    value = new MongooseDocumentArray(value, path, doc);\n  }\n\n  if (prev != null) {\n    value[arrayAtomicsSymbol] = prev[arrayAtomicsSymbol] || {};\n  }\n\n  if (options.arrayPathIndex != null) {\n    value[arrayPathSymbol] = path + '.' + options.arrayPathIndex;\n  }\n\n  const rawArray = utils.isMongooseDocumentArray(value) ? value.__array : value;\n  const len = rawArray.length;\n\n  for (let i = 0; i < len; ++i) {\n    if (!rawArray[i]) {\n      continue;\n    }\n\n    const Constructor = getConstructor(this.casterConstructor, rawArray[i]);\n\n    // Check if the document has a different schema (re gh-3701)\n    if (rawArray[i].$__ != null && !(rawArray[i] instanceof Constructor)) {\n      const spreadDoc = handleSpreadDoc(rawArray[i], true);\n      if (rawArray[i] !== spreadDoc) {\n        rawArray[i] = spreadDoc;\n      } else {\n        rawArray[i] = rawArray[i].toObject({\n          transform: false,\n          // Special case: if different model, but same schema, apply virtuals\n          // re: gh-7898\n          virtuals: rawArray[i].schema === Constructor.schema\n        });\n      }\n    }\n\n    if (rawArray[i] instanceof Subdocument) {\n      if (rawArray[i][documentArrayParent] !== doc) {\n        if (init) {\n          const subdoc = new Constructor(null, value, initDocumentOptions, selected, i);\n          rawArray[i] = subdoc.$init(rawArray[i]);\n        } else {\n          const subdoc = new Constructor(rawArray[i], value, undefined, undefined, i);\n          rawArray[i] = subdoc;\n        }\n      }\n      // Might not have the correct index yet, so ensure it does.\n      if (rawArray[i].__index == null) {\n        rawArray[i].$setIndex(i);\n      }\n    } else if (rawArray[i] != null) {\n      if (init) {\n        if (doc) {\n          selected || (selected = scopePaths(this, doc.$__.selected, init));\n        } else {\n          selected = true;\n        }\n\n        subdoc = new Constructor(null, value, initDocumentOptions, selected, i);\n        rawArray[i] = subdoc.$init(rawArray[i]);\n      } else {\n        if (prev && typeof prev.id === 'function') {\n          subdoc = prev.id(rawArray[i]._id);\n        }\n\n        if (prev && subdoc && utils.deepEqual(subdoc.toObject(_toObjectOptions), rawArray[i])) {\n          // handle resetting doc with existing id and same data\n          subdoc.set(rawArray[i]);\n          // if set() is hooked it will have no return value\n          // see gh-746\n          rawArray[i] = subdoc;\n        } else {\n          try {\n            subdoc = new Constructor(rawArray[i], value, undefined,\n              undefined, i);\n            // if set() is hooked it will have no return value\n            // see gh-746\n            rawArray[i] = subdoc;\n          } catch (error) {\n            throw new CastError('embedded', rawArray[i],\n              value[arrayPathSymbol], error, this);\n          }\n        }\n      }\n    }\n  }\n\n  return value;\n};\n\n/*!\n * ignore\n */\n\nSchemaDocumentArray.prototype.clone = function() {\n  const options = Object.assign({}, this.options);\n  const schematype = new this.constructor(this.path, this.schema, options, this.schemaOptions);\n  schematype.validators = this.validators.slice();\n  if (this.requiredValidator !== undefined) {\n    schematype.requiredValidator = this.requiredValidator;\n  }\n  schematype.Constructor.discriminators = Object.assign({},\n    this.Constructor.discriminators);\n  return schematype;\n};\n\n/*!\n * ignore\n */\n\nSchemaDocumentArray.prototype.applyGetters = function(value, scope) {\n  return SchemaType.prototype.applyGetters.call(this, value, scope);\n};\n\n/**\n * Scopes paths selected in a query to this array.\n * Necessary for proper default application of subdocument values.\n *\n * @param {DocumentArrayPath} array the array to scope `fields` paths\n * @param {Object|undefined} fields the root fields selected in the query\n * @param {Boolean|undefined} init if we are being created part of a query result\n * @api private\n */\n\nfunction scopePaths(array, fields, init) {\n  if (!(init && fields)) {\n    return undefined;\n  }\n\n  const path = array.path + '.';\n  const keys = Object.keys(fields);\n  let i = keys.length;\n  const selected = {};\n  let hasKeys;\n  let key;\n  let sub;\n\n  while (i--) {\n    key = keys[i];\n    if (key.startsWith(path)) {\n      sub = key.substring(path.length);\n      if (sub === '$') {\n        continue;\n      }\n      if (sub.startsWith('$.')) {\n        sub = sub.substring(2);\n      }\n      hasKeys || (hasKeys = true);\n      selected[sub] = fields[key];\n    }\n  }\n\n  return hasKeys && selected || undefined;\n}\n\n/*!\n * ignore\n */\n\nSchemaDocumentArray.defaultOptions = {};\n\n/**\n * Sets a default option for all DocumentArray instances.\n *\n * #### Example:\n *\n *     // Make all numbers have option `min` equal to 0.\n *     mongoose.Schema.DocumentArray.set('_id', false);\n *\n * @param {String} option The name of the option you'd like to set (e.g. trim, lowercase, etc...)\n * @param {Any} value The value of the option you'd like to set.\n * @return {void}\n * @function set\n * @static\n * @api public\n */\n\nSchemaDocumentArray.set = SchemaType.set;\n\nSchemaDocumentArray.setters = [];\n\n/**\n * Attaches a getter for all DocumentArrayPath instances\n *\n * @param {Function} getter\n * @return {this}\n * @function get\n * @static\n * @api public\n */\n\nSchemaDocumentArray.get = SchemaType.get;\n\n/*!\n * Module exports.\n */\n\nmodule.exports = SchemaDocumentArray;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvc2NoZW1hL2RvY3VtZW50QXJyYXkuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7QUFDQTtBQUNBOztBQUVBLGtCQUFrQixtQkFBTyxDQUFDLHdFQUFlO0FBQ3pDLDZCQUE2QixtQkFBTyxDQUFDLGtHQUF3QjtBQUM3RCxxQkFBcUIsMERBQThCO0FBQ25ELG9CQUFvQixtQkFBTyxDQUFDLG9FQUFTO0FBQ3JDO0FBQ0EsRUFBRSxtQkFBTyxDQUFDLHdIQUF1QztBQUNqRCxtQkFBbUIsbUJBQU8sQ0FBQyx3RUFBZTtBQUMxQyxzQkFBc0IsbUJBQU8sQ0FBQywwR0FBZ0M7QUFDOUQsdUJBQXVCLG1CQUFPLENBQUMsOEdBQWtDO0FBQ2pFLHdCQUF3QixtQkFBTyxDQUFDLG9IQUFxQztBQUNyRSxjQUFjLG1CQUFPLENBQUMsOERBQVU7QUFDaEMsdUJBQXVCLG1CQUFPLENBQUMsNEhBQXlDO0FBQ3hFLGlDQUFpQyxtQkFBTyxDQUFDLHNHQUE4Qjs7QUFFdkUsMkJBQTJCLDRIQUFnRDtBQUMzRSx3QkFBd0IseUhBQTZDO0FBQ3JFLDRCQUE0Qiw2SEFBaUQ7O0FBRTdFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFD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O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbGllbnQvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvc2NoZW1hL2RvY3VtZW50QXJyYXkuanM/NmZkMCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbi8qIVxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG5jb25zdCBDYXN0RXJyb3IgPSByZXF1aXJlKCcuLi9lcnJvci9jYXN0Jyk7XG5jb25zdCBEb2N1bWVudEFycmF5RWxlbWVudCA9IHJlcXVpcmUoJy4vZG9jdW1lbnRBcnJheUVsZW1lbnQnKTtcbmNvbnN0IEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcbmNvbnN0IFNjaGVtYUFycmF5ID0gcmVxdWlyZSgnLi9hcnJheScpO1xuY29uc3QgU2NoZW1hRG9jdW1lbnRBcnJheU9wdGlvbnMgPVxuICByZXF1aXJlKCcuLi9vcHRpb25zL3NjaGVtYURvY3VtZW50QXJyYXlPcHRpb25zJyk7XG5jb25zdCBTY2hlbWFUeXBlID0gcmVxdWlyZSgnLi4vc2NoZW1hVHlwZScpO1xuY29uc3QgZGlzY3JpbWluYXRvciA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvbW9kZWwvZGlzY3JpbWluYXRvcicpO1xuY29uc3QgaGFuZGxlSWRPcHRpb24gPSByZXF1aXJlKCcuLi9oZWxwZXJzL3NjaGVtYS9oYW5kbGVJZE9wdGlvbicpO1xuY29uc3QgaGFuZGxlU3ByZWFkRG9jID0gcmVxdWlyZSgnLi4vaGVscGVycy9kb2N1bWVudC9oYW5kbGVTcHJlYWREb2MnKTtcbmNvbnN0IHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMnKTtcbmNvbnN0IGdldENvbnN0cnVjdG9yID0gcmVxdWlyZSgnLi4vaGVscGVycy9kaXNjcmltaW5hdG9yL2dldENvbnN0cnVjdG9yJyk7XG5jb25zdCBJbnZhbGlkU2NoZW1hT3B0aW9uRXJyb3IgPSByZXF1aXJlKCcuLi9lcnJvci9pbnZhbGlkU2NoZW1hT3B0aW9uJyk7XG5cbmNvbnN0IGFycmF5QXRvbWljc1N5bWJvbCA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvc3ltYm9scycpLmFycmF5QXRvbWljc1N5bWJvbDtcbmNvbnN0IGFycmF5UGF0aFN5bWJvbCA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvc3ltYm9scycpLmFycmF5UGF0aFN5bWJvbDtcbmNvbnN0IGRvY3VtZW50QXJyYXlQYXJlbnQgPSByZXF1aXJlKCcuLi9oZWxwZXJzL3N5bWJvbHMnKS5kb2N1bWVudEFycmF5UGFyZW50O1xuXG5sZXQgTW9uZ29vc2VEb2N1bWVudEFycmF5O1xubGV0IFN1YmRvY3VtZW50O1xuXG4vKipcbiAqIFN1YmRvY3NBcnJheSBTY2hlbWFUeXBlIGNvbnN0cnVjdG9yXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGtleVxuICogQHBhcmFtIHtTY2hlbWF9IHNjaGVtYVxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEBwYXJhbSB7T2JqZWN0fSBzY2hlbWFPcHRpb25zXG4gKiBAaW5oZXJpdHMgU2NoZW1hQXJyYXlcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gU2NoZW1hRG9jdW1lbnRBcnJheShrZXksIHNjaGVtYSwgb3B0aW9ucywgc2NoZW1hT3B0aW9ucykge1xuICBpZiAoc2NoZW1hLm9wdGlvbnMgJiYgc2NoZW1hLm9wdGlvbnMudGltZXNlcmllcykge1xuICAgIHRocm93IG5ldyBJbnZhbGlkU2NoZW1hT3B0aW9uRXJyb3Ioa2V5LCAndGltZXNlcmllcycpO1xuICB9XG4gIGNvbnN0IHNjaGVtYVR5cGVJZE9wdGlvbiA9IFNjaGVtYURvY3VtZW50QXJyYXkuZGVmYXVsdE9wdGlvbnMgJiZcbiAgICBTY2hlbWFEb2N1bWVudEFycmF5LmRlZmF1bHRPcHRpb25zLl9pZDtcbiAgaWYgKHNjaGVtYVR5cGVJZE9wdGlvbiAhPSBudWxsKSB7XG4gICAgc2NoZW1hT3B0aW9ucyA9IHNjaGVtYU9wdGlvbnMgfHwge307XG4gICAgc2NoZW1hT3B0aW9ucy5faWQgPSBzY2hlbWFUeXBlSWRPcHRpb247XG4gIH1cblxuICBpZiAoc2NoZW1hT3B0aW9ucyAhPSBudWxsICYmIHNjaGVtYU9wdGlvbnMuX2lkICE9IG51bGwpIHtcbiAgICBzY2hlbWEgPSBoYW5kbGVJZE9wdGlvbihzY2hlbWEsIHNjaGVtYU9wdGlvbnMpO1xuICB9IGVsc2UgaWYgKG9wdGlvbnMgIT0gbnVsbCAmJiBvcHRpb25zLl9pZCAhPSBudWxsKSB7XG4gICAgc2NoZW1hID0gaGFuZGxlSWRPcHRpb24oc2NoZW1hLCBvcHRpb25zKTtcbiAgfVxuXG4gIGNvbnN0IEVtYmVkZGVkRG9jdW1lbnQgPSBfY3JlYXRlQ29uc3RydWN0b3Ioc2NoZW1hLCBvcHRpb25zKTtcbiAgRW1iZWRkZWREb2N1bWVudC5wcm90b3R5cGUuJGJhc2VQYXRoID0ga2V5O1xuXG4gIFNjaGVtYUFycmF5LmNhbGwodGhpcywga2V5LCBFbWJlZGRlZERvY3VtZW50LCBvcHRpb25zKTtcblxuICB0aGlzLnNjaGVtYSA9IHNjaGVtYTtcbiAgdGhpcy5zY2hlbWFPcHRpb25zID0gc2NoZW1hT3B0aW9ucyB8fCB7fTtcbiAgdGhpcy4kaXNNb25nb29zZURvY3VtZW50QXJyYXkgPSB0cnVlO1xuICB0aGlzLkNvbnN0cnVjdG9yID0gRW1iZWRkZWREb2N1bWVudDtcblxuICBFbWJlZGRlZERvY3VtZW50LmJhc2UgPSBzY2hlbWEuYmFzZTtcblxuICBjb25zdCBmbiA9IHRoaXMuZGVmYXVsdFZhbHVlO1xuXG4gIGlmICghKCdkZWZhdWx0VmFsdWUnIGluIHRoaXMpIHx8IGZuICE9PSB2b2lkIDApIHtcbiAgICB0aGlzLmRlZmF1bHQoZnVuY3Rpb24oKSB7XG4gICAgICBsZXQgYXJyID0gZm4uY2FsbCh0aGlzKTtcbiAgICAgIGlmIChhcnIgIT0gbnVsbCAmJiAhQXJyYXkuaXNBcnJheShhcnIpKSB7XG4gICAgICAgIGFyciA9IFthcnJdO1xuICAgICAgfVxuICAgICAgLy8gTGVhdmUgaXQgdXAgdG8gYGNhc3QoKWAgdG8gY29udmVydCB0aGlzIHRvIGEgZG9jdW1lbnRhcnJheVxuICAgICAgcmV0dXJuIGFycjtcbiAgICB9KTtcbiAgfVxuXG4gIGNvbnN0ICRwYXJlbnRTY2hlbWFUeXBlID0gdGhpcztcbiAgdGhpcy4kZW1iZWRkZWRTY2hlbWFUeXBlID0gbmV3IERvY3VtZW50QXJyYXlFbGVtZW50KGtleSArICcuJCcsIHtcbiAgICByZXF1aXJlZDogdGhpcyAmJlxuICAgICAgdGhpcy5zY2hlbWFPcHRpb25zICYmXG4gICAgICB0aGlzLnNjaGVtYU9wdGlvbnMucmVxdWlyZWQgfHwgZmFsc2UsXG4gICAgJHBhcmVudFNjaGVtYVR5cGVcbiAgfSk7XG5cbiAgdGhpcy4kZW1iZWRkZWRTY2hlbWFUeXBlLmNhc3RlciA9IHRoaXMuQ29uc3RydWN0b3I7XG4gIHRoaXMuJGVtYmVkZGVkU2NoZW1hVHlwZS5zY2hlbWEgPSB0aGlzLnNjaGVtYTtcbn1cblxuLyoqXG4gKiBUaGlzIHNjaGVtYSB0eXBlJ3MgbmFtZSwgdG8gZGVmZW5kIGFnYWluc3QgbWluaWZpZXJzIHRoYXQgbWFuZ2xlXG4gKiBmdW5jdGlvbiBuYW1lcy5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5TY2hlbWFEb2N1bWVudEFycmF5LnNjaGVtYU5hbWUgPSAnRG9jdW1lbnRBcnJheSc7XG5cbi8qKlxuICogT3B0aW9ucyBmb3IgYWxsIGRvY3VtZW50IGFycmF5cy5cbiAqXG4gKiAtIGBjYXN0Tm9uQXJyYXlzYDogYHRydWVgIGJ5IGRlZmF1bHQuIElmIGBmYWxzZWAsIE1vbmdvb3NlIHdpbGwgdGhyb3cgYSBDYXN0RXJyb3Igd2hlbiBhIHZhbHVlIGlzbid0IGFuIGFycmF5LiBJZiBgdHJ1ZWAsIE1vbmdvb3NlIHdpbGwgd3JhcCB0aGUgcHJvdmlkZWQgdmFsdWUgaW4gYW4gYXJyYXkgYmVmb3JlIGNhc3RpbmcuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5TY2hlbWFEb2N1bWVudEFycmF5Lm9wdGlvbnMgPSB7IGNhc3ROb25BcnJheXM6IHRydWUgfTtcblxuLyohXG4gKiBJbmhlcml0cyBmcm9tIFNjaGVtYUFycmF5LlxuICovXG5TY2hlbWFEb2N1bWVudEFycmF5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoU2NoZW1hQXJyYXkucHJvdG90eXBlKTtcblNjaGVtYURvY3VtZW50QXJyYXkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gU2NoZW1hRG9jdW1lbnRBcnJheTtcblNjaGVtYURvY3VtZW50QXJyYXkucHJvdG90eXBlLk9wdGlvbnNDb25zdHJ1Y3RvciA9IFNjaGVtYURvY3VtZW50QXJyYXlPcHRpb25zO1xuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cbmZ1bmN0aW9uIF9jcmVhdGVDb25zdHJ1Y3RvcihzY2hlbWEsIG9wdGlvbnMsIGJhc2VDbGFzcykge1xuICBTdWJkb2N1bWVudCB8fCAoU3ViZG9jdW1lbnQgPSByZXF1aXJlKCcuLi90eXBlcy9hcnJheVN1YmRvY3VtZW50JykpO1xuXG4gIC8vIGNvbXBpbGUgYW4gZW1iZWRkZWQgZG9jdW1lbnQgZm9yIHRoaXMgc2NoZW1hXG4gIGZ1bmN0aW9uIEVtYmVkZGVkRG9jdW1lbnQoKSB7XG4gICAgU3ViZG9jdW1lbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICBpZiAodGhpcy5fX3BhcmVudEFycmF5ID09IG51bGwgfHwgdGhpcy5fX3BhcmVudEFycmF5LmdldEFycmF5UGFyZW50KCkgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLiRzZXNzaW9uKHRoaXMuX19wYXJlbnRBcnJheS5nZXRBcnJheVBhcmVudCgpLiRzZXNzaW9uKCkpO1xuICB9XG5cbiAgc2NoZW1hLl9wcmVDb21waWxlKCk7XG5cbiAgY29uc3QgcHJvdG8gPSBiYXNlQ2xhc3MgIT0gbnVsbCA/IGJhc2VDbGFzcy5wcm90b3R5cGUgOiBTdWJkb2N1bWVudC5wcm90b3R5cGU7XG4gIEVtYmVkZGVkRG9jdW1lbnQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShwcm90byk7XG4gIEVtYmVkZGVkRG9jdW1lbnQucHJvdG90eXBlLiRfX3NldFNjaGVtYShzY2hlbWEpO1xuICBFbWJlZGRlZERvY3VtZW50LnNjaGVtYSA9IHNjaGVtYTtcbiAgRW1iZWRkZWREb2N1bWVudC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBFbWJlZGRlZERvY3VtZW50O1xuICBFbWJlZGRlZERvY3VtZW50LiRpc0FycmF5U3ViZG9jdW1lbnQgPSB0cnVlO1xuICBFbWJlZGRlZERvY3VtZW50LmV2ZW50cyA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgRW1iZWRkZWREb2N1bWVudC5iYXNlID0gc2NoZW1hLmJhc2U7XG5cbiAgLy8gYXBwbHkgbWV0aG9kc1xuICBmb3IgKGNvbnN0IGkgaW4gc2NoZW1hLm1ldGhvZHMpIHtcbiAgICBFbWJlZGRlZERvY3VtZW50LnByb3RvdHlwZVtpXSA9IHNjaGVtYS5tZXRob2RzW2ldO1xuICB9XG5cbiAgLy8gYXBwbHkgc3RhdGljc1xuICBmb3IgKGNvbnN0IGkgaW4gc2NoZW1hLnN0YXRpY3MpIHtcbiAgICBFbWJlZGRlZERvY3VtZW50W2ldID0gc2NoZW1hLnN0YXRpY3NbaV07XG4gIH1cblxuICBmb3IgKGNvbnN0IGkgaW4gRXZlbnRFbWl0dGVyLnByb3RvdHlwZSkge1xuICAgIEVtYmVkZGVkRG9jdW1lbnRbaV0gPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlW2ldO1xuICB9XG5cbiAgRW1iZWRkZWREb2N1bWVudC5vcHRpb25zID0gb3B0aW9ucztcblxuICByZXR1cm4gRW1iZWRkZWREb2N1bWVudDtcbn1cblxuLyoqXG4gKiBBZGRzIGEgZGlzY3JpbWluYXRvciB0byB0aGlzIGRvY3VtZW50IGFycmF5LlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgY29uc3Qgc2hhcGVTY2hlbWEgPSBTY2hlbWEoeyBuYW1lOiBTdHJpbmcgfSwgeyBkaXNjcmltaW5hdG9yS2V5OiAna2luZCcgfSk7XG4gKiAgICAgY29uc3Qgc2NoZW1hID0gU2NoZW1hKHsgc2hhcGVzOiBbc2hhcGVTY2hlbWFdIH0pO1xuICpcbiAqICAgICBjb25zdCBkb2NBcnJheVBhdGggPSBwYXJlbnRTY2hlbWEucGF0aCgnc2hhcGVzJyk7XG4gKiAgICAgZG9jQXJyYXlQYXRoLmRpc2NyaW1pbmF0b3IoJ0NpcmNsZScsIFNjaGVtYSh7IHJhZGl1czogTnVtYmVyIH0pKTtcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICogQHBhcmFtIHtTY2hlbWF9IHNjaGVtYSBmaWVsZHMgdG8gYWRkIHRvIHRoZSBzY2hlbWEgZm9yIGluc3RhbmNlcyBvZiB0aGlzIHN1Yi1jbGFzc1xuICogQHBhcmFtIHtPYmplY3R8c3RyaW5nfSBbb3B0aW9uc10gSWYgc3RyaW5nLCBzYW1lIGFzIGBvcHRpb25zLnZhbHVlYC5cbiAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy52YWx1ZV0gdGhlIHN0cmluZyBzdG9yZWQgaW4gdGhlIGBkaXNjcmltaW5hdG9yS2V5YCBwcm9wZXJ0eS4gSWYgbm90IHNwZWNpZmllZCwgTW9uZ29vc2UgdXNlcyB0aGUgYG5hbWVgIHBhcmFtZXRlci5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuY2xvbmU9dHJ1ZV0gQnkgZGVmYXVsdCwgYGRpc2NyaW1pbmF0b3IoKWAgY2xvbmVzIHRoZSBnaXZlbiBgc2NoZW1hYC4gU2V0IHRvIGBmYWxzZWAgdG8gc2tpcCBjbG9uaW5nLlxuICogQHNlZSBkaXNjcmltaW5hdG9ycyBodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvZGlzY3JpbWluYXRvcnMuaHRtbFxuICogQHJldHVybiB7RnVuY3Rpb259IHRoZSBjb25zdHJ1Y3RvciBNb25nb29zZSB3aWxsIHVzZSBmb3IgY3JlYXRpbmcgaW5zdGFuY2VzIG9mIHRoaXMgZGlzY3JpbWluYXRvciBtb2RlbFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5TY2hlbWFEb2N1bWVudEFycmF5LnByb3RvdHlwZS5kaXNjcmltaW5hdG9yID0gZnVuY3Rpb24obmFtZSwgc2NoZW1hLCBvcHRpb25zKSB7XG4gIGlmICh0eXBlb2YgbmFtZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIG5hbWUgPSB1dGlscy5nZXRGdW5jdGlvbk5hbWUobmFtZSk7XG4gIH1cblxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgY29uc3QgdGllZFZhbHVlID0gdXRpbHMuaXNQT0pPKG9wdGlvbnMpID8gb3B0aW9ucy52YWx1ZSA6IG9wdGlvbnM7XG4gIGNvbnN0IGNsb25lID0gdHlwZW9mIG9wdGlvbnMuY2xvbmUgPT09ICdib29sZWFuJyA/IG9wdGlvbnMuY2xvbmUgOiB0cnVlO1xuXG4gIGlmIChzY2hlbWEuaW5zdGFuY2VPZlNjaGVtYSAmJiBjbG9uZSkge1xuICAgIHNjaGVtYSA9IHNjaGVtYS5jbG9uZSgpO1xuICB9XG5cbiAgc2NoZW1hID0gZGlzY3JpbWluYXRvcih0aGlzLmNhc3RlckNvbnN0cnVjdG9yLCBuYW1lLCBzY2hlbWEsIHRpZWRWYWx1ZSk7XG5cbiAgY29uc3QgRW1iZWRkZWREb2N1bWVudCA9IF9jcmVhdGVDb25zdHJ1Y3RvcihzY2hlbWEsIG51bGwsIHRoaXMuY2FzdGVyQ29uc3RydWN0b3IpO1xuICBFbWJlZGRlZERvY3VtZW50LmJhc2VDYXN0ZXJDb25zdHJ1Y3RvciA9IHRoaXMuY2FzdGVyQ29uc3RydWN0b3I7XG5cbiAgdHJ5IHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRW1iZWRkZWREb2N1bWVudCwgJ25hbWUnLCB7XG4gICAgICB2YWx1ZTogbmFtZVxuICAgIH0pO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIC8vIElnbm9yZSBlcnJvciwgb25seSBoYXBwZW5zIG9uIG9sZCB2ZXJzaW9ucyBvZiBub2RlXG4gIH1cblxuICB0aGlzLmNhc3RlckNvbnN0cnVjdG9yLmRpc2NyaW1pbmF0b3JzW25hbWVdID0gRW1iZWRkZWREb2N1bWVudDtcblxuICByZXR1cm4gdGhpcy5jYXN0ZXJDb25zdHJ1Y3Rvci5kaXNjcmltaW5hdG9yc1tuYW1lXTtcbn07XG5cbi8qKlxuICogUGVyZm9ybXMgbG9jYWwgdmFsaWRhdGlvbnMgZmlyc3QsIHRoZW4gdmFsaWRhdGlvbnMgb24gZWFjaCBlbWJlZGRlZCBkb2NcbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5TY2hlbWFEb2N1bWVudEFycmF5LnByb3RvdHlwZS5kb1ZhbGlkYXRlID0gZnVuY3Rpb24oYXJyYXksIGZuLCBzY29wZSwgb3B0aW9ucykge1xuICAvLyBsYXp5IGxvYWRcbiAgTW9uZ29vc2VEb2N1bWVudEFycmF5IHx8IChNb25nb29zZURvY3VtZW50QXJyYXkgPSByZXF1aXJlKCcuLi90eXBlcy9kb2N1bWVudEFycmF5JykpO1xuXG4gIGNvbnN0IF90aGlzID0gdGhpcztcbiAgdHJ5IHtcbiAgICBTY2hlbWFUeXBlLnByb3RvdHlwZS5kb1ZhbGlkYXRlLmNhbGwodGhpcywgYXJyYXksIGNiLCBzY29wZSk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHJldHVybiBmbihlcnIpO1xuICB9XG5cbiAgZnVuY3Rpb24gY2IoZXJyKSB7XG4gICAgaWYgKGVycikge1xuICAgICAgcmV0dXJuIGZuKGVycik7XG4gICAgfVxuXG4gICAgbGV0IGNvdW50ID0gYXJyYXkgJiYgYXJyYXkubGVuZ3RoO1xuICAgIGxldCBlcnJvcjtcblxuICAgIGlmICghY291bnQpIHtcbiAgICAgIHJldHVybiBmbigpO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLnVwZGF0ZVZhbGlkYXRvcikge1xuICAgICAgcmV0dXJuIGZuKCk7XG4gICAgfVxuICAgIGlmICghdXRpbHMuaXNNb25nb29zZURvY3VtZW50QXJyYXkoYXJyYXkpKSB7XG4gICAgICBhcnJheSA9IG5ldyBNb25nb29zZURvY3VtZW50QXJyYXkoYXJyYXksIF90aGlzLnBhdGgsIHNjb3BlKTtcbiAgICB9XG5cbiAgICAvLyBoYW5kbGUgc3BhcnNlIGFycmF5cywgZG8gbm90IHVzZSBhcnJheS5mb3JFYWNoIHdoaWNoIGRvZXMgbm90XG4gICAgLy8gaXRlcmF0ZSBvdmVyIHNwYXJzZSBlbGVtZW50cyB5ZXQgcmVwb3J0cyBhcnJheS5sZW5ndGggaW5jbHVkaW5nXG4gICAgLy8gdGhlbSA6KFxuXG4gICAgZnVuY3Rpb24gY2FsbGJhY2soZXJyKSB7XG4gICAgICBpZiAoZXJyICE9IG51bGwpIHtcbiAgICAgICAgZXJyb3IgPSBlcnI7XG4gICAgICB9XG4gICAgICAtLWNvdW50IHx8IGZuKGVycm9yKTtcbiAgICB9XG5cbiAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gY291bnQ7IGkgPCBsZW47ICsraSkge1xuICAgICAgLy8gc2lkZXN0ZXAgc3BhcnNlIGVudHJpZXNcbiAgICAgIGxldCBkb2MgPSBhcnJheVtpXTtcbiAgICAgIGlmIChkb2MgPT0gbnVsbCkge1xuICAgICAgICAtLWNvdW50IHx8IGZuKGVycm9yKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIC8vIElmIHlvdSBzZXQgdGhlIGFycmF5IGluZGV4IGRpcmVjdGx5LCB0aGUgZG9jIG1pZ2h0IG5vdCB5ZXQgYmVcbiAgICAgIC8vIGEgZnVsbCBmbGVkZ2VkIG1vbmdvb3NlIHN1YmRvYywgc28gbWFrZSBpdCBpbnRvIG9uZS5cbiAgICAgIGlmICghKGRvYyBpbnN0YW5jZW9mIFN1YmRvY3VtZW50KSkge1xuICAgICAgICBjb25zdCBDb25zdHJ1Y3RvciA9IGdldENvbnN0cnVjdG9yKF90aGlzLmNhc3RlckNvbnN0cnVjdG9yLCBhcnJheVtpXSk7XG4gICAgICAgIGRvYyA9IGFycmF5W2ldID0gbmV3IENvbnN0cnVjdG9yKGRvYywgYXJyYXksIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBpKTtcbiAgICAgIH1cblxuICAgICAgaWYgKG9wdGlvbnMgIT0gbnVsbCAmJiBvcHRpb25zLnZhbGlkYXRlTW9kaWZpZWRPbmx5ICYmICFkb2MuJGlzTW9kaWZpZWQoKSkge1xuICAgICAgICAtLWNvdW50IHx8IGZuKGVycm9yKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGRvYy4kX192YWxpZGF0ZShjYWxsYmFjayk7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIFBlcmZvcm1zIGxvY2FsIHZhbGlkYXRpb25zIGZpcnN0LCB0aGVuIHZhbGlkYXRpb25zIG9uIGVhY2ggZW1iZWRkZWQgZG9jLlxuICpcbiAqICMjIyMgTm90ZTpcbiAqXG4gKiBUaGlzIG1ldGhvZCBpZ25vcmVzIHRoZSBhc3luY2hyb25vdXMgdmFsaWRhdG9ycy5cbiAqXG4gKiBAcmV0dXJuIHtNb25nb29zZUVycm9yfHVuZGVmaW5lZH1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNjaGVtYURvY3VtZW50QXJyYXkucHJvdG90eXBlLmRvVmFsaWRhdGVTeW5jID0gZnVuY3Rpb24oYXJyYXksIHNjb3BlLCBvcHRpb25zKSB7XG4gIGNvbnN0IHNjaGVtYVR5cGVFcnJvciA9IFNjaGVtYVR5cGUucHJvdG90eXBlLmRvVmFsaWRhdGVTeW5jLmNhbGwodGhpcywgYXJyYXksIHNjb3BlKTtcbiAgaWYgKHNjaGVtYVR5cGVFcnJvciAhPSBudWxsKSB7XG4gICAgcmV0dXJuIHNjaGVtYVR5cGVFcnJvcjtcbiAgfVxuXG4gIGNvbnN0IGNvdW50ID0gYXJyYXkgJiYgYXJyYXkubGVuZ3RoO1xuICBsZXQgcmVzdWx0RXJyb3IgPSBudWxsO1xuXG4gIGlmICghY291bnQpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBoYW5kbGUgc3BhcnNlIGFycmF5cywgZG8gbm90IHVzZSBhcnJheS5mb3JFYWNoIHdoaWNoIGRvZXMgbm90XG4gIC8vIGl0ZXJhdGUgb3ZlciBzcGFyc2UgZWxlbWVudHMgeWV0IHJlcG9ydHMgYXJyYXkubGVuZ3RoIGluY2x1ZGluZ1xuICAvLyB0aGVtIDooXG5cbiAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IGNvdW50OyBpIDwgbGVuOyArK2kpIHtcbiAgICAvLyBzaWRlc3RlcCBzcGFyc2UgZW50cmllc1xuICAgIGxldCBkb2MgPSBhcnJheVtpXTtcbiAgICBpZiAoIWRvYykge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gSWYgeW91IHNldCB0aGUgYXJyYXkgaW5kZXggZGlyZWN0bHksIHRoZSBkb2MgbWlnaHQgbm90IHlldCBiZVxuICAgIC8vIGEgZnVsbCBmbGVkZ2VkIG1vbmdvb3NlIHN1YmRvYywgc28gbWFrZSBpdCBpbnRvIG9uZS5cbiAgICBpZiAoIShkb2MgaW5zdGFuY2VvZiBTdWJkb2N1bWVudCkpIHtcbiAgICAgIGNvbnN0IENvbnN0cnVjdG9yID0gZ2V0Q29uc3RydWN0b3IodGhpcy5jYXN0ZXJDb25zdHJ1Y3RvciwgYXJyYXlbaV0pO1xuICAgICAgZG9jID0gYXJyYXlbaV0gPSBuZXcgQ29uc3RydWN0b3IoZG9jLCBhcnJheSwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGkpO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zICE9IG51bGwgJiYgb3B0aW9ucy52YWxpZGF0ZU1vZGlmaWVkT25seSAmJiAhZG9jLiRpc01vZGlmaWVkKCkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGNvbnN0IHN1YmRvY1ZhbGlkYXRlRXJyb3IgPSBkb2MudmFsaWRhdGVTeW5jKCk7XG5cbiAgICBpZiAoc3ViZG9jVmFsaWRhdGVFcnJvciAmJiByZXN1bHRFcnJvciA9PSBudWxsKSB7XG4gICAgICByZXN1bHRFcnJvciA9IHN1YmRvY1ZhbGlkYXRlRXJyb3I7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlc3VsdEVycm9yO1xufTtcblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5TY2hlbWFEb2N1bWVudEFycmF5LnByb3RvdHlwZS5nZXREZWZhdWx0ID0gZnVuY3Rpb24oc2NvcGUsIGluaXQsIG9wdGlvbnMpIHtcbiAgbGV0IHJldCA9IHR5cGVvZiB0aGlzLmRlZmF1bHRWYWx1ZSA9PT0gJ2Z1bmN0aW9uJ1xuICAgID8gdGhpcy5kZWZhdWx0VmFsdWUuY2FsbChzY29wZSlcbiAgICA6IHRoaXMuZGVmYXVsdFZhbHVlO1xuXG4gIGlmIChyZXQgPT0gbnVsbCkge1xuICAgIHJldHVybiByZXQ7XG4gIH1cblxuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLnNraXBDYXN0KSB7XG4gICAgcmV0dXJuIHJldDtcbiAgfVxuXG4gIC8vIGxhenkgbG9hZFxuICBNb25nb29zZURvY3VtZW50QXJyYXkgfHwgKE1vbmdvb3NlRG9jdW1lbnRBcnJheSA9IHJlcXVpcmUoJy4uL3R5cGVzL2RvY3VtZW50QXJyYXknKSk7XG5cbiAgaWYgKCFBcnJheS5pc0FycmF5KHJldCkpIHtcbiAgICByZXQgPSBbcmV0XTtcbiAgfVxuXG4gIHJldCA9IG5ldyBNb25nb29zZURvY3VtZW50QXJyYXkocmV0LCB0aGlzLnBhdGgsIHNjb3BlKTtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IHJldC5sZW5ndGg7ICsraSkge1xuICAgIGNvbnN0IENvbnN0cnVjdG9yID0gZ2V0Q29uc3RydWN0b3IodGhpcy5jYXN0ZXJDb25zdHJ1Y3RvciwgcmV0W2ldKTtcbiAgICBjb25zdCBfc3ViZG9jID0gbmV3IENvbnN0cnVjdG9yKHt9LCByZXQsIHVuZGVmaW5lZCxcbiAgICAgIHVuZGVmaW5lZCwgaSk7XG4gICAgX3N1YmRvYy4kaW5pdChyZXRbaV0pO1xuICAgIF9zdWJkb2MuaXNOZXcgPSB0cnVlO1xuXG4gICAgLy8gTWFrZSBzdXJlIGFsbCBwYXRocyBpbiB0aGUgc3ViZG9jIGFyZSBzZXQgdG8gYGRlZmF1bHRgIGluc3RlYWRcbiAgICAvLyBvZiBgaW5pdGAgc2luY2Ugd2UgdXNlZCBgaW5pdGAuXG4gICAgT2JqZWN0LmFzc2lnbihfc3ViZG9jLiRfXy5hY3RpdmVQYXRocy5kZWZhdWx0LCBfc3ViZG9jLiRfXy5hY3RpdmVQYXRocy5pbml0KTtcbiAgICBfc3ViZG9jLiRfXy5hY3RpdmVQYXRocy5pbml0ID0ge307XG5cbiAgICByZXRbaV0gPSBfc3ViZG9jO1xuICB9XG5cbiAgcmV0dXJuIHJldDtcbn07XG5cbmNvbnN0IF90b09iamVjdE9wdGlvbnMgPSBPYmplY3QuZnJlZXplKHsgdHJhbnNmb3JtOiBmYWxzZSwgdmlydHVhbHM6IGZhbHNlIH0pO1xuY29uc3QgaW5pdERvY3VtZW50T3B0aW9ucyA9IE9iamVjdC5mcmVlemUoeyBza2lwSWQ6IGZhbHNlLCB3aWxsSW5pdDogdHJ1ZSB9KTtcblxuLyoqXG4gKiBDYXN0cyBjb250ZW50c1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWx1ZVxuICogQHBhcmFtIHtEb2N1bWVudH0gZG9jdW1lbnQgdGhhdCB0cmlnZ2VycyB0aGUgY2FzdGluZ1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU2NoZW1hRG9jdW1lbnRBcnJheS5wcm90b3R5cGUuY2FzdCA9IGZ1bmN0aW9uKHZhbHVlLCBkb2MsIGluaXQsIHByZXYsIG9wdGlvbnMpIHtcbiAgLy8gbGF6eSBsb2FkXG4gIE1vbmdvb3NlRG9jdW1lbnRBcnJheSB8fCAoTW9uZ29vc2VEb2N1bWVudEFycmF5ID0gcmVxdWlyZSgnLi4vdHlwZXMvZG9jdW1lbnRBcnJheScpKTtcblxuICAvLyBTa2lwIGNhc3RpbmcgaWYgYHZhbHVlYCBpcyB0aGUgc2FtZSBhcyB0aGUgcHJldmlvdXMgdmFsdWUsIG5vIG5lZWQgdG8gY2FzdC4gU2VlIGdoLTkyNjZcbiAgaWYgKHZhbHVlICE9IG51bGwgJiYgdmFsdWVbYXJyYXlQYXRoU3ltYm9sXSAhPSBudWxsICYmIHZhbHVlID09PSBwcmV2KSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG5cbiAgbGV0IHNlbGVjdGVkO1xuICBsZXQgc3ViZG9jO1xuXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIGNvbnN0IHBhdGggPSBvcHRpb25zLnBhdGggfHwgdGhpcy5wYXRoO1xuXG4gIGlmICghQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICBpZiAoIWluaXQgJiYgIVNjaGVtYURvY3VtZW50QXJyYXkub3B0aW9ucy5jYXN0Tm9uQXJyYXlzKSB7XG4gICAgICB0aHJvdyBuZXcgQ2FzdEVycm9yKCdEb2N1bWVudEFycmF5JywgdmFsdWUsIHRoaXMucGF0aCwgbnVsbCwgdGhpcyk7XG4gICAgfVxuICAgIC8vIGdoLTI0NDIgbWFyayB3aG9sZSBhcnJheSBhcyBtb2RpZmllZCBpZiB3ZSdyZSBpbml0aWFsaXppbmcgYSBkb2MgZnJvbVxuICAgIC8vIHRoZSBkYiBhbmQgdGhlIHBhdGggaXNuJ3QgYW4gYXJyYXkgaW4gdGhlIGRvY3VtZW50XG4gICAgaWYgKCEhZG9jICYmIGluaXQpIHtcbiAgICAgIGRvYy5tYXJrTW9kaWZpZWQocGF0aCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmNhc3QoW3ZhbHVlXSwgZG9jLCBpbml0LCBwcmV2LCBvcHRpb25zKTtcbiAgfVxuXG4gIC8vIFdlIG5lZWQgdG8gY3JlYXRlIGEgbmV3IGFycmF5LCBvdGhlcndpc2UgY2hhbmdlIHRyYWNraW5nIHdpbGxcbiAgLy8gdXBkYXRlIHRoZSBvbGQgZG9jIChnaC00NDQ5KVxuICBpZiAoIW9wdGlvbnMuc2tpcERvY3VtZW50QXJyYXlDYXN0IHx8IHV0aWxzLmlzTW9uZ29vc2VEb2N1bWVudEFycmF5KHZhbHVlKSkge1xuICAgIHZhbHVlID0gbmV3IE1vbmdvb3NlRG9jdW1lbnRBcnJheSh2YWx1ZSwgcGF0aCwgZG9jKTtcbiAgfVxuXG4gIGlmIChwcmV2ICE9IG51bGwpIHtcbiAgICB2YWx1ZVthcnJheUF0b21pY3NTeW1ib2xdID0gcHJldlthcnJheUF0b21pY3NTeW1ib2xdIHx8IHt9O1xuICB9XG5cbiAgaWYgKG9wdGlvbnMuYXJyYXlQYXRoSW5kZXggIT0gbnVsbCkge1xuICAgIHZhbHVlW2FycmF5UGF0aFN5bWJvbF0gPSBwYXRoICsgJy4nICsgb3B0aW9ucy5hcnJheVBhdGhJbmRleDtcbiAgfVxuXG4gIGNvbnN0IHJhd0FycmF5ID0gdXRpbHMuaXNNb25nb29zZURvY3VtZW50QXJyYXkodmFsdWUpID8gdmFsdWUuX19hcnJheSA6IHZhbHVlO1xuICBjb25zdCBsZW4gPSByYXdBcnJheS5sZW5ndGg7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgIGlmICghcmF3QXJyYXlbaV0pIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGNvbnN0IENvbnN0cnVjdG9yID0gZ2V0Q29uc3RydWN0b3IodGhpcy5jYXN0ZXJDb25zdHJ1Y3RvciwgcmF3QXJyYXlbaV0pO1xuXG4gICAgLy8gQ2hlY2sgaWYgdGhlIGRvY3VtZW50IGhhcyBhIGRpZmZlcmVudCBzY2hlbWEgKHJlIGdoLTM3MDEpXG4gICAgaWYgKHJhd0FycmF5W2ldLiRfXyAhPSBudWxsICYmICEocmF3QXJyYXlbaV0gaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHtcbiAgICAgIGNvbnN0IHNwcmVhZERvYyA9IGhhbmRsZVNwcmVhZERvYyhyYXdBcnJheVtpXSwgdHJ1ZSk7XG4gICAgICBpZiAocmF3QXJyYXlbaV0gIT09IHNwcmVhZERvYykge1xuICAgICAgICByYXdBcnJheVtpXSA9IHNwcmVhZERvYztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJhd0FycmF5W2ldID0gcmF3QXJyYXlbaV0udG9PYmplY3Qoe1xuICAgICAgICAgIHRyYW5zZm9ybTogZmFsc2UsXG4gICAgICAgICAgLy8gU3BlY2lhbCBjYXNlOiBpZiBkaWZmZXJlbnQgbW9kZWwsIGJ1dCBzYW1lIHNjaGVtYSwgYXBwbHkgdmlydHVhbHNcbiAgICAgICAgICAvLyByZTogZ2gtNzg5OFxuICAgICAgICAgIHZpcnR1YWxzOiByYXdBcnJheVtpXS5zY2hlbWEgPT09IENvbnN0cnVjdG9yLnNjaGVtYVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocmF3QXJyYXlbaV0gaW5zdGFuY2VvZiBTdWJkb2N1bWVudCkge1xuICAgICAgaWYgKHJhd0FycmF5W2ldW2RvY3VtZW50QXJyYXlQYXJlbnRdICE9PSBkb2MpIHtcbiAgICAgICAgaWYgKGluaXQpIHtcbiAgICAgICAgICBjb25zdCBzdWJkb2MgPSBuZXcgQ29uc3RydWN0b3IobnVsbCwgdmFsdWUsIGluaXREb2N1bWVudE9wdGlvbnMsIHNlbGVjdGVkLCBpKTtcbiAgICAgICAgICByYXdBcnJheVtpXSA9IHN1YmRvYy4kaW5pdChyYXdBcnJheVtpXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc3Qgc3ViZG9jID0gbmV3IENvbnN0cnVjdG9yKHJhd0FycmF5W2ldLCB2YWx1ZSwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGkpO1xuICAgICAgICAgIHJhd0FycmF5W2ldID0gc3ViZG9jO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBNaWdodCBub3QgaGF2ZSB0aGUgY29ycmVjdCBpbmRleCB5ZXQsIHNvIGVuc3VyZSBpdCBkb2VzLlxuICAgICAgaWYgKHJhd0FycmF5W2ldLl9faW5kZXggPT0gbnVsbCkge1xuICAgICAgICByYXdBcnJheVtpXS4kc2V0SW5kZXgoaSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChyYXdBcnJheVtpXSAhPSBudWxsKSB7XG4gICAgICBpZiAoaW5pdCkge1xuICAgICAgICBpZiAoZG9jKSB7XG4gICAgICAgICAgc2VsZWN0ZWQgfHwgKHNlbGVjdGVkID0gc2NvcGVQYXRocyh0aGlzLCBkb2MuJF9fLnNlbGVjdGVkLCBpbml0KSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgc3ViZG9jID0gbmV3IENvbnN0cnVjdG9yKG51bGwsIHZhbHVlLCBpbml0RG9jdW1lbnRPcHRpb25zLCBzZWxlY3RlZCwgaSk7XG4gICAgICAgIHJhd0FycmF5W2ldID0gc3ViZG9jLiRpbml0KHJhd0FycmF5W2ldKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChwcmV2ICYmIHR5cGVvZiBwcmV2LmlkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgc3ViZG9jID0gcHJldi5pZChyYXdBcnJheVtpXS5faWQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHByZXYgJiYgc3ViZG9jICYmIHV0aWxzLmRlZXBFcXVhbChzdWJkb2MudG9PYmplY3QoX3RvT2JqZWN0T3B0aW9ucyksIHJhd0FycmF5W2ldKSkge1xuICAgICAgICAgIC8vIGhhbmRsZSByZXNldHRpbmcgZG9jIHdpdGggZXhpc3RpbmcgaWQgYW5kIHNhbWUgZGF0YVxuICAgICAgICAgIHN1YmRvYy5zZXQocmF3QXJyYXlbaV0pO1xuICAgICAgICAgIC8vIGlmIHNldCgpIGlzIGhvb2tlZCBpdCB3aWxsIGhhdmUgbm8gcmV0dXJuIHZhbHVlXG4gICAgICAgICAgLy8gc2VlIGdoLTc0NlxuICAgICAgICAgIHJhd0FycmF5W2ldID0gc3ViZG9jO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBzdWJkb2MgPSBuZXcgQ29uc3RydWN0b3IocmF3QXJyYXlbaV0sIHZhbHVlLCB1bmRlZmluZWQsXG4gICAgICAgICAgICAgIHVuZGVmaW5lZCwgaSk7XG4gICAgICAgICAgICAvLyBpZiBzZXQoKSBpcyBob29rZWQgaXQgd2lsbCBoYXZlIG5vIHJldHVybiB2YWx1ZVxuICAgICAgICAgICAgLy8gc2VlIGdoLTc0NlxuICAgICAgICAgICAgcmF3QXJyYXlbaV0gPSBzdWJkb2M7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBDYXN0RXJyb3IoJ2VtYmVkZGVkJywgcmF3QXJyYXlbaV0sXG4gICAgICAgICAgICAgIHZhbHVlW2FycmF5UGF0aFN5bWJvbF0sIGVycm9yLCB0aGlzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdmFsdWU7XG59O1xuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cblNjaGVtYURvY3VtZW50QXJyYXkucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24oKSB7XG4gIGNvbnN0IG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLm9wdGlvbnMpO1xuICBjb25zdCBzY2hlbWF0eXBlID0gbmV3IHRoaXMuY29uc3RydWN0b3IodGhpcy5wYXRoLCB0aGlzLnNjaGVtYSwgb3B0aW9ucywgdGhpcy5zY2hlbWFPcHRpb25zKTtcbiAgc2NoZW1hdHlwZS52YWxpZGF0b3JzID0gdGhpcy52YWxpZGF0b3JzLnNsaWNlKCk7XG4gIGlmICh0aGlzLnJlcXVpcmVkVmFsaWRhdG9yICE9PSB1bmRlZmluZWQpIHtcbiAgICBzY2hlbWF0eXBlLnJlcXVpcmVkVmFsaWRhdG9yID0gdGhpcy5yZXF1aXJlZFZhbGlkYXRvcjtcbiAgfVxuICBzY2hlbWF0eXBlLkNvbnN0cnVjdG9yLmRpc2NyaW1pbmF0b3JzID0gT2JqZWN0LmFzc2lnbih7fSxcbiAgICB0aGlzLkNvbnN0cnVjdG9yLmRpc2NyaW1pbmF0b3JzKTtcbiAgcmV0dXJuIHNjaGVtYXR5cGU7XG59O1xuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cblNjaGVtYURvY3VtZW50QXJyYXkucHJvdG90eXBlLmFwcGx5R2V0dGVycyA9IGZ1bmN0aW9uKHZhbHVlLCBzY29wZSkge1xuICByZXR1cm4gU2NoZW1hVHlwZS5wcm90b3R5cGUuYXBwbHlHZXR0ZXJzLmNhbGwodGhpcywgdmFsdWUsIHNjb3BlKTtcbn07XG5cbi8qKlxuICogU2NvcGVzIHBhdGhzIHNlbGVjdGVkIGluIGEgcXVlcnkgdG8gdGhpcyBhcnJheS5cbiAqIE5lY2Vzc2FyeSBmb3IgcHJvcGVyIGRlZmF1bHQgYXBwbGljYXRpb24gb2Ygc3ViZG9jdW1lbnQgdmFsdWVzLlxuICpcbiAqIEBwYXJhbSB7RG9jdW1lbnRBcnJheVBhdGh9IGFycmF5IHRoZSBhcnJheSB0byBzY29wZSBgZmllbGRzYCBwYXRoc1xuICogQHBhcmFtIHtPYmplY3R8dW5kZWZpbmVkfSBmaWVsZHMgdGhlIHJvb3QgZmllbGRzIHNlbGVjdGVkIGluIHRoZSBxdWVyeVxuICogQHBhcmFtIHtCb29sZWFufHVuZGVmaW5lZH0gaW5pdCBpZiB3ZSBhcmUgYmVpbmcgY3JlYXRlZCBwYXJ0IG9mIGEgcXVlcnkgcmVzdWx0XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBzY29wZVBhdGhzKGFycmF5LCBmaWVsZHMsIGluaXQpIHtcbiAgaWYgKCEoaW5pdCAmJiBmaWVsZHMpKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuXG4gIGNvbnN0IHBhdGggPSBhcnJheS5wYXRoICsgJy4nO1xuICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoZmllbGRzKTtcbiAgbGV0IGkgPSBrZXlzLmxlbmd0aDtcbiAgY29uc3Qgc2VsZWN0ZWQgPSB7fTtcbiAgbGV0IGhhc0tleXM7XG4gIGxldCBrZXk7XG4gIGxldCBzdWI7XG5cbiAgd2hpbGUgKGktLSkge1xuICAgIGtleSA9IGtleXNbaV07XG4gICAgaWYgKGtleS5zdGFydHNXaXRoKHBhdGgpKSB7XG4gICAgICBzdWIgPSBrZXkuc3Vic3RyaW5nKHBhdGgubGVuZ3RoKTtcbiAgICAgIGlmIChzdWIgPT09ICckJykge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmIChzdWIuc3RhcnRzV2l0aCgnJC4nKSkge1xuICAgICAgICBzdWIgPSBzdWIuc3Vic3RyaW5nKDIpO1xuICAgICAgfVxuICAgICAgaGFzS2V5cyB8fCAoaGFzS2V5cyA9IHRydWUpO1xuICAgICAgc2VsZWN0ZWRbc3ViXSA9IGZpZWxkc1trZXldO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBoYXNLZXlzICYmIHNlbGVjdGVkIHx8IHVuZGVmaW5lZDtcbn1cblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5TY2hlbWFEb2N1bWVudEFycmF5LmRlZmF1bHRPcHRpb25zID0ge307XG5cbi8qKlxuICogU2V0cyBhIGRlZmF1bHQgb3B0aW9uIGZvciBhbGwgRG9jdW1lbnRBcnJheSBpbnN0YW5jZXMuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICAvLyBNYWtlIGFsbCBudW1iZXJzIGhhdmUgb3B0aW9uIGBtaW5gIGVxdWFsIHRvIDAuXG4gKiAgICAgbW9uZ29vc2UuU2NoZW1hLkRvY3VtZW50QXJyYXkuc2V0KCdfaWQnLCBmYWxzZSk7XG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG9wdGlvbiBUaGUgbmFtZSBvZiB0aGUgb3B0aW9uIHlvdSdkIGxpa2UgdG8gc2V0IChlLmcuIHRyaW0sIGxvd2VyY2FzZSwgZXRjLi4uKVxuICogQHBhcmFtIHtBbnl9IHZhbHVlIFRoZSB2YWx1ZSBvZiB0aGUgb3B0aW9uIHlvdSdkIGxpa2UgdG8gc2V0LlxuICogQHJldHVybiB7dm9pZH1cbiAqIEBmdW5jdGlvbiBzZXRcbiAqIEBzdGF0aWNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuU2NoZW1hRG9jdW1lbnRBcnJheS5zZXQgPSBTY2hlbWFUeXBlLnNldDtcblxuU2NoZW1hRG9jdW1lbnRBcnJheS5zZXR0ZXJzID0gW107XG5cbi8qKlxuICogQXR0YWNoZXMgYSBnZXR0ZXIgZm9yIGFsbCBEb2N1bWVudEFycmF5UGF0aCBpbnN0YW5jZXNcbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBnZXR0ZXJcbiAqIEByZXR1cm4ge3RoaXN9XG4gKiBAZnVuY3Rpb24gZ2V0XG4gKiBAc3RhdGljXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblNjaGVtYURvY3VtZW50QXJyYXkuZ2V0ID0gU2NoZW1hVHlwZS5nZXQ7XG5cbi8qIVxuICogTW9kdWxlIGV4cG9ydHMuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBTY2hlbWFEb2N1bWVudEFycmF5O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../server/node_modules/mongoose/lib/schema/documentArray.js\n");

/***/ }),

/***/ "../server/node_modules/mongoose/lib/schema/documentArrayElement.js":
/*!**************************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/schema/documentArrayElement.js ***!
  \**************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*!\n * Module dependencies.\n */\n\n\n\nconst MongooseError = __webpack_require__(/*! ../error/mongooseError */ \"../server/node_modules/mongoose/lib/error/mongooseError.js\");\nconst SchemaType = __webpack_require__(/*! ../schemaType */ \"../server/node_modules/mongoose/lib/schemaType.js\");\nconst SchemaSubdocument = __webpack_require__(/*! ./subdocument */ \"../server/node_modules/mongoose/lib/schema/subdocument.js\");\nconst getConstructor = __webpack_require__(/*! ../helpers/discriminator/getConstructor */ \"../server/node_modules/mongoose/lib/helpers/discriminator/getConstructor.js\");\n\n/**\n * DocumentArrayElement SchemaType constructor.\n *\n * @param {String} path\n * @param {Object} options\n * @inherits SchemaType\n * @api public\n */\n\nfunction SchemaDocumentArrayElement(path, options) {\n  this.$parentSchemaType = options && options.$parentSchemaType;\n  if (!this.$parentSchemaType) {\n    throw new MongooseError('Cannot create DocumentArrayElement schematype without a parent');\n  }\n  delete options.$parentSchemaType;\n\n  SchemaType.call(this, path, options, 'DocumentArrayElement');\n\n  this.$isMongooseDocumentArrayElement = true;\n}\n\n/**\n * This schema type's name, to defend against minifiers that mangle\n * function names.\n *\n * @api public\n */\nSchemaDocumentArrayElement.schemaName = 'DocumentArrayElement';\n\nSchemaDocumentArrayElement.defaultOptions = {};\n\n/*!\n * Inherits from SchemaType.\n */\nSchemaDocumentArrayElement.prototype = Object.create(SchemaType.prototype);\nSchemaDocumentArrayElement.prototype.constructor = SchemaDocumentArrayElement;\n\n/**\n * Casts `val` for DocumentArrayElement.\n *\n * @param {Object} value to cast\n * @api private\n */\n\nSchemaDocumentArrayElement.prototype.cast = function(...args) {\n  return this.$parentSchemaType.cast(...args)[0];\n};\n\n/**\n * Casts contents for queries.\n *\n * @param {String} $cond\n * @param {any} [val]\n * @api private\n */\n\nSchemaDocumentArrayElement.prototype.doValidate = function(value, fn, scope, options) {\n  const Constructor = getConstructor(this.caster, value);\n\n  if (value && !(value instanceof Constructor)) {\n    value = new Constructor(value, scope, null, null, options && options.index != null ? options.index : null);\n  }\n\n  return SchemaSubdocument.prototype.doValidate.call(this, value, fn, scope, options);\n};\n\n/**\n * Clone the current SchemaType\n *\n * @return {DocumentArrayElement} The cloned instance\n * @api private\n */\n\nSchemaDocumentArrayElement.prototype.clone = function() {\n  this.options.$parentSchemaType = this.$parentSchemaType;\n  const ret = SchemaType.prototype.clone.apply(this, arguments);\n  delete this.options.$parentSchemaType;\n\n  ret.caster = this.caster;\n  ret.schema = this.schema;\n\n  return ret;\n};\n\n/*!\n * Module exports.\n */\n\nmodule.exports = SchemaDocumentArrayElement;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvc2NoZW1hL2RvY3VtZW50QXJyYXlFbGVtZW50LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTs7QUFFYTs7QUFFYixzQkFBc0IsbUJBQU8sQ0FBQywwRkFBd0I7QUFDdEQsbUJBQW1CLG1CQUFPLENBQUMsd0VBQWU7QUFDMUMsMEJBQTBCLG1CQUFPLENBQUMsZ0ZBQWU7QUFDakQsdUJBQXVCLG1CQUFPLENBQUMsNEhBQXlDOztBQUV4RTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxLQUFLO0FBQ2hCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHNCQUFzQjtBQUNsQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbGllbnQvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvc2NoZW1hL2RvY3VtZW50QXJyYXlFbGVtZW50LmpzPzU3Y2QiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuY29uc3QgTW9uZ29vc2VFcnJvciA9IHJlcXVpcmUoJy4uL2Vycm9yL21vbmdvb3NlRXJyb3InKTtcbmNvbnN0IFNjaGVtYVR5cGUgPSByZXF1aXJlKCcuLi9zY2hlbWFUeXBlJyk7XG5jb25zdCBTY2hlbWFTdWJkb2N1bWVudCA9IHJlcXVpcmUoJy4vc3ViZG9jdW1lbnQnKTtcbmNvbnN0IGdldENvbnN0cnVjdG9yID0gcmVxdWlyZSgnLi4vaGVscGVycy9kaXNjcmltaW5hdG9yL2dldENvbnN0cnVjdG9yJyk7XG5cbi8qKlxuICogRG9jdW1lbnRBcnJheUVsZW1lbnQgU2NoZW1hVHlwZSBjb25zdHJ1Y3Rvci5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcGF0aFxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEBpbmhlcml0cyBTY2hlbWFUeXBlXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIFNjaGVtYURvY3VtZW50QXJyYXlFbGVtZW50KHBhdGgsIG9wdGlvbnMpIHtcbiAgdGhpcy4kcGFyZW50U2NoZW1hVHlwZSA9IG9wdGlvbnMgJiYgb3B0aW9ucy4kcGFyZW50U2NoZW1hVHlwZTtcbiAgaWYgKCF0aGlzLiRwYXJlbnRTY2hlbWFUeXBlKSB7XG4gICAgdGhyb3cgbmV3IE1vbmdvb3NlRXJyb3IoJ0Nhbm5vdCBjcmVhdGUgRG9jdW1lbnRBcnJheUVsZW1lbnQgc2NoZW1hdHlwZSB3aXRob3V0IGEgcGFyZW50Jyk7XG4gIH1cbiAgZGVsZXRlIG9wdGlvbnMuJHBhcmVudFNjaGVtYVR5cGU7XG5cbiAgU2NoZW1hVHlwZS5jYWxsKHRoaXMsIHBhdGgsIG9wdGlvbnMsICdEb2N1bWVudEFycmF5RWxlbWVudCcpO1xuXG4gIHRoaXMuJGlzTW9uZ29vc2VEb2N1bWVudEFycmF5RWxlbWVudCA9IHRydWU7XG59XG5cbi8qKlxuICogVGhpcyBzY2hlbWEgdHlwZSdzIG5hbWUsIHRvIGRlZmVuZCBhZ2FpbnN0IG1pbmlmaWVycyB0aGF0IG1hbmdsZVxuICogZnVuY3Rpb24gbmFtZXMuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuU2NoZW1hRG9jdW1lbnRBcnJheUVsZW1lbnQuc2NoZW1hTmFtZSA9ICdEb2N1bWVudEFycmF5RWxlbWVudCc7XG5cblNjaGVtYURvY3VtZW50QXJyYXlFbGVtZW50LmRlZmF1bHRPcHRpb25zID0ge307XG5cbi8qIVxuICogSW5oZXJpdHMgZnJvbSBTY2hlbWFUeXBlLlxuICovXG5TY2hlbWFEb2N1bWVudEFycmF5RWxlbWVudC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFNjaGVtYVR5cGUucHJvdG90eXBlKTtcblNjaGVtYURvY3VtZW50QXJyYXlFbGVtZW50LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFNjaGVtYURvY3VtZW50QXJyYXlFbGVtZW50O1xuXG4vKipcbiAqIENhc3RzIGB2YWxgIGZvciBEb2N1bWVudEFycmF5RWxlbWVudC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsdWUgdG8gY2FzdFxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU2NoZW1hRG9jdW1lbnRBcnJheUVsZW1lbnQucHJvdG90eXBlLmNhc3QgPSBmdW5jdGlvbiguLi5hcmdzKSB7XG4gIHJldHVybiB0aGlzLiRwYXJlbnRTY2hlbWFUeXBlLmNhc3QoLi4uYXJncylbMF07XG59O1xuXG4vKipcbiAqIENhc3RzIGNvbnRlbnRzIGZvciBxdWVyaWVzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSAkY29uZFxuICogQHBhcmFtIHthbnl9IFt2YWxdXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5TY2hlbWFEb2N1bWVudEFycmF5RWxlbWVudC5wcm90b3R5cGUuZG9WYWxpZGF0ZSA9IGZ1bmN0aW9uKHZhbHVlLCBmbiwgc2NvcGUsIG9wdGlvbnMpIHtcbiAgY29uc3QgQ29uc3RydWN0b3IgPSBnZXRDb25zdHJ1Y3Rvcih0aGlzLmNhc3RlciwgdmFsdWUpO1xuXG4gIGlmICh2YWx1ZSAmJiAhKHZhbHVlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7XG4gICAgdmFsdWUgPSBuZXcgQ29uc3RydWN0b3IodmFsdWUsIHNjb3BlLCBudWxsLCBudWxsLCBvcHRpb25zICYmIG9wdGlvbnMuaW5kZXggIT0gbnVsbCA/IG9wdGlvbnMuaW5kZXggOiBudWxsKTtcbiAgfVxuXG4gIHJldHVybiBTY2hlbWFTdWJkb2N1bWVudC5wcm90b3R5cGUuZG9WYWxpZGF0ZS5jYWxsKHRoaXMsIHZhbHVlLCBmbiwgc2NvcGUsIG9wdGlvbnMpO1xufTtcblxuLyoqXG4gKiBDbG9uZSB0aGUgY3VycmVudCBTY2hlbWFUeXBlXG4gKlxuICogQHJldHVybiB7RG9jdW1lbnRBcnJheUVsZW1lbnR9IFRoZSBjbG9uZWQgaW5zdGFuY2VcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNjaGVtYURvY3VtZW50QXJyYXlFbGVtZW50LnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLm9wdGlvbnMuJHBhcmVudFNjaGVtYVR5cGUgPSB0aGlzLiRwYXJlbnRTY2hlbWFUeXBlO1xuICBjb25zdCByZXQgPSBTY2hlbWFUeXBlLnByb3RvdHlwZS5jbG9uZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICBkZWxldGUgdGhpcy5vcHRpb25zLiRwYXJlbnRTY2hlbWFUeXBlO1xuXG4gIHJldC5jYXN0ZXIgPSB0aGlzLmNhc3RlcjtcbiAgcmV0LnNjaGVtYSA9IHRoaXMuc2NoZW1hO1xuXG4gIHJldHVybiByZXQ7XG59O1xuXG4vKiFcbiAqIE1vZHVsZSBleHBvcnRzLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gU2NoZW1hRG9jdW1lbnRBcnJheUVsZW1lbnQ7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../server/node_modules/mongoose/lib/schema/documentArrayElement.js\n");

/***/ }),

/***/ "../server/node_modules/mongoose/lib/schema/index.js":
/*!***********************************************************!*\
  !*** ../server/node_modules/mongoose/lib/schema/index.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n/*!\n * Module exports.\n */\n\n\n\nexports.Array = __webpack_require__(/*! ./array */ \"../server/node_modules/mongoose/lib/schema/array.js\");\nexports.BigInt = __webpack_require__(/*! ./bigint */ \"../server/node_modules/mongoose/lib/schema/bigint.js\");\nexports.Boolean = __webpack_require__(/*! ./boolean */ \"../server/node_modules/mongoose/lib/schema/boolean.js\");\nexports.Buffer = __webpack_require__(/*! ./buffer */ \"../server/node_modules/mongoose/lib/schema/buffer.js\");\nexports.Date = __webpack_require__(/*! ./date */ \"../server/node_modules/mongoose/lib/schema/date.js\");\nexports.Decimal128 = exports.Decimal = __webpack_require__(/*! ./decimal128 */ \"../server/node_modules/mongoose/lib/schema/decimal128.js\");\nexports.DocumentArray = __webpack_require__(/*! ./documentArray */ \"../server/node_modules/mongoose/lib/schema/documentArray.js\");\nexports.Map = __webpack_require__(/*! ./map */ \"../server/node_modules/mongoose/lib/schema/map.js\");\nexports.Mixed = __webpack_require__(/*! ./mixed */ \"../server/node_modules/mongoose/lib/schema/mixed.js\");\nexports.Number = __webpack_require__(/*! ./number */ \"../server/node_modules/mongoose/lib/schema/number.js\");\nexports.ObjectId = __webpack_require__(/*! ./objectId */ \"../server/node_modules/mongoose/lib/schema/objectId.js\");\nexports.String = __webpack_require__(/*! ./string */ \"../server/node_modules/mongoose/lib/schema/string.js\");\nexports.Subdocument = __webpack_require__(/*! ./subdocument */ \"../server/node_modules/mongoose/lib/schema/subdocument.js\");\nexports.UUID = __webpack_require__(/*! ./uuid */ \"../server/node_modules/mongoose/lib/schema/uuid.js\");\n\n// alias\n\nexports.Oid = exports.ObjectId;\nexports.Object = exports.Mixed;\nexports.Bool = exports.Boolean;\nexports.ObjectID = exports.ObjectId;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvc2NoZW1hL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7O0FBRWIseUdBQWtDO0FBQ2xDLDRHQUFvQztBQUNwQywrR0FBc0M7QUFDdEMsNEdBQW9DO0FBQ3BDLHNHQUFnQztBQUNoQyxrQkFBa0IsR0FBRyxxSEFBeUM7QUFDOUQsaUlBQWtEO0FBQ2xELG1HQUE4QjtBQUM5Qix5R0FBa0M7QUFDbEMsNEdBQW9DO0FBQ3BDLGtIQUF3QztBQUN4Qyw0R0FBb0M7QUFDcEMsMkhBQThDO0FBQzlDLHNHQUFnQzs7QUFFaEM7O0FBRUEsV0FBVztBQUNYLGNBQWM7QUFDZCxZQUFZO0FBQ1osZ0JBQWdCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2xpZW50Ly4uL3NlcnZlci9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL3NjaGVtYS9pbmRleC5qcz9jMDliIl0sInNvdXJjZXNDb250ZW50IjpbIlxuLyohXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuQXJyYXkgPSByZXF1aXJlKCcuL2FycmF5Jyk7XG5leHBvcnRzLkJpZ0ludCA9IHJlcXVpcmUoJy4vYmlnaW50Jyk7XG5leHBvcnRzLkJvb2xlYW4gPSByZXF1aXJlKCcuL2Jvb2xlYW4nKTtcbmV4cG9ydHMuQnVmZmVyID0gcmVxdWlyZSgnLi9idWZmZXInKTtcbmV4cG9ydHMuRGF0ZSA9IHJlcXVpcmUoJy4vZGF0ZScpO1xuZXhwb3J0cy5EZWNpbWFsMTI4ID0gZXhwb3J0cy5EZWNpbWFsID0gcmVxdWlyZSgnLi9kZWNpbWFsMTI4Jyk7XG5leHBvcnRzLkRvY3VtZW50QXJyYXkgPSByZXF1aXJlKCcuL2RvY3VtZW50QXJyYXknKTtcbmV4cG9ydHMuTWFwID0gcmVxdWlyZSgnLi9tYXAnKTtcbmV4cG9ydHMuTWl4ZWQgPSByZXF1aXJlKCcuL21peGVkJyk7XG5leHBvcnRzLk51bWJlciA9IHJlcXVpcmUoJy4vbnVtYmVyJyk7XG5leHBvcnRzLk9iamVjdElkID0gcmVxdWlyZSgnLi9vYmplY3RJZCcpO1xuZXhwb3J0cy5TdHJpbmcgPSByZXF1aXJlKCcuL3N0cmluZycpO1xuZXhwb3J0cy5TdWJkb2N1bWVudCA9IHJlcXVpcmUoJy4vc3ViZG9jdW1lbnQnKTtcbmV4cG9ydHMuVVVJRCA9IHJlcXVpcmUoJy4vdXVpZCcpO1xuXG4vLyBhbGlhc1xuXG5leHBvcnRzLk9pZCA9IGV4cG9ydHMuT2JqZWN0SWQ7XG5leHBvcnRzLk9iamVjdCA9IGV4cG9ydHMuTWl4ZWQ7XG5leHBvcnRzLkJvb2wgPSBleHBvcnRzLkJvb2xlYW47XG5leHBvcnRzLk9iamVjdElEID0gZXhwb3J0cy5PYmplY3RJZDtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../server/node_modules/mongoose/lib/schema/index.js\n");

/***/ }),

/***/ "../server/node_modules/mongoose/lib/schema/map.js":
/*!*********************************************************!*\
  !*** ../server/node_modules/mongoose/lib/schema/map.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\n/*!\n * ignore\n */\n\nconst MongooseMap = __webpack_require__(/*! ../types/map */ \"../server/node_modules/mongoose/lib/types/map.js\");\nconst SchemaMapOptions = __webpack_require__(/*! ../options/schemaMapOptions */ \"../server/node_modules/mongoose/lib/options/schemaMapOptions.js\");\nconst SchemaType = __webpack_require__(/*! ../schemaType */ \"../server/node_modules/mongoose/lib/schemaType.js\");\n/*!\n * ignore\n */\n\nclass SchemaMap extends SchemaType {\n  constructor(key, options) {\n    super(key, options, 'Map');\n    this.$isSchemaMap = true;\n  }\n\n  set(option, value) {\n    return SchemaType.set(option, value);\n  }\n\n  cast(val, doc, init) {\n    if (val instanceof MongooseMap) {\n      return val;\n    }\n\n    const path = this.path;\n\n    if (init) {\n      const map = new MongooseMap({}, path, doc, this.$__schemaType);\n\n      if (val instanceof global.Map) {\n        for (const key of val.keys()) {\n          let _val = val.get(key);\n          if (_val == null) {\n            _val = map.$__schemaType._castNullish(_val);\n          } else {\n            _val = map.$__schemaType.cast(_val, doc, true, null, { path: path + '.' + key });\n          }\n          map.$init(key, _val);\n        }\n      } else {\n        for (const key of Object.keys(val)) {\n          let _val = val[key];\n          if (_val == null) {\n            _val = map.$__schemaType._castNullish(_val);\n          } else {\n            _val = map.$__schemaType.cast(_val, doc, true, null, { path: path + '.' + key });\n          }\n          map.$init(key, _val);\n        }\n      }\n\n      return map;\n    }\n\n    return new MongooseMap(val, path, doc, this.$__schemaType);\n  }\n\n  clone() {\n    const schematype = super.clone();\n\n    if (this.$__schemaType != null) {\n      schematype.$__schemaType = this.$__schemaType.clone();\n    }\n    return schematype;\n  }\n}\n\n/**\n * This schema type's name, to defend against minifiers that mangle\n * function names.\n *\n * @api public\n */\nSchemaMap.schemaName = 'Map';\n\nSchemaMap.prototype.OptionsConstructor = SchemaMapOptions;\n\nSchemaMap.defaultOptions = {};\n\nmodule.exports = SchemaMap;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvc2NoZW1hL21hcC5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CLG1CQUFPLENBQUMsc0VBQWM7QUFDMUMseUJBQXlCLG1CQUFPLENBQUMsb0dBQTZCO0FBQzlELG1CQUFtQixtQkFBTyxDQUFDLHdFQUFlO0FBQzFDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLG9DQUFvQzs7QUFFcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWixtRUFBbUUsd0JBQXdCO0FBQzNGO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWixtRUFBbUUsd0JBQXdCO0FBQzNGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL2NsaWVudC8uLi9zZXJ2ZXIvbm9kZV9tb2R1bGVzL21vbmdvb3NlL2xpYi9zY2hlbWEvbWFwLmpzP2EyMzMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cbmNvbnN0IE1vbmdvb3NlTWFwID0gcmVxdWlyZSgnLi4vdHlwZXMvbWFwJyk7XG5jb25zdCBTY2hlbWFNYXBPcHRpb25zID0gcmVxdWlyZSgnLi4vb3B0aW9ucy9zY2hlbWFNYXBPcHRpb25zJyk7XG5jb25zdCBTY2hlbWFUeXBlID0gcmVxdWlyZSgnLi4vc2NoZW1hVHlwZScpO1xuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5jbGFzcyBTY2hlbWFNYXAgZXh0ZW5kcyBTY2hlbWFUeXBlIHtcbiAgY29uc3RydWN0b3Ioa2V5LCBvcHRpb25zKSB7XG4gICAgc3VwZXIoa2V5LCBvcHRpb25zLCAnTWFwJyk7XG4gICAgdGhpcy4kaXNTY2hlbWFNYXAgPSB0cnVlO1xuICB9XG5cbiAgc2V0KG9wdGlvbiwgdmFsdWUpIHtcbiAgICByZXR1cm4gU2NoZW1hVHlwZS5zZXQob3B0aW9uLCB2YWx1ZSk7XG4gIH1cblxuICBjYXN0KHZhbCwgZG9jLCBpbml0KSB7XG4gICAgaWYgKHZhbCBpbnN0YW5jZW9mIE1vbmdvb3NlTWFwKSB7XG4gICAgICByZXR1cm4gdmFsO1xuICAgIH1cblxuICAgIGNvbnN0IHBhdGggPSB0aGlzLnBhdGg7XG5cbiAgICBpZiAoaW5pdCkge1xuICAgICAgY29uc3QgbWFwID0gbmV3IE1vbmdvb3NlTWFwKHt9LCBwYXRoLCBkb2MsIHRoaXMuJF9fc2NoZW1hVHlwZSk7XG5cbiAgICAgIGlmICh2YWwgaW5zdGFuY2VvZiBnbG9iYWwuTWFwKSB7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IG9mIHZhbC5rZXlzKCkpIHtcbiAgICAgICAgICBsZXQgX3ZhbCA9IHZhbC5nZXQoa2V5KTtcbiAgICAgICAgICBpZiAoX3ZhbCA9PSBudWxsKSB7XG4gICAgICAgICAgICBfdmFsID0gbWFwLiRfX3NjaGVtYVR5cGUuX2Nhc3ROdWxsaXNoKF92YWwpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBfdmFsID0gbWFwLiRfX3NjaGVtYVR5cGUuY2FzdChfdmFsLCBkb2MsIHRydWUsIG51bGwsIHsgcGF0aDogcGF0aCArICcuJyArIGtleSB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbWFwLiRpbml0KGtleSwgX3ZhbCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKHZhbCkpIHtcbiAgICAgICAgICBsZXQgX3ZhbCA9IHZhbFtrZXldO1xuICAgICAgICAgIGlmIChfdmFsID09IG51bGwpIHtcbiAgICAgICAgICAgIF92YWwgPSBtYXAuJF9fc2NoZW1hVHlwZS5fY2FzdE51bGxpc2goX3ZhbCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIF92YWwgPSBtYXAuJF9fc2NoZW1hVHlwZS5jYXN0KF92YWwsIGRvYywgdHJ1ZSwgbnVsbCwgeyBwYXRoOiBwYXRoICsgJy4nICsga2V5IH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBtYXAuJGluaXQoa2V5LCBfdmFsKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gbWFwO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgTW9uZ29vc2VNYXAodmFsLCBwYXRoLCBkb2MsIHRoaXMuJF9fc2NoZW1hVHlwZSk7XG4gIH1cblxuICBjbG9uZSgpIHtcbiAgICBjb25zdCBzY2hlbWF0eXBlID0gc3VwZXIuY2xvbmUoKTtcblxuICAgIGlmICh0aGlzLiRfX3NjaGVtYVR5cGUgIT0gbnVsbCkge1xuICAgICAgc2NoZW1hdHlwZS4kX19zY2hlbWFUeXBlID0gdGhpcy4kX19zY2hlbWFUeXBlLmNsb25lKCk7XG4gICAgfVxuICAgIHJldHVybiBzY2hlbWF0eXBlO1xuICB9XG59XG5cbi8qKlxuICogVGhpcyBzY2hlbWEgdHlwZSdzIG5hbWUsIHRvIGRlZmVuZCBhZ2FpbnN0IG1pbmlmaWVycyB0aGF0IG1hbmdsZVxuICogZnVuY3Rpb24gbmFtZXMuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuU2NoZW1hTWFwLnNjaGVtYU5hbWUgPSAnTWFwJztcblxuU2NoZW1hTWFwLnByb3RvdHlwZS5PcHRpb25zQ29uc3RydWN0b3IgPSBTY2hlbWFNYXBPcHRpb25zO1xuXG5TY2hlbWFNYXAuZGVmYXVsdE9wdGlvbnMgPSB7fTtcblxubW9kdWxlLmV4cG9ydHMgPSBTY2hlbWFNYXA7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../server/node_modules/mongoose/lib/schema/map.js\n");

/***/ }),

/***/ "../server/node_modules/mongoose/lib/schema/mixed.js":
/*!***********************************************************!*\
  !*** ../server/node_modules/mongoose/lib/schema/mixed.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*!\n * Module dependencies.\n */\n\n\n\nconst SchemaType = __webpack_require__(/*! ../schemaType */ \"../server/node_modules/mongoose/lib/schemaType.js\");\nconst symbols = __webpack_require__(/*! ./symbols */ \"../server/node_modules/mongoose/lib/schema/symbols.js\");\nconst isObject = __webpack_require__(/*! ../helpers/isObject */ \"../server/node_modules/mongoose/lib/helpers/isObject.js\");\nconst utils = __webpack_require__(/*! ../utils */ \"../server/node_modules/mongoose/lib/utils.js\");\n\n/**\n * Mixed SchemaType constructor.\n *\n * @param {String} path\n * @param {Object} options\n * @inherits SchemaType\n * @api public\n */\n\nfunction SchemaMixed(path, options) {\n  if (options && options.default) {\n    const def = options.default;\n    if (Array.isArray(def) && def.length === 0) {\n      // make sure empty array defaults are handled\n      options.default = Array;\n    } else if (!options.shared && isObject(def) && Object.keys(def).length === 0) {\n      // prevent odd \"shared\" objects between documents\n      options.default = function() {\n        return {};\n      };\n    }\n  }\n\n  SchemaType.call(this, path, options, 'Mixed');\n\n  this[symbols.schemaMixedSymbol] = true;\n}\n\n/**\n * This schema type's name, to defend against minifiers that mangle\n * function names.\n *\n * @api public\n */\nSchemaMixed.schemaName = 'Mixed';\n\nSchemaMixed.defaultOptions = {};\n\n/*!\n * Inherits from SchemaType.\n */\nSchemaMixed.prototype = Object.create(SchemaType.prototype);\nSchemaMixed.prototype.constructor = SchemaMixed;\n\n/**\n * Attaches a getter for all Mixed paths.\n *\n * #### Example:\n *\n *     // Hide the 'hidden' path\n *     mongoose.Schema.Mixed.get(v => Object.assign({}, v, { hidden: null }));\n *\n *     const Model = mongoose.model('Test', new Schema({ test: {} }));\n *     new Model({ test: { hidden: 'Secret!' } }).test.hidden; // null\n *\n * @param {Function} getter\n * @return {this}\n * @function get\n * @static\n * @api public\n */\n\nSchemaMixed.get = SchemaType.get;\n\n/**\n * Sets a default option for all Mixed instances.\n *\n * #### Example:\n *\n *     // Make all mixed instances have `required` of true by default.\n *     mongoose.Schema.Mixed.set('required', true);\n *\n *     const User = mongoose.model('User', new Schema({ test: mongoose.Mixed }));\n *     new User({ }).validateSync().errors.test.message; // Path `test` is required.\n *\n * @param {String} option The option you'd like to set the value for\n * @param {Any} value value for option\n * @return {undefined}\n * @function set\n * @static\n * @api public\n */\n\nSchemaMixed.set = SchemaType.set;\n\nSchemaMixed.setters = [];\n\n/**\n * Casts `val` for Mixed.\n *\n * _this is a no-op_\n *\n * @param {Object} value to cast\n * @api private\n */\n\nSchemaMixed.prototype.cast = function(val) {\n  if (val instanceof Error) {\n    return utils.errorToPOJO(val);\n  }\n  return val;\n};\n\n/**\n * Casts contents for queries.\n *\n * @param {String} $cond\n * @param {any} [val]\n * @api private\n */\n\nSchemaMixed.prototype.castForQuery = function($cond, val) {\n  return val;\n};\n\n/*!\n * Module exports.\n */\n\nmodule.exports = SchemaMixed;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvc2NoZW1hL21peGVkLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTs7QUFFYTs7QUFFYixtQkFBbUIsbUJBQU8sQ0FBQyx3RUFBZTtBQUMxQyxnQkFBZ0IsbUJBQU8sQ0FBQyx3RUFBVztBQUNuQyxpQkFBaUIsbUJBQU8sQ0FBQyxvRkFBcUI7QUFDOUMsY0FBYyxtQkFBTyxDQUFDLDhEQUFVOztBQUVoQztBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QsT0FBTyxjQUFjO0FBQzNFO0FBQ0EseURBQXlELFVBQVU7QUFDbkUsbUJBQW1CLFFBQVEscUJBQXFCLGVBQWU7QUFDL0Q7QUFDQSxXQUFXLFVBQVU7QUFDckIsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0Qsc0JBQXNCO0FBQzlFLG1CQUFtQixzQ0FBc0M7QUFDekQ7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxLQUFLO0FBQ2hCLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLEtBQUs7QUFDaEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2xpZW50Ly4uL3NlcnZlci9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL3NjaGVtYS9taXhlZC5qcz84YjVhIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbmNvbnN0IFNjaGVtYVR5cGUgPSByZXF1aXJlKCcuLi9zY2hlbWFUeXBlJyk7XG5jb25zdCBzeW1ib2xzID0gcmVxdWlyZSgnLi9zeW1ib2xzJyk7XG5jb25zdCBpc09iamVjdCA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvaXNPYmplY3QnKTtcbmNvbnN0IHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMnKTtcblxuLyoqXG4gKiBNaXhlZCBTY2hlbWFUeXBlIGNvbnN0cnVjdG9yLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQGluaGVyaXRzIFNjaGVtYVR5cGVcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gU2NoZW1hTWl4ZWQocGF0aCwgb3B0aW9ucykge1xuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmRlZmF1bHQpIHtcbiAgICBjb25zdCBkZWYgPSBvcHRpb25zLmRlZmF1bHQ7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZGVmKSAmJiBkZWYubGVuZ3RoID09PSAwKSB7XG4gICAgICAvLyBtYWtlIHN1cmUgZW1wdHkgYXJyYXkgZGVmYXVsdHMgYXJlIGhhbmRsZWRcbiAgICAgIG9wdGlvbnMuZGVmYXVsdCA9IEFycmF5O1xuICAgIH0gZWxzZSBpZiAoIW9wdGlvbnMuc2hhcmVkICYmIGlzT2JqZWN0KGRlZikgJiYgT2JqZWN0LmtleXMoZGVmKS5sZW5ndGggPT09IDApIHtcbiAgICAgIC8vIHByZXZlbnQgb2RkIFwic2hhcmVkXCIgb2JqZWN0cyBiZXR3ZWVuIGRvY3VtZW50c1xuICAgICAgb3B0aW9ucy5kZWZhdWx0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB7fTtcbiAgICAgIH07XG4gICAgfVxuICB9XG5cbiAgU2NoZW1hVHlwZS5jYWxsKHRoaXMsIHBhdGgsIG9wdGlvbnMsICdNaXhlZCcpO1xuXG4gIHRoaXNbc3ltYm9scy5zY2hlbWFNaXhlZFN5bWJvbF0gPSB0cnVlO1xufVxuXG4vKipcbiAqIFRoaXMgc2NoZW1hIHR5cGUncyBuYW1lLCB0byBkZWZlbmQgYWdhaW5zdCBtaW5pZmllcnMgdGhhdCBtYW5nbGVcbiAqIGZ1bmN0aW9uIG5hbWVzLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblNjaGVtYU1peGVkLnNjaGVtYU5hbWUgPSAnTWl4ZWQnO1xuXG5TY2hlbWFNaXhlZC5kZWZhdWx0T3B0aW9ucyA9IHt9O1xuXG4vKiFcbiAqIEluaGVyaXRzIGZyb20gU2NoZW1hVHlwZS5cbiAqL1xuU2NoZW1hTWl4ZWQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShTY2hlbWFUeXBlLnByb3RvdHlwZSk7XG5TY2hlbWFNaXhlZC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBTY2hlbWFNaXhlZDtcblxuLyoqXG4gKiBBdHRhY2hlcyBhIGdldHRlciBmb3IgYWxsIE1peGVkIHBhdGhzLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgLy8gSGlkZSB0aGUgJ2hpZGRlbicgcGF0aFxuICogICAgIG1vbmdvb3NlLlNjaGVtYS5NaXhlZC5nZXQodiA9PiBPYmplY3QuYXNzaWduKHt9LCB2LCB7IGhpZGRlbjogbnVsbCB9KSk7XG4gKlxuICogICAgIGNvbnN0IE1vZGVsID0gbW9uZ29vc2UubW9kZWwoJ1Rlc3QnLCBuZXcgU2NoZW1hKHsgdGVzdDoge30gfSkpO1xuICogICAgIG5ldyBNb2RlbCh7IHRlc3Q6IHsgaGlkZGVuOiAnU2VjcmV0IScgfSB9KS50ZXN0LmhpZGRlbjsgLy8gbnVsbFxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGdldHRlclxuICogQHJldHVybiB7dGhpc31cbiAqIEBmdW5jdGlvbiBnZXRcbiAqIEBzdGF0aWNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuU2NoZW1hTWl4ZWQuZ2V0ID0gU2NoZW1hVHlwZS5nZXQ7XG5cbi8qKlxuICogU2V0cyBhIGRlZmF1bHQgb3B0aW9uIGZvciBhbGwgTWl4ZWQgaW5zdGFuY2VzLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgLy8gTWFrZSBhbGwgbWl4ZWQgaW5zdGFuY2VzIGhhdmUgYHJlcXVpcmVkYCBvZiB0cnVlIGJ5IGRlZmF1bHQuXG4gKiAgICAgbW9uZ29vc2UuU2NoZW1hLk1peGVkLnNldCgncmVxdWlyZWQnLCB0cnVlKTtcbiAqXG4gKiAgICAgY29uc3QgVXNlciA9IG1vbmdvb3NlLm1vZGVsKCdVc2VyJywgbmV3IFNjaGVtYSh7IHRlc3Q6IG1vbmdvb3NlLk1peGVkIH0pKTtcbiAqICAgICBuZXcgVXNlcih7IH0pLnZhbGlkYXRlU3luYygpLmVycm9ycy50ZXN0Lm1lc3NhZ2U7IC8vIFBhdGggYHRlc3RgIGlzIHJlcXVpcmVkLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBvcHRpb24gVGhlIG9wdGlvbiB5b3UnZCBsaWtlIHRvIHNldCB0aGUgdmFsdWUgZm9yXG4gKiBAcGFyYW0ge0FueX0gdmFsdWUgdmFsdWUgZm9yIG9wdGlvblxuICogQHJldHVybiB7dW5kZWZpbmVkfVxuICogQGZ1bmN0aW9uIHNldFxuICogQHN0YXRpY1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5TY2hlbWFNaXhlZC5zZXQgPSBTY2hlbWFUeXBlLnNldDtcblxuU2NoZW1hTWl4ZWQuc2V0dGVycyA9IFtdO1xuXG4vKipcbiAqIENhc3RzIGB2YWxgIGZvciBNaXhlZC5cbiAqXG4gKiBfdGhpcyBpcyBhIG5vLW9wX1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWx1ZSB0byBjYXN0XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5TY2hlbWFNaXhlZC5wcm90b3R5cGUuY2FzdCA9IGZ1bmN0aW9uKHZhbCkge1xuICBpZiAodmFsIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICByZXR1cm4gdXRpbHMuZXJyb3JUb1BPSk8odmFsKTtcbiAgfVxuICByZXR1cm4gdmFsO1xufTtcblxuLyoqXG4gKiBDYXN0cyBjb250ZW50cyBmb3IgcXVlcmllcy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gJGNvbmRcbiAqIEBwYXJhbSB7YW55fSBbdmFsXVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU2NoZW1hTWl4ZWQucHJvdG90eXBlLmNhc3RGb3JRdWVyeSA9IGZ1bmN0aW9uKCRjb25kLCB2YWwpIHtcbiAgcmV0dXJuIHZhbDtcbn07XG5cbi8qIVxuICogTW9kdWxlIGV4cG9ydHMuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBTY2hlbWFNaXhlZDtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../server/node_modules/mongoose/lib/schema/mixed.js\n");

/***/ }),

/***/ "../server/node_modules/mongoose/lib/schema/number.js":
/*!************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/schema/number.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\n/*!\n * Module requirements.\n */\n\nconst MongooseError = __webpack_require__(/*! ../error/index */ \"../server/node_modules/mongoose/lib/error/index.js\");\nconst SchemaNumberOptions = __webpack_require__(/*! ../options/schemaNumberOptions */ \"../server/node_modules/mongoose/lib/options/schemaNumberOptions.js\");\nconst SchemaType = __webpack_require__(/*! ../schemaType */ \"../server/node_modules/mongoose/lib/schemaType.js\");\nconst castNumber = __webpack_require__(/*! ../cast/number */ \"../server/node_modules/mongoose/lib/cast/number.js\");\nconst handleBitwiseOperator = __webpack_require__(/*! ./operators/bitwise */ \"../server/node_modules/mongoose/lib/schema/operators/bitwise.js\");\nconst utils = __webpack_require__(/*! ../utils */ \"../server/node_modules/mongoose/lib/utils.js\");\n\nconst CastError = SchemaType.CastError;\n\n/**\n * Number SchemaType constructor.\n *\n * @param {String} key\n * @param {Object} options\n * @inherits SchemaType\n * @api public\n */\n\nfunction SchemaNumber(key, options) {\n  SchemaType.call(this, key, options, 'Number');\n}\n\n/**\n * Attaches a getter for all Number instances.\n *\n * #### Example:\n *\n *     // Make all numbers round down\n *     mongoose.Number.get(function(v) { return Math.floor(v); });\n *\n *     const Model = mongoose.model('Test', new Schema({ test: Number }));\n *     new Model({ test: 3.14 }).test; // 3\n *\n * @param {Function} getter\n * @return {this}\n * @function get\n * @static\n * @api public\n */\n\nSchemaNumber.get = SchemaType.get;\n\n/**\n * Sets a default option for all Number instances.\n *\n * #### Example:\n *\n *     // Make all numbers have option `min` equal to 0.\n *     mongoose.Schema.Number.set('min', 0);\n *\n *     const Order = mongoose.model('Order', new Schema({ amount: Number }));\n *     new Order({ amount: -10 }).validateSync().errors.amount.message; // Path `amount` must be larger than 0.\n *\n * @param {String} option The option you'd like to set the value for\n * @param {Any} value value for option\n * @return {undefined}\n * @function set\n * @static\n * @api public\n */\n\nSchemaNumber.set = SchemaType.set;\n\nSchemaNumber.setters = [];\n\n/*!\n * ignore\n */\n\nSchemaNumber._cast = castNumber;\n\n/**\n * Get/set the function used to cast arbitrary values to numbers.\n *\n * #### Example:\n *\n *     // Make Mongoose cast empty strings '' to 0 for paths declared as numbers\n *     const original = mongoose.Number.cast();\n *     mongoose.Number.cast(v => {\n *       if (v === '') { return 0; }\n *       return original(v);\n *     });\n *\n *     // Or disable casting entirely\n *     mongoose.Number.cast(false);\n *\n * @param {Function} caster\n * @return {Function}\n * @function get\n * @static\n * @api public\n */\n\nSchemaNumber.cast = function cast(caster) {\n  if (arguments.length === 0) {\n    return this._cast;\n  }\n  if (caster === false) {\n    caster = this._defaultCaster;\n  }\n  this._cast = caster;\n\n  return this._cast;\n};\n\n/*!\n * ignore\n */\n\nSchemaNumber._defaultCaster = v => {\n  if (typeof v !== 'number') {\n    throw new Error();\n  }\n  return v;\n};\n\n/**\n * This schema type's name, to defend against minifiers that mangle\n * function names.\n *\n * @api public\n */\nSchemaNumber.schemaName = 'Number';\n\nSchemaNumber.defaultOptions = {};\n\n/*!\n * Inherits from SchemaType.\n */\nSchemaNumber.prototype = Object.create(SchemaType.prototype);\nSchemaNumber.prototype.constructor = SchemaNumber;\nSchemaNumber.prototype.OptionsConstructor = SchemaNumberOptions;\n\n/*!\n * ignore\n */\n\nSchemaNumber._checkRequired = v => typeof v === 'number' || v instanceof Number;\n\n/**\n * Override the function the required validator uses to check whether a string\n * passes the `required` check.\n *\n * @param {Function} fn\n * @return {Function}\n * @function checkRequired\n * @static\n * @api public\n */\n\nSchemaNumber.checkRequired = SchemaType.checkRequired;\n\n/**\n * Check if the given value satisfies a required validator.\n *\n * @param {Any} value\n * @param {Document} doc\n * @return {Boolean}\n * @api public\n */\n\nSchemaNumber.prototype.checkRequired = function checkRequired(value, doc) {\n  if (typeof value === 'object' && SchemaType._isRef(this, value, doc, true)) {\n    return value != null;\n  }\n\n  // `require('util').inherits()` does **not** copy static properties, and\n  // plugins like mongoose-float use `inherits()` for pre-ES6.\n  const _checkRequired = typeof this.constructor.checkRequired === 'function' ?\n    this.constructor.checkRequired() :\n    SchemaNumber.checkRequired();\n\n  return _checkRequired(value);\n};\n\n/**\n * Sets a minimum number validator.\n *\n * #### Example:\n *\n *     const s = new Schema({ n: { type: Number, min: 10 })\n *     const M = db.model('M', s)\n *     const m = new M({ n: 9 })\n *     m.save(function (err) {\n *       console.error(err) // validator error\n *       m.n = 10;\n *       m.save() // success\n *     })\n *\n *     // custom error messages\n *     // We can also use the special {MIN} token which will be replaced with the invalid value\n *     const min = [10, 'The value of path `{PATH}` ({VALUE}) is beneath the limit ({MIN}).'];\n *     const schema = new Schema({ n: { type: Number, min: min })\n *     const M = mongoose.model('Measurement', schema);\n *     const s= new M({ n: 4 });\n *     s.validate(function (err) {\n *       console.log(String(err)) // ValidationError: The value of path `n` (4) is beneath the limit (10).\n *     })\n *\n * @param {Number} value minimum number\n * @param {String} [message] optional custom error message\n * @return {SchemaType} this\n * @see Customized Error Messages https://mongoosejs.com/docs/api/error.html#Error.messages\n * @api public\n */\n\nSchemaNumber.prototype.min = function(value, message) {\n  if (this.minValidator) {\n    this.validators = this.validators.filter(function(v) {\n      return v.validator !== this.minValidator;\n    }, this);\n  }\n\n  if (value !== null && value !== undefined) {\n    let msg = message || MongooseError.messages.Number.min;\n    msg = msg.replace(/{MIN}/, value);\n    this.validators.push({\n      validator: this.minValidator = function(v) {\n        return v == null || v >= value;\n      },\n      message: msg,\n      type: 'min',\n      min: value\n    });\n  }\n\n  return this;\n};\n\n/**\n * Sets a maximum number validator.\n *\n * #### Example:\n *\n *     const s = new Schema({ n: { type: Number, max: 10 })\n *     const M = db.model('M', s)\n *     const m = new M({ n: 11 })\n *     m.save(function (err) {\n *       console.error(err) // validator error\n *       m.n = 10;\n *       m.save() // success\n *     })\n *\n *     // custom error messages\n *     // We can also use the special {MAX} token which will be replaced with the invalid value\n *     const max = [10, 'The value of path `{PATH}` ({VALUE}) exceeds the limit ({MAX}).'];\n *     const schema = new Schema({ n: { type: Number, max: max })\n *     const M = mongoose.model('Measurement', schema);\n *     const s= new M({ n: 4 });\n *     s.validate(function (err) {\n *       console.log(String(err)) // ValidationError: The value of path `n` (4) exceeds the limit (10).\n *     })\n *\n * @param {Number} maximum number\n * @param {String} [message] optional custom error message\n * @return {SchemaType} this\n * @see Customized Error Messages https://mongoosejs.com/docs/api/error.html#Error.messages\n * @api public\n */\n\nSchemaNumber.prototype.max = function(value, message) {\n  if (this.maxValidator) {\n    this.validators = this.validators.filter(function(v) {\n      return v.validator !== this.maxValidator;\n    }, this);\n  }\n\n  if (value !== null && value !== undefined) {\n    let msg = message || MongooseError.messages.Number.max;\n    msg = msg.replace(/{MAX}/, value);\n    this.validators.push({\n      validator: this.maxValidator = function(v) {\n        return v == null || v <= value;\n      },\n      message: msg,\n      type: 'max',\n      max: value\n    });\n  }\n\n  return this;\n};\n\n/**\n * Sets a enum validator\n *\n * #### Example:\n *\n *     const s = new Schema({ n: { type: Number, enum: [1, 2, 3] });\n *     const M = db.model('M', s);\n *\n *     const m = new M({ n: 4 });\n *     await m.save(); // throws validation error\n *\n *     m.n = 3;\n *     await m.save(); // succeeds\n *\n * @param {Array} values allowed values\n * @param {String} [message] optional custom error message\n * @return {SchemaType} this\n * @see Customized Error Messages https://mongoosejs.com/docs/api/error.html#Error.messages\n * @api public\n */\n\nSchemaNumber.prototype.enum = function(values, message) {\n  if (this.enumValidator) {\n    this.validators = this.validators.filter(function(v) {\n      return v.validator !== this.enumValidator;\n    }, this);\n  }\n\n\n  if (!Array.isArray(values)) {\n    const isObjectSyntax = utils.isPOJO(values) && values.values != null;\n    if (isObjectSyntax) {\n      message = values.message;\n      values = values.values;\n    } else if (typeof values === 'number') {\n      values = Array.prototype.slice.call(arguments);\n      message = null;\n    }\n\n    if (utils.isPOJO(values)) {\n      values = Object.values(values);\n    }\n    message = message || MongooseError.messages.Number.enum;\n  }\n\n  message = message == null ? MongooseError.messages.Number.enum : message;\n\n  this.enumValidator = v => v == null || values.indexOf(v) !== -1;\n  this.validators.push({\n    validator: this.enumValidator,\n    message: message,\n    type: 'enum',\n    enumValues: values\n  });\n\n  return this;\n};\n\n/**\n * Casts to number\n *\n * @param {Object} value value to cast\n * @param {Document} doc document that triggers the casting\n * @param {Boolean} init\n * @api private\n */\n\nSchemaNumber.prototype.cast = function(value, doc, init) {\n  if (typeof value !== 'number' && SchemaType._isRef(this, value, doc, init)) {\n    if (value == null || utils.isNonBuiltinObject(value)) {\n      return this._castRef(value, doc, init);\n    }\n  }\n\n  const val = value && typeof value._id !== 'undefined' ?\n    value._id : // documents\n    value;\n\n  let castNumber;\n  if (typeof this._castFunction === 'function') {\n    castNumber = this._castFunction;\n  } else if (typeof this.constructor.cast === 'function') {\n    castNumber = this.constructor.cast();\n  } else {\n    castNumber = SchemaNumber.cast();\n  }\n\n  try {\n    return castNumber(val);\n  } catch (err) {\n    throw new CastError('Number', val, this.path, err, this);\n  }\n};\n\n/*!\n * ignore\n */\n\nfunction handleSingle(val) {\n  return this.cast(val);\n}\n\nfunction handleArray(val) {\n  const _this = this;\n  if (!Array.isArray(val)) {\n    return [this.cast(val)];\n  }\n  return val.map(function(m) {\n    return _this.cast(m);\n  });\n}\n\nSchemaNumber.prototype.$conditionalHandlers = {\n  ...SchemaType.prototype.$conditionalHandlers,\n  $bitsAllClear: handleBitwiseOperator,\n  $bitsAnyClear: handleBitwiseOperator,\n  $bitsAllSet: handleBitwiseOperator,\n  $bitsAnySet: handleBitwiseOperator,\n  $gt: handleSingle,\n  $gte: handleSingle,\n  $lt: handleSingle,\n  $lte: handleSingle,\n  $mod: handleArray\n};\n\n/**\n * Casts contents for queries.\n *\n * @param {String} $conditional\n * @param {any} [value]\n * @api private\n */\n\nSchemaNumber.prototype.castForQuery = function($conditional, val, context) {\n  let handler;\n  if ($conditional != null) {\n    handler = this.$conditionalHandlers[$conditional];\n    if (!handler) {\n      throw new CastError('number', val, this.path, null, this);\n    }\n    return handler.call(this, val, context);\n  }\n\n  try {\n    val = this.applySetters(val, context);\n  } catch (err) {\n    if (err instanceof CastError && err.path === this.path && this.$fullPath != null) {\n      err.path = this.$fullPath;\n    }\n    throw err;\n  }\n\n  return val;\n};\n\n/*!\n * Module exports.\n */\n\nmodule.exports = SchemaNumber;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvc2NoZW1hL251bWJlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBO0FBQ0E7O0FBRUEsc0JBQXNCLG1CQUFPLENBQUMsMEVBQWdCO0FBQzlDLDRCQUE0QixtQkFBTyxDQUFDLDBHQUFnQztBQUNwRSxtQkFBbUIsbUJBQU8sQ0FBQyx3RUFBZTtBQUMxQyxtQkFBbUIsbUJBQU8sQ0FBQywwRUFBZ0I7QUFDM0MsOEJBQThCLG1CQUFPLENBQUMsNEZBQXFCO0FBQzNELGNBQWMsbUJBQU8sQ0FBQyw4REFBVTs7QUFFaEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5Qyx1QkFBdUI7QUFDaEU7QUFDQSx5REFBeUQsY0FBYztBQUN2RSxtQkFBbUIsWUFBWSxRQUFRO0FBQ3ZDO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBELGdCQUFnQjtBQUMxRSxtQkFBbUIsYUFBYSx3Q0FBd0M7QUFDeEU7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxLQUFLO0FBQ2hCLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsVUFBVTtBQUNyQixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtB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QTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLEtBQUs7QUFDaEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2xpZW50Ly4uL3NlcnZlci9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL3NjaGVtYS9udW1iZXIuanM/NTUwMSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbi8qIVxuICogTW9kdWxlIHJlcXVpcmVtZW50cy5cbiAqL1xuXG5jb25zdCBNb25nb29zZUVycm9yID0gcmVxdWlyZSgnLi4vZXJyb3IvaW5kZXgnKTtcbmNvbnN0IFNjaGVtYU51bWJlck9wdGlvbnMgPSByZXF1aXJlKCcuLi9vcHRpb25zL3NjaGVtYU51bWJlck9wdGlvbnMnKTtcbmNvbnN0IFNjaGVtYVR5cGUgPSByZXF1aXJlKCcuLi9zY2hlbWFUeXBlJyk7XG5jb25zdCBjYXN0TnVtYmVyID0gcmVxdWlyZSgnLi4vY2FzdC9udW1iZXInKTtcbmNvbnN0IGhhbmRsZUJpdHdpc2VPcGVyYXRvciA9IHJlcXVpcmUoJy4vb3BlcmF0b3JzL2JpdHdpc2UnKTtcbmNvbnN0IHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMnKTtcblxuY29uc3QgQ2FzdEVycm9yID0gU2NoZW1hVHlwZS5DYXN0RXJyb3I7XG5cbi8qKlxuICogTnVtYmVyIFNjaGVtYVR5cGUgY29uc3RydWN0b3IuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGtleVxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEBpbmhlcml0cyBTY2hlbWFUeXBlXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIFNjaGVtYU51bWJlcihrZXksIG9wdGlvbnMpIHtcbiAgU2NoZW1hVHlwZS5jYWxsKHRoaXMsIGtleSwgb3B0aW9ucywgJ051bWJlcicpO1xufVxuXG4vKipcbiAqIEF0dGFjaGVzIGEgZ2V0dGVyIGZvciBhbGwgTnVtYmVyIGluc3RhbmNlcy5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIC8vIE1ha2UgYWxsIG51bWJlcnMgcm91bmQgZG93blxuICogICAgIG1vbmdvb3NlLk51bWJlci5nZXQoZnVuY3Rpb24odikgeyByZXR1cm4gTWF0aC5mbG9vcih2KTsgfSk7XG4gKlxuICogICAgIGNvbnN0IE1vZGVsID0gbW9uZ29vc2UubW9kZWwoJ1Rlc3QnLCBuZXcgU2NoZW1hKHsgdGVzdDogTnVtYmVyIH0pKTtcbiAqICAgICBuZXcgTW9kZWwoeyB0ZXN0OiAzLjE0IH0pLnRlc3Q7IC8vIDNcbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBnZXR0ZXJcbiAqIEByZXR1cm4ge3RoaXN9XG4gKiBAZnVuY3Rpb24gZ2V0XG4gKiBAc3RhdGljXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblNjaGVtYU51bWJlci5nZXQgPSBTY2hlbWFUeXBlLmdldDtcblxuLyoqXG4gKiBTZXRzIGEgZGVmYXVsdCBvcHRpb24gZm9yIGFsbCBOdW1iZXIgaW5zdGFuY2VzLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgLy8gTWFrZSBhbGwgbnVtYmVycyBoYXZlIG9wdGlvbiBgbWluYCBlcXVhbCB0byAwLlxuICogICAgIG1vbmdvb3NlLlNjaGVtYS5OdW1iZXIuc2V0KCdtaW4nLCAwKTtcbiAqXG4gKiAgICAgY29uc3QgT3JkZXIgPSBtb25nb29zZS5tb2RlbCgnT3JkZXInLCBuZXcgU2NoZW1hKHsgYW1vdW50OiBOdW1iZXIgfSkpO1xuICogICAgIG5ldyBPcmRlcih7IGFtb3VudDogLTEwIH0pLnZhbGlkYXRlU3luYygpLmVycm9ycy5hbW91bnQubWVzc2FnZTsgLy8gUGF0aCBgYW1vdW50YCBtdXN0IGJlIGxhcmdlciB0aGFuIDAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG9wdGlvbiBUaGUgb3B0aW9uIHlvdSdkIGxpa2UgdG8gc2V0IHRoZSB2YWx1ZSBmb3JcbiAqIEBwYXJhbSB7QW55fSB2YWx1ZSB2YWx1ZSBmb3Igb3B0aW9uXG4gKiBAcmV0dXJuIHt1bmRlZmluZWR9XG4gKiBAZnVuY3Rpb24gc2V0XG4gKiBAc3RhdGljXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblNjaGVtYU51bWJlci5zZXQgPSBTY2hlbWFUeXBlLnNldDtcblxuU2NoZW1hTnVtYmVyLnNldHRlcnMgPSBbXTtcblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5TY2hlbWFOdW1iZXIuX2Nhc3QgPSBjYXN0TnVtYmVyO1xuXG4vKipcbiAqIEdldC9zZXQgdGhlIGZ1bmN0aW9uIHVzZWQgdG8gY2FzdCBhcmJpdHJhcnkgdmFsdWVzIHRvIG51bWJlcnMuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICAvLyBNYWtlIE1vbmdvb3NlIGNhc3QgZW1wdHkgc3RyaW5ncyAnJyB0byAwIGZvciBwYXRocyBkZWNsYXJlZCBhcyBudW1iZXJzXG4gKiAgICAgY29uc3Qgb3JpZ2luYWwgPSBtb25nb29zZS5OdW1iZXIuY2FzdCgpO1xuICogICAgIG1vbmdvb3NlLk51bWJlci5jYXN0KHYgPT4ge1xuICogICAgICAgaWYgKHYgPT09ICcnKSB7IHJldHVybiAwOyB9XG4gKiAgICAgICByZXR1cm4gb3JpZ2luYWwodik7XG4gKiAgICAgfSk7XG4gKlxuICogICAgIC8vIE9yIGRpc2FibGUgY2FzdGluZyBlbnRpcmVseVxuICogICAgIG1vbmdvb3NlLk51bWJlci5jYXN0KGZhbHNlKTtcbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYXN0ZXJcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICogQGZ1bmN0aW9uIGdldFxuICogQHN0YXRpY1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5TY2hlbWFOdW1iZXIuY2FzdCA9IGZ1bmN0aW9uIGNhc3QoY2FzdGVyKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIHRoaXMuX2Nhc3Q7XG4gIH1cbiAgaWYgKGNhc3RlciA9PT0gZmFsc2UpIHtcbiAgICBjYXN0ZXIgPSB0aGlzLl9kZWZhdWx0Q2FzdGVyO1xuICB9XG4gIHRoaXMuX2Nhc3QgPSBjYXN0ZXI7XG5cbiAgcmV0dXJuIHRoaXMuX2Nhc3Q7XG59O1xuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cblNjaGVtYU51bWJlci5fZGVmYXVsdENhc3RlciA9IHYgPT4ge1xuICBpZiAodHlwZW9mIHYgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCk7XG4gIH1cbiAgcmV0dXJuIHY7XG59O1xuXG4vKipcbiAqIFRoaXMgc2NoZW1hIHR5cGUncyBuYW1lLCB0byBkZWZlbmQgYWdhaW5zdCBtaW5pZmllcnMgdGhhdCBtYW5nbGVcbiAqIGZ1bmN0aW9uIG5hbWVzLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblNjaGVtYU51bWJlci5zY2hlbWFOYW1lID0gJ051bWJlcic7XG5cblNjaGVtYU51bWJlci5kZWZhdWx0T3B0aW9ucyA9IHt9O1xuXG4vKiFcbiAqIEluaGVyaXRzIGZyb20gU2NoZW1hVHlwZS5cbiAqL1xuU2NoZW1hTnVtYmVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoU2NoZW1hVHlwZS5wcm90b3R5cGUpO1xuU2NoZW1hTnVtYmVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFNjaGVtYU51bWJlcjtcblNjaGVtYU51bWJlci5wcm90b3R5cGUuT3B0aW9uc0NvbnN0cnVjdG9yID0gU2NoZW1hTnVtYmVyT3B0aW9ucztcblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5TY2hlbWFOdW1iZXIuX2NoZWNrUmVxdWlyZWQgPSB2ID0+IHR5cGVvZiB2ID09PSAnbnVtYmVyJyB8fCB2IGluc3RhbmNlb2YgTnVtYmVyO1xuXG4vKipcbiAqIE92ZXJyaWRlIHRoZSBmdW5jdGlvbiB0aGUgcmVxdWlyZWQgdmFsaWRhdG9yIHVzZXMgdG8gY2hlY2sgd2hldGhlciBhIHN0cmluZ1xuICogcGFzc2VzIHRoZSBgcmVxdWlyZWRgIGNoZWNrLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAqIEBmdW5jdGlvbiBjaGVja1JlcXVpcmVkXG4gKiBAc3RhdGljXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblNjaGVtYU51bWJlci5jaGVja1JlcXVpcmVkID0gU2NoZW1hVHlwZS5jaGVja1JlcXVpcmVkO1xuXG4vKipcbiAqIENoZWNrIGlmIHRoZSBnaXZlbiB2YWx1ZSBzYXRpc2ZpZXMgYSByZXF1aXJlZCB2YWxpZGF0b3IuXG4gKlxuICogQHBhcmFtIHtBbnl9IHZhbHVlXG4gKiBAcGFyYW0ge0RvY3VtZW50fSBkb2NcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblNjaGVtYU51bWJlci5wcm90b3R5cGUuY2hlY2tSZXF1aXJlZCA9IGZ1bmN0aW9uIGNoZWNrUmVxdWlyZWQodmFsdWUsIGRvYykge1xuICBpZiAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiBTY2hlbWFUeXBlLl9pc1JlZih0aGlzLCB2YWx1ZSwgZG9jLCB0cnVlKSkge1xuICAgIHJldHVybiB2YWx1ZSAhPSBudWxsO1xuICB9XG5cbiAgLy8gYHJlcXVpcmUoJ3V0aWwnKS5pbmhlcml0cygpYCBkb2VzICoqbm90KiogY29weSBzdGF0aWMgcHJvcGVydGllcywgYW5kXG4gIC8vIHBsdWdpbnMgbGlrZSBtb25nb29zZS1mbG9hdCB1c2UgYGluaGVyaXRzKClgIGZvciBwcmUtRVM2LlxuICBjb25zdCBfY2hlY2tSZXF1aXJlZCA9IHR5cGVvZiB0aGlzLmNvbnN0cnVjdG9yLmNoZWNrUmVxdWlyZWQgPT09ICdmdW5jdGlvbicgP1xuICAgIHRoaXMuY29uc3RydWN0b3IuY2hlY2tSZXF1aXJlZCgpIDpcbiAgICBTY2hlbWFOdW1iZXIuY2hlY2tSZXF1aXJlZCgpO1xuXG4gIHJldHVybiBfY2hlY2tSZXF1aXJlZCh2YWx1ZSk7XG59O1xuXG4vKipcbiAqIFNldHMgYSBtaW5pbXVtIG51bWJlciB2YWxpZGF0b3IuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBjb25zdCBzID0gbmV3IFNjaGVtYSh7IG46IHsgdHlwZTogTnVtYmVyLCBtaW46IDEwIH0pXG4gKiAgICAgY29uc3QgTSA9IGRiLm1vZGVsKCdNJywgcylcbiAqICAgICBjb25zdCBtID0gbmV3IE0oeyBuOiA5IH0pXG4gKiAgICAgbS5zYXZlKGZ1bmN0aW9uIChlcnIpIHtcbiAqICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyKSAvLyB2YWxpZGF0b3IgZXJyb3JcbiAqICAgICAgIG0ubiA9IDEwO1xuICogICAgICAgbS5zYXZlKCkgLy8gc3VjY2Vzc1xuICogICAgIH0pXG4gKlxuICogICAgIC8vIGN1c3RvbSBlcnJvciBtZXNzYWdlc1xuICogICAgIC8vIFdlIGNhbiBhbHNvIHVzZSB0aGUgc3BlY2lhbCB7TUlOfSB0b2tlbiB3aGljaCB3aWxsIGJlIHJlcGxhY2VkIHdpdGggdGhlIGludmFsaWQgdmFsdWVcbiAqICAgICBjb25zdCBtaW4gPSBbMTAsICdUaGUgdmFsdWUgb2YgcGF0aCBge1BBVEh9YCAoe1ZBTFVFfSkgaXMgYmVuZWF0aCB0aGUgbGltaXQgKHtNSU59KS4nXTtcbiAqICAgICBjb25zdCBzY2hlbWEgPSBuZXcgU2NoZW1hKHsgbjogeyB0eXBlOiBOdW1iZXIsIG1pbjogbWluIH0pXG4gKiAgICAgY29uc3QgTSA9IG1vbmdvb3NlLm1vZGVsKCdNZWFzdXJlbWVudCcsIHNjaGVtYSk7XG4gKiAgICAgY29uc3Qgcz0gbmV3IE0oeyBuOiA0IH0pO1xuICogICAgIHMudmFsaWRhdGUoZnVuY3Rpb24gKGVycikge1xuICogICAgICAgY29uc29sZS5sb2coU3RyaW5nKGVycikpIC8vIFZhbGlkYXRpb25FcnJvcjogVGhlIHZhbHVlIG9mIHBhdGggYG5gICg0KSBpcyBiZW5lYXRoIHRoZSBsaW1pdCAoMTApLlxuICogICAgIH0pXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlIG1pbmltdW0gbnVtYmVyXG4gKiBAcGFyYW0ge1N0cmluZ30gW21lc3NhZ2VdIG9wdGlvbmFsIGN1c3RvbSBlcnJvciBtZXNzYWdlXG4gKiBAcmV0dXJuIHtTY2hlbWFUeXBlfSB0aGlzXG4gKiBAc2VlIEN1c3RvbWl6ZWQgRXJyb3IgTWVzc2FnZXMgaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2FwaS9lcnJvci5odG1sI0Vycm9yLm1lc3NhZ2VzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblNjaGVtYU51bWJlci5wcm90b3R5cGUubWluID0gZnVuY3Rpb24odmFsdWUsIG1lc3NhZ2UpIHtcbiAgaWYgKHRoaXMubWluVmFsaWRhdG9yKSB7XG4gICAgdGhpcy52YWxpZGF0b3JzID0gdGhpcy52YWxpZGF0b3JzLmZpbHRlcihmdW5jdGlvbih2KSB7XG4gICAgICByZXR1cm4gdi52YWxpZGF0b3IgIT09IHRoaXMubWluVmFsaWRhdG9yO1xuICAgIH0sIHRoaXMpO1xuICB9XG5cbiAgaWYgKHZhbHVlICE9PSBudWxsICYmIHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICBsZXQgbXNnID0gbWVzc2FnZSB8fCBNb25nb29zZUVycm9yLm1lc3NhZ2VzLk51bWJlci5taW47XG4gICAgbXNnID0gbXNnLnJlcGxhY2UoL3tNSU59LywgdmFsdWUpO1xuICAgIHRoaXMudmFsaWRhdG9ycy5wdXNoKHtcbiAgICAgIHZhbGlkYXRvcjogdGhpcy5taW5WYWxpZGF0b3IgPSBmdW5jdGlvbih2KSB7XG4gICAgICAgIHJldHVybiB2ID09IG51bGwgfHwgdiA+PSB2YWx1ZTtcbiAgICAgIH0sXG4gICAgICBtZXNzYWdlOiBtc2csXG4gICAgICB0eXBlOiAnbWluJyxcbiAgICAgIG1pbjogdmFsdWVcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZXRzIGEgbWF4aW11bSBudW1iZXIgdmFsaWRhdG9yLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgY29uc3QgcyA9IG5ldyBTY2hlbWEoeyBuOiB7IHR5cGU6IE51bWJlciwgbWF4OiAxMCB9KVxuICogICAgIGNvbnN0IE0gPSBkYi5tb2RlbCgnTScsIHMpXG4gKiAgICAgY29uc3QgbSA9IG5ldyBNKHsgbjogMTEgfSlcbiAqICAgICBtLnNhdmUoZnVuY3Rpb24gKGVycikge1xuICogICAgICAgY29uc29sZS5lcnJvcihlcnIpIC8vIHZhbGlkYXRvciBlcnJvclxuICogICAgICAgbS5uID0gMTA7XG4gKiAgICAgICBtLnNhdmUoKSAvLyBzdWNjZXNzXG4gKiAgICAgfSlcbiAqXG4gKiAgICAgLy8gY3VzdG9tIGVycm9yIG1lc3NhZ2VzXG4gKiAgICAgLy8gV2UgY2FuIGFsc28gdXNlIHRoZSBzcGVjaWFsIHtNQVh9IHRva2VuIHdoaWNoIHdpbGwgYmUgcmVwbGFjZWQgd2l0aCB0aGUgaW52YWxpZCB2YWx1ZVxuICogICAgIGNvbnN0IG1heCA9IFsxMCwgJ1RoZSB2YWx1ZSBvZiBwYXRoIGB7UEFUSH1gICh7VkFMVUV9KSBleGNlZWRzIHRoZSBsaW1pdCAoe01BWH0pLiddO1xuICogICAgIGNvbnN0IHNjaGVtYSA9IG5ldyBTY2hlbWEoeyBuOiB7IHR5cGU6IE51bWJlciwgbWF4OiBtYXggfSlcbiAqICAgICBjb25zdCBNID0gbW9uZ29vc2UubW9kZWwoJ01lYXN1cmVtZW50Jywgc2NoZW1hKTtcbiAqICAgICBjb25zdCBzPSBuZXcgTSh7IG46IDQgfSk7XG4gKiAgICAgcy52YWxpZGF0ZShmdW5jdGlvbiAoZXJyKSB7XG4gKiAgICAgICBjb25zb2xlLmxvZyhTdHJpbmcoZXJyKSkgLy8gVmFsaWRhdGlvbkVycm9yOiBUaGUgdmFsdWUgb2YgcGF0aCBgbmAgKDQpIGV4Y2VlZHMgdGhlIGxpbWl0ICgxMCkuXG4gKiAgICAgfSlcbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gbWF4aW11bSBudW1iZXJcbiAqIEBwYXJhbSB7U3RyaW5nfSBbbWVzc2FnZV0gb3B0aW9uYWwgY3VzdG9tIGVycm9yIG1lc3NhZ2VcbiAqIEByZXR1cm4ge1NjaGVtYVR5cGV9IHRoaXNcbiAqIEBzZWUgQ3VzdG9taXplZCBFcnJvciBNZXNzYWdlcyBodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvYXBpL2Vycm9yLmh0bWwjRXJyb3IubWVzc2FnZXNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuU2NoZW1hTnVtYmVyLnByb3RvdHlwZS5tYXggPSBmdW5jdGlvbih2YWx1ZSwgbWVzc2FnZSkge1xuICBpZiAodGhpcy5tYXhWYWxpZGF0b3IpIHtcbiAgICB0aGlzLnZhbGlkYXRvcnMgPSB0aGlzLnZhbGlkYXRvcnMuZmlsdGVyKGZ1bmN0aW9uKHYpIHtcbiAgICAgIHJldHVybiB2LnZhbGlkYXRvciAhPT0gdGhpcy5tYXhWYWxpZGF0b3I7XG4gICAgfSwgdGhpcyk7XG4gIH1cblxuICBpZiAodmFsdWUgIT09IG51bGwgJiYgdmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgIGxldCBtc2cgPSBtZXNzYWdlIHx8IE1vbmdvb3NlRXJyb3IubWVzc2FnZXMuTnVtYmVyLm1heDtcbiAgICBtc2cgPSBtc2cucmVwbGFjZSgve01BWH0vLCB2YWx1ZSk7XG4gICAgdGhpcy52YWxpZGF0b3JzLnB1c2goe1xuICAgICAgdmFsaWRhdG9yOiB0aGlzLm1heFZhbGlkYXRvciA9IGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgcmV0dXJuIHYgPT0gbnVsbCB8fCB2IDw9IHZhbHVlO1xuICAgICAgfSxcbiAgICAgIG1lc3NhZ2U6IG1zZyxcbiAgICAgIHR5cGU6ICdtYXgnLFxuICAgICAgbWF4OiB2YWx1ZVxuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNldHMgYSBlbnVtIHZhbGlkYXRvclxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgY29uc3QgcyA9IG5ldyBTY2hlbWEoeyBuOiB7IHR5cGU6IE51bWJlciwgZW51bTogWzEsIDIsIDNdIH0pO1xuICogICAgIGNvbnN0IE0gPSBkYi5tb2RlbCgnTScsIHMpO1xuICpcbiAqICAgICBjb25zdCBtID0gbmV3IE0oeyBuOiA0IH0pO1xuICogICAgIGF3YWl0IG0uc2F2ZSgpOyAvLyB0aHJvd3MgdmFsaWRhdGlvbiBlcnJvclxuICpcbiAqICAgICBtLm4gPSAzO1xuICogICAgIGF3YWl0IG0uc2F2ZSgpOyAvLyBzdWNjZWVkc1xuICpcbiAqIEBwYXJhbSB7QXJyYXl9IHZhbHVlcyBhbGxvd2VkIHZhbHVlc1xuICogQHBhcmFtIHtTdHJpbmd9IFttZXNzYWdlXSBvcHRpb25hbCBjdXN0b20gZXJyb3IgbWVzc2FnZVxuICogQHJldHVybiB7U2NoZW1hVHlwZX0gdGhpc1xuICogQHNlZSBDdXN0b21pemVkIEVycm9yIE1lc3NhZ2VzIGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvZXJyb3IuaHRtbCNFcnJvci5tZXNzYWdlc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5TY2hlbWFOdW1iZXIucHJvdG90eXBlLmVudW0gPSBmdW5jdGlvbih2YWx1ZXMsIG1lc3NhZ2UpIHtcbiAgaWYgKHRoaXMuZW51bVZhbGlkYXRvcikge1xuICAgIHRoaXMudmFsaWRhdG9ycyA9IHRoaXMudmFsaWRhdG9ycy5maWx0ZXIoZnVuY3Rpb24odikge1xuICAgICAgcmV0dXJuIHYudmFsaWRhdG9yICE9PSB0aGlzLmVudW1WYWxpZGF0b3I7XG4gICAgfSwgdGhpcyk7XG4gIH1cblxuXG4gIGlmICghQXJyYXkuaXNBcnJheSh2YWx1ZXMpKSB7XG4gICAgY29uc3QgaXNPYmplY3RTeW50YXggPSB1dGlscy5pc1BPSk8odmFsdWVzKSAmJiB2YWx1ZXMudmFsdWVzICE9IG51bGw7XG4gICAgaWYgKGlzT2JqZWN0U3ludGF4KSB7XG4gICAgICBtZXNzYWdlID0gdmFsdWVzLm1lc3NhZ2U7XG4gICAgICB2YWx1ZXMgPSB2YWx1ZXMudmFsdWVzO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlcyA9PT0gJ251bWJlcicpIHtcbiAgICAgIHZhbHVlcyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgICBtZXNzYWdlID0gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAodXRpbHMuaXNQT0pPKHZhbHVlcykpIHtcbiAgICAgIHZhbHVlcyA9IE9iamVjdC52YWx1ZXModmFsdWVzKTtcbiAgICB9XG4gICAgbWVzc2FnZSA9IG1lc3NhZ2UgfHwgTW9uZ29vc2VFcnJvci5tZXNzYWdlcy5OdW1iZXIuZW51bTtcbiAgfVxuXG4gIG1lc3NhZ2UgPSBtZXNzYWdlID09IG51bGwgPyBNb25nb29zZUVycm9yLm1lc3NhZ2VzLk51bWJlci5lbnVtIDogbWVzc2FnZTtcblxuICB0aGlzLmVudW1WYWxpZGF0b3IgPSB2ID0+IHYgPT0gbnVsbCB8fCB2YWx1ZXMuaW5kZXhPZih2KSAhPT0gLTE7XG4gIHRoaXMudmFsaWRhdG9ycy5wdXNoKHtcbiAgICB2YWxpZGF0b3I6IHRoaXMuZW51bVZhbGlkYXRvcixcbiAgICBtZXNzYWdlOiBtZXNzYWdlLFxuICAgIHR5cGU6ICdlbnVtJyxcbiAgICBlbnVtVmFsdWVzOiB2YWx1ZXNcbiAgfSk7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIENhc3RzIHRvIG51bWJlclxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWx1ZSB2YWx1ZSB0byBjYXN0XG4gKiBAcGFyYW0ge0RvY3VtZW50fSBkb2MgZG9jdW1lbnQgdGhhdCB0cmlnZ2VycyB0aGUgY2FzdGluZ1xuICogQHBhcmFtIHtCb29sZWFufSBpbml0XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5TY2hlbWFOdW1iZXIucHJvdG90eXBlLmNhc3QgPSBmdW5jdGlvbih2YWx1ZSwgZG9jLCBpbml0KSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgIT09ICdudW1iZXInICYmIFNjaGVtYVR5cGUuX2lzUmVmKHRoaXMsIHZhbHVlLCBkb2MsIGluaXQpKSB7XG4gICAgaWYgKHZhbHVlID09IG51bGwgfHwgdXRpbHMuaXNOb25CdWlsdGluT2JqZWN0KHZhbHVlKSkge1xuICAgICAgcmV0dXJuIHRoaXMuX2Nhc3RSZWYodmFsdWUsIGRvYywgaW5pdCk7XG4gICAgfVxuICB9XG5cbiAgY29uc3QgdmFsID0gdmFsdWUgJiYgdHlwZW9mIHZhbHVlLl9pZCAhPT0gJ3VuZGVmaW5lZCcgP1xuICAgIHZhbHVlLl9pZCA6IC8vIGRvY3VtZW50c1xuICAgIHZhbHVlO1xuXG4gIGxldCBjYXN0TnVtYmVyO1xuICBpZiAodHlwZW9mIHRoaXMuX2Nhc3RGdW5jdGlvbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNhc3ROdW1iZXIgPSB0aGlzLl9jYXN0RnVuY3Rpb247XG4gIH0gZWxzZSBpZiAodHlwZW9mIHRoaXMuY29uc3RydWN0b3IuY2FzdCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNhc3ROdW1iZXIgPSB0aGlzLmNvbnN0cnVjdG9yLmNhc3QoKTtcbiAgfSBlbHNlIHtcbiAgICBjYXN0TnVtYmVyID0gU2NoZW1hTnVtYmVyLmNhc3QoKTtcbiAgfVxuXG4gIHRyeSB7XG4gICAgcmV0dXJuIGNhc3ROdW1iZXIodmFsKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgdGhyb3cgbmV3IENhc3RFcnJvcignTnVtYmVyJywgdmFsLCB0aGlzLnBhdGgsIGVyciwgdGhpcyk7XG4gIH1cbn07XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxuZnVuY3Rpb24gaGFuZGxlU2luZ2xlKHZhbCkge1xuICByZXR1cm4gdGhpcy5jYXN0KHZhbCk7XG59XG5cbmZ1bmN0aW9uIGhhbmRsZUFycmF5KHZhbCkge1xuICBjb25zdCBfdGhpcyA9IHRoaXM7XG4gIGlmICghQXJyYXkuaXNBcnJheSh2YWwpKSB7XG4gICAgcmV0dXJuIFt0aGlzLmNhc3QodmFsKV07XG4gIH1cbiAgcmV0dXJuIHZhbC5tYXAoZnVuY3Rpb24obSkge1xuICAgIHJldHVybiBfdGhpcy5jYXN0KG0pO1xuICB9KTtcbn1cblxuU2NoZW1hTnVtYmVyLnByb3RvdHlwZS4kY29uZGl0aW9uYWxIYW5kbGVycyA9IHtcbiAgLi4uU2NoZW1hVHlwZS5wcm90b3R5cGUuJGNvbmRpdGlvbmFsSGFuZGxlcnMsXG4gICRiaXRzQWxsQ2xlYXI6IGhhbmRsZUJpdHdpc2VPcGVyYXRvcixcbiAgJGJpdHNBbnlDbGVhcjogaGFuZGxlQml0d2lzZU9wZXJhdG9yLFxuICAkYml0c0FsbFNldDogaGFuZGxlQml0d2lzZU9wZXJhdG9yLFxuICAkYml0c0FueVNldDogaGFuZGxlQml0d2lzZU9wZXJhdG9yLFxuICAkZ3Q6IGhhbmRsZVNpbmdsZSxcbiAgJGd0ZTogaGFuZGxlU2luZ2xlLFxuICAkbHQ6IGhhbmRsZVNpbmdsZSxcbiAgJGx0ZTogaGFuZGxlU2luZ2xlLFxuICAkbW9kOiBoYW5kbGVBcnJheVxufTtcblxuLyoqXG4gKiBDYXN0cyBjb250ZW50cyBmb3IgcXVlcmllcy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gJGNvbmRpdGlvbmFsXG4gKiBAcGFyYW0ge2FueX0gW3ZhbHVlXVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU2NoZW1hTnVtYmVyLnByb3RvdHlwZS5jYXN0Rm9yUXVlcnkgPSBmdW5jdGlvbigkY29uZGl0aW9uYWwsIHZhbCwgY29udGV4dCkge1xuICBsZXQgaGFuZGxlcjtcbiAgaWYgKCRjb25kaXRpb25hbCAhPSBudWxsKSB7XG4gICAgaGFuZGxlciA9IHRoaXMuJGNvbmRpdGlvbmFsSGFuZGxlcnNbJGNvbmRpdGlvbmFsXTtcbiAgICBpZiAoIWhhbmRsZXIpIHtcbiAgICAgIHRocm93IG5ldyBDYXN0RXJyb3IoJ251bWJlcicsIHZhbCwgdGhpcy5wYXRoLCBudWxsLCB0aGlzKTtcbiAgICB9XG4gICAgcmV0dXJuIGhhbmRsZXIuY2FsbCh0aGlzLCB2YWwsIGNvbnRleHQpO1xuICB9XG5cbiAgdHJ5IHtcbiAgICB2YWwgPSB0aGlzLmFwcGx5U2V0dGVycyh2YWwsIGNvbnRleHQpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBpZiAoZXJyIGluc3RhbmNlb2YgQ2FzdEVycm9yICYmIGVyci5wYXRoID09PSB0aGlzLnBhdGggJiYgdGhpcy4kZnVsbFBhdGggIT0gbnVsbCkge1xuICAgICAgZXJyLnBhdGggPSB0aGlzLiRmdWxsUGF0aDtcbiAgICB9XG4gICAgdGhyb3cgZXJyO1xuICB9XG5cbiAgcmV0dXJuIHZhbDtcbn07XG5cbi8qIVxuICogTW9kdWxlIGV4cG9ydHMuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBTY2hlbWFOdW1iZXI7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../server/node_modules/mongoose/lib/schema/number.js\n");

/***/ }),

/***/ "../server/node_modules/mongoose/lib/schema/objectId.js":
/*!**************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/schema/objectId.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*!\n * Module dependencies.\n */\n\n\n\nconst SchemaObjectIdOptions = __webpack_require__(/*! ../options/schemaObjectIdOptions */ \"../server/node_modules/mongoose/lib/options/schemaObjectIdOptions.js\");\nconst SchemaType = __webpack_require__(/*! ../schemaType */ \"../server/node_modules/mongoose/lib/schemaType.js\");\nconst castObjectId = __webpack_require__(/*! ../cast/objectid */ \"../server/node_modules/mongoose/lib/cast/objectid.js\");\nconst getConstructorName = __webpack_require__(/*! ../helpers/getConstructorName */ \"../server/node_modules/mongoose/lib/helpers/getConstructorName.js\");\nconst oid = __webpack_require__(/*! ../types/objectid */ \"../server/node_modules/mongoose/lib/types/objectid.js\");\nconst isBsonType = __webpack_require__(/*! ../helpers/isBsonType */ \"../server/node_modules/mongoose/lib/helpers/isBsonType.js\");\nconst utils = __webpack_require__(/*! ../utils */ \"../server/node_modules/mongoose/lib/utils.js\");\n\nconst CastError = SchemaType.CastError;\nlet Document;\n\n/**\n * ObjectId SchemaType constructor.\n *\n * @param {String} key\n * @param {Object} options\n * @inherits SchemaType\n * @api public\n */\n\nfunction SchemaObjectId(key, options) {\n  const isKeyHexStr = typeof key === 'string' && key.length === 24 && /^[a-f0-9]+$/i.test(key);\n  const suppressWarning = options && options.suppressWarning;\n  if ((isKeyHexStr || typeof key === 'undefined') && !suppressWarning) {\n    utils.warn('mongoose: To create a new ObjectId please try ' +\n      '`Mongoose.Types.ObjectId` instead of using ' +\n      '`Mongoose.Schema.ObjectId`. Set the `suppressWarning` option if ' +\n      'you\\'re trying to create a hex char path in your schema.');\n  }\n  SchemaType.call(this, key, options, 'ObjectId');\n}\n\n/**\n * This schema type's name, to defend against minifiers that mangle\n * function names.\n *\n * @api public\n */\nSchemaObjectId.schemaName = 'ObjectId';\n\nSchemaObjectId.defaultOptions = {};\n\n/*!\n * Inherits from SchemaType.\n */\nSchemaObjectId.prototype = Object.create(SchemaType.prototype);\nSchemaObjectId.prototype.constructor = SchemaObjectId;\nSchemaObjectId.prototype.OptionsConstructor = SchemaObjectIdOptions;\n\n/**\n * Attaches a getter for all ObjectId instances\n *\n * #### Example:\n *\n *     // Always convert to string when getting an ObjectId\n *     mongoose.ObjectId.get(v => v.toString());\n *\n *     const Model = mongoose.model('Test', new Schema({}));\n *     typeof (new Model({})._id); // 'string'\n *\n * @param {Function} getter\n * @return {this}\n * @function get\n * @static\n * @api public\n */\n\nSchemaObjectId.get = SchemaType.get;\n\n/**\n * Sets a default option for all ObjectId instances.\n *\n * #### Example:\n *\n *     // Make all object ids have option `required` equal to true.\n *     mongoose.Schema.ObjectId.set('required', true);\n *\n *     const Order = mongoose.model('Order', new Schema({ userId: ObjectId }));\n *     new Order({ }).validateSync().errors.userId.message; // Path `userId` is required.\n *\n * @param {String} option The option you'd like to set the value for\n * @param {Any} value value for option\n * @return {undefined}\n * @function set\n * @static\n * @api public\n */\n\nSchemaObjectId.set = SchemaType.set;\n\nSchemaObjectId.setters = [];\n\n/**\n * Adds an auto-generated ObjectId default if turnOn is true.\n * @param {Boolean} turnOn auto generated ObjectId defaults\n * @api public\n * @return {SchemaType} this\n */\n\nSchemaObjectId.prototype.auto = function(turnOn) {\n  if (turnOn) {\n    this.default(defaultId);\n    this.set(resetId);\n  }\n\n  return this;\n};\n\n/*!\n * ignore\n */\n\nSchemaObjectId._checkRequired = v => isBsonType(v, 'ObjectId');\n\n/*!\n * ignore\n */\n\nSchemaObjectId._cast = castObjectId;\n\n/**\n * Get/set the function used to cast arbitrary values to objectids.\n *\n * #### Example:\n *\n *     // Make Mongoose only try to cast length 24 strings. By default, any 12\n *     // char string is a valid ObjectId.\n *     const original = mongoose.ObjectId.cast();\n *     mongoose.ObjectId.cast(v => {\n *       assert.ok(typeof v !== 'string' || v.length === 24);\n *       return original(v);\n *     });\n *\n *     // Or disable casting entirely\n *     mongoose.ObjectId.cast(false);\n *\n * @param {Function} caster\n * @return {Function}\n * @function get\n * @static\n * @api public\n */\n\nSchemaObjectId.cast = function cast(caster) {\n  if (arguments.length === 0) {\n    return this._cast;\n  }\n  if (caster === false) {\n    caster = this._defaultCaster;\n  }\n  this._cast = caster;\n\n  return this._cast;\n};\n\n/*!\n * ignore\n */\n\nSchemaObjectId._defaultCaster = v => {\n  if (!(isBsonType(v, 'ObjectId'))) {\n    throw new Error(v + ' is not an instance of ObjectId');\n  }\n  return v;\n};\n\n/**\n * Override the function the required validator uses to check whether a string\n * passes the `required` check.\n *\n * #### Example:\n *\n *     // Allow empty strings to pass `required` check\n *     mongoose.Schema.Types.String.checkRequired(v => v != null);\n *\n *     const M = mongoose.model({ str: { type: String, required: true } });\n *     new M({ str: '' }).validateSync(); // `null`, validation passes!\n *\n * @param {Function} fn\n * @return {Function}\n * @function checkRequired\n * @static\n * @api public\n */\n\nSchemaObjectId.checkRequired = SchemaType.checkRequired;\n\n/**\n * Check if the given value satisfies a required validator.\n *\n * @param {Any} value\n * @param {Document} doc\n * @return {Boolean}\n * @api public\n */\n\nSchemaObjectId.prototype.checkRequired = function checkRequired(value, doc) {\n  if (SchemaType._isRef(this, value, doc, true)) {\n    return !!value;\n  }\n\n  // `require('util').inherits()` does **not** copy static properties, and\n  // plugins like mongoose-float use `inherits()` for pre-ES6.\n  const _checkRequired = typeof this.constructor.checkRequired === 'function' ?\n    this.constructor.checkRequired() :\n    SchemaObjectId.checkRequired();\n\n  return _checkRequired(value);\n};\n\n/**\n * Casts to ObjectId\n *\n * @param {Object} value\n * @param {Object} doc\n * @param {Boolean} init whether this is an initialization cast\n * @api private\n */\n\nSchemaObjectId.prototype.cast = function(value, doc, init) {\n  if (!(isBsonType(value, 'ObjectId')) && SchemaType._isRef(this, value, doc, init)) {\n    // wait! we may need to cast this to a document\n    if ((getConstructorName(value) || '').toLowerCase() === 'objectid') {\n      return new oid(value.toHexString());\n    }\n\n    if (value == null || utils.isNonBuiltinObject(value)) {\n      return this._castRef(value, doc, init);\n    }\n  }\n\n  let castObjectId;\n  if (typeof this._castFunction === 'function') {\n    castObjectId = this._castFunction;\n  } else if (typeof this.constructor.cast === 'function') {\n    castObjectId = this.constructor.cast();\n  } else {\n    castObjectId = SchemaObjectId.cast();\n  }\n\n  try {\n    return castObjectId(value);\n  } catch (error) {\n    throw new CastError('ObjectId', value, this.path, error, this);\n  }\n};\n\n/*!\n * ignore\n */\n\nfunction handleSingle(val) {\n  return this.cast(val);\n}\n\nSchemaObjectId.prototype.$conditionalHandlers = {\n  ...SchemaType.prototype.$conditionalHandlers,\n  $gt: handleSingle,\n  $gte: handleSingle,\n  $lt: handleSingle,\n  $lte: handleSingle\n};\n\n/*!\n * ignore\n */\n\nfunction defaultId() {\n  return new oid();\n}\n\ndefaultId.$runBeforeSetters = true;\n\nfunction resetId(v) {\n  Document || (Document = __webpack_require__(/*! ../document */ \"../server/node_modules/mongoose/lib/document.js\"));\n\n  if (this instanceof Document) {\n    if (v === void 0) {\n      const _v = new oid();\n      return _v;\n    }\n  }\n\n  return v;\n}\n\n/*!\n * Module exports.\n */\n\nmodule.exports = SchemaObjectId;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvc2NoZW1hL29iamVjdElkLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTs7QUFFYTs7QUFFYiw4QkFBOEIsbUJBQU8sQ0FBQyw4R0FBa0M7QUFDeEUsbUJBQW1CLG1CQUFPLENBQUMsd0VBQWU7QUFDMUMscUJBQXFCLG1CQUFPLENBQUMsOEVBQWtCO0FBQy9DLDJCQUEyQixtQkFBTyxDQUFDLHdHQUErQjtBQUNsRSxZQUFZLG1CQUFPLENBQUMsZ0ZBQW1CO0FBQ3ZDLG1CQUFtQixtQkFBTyxDQUFDLHdGQUF1QjtBQUNsRCxjQUFjLG1CQUFPLENBQUMsOERBQVU7O0FBRWhDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RDtBQUN6RCwyQkFBMkIsUUFBUTtBQUNuQztBQUNBLFdBQVcsVUFBVTtBQUNyQixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRCxrQkFBa0I7QUFDNUUsb0JBQW9CLHdDQUF3QztBQUM1RDtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLEtBQUs7QUFDaEIsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEI7QUFDQSxZQUFZLFlBQVk7QUFDeEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsVUFBVTtBQUNyQixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLE9BQU8sZ0NBQWdDO0FBQ3pFLGVBQWUsU0FBUyxrQkFBa0I7QUFDMUM7QUFDQSxXQUFXLFVBQVU7QUFDckIsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLFVBQVU7QUFDckIsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLDBCQUEwQixtQkFBTyxDQUFDLG9FQUFhOztBQUUvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbGllbnQvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvc2NoZW1hL29iamVjdElkLmpzP2Y5ZjEiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuY29uc3QgU2NoZW1hT2JqZWN0SWRPcHRpb25zID0gcmVxdWlyZSgnLi4vb3B0aW9ucy9zY2hlbWFPYmplY3RJZE9wdGlvbnMnKTtcbmNvbnN0IFNjaGVtYVR5cGUgPSByZXF1aXJlKCcuLi9zY2hlbWFUeXBlJyk7XG5jb25zdCBjYXN0T2JqZWN0SWQgPSByZXF1aXJlKCcuLi9jYXN0L29iamVjdGlkJyk7XG5jb25zdCBnZXRDb25zdHJ1Y3Rvck5hbWUgPSByZXF1aXJlKCcuLi9oZWxwZXJzL2dldENvbnN0cnVjdG9yTmFtZScpO1xuY29uc3Qgb2lkID0gcmVxdWlyZSgnLi4vdHlwZXMvb2JqZWN0aWQnKTtcbmNvbnN0IGlzQnNvblR5cGUgPSByZXF1aXJlKCcuLi9oZWxwZXJzL2lzQnNvblR5cGUnKTtcbmNvbnN0IHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMnKTtcblxuY29uc3QgQ2FzdEVycm9yID0gU2NoZW1hVHlwZS5DYXN0RXJyb3I7XG5sZXQgRG9jdW1lbnQ7XG5cbi8qKlxuICogT2JqZWN0SWQgU2NoZW1hVHlwZSBjb25zdHJ1Y3Rvci5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30ga2V5XG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQGluaGVyaXRzIFNjaGVtYVR5cGVcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gU2NoZW1hT2JqZWN0SWQoa2V5LCBvcHRpb25zKSB7XG4gIGNvbnN0IGlzS2V5SGV4U3RyID0gdHlwZW9mIGtleSA9PT0gJ3N0cmluZycgJiYga2V5Lmxlbmd0aCA9PT0gMjQgJiYgL15bYS1mMC05XSskL2kudGVzdChrZXkpO1xuICBjb25zdCBzdXBwcmVzc1dhcm5pbmcgPSBvcHRpb25zICYmIG9wdGlvbnMuc3VwcHJlc3NXYXJuaW5nO1xuICBpZiAoKGlzS2V5SGV4U3RyIHx8IHR5cGVvZiBrZXkgPT09ICd1bmRlZmluZWQnKSAmJiAhc3VwcHJlc3NXYXJuaW5nKSB7XG4gICAgdXRpbHMud2FybignbW9uZ29vc2U6IFRvIGNyZWF0ZSBhIG5ldyBPYmplY3RJZCBwbGVhc2UgdHJ5ICcgK1xuICAgICAgJ2BNb25nb29zZS5UeXBlcy5PYmplY3RJZGAgaW5zdGVhZCBvZiB1c2luZyAnICtcbiAgICAgICdgTW9uZ29vc2UuU2NoZW1hLk9iamVjdElkYC4gU2V0IHRoZSBgc3VwcHJlc3NXYXJuaW5nYCBvcHRpb24gaWYgJyArXG4gICAgICAneW91XFwncmUgdHJ5aW5nIHRvIGNyZWF0ZSBhIGhleCBjaGFyIHBhdGggaW4geW91ciBzY2hlbWEuJyk7XG4gIH1cbiAgU2NoZW1hVHlwZS5jYWxsKHRoaXMsIGtleSwgb3B0aW9ucywgJ09iamVjdElkJyk7XG59XG5cbi8qKlxuICogVGhpcyBzY2hlbWEgdHlwZSdzIG5hbWUsIHRvIGRlZmVuZCBhZ2FpbnN0IG1pbmlmaWVycyB0aGF0IG1hbmdsZVxuICogZnVuY3Rpb24gbmFtZXMuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuU2NoZW1hT2JqZWN0SWQuc2NoZW1hTmFtZSA9ICdPYmplY3RJZCc7XG5cblNjaGVtYU9iamVjdElkLmRlZmF1bHRPcHRpb25zID0ge307XG5cbi8qIVxuICogSW5oZXJpdHMgZnJvbSBTY2hlbWFUeXBlLlxuICovXG5TY2hlbWFPYmplY3RJZC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFNjaGVtYVR5cGUucHJvdG90eXBlKTtcblNjaGVtYU9iamVjdElkLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFNjaGVtYU9iamVjdElkO1xuU2NoZW1hT2JqZWN0SWQucHJvdG90eXBlLk9wdGlvbnNDb25zdHJ1Y3RvciA9IFNjaGVtYU9iamVjdElkT3B0aW9ucztcblxuLyoqXG4gKiBBdHRhY2hlcyBhIGdldHRlciBmb3IgYWxsIE9iamVjdElkIGluc3RhbmNlc1xuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgLy8gQWx3YXlzIGNvbnZlcnQgdG8gc3RyaW5nIHdoZW4gZ2V0dGluZyBhbiBPYmplY3RJZFxuICogICAgIG1vbmdvb3NlLk9iamVjdElkLmdldCh2ID0+IHYudG9TdHJpbmcoKSk7XG4gKlxuICogICAgIGNvbnN0IE1vZGVsID0gbW9uZ29vc2UubW9kZWwoJ1Rlc3QnLCBuZXcgU2NoZW1hKHt9KSk7XG4gKiAgICAgdHlwZW9mIChuZXcgTW9kZWwoe30pLl9pZCk7IC8vICdzdHJpbmcnXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZ2V0dGVyXG4gKiBAcmV0dXJuIHt0aGlzfVxuICogQGZ1bmN0aW9uIGdldFxuICogQHN0YXRpY1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5TY2hlbWFPYmplY3RJZC5nZXQgPSBTY2hlbWFUeXBlLmdldDtcblxuLyoqXG4gKiBTZXRzIGEgZGVmYXVsdCBvcHRpb24gZm9yIGFsbCBPYmplY3RJZCBpbnN0YW5jZXMuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICAvLyBNYWtlIGFsbCBvYmplY3QgaWRzIGhhdmUgb3B0aW9uIGByZXF1aXJlZGAgZXF1YWwgdG8gdHJ1ZS5cbiAqICAgICBtb25nb29zZS5TY2hlbWEuT2JqZWN0SWQuc2V0KCdyZXF1aXJlZCcsIHRydWUpO1xuICpcbiAqICAgICBjb25zdCBPcmRlciA9IG1vbmdvb3NlLm1vZGVsKCdPcmRlcicsIG5ldyBTY2hlbWEoeyB1c2VySWQ6IE9iamVjdElkIH0pKTtcbiAqICAgICBuZXcgT3JkZXIoeyB9KS52YWxpZGF0ZVN5bmMoKS5lcnJvcnMudXNlcklkLm1lc3NhZ2U7IC8vIFBhdGggYHVzZXJJZGAgaXMgcmVxdWlyZWQuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG9wdGlvbiBUaGUgb3B0aW9uIHlvdSdkIGxpa2UgdG8gc2V0IHRoZSB2YWx1ZSBmb3JcbiAqIEBwYXJhbSB7QW55fSB2YWx1ZSB2YWx1ZSBmb3Igb3B0aW9uXG4gKiBAcmV0dXJuIHt1bmRlZmluZWR9XG4gKiBAZnVuY3Rpb24gc2V0XG4gKiBAc3RhdGljXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblNjaGVtYU9iamVjdElkLnNldCA9IFNjaGVtYVR5cGUuc2V0O1xuXG5TY2hlbWFPYmplY3RJZC5zZXR0ZXJzID0gW107XG5cbi8qKlxuICogQWRkcyBhbiBhdXRvLWdlbmVyYXRlZCBPYmplY3RJZCBkZWZhdWx0IGlmIHR1cm5PbiBpcyB0cnVlLlxuICogQHBhcmFtIHtCb29sZWFufSB0dXJuT24gYXV0byBnZW5lcmF0ZWQgT2JqZWN0SWQgZGVmYXVsdHNcbiAqIEBhcGkgcHVibGljXG4gKiBAcmV0dXJuIHtTY2hlbWFUeXBlfSB0aGlzXG4gKi9cblxuU2NoZW1hT2JqZWN0SWQucHJvdG90eXBlLmF1dG8gPSBmdW5jdGlvbih0dXJuT24pIHtcbiAgaWYgKHR1cm5Pbikge1xuICAgIHRoaXMuZGVmYXVsdChkZWZhdWx0SWQpO1xuICAgIHRoaXMuc2V0KHJlc2V0SWQpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cblNjaGVtYU9iamVjdElkLl9jaGVja1JlcXVpcmVkID0gdiA9PiBpc0Jzb25UeXBlKHYsICdPYmplY3RJZCcpO1xuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cblNjaGVtYU9iamVjdElkLl9jYXN0ID0gY2FzdE9iamVjdElkO1xuXG4vKipcbiAqIEdldC9zZXQgdGhlIGZ1bmN0aW9uIHVzZWQgdG8gY2FzdCBhcmJpdHJhcnkgdmFsdWVzIHRvIG9iamVjdGlkcy5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIC8vIE1ha2UgTW9uZ29vc2Ugb25seSB0cnkgdG8gY2FzdCBsZW5ndGggMjQgc3RyaW5ncy4gQnkgZGVmYXVsdCwgYW55IDEyXG4gKiAgICAgLy8gY2hhciBzdHJpbmcgaXMgYSB2YWxpZCBPYmplY3RJZC5cbiAqICAgICBjb25zdCBvcmlnaW5hbCA9IG1vbmdvb3NlLk9iamVjdElkLmNhc3QoKTtcbiAqICAgICBtb25nb29zZS5PYmplY3RJZC5jYXN0KHYgPT4ge1xuICogICAgICAgYXNzZXJ0Lm9rKHR5cGVvZiB2ICE9PSAnc3RyaW5nJyB8fCB2Lmxlbmd0aCA9PT0gMjQpO1xuICogICAgICAgcmV0dXJuIG9yaWdpbmFsKHYpO1xuICogICAgIH0pO1xuICpcbiAqICAgICAvLyBPciBkaXNhYmxlIGNhc3RpbmcgZW50aXJlbHlcbiAqICAgICBtb25nb29zZS5PYmplY3RJZC5jYXN0KGZhbHNlKTtcbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYXN0ZXJcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICogQGZ1bmN0aW9uIGdldFxuICogQHN0YXRpY1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5TY2hlbWFPYmplY3RJZC5jYXN0ID0gZnVuY3Rpb24gY2FzdChjYXN0ZXIpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gdGhpcy5fY2FzdDtcbiAgfVxuICBpZiAoY2FzdGVyID09PSBmYWxzZSkge1xuICAgIGNhc3RlciA9IHRoaXMuX2RlZmF1bHRDYXN0ZXI7XG4gIH1cbiAgdGhpcy5fY2FzdCA9IGNhc3RlcjtcblxuICByZXR1cm4gdGhpcy5fY2FzdDtcbn07XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxuU2NoZW1hT2JqZWN0SWQuX2RlZmF1bHRDYXN0ZXIgPSB2ID0+IHtcbiAgaWYgKCEoaXNCc29uVHlwZSh2LCAnT2JqZWN0SWQnKSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IodiArICcgaXMgbm90IGFuIGluc3RhbmNlIG9mIE9iamVjdElkJyk7XG4gIH1cbiAgcmV0dXJuIHY7XG59O1xuXG4vKipcbiAqIE92ZXJyaWRlIHRoZSBmdW5jdGlvbiB0aGUgcmVxdWlyZWQgdmFsaWRhdG9yIHVzZXMgdG8gY2hlY2sgd2hldGhlciBhIHN0cmluZ1xuICogcGFzc2VzIHRoZSBgcmVxdWlyZWRgIGNoZWNrLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgLy8gQWxsb3cgZW1wdHkgc3RyaW5ncyB0byBwYXNzIGByZXF1aXJlZGAgY2hlY2tcbiAqICAgICBtb25nb29zZS5TY2hlbWEuVHlwZXMuU3RyaW5nLmNoZWNrUmVxdWlyZWQodiA9PiB2ICE9IG51bGwpO1xuICpcbiAqICAgICBjb25zdCBNID0gbW9uZ29vc2UubW9kZWwoeyBzdHI6IHsgdHlwZTogU3RyaW5nLCByZXF1aXJlZDogdHJ1ZSB9IH0pO1xuICogICAgIG5ldyBNKHsgc3RyOiAnJyB9KS52YWxpZGF0ZVN5bmMoKTsgLy8gYG51bGxgLCB2YWxpZGF0aW9uIHBhc3NlcyFcbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICogQHJldHVybiB7RnVuY3Rpb259XG4gKiBAZnVuY3Rpb24gY2hlY2tSZXF1aXJlZFxuICogQHN0YXRpY1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5TY2hlbWFPYmplY3RJZC5jaGVja1JlcXVpcmVkID0gU2NoZW1hVHlwZS5jaGVja1JlcXVpcmVkO1xuXG4vKipcbiAqIENoZWNrIGlmIHRoZSBnaXZlbiB2YWx1ZSBzYXRpc2ZpZXMgYSByZXF1aXJlZCB2YWxpZGF0b3IuXG4gKlxuICogQHBhcmFtIHtBbnl9IHZhbHVlXG4gKiBAcGFyYW0ge0RvY3VtZW50fSBkb2NcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblNjaGVtYU9iamVjdElkLnByb3RvdHlwZS5jaGVja1JlcXVpcmVkID0gZnVuY3Rpb24gY2hlY2tSZXF1aXJlZCh2YWx1ZSwgZG9jKSB7XG4gIGlmIChTY2hlbWFUeXBlLl9pc1JlZih0aGlzLCB2YWx1ZSwgZG9jLCB0cnVlKSkge1xuICAgIHJldHVybiAhIXZhbHVlO1xuICB9XG5cbiAgLy8gYHJlcXVpcmUoJ3V0aWwnKS5pbmhlcml0cygpYCBkb2VzICoqbm90KiogY29weSBzdGF0aWMgcHJvcGVydGllcywgYW5kXG4gIC8vIHBsdWdpbnMgbGlrZSBtb25nb29zZS1mbG9hdCB1c2UgYGluaGVyaXRzKClgIGZvciBwcmUtRVM2LlxuICBjb25zdCBfY2hlY2tSZXF1aXJlZCA9IHR5cGVvZiB0aGlzLmNvbnN0cnVjdG9yLmNoZWNrUmVxdWlyZWQgPT09ICdmdW5jdGlvbicgP1xuICAgIHRoaXMuY29uc3RydWN0b3IuY2hlY2tSZXF1aXJlZCgpIDpcbiAgICBTY2hlbWFPYmplY3RJZC5jaGVja1JlcXVpcmVkKCk7XG5cbiAgcmV0dXJuIF9jaGVja1JlcXVpcmVkKHZhbHVlKTtcbn07XG5cbi8qKlxuICogQ2FzdHMgdG8gT2JqZWN0SWRcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsdWVcbiAqIEBwYXJhbSB7T2JqZWN0fSBkb2NcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gaW5pdCB3aGV0aGVyIHRoaXMgaXMgYW4gaW5pdGlhbGl6YXRpb24gY2FzdFxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU2NoZW1hT2JqZWN0SWQucHJvdG90eXBlLmNhc3QgPSBmdW5jdGlvbih2YWx1ZSwgZG9jLCBpbml0KSB7XG4gIGlmICghKGlzQnNvblR5cGUodmFsdWUsICdPYmplY3RJZCcpKSAmJiBTY2hlbWFUeXBlLl9pc1JlZih0aGlzLCB2YWx1ZSwgZG9jLCBpbml0KSkge1xuICAgIC8vIHdhaXQhIHdlIG1heSBuZWVkIHRvIGNhc3QgdGhpcyB0byBhIGRvY3VtZW50XG4gICAgaWYgKChnZXRDb25zdHJ1Y3Rvck5hbWUodmFsdWUpIHx8ICcnKS50b0xvd2VyQ2FzZSgpID09PSAnb2JqZWN0aWQnKSB7XG4gICAgICByZXR1cm4gbmV3IG9pZCh2YWx1ZS50b0hleFN0cmluZygpKTtcbiAgICB9XG5cbiAgICBpZiAodmFsdWUgPT0gbnVsbCB8fCB1dGlscy5pc05vbkJ1aWx0aW5PYmplY3QodmFsdWUpKSB7XG4gICAgICByZXR1cm4gdGhpcy5fY2FzdFJlZih2YWx1ZSwgZG9jLCBpbml0KTtcbiAgICB9XG4gIH1cblxuICBsZXQgY2FzdE9iamVjdElkO1xuICBpZiAodHlwZW9mIHRoaXMuX2Nhc3RGdW5jdGlvbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNhc3RPYmplY3RJZCA9IHRoaXMuX2Nhc3RGdW5jdGlvbjtcbiAgfSBlbHNlIGlmICh0eXBlb2YgdGhpcy5jb25zdHJ1Y3Rvci5jYXN0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FzdE9iamVjdElkID0gdGhpcy5jb25zdHJ1Y3Rvci5jYXN0KCk7XG4gIH0gZWxzZSB7XG4gICAgY2FzdE9iamVjdElkID0gU2NoZW1hT2JqZWN0SWQuY2FzdCgpO1xuICB9XG5cbiAgdHJ5IHtcbiAgICByZXR1cm4gY2FzdE9iamVjdElkKHZhbHVlKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICB0aHJvdyBuZXcgQ2FzdEVycm9yKCdPYmplY3RJZCcsIHZhbHVlLCB0aGlzLnBhdGgsIGVycm9yLCB0aGlzKTtcbiAgfVxufTtcblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5mdW5jdGlvbiBoYW5kbGVTaW5nbGUodmFsKSB7XG4gIHJldHVybiB0aGlzLmNhc3QodmFsKTtcbn1cblxuU2NoZW1hT2JqZWN0SWQucHJvdG90eXBlLiRjb25kaXRpb25hbEhhbmRsZXJzID0ge1xuICAuLi5TY2hlbWFUeXBlLnByb3RvdHlwZS4kY29uZGl0aW9uYWxIYW5kbGVycyxcbiAgJGd0OiBoYW5kbGVTaW5nbGUsXG4gICRndGU6IGhhbmRsZVNpbmdsZSxcbiAgJGx0OiBoYW5kbGVTaW5nbGUsXG4gICRsdGU6IGhhbmRsZVNpbmdsZVxufTtcblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5mdW5jdGlvbiBkZWZhdWx0SWQoKSB7XG4gIHJldHVybiBuZXcgb2lkKCk7XG59XG5cbmRlZmF1bHRJZC4kcnVuQmVmb3JlU2V0dGVycyA9IHRydWU7XG5cbmZ1bmN0aW9uIHJlc2V0SWQodikge1xuICBEb2N1bWVudCB8fCAoRG9jdW1lbnQgPSByZXF1aXJlKCcuLi9kb2N1bWVudCcpKTtcblxuICBpZiAodGhpcyBpbnN0YW5jZW9mIERvY3VtZW50KSB7XG4gICAgaWYgKHYgPT09IHZvaWQgMCkge1xuICAgICAgY29uc3QgX3YgPSBuZXcgb2lkKCk7XG4gICAgICByZXR1cm4gX3Y7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHY7XG59XG5cbi8qIVxuICogTW9kdWxlIGV4cG9ydHMuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBTY2hlbWFPYmplY3RJZDtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../server/node_modules/mongoose/lib/schema/objectId.js\n");

/***/ }),

/***/ "../server/node_modules/mongoose/lib/schema/operators/bitwise.js":
/*!***********************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/schema/operators/bitwise.js ***!
  \***********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*!\n * Module requirements.\n */\n\n\n\nconst CastError = __webpack_require__(/*! ../../error/cast */ \"../server/node_modules/mongoose/lib/error/cast.js\");\n\n/*!\n * ignore\n */\n\nfunction handleBitwiseOperator(val) {\n  const _this = this;\n  if (Array.isArray(val)) {\n    return val.map(function(v) {\n      return _castNumber(_this.path, v);\n    });\n  } else if (Buffer.isBuffer(val)) {\n    return val;\n  }\n  // Assume trying to cast to number\n  return _castNumber(_this.path, val);\n}\n\n/*!\n * ignore\n */\n\nfunction _castNumber(path, num) {\n  const v = Number(num);\n  if (isNaN(v)) {\n    throw new CastError('number', num, path);\n  }\n  return v;\n}\n\nmodule.exports = handleBitwiseOperator;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvc2NoZW1hL29wZXJhdG9ycy9iaXR3aXNlLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTs7QUFFYTs7QUFFYixrQkFBa0IsbUJBQU8sQ0FBQywyRUFBa0I7O0FBRTVDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL2NsaWVudC8uLi9zZXJ2ZXIvbm9kZV9tb2R1bGVzL21vbmdvb3NlL2xpYi9zY2hlbWEvb3BlcmF0b3JzL2JpdHdpc2UuanM/YjBhNyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIE1vZHVsZSByZXF1aXJlbWVudHMuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBDYXN0RXJyb3IgPSByZXF1aXJlKCcuLi8uLi9lcnJvci9jYXN0Jyk7XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxuZnVuY3Rpb24gaGFuZGxlQml0d2lzZU9wZXJhdG9yKHZhbCkge1xuICBjb25zdCBfdGhpcyA9IHRoaXM7XG4gIGlmIChBcnJheS5pc0FycmF5KHZhbCkpIHtcbiAgICByZXR1cm4gdmFsLm1hcChmdW5jdGlvbih2KSB7XG4gICAgICByZXR1cm4gX2Nhc3ROdW1iZXIoX3RoaXMucGF0aCwgdik7XG4gICAgfSk7XG4gIH0gZWxzZSBpZiAoQnVmZmVyLmlzQnVmZmVyKHZhbCkpIHtcbiAgICByZXR1cm4gdmFsO1xuICB9XG4gIC8vIEFzc3VtZSB0cnlpbmcgdG8gY2FzdCB0byBudW1iZXJcbiAgcmV0dXJuIF9jYXN0TnVtYmVyKF90aGlzLnBhdGgsIHZhbCk7XG59XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxuZnVuY3Rpb24gX2Nhc3ROdW1iZXIocGF0aCwgbnVtKSB7XG4gIGNvbnN0IHYgPSBOdW1iZXIobnVtKTtcbiAgaWYgKGlzTmFOKHYpKSB7XG4gICAgdGhyb3cgbmV3IENhc3RFcnJvcignbnVtYmVyJywgbnVtLCBwYXRoKTtcbiAgfVxuICByZXR1cm4gdjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBoYW5kbGVCaXR3aXNlT3BlcmF0b3I7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../server/node_modules/mongoose/lib/schema/operators/bitwise.js\n");

/***/ }),

/***/ "../server/node_modules/mongoose/lib/schema/operators/exists.js":
/*!**********************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/schema/operators/exists.js ***!
  \**********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst castBoolean = __webpack_require__(/*! ../../cast/boolean */ \"../server/node_modules/mongoose/lib/cast/boolean.js\");\n\n/*!\n * ignore\n */\n\nmodule.exports = function(val) {\n  const path = this != null ? this.path : null;\n  return castBoolean(val, path);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvc2NoZW1hL29wZXJhdG9ycy9leGlzdHMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsb0JBQW9CLG1CQUFPLENBQUMsK0VBQW9COztBQUVoRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbGllbnQvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvc2NoZW1hL29wZXJhdG9ycy9leGlzdHMuanM/NDFiNCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IGNhc3RCb29sZWFuID0gcmVxdWlyZSgnLi4vLi4vY2FzdC9ib29sZWFuJyk7XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbih2YWwpIHtcbiAgY29uc3QgcGF0aCA9IHRoaXMgIT0gbnVsbCA/IHRoaXMucGF0aCA6IG51bGw7XG4gIHJldHVybiBjYXN0Qm9vbGVhbih2YWwsIHBhdGgpO1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../server/node_modules/mongoose/lib/schema/operators/exists.js\n");

/***/ }),

/***/ "../server/node_modules/mongoose/lib/schema/operators/geospatial.js":
/*!**************************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/schema/operators/geospatial.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("/*!\n * Module requirements.\n */\n\n\n\nconst castArraysOfNumbers = (__webpack_require__(/*! ./helpers */ \"../server/node_modules/mongoose/lib/schema/operators/helpers.js\").castArraysOfNumbers);\nconst castToNumber = (__webpack_require__(/*! ./helpers */ \"../server/node_modules/mongoose/lib/schema/operators/helpers.js\").castToNumber);\n\n/*!\n * ignore\n */\n\nexports.cast$geoIntersects = cast$geoIntersects;\nexports.cast$near = cast$near;\nexports.cast$within = cast$within;\n\nfunction cast$near(val) {\n  const SchemaArray = __webpack_require__(/*! ../array */ \"../server/node_modules/mongoose/lib/schema/array.js\");\n\n  if (Array.isArray(val)) {\n    castArraysOfNumbers(val, this);\n    return val;\n  }\n\n  _castMinMaxDistance(this, val);\n\n  if (val && val.$geometry) {\n    return cast$geometry(val, this);\n  }\n\n  if (!Array.isArray(val)) {\n    throw new TypeError('$near must be either an array or an object ' +\n      'with a $geometry property');\n  }\n\n  return SchemaArray.prototype.castForQuery.call(this, null, val);\n}\n\nfunction cast$geometry(val, self) {\n  switch (val.$geometry.type) {\n    case 'Polygon':\n    case 'LineString':\n    case 'Point':\n      castArraysOfNumbers(val.$geometry.coordinates, self);\n      break;\n    default:\n      // ignore unknowns\n      break;\n  }\n\n  _castMinMaxDistance(self, val);\n\n  return val;\n}\n\nfunction cast$within(val) {\n  _castMinMaxDistance(this, val);\n\n  if (val.$box || val.$polygon) {\n    const type = val.$box ? '$box' : '$polygon';\n    val[type].forEach(arr => {\n      if (!Array.isArray(arr)) {\n        const msg = 'Invalid $within $box argument. '\n            + 'Expected an array, received ' + arr;\n        throw new TypeError(msg);\n      }\n      arr.forEach((v, i) => {\n        arr[i] = castToNumber.call(this, v);\n      });\n    });\n  } else if (val.$center || val.$centerSphere) {\n    const type = val.$center ? '$center' : '$centerSphere';\n    val[type].forEach((item, i) => {\n      if (Array.isArray(item)) {\n        item.forEach((v, j) => {\n          item[j] = castToNumber.call(this, v);\n        });\n      } else {\n        val[type][i] = castToNumber.call(this, item);\n      }\n    });\n  } else if (val.$geometry) {\n    cast$geometry(val, this);\n  }\n\n  return val;\n}\n\nfunction cast$geoIntersects(val) {\n  const geo = val.$geometry;\n  if (!geo) {\n    return;\n  }\n\n  cast$geometry(val, this);\n  return val;\n}\n\nfunction _castMinMaxDistance(self, val) {\n  if (val.$maxDistance) {\n    val.$maxDistance = castToNumber.call(self, val.$maxDistance);\n  }\n  if (val.$minDistance) {\n    val.$minDistance = castToNumber.call(self, val.$minDistance);\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvc2NoZW1hL29wZXJhdG9ycy9nZW9zcGF0aWFsLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTs7QUFFYTs7QUFFYiw0QkFBNEIsNkhBQXdDO0FBQ3BFLHFCQUFxQixzSEFBaUM7O0FBRXREO0FBQ0E7QUFDQTs7QUFFQSwwQkFBMEI7QUFDMUIsaUJBQWlCO0FBQ2pCLG1CQUFtQjs7QUFFbkI7QUFDQSxzQkFBc0IsbUJBQU8sQ0FBQyxxRUFBVTs7QUFFeEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2NsaWVudC8uLi9zZXJ2ZXIvbm9kZV9tb2R1bGVzL21vbmdvb3NlL2xpYi9zY2hlbWEvb3BlcmF0b3JzL2dlb3NwYXRpYWwuanM/NWE1MSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIE1vZHVsZSByZXF1aXJlbWVudHMuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBjYXN0QXJyYXlzT2ZOdW1iZXJzID0gcmVxdWlyZSgnLi9oZWxwZXJzJykuY2FzdEFycmF5c09mTnVtYmVycztcbmNvbnN0IGNhc3RUb051bWJlciA9IHJlcXVpcmUoJy4vaGVscGVycycpLmNhc3RUb051bWJlcjtcblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5leHBvcnRzLmNhc3QkZ2VvSW50ZXJzZWN0cyA9IGNhc3QkZ2VvSW50ZXJzZWN0cztcbmV4cG9ydHMuY2FzdCRuZWFyID0gY2FzdCRuZWFyO1xuZXhwb3J0cy5jYXN0JHdpdGhpbiA9IGNhc3Qkd2l0aGluO1xuXG5mdW5jdGlvbiBjYXN0JG5lYXIodmFsKSB7XG4gIGNvbnN0IFNjaGVtYUFycmF5ID0gcmVxdWlyZSgnLi4vYXJyYXknKTtcblxuICBpZiAoQXJyYXkuaXNBcnJheSh2YWwpKSB7XG4gICAgY2FzdEFycmF5c09mTnVtYmVycyh2YWwsIHRoaXMpO1xuICAgIHJldHVybiB2YWw7XG4gIH1cblxuICBfY2FzdE1pbk1heERpc3RhbmNlKHRoaXMsIHZhbCk7XG5cbiAgaWYgKHZhbCAmJiB2YWwuJGdlb21ldHJ5KSB7XG4gICAgcmV0dXJuIGNhc3QkZ2VvbWV0cnkodmFsLCB0aGlzKTtcbiAgfVxuXG4gIGlmICghQXJyYXkuaXNBcnJheSh2YWwpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignJG5lYXIgbXVzdCBiZSBlaXRoZXIgYW4gYXJyYXkgb3IgYW4gb2JqZWN0ICcgK1xuICAgICAgJ3dpdGggYSAkZ2VvbWV0cnkgcHJvcGVydHknKTtcbiAgfVxuXG4gIHJldHVybiBTY2hlbWFBcnJheS5wcm90b3R5cGUuY2FzdEZvclF1ZXJ5LmNhbGwodGhpcywgbnVsbCwgdmFsKTtcbn1cblxuZnVuY3Rpb24gY2FzdCRnZW9tZXRyeSh2YWwsIHNlbGYpIHtcbiAgc3dpdGNoICh2YWwuJGdlb21ldHJ5LnR5cGUpIHtcbiAgICBjYXNlICdQb2x5Z29uJzpcbiAgICBjYXNlICdMaW5lU3RyaW5nJzpcbiAgICBjYXNlICdQb2ludCc6XG4gICAgICBjYXN0QXJyYXlzT2ZOdW1iZXJzKHZhbC4kZ2VvbWV0cnkuY29vcmRpbmF0ZXMsIHNlbGYpO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIC8vIGlnbm9yZSB1bmtub3duc1xuICAgICAgYnJlYWs7XG4gIH1cblxuICBfY2FzdE1pbk1heERpc3RhbmNlKHNlbGYsIHZhbCk7XG5cbiAgcmV0dXJuIHZhbDtcbn1cblxuZnVuY3Rpb24gY2FzdCR3aXRoaW4odmFsKSB7XG4gIF9jYXN0TWluTWF4RGlzdGFuY2UodGhpcywgdmFsKTtcblxuICBpZiAodmFsLiRib3ggfHwgdmFsLiRwb2x5Z29uKSB7XG4gICAgY29uc3QgdHlwZSA9IHZhbC4kYm94ID8gJyRib3gnIDogJyRwb2x5Z29uJztcbiAgICB2YWxbdHlwZV0uZm9yRWFjaChhcnIgPT4ge1xuICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGFycikpIHtcbiAgICAgICAgY29uc3QgbXNnID0gJ0ludmFsaWQgJHdpdGhpbiAkYm94IGFyZ3VtZW50LiAnXG4gICAgICAgICAgICArICdFeHBlY3RlZCBhbiBhcnJheSwgcmVjZWl2ZWQgJyArIGFycjtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihtc2cpO1xuICAgICAgfVxuICAgICAgYXJyLmZvckVhY2goKHYsIGkpID0+IHtcbiAgICAgICAgYXJyW2ldID0gY2FzdFRvTnVtYmVyLmNhbGwodGhpcywgdik7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSBlbHNlIGlmICh2YWwuJGNlbnRlciB8fCB2YWwuJGNlbnRlclNwaGVyZSkge1xuICAgIGNvbnN0IHR5cGUgPSB2YWwuJGNlbnRlciA/ICckY2VudGVyJyA6ICckY2VudGVyU3BoZXJlJztcbiAgICB2YWxbdHlwZV0uZm9yRWFjaCgoaXRlbSwgaSkgPT4ge1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoaXRlbSkpIHtcbiAgICAgICAgaXRlbS5mb3JFYWNoKCh2LCBqKSA9PiB7XG4gICAgICAgICAgaXRlbVtqXSA9IGNhc3RUb051bWJlci5jYWxsKHRoaXMsIHYpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhbFt0eXBlXVtpXSA9IGNhc3RUb051bWJlci5jYWxsKHRoaXMsIGl0ZW0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9IGVsc2UgaWYgKHZhbC4kZ2VvbWV0cnkpIHtcbiAgICBjYXN0JGdlb21ldHJ5KHZhbCwgdGhpcyk7XG4gIH1cblxuICByZXR1cm4gdmFsO1xufVxuXG5mdW5jdGlvbiBjYXN0JGdlb0ludGVyc2VjdHModmFsKSB7XG4gIGNvbnN0IGdlbyA9IHZhbC4kZ2VvbWV0cnk7XG4gIGlmICghZ2VvKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY2FzdCRnZW9tZXRyeSh2YWwsIHRoaXMpO1xuICByZXR1cm4gdmFsO1xufVxuXG5mdW5jdGlvbiBfY2FzdE1pbk1heERpc3RhbmNlKHNlbGYsIHZhbCkge1xuICBpZiAodmFsLiRtYXhEaXN0YW5jZSkge1xuICAgIHZhbC4kbWF4RGlzdGFuY2UgPSBjYXN0VG9OdW1iZXIuY2FsbChzZWxmLCB2YWwuJG1heERpc3RhbmNlKTtcbiAgfVxuICBpZiAodmFsLiRtaW5EaXN0YW5jZSkge1xuICAgIHZhbC4kbWluRGlzdGFuY2UgPSBjYXN0VG9OdW1iZXIuY2FsbChzZWxmLCB2YWwuJG1pbkRpc3RhbmNlKTtcbiAgfVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../server/node_modules/mongoose/lib/schema/operators/geospatial.js\n");

/***/ }),

/***/ "../server/node_modules/mongoose/lib/schema/operators/helpers.js":
/*!***********************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/schema/operators/helpers.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\n/*!\n * Module requirements.\n */\n\nconst SchemaNumber = __webpack_require__(/*! ../number */ \"../server/node_modules/mongoose/lib/schema/number.js\");\n\n/*!\n * ignore\n */\n\nexports.castToNumber = castToNumber;\nexports.castArraysOfNumbers = castArraysOfNumbers;\n\n/*!\n * ignore\n */\n\nfunction castToNumber(val) {\n  return SchemaNumber.cast()(val);\n}\n\nfunction castArraysOfNumbers(arr, self) {\n  arr.forEach(function(v, i) {\n    if (Array.isArray(v)) {\n      castArraysOfNumbers(v, self);\n    } else {\n      arr[i] = castToNumber.call(self, v);\n    }\n  });\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvc2NoZW1hL29wZXJhdG9ycy9oZWxwZXJzLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0E7QUFDQTs7QUFFQSxxQkFBcUIsbUJBQU8sQ0FBQyx1RUFBVzs7QUFFeEM7QUFDQTtBQUNBOztBQUVBLG9CQUFvQjtBQUNwQiwyQkFBMkI7O0FBRTNCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEdBQUc7QUFDSCIsInNvdXJjZXMiOlsid2VicGFjazovL2NsaWVudC8uLi9zZXJ2ZXIvbm9kZV9tb2R1bGVzL21vbmdvb3NlL2xpYi9zY2hlbWEvb3BlcmF0b3JzL2hlbHBlcnMuanM/MTU4YiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbi8qIVxuICogTW9kdWxlIHJlcXVpcmVtZW50cy5cbiAqL1xuXG5jb25zdCBTY2hlbWFOdW1iZXIgPSByZXF1aXJlKCcuLi9udW1iZXInKTtcblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5leHBvcnRzLmNhc3RUb051bWJlciA9IGNhc3RUb051bWJlcjtcbmV4cG9ydHMuY2FzdEFycmF5c09mTnVtYmVycyA9IGNhc3RBcnJheXNPZk51bWJlcnM7XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxuZnVuY3Rpb24gY2FzdFRvTnVtYmVyKHZhbCkge1xuICByZXR1cm4gU2NoZW1hTnVtYmVyLmNhc3QoKSh2YWwpO1xufVxuXG5mdW5jdGlvbiBjYXN0QXJyYXlzT2ZOdW1iZXJzKGFyciwgc2VsZikge1xuICBhcnIuZm9yRWFjaChmdW5jdGlvbih2LCBpKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodikpIHtcbiAgICAgIGNhc3RBcnJheXNPZk51bWJlcnModiwgc2VsZik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFycltpXSA9IGNhc3RUb051bWJlci5jYWxsKHNlbGYsIHYpO1xuICAgIH1cbiAgfSk7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../server/node_modules/mongoose/lib/schema/operators/helpers.js\n");

/***/ }),

/***/ "../server/node_modules/mongoose/lib/schema/operators/text.js":
/*!********************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/schema/operators/text.js ***!
  \********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst CastError = __webpack_require__(/*! ../../error/cast */ \"../server/node_modules/mongoose/lib/error/cast.js\");\nconst castBoolean = __webpack_require__(/*! ../../cast/boolean */ \"../server/node_modules/mongoose/lib/cast/boolean.js\");\nconst castString = __webpack_require__(/*! ../../cast/string */ \"../server/node_modules/mongoose/lib/cast/string.js\");\n\n/**\n * Casts val to an object suitable for `$text`. Throws an error if the object\n * can't be casted.\n *\n * @param {Any} val value to cast\n * @param {String} [path] path to associate with any errors that occured\n * @return {Object} casted object\n * @see https://www.mongodb.com/docs/manual/reference/operator/query/text/\n * @api private\n */\n\nmodule.exports = function(val, path) {\n  if (val == null || typeof val !== 'object') {\n    throw new CastError('$text', val, path);\n  }\n\n  if (val.$search != null) {\n    val.$search = castString(val.$search, path + '.$search');\n  }\n  if (val.$language != null) {\n    val.$language = castString(val.$language, path + '.$language');\n  }\n  if (val.$caseSensitive != null) {\n    val.$caseSensitive = castBoolean(val.$caseSensitive,\n      path + '.$castSensitive');\n  }\n  if (val.$diacriticSensitive != null) {\n    val.$diacriticSensitive = castBoolean(val.$diacriticSensitive,\n      path + '.$diacriticSensitive');\n  }\n\n  return val;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvc2NoZW1hL29wZXJhdG9ycy90ZXh0LmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLGtCQUFrQixtQkFBTyxDQUFDLDJFQUFrQjtBQUM1QyxvQkFBb0IsbUJBQU8sQ0FBQywrRUFBb0I7QUFDaEQsbUJBQW1CLG1CQUFPLENBQUMsNkVBQW1COztBQUU5QztBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLFFBQVE7QUFDbkIsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbGllbnQvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvc2NoZW1hL29wZXJhdG9ycy90ZXh0LmpzPzUxYjciXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBDYXN0RXJyb3IgPSByZXF1aXJlKCcuLi8uLi9lcnJvci9jYXN0Jyk7XG5jb25zdCBjYXN0Qm9vbGVhbiA9IHJlcXVpcmUoJy4uLy4uL2Nhc3QvYm9vbGVhbicpO1xuY29uc3QgY2FzdFN0cmluZyA9IHJlcXVpcmUoJy4uLy4uL2Nhc3Qvc3RyaW5nJyk7XG5cbi8qKlxuICogQ2FzdHMgdmFsIHRvIGFuIG9iamVjdCBzdWl0YWJsZSBmb3IgYCR0ZXh0YC4gVGhyb3dzIGFuIGVycm9yIGlmIHRoZSBvYmplY3RcbiAqIGNhbid0IGJlIGNhc3RlZC5cbiAqXG4gKiBAcGFyYW0ge0FueX0gdmFsIHZhbHVlIHRvIGNhc3RcbiAqIEBwYXJhbSB7U3RyaW5nfSBbcGF0aF0gcGF0aCB0byBhc3NvY2lhdGUgd2l0aCBhbnkgZXJyb3JzIHRoYXQgb2NjdXJlZFxuICogQHJldHVybiB7T2JqZWN0fSBjYXN0ZWQgb2JqZWN0XG4gKiBAc2VlIGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvbWFudWFsL3JlZmVyZW5jZS9vcGVyYXRvci9xdWVyeS90ZXh0L1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbih2YWwsIHBhdGgpIHtcbiAgaWYgKHZhbCA9PSBudWxsIHx8IHR5cGVvZiB2YWwgIT09ICdvYmplY3QnKSB7XG4gICAgdGhyb3cgbmV3IENhc3RFcnJvcignJHRleHQnLCB2YWwsIHBhdGgpO1xuICB9XG5cbiAgaWYgKHZhbC4kc2VhcmNoICE9IG51bGwpIHtcbiAgICB2YWwuJHNlYXJjaCA9IGNhc3RTdHJpbmcodmFsLiRzZWFyY2gsIHBhdGggKyAnLiRzZWFyY2gnKTtcbiAgfVxuICBpZiAodmFsLiRsYW5ndWFnZSAhPSBudWxsKSB7XG4gICAgdmFsLiRsYW5ndWFnZSA9IGNhc3RTdHJpbmcodmFsLiRsYW5ndWFnZSwgcGF0aCArICcuJGxhbmd1YWdlJyk7XG4gIH1cbiAgaWYgKHZhbC4kY2FzZVNlbnNpdGl2ZSAhPSBudWxsKSB7XG4gICAgdmFsLiRjYXNlU2Vuc2l0aXZlID0gY2FzdEJvb2xlYW4odmFsLiRjYXNlU2Vuc2l0aXZlLFxuICAgICAgcGF0aCArICcuJGNhc3RTZW5zaXRpdmUnKTtcbiAgfVxuICBpZiAodmFsLiRkaWFjcml0aWNTZW5zaXRpdmUgIT0gbnVsbCkge1xuICAgIHZhbC4kZGlhY3JpdGljU2Vuc2l0aXZlID0gY2FzdEJvb2xlYW4odmFsLiRkaWFjcml0aWNTZW5zaXRpdmUsXG4gICAgICBwYXRoICsgJy4kZGlhY3JpdGljU2Vuc2l0aXZlJyk7XG4gIH1cblxuICByZXR1cm4gdmFsO1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../server/node_modules/mongoose/lib/schema/operators/text.js\n");

/***/ }),

/***/ "../server/node_modules/mongoose/lib/schema/operators/type.js":
/*!********************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/schema/operators/type.js ***!
  \********************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/*!\n * ignore\n */\n\nmodule.exports = function(val) {\n  if (Array.isArray(val)) {\n    if (!val.every(v => typeof v === 'number' || typeof v === 'string')) {\n      throw new Error('$type array values must be strings or numbers');\n    }\n    return val;\n  }\n\n  if (typeof val !== 'number' && typeof val !== 'string') {\n    throw new Error('$type parameter must be number, string, or array of numbers and strings');\n  }\n\n  return val;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvc2NoZW1hL29wZXJhdG9ycy90eXBlLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2NsaWVudC8uLi9zZXJ2ZXIvbm9kZV9tb2R1bGVzL21vbmdvb3NlL2xpYi9zY2hlbWEvb3BlcmF0b3JzL3R5cGUuanM/N2U3YiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbih2YWwpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsKSkge1xuICAgIGlmICghdmFsLmV2ZXJ5KHYgPT4gdHlwZW9mIHYgPT09ICdudW1iZXInIHx8IHR5cGVvZiB2ID09PSAnc3RyaW5nJykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignJHR5cGUgYXJyYXkgdmFsdWVzIG11c3QgYmUgc3RyaW5ncyBvciBudW1iZXJzJyk7XG4gICAgfVxuICAgIHJldHVybiB2YWw7XG4gIH1cblxuICBpZiAodHlwZW9mIHZhbCAhPT0gJ251bWJlcicgJiYgdHlwZW9mIHZhbCAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJyR0eXBlIHBhcmFtZXRlciBtdXN0IGJlIG51bWJlciwgc3RyaW5nLCBvciBhcnJheSBvZiBudW1iZXJzIGFuZCBzdHJpbmdzJyk7XG4gIH1cblxuICByZXR1cm4gdmFsO1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../server/node_modules/mongoose/lib/schema/operators/type.js\n");

/***/ }),

/***/ "../server/node_modules/mongoose/lib/schema/string.js":
/*!************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/schema/string.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\n/*!\n * Module dependencies.\n */\n\nconst SchemaType = __webpack_require__(/*! ../schemaType */ \"../server/node_modules/mongoose/lib/schemaType.js\");\nconst MongooseError = __webpack_require__(/*! ../error/index */ \"../server/node_modules/mongoose/lib/error/index.js\");\nconst SchemaStringOptions = __webpack_require__(/*! ../options/schemaStringOptions */ \"../server/node_modules/mongoose/lib/options/schemaStringOptions.js\");\nconst castString = __webpack_require__(/*! ../cast/string */ \"../server/node_modules/mongoose/lib/cast/string.js\");\nconst utils = __webpack_require__(/*! ../utils */ \"../server/node_modules/mongoose/lib/utils.js\");\nconst isBsonType = __webpack_require__(/*! ../helpers/isBsonType */ \"../server/node_modules/mongoose/lib/helpers/isBsonType.js\");\n\nconst CastError = SchemaType.CastError;\n\n/**\n * String SchemaType constructor.\n *\n * @param {String} key\n * @param {Object} options\n * @inherits SchemaType\n * @api public\n */\n\nfunction SchemaString(key, options) {\n  this.enumValues = [];\n  this.regExp = null;\n  SchemaType.call(this, key, options, 'String');\n}\n\n/**\n * This schema type's name, to defend against minifiers that mangle\n * function names.\n *\n * @api public\n */\nSchemaString.schemaName = 'String';\n\nSchemaString.defaultOptions = {};\n\n/*!\n * Inherits from SchemaType.\n */\nSchemaString.prototype = Object.create(SchemaType.prototype);\nSchemaString.prototype.constructor = SchemaString;\nObject.defineProperty(SchemaString.prototype, 'OptionsConstructor', {\n  configurable: false,\n  enumerable: false,\n  writable: false,\n  value: SchemaStringOptions\n});\n\n/*!\n * ignore\n */\n\nSchemaString._cast = castString;\n\n/**\n * Get/set the function used to cast arbitrary values to strings.\n *\n * #### Example:\n *\n *     // Throw an error if you pass in an object. Normally, Mongoose allows\n *     // objects with custom `toString()` functions.\n *     const original = mongoose.Schema.Types.String.cast();\n *     mongoose.Schema.Types.String.cast(v => {\n *       assert.ok(v == null || typeof v !== 'object');\n *       return original(v);\n *     });\n *\n *     // Or disable casting entirely\n *     mongoose.Schema.Types.String.cast(false);\n *\n * @param {Function} caster\n * @return {Function}\n * @function get\n * @static\n * @api public\n */\n\nSchemaString.cast = function cast(caster) {\n  if (arguments.length === 0) {\n    return this._cast;\n  }\n  if (caster === false) {\n    caster = this._defaultCaster;\n  }\n  this._cast = caster;\n\n  return this._cast;\n};\n\n/*!\n * ignore\n */\n\nSchemaString._defaultCaster = v => {\n  if (v != null && typeof v !== 'string') {\n    throw new Error();\n  }\n  return v;\n};\n\n/**\n * Attaches a getter for all String instances.\n *\n * #### Example:\n *\n *     // Make all numbers round down\n *     mongoose.Schema.String.get(v => v.toLowerCase());\n *\n *     const Model = mongoose.model('Test', new Schema({ test: String }));\n *     new Model({ test: 'FOO' }).test; // 'foo'\n *\n * @param {Function} getter\n * @return {this}\n * @function get\n * @static\n * @api public\n */\n\nSchemaString.get = SchemaType.get;\n\n/**\n * Sets a default option for all String instances.\n *\n * #### Example:\n *\n *     // Make all strings have option `trim` equal to true.\n *     mongoose.Schema.String.set('trim', true);\n *\n *     const User = mongoose.model('User', new Schema({ name: String }));\n *     new User({ name: '   John Doe   ' }).name; // 'John Doe'\n *\n * @param {String} option The option you'd like to set the value for\n * @param {Any} value value for option\n * @return {undefined}\n * @function set\n * @static\n * @api public\n */\n\nSchemaString.set = SchemaType.set;\n\nSchemaString.setters = [];\n\n/*!\n * ignore\n */\n\nSchemaString._checkRequired = v => (v instanceof String || typeof v === 'string') && v.length;\n\n/**\n * Override the function the required validator uses to check whether a string\n * passes the `required` check.\n *\n * #### Example:\n *\n *     // Allow empty strings to pass `required` check\n *     mongoose.Schema.Types.String.checkRequired(v => v != null);\n *\n *     const M = mongoose.model({ str: { type: String, required: true } });\n *     new M({ str: '' }).validateSync(); // `null`, validation passes!\n *\n * @param {Function} fn\n * @return {Function}\n * @function checkRequired\n * @static\n * @api public\n */\n\nSchemaString.checkRequired = SchemaType.checkRequired;\n\n/**\n * Adds an enum validator\n *\n * #### Example:\n *\n *     const states = ['opening', 'open', 'closing', 'closed']\n *     const s = new Schema({ state: { type: String, enum: states }})\n *     const M = db.model('M', s)\n *     const m = new M({ state: 'invalid' })\n *     m.save(function (err) {\n *       console.error(String(err)) // ValidationError: `invalid` is not a valid enum value for path `state`.\n *       m.state = 'open'\n *       m.save(callback) // success\n *     })\n *\n *     // or with custom error messages\n *     const enum = {\n *       values: ['opening', 'open', 'closing', 'closed'],\n *       message: 'enum validator failed for path `{PATH}` with value `{VALUE}`'\n *     }\n *     const s = new Schema({ state: { type: String, enum: enum })\n *     const M = db.model('M', s)\n *     const m = new M({ state: 'invalid' })\n *     m.save(function (err) {\n *       console.error(String(err)) // ValidationError: enum validator failed for path `state` with value `invalid`\n *       m.state = 'open'\n *       m.save(callback) // success\n *     })\n *\n * @param {...String|Object} [args] enumeration values\n * @return {SchemaType} this\n * @see Customized Error Messages https://mongoosejs.com/docs/api/error.html#Error.messages\n * @see Enums in JavaScript https://masteringjs.io/tutorials/fundamentals/enum\n * @api public\n */\n\nSchemaString.prototype.enum = function() {\n  if (this.enumValidator) {\n    this.validators = this.validators.filter(function(v) {\n      return v.validator !== this.enumValidator;\n    }, this);\n    this.enumValidator = false;\n  }\n\n  if (arguments[0] === void 0 || arguments[0] === false) {\n    return this;\n  }\n\n  let values;\n  let errorMessage;\n\n  if (utils.isObject(arguments[0])) {\n    if (Array.isArray(arguments[0].values)) {\n      values = arguments[0].values;\n      errorMessage = arguments[0].message;\n    } else {\n      values = utils.object.vals(arguments[0]);\n      errorMessage = MongooseError.messages.String.enum;\n    }\n  } else {\n    values = arguments;\n    errorMessage = MongooseError.messages.String.enum;\n  }\n\n  for (const value of values) {\n    if (value !== undefined) {\n      this.enumValues.push(this.cast(value));\n    }\n  }\n\n  const vals = this.enumValues;\n  this.enumValidator = function(v) {\n    return null == v || ~vals.indexOf(v);\n  };\n  this.validators.push({\n    validator: this.enumValidator,\n    message: errorMessage,\n    type: 'enum',\n    enumValues: vals\n  });\n\n  return this;\n};\n\n/**\n * Adds a lowercase [setter](https://mongoosejs.com/docs/api/schematype.html#SchemaType.prototype.set()).\n *\n * #### Example:\n *\n *     const s = new Schema({ email: { type: String, lowercase: true }})\n *     const M = db.model('M', s);\n *     const m = new M({ email: 'SomeEmail@example.COM' });\n *     console.log(m.email) // someemail@example.com\n *     M.find({ email: 'SomeEmail@example.com' }); // Queries by 'someemail@example.com'\n *\n * Note that `lowercase` does **not** affect regular expression queries:\n *\n * #### Example:\n *\n *     // Still queries for documents whose `email` matches the regular\n *     // expression /SomeEmail/. Mongoose does **not** convert the RegExp\n *     // to lowercase.\n *     M.find({ email: /SomeEmail/ });\n *\n * @api public\n * @return {SchemaType} this\n */\n\nSchemaString.prototype.lowercase = function(shouldApply) {\n  if (arguments.length > 0 && !shouldApply) {\n    return this;\n  }\n  return this.set(v => {\n    if (typeof v !== 'string') {\n      v = this.cast(v);\n    }\n    if (v) {\n      return v.toLowerCase();\n    }\n    return v;\n  });\n};\n\n/**\n * Adds an uppercase [setter](https://mongoosejs.com/docs/api/schematype.html#SchemaType.prototype.set()).\n *\n * #### Example:\n *\n *     const s = new Schema({ caps: { type: String, uppercase: true }})\n *     const M = db.model('M', s);\n *     const m = new M({ caps: 'an example' });\n *     console.log(m.caps) // AN EXAMPLE\n *     M.find({ caps: 'an example' }) // Matches documents where caps = 'AN EXAMPLE'\n *\n * Note that `uppercase` does **not** affect regular expression queries:\n *\n * #### Example:\n *\n *     // Mongoose does **not** convert the RegExp to uppercase.\n *     M.find({ email: /an example/ });\n *\n * @api public\n * @return {SchemaType} this\n */\n\nSchemaString.prototype.uppercase = function(shouldApply) {\n  if (arguments.length > 0 && !shouldApply) {\n    return this;\n  }\n  return this.set(v => {\n    if (typeof v !== 'string') {\n      v = this.cast(v);\n    }\n    if (v) {\n      return v.toUpperCase();\n    }\n    return v;\n  });\n};\n\n/**\n * Adds a trim [setter](https://mongoosejs.com/docs/api/schematype.html#SchemaType.prototype.set()).\n *\n * The string value will be [trimmed](https://masteringjs.io/tutorials/fundamentals/trim-string) when set.\n *\n * #### Example:\n *\n *     const s = new Schema({ name: { type: String, trim: true }});\n *     const M = db.model('M', s);\n *     const string = ' some name ';\n *     console.log(string.length); // 11\n *     const m = new M({ name: string });\n *     console.log(m.name.length); // 9\n *\n *     // Equivalent to `findOne({ name: string.trim() })`\n *     M.findOne({ name: string });\n *\n * Note that `trim` does **not** affect regular expression queries:\n *\n * #### Example:\n *\n *     // Mongoose does **not** trim whitespace from the RegExp.\n *     M.find({ name: / some name / });\n *\n * @api public\n * @return {SchemaType} this\n */\n\nSchemaString.prototype.trim = function(shouldTrim) {\n  if (arguments.length > 0 && !shouldTrim) {\n    return this;\n  }\n  return this.set(v => {\n    if (typeof v !== 'string') {\n      v = this.cast(v);\n    }\n    if (v) {\n      return v.trim();\n    }\n    return v;\n  });\n};\n\n/**\n * Sets a minimum length validator.\n *\n * #### Example:\n *\n *     const schema = new Schema({ postalCode: { type: String, minlength: 5 })\n *     const Address = db.model('Address', schema)\n *     const address = new Address({ postalCode: '9512' })\n *     address.save(function (err) {\n *       console.error(err) // validator error\n *       address.postalCode = '95125';\n *       address.save() // success\n *     })\n *\n *     // custom error messages\n *     // We can also use the special {MINLENGTH} token which will be replaced with the minimum allowed length\n *     const minlength = [5, 'The value of path `{PATH}` (`{VALUE}`) is shorter than the minimum allowed length ({MINLENGTH}).'];\n *     const schema = new Schema({ postalCode: { type: String, minlength: minlength })\n *     const Address = mongoose.model('Address', schema);\n *     const address = new Address({ postalCode: '9512' });\n *     address.validate(function (err) {\n *       console.log(String(err)) // ValidationError: The value of path `postalCode` (`9512`) is shorter than the minimum length (5).\n *     })\n *\n * @param {Number} value minimum string length\n * @param {String} [message] optional custom error message\n * @return {SchemaType} this\n * @see Customized Error Messages https://mongoosejs.com/docs/api/error.html#Error.messages\n * @api public\n */\n\nSchemaString.prototype.minlength = function(value, message) {\n  if (this.minlengthValidator) {\n    this.validators = this.validators.filter(function(v) {\n      return v.validator !== this.minlengthValidator;\n    }, this);\n  }\n\n  if (value !== null && value !== undefined) {\n    let msg = message || MongooseError.messages.String.minlength;\n    msg = msg.replace(/{MINLENGTH}/, value);\n    this.validators.push({\n      validator: this.minlengthValidator = function(v) {\n        return v === null || v.length >= value;\n      },\n      message: msg,\n      type: 'minlength',\n      minlength: value\n    });\n  }\n\n  return this;\n};\n\nSchemaString.prototype.minLength = SchemaString.prototype.minlength;\n\n/**\n * Sets a maximum length validator.\n *\n * #### Example:\n *\n *     const schema = new Schema({ postalCode: { type: String, maxlength: 9 })\n *     const Address = db.model('Address', schema)\n *     const address = new Address({ postalCode: '9512512345' })\n *     address.save(function (err) {\n *       console.error(err) // validator error\n *       address.postalCode = '95125';\n *       address.save() // success\n *     })\n *\n *     // custom error messages\n *     // We can also use the special {MAXLENGTH} token which will be replaced with the maximum allowed length\n *     const maxlength = [9, 'The value of path `{PATH}` (`{VALUE}`) exceeds the maximum allowed length ({MAXLENGTH}).'];\n *     const schema = new Schema({ postalCode: { type: String, maxlength: maxlength })\n *     const Address = mongoose.model('Address', schema);\n *     const address = new Address({ postalCode: '9512512345' });\n *     address.validate(function (err) {\n *       console.log(String(err)) // ValidationError: The value of path `postalCode` (`9512512345`) exceeds the maximum allowed length (9).\n *     })\n *\n * @param {Number} value maximum string length\n * @param {String} [message] optional custom error message\n * @return {SchemaType} this\n * @see Customized Error Messages https://mongoosejs.com/docs/api/error.html#Error.messages\n * @api public\n */\n\nSchemaString.prototype.maxlength = function(value, message) {\n  if (this.maxlengthValidator) {\n    this.validators = this.validators.filter(function(v) {\n      return v.validator !== this.maxlengthValidator;\n    }, this);\n  }\n\n  if (value !== null && value !== undefined) {\n    let msg = message || MongooseError.messages.String.maxlength;\n    msg = msg.replace(/{MAXLENGTH}/, value);\n    this.validators.push({\n      validator: this.maxlengthValidator = function(v) {\n        return v === null || v.length <= value;\n      },\n      message: msg,\n      type: 'maxlength',\n      maxlength: value\n    });\n  }\n\n  return this;\n};\n\nSchemaString.prototype.maxLength = SchemaString.prototype.maxlength;\n\n/**\n * Sets a regexp validator.\n *\n * Any value that does not pass `regExp`.test(val) will fail validation.\n *\n * #### Example:\n *\n *     const s = new Schema({ name: { type: String, match: /^a/ }})\n *     const M = db.model('M', s)\n *     const m = new M({ name: 'I am invalid' })\n *     m.validate(function (err) {\n *       console.error(String(err)) // \"ValidationError: Path `name` is invalid (I am invalid).\"\n *       m.name = 'apples'\n *       m.validate(function (err) {\n *         assert.ok(err) // success\n *       })\n *     })\n *\n *     // using a custom error message\n *     const match = [ /\\.html$/, \"That file doesn't end in .html ({VALUE})\" ];\n *     const s = new Schema({ file: { type: String, match: match }})\n *     const M = db.model('M', s);\n *     const m = new M({ file: 'invalid' });\n *     m.validate(function (err) {\n *       console.log(String(err)) // \"ValidationError: That file doesn't end in .html (invalid)\"\n *     })\n *\n * Empty strings, `undefined`, and `null` values always pass the match validator. If you require these values, enable the `required` validator also.\n *\n *     const s = new Schema({ name: { type: String, match: /^a/, required: true }})\n *\n * @param {RegExp} regExp regular expression to test against\n * @param {String} [message] optional custom error message\n * @return {SchemaType} this\n * @see Customized Error Messages https://mongoosejs.com/docs/api/error.html#Error.messages\n * @api public\n */\n\nSchemaString.prototype.match = function match(regExp, message) {\n  // yes, we allow multiple match validators\n\n  const msg = message || MongooseError.messages.String.match;\n\n  const matchValidator = function(v) {\n    if (!regExp) {\n      return false;\n    }\n\n    // In case RegExp happens to have `/g` flag set, we need to reset the\n    // `lastIndex`, otherwise `match` will intermittently fail.\n    regExp.lastIndex = 0;\n\n    const ret = ((v != null && v !== '')\n      ? regExp.test(v)\n      : true);\n    return ret;\n  };\n\n  this.validators.push({\n    validator: matchValidator,\n    message: msg,\n    type: 'regexp',\n    regexp: regExp\n  });\n  return this;\n};\n\n/**\n * Check if the given value satisfies the `required` validator. The value is\n * considered valid if it is a string (that is, not `null` or `undefined`) and\n * has positive length. The `required` validator **will** fail for empty\n * strings.\n *\n * @param {Any} value\n * @param {Document} doc\n * @return {Boolean}\n * @api public\n */\n\nSchemaString.prototype.checkRequired = function checkRequired(value, doc) {\n  if (typeof value === 'object' && SchemaType._isRef(this, value, doc, true)) {\n    return value != null;\n  }\n\n  // `require('util').inherits()` does **not** copy static properties, and\n  // plugins like mongoose-float use `inherits()` for pre-ES6.\n  const _checkRequired = typeof this.constructor.checkRequired === 'function' ?\n    this.constructor.checkRequired() :\n    SchemaString.checkRequired();\n\n  return _checkRequired(value);\n};\n\n/**\n * Casts to String\n *\n * @api private\n */\n\nSchemaString.prototype.cast = function(value, doc, init) {\n  if (typeof value !== 'string' && SchemaType._isRef(this, value, doc, init)) {\n    return this._castRef(value, doc, init);\n  }\n\n  let castString;\n  if (typeof this._castFunction === 'function') {\n    castString = this._castFunction;\n  } else if (typeof this.constructor.cast === 'function') {\n    castString = this.constructor.cast();\n  } else {\n    castString = SchemaString.cast();\n  }\n\n  try {\n    return castString(value);\n  } catch (error) {\n    throw new CastError('string', value, this.path, null, this);\n  }\n};\n\n/*!\n * ignore\n */\n\nfunction handleSingle(val, context) {\n  return this.castForQuery(null, val, context);\n}\n\n/*!\n * ignore\n */\n\nfunction handleArray(val, context) {\n  const _this = this;\n  if (!Array.isArray(val)) {\n    return [this.castForQuery(null, val, context)];\n  }\n  return val.map(function(m) {\n    return _this.castForQuery(null, m, context);\n  });\n}\n\n/*!\n * ignore\n */\n\nfunction handleSingleNoSetters(val) {\n  if (val == null) {\n    return this._castNullish(val);\n  }\n\n  return this.cast(val, this);\n}\n\nconst $conditionalHandlers = {\n  ...SchemaType.prototype.$conditionalHandlers,\n  $all: handleArray,\n  $gt: handleSingle,\n  $gte: handleSingle,\n  $lt: handleSingle,\n  $lte: handleSingle,\n  $options: handleSingleNoSetters,\n  $regex: function handle$regex(val) {\n    if (Object.prototype.toString.call(val) === '[object RegExp]') {\n      return val;\n    }\n\n    return handleSingleNoSetters.call(this, val);\n  },\n  $not: handleSingle\n};\n\nObject.defineProperty(SchemaString.prototype, '$conditionalHandlers', {\n  configurable: false,\n  enumerable: false,\n  writable: false,\n  value: Object.freeze($conditionalHandlers)\n});\n\n/**\n * Casts contents for queries.\n *\n * @param {String} $conditional\n * @param {any} [val]\n * @api private\n */\n\nSchemaString.prototype.castForQuery = function($conditional, val, context) {\n  let handler;\n  if ($conditional != null) {\n    handler = this.$conditionalHandlers[$conditional];\n    if (!handler) {\n      throw new Error('Can\\'t use ' + $conditional + ' with String.');\n    }\n    return handler.call(this, val, context);\n  }\n\n  if (Object.prototype.toString.call(val) === '[object RegExp]' || isBsonType(val, 'BSONRegExp')) {\n    return val;\n  }\n\n  try {\n    return this.applySetters(val, context);\n  } catch (err) {\n    if (err instanceof CastError && err.path === this.path && this.$fullPath != null) {\n      err.path = this.$fullPath;\n    }\n    throw err;\n  }\n};\n\n/*!\n * Module exports.\n */\n\nmodule.exports = SchemaString;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvc2NoZW1hL3N0cmluZy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CLG1CQUFPLENBQUMsd0VBQWU7QUFDMUMsc0JBQXNCLG1CQUFPLENBQUMsMEVBQWdCO0FBQzlDLDRCQUE0QixtQkFBTyxDQUFDLDBHQUFnQztBQUNwRSxtQkFBbUIsbUJBQU8sQ0FBQywwRUFBZ0I7QUFDM0MsY0FBYyxtQkFBTyxDQUFDLDhEQUFVO0FBQ2hDLG1CQUFtQixtQkFBTyxDQUFDLHdGQUF1Qjs7QUFFbEQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFVBQVU7QUFDckIsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsY0FBYztBQUN2RSxtQkFBbUIsYUFBYSxRQUFRO0FBQ3hDO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFD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QUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLEtBQUs7QUFDaEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL2NsaWVudC8uLi9zZXJ2ZXIvbm9kZV9tb2R1bGVzL21vbmdvb3NlL2xpYi9zY2hlbWEvc3RyaW5nLmpzP2ZmN2QiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG4vKiFcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxuY29uc3QgU2NoZW1hVHlwZSA9IHJlcXVpcmUoJy4uL3NjaGVtYVR5cGUnKTtcbmNvbnN0IE1vbmdvb3NlRXJyb3IgPSByZXF1aXJlKCcuLi9lcnJvci9pbmRleCcpO1xuY29uc3QgU2NoZW1hU3RyaW5nT3B0aW9ucyA9IHJlcXVpcmUoJy4uL29wdGlvbnMvc2NoZW1hU3RyaW5nT3B0aW9ucycpO1xuY29uc3QgY2FzdFN0cmluZyA9IHJlcXVpcmUoJy4uL2Nhc3Qvc3RyaW5nJyk7XG5jb25zdCB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzJyk7XG5jb25zdCBpc0Jzb25UeXBlID0gcmVxdWlyZSgnLi4vaGVscGVycy9pc0Jzb25UeXBlJyk7XG5cbmNvbnN0IENhc3RFcnJvciA9IFNjaGVtYVR5cGUuQ2FzdEVycm9yO1xuXG4vKipcbiAqIFN0cmluZyBTY2hlbWFUeXBlIGNvbnN0cnVjdG9yLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBrZXlcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAaW5oZXJpdHMgU2NoZW1hVHlwZVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBTY2hlbWFTdHJpbmcoa2V5LCBvcHRpb25zKSB7XG4gIHRoaXMuZW51bVZhbHVlcyA9IFtdO1xuICB0aGlzLnJlZ0V4cCA9IG51bGw7XG4gIFNjaGVtYVR5cGUuY2FsbCh0aGlzLCBrZXksIG9wdGlvbnMsICdTdHJpbmcnKTtcbn1cblxuLyoqXG4gKiBUaGlzIHNjaGVtYSB0eXBlJ3MgbmFtZSwgdG8gZGVmZW5kIGFnYWluc3QgbWluaWZpZXJzIHRoYXQgbWFuZ2xlXG4gKiBmdW5jdGlvbiBuYW1lcy5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5TY2hlbWFTdHJpbmcuc2NoZW1hTmFtZSA9ICdTdHJpbmcnO1xuXG5TY2hlbWFTdHJpbmcuZGVmYXVsdE9wdGlvbnMgPSB7fTtcblxuLyohXG4gKiBJbmhlcml0cyBmcm9tIFNjaGVtYVR5cGUuXG4gKi9cblNjaGVtYVN0cmluZy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFNjaGVtYVR5cGUucHJvdG90eXBlKTtcblNjaGVtYVN0cmluZy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBTY2hlbWFTdHJpbmc7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoU2NoZW1hU3RyaW5nLnByb3RvdHlwZSwgJ09wdGlvbnNDb25zdHJ1Y3RvcicsIHtcbiAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgZW51bWVyYWJsZTogZmFsc2UsXG4gIHdyaXRhYmxlOiBmYWxzZSxcbiAgdmFsdWU6IFNjaGVtYVN0cmluZ09wdGlvbnNcbn0pO1xuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cblNjaGVtYVN0cmluZy5fY2FzdCA9IGNhc3RTdHJpbmc7XG5cbi8qKlxuICogR2V0L3NldCB0aGUgZnVuY3Rpb24gdXNlZCB0byBjYXN0IGFyYml0cmFyeSB2YWx1ZXMgdG8gc3RyaW5ncy5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIC8vIFRocm93IGFuIGVycm9yIGlmIHlvdSBwYXNzIGluIGFuIG9iamVjdC4gTm9ybWFsbHksIE1vbmdvb3NlIGFsbG93c1xuICogICAgIC8vIG9iamVjdHMgd2l0aCBjdXN0b20gYHRvU3RyaW5nKClgIGZ1bmN0aW9ucy5cbiAqICAgICBjb25zdCBvcmlnaW5hbCA9IG1vbmdvb3NlLlNjaGVtYS5UeXBlcy5TdHJpbmcuY2FzdCgpO1xuICogICAgIG1vbmdvb3NlLlNjaGVtYS5UeXBlcy5TdHJpbmcuY2FzdCh2ID0+IHtcbiAqICAgICAgIGFzc2VydC5vayh2ID09IG51bGwgfHwgdHlwZW9mIHYgIT09ICdvYmplY3QnKTtcbiAqICAgICAgIHJldHVybiBvcmlnaW5hbCh2KTtcbiAqICAgICB9KTtcbiAqXG4gKiAgICAgLy8gT3IgZGlzYWJsZSBjYXN0aW5nIGVudGlyZWx5XG4gKiAgICAgbW9uZ29vc2UuU2NoZW1hLlR5cGVzLlN0cmluZy5jYXN0KGZhbHNlKTtcbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYXN0ZXJcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICogQGZ1bmN0aW9uIGdldFxuICogQHN0YXRpY1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5TY2hlbWFTdHJpbmcuY2FzdCA9IGZ1bmN0aW9uIGNhc3QoY2FzdGVyKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIHRoaXMuX2Nhc3Q7XG4gIH1cbiAgaWYgKGNhc3RlciA9PT0gZmFsc2UpIHtcbiAgICBjYXN0ZXIgPSB0aGlzLl9kZWZhdWx0Q2FzdGVyO1xuICB9XG4gIHRoaXMuX2Nhc3QgPSBjYXN0ZXI7XG5cbiAgcmV0dXJuIHRoaXMuX2Nhc3Q7XG59O1xuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cblNjaGVtYVN0cmluZy5fZGVmYXVsdENhc3RlciA9IHYgPT4ge1xuICBpZiAodiAhPSBudWxsICYmIHR5cGVvZiB2ICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBFcnJvcigpO1xuICB9XG4gIHJldHVybiB2O1xufTtcblxuLyoqXG4gKiBBdHRhY2hlcyBhIGdldHRlciBmb3IgYWxsIFN0cmluZyBpbnN0YW5jZXMuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICAvLyBNYWtlIGFsbCBudW1iZXJzIHJvdW5kIGRvd25cbiAqICAgICBtb25nb29zZS5TY2hlbWEuU3RyaW5nLmdldCh2ID0+IHYudG9Mb3dlckNhc2UoKSk7XG4gKlxuICogICAgIGNvbnN0IE1vZGVsID0gbW9uZ29vc2UubW9kZWwoJ1Rlc3QnLCBuZXcgU2NoZW1hKHsgdGVzdDogU3RyaW5nIH0pKTtcbiAqICAgICBuZXcgTW9kZWwoeyB0ZXN0OiAnRk9PJyB9KS50ZXN0OyAvLyAnZm9vJ1xuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGdldHRlclxuICogQHJldHVybiB7dGhpc31cbiAqIEBmdW5jdGlvbiBnZXRcbiAqIEBzdGF0aWNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuU2NoZW1hU3RyaW5nLmdldCA9IFNjaGVtYVR5cGUuZ2V0O1xuXG4vKipcbiAqIFNldHMgYSBkZWZhdWx0IG9wdGlvbiBmb3IgYWxsIFN0cmluZyBpbnN0YW5jZXMuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICAvLyBNYWtlIGFsbCBzdHJpbmdzIGhhdmUgb3B0aW9uIGB0cmltYCBlcXVhbCB0byB0cnVlLlxuICogICAgIG1vbmdvb3NlLlNjaGVtYS5TdHJpbmcuc2V0KCd0cmltJywgdHJ1ZSk7XG4gKlxuICogICAgIGNvbnN0IFVzZXIgPSBtb25nb29zZS5tb2RlbCgnVXNlcicsIG5ldyBTY2hlbWEoeyBuYW1lOiBTdHJpbmcgfSkpO1xuICogICAgIG5ldyBVc2VyKHsgbmFtZTogJyAgIEpvaG4gRG9lICAgJyB9KS5uYW1lOyAvLyAnSm9obiBEb2UnXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG9wdGlvbiBUaGUgb3B0aW9uIHlvdSdkIGxpa2UgdG8gc2V0IHRoZSB2YWx1ZSBmb3JcbiAqIEBwYXJhbSB7QW55fSB2YWx1ZSB2YWx1ZSBmb3Igb3B0aW9uXG4gKiBAcmV0dXJuIHt1bmRlZmluZWR9XG4gKiBAZnVuY3Rpb24gc2V0XG4gKiBAc3RhdGljXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblNjaGVtYVN0cmluZy5zZXQgPSBTY2hlbWFUeXBlLnNldDtcblxuU2NoZW1hU3RyaW5nLnNldHRlcnMgPSBbXTtcblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5TY2hlbWFTdHJpbmcuX2NoZWNrUmVxdWlyZWQgPSB2ID0+ICh2IGluc3RhbmNlb2YgU3RyaW5nIHx8IHR5cGVvZiB2ID09PSAnc3RyaW5nJykgJiYgdi5sZW5ndGg7XG5cbi8qKlxuICogT3ZlcnJpZGUgdGhlIGZ1bmN0aW9uIHRoZSByZXF1aXJlZCB2YWxpZGF0b3IgdXNlcyB0byBjaGVjayB3aGV0aGVyIGEgc3RyaW5nXG4gKiBwYXNzZXMgdGhlIGByZXF1aXJlZGAgY2hlY2suXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICAvLyBBbGxvdyBlbXB0eSBzdHJpbmdzIHRvIHBhc3MgYHJlcXVpcmVkYCBjaGVja1xuICogICAgIG1vbmdvb3NlLlNjaGVtYS5UeXBlcy5TdHJpbmcuY2hlY2tSZXF1aXJlZCh2ID0+IHYgIT0gbnVsbCk7XG4gKlxuICogICAgIGNvbnN0IE0gPSBtb25nb29zZS5tb2RlbCh7IHN0cjogeyB0eXBlOiBTdHJpbmcsIHJlcXVpcmVkOiB0cnVlIH0gfSk7XG4gKiAgICAgbmV3IE0oeyBzdHI6ICcnIH0pLnZhbGlkYXRlU3luYygpOyAvLyBgbnVsbGAsIHZhbGlkYXRpb24gcGFzc2VzIVxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAqIEBmdW5jdGlvbiBjaGVja1JlcXVpcmVkXG4gKiBAc3RhdGljXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblNjaGVtYVN0cmluZy5jaGVja1JlcXVpcmVkID0gU2NoZW1hVHlwZS5jaGVja1JlcXVpcmVkO1xuXG4vKipcbiAqIEFkZHMgYW4gZW51bSB2YWxpZGF0b3JcbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IHN0YXRlcyA9IFsnb3BlbmluZycsICdvcGVuJywgJ2Nsb3NpbmcnLCAnY2xvc2VkJ11cbiAqICAgICBjb25zdCBzID0gbmV3IFNjaGVtYSh7IHN0YXRlOiB7IHR5cGU6IFN0cmluZywgZW51bTogc3RhdGVzIH19KVxuICogICAgIGNvbnN0IE0gPSBkYi5tb2RlbCgnTScsIHMpXG4gKiAgICAgY29uc3QgbSA9IG5ldyBNKHsgc3RhdGU6ICdpbnZhbGlkJyB9KVxuICogICAgIG0uc2F2ZShmdW5jdGlvbiAoZXJyKSB7XG4gKiAgICAgICBjb25zb2xlLmVycm9yKFN0cmluZyhlcnIpKSAvLyBWYWxpZGF0aW9uRXJyb3I6IGBpbnZhbGlkYCBpcyBub3QgYSB2YWxpZCBlbnVtIHZhbHVlIGZvciBwYXRoIGBzdGF0ZWAuXG4gKiAgICAgICBtLnN0YXRlID0gJ29wZW4nXG4gKiAgICAgICBtLnNhdmUoY2FsbGJhY2spIC8vIHN1Y2Nlc3NcbiAqICAgICB9KVxuICpcbiAqICAgICAvLyBvciB3aXRoIGN1c3RvbSBlcnJvciBtZXNzYWdlc1xuICogICAgIGNvbnN0IGVudW0gPSB7XG4gKiAgICAgICB2YWx1ZXM6IFsnb3BlbmluZycsICdvcGVuJywgJ2Nsb3NpbmcnLCAnY2xvc2VkJ10sXG4gKiAgICAgICBtZXNzYWdlOiAnZW51bSB2YWxpZGF0b3IgZmFpbGVkIGZvciBwYXRoIGB7UEFUSH1gIHdpdGggdmFsdWUgYHtWQUxVRX1gJ1xuICogICAgIH1cbiAqICAgICBjb25zdCBzID0gbmV3IFNjaGVtYSh7IHN0YXRlOiB7IHR5cGU6IFN0cmluZywgZW51bTogZW51bSB9KVxuICogICAgIGNvbnN0IE0gPSBkYi5tb2RlbCgnTScsIHMpXG4gKiAgICAgY29uc3QgbSA9IG5ldyBNKHsgc3RhdGU6ICdpbnZhbGlkJyB9KVxuICogICAgIG0uc2F2ZShmdW5jdGlvbiAoZXJyKSB7XG4gKiAgICAgICBjb25zb2xlLmVycm9yKFN0cmluZyhlcnIpKSAvLyBWYWxpZGF0aW9uRXJyb3I6IGVudW0gdmFsaWRhdG9yIGZhaWxlZCBmb3IgcGF0aCBgc3RhdGVgIHdpdGggdmFsdWUgYGludmFsaWRgXG4gKiAgICAgICBtLnN0YXRlID0gJ29wZW4nXG4gKiAgICAgICBtLnNhdmUoY2FsbGJhY2spIC8vIHN1Y2Nlc3NcbiAqICAgICB9KVxuICpcbiAqIEBwYXJhbSB7Li4uU3RyaW5nfE9iamVjdH0gW2FyZ3NdIGVudW1lcmF0aW9uIHZhbHVlc1xuICogQHJldHVybiB7U2NoZW1hVHlwZX0gdGhpc1xuICogQHNlZSBDdXN0b21pemVkIEVycm9yIE1lc3NhZ2VzIGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvZXJyb3IuaHRtbCNFcnJvci5tZXNzYWdlc1xuICogQHNlZSBFbnVtcyBpbiBKYXZhU2NyaXB0IGh0dHBzOi8vbWFzdGVyaW5nanMuaW8vdHV0b3JpYWxzL2Z1bmRhbWVudGFscy9lbnVtXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblNjaGVtYVN0cmluZy5wcm90b3R5cGUuZW51bSA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5lbnVtVmFsaWRhdG9yKSB7XG4gICAgdGhpcy52YWxpZGF0b3JzID0gdGhpcy52YWxpZGF0b3JzLmZpbHRlcihmdW5jdGlvbih2KSB7XG4gICAgICByZXR1cm4gdi52YWxpZGF0b3IgIT09IHRoaXMuZW51bVZhbGlkYXRvcjtcbiAgICB9LCB0aGlzKTtcbiAgICB0aGlzLmVudW1WYWxpZGF0b3IgPSBmYWxzZTtcbiAgfVxuXG4gIGlmIChhcmd1bWVudHNbMF0gPT09IHZvaWQgMCB8fCBhcmd1bWVudHNbMF0gPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBsZXQgdmFsdWVzO1xuICBsZXQgZXJyb3JNZXNzYWdlO1xuXG4gIGlmICh1dGlscy5pc09iamVjdChhcmd1bWVudHNbMF0pKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYXJndW1lbnRzWzBdLnZhbHVlcykpIHtcbiAgICAgIHZhbHVlcyA9IGFyZ3VtZW50c1swXS52YWx1ZXM7XG4gICAgICBlcnJvck1lc3NhZ2UgPSBhcmd1bWVudHNbMF0ubWVzc2FnZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsdWVzID0gdXRpbHMub2JqZWN0LnZhbHMoYXJndW1lbnRzWzBdKTtcbiAgICAgIGVycm9yTWVzc2FnZSA9IE1vbmdvb3NlRXJyb3IubWVzc2FnZXMuU3RyaW5nLmVudW07XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhbHVlcyA9IGFyZ3VtZW50cztcbiAgICBlcnJvck1lc3NhZ2UgPSBNb25nb29zZUVycm9yLm1lc3NhZ2VzLlN0cmluZy5lbnVtO1xuICB9XG5cbiAgZm9yIChjb25zdCB2YWx1ZSBvZiB2YWx1ZXMpIHtcbiAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5lbnVtVmFsdWVzLnB1c2godGhpcy5jYXN0KHZhbHVlKSk7XG4gICAgfVxuICB9XG5cbiAgY29uc3QgdmFscyA9IHRoaXMuZW51bVZhbHVlcztcbiAgdGhpcy5lbnVtVmFsaWRhdG9yID0gZnVuY3Rpb24odikge1xuICAgIHJldHVybiBudWxsID09IHYgfHwgfnZhbHMuaW5kZXhPZih2KTtcbiAgfTtcbiAgdGhpcy52YWxpZGF0b3JzLnB1c2goe1xuICAgIHZhbGlkYXRvcjogdGhpcy5lbnVtVmFsaWRhdG9yLFxuICAgIG1lc3NhZ2U6IGVycm9yTWVzc2FnZSxcbiAgICB0eXBlOiAnZW51bScsXG4gICAgZW51bVZhbHVlczogdmFsc1xuICB9KTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQWRkcyBhIGxvd2VyY2FzZSBbc2V0dGVyXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvYXBpL3NjaGVtYXR5cGUuaHRtbCNTY2hlbWFUeXBlLnByb3RvdHlwZS5zZXQoKSkuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBjb25zdCBzID0gbmV3IFNjaGVtYSh7IGVtYWlsOiB7IHR5cGU6IFN0cmluZywgbG93ZXJjYXNlOiB0cnVlIH19KVxuICogICAgIGNvbnN0IE0gPSBkYi5tb2RlbCgnTScsIHMpO1xuICogICAgIGNvbnN0IG0gPSBuZXcgTSh7IGVtYWlsOiAnU29tZUVtYWlsQGV4YW1wbGUuQ09NJyB9KTtcbiAqICAgICBjb25zb2xlLmxvZyhtLmVtYWlsKSAvLyBzb21lZW1haWxAZXhhbXBsZS5jb21cbiAqICAgICBNLmZpbmQoeyBlbWFpbDogJ1NvbWVFbWFpbEBleGFtcGxlLmNvbScgfSk7IC8vIFF1ZXJpZXMgYnkgJ3NvbWVlbWFpbEBleGFtcGxlLmNvbSdcbiAqXG4gKiBOb3RlIHRoYXQgYGxvd2VyY2FzZWAgZG9lcyAqKm5vdCoqIGFmZmVjdCByZWd1bGFyIGV4cHJlc3Npb24gcXVlcmllczpcbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIC8vIFN0aWxsIHF1ZXJpZXMgZm9yIGRvY3VtZW50cyB3aG9zZSBgZW1haWxgIG1hdGNoZXMgdGhlIHJlZ3VsYXJcbiAqICAgICAvLyBleHByZXNzaW9uIC9Tb21lRW1haWwvLiBNb25nb29zZSBkb2VzICoqbm90KiogY29udmVydCB0aGUgUmVnRXhwXG4gKiAgICAgLy8gdG8gbG93ZXJjYXNlLlxuICogICAgIE0uZmluZCh7IGVtYWlsOiAvU29tZUVtYWlsLyB9KTtcbiAqXG4gKiBAYXBpIHB1YmxpY1xuICogQHJldHVybiB7U2NoZW1hVHlwZX0gdGhpc1xuICovXG5cblNjaGVtYVN0cmluZy5wcm90b3R5cGUubG93ZXJjYXNlID0gZnVuY3Rpb24oc2hvdWxkQXBwbHkpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAwICYmICFzaG91bGRBcHBseSkge1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHJldHVybiB0aGlzLnNldCh2ID0+IHtcbiAgICBpZiAodHlwZW9mIHYgIT09ICdzdHJpbmcnKSB7XG4gICAgICB2ID0gdGhpcy5jYXN0KHYpO1xuICAgIH1cbiAgICBpZiAodikge1xuICAgICAgcmV0dXJuIHYudG9Mb3dlckNhc2UoKTtcbiAgICB9XG4gICAgcmV0dXJuIHY7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBBZGRzIGFuIHVwcGVyY2FzZSBbc2V0dGVyXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvYXBpL3NjaGVtYXR5cGUuaHRtbCNTY2hlbWFUeXBlLnByb3RvdHlwZS5zZXQoKSkuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBjb25zdCBzID0gbmV3IFNjaGVtYSh7IGNhcHM6IHsgdHlwZTogU3RyaW5nLCB1cHBlcmNhc2U6IHRydWUgfX0pXG4gKiAgICAgY29uc3QgTSA9IGRiLm1vZGVsKCdNJywgcyk7XG4gKiAgICAgY29uc3QgbSA9IG5ldyBNKHsgY2FwczogJ2FuIGV4YW1wbGUnIH0pO1xuICogICAgIGNvbnNvbGUubG9nKG0uY2FwcykgLy8gQU4gRVhBTVBMRVxuICogICAgIE0uZmluZCh7IGNhcHM6ICdhbiBleGFtcGxlJyB9KSAvLyBNYXRjaGVzIGRvY3VtZW50cyB3aGVyZSBjYXBzID0gJ0FOIEVYQU1QTEUnXG4gKlxuICogTm90ZSB0aGF0IGB1cHBlcmNhc2VgIGRvZXMgKipub3QqKiBhZmZlY3QgcmVndWxhciBleHByZXNzaW9uIHF1ZXJpZXM6XG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICAvLyBNb25nb29zZSBkb2VzICoqbm90KiogY29udmVydCB0aGUgUmVnRXhwIHRvIHVwcGVyY2FzZS5cbiAqICAgICBNLmZpbmQoeyBlbWFpbDogL2FuIGV4YW1wbGUvIH0pO1xuICpcbiAqIEBhcGkgcHVibGljXG4gKiBAcmV0dXJuIHtTY2hlbWFUeXBlfSB0aGlzXG4gKi9cblxuU2NoZW1hU3RyaW5nLnByb3RvdHlwZS51cHBlcmNhc2UgPSBmdW5jdGlvbihzaG91bGRBcHBseSkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgIXNob3VsZEFwcGx5KSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgcmV0dXJuIHRoaXMuc2V0KHYgPT4ge1xuICAgIGlmICh0eXBlb2YgdiAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHYgPSB0aGlzLmNhc3Qodik7XG4gICAgfVxuICAgIGlmICh2KSB7XG4gICAgICByZXR1cm4gdi50b1VwcGVyQ2FzZSgpO1xuICAgIH1cbiAgICByZXR1cm4gdjtcbiAgfSk7XG59O1xuXG4vKipcbiAqIEFkZHMgYSB0cmltIFtzZXR0ZXJdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvc2NoZW1hdHlwZS5odG1sI1NjaGVtYVR5cGUucHJvdG90eXBlLnNldCgpKS5cbiAqXG4gKiBUaGUgc3RyaW5nIHZhbHVlIHdpbGwgYmUgW3RyaW1tZWRdKGh0dHBzOi8vbWFzdGVyaW5nanMuaW8vdHV0b3JpYWxzL2Z1bmRhbWVudGFscy90cmltLXN0cmluZykgd2hlbiBzZXQuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBjb25zdCBzID0gbmV3IFNjaGVtYSh7IG5hbWU6IHsgdHlwZTogU3RyaW5nLCB0cmltOiB0cnVlIH19KTtcbiAqICAgICBjb25zdCBNID0gZGIubW9kZWwoJ00nLCBzKTtcbiAqICAgICBjb25zdCBzdHJpbmcgPSAnIHNvbWUgbmFtZSAnO1xuICogICAgIGNvbnNvbGUubG9nKHN0cmluZy5sZW5ndGgpOyAvLyAxMVxuICogICAgIGNvbnN0IG0gPSBuZXcgTSh7IG5hbWU6IHN0cmluZyB9KTtcbiAqICAgICBjb25zb2xlLmxvZyhtLm5hbWUubGVuZ3RoKTsgLy8gOVxuICpcbiAqICAgICAvLyBFcXVpdmFsZW50IHRvIGBmaW5kT25lKHsgbmFtZTogc3RyaW5nLnRyaW0oKSB9KWBcbiAqICAgICBNLmZpbmRPbmUoeyBuYW1lOiBzdHJpbmcgfSk7XG4gKlxuICogTm90ZSB0aGF0IGB0cmltYCBkb2VzICoqbm90KiogYWZmZWN0IHJlZ3VsYXIgZXhwcmVzc2lvbiBxdWVyaWVzOlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgLy8gTW9uZ29vc2UgZG9lcyAqKm5vdCoqIHRyaW0gd2hpdGVzcGFjZSBmcm9tIHRoZSBSZWdFeHAuXG4gKiAgICAgTS5maW5kKHsgbmFtZTogLyBzb21lIG5hbWUgLyB9KTtcbiAqXG4gKiBAYXBpIHB1YmxpY1xuICogQHJldHVybiB7U2NoZW1hVHlwZX0gdGhpc1xuICovXG5cblNjaGVtYVN0cmluZy5wcm90b3R5cGUudHJpbSA9IGZ1bmN0aW9uKHNob3VsZFRyaW0pIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAwICYmICFzaG91bGRUcmltKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgcmV0dXJuIHRoaXMuc2V0KHYgPT4ge1xuICAgIGlmICh0eXBlb2YgdiAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHYgPSB0aGlzLmNhc3Qodik7XG4gICAgfVxuICAgIGlmICh2KSB7XG4gICAgICByZXR1cm4gdi50cmltKCk7XG4gICAgfVxuICAgIHJldHVybiB2O1xuICB9KTtcbn07XG5cbi8qKlxuICogU2V0cyBhIG1pbmltdW0gbGVuZ3RoIHZhbGlkYXRvci5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IHNjaGVtYSA9IG5ldyBTY2hlbWEoeyBwb3N0YWxDb2RlOiB7IHR5cGU6IFN0cmluZywgbWlubGVuZ3RoOiA1IH0pXG4gKiAgICAgY29uc3QgQWRkcmVzcyA9IGRiLm1vZGVsKCdBZGRyZXNzJywgc2NoZW1hKVxuICogICAgIGNvbnN0IGFkZHJlc3MgPSBuZXcgQWRkcmVzcyh7IHBvc3RhbENvZGU6ICc5NTEyJyB9KVxuICogICAgIGFkZHJlc3Muc2F2ZShmdW5jdGlvbiAoZXJyKSB7XG4gKiAgICAgICBjb25zb2xlLmVycm9yKGVycikgLy8gdmFsaWRhdG9yIGVycm9yXG4gKiAgICAgICBhZGRyZXNzLnBvc3RhbENvZGUgPSAnOTUxMjUnO1xuICogICAgICAgYWRkcmVzcy5zYXZlKCkgLy8gc3VjY2Vzc1xuICogICAgIH0pXG4gKlxuICogICAgIC8vIGN1c3RvbSBlcnJvciBtZXNzYWdlc1xuICogICAgIC8vIFdlIGNhbiBhbHNvIHVzZSB0aGUgc3BlY2lhbCB7TUlOTEVOR1RIfSB0b2tlbiB3aGljaCB3aWxsIGJlIHJlcGxhY2VkIHdpdGggdGhlIG1pbmltdW0gYWxsb3dlZCBsZW5ndGhcbiAqICAgICBjb25zdCBtaW5sZW5ndGggPSBbNSwgJ1RoZSB2YWx1ZSBvZiBwYXRoIGB7UEFUSH1gIChge1ZBTFVFfWApIGlzIHNob3J0ZXIgdGhhbiB0aGUgbWluaW11bSBhbGxvd2VkIGxlbmd0aCAoe01JTkxFTkdUSH0pLiddO1xuICogICAgIGNvbnN0IHNjaGVtYSA9IG5ldyBTY2hlbWEoeyBwb3N0YWxDb2RlOiB7IHR5cGU6IFN0cmluZywgbWlubGVuZ3RoOiBtaW5sZW5ndGggfSlcbiAqICAgICBjb25zdCBBZGRyZXNzID0gbW9uZ29vc2UubW9kZWwoJ0FkZHJlc3MnLCBzY2hlbWEpO1xuICogICAgIGNvbnN0IGFkZHJlc3MgPSBuZXcgQWRkcmVzcyh7IHBvc3RhbENvZGU6ICc5NTEyJyB9KTtcbiAqICAgICBhZGRyZXNzLnZhbGlkYXRlKGZ1bmN0aW9uIChlcnIpIHtcbiAqICAgICAgIGNvbnNvbGUubG9nKFN0cmluZyhlcnIpKSAvLyBWYWxpZGF0aW9uRXJyb3I6IFRoZSB2YWx1ZSBvZiBwYXRoIGBwb3N0YWxDb2RlYCAoYDk1MTJgKSBpcyBzaG9ydGVyIHRoYW4gdGhlIG1pbmltdW0gbGVuZ3RoICg1KS5cbiAqICAgICB9KVxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZSBtaW5pbXVtIHN0cmluZyBsZW5ndGhcbiAqIEBwYXJhbSB7U3RyaW5nfSBbbWVzc2FnZV0gb3B0aW9uYWwgY3VzdG9tIGVycm9yIG1lc3NhZ2VcbiAqIEByZXR1cm4ge1NjaGVtYVR5cGV9IHRoaXNcbiAqIEBzZWUgQ3VzdG9taXplZCBFcnJvciBNZXNzYWdlcyBodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvYXBpL2Vycm9yLmh0bWwjRXJyb3IubWVzc2FnZXNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuU2NoZW1hU3RyaW5nLnByb3RvdHlwZS5taW5sZW5ndGggPSBmdW5jdGlvbih2YWx1ZSwgbWVzc2FnZSkge1xuICBpZiAodGhpcy5taW5sZW5ndGhWYWxpZGF0b3IpIHtcbiAgICB0aGlzLnZhbGlkYXRvcnMgPSB0aGlzLnZhbGlkYXRvcnMuZmlsdGVyKGZ1bmN0aW9uKHYpIHtcbiAgICAgIHJldHVybiB2LnZhbGlkYXRvciAhPT0gdGhpcy5taW5sZW5ndGhWYWxpZGF0b3I7XG4gICAgfSwgdGhpcyk7XG4gIH1cblxuICBpZiAodmFsdWUgIT09IG51bGwgJiYgdmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgIGxldCBtc2cgPSBtZXNzYWdlIHx8IE1vbmdvb3NlRXJyb3IubWVzc2FnZXMuU3RyaW5nLm1pbmxlbmd0aDtcbiAgICBtc2cgPSBtc2cucmVwbGFjZSgve01JTkxFTkdUSH0vLCB2YWx1ZSk7XG4gICAgdGhpcy52YWxpZGF0b3JzLnB1c2goe1xuICAgICAgdmFsaWRhdG9yOiB0aGlzLm1pbmxlbmd0aFZhbGlkYXRvciA9IGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgcmV0dXJuIHYgPT09IG51bGwgfHwgdi5sZW5ndGggPj0gdmFsdWU7XG4gICAgICB9LFxuICAgICAgbWVzc2FnZTogbXNnLFxuICAgICAgdHlwZTogJ21pbmxlbmd0aCcsXG4gICAgICBtaW5sZW5ndGg6IHZhbHVlXG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cblNjaGVtYVN0cmluZy5wcm90b3R5cGUubWluTGVuZ3RoID0gU2NoZW1hU3RyaW5nLnByb3RvdHlwZS5taW5sZW5ndGg7XG5cbi8qKlxuICogU2V0cyBhIG1heGltdW0gbGVuZ3RoIHZhbGlkYXRvci5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IHNjaGVtYSA9IG5ldyBTY2hlbWEoeyBwb3N0YWxDb2RlOiB7IHR5cGU6IFN0cmluZywgbWF4bGVuZ3RoOiA5IH0pXG4gKiAgICAgY29uc3QgQWRkcmVzcyA9IGRiLm1vZGVsKCdBZGRyZXNzJywgc2NoZW1hKVxuICogICAgIGNvbnN0IGFkZHJlc3MgPSBuZXcgQWRkcmVzcyh7IHBvc3RhbENvZGU6ICc5NTEyNTEyMzQ1JyB9KVxuICogICAgIGFkZHJlc3Muc2F2ZShmdW5jdGlvbiAoZXJyKSB7XG4gKiAgICAgICBjb25zb2xlLmVycm9yKGVycikgLy8gdmFsaWRhdG9yIGVycm9yXG4gKiAgICAgICBhZGRyZXNzLnBvc3RhbENvZGUgPSAnOTUxMjUnO1xuICogICAgICAgYWRkcmVzcy5zYXZlKCkgLy8gc3VjY2Vzc1xuICogICAgIH0pXG4gKlxuICogICAgIC8vIGN1c3RvbSBlcnJvciBtZXNzYWdlc1xuICogICAgIC8vIFdlIGNhbiBhbHNvIHVzZSB0aGUgc3BlY2lhbCB7TUFYTEVOR1RIfSB0b2tlbiB3aGljaCB3aWxsIGJlIHJlcGxhY2VkIHdpdGggdGhlIG1heGltdW0gYWxsb3dlZCBsZW5ndGhcbiAqICAgICBjb25zdCBtYXhsZW5ndGggPSBbOSwgJ1RoZSB2YWx1ZSBvZiBwYXRoIGB7UEFUSH1gIChge1ZBTFVFfWApIGV4Y2VlZHMgdGhlIG1heGltdW0gYWxsb3dlZCBsZW5ndGggKHtNQVhMRU5HVEh9KS4nXTtcbiAqICAgICBjb25zdCBzY2hlbWEgPSBuZXcgU2NoZW1hKHsgcG9zdGFsQ29kZTogeyB0eXBlOiBTdHJpbmcsIG1heGxlbmd0aDogbWF4bGVuZ3RoIH0pXG4gKiAgICAgY29uc3QgQWRkcmVzcyA9IG1vbmdvb3NlLm1vZGVsKCdBZGRyZXNzJywgc2NoZW1hKTtcbiAqICAgICBjb25zdCBhZGRyZXNzID0gbmV3IEFkZHJlc3MoeyBwb3N0YWxDb2RlOiAnOTUxMjUxMjM0NScgfSk7XG4gKiAgICAgYWRkcmVzcy52YWxpZGF0ZShmdW5jdGlvbiAoZXJyKSB7XG4gKiAgICAgICBjb25zb2xlLmxvZyhTdHJpbmcoZXJyKSkgLy8gVmFsaWRhdGlvbkVycm9yOiBUaGUgdmFsdWUgb2YgcGF0aCBgcG9zdGFsQ29kZWAgKGA5NTEyNTEyMzQ1YCkgZXhjZWVkcyB0aGUgbWF4aW11bSBhbGxvd2VkIGxlbmd0aCAoOSkuXG4gKiAgICAgfSlcbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gdmFsdWUgbWF4aW11bSBzdHJpbmcgbGVuZ3RoXG4gKiBAcGFyYW0ge1N0cmluZ30gW21lc3NhZ2VdIG9wdGlvbmFsIGN1c3RvbSBlcnJvciBtZXNzYWdlXG4gKiBAcmV0dXJuIHtTY2hlbWFUeXBlfSB0aGlzXG4gKiBAc2VlIEN1c3RvbWl6ZWQgRXJyb3IgTWVzc2FnZXMgaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2FwaS9lcnJvci5odG1sI0Vycm9yLm1lc3NhZ2VzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblNjaGVtYVN0cmluZy5wcm90b3R5cGUubWF4bGVuZ3RoID0gZnVuY3Rpb24odmFsdWUsIG1lc3NhZ2UpIHtcbiAgaWYgKHRoaXMubWF4bGVuZ3RoVmFsaWRhdG9yKSB7XG4gICAgdGhpcy52YWxpZGF0b3JzID0gdGhpcy52YWxpZGF0b3JzLmZpbHRlcihmdW5jdGlvbih2KSB7XG4gICAgICByZXR1cm4gdi52YWxpZGF0b3IgIT09IHRoaXMubWF4bGVuZ3RoVmFsaWRhdG9yO1xuICAgIH0sIHRoaXMpO1xuICB9XG5cbiAgaWYgKHZhbHVlICE9PSBudWxsICYmIHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICBsZXQgbXNnID0gbWVzc2FnZSB8fCBNb25nb29zZUVycm9yLm1lc3NhZ2VzLlN0cmluZy5tYXhsZW5ndGg7XG4gICAgbXNnID0gbXNnLnJlcGxhY2UoL3tNQVhMRU5HVEh9LywgdmFsdWUpO1xuICAgIHRoaXMudmFsaWRhdG9ycy5wdXNoKHtcbiAgICAgIHZhbGlkYXRvcjogdGhpcy5tYXhsZW5ndGhWYWxpZGF0b3IgPSBmdW5jdGlvbih2KSB7XG4gICAgICAgIHJldHVybiB2ID09PSBudWxsIHx8IHYubGVuZ3RoIDw9IHZhbHVlO1xuICAgICAgfSxcbiAgICAgIG1lc3NhZ2U6IG1zZyxcbiAgICAgIHR5cGU6ICdtYXhsZW5ndGgnLFxuICAgICAgbWF4bGVuZ3RoOiB2YWx1ZVxuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5TY2hlbWFTdHJpbmcucHJvdG90eXBlLm1heExlbmd0aCA9IFNjaGVtYVN0cmluZy5wcm90b3R5cGUubWF4bGVuZ3RoO1xuXG4vKipcbiAqIFNldHMgYSByZWdleHAgdmFsaWRhdG9yLlxuICpcbiAqIEFueSB2YWx1ZSB0aGF0IGRvZXMgbm90IHBhc3MgYHJlZ0V4cGAudGVzdCh2YWwpIHdpbGwgZmFpbCB2YWxpZGF0aW9uLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgY29uc3QgcyA9IG5ldyBTY2hlbWEoeyBuYW1lOiB7IHR5cGU6IFN0cmluZywgbWF0Y2g6IC9eYS8gfX0pXG4gKiAgICAgY29uc3QgTSA9IGRiLm1vZGVsKCdNJywgcylcbiAqICAgICBjb25zdCBtID0gbmV3IE0oeyBuYW1lOiAnSSBhbSBpbnZhbGlkJyB9KVxuICogICAgIG0udmFsaWRhdGUoZnVuY3Rpb24gKGVycikge1xuICogICAgICAgY29uc29sZS5lcnJvcihTdHJpbmcoZXJyKSkgLy8gXCJWYWxpZGF0aW9uRXJyb3I6IFBhdGggYG5hbWVgIGlzIGludmFsaWQgKEkgYW0gaW52YWxpZCkuXCJcbiAqICAgICAgIG0ubmFtZSA9ICdhcHBsZXMnXG4gKiAgICAgICBtLnZhbGlkYXRlKGZ1bmN0aW9uIChlcnIpIHtcbiAqICAgICAgICAgYXNzZXJ0Lm9rKGVycikgLy8gc3VjY2Vzc1xuICogICAgICAgfSlcbiAqICAgICB9KVxuICpcbiAqICAgICAvLyB1c2luZyBhIGN1c3RvbSBlcnJvciBtZXNzYWdlXG4gKiAgICAgY29uc3QgbWF0Y2ggPSBbIC9cXC5odG1sJC8sIFwiVGhhdCBmaWxlIGRvZXNuJ3QgZW5kIGluIC5odG1sICh7VkFMVUV9KVwiIF07XG4gKiAgICAgY29uc3QgcyA9IG5ldyBTY2hlbWEoeyBmaWxlOiB7IHR5cGU6IFN0cmluZywgbWF0Y2g6IG1hdGNoIH19KVxuICogICAgIGNvbnN0IE0gPSBkYi5tb2RlbCgnTScsIHMpO1xuICogICAgIGNvbnN0IG0gPSBuZXcgTSh7IGZpbGU6ICdpbnZhbGlkJyB9KTtcbiAqICAgICBtLnZhbGlkYXRlKGZ1bmN0aW9uIChlcnIpIHtcbiAqICAgICAgIGNvbnNvbGUubG9nKFN0cmluZyhlcnIpKSAvLyBcIlZhbGlkYXRpb25FcnJvcjogVGhhdCBmaWxlIGRvZXNuJ3QgZW5kIGluIC5odG1sIChpbnZhbGlkKVwiXG4gKiAgICAgfSlcbiAqXG4gKiBFbXB0eSBzdHJpbmdzLCBgdW5kZWZpbmVkYCwgYW5kIGBudWxsYCB2YWx1ZXMgYWx3YXlzIHBhc3MgdGhlIG1hdGNoIHZhbGlkYXRvci4gSWYgeW91IHJlcXVpcmUgdGhlc2UgdmFsdWVzLCBlbmFibGUgdGhlIGByZXF1aXJlZGAgdmFsaWRhdG9yIGFsc28uXG4gKlxuICogICAgIGNvbnN0IHMgPSBuZXcgU2NoZW1hKHsgbmFtZTogeyB0eXBlOiBTdHJpbmcsIG1hdGNoOiAvXmEvLCByZXF1aXJlZDogdHJ1ZSB9fSlcbiAqXG4gKiBAcGFyYW0ge1JlZ0V4cH0gcmVnRXhwIHJlZ3VsYXIgZXhwcmVzc2lvbiB0byB0ZXN0IGFnYWluc3RcbiAqIEBwYXJhbSB7U3RyaW5nfSBbbWVzc2FnZV0gb3B0aW9uYWwgY3VzdG9tIGVycm9yIG1lc3NhZ2VcbiAqIEByZXR1cm4ge1NjaGVtYVR5cGV9IHRoaXNcbiAqIEBzZWUgQ3VzdG9taXplZCBFcnJvciBNZXNzYWdlcyBodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvYXBpL2Vycm9yLmh0bWwjRXJyb3IubWVzc2FnZXNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuU2NoZW1hU3RyaW5nLnByb3RvdHlwZS5tYXRjaCA9IGZ1bmN0aW9uIG1hdGNoKHJlZ0V4cCwgbWVzc2FnZSkge1xuICAvLyB5ZXMsIHdlIGFsbG93IG11bHRpcGxlIG1hdGNoIHZhbGlkYXRvcnNcblxuICBjb25zdCBtc2cgPSBtZXNzYWdlIHx8IE1vbmdvb3NlRXJyb3IubWVzc2FnZXMuU3RyaW5nLm1hdGNoO1xuXG4gIGNvbnN0IG1hdGNoVmFsaWRhdG9yID0gZnVuY3Rpb24odikge1xuICAgIGlmICghcmVnRXhwKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gSW4gY2FzZSBSZWdFeHAgaGFwcGVucyB0byBoYXZlIGAvZ2AgZmxhZyBzZXQsIHdlIG5lZWQgdG8gcmVzZXQgdGhlXG4gICAgLy8gYGxhc3RJbmRleGAsIG90aGVyd2lzZSBgbWF0Y2hgIHdpbGwgaW50ZXJtaXR0ZW50bHkgZmFpbC5cbiAgICByZWdFeHAubGFzdEluZGV4ID0gMDtcblxuICAgIGNvbnN0IHJldCA9ICgodiAhPSBudWxsICYmIHYgIT09ICcnKVxuICAgICAgPyByZWdFeHAudGVzdCh2KVxuICAgICAgOiB0cnVlKTtcbiAgICByZXR1cm4gcmV0O1xuICB9O1xuXG4gIHRoaXMudmFsaWRhdG9ycy5wdXNoKHtcbiAgICB2YWxpZGF0b3I6IG1hdGNoVmFsaWRhdG9yLFxuICAgIG1lc3NhZ2U6IG1zZyxcbiAgICB0eXBlOiAncmVnZXhwJyxcbiAgICByZWdleHA6IHJlZ0V4cFxuICB9KTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIENoZWNrIGlmIHRoZSBnaXZlbiB2YWx1ZSBzYXRpc2ZpZXMgdGhlIGByZXF1aXJlZGAgdmFsaWRhdG9yLiBUaGUgdmFsdWUgaXNcbiAqIGNvbnNpZGVyZWQgdmFsaWQgaWYgaXQgaXMgYSBzdHJpbmcgKHRoYXQgaXMsIG5vdCBgbnVsbGAgb3IgYHVuZGVmaW5lZGApIGFuZFxuICogaGFzIHBvc2l0aXZlIGxlbmd0aC4gVGhlIGByZXF1aXJlZGAgdmFsaWRhdG9yICoqd2lsbCoqIGZhaWwgZm9yIGVtcHR5XG4gKiBzdHJpbmdzLlxuICpcbiAqIEBwYXJhbSB7QW55fSB2YWx1ZVxuICogQHBhcmFtIHtEb2N1bWVudH0gZG9jXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5TY2hlbWFTdHJpbmcucHJvdG90eXBlLmNoZWNrUmVxdWlyZWQgPSBmdW5jdGlvbiBjaGVja1JlcXVpcmVkKHZhbHVlLCBkb2MpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgU2NoZW1hVHlwZS5faXNSZWYodGhpcywgdmFsdWUsIGRvYywgdHJ1ZSkpIHtcbiAgICByZXR1cm4gdmFsdWUgIT0gbnVsbDtcbiAgfVxuXG4gIC8vIGByZXF1aXJlKCd1dGlsJykuaW5oZXJpdHMoKWAgZG9lcyAqKm5vdCoqIGNvcHkgc3RhdGljIHByb3BlcnRpZXMsIGFuZFxuICAvLyBwbHVnaW5zIGxpa2UgbW9uZ29vc2UtZmxvYXQgdXNlIGBpbmhlcml0cygpYCBmb3IgcHJlLUVTNi5cbiAgY29uc3QgX2NoZWNrUmVxdWlyZWQgPSB0eXBlb2YgdGhpcy5jb25zdHJ1Y3Rvci5jaGVja1JlcXVpcmVkID09PSAnZnVuY3Rpb24nID9cbiAgICB0aGlzLmNvbnN0cnVjdG9yLmNoZWNrUmVxdWlyZWQoKSA6XG4gICAgU2NoZW1hU3RyaW5nLmNoZWNrUmVxdWlyZWQoKTtcblxuICByZXR1cm4gX2NoZWNrUmVxdWlyZWQodmFsdWUpO1xufTtcblxuLyoqXG4gKiBDYXN0cyB0byBTdHJpbmdcbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5TY2hlbWFTdHJpbmcucHJvdG90eXBlLmNhc3QgPSBmdW5jdGlvbih2YWx1ZSwgZG9jLCBpbml0KSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnICYmIFNjaGVtYVR5cGUuX2lzUmVmKHRoaXMsIHZhbHVlLCBkb2MsIGluaXQpKSB7XG4gICAgcmV0dXJuIHRoaXMuX2Nhc3RSZWYodmFsdWUsIGRvYywgaW5pdCk7XG4gIH1cblxuICBsZXQgY2FzdFN0cmluZztcbiAgaWYgKHR5cGVvZiB0aGlzLl9jYXN0RnVuY3Rpb24gPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYXN0U3RyaW5nID0gdGhpcy5fY2FzdEZ1bmN0aW9uO1xuICB9IGVsc2UgaWYgKHR5cGVvZiB0aGlzLmNvbnN0cnVjdG9yLmNhc3QgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYXN0U3RyaW5nID0gdGhpcy5jb25zdHJ1Y3Rvci5jYXN0KCk7XG4gIH0gZWxzZSB7XG4gICAgY2FzdFN0cmluZyA9IFNjaGVtYVN0cmluZy5jYXN0KCk7XG4gIH1cblxuICB0cnkge1xuICAgIHJldHVybiBjYXN0U3RyaW5nKHZhbHVlKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICB0aHJvdyBuZXcgQ2FzdEVycm9yKCdzdHJpbmcnLCB2YWx1ZSwgdGhpcy5wYXRoLCBudWxsLCB0aGlzKTtcbiAgfVxufTtcblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5mdW5jdGlvbiBoYW5kbGVTaW5nbGUodmFsLCBjb250ZXh0KSB7XG4gIHJldHVybiB0aGlzLmNhc3RGb3JRdWVyeShudWxsLCB2YWwsIGNvbnRleHQpO1xufVxuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cbmZ1bmN0aW9uIGhhbmRsZUFycmF5KHZhbCwgY29udGV4dCkge1xuICBjb25zdCBfdGhpcyA9IHRoaXM7XG4gIGlmICghQXJyYXkuaXNBcnJheSh2YWwpKSB7XG4gICAgcmV0dXJuIFt0aGlzLmNhc3RGb3JRdWVyeShudWxsLCB2YWwsIGNvbnRleHQpXTtcbiAgfVxuICByZXR1cm4gdmFsLm1hcChmdW5jdGlvbihtKSB7XG4gICAgcmV0dXJuIF90aGlzLmNhc3RGb3JRdWVyeShudWxsLCBtLCBjb250ZXh0KTtcbiAgfSk7XG59XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxuZnVuY3Rpb24gaGFuZGxlU2luZ2xlTm9TZXR0ZXJzKHZhbCkge1xuICBpZiAodmFsID09IG51bGwpIHtcbiAgICByZXR1cm4gdGhpcy5fY2FzdE51bGxpc2godmFsKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzLmNhc3QodmFsLCB0aGlzKTtcbn1cblxuY29uc3QgJGNvbmRpdGlvbmFsSGFuZGxlcnMgPSB7XG4gIC4uLlNjaGVtYVR5cGUucHJvdG90eXBlLiRjb25kaXRpb25hbEhhbmRsZXJzLFxuICAkYWxsOiBoYW5kbGVBcnJheSxcbiAgJGd0OiBoYW5kbGVTaW5nbGUsXG4gICRndGU6IGhhbmRsZVNpbmdsZSxcbiAgJGx0OiBoYW5kbGVTaW5nbGUsXG4gICRsdGU6IGhhbmRsZVNpbmdsZSxcbiAgJG9wdGlvbnM6IGhhbmRsZVNpbmdsZU5vU2V0dGVycyxcbiAgJHJlZ2V4OiBmdW5jdGlvbiBoYW5kbGUkcmVnZXgodmFsKSB7XG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWwpID09PSAnW29iamVjdCBSZWdFeHBdJykge1xuICAgICAgcmV0dXJuIHZhbDtcbiAgICB9XG5cbiAgICByZXR1cm4gaGFuZGxlU2luZ2xlTm9TZXR0ZXJzLmNhbGwodGhpcywgdmFsKTtcbiAgfSxcbiAgJG5vdDogaGFuZGxlU2luZ2xlXG59O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoU2NoZW1hU3RyaW5nLnByb3RvdHlwZSwgJyRjb25kaXRpb25hbEhhbmRsZXJzJywge1xuICBjb25maWd1cmFibGU6IGZhbHNlLFxuICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgd3JpdGFibGU6IGZhbHNlLFxuICB2YWx1ZTogT2JqZWN0LmZyZWV6ZSgkY29uZGl0aW9uYWxIYW5kbGVycylcbn0pO1xuXG4vKipcbiAqIENhc3RzIGNvbnRlbnRzIGZvciBxdWVyaWVzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSAkY29uZGl0aW9uYWxcbiAqIEBwYXJhbSB7YW55fSBbdmFsXVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU2NoZW1hU3RyaW5nLnByb3RvdHlwZS5jYXN0Rm9yUXVlcnkgPSBmdW5jdGlvbigkY29uZGl0aW9uYWwsIHZhbCwgY29udGV4dCkge1xuICBsZXQgaGFuZGxlcjtcbiAgaWYgKCRjb25kaXRpb25hbCAhPSBudWxsKSB7XG4gICAgaGFuZGxlciA9IHRoaXMuJGNvbmRpdGlvbmFsSGFuZGxlcnNbJGNvbmRpdGlvbmFsXTtcbiAgICBpZiAoIWhhbmRsZXIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ2FuXFwndCB1c2UgJyArICRjb25kaXRpb25hbCArICcgd2l0aCBTdHJpbmcuJyk7XG4gICAgfVxuICAgIHJldHVybiBoYW5kbGVyLmNhbGwodGhpcywgdmFsLCBjb250ZXh0KTtcbiAgfVxuXG4gIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsKSA9PT0gJ1tvYmplY3QgUmVnRXhwXScgfHwgaXNCc29uVHlwZSh2YWwsICdCU09OUmVnRXhwJykpIHtcbiAgICByZXR1cm4gdmFsO1xuICB9XG5cbiAgdHJ5IHtcbiAgICByZXR1cm4gdGhpcy5hcHBseVNldHRlcnModmFsLCBjb250ZXh0KTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgaWYgKGVyciBpbnN0YW5jZW9mIENhc3RFcnJvciAmJiBlcnIucGF0aCA9PT0gdGhpcy5wYXRoICYmIHRoaXMuJGZ1bGxQYXRoICE9IG51bGwpIHtcbiAgICAgIGVyci5wYXRoID0gdGhpcy4kZnVsbFBhdGg7XG4gICAgfVxuICAgIHRocm93IGVycjtcbiAgfVxufTtcblxuLyohXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNjaGVtYVN0cmluZztcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../server/node_modules/mongoose/lib/schema/string.js\n");

/***/ }),

/***/ "../server/node_modules/mongoose/lib/schema/subdocument.js":
/*!*****************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/schema/subdocument.js ***!
  \*****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\n/*!\n * Module dependencies.\n */\n\nconst CastError = __webpack_require__(/*! ../error/cast */ \"../server/node_modules/mongoose/lib/error/cast.js\");\nconst EventEmitter = (__webpack_require__(/*! events */ \"events\").EventEmitter);\nconst ObjectExpectedError = __webpack_require__(/*! ../error/objectExpected */ \"../server/node_modules/mongoose/lib/error/objectExpected.js\");\nconst SchemaSubdocumentOptions = __webpack_require__(/*! ../options/schemaSubdocumentOptions */ \"../server/node_modules/mongoose/lib/options/schemaSubdocumentOptions.js\");\nconst SchemaType = __webpack_require__(/*! ../schemaType */ \"../server/node_modules/mongoose/lib/schemaType.js\");\nconst applyDefaults = __webpack_require__(/*! ../helpers/document/applyDefaults */ \"../server/node_modules/mongoose/lib/helpers/document/applyDefaults.js\");\nconst $exists = __webpack_require__(/*! ./operators/exists */ \"../server/node_modules/mongoose/lib/schema/operators/exists.js\");\nconst castToNumber = (__webpack_require__(/*! ./operators/helpers */ \"../server/node_modules/mongoose/lib/schema/operators/helpers.js\").castToNumber);\nconst discriminator = __webpack_require__(/*! ../helpers/model/discriminator */ \"../server/node_modules/mongoose/lib/helpers/model/discriminator.js\");\nconst geospatial = __webpack_require__(/*! ./operators/geospatial */ \"../server/node_modules/mongoose/lib/schema/operators/geospatial.js\");\nconst getConstructor = __webpack_require__(/*! ../helpers/discriminator/getConstructor */ \"../server/node_modules/mongoose/lib/helpers/discriminator/getConstructor.js\");\nconst handleIdOption = __webpack_require__(/*! ../helpers/schema/handleIdOption */ \"../server/node_modules/mongoose/lib/helpers/schema/handleIdOption.js\");\nconst internalToObjectOptions = (__webpack_require__(/*! ../options */ \"../server/node_modules/mongoose/lib/options.js\").internalToObjectOptions);\nconst isExclusive = __webpack_require__(/*! ../helpers/projection/isExclusive */ \"../server/node_modules/mongoose/lib/helpers/projection/isExclusive.js\");\nconst utils = __webpack_require__(/*! ../utils */ \"../server/node_modules/mongoose/lib/utils.js\");\nconst InvalidSchemaOptionError = __webpack_require__(/*! ../error/invalidSchemaOption */ \"../server/node_modules/mongoose/lib/error/invalidSchemaOption.js\");\n\nlet SubdocumentType;\n\nmodule.exports = SchemaSubdocument;\n\n/**\n * Single nested subdocument SchemaType constructor.\n *\n * @param {Schema} schema\n * @param {String} path\n * @param {Object} options\n * @inherits SchemaType\n * @api public\n */\n\nfunction SchemaSubdocument(schema, path, options) {\n  if (schema.options.timeseries) {\n    throw new InvalidSchemaOptionError(path, 'timeseries');\n  }\n  const schemaTypeIdOption = SchemaSubdocument.defaultOptions &&\n    SchemaSubdocument.defaultOptions._id;\n  if (schemaTypeIdOption != null) {\n    options = options || {};\n    options._id = schemaTypeIdOption;\n  }\n\n  schema = handleIdOption(schema, options);\n\n  this.caster = _createConstructor(schema, null, options);\n  this.caster.path = path;\n  this.caster.prototype.$basePath = path;\n  this.schema = schema;\n  this.$isSingleNested = true;\n  this.base = schema.base;\n  SchemaType.call(this, path, options, 'Embedded');\n}\n\n/*!\n * ignore\n */\n\nSchemaSubdocument.prototype = Object.create(SchemaType.prototype);\nSchemaSubdocument.prototype.constructor = SchemaSubdocument;\nSchemaSubdocument.prototype.OptionsConstructor = SchemaSubdocumentOptions;\n\n/*!\n * ignore\n */\n\nfunction _createConstructor(schema, baseClass, options) {\n  // lazy load\n  SubdocumentType || (SubdocumentType = __webpack_require__(/*! ../types/subdocument */ \"../server/node_modules/mongoose/lib/types/subdocument.js\"));\n\n  const _embedded = function SingleNested(value, path, parent) {\n    this.$__parent = parent;\n    SubdocumentType.apply(this, arguments);\n\n    if (parent == null) {\n      return;\n    }\n    this.$session(parent.$session());\n  };\n\n  schema._preCompile();\n\n  const proto = baseClass != null ? baseClass.prototype : SubdocumentType.prototype;\n  _embedded.prototype = Object.create(proto);\n  _embedded.prototype.$__setSchema(schema);\n  _embedded.prototype.constructor = _embedded;\n  _embedded.$__required = options?.required;\n  _embedded.base = schema.base;\n  _embedded.schema = schema;\n  _embedded.$isSingleNested = true;\n  _embedded.events = new EventEmitter();\n  _embedded.prototype.toBSON = function() {\n    return this.toObject(internalToObjectOptions);\n  };\n\n  // apply methods\n  for (const i in schema.methods) {\n    _embedded.prototype[i] = schema.methods[i];\n  }\n\n  // apply statics\n  for (const i in schema.statics) {\n    _embedded[i] = schema.statics[i];\n  }\n\n  for (const i in EventEmitter.prototype) {\n    _embedded[i] = EventEmitter.prototype[i];\n  }\n\n  return _embedded;\n}\n\n/**\n * Special case for when users use a common location schema to represent\n * locations for use with $geoWithin.\n * https://www.mongodb.com/docs/manual/reference/operator/query/geoWithin/\n *\n * @param {Object} val\n * @api private\n */\n\nSchemaSubdocument.prototype.$conditionalHandlers.$geoWithin = function handle$geoWithin(val, context) {\n  return { $geometry: this.castForQuery(null, val.$geometry, context) };\n};\n\n/*!\n * ignore\n */\n\nSchemaSubdocument.prototype.$conditionalHandlers.$near =\nSchemaSubdocument.prototype.$conditionalHandlers.$nearSphere = geospatial.cast$near;\n\nSchemaSubdocument.prototype.$conditionalHandlers.$within =\nSchemaSubdocument.prototype.$conditionalHandlers.$geoWithin = geospatial.cast$within;\n\nSchemaSubdocument.prototype.$conditionalHandlers.$geoIntersects =\n  geospatial.cast$geoIntersects;\n\nSchemaSubdocument.prototype.$conditionalHandlers.$minDistance = castToNumber;\nSchemaSubdocument.prototype.$conditionalHandlers.$maxDistance = castToNumber;\n\nSchemaSubdocument.prototype.$conditionalHandlers.$exists = $exists;\n\n/**\n * Casts contents\n *\n * @param {Object} value\n * @api private\n */\n\nSchemaSubdocument.prototype.cast = function(val, doc, init, priorVal, options) {\n  if (val && val.$isSingleNested && val.parent === doc) {\n    return val;\n  }\n\n  if (val != null && (typeof val !== 'object' || Array.isArray(val))) {\n    throw new ObjectExpectedError(this.path, val);\n  }\n\n  const discriminatorKeyPath = this.schema.path(this.schema.options.discriminatorKey);\n  const defaultDiscriminatorValue = discriminatorKeyPath == null ? null : discriminatorKeyPath.getDefault(doc);\n  const Constructor = getConstructor(this.caster, val, defaultDiscriminatorValue);\n\n  let subdoc;\n\n  // Only pull relevant selected paths and pull out the base path\n  const parentSelected = doc && doc.$__ && doc.$__.selected;\n  const path = this.path;\n  const selected = parentSelected == null ? null : Object.keys(parentSelected).reduce((obj, key) => {\n    if (key.startsWith(path + '.')) {\n      obj = obj || {};\n      obj[key.substring(path.length + 1)] = parentSelected[key];\n    }\n    return obj;\n  }, null);\n  if (init) {\n    subdoc = new Constructor(void 0, selected, doc, false, { defaults: false });\n    delete subdoc.$__.defaults;\n    subdoc.$init(val);\n    const exclude = isExclusive(selected);\n    applyDefaults(subdoc, selected, exclude);\n  } else {\n    options = Object.assign({}, options, { priorDoc: priorVal });\n    if (Object.keys(val).length === 0) {\n      return new Constructor({}, selected, doc, undefined, options);\n    }\n\n    return new Constructor(val, selected, doc, undefined, options);\n  }\n\n  return subdoc;\n};\n\n/**\n * Casts contents for query\n *\n * @param {string} [$conditional] optional query operator (like `$eq` or `$in`)\n * @param {any} value\n * @api private\n */\n\nSchemaSubdocument.prototype.castForQuery = function($conditional, val, context, options) {\n  let handler;\n  if ($conditional != null) {\n    handler = this.$conditionalHandlers[$conditional];\n    if (!handler) {\n      throw new Error('Can\\'t use ' + $conditional);\n    }\n    return handler.call(this, val);\n  }\n  if (val == null) {\n    return val;\n  }\n\n  const Constructor = getConstructor(this.caster, val);\n  if (val instanceof Constructor) {\n    return val;\n  }\n\n  if (this.options.runSetters) {\n    val = this._applySetters(val, context);\n  }\n\n  const overrideStrict = options != null && options.strict != null ?\n    options.strict :\n    void 0;\n\n  try {\n    val = new Constructor(val, overrideStrict);\n  } catch (error) {\n    // Make sure we always wrap in a CastError (gh-6803)\n    if (!(error instanceof CastError)) {\n      throw new CastError('Embedded', val, this.path, error, this);\n    }\n    throw error;\n  }\n  return val;\n};\n\n/**\n * Async validation on this single nested doc.\n *\n * @api private\n */\n\nSchemaSubdocument.prototype.doValidate = function(value, fn, scope, options) {\n  const Constructor = getConstructor(this.caster, value);\n\n  if (value && !(value instanceof Constructor)) {\n    value = new Constructor(value, null, (scope != null && scope.$__ != null) ? scope : null);\n  }\n\n  if (options && options.skipSchemaValidators) {\n    if (!value) {\n      return fn(null);\n    }\n    return value.validate().then(() => fn(null), err => fn(err));\n  }\n\n  SchemaType.prototype.doValidate.call(this, value, function(error) {\n    if (error) {\n      return fn(error);\n    }\n    if (!value) {\n      return fn(null);\n    }\n\n    value.validate().then(() => fn(null), err => fn(err));\n  }, scope, options);\n};\n\n/**\n * Synchronously validate this single nested doc\n *\n * @api private\n */\n\nSchemaSubdocument.prototype.doValidateSync = function(value, scope, options) {\n  if (!options || !options.skipSchemaValidators) {\n    const schemaTypeError = SchemaType.prototype.doValidateSync.call(this, value, scope);\n    if (schemaTypeError) {\n      return schemaTypeError;\n    }\n  }\n  if (!value) {\n    return;\n  }\n  return value.validateSync();\n};\n\n/**\n * Adds a discriminator to this single nested subdocument.\n *\n * #### Example:\n *\n *     const shapeSchema = Schema({ name: String }, { discriminatorKey: 'kind' });\n *     const schema = Schema({ shape: shapeSchema });\n *\n *     const singleNestedPath = parentSchema.path('shape');\n *     singleNestedPath.discriminator('Circle', Schema({ radius: Number }));\n *\n * @param {String} name\n * @param {Schema} schema fields to add to the schema for instances of this sub-class\n * @param {Object|string} [options] If string, same as `options.value`.\n * @param {String} [options.value] the string stored in the `discriminatorKey` property. If not specified, Mongoose uses the `name` parameter.\n * @param {Boolean} [options.clone=true] By default, `discriminator()` clones the given `schema`. Set to `false` to skip cloning.\n * @return {Function} the constructor Mongoose will use for creating instances of this discriminator model\n * @see discriminators https://mongoosejs.com/docs/discriminators.html\n * @api public\n */\n\nSchemaSubdocument.prototype.discriminator = function(name, schema, options) {\n  options = options || {};\n  const value = utils.isPOJO(options) ? options.value : options;\n  const clone = typeof options.clone === 'boolean'\n    ? options.clone\n    : true;\n\n  if (schema.instanceOfSchema && clone) {\n    schema = schema.clone();\n  }\n\n  schema = discriminator(this.caster, name, schema, value);\n\n  this.caster.discriminators[name] = _createConstructor(schema, this.caster);\n\n  return this.caster.discriminators[name];\n};\n\n/*!\n * ignore\n */\n\nSchemaSubdocument.defaultOptions = {};\n\n/**\n * Sets a default option for all Subdocument instances.\n *\n * #### Example:\n *\n *     // Make all numbers have option `min` equal to 0.\n *     mongoose.Schema.Subdocument.set('required', true);\n *\n * @param {String} option The option you'd like to set the value for\n * @param {Any} value value for option\n * @return {void}\n * @function set\n * @static\n * @api public\n */\n\nSchemaSubdocument.set = SchemaType.set;\n\nSchemaSubdocument.setters = [];\n\n/**\n * Attaches a getter for all Subdocument instances\n *\n * @param {Function} getter\n * @return {this}\n * @function get\n * @static\n * @api public\n */\n\nSchemaSubdocument.get = SchemaType.get;\n\n/*!\n * ignore\n */\n\nSchemaSubdocument.prototype.toJSON = function toJSON() {\n  return { path: this.path, options: this.options };\n};\n\n/*!\n * ignore\n */\n\nSchemaSubdocument.prototype.clone = function() {\n  const schematype = new this.constructor(\n    this.schema,\n    this.path,\n    { ...this.options, _skipApplyDiscriminators: true }\n  );\n  schematype.validators = this.validators.slice();\n  if (this.requiredValidator !== undefined) {\n    schematype.requiredValidator = this.requiredValidator;\n  }\n  schematype.caster.discriminators = Object.assign({}, this.caster.discriminators);\n  return schematype;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvc2NoZW1hL3N1YmRvY3VtZW50LmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0IsbUJBQU8sQ0FBQyx3RUFBZTtBQUN6QyxxQkFBcUIsMERBQThCO0FBQ25ELDRCQUE0QixtQkFBTyxDQUFDLDRGQUF5QjtBQUM3RCxpQ0FBaUMsbUJBQU8sQ0FBQyxvSEFBcUM7QUFDOUUsbUJBQW1CLG1CQUFPLENBQUMsd0VBQWU7QUFDMUMsc0JBQXNCLG1CQUFPLENBQUMsZ0hBQW1DO0FBQ2pFLGdCQUFnQixtQkFBTyxDQUFDLDBGQUFvQjtBQUM1QyxxQkFBcUIsZ0lBQTJDO0FBQ2hFLHNCQUFzQixtQkFBTyxDQUFDLDBHQUFnQztBQUM5RCxtQkFBbUIsbUJBQU8sQ0FBQyxrR0FBd0I7QUFDbkQsdUJBQXVCLG1CQUFPLENBQUMsNEhBQXlDO0FBQ3hFLHVCQUF1QixtQkFBTyxDQUFDLDhHQUFrQztBQUNqRSxnQ0FBZ0MsaUhBQTZDO0FBQzdFLG9CQUFvQixtQkFBTyxDQUFDLGdIQUFtQztBQUMvRCxjQUFjLG1CQUFPLENBQUMsOERBQVU7QUFDaEMsaUNBQWlDLG1CQUFPLENBQUMsc0dBQThCOztBQUV2RTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esd0NBQXdDLG1CQUFPLENBQUMsc0ZBQXNCOztBQUV0RTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBOztBQUVBO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsNkRBQTZELGlCQUFpQjtBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSiw4QkFBOEIsYUFBYSxvQkFBb0I7QUFDL0Q7QUFDQSwrQkFBK0I7QUFDL0I7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLEtBQUs7QUFDaEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxjQUFjLElBQUksMEJBQTBCO0FBQ2hGLCtCQUErQixvQkFBb0I7QUFDbkQ7QUFDQTtBQUNBLHlEQUF5RCxnQkFBZ0I7QUFDekU7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsZUFBZTtBQUMxQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxTQUFTO0FBQ3BCLFlBQVksVUFBVTtBQUN0QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsS0FBSztBQUNoQixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQ7QUFDckQ7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2NsaWVudC8uLi9zZXJ2ZXIvbm9kZV9tb2R1bGVzL21vbmdvb3NlL2xpYi9zY2hlbWEvc3ViZG9jdW1lbnQuanM/ZmM5ZSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbi8qIVxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG5jb25zdCBDYXN0RXJyb3IgPSByZXF1aXJlKCcuLi9lcnJvci9jYXN0Jyk7XG5jb25zdCBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXI7XG5jb25zdCBPYmplY3RFeHBlY3RlZEVycm9yID0gcmVxdWlyZSgnLi4vZXJyb3Ivb2JqZWN0RXhwZWN0ZWQnKTtcbmNvbnN0IFNjaGVtYVN1YmRvY3VtZW50T3B0aW9ucyA9IHJlcXVpcmUoJy4uL29wdGlvbnMvc2NoZW1hU3ViZG9jdW1lbnRPcHRpb25zJyk7XG5jb25zdCBTY2hlbWFUeXBlID0gcmVxdWlyZSgnLi4vc2NoZW1hVHlwZScpO1xuY29uc3QgYXBwbHlEZWZhdWx0cyA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvZG9jdW1lbnQvYXBwbHlEZWZhdWx0cycpO1xuY29uc3QgJGV4aXN0cyA9IHJlcXVpcmUoJy4vb3BlcmF0b3JzL2V4aXN0cycpO1xuY29uc3QgY2FzdFRvTnVtYmVyID0gcmVxdWlyZSgnLi9vcGVyYXRvcnMvaGVscGVycycpLmNhc3RUb051bWJlcjtcbmNvbnN0IGRpc2NyaW1pbmF0b3IgPSByZXF1aXJlKCcuLi9oZWxwZXJzL21vZGVsL2Rpc2NyaW1pbmF0b3InKTtcbmNvbnN0IGdlb3NwYXRpYWwgPSByZXF1aXJlKCcuL29wZXJhdG9ycy9nZW9zcGF0aWFsJyk7XG5jb25zdCBnZXRDb25zdHJ1Y3RvciA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvZGlzY3JpbWluYXRvci9nZXRDb25zdHJ1Y3RvcicpO1xuY29uc3QgaGFuZGxlSWRPcHRpb24gPSByZXF1aXJlKCcuLi9oZWxwZXJzL3NjaGVtYS9oYW5kbGVJZE9wdGlvbicpO1xuY29uc3QgaW50ZXJuYWxUb09iamVjdE9wdGlvbnMgPSByZXF1aXJlKCcuLi9vcHRpb25zJykuaW50ZXJuYWxUb09iamVjdE9wdGlvbnM7XG5jb25zdCBpc0V4Y2x1c2l2ZSA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvcHJvamVjdGlvbi9pc0V4Y2x1c2l2ZScpO1xuY29uc3QgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscycpO1xuY29uc3QgSW52YWxpZFNjaGVtYU9wdGlvbkVycm9yID0gcmVxdWlyZSgnLi4vZXJyb3IvaW52YWxpZFNjaGVtYU9wdGlvbicpO1xuXG5sZXQgU3ViZG9jdW1lbnRUeXBlO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNjaGVtYVN1YmRvY3VtZW50O1xuXG4vKipcbiAqIFNpbmdsZSBuZXN0ZWQgc3ViZG9jdW1lbnQgU2NoZW1hVHlwZSBjb25zdHJ1Y3Rvci5cbiAqXG4gKiBAcGFyYW0ge1NjaGVtYX0gc2NoZW1hXG4gKiBAcGFyYW0ge1N0cmluZ30gcGF0aFxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEBpbmhlcml0cyBTY2hlbWFUeXBlXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIFNjaGVtYVN1YmRvY3VtZW50KHNjaGVtYSwgcGF0aCwgb3B0aW9ucykge1xuICBpZiAoc2NoZW1hLm9wdGlvbnMudGltZXNlcmllcykge1xuICAgIHRocm93IG5ldyBJbnZhbGlkU2NoZW1hT3B0aW9uRXJyb3IocGF0aCwgJ3RpbWVzZXJpZXMnKTtcbiAgfVxuICBjb25zdCBzY2hlbWFUeXBlSWRPcHRpb24gPSBTY2hlbWFTdWJkb2N1bWVudC5kZWZhdWx0T3B0aW9ucyAmJlxuICAgIFNjaGVtYVN1YmRvY3VtZW50LmRlZmF1bHRPcHRpb25zLl9pZDtcbiAgaWYgKHNjaGVtYVR5cGVJZE9wdGlvbiAhPSBudWxsKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgb3B0aW9ucy5faWQgPSBzY2hlbWFUeXBlSWRPcHRpb247XG4gIH1cblxuICBzY2hlbWEgPSBoYW5kbGVJZE9wdGlvbihzY2hlbWEsIG9wdGlvbnMpO1xuXG4gIHRoaXMuY2FzdGVyID0gX2NyZWF0ZUNvbnN0cnVjdG9yKHNjaGVtYSwgbnVsbCwgb3B0aW9ucyk7XG4gIHRoaXMuY2FzdGVyLnBhdGggPSBwYXRoO1xuICB0aGlzLmNhc3Rlci5wcm90b3R5cGUuJGJhc2VQYXRoID0gcGF0aDtcbiAgdGhpcy5zY2hlbWEgPSBzY2hlbWE7XG4gIHRoaXMuJGlzU2luZ2xlTmVzdGVkID0gdHJ1ZTtcbiAgdGhpcy5iYXNlID0gc2NoZW1hLmJhc2U7XG4gIFNjaGVtYVR5cGUuY2FsbCh0aGlzLCBwYXRoLCBvcHRpb25zLCAnRW1iZWRkZWQnKTtcbn1cblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5TY2hlbWFTdWJkb2N1bWVudC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFNjaGVtYVR5cGUucHJvdG90eXBlKTtcblNjaGVtYVN1YmRvY3VtZW50LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFNjaGVtYVN1YmRvY3VtZW50O1xuU2NoZW1hU3ViZG9jdW1lbnQucHJvdG90eXBlLk9wdGlvbnNDb25zdHJ1Y3RvciA9IFNjaGVtYVN1YmRvY3VtZW50T3B0aW9ucztcblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5mdW5jdGlvbiBfY3JlYXRlQ29uc3RydWN0b3Ioc2NoZW1hLCBiYXNlQ2xhc3MsIG9wdGlvbnMpIHtcbiAgLy8gbGF6eSBsb2FkXG4gIFN1YmRvY3VtZW50VHlwZSB8fCAoU3ViZG9jdW1lbnRUeXBlID0gcmVxdWlyZSgnLi4vdHlwZXMvc3ViZG9jdW1lbnQnKSk7XG5cbiAgY29uc3QgX2VtYmVkZGVkID0gZnVuY3Rpb24gU2luZ2xlTmVzdGVkKHZhbHVlLCBwYXRoLCBwYXJlbnQpIHtcbiAgICB0aGlzLiRfX3BhcmVudCA9IHBhcmVudDtcbiAgICBTdWJkb2N1bWVudFR5cGUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuICAgIGlmIChwYXJlbnQgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLiRzZXNzaW9uKHBhcmVudC4kc2Vzc2lvbigpKTtcbiAgfTtcblxuICBzY2hlbWEuX3ByZUNvbXBpbGUoKTtcblxuICBjb25zdCBwcm90byA9IGJhc2VDbGFzcyAhPSBudWxsID8gYmFzZUNsYXNzLnByb3RvdHlwZSA6IFN1YmRvY3VtZW50VHlwZS5wcm90b3R5cGU7XG4gIF9lbWJlZGRlZC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHByb3RvKTtcbiAgX2VtYmVkZGVkLnByb3RvdHlwZS4kX19zZXRTY2hlbWEoc2NoZW1hKTtcbiAgX2VtYmVkZGVkLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IF9lbWJlZGRlZDtcbiAgX2VtYmVkZGVkLiRfX3JlcXVpcmVkID0gb3B0aW9ucz8ucmVxdWlyZWQ7XG4gIF9lbWJlZGRlZC5iYXNlID0gc2NoZW1hLmJhc2U7XG4gIF9lbWJlZGRlZC5zY2hlbWEgPSBzY2hlbWE7XG4gIF9lbWJlZGRlZC4kaXNTaW5nbGVOZXN0ZWQgPSB0cnVlO1xuICBfZW1iZWRkZWQuZXZlbnRzID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICBfZW1iZWRkZWQucHJvdG90eXBlLnRvQlNPTiA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnRvT2JqZWN0KGludGVybmFsVG9PYmplY3RPcHRpb25zKTtcbiAgfTtcblxuICAvLyBhcHBseSBtZXRob2RzXG4gIGZvciAoY29uc3QgaSBpbiBzY2hlbWEubWV0aG9kcykge1xuICAgIF9lbWJlZGRlZC5wcm90b3R5cGVbaV0gPSBzY2hlbWEubWV0aG9kc1tpXTtcbiAgfVxuXG4gIC8vIGFwcGx5IHN0YXRpY3NcbiAgZm9yIChjb25zdCBpIGluIHNjaGVtYS5zdGF0aWNzKSB7XG4gICAgX2VtYmVkZGVkW2ldID0gc2NoZW1hLnN0YXRpY3NbaV07XG4gIH1cblxuICBmb3IgKGNvbnN0IGkgaW4gRXZlbnRFbWl0dGVyLnByb3RvdHlwZSkge1xuICAgIF9lbWJlZGRlZFtpXSA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGVbaV07XG4gIH1cblxuICByZXR1cm4gX2VtYmVkZGVkO1xufVxuXG4vKipcbiAqIFNwZWNpYWwgY2FzZSBmb3Igd2hlbiB1c2VycyB1c2UgYSBjb21tb24gbG9jYXRpb24gc2NoZW1hIHRvIHJlcHJlc2VudFxuICogbG9jYXRpb25zIGZvciB1c2Ugd2l0aCAkZ2VvV2l0aGluLlxuICogaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvcmVmZXJlbmNlL29wZXJhdG9yL3F1ZXJ5L2dlb1dpdGhpbi9cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5TY2hlbWFTdWJkb2N1bWVudC5wcm90b3R5cGUuJGNvbmRpdGlvbmFsSGFuZGxlcnMuJGdlb1dpdGhpbiA9IGZ1bmN0aW9uIGhhbmRsZSRnZW9XaXRoaW4odmFsLCBjb250ZXh0KSB7XG4gIHJldHVybiB7ICRnZW9tZXRyeTogdGhpcy5jYXN0Rm9yUXVlcnkobnVsbCwgdmFsLiRnZW9tZXRyeSwgY29udGV4dCkgfTtcbn07XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxuU2NoZW1hU3ViZG9jdW1lbnQucHJvdG90eXBlLiRjb25kaXRpb25hbEhhbmRsZXJzLiRuZWFyID1cblNjaGVtYVN1YmRvY3VtZW50LnByb3RvdHlwZS4kY29uZGl0aW9uYWxIYW5kbGVycy4kbmVhclNwaGVyZSA9IGdlb3NwYXRpYWwuY2FzdCRuZWFyO1xuXG5TY2hlbWFTdWJkb2N1bWVudC5wcm90b3R5cGUuJGNvbmRpdGlvbmFsSGFuZGxlcnMuJHdpdGhpbiA9XG5TY2hlbWFTdWJkb2N1bWVudC5wcm90b3R5cGUuJGNvbmRpdGlvbmFsSGFuZGxlcnMuJGdlb1dpdGhpbiA9IGdlb3NwYXRpYWwuY2FzdCR3aXRoaW47XG5cblNjaGVtYVN1YmRvY3VtZW50LnByb3RvdHlwZS4kY29uZGl0aW9uYWxIYW5kbGVycy4kZ2VvSW50ZXJzZWN0cyA9XG4gIGdlb3NwYXRpYWwuY2FzdCRnZW9JbnRlcnNlY3RzO1xuXG5TY2hlbWFTdWJkb2N1bWVudC5wcm90b3R5cGUuJGNvbmRpdGlvbmFsSGFuZGxlcnMuJG1pbkRpc3RhbmNlID0gY2FzdFRvTnVtYmVyO1xuU2NoZW1hU3ViZG9jdW1lbnQucHJvdG90eXBlLiRjb25kaXRpb25hbEhhbmRsZXJzLiRtYXhEaXN0YW5jZSA9IGNhc3RUb051bWJlcjtcblxuU2NoZW1hU3ViZG9jdW1lbnQucHJvdG90eXBlLiRjb25kaXRpb25hbEhhbmRsZXJzLiRleGlzdHMgPSAkZXhpc3RzO1xuXG4vKipcbiAqIENhc3RzIGNvbnRlbnRzXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbHVlXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5TY2hlbWFTdWJkb2N1bWVudC5wcm90b3R5cGUuY2FzdCA9IGZ1bmN0aW9uKHZhbCwgZG9jLCBpbml0LCBwcmlvclZhbCwgb3B0aW9ucykge1xuICBpZiAodmFsICYmIHZhbC4kaXNTaW5nbGVOZXN0ZWQgJiYgdmFsLnBhcmVudCA9PT0gZG9jKSB7XG4gICAgcmV0dXJuIHZhbDtcbiAgfVxuXG4gIGlmICh2YWwgIT0gbnVsbCAmJiAodHlwZW9mIHZhbCAhPT0gJ29iamVjdCcgfHwgQXJyYXkuaXNBcnJheSh2YWwpKSkge1xuICAgIHRocm93IG5ldyBPYmplY3RFeHBlY3RlZEVycm9yKHRoaXMucGF0aCwgdmFsKTtcbiAgfVxuXG4gIGNvbnN0IGRpc2NyaW1pbmF0b3JLZXlQYXRoID0gdGhpcy5zY2hlbWEucGF0aCh0aGlzLnNjaGVtYS5vcHRpb25zLmRpc2NyaW1pbmF0b3JLZXkpO1xuICBjb25zdCBkZWZhdWx0RGlzY3JpbWluYXRvclZhbHVlID0gZGlzY3JpbWluYXRvcktleVBhdGggPT0gbnVsbCA/IG51bGwgOiBkaXNjcmltaW5hdG9yS2V5UGF0aC5nZXREZWZhdWx0KGRvYyk7XG4gIGNvbnN0IENvbnN0cnVjdG9yID0gZ2V0Q29uc3RydWN0b3IodGhpcy5jYXN0ZXIsIHZhbCwgZGVmYXVsdERpc2NyaW1pbmF0b3JWYWx1ZSk7XG5cbiAgbGV0IHN1YmRvYztcblxuICAvLyBPbmx5IHB1bGwgcmVsZXZhbnQgc2VsZWN0ZWQgcGF0aHMgYW5kIHB1bGwgb3V0IHRoZSBiYXNlIHBhdGhcbiAgY29uc3QgcGFyZW50U2VsZWN0ZWQgPSBkb2MgJiYgZG9jLiRfXyAmJiBkb2MuJF9fLnNlbGVjdGVkO1xuICBjb25zdCBwYXRoID0gdGhpcy5wYXRoO1xuICBjb25zdCBzZWxlY3RlZCA9IHBhcmVudFNlbGVjdGVkID09IG51bGwgPyBudWxsIDogT2JqZWN0LmtleXMocGFyZW50U2VsZWN0ZWQpLnJlZHVjZSgob2JqLCBrZXkpID0+IHtcbiAgICBpZiAoa2V5LnN0YXJ0c1dpdGgocGF0aCArICcuJykpIHtcbiAgICAgIG9iaiA9IG9iaiB8fCB7fTtcbiAgICAgIG9ialtrZXkuc3Vic3RyaW5nKHBhdGgubGVuZ3RoICsgMSldID0gcGFyZW50U2VsZWN0ZWRba2V5XTtcbiAgICB9XG4gICAgcmV0dXJuIG9iajtcbiAgfSwgbnVsbCk7XG4gIGlmIChpbml0KSB7XG4gICAgc3ViZG9jID0gbmV3IENvbnN0cnVjdG9yKHZvaWQgMCwgc2VsZWN0ZWQsIGRvYywgZmFsc2UsIHsgZGVmYXVsdHM6IGZhbHNlIH0pO1xuICAgIGRlbGV0ZSBzdWJkb2MuJF9fLmRlZmF1bHRzO1xuICAgIHN1YmRvYy4kaW5pdCh2YWwpO1xuICAgIGNvbnN0IGV4Y2x1ZGUgPSBpc0V4Y2x1c2l2ZShzZWxlY3RlZCk7XG4gICAgYXBwbHlEZWZhdWx0cyhzdWJkb2MsIHNlbGVjdGVkLCBleGNsdWRlKTtcbiAgfSBlbHNlIHtcbiAgICBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucywgeyBwcmlvckRvYzogcHJpb3JWYWwgfSk7XG4gICAgaWYgKE9iamVjdC5rZXlzKHZhbCkubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gbmV3IENvbnN0cnVjdG9yKHt9LCBzZWxlY3RlZCwgZG9jLCB1bmRlZmluZWQsIG9wdGlvbnMpO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgQ29uc3RydWN0b3IodmFsLCBzZWxlY3RlZCwgZG9jLCB1bmRlZmluZWQsIG9wdGlvbnMpO1xuICB9XG5cbiAgcmV0dXJuIHN1YmRvYztcbn07XG5cbi8qKlxuICogQ2FzdHMgY29udGVudHMgZm9yIHF1ZXJ5XG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IFskY29uZGl0aW9uYWxdIG9wdGlvbmFsIHF1ZXJ5IG9wZXJhdG9yIChsaWtlIGAkZXFgIG9yIGAkaW5gKVxuICogQHBhcmFtIHthbnl9IHZhbHVlXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5TY2hlbWFTdWJkb2N1bWVudC5wcm90b3R5cGUuY2FzdEZvclF1ZXJ5ID0gZnVuY3Rpb24oJGNvbmRpdGlvbmFsLCB2YWwsIGNvbnRleHQsIG9wdGlvbnMpIHtcbiAgbGV0IGhhbmRsZXI7XG4gIGlmICgkY29uZGl0aW9uYWwgIT0gbnVsbCkge1xuICAgIGhhbmRsZXIgPSB0aGlzLiRjb25kaXRpb25hbEhhbmRsZXJzWyRjb25kaXRpb25hbF07XG4gICAgaWYgKCFoYW5kbGVyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NhblxcJ3QgdXNlICcgKyAkY29uZGl0aW9uYWwpO1xuICAgIH1cbiAgICByZXR1cm4gaGFuZGxlci5jYWxsKHRoaXMsIHZhbCk7XG4gIH1cbiAgaWYgKHZhbCA9PSBudWxsKSB7XG4gICAgcmV0dXJuIHZhbDtcbiAgfVxuXG4gIGNvbnN0IENvbnN0cnVjdG9yID0gZ2V0Q29uc3RydWN0b3IodGhpcy5jYXN0ZXIsIHZhbCk7XG4gIGlmICh2YWwgaW5zdGFuY2VvZiBDb25zdHJ1Y3Rvcikge1xuICAgIHJldHVybiB2YWw7XG4gIH1cblxuICBpZiAodGhpcy5vcHRpb25zLnJ1blNldHRlcnMpIHtcbiAgICB2YWwgPSB0aGlzLl9hcHBseVNldHRlcnModmFsLCBjb250ZXh0KTtcbiAgfVxuXG4gIGNvbnN0IG92ZXJyaWRlU3RyaWN0ID0gb3B0aW9ucyAhPSBudWxsICYmIG9wdGlvbnMuc3RyaWN0ICE9IG51bGwgP1xuICAgIG9wdGlvbnMuc3RyaWN0IDpcbiAgICB2b2lkIDA7XG5cbiAgdHJ5IHtcbiAgICB2YWwgPSBuZXcgQ29uc3RydWN0b3IodmFsLCBvdmVycmlkZVN0cmljdCk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgLy8gTWFrZSBzdXJlIHdlIGFsd2F5cyB3cmFwIGluIGEgQ2FzdEVycm9yIChnaC02ODAzKVxuICAgIGlmICghKGVycm9yIGluc3RhbmNlb2YgQ2FzdEVycm9yKSkge1xuICAgICAgdGhyb3cgbmV3IENhc3RFcnJvcignRW1iZWRkZWQnLCB2YWwsIHRoaXMucGF0aCwgZXJyb3IsIHRoaXMpO1xuICAgIH1cbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxuICByZXR1cm4gdmFsO1xufTtcblxuLyoqXG4gKiBBc3luYyB2YWxpZGF0aW9uIG9uIHRoaXMgc2luZ2xlIG5lc3RlZCBkb2MuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU2NoZW1hU3ViZG9jdW1lbnQucHJvdG90eXBlLmRvVmFsaWRhdGUgPSBmdW5jdGlvbih2YWx1ZSwgZm4sIHNjb3BlLCBvcHRpb25zKSB7XG4gIGNvbnN0IENvbnN0cnVjdG9yID0gZ2V0Q29uc3RydWN0b3IodGhpcy5jYXN0ZXIsIHZhbHVlKTtcblxuICBpZiAodmFsdWUgJiYgISh2YWx1ZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkge1xuICAgIHZhbHVlID0gbmV3IENvbnN0cnVjdG9yKHZhbHVlLCBudWxsLCAoc2NvcGUgIT0gbnVsbCAmJiBzY29wZS4kX18gIT0gbnVsbCkgPyBzY29wZSA6IG51bGwpO1xuICB9XG5cbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5za2lwU2NoZW1hVmFsaWRhdG9ycykge1xuICAgIGlmICghdmFsdWUpIHtcbiAgICAgIHJldHVybiBmbihudWxsKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlLnZhbGlkYXRlKCkudGhlbigoKSA9PiBmbihudWxsKSwgZXJyID0+IGZuKGVycikpO1xuICB9XG5cbiAgU2NoZW1hVHlwZS5wcm90b3R5cGUuZG9WYWxpZGF0ZS5jYWxsKHRoaXMsIHZhbHVlLCBmdW5jdGlvbihlcnJvcikge1xuICAgIGlmIChlcnJvcikge1xuICAgICAgcmV0dXJuIGZuKGVycm9yKTtcbiAgICB9XG4gICAgaWYgKCF2YWx1ZSkge1xuICAgICAgcmV0dXJuIGZuKG51bGwpO1xuICAgIH1cblxuICAgIHZhbHVlLnZhbGlkYXRlKCkudGhlbigoKSA9PiBmbihudWxsKSwgZXJyID0+IGZuKGVycikpO1xuICB9LCBzY29wZSwgb3B0aW9ucyk7XG59O1xuXG4vKipcbiAqIFN5bmNocm9ub3VzbHkgdmFsaWRhdGUgdGhpcyBzaW5nbGUgbmVzdGVkIGRvY1xuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNjaGVtYVN1YmRvY3VtZW50LnByb3RvdHlwZS5kb1ZhbGlkYXRlU3luYyA9IGZ1bmN0aW9uKHZhbHVlLCBzY29wZSwgb3B0aW9ucykge1xuICBpZiAoIW9wdGlvbnMgfHwgIW9wdGlvbnMuc2tpcFNjaGVtYVZhbGlkYXRvcnMpIHtcbiAgICBjb25zdCBzY2hlbWFUeXBlRXJyb3IgPSBTY2hlbWFUeXBlLnByb3RvdHlwZS5kb1ZhbGlkYXRlU3luYy5jYWxsKHRoaXMsIHZhbHVlLCBzY29wZSk7XG4gICAgaWYgKHNjaGVtYVR5cGVFcnJvcikge1xuICAgICAgcmV0dXJuIHNjaGVtYVR5cGVFcnJvcjtcbiAgICB9XG4gIH1cbiAgaWYgKCF2YWx1ZSkge1xuICAgIHJldHVybjtcbiAgfVxuICByZXR1cm4gdmFsdWUudmFsaWRhdGVTeW5jKCk7XG59O1xuXG4vKipcbiAqIEFkZHMgYSBkaXNjcmltaW5hdG9yIHRvIHRoaXMgc2luZ2xlIG5lc3RlZCBzdWJkb2N1bWVudC5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IHNoYXBlU2NoZW1hID0gU2NoZW1hKHsgbmFtZTogU3RyaW5nIH0sIHsgZGlzY3JpbWluYXRvcktleTogJ2tpbmQnIH0pO1xuICogICAgIGNvbnN0IHNjaGVtYSA9IFNjaGVtYSh7IHNoYXBlOiBzaGFwZVNjaGVtYSB9KTtcbiAqXG4gKiAgICAgY29uc3Qgc2luZ2xlTmVzdGVkUGF0aCA9IHBhcmVudFNjaGVtYS5wYXRoKCdzaGFwZScpO1xuICogICAgIHNpbmdsZU5lc3RlZFBhdGguZGlzY3JpbWluYXRvcignQ2lyY2xlJywgU2NoZW1hKHsgcmFkaXVzOiBOdW1iZXIgfSkpO1xuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gKiBAcGFyYW0ge1NjaGVtYX0gc2NoZW1hIGZpZWxkcyB0byBhZGQgdG8gdGhlIHNjaGVtYSBmb3IgaW5zdGFuY2VzIG9mIHRoaXMgc3ViLWNsYXNzXG4gKiBAcGFyYW0ge09iamVjdHxzdHJpbmd9IFtvcHRpb25zXSBJZiBzdHJpbmcsIHNhbWUgYXMgYG9wdGlvbnMudmFsdWVgLlxuICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLnZhbHVlXSB0aGUgc3RyaW5nIHN0b3JlZCBpbiB0aGUgYGRpc2NyaW1pbmF0b3JLZXlgIHByb3BlcnR5LiBJZiBub3Qgc3BlY2lmaWVkLCBNb25nb29zZSB1c2VzIHRoZSBgbmFtZWAgcGFyYW1ldGVyLlxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5jbG9uZT10cnVlXSBCeSBkZWZhdWx0LCBgZGlzY3JpbWluYXRvcigpYCBjbG9uZXMgdGhlIGdpdmVuIGBzY2hlbWFgLiBTZXQgdG8gYGZhbHNlYCB0byBza2lwIGNsb25pbmcuXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn0gdGhlIGNvbnN0cnVjdG9yIE1vbmdvb3NlIHdpbGwgdXNlIGZvciBjcmVhdGluZyBpbnN0YW5jZXMgb2YgdGhpcyBkaXNjcmltaW5hdG9yIG1vZGVsXG4gKiBAc2VlIGRpc2NyaW1pbmF0b3JzIGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9kaXNjcmltaW5hdG9ycy5odG1sXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblNjaGVtYVN1YmRvY3VtZW50LnByb3RvdHlwZS5kaXNjcmltaW5hdG9yID0gZnVuY3Rpb24obmFtZSwgc2NoZW1hLCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBjb25zdCB2YWx1ZSA9IHV0aWxzLmlzUE9KTyhvcHRpb25zKSA/IG9wdGlvbnMudmFsdWUgOiBvcHRpb25zO1xuICBjb25zdCBjbG9uZSA9IHR5cGVvZiBvcHRpb25zLmNsb25lID09PSAnYm9vbGVhbidcbiAgICA/IG9wdGlvbnMuY2xvbmVcbiAgICA6IHRydWU7XG5cbiAgaWYgKHNjaGVtYS5pbnN0YW5jZU9mU2NoZW1hICYmIGNsb25lKSB7XG4gICAgc2NoZW1hID0gc2NoZW1hLmNsb25lKCk7XG4gIH1cblxuICBzY2hlbWEgPSBkaXNjcmltaW5hdG9yKHRoaXMuY2FzdGVyLCBuYW1lLCBzY2hlbWEsIHZhbHVlKTtcblxuICB0aGlzLmNhc3Rlci5kaXNjcmltaW5hdG9yc1tuYW1lXSA9IF9jcmVhdGVDb25zdHJ1Y3RvcihzY2hlbWEsIHRoaXMuY2FzdGVyKTtcblxuICByZXR1cm4gdGhpcy5jYXN0ZXIuZGlzY3JpbWluYXRvcnNbbmFtZV07XG59O1xuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cblNjaGVtYVN1YmRvY3VtZW50LmRlZmF1bHRPcHRpb25zID0ge307XG5cbi8qKlxuICogU2V0cyBhIGRlZmF1bHQgb3B0aW9uIGZvciBhbGwgU3ViZG9jdW1lbnQgaW5zdGFuY2VzLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgLy8gTWFrZSBhbGwgbnVtYmVycyBoYXZlIG9wdGlvbiBgbWluYCBlcXVhbCB0byAwLlxuICogICAgIG1vbmdvb3NlLlNjaGVtYS5TdWJkb2N1bWVudC5zZXQoJ3JlcXVpcmVkJywgdHJ1ZSk7XG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG9wdGlvbiBUaGUgb3B0aW9uIHlvdSdkIGxpa2UgdG8gc2V0IHRoZSB2YWx1ZSBmb3JcbiAqIEBwYXJhbSB7QW55fSB2YWx1ZSB2YWx1ZSBmb3Igb3B0aW9uXG4gKiBAcmV0dXJuIHt2b2lkfVxuICogQGZ1bmN0aW9uIHNldFxuICogQHN0YXRpY1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5TY2hlbWFTdWJkb2N1bWVudC5zZXQgPSBTY2hlbWFUeXBlLnNldDtcblxuU2NoZW1hU3ViZG9jdW1lbnQuc2V0dGVycyA9IFtdO1xuXG4vKipcbiAqIEF0dGFjaGVzIGEgZ2V0dGVyIGZvciBhbGwgU3ViZG9jdW1lbnQgaW5zdGFuY2VzXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZ2V0dGVyXG4gKiBAcmV0dXJuIHt0aGlzfVxuICogQGZ1bmN0aW9uIGdldFxuICogQHN0YXRpY1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5TY2hlbWFTdWJkb2N1bWVudC5nZXQgPSBTY2hlbWFUeXBlLmdldDtcblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5TY2hlbWFTdWJkb2N1bWVudC5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OKCkge1xuICByZXR1cm4geyBwYXRoOiB0aGlzLnBhdGgsIG9wdGlvbnM6IHRoaXMub3B0aW9ucyB9O1xufTtcblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5TY2hlbWFTdWJkb2N1bWVudC5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbigpIHtcbiAgY29uc3Qgc2NoZW1hdHlwZSA9IG5ldyB0aGlzLmNvbnN0cnVjdG9yKFxuICAgIHRoaXMuc2NoZW1hLFxuICAgIHRoaXMucGF0aCxcbiAgICB7IC4uLnRoaXMub3B0aW9ucywgX3NraXBBcHBseURpc2NyaW1pbmF0b3JzOiB0cnVlIH1cbiAgKTtcbiAgc2NoZW1hdHlwZS52YWxpZGF0b3JzID0gdGhpcy52YWxpZGF0b3JzLnNsaWNlKCk7XG4gIGlmICh0aGlzLnJlcXVpcmVkVmFsaWRhdG9yICE9PSB1bmRlZmluZWQpIHtcbiAgICBzY2hlbWF0eXBlLnJlcXVpcmVkVmFsaWRhdG9yID0gdGhpcy5yZXF1aXJlZFZhbGlkYXRvcjtcbiAgfVxuICBzY2hlbWF0eXBlLmNhc3Rlci5kaXNjcmltaW5hdG9ycyA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMuY2FzdGVyLmRpc2NyaW1pbmF0b3JzKTtcbiAgcmV0dXJuIHNjaGVtYXR5cGU7XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../server/node_modules/mongoose/lib/schema/subdocument.js\n");

/***/ }),

/***/ "../server/node_modules/mongoose/lib/schema/symbols.js":
/*!*************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/schema/symbols.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\nexports.schemaMixedSymbol = Symbol.for('mongoose:schema_mixed');\n\nexports.builtInMiddleware = Symbol.for('mongoose:built-in-middleware');\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvc2NoZW1hL3N5bWJvbHMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIseUJBQXlCOztBQUV6Qix5QkFBeUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbGllbnQvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvc2NoZW1hL3N5bWJvbHMuanM/NzA4YSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuc2NoZW1hTWl4ZWRTeW1ib2wgPSBTeW1ib2wuZm9yKCdtb25nb29zZTpzY2hlbWFfbWl4ZWQnKTtcblxuZXhwb3J0cy5idWlsdEluTWlkZGxld2FyZSA9IFN5bWJvbC5mb3IoJ21vbmdvb3NlOmJ1aWx0LWluLW1pZGRsZXdhcmUnKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../server/node_modules/mongoose/lib/schema/symbols.js\n");

/***/ }),

/***/ "../server/node_modules/mongoose/lib/schema/uuid.js":
/*!**********************************************************!*\
  !*** ../server/node_modules/mongoose/lib/schema/uuid.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*!\n * Module dependencies.\n */\n\n\n\nconst MongooseBuffer = __webpack_require__(/*! ../types/buffer */ \"../server/node_modules/mongoose/lib/types/buffer.js\");\nconst SchemaType = __webpack_require__(/*! ../schemaType */ \"../server/node_modules/mongoose/lib/schemaType.js\");\nconst CastError = SchemaType.CastError;\nconst utils = __webpack_require__(/*! ../utils */ \"../server/node_modules/mongoose/lib/utils.js\");\nconst handleBitwiseOperator = __webpack_require__(/*! ./operators/bitwise */ \"../server/node_modules/mongoose/lib/schema/operators/bitwise.js\");\n\nconst UUID_FORMAT = /[0-9a-f]{8}-[0-9a-f]{4}-[0-9][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}/i;\nconst Binary = MongooseBuffer.Binary;\n\n/**\n * Helper function to convert the input hex-string to a buffer\n * @param {String} hex The hex string to convert\n * @returns {Buffer} The hex as buffer\n * @api private\n */\n\nfunction hex2buffer(hex) {\n  // use buffer built-in function to convert from hex-string to buffer\n  const buff = hex != null && Buffer.from(hex, 'hex');\n  return buff;\n}\n\n/**\n * Helper function to convert the buffer input to a string\n * @param {Buffer} buf The buffer to convert to a hex-string\n * @returns {String} The buffer as a hex-string\n * @api private\n */\n\nfunction binary2hex(buf) {\n  // use buffer built-in function to convert from buffer to hex-string\n  const hex = buf != null && buf.toString('hex');\n  return hex;\n}\n\n/**\n * Convert a String to Binary\n * @param {String} uuidStr The value to process\n * @returns {MongooseBuffer} The binary to store\n * @api private\n */\n\nfunction stringToBinary(uuidStr) {\n  // Protect against undefined & throwing err\n  if (typeof uuidStr !== 'string') uuidStr = '';\n  const hex = uuidStr.replace(/[{}-]/g, ''); // remove extra characters\n  const bytes = hex2buffer(hex);\n  const buff = new MongooseBuffer(bytes);\n  buff._subtype = 4;\n\n  return buff;\n}\n\n/**\n * Convert binary to a uuid string\n * @param {Buffer|Binary|String} uuidBin The value to process\n * @returns {String} The completed uuid-string\n * @api private\n */\nfunction binaryToString(uuidBin) {\n  // i(hasezoey) dont quite know why, but \"uuidBin\" may sometimes also be the already processed string\n  let hex;\n  if (typeof uuidBin !== 'string' && uuidBin != null) {\n    hex = binary2hex(uuidBin);\n    const uuidStr = hex.substring(0, 8) + '-' + hex.substring(8, 8 + 4) + '-' + hex.substring(12, 12 + 4) + '-' + hex.substring(16, 16 + 4) + '-' + hex.substring(20, 20 + 12);\n    return uuidStr;\n  }\n  return uuidBin;\n}\n\n/**\n * UUIDv1 SchemaType constructor.\n *\n * @param {String} key\n * @param {Object} options\n * @inherits SchemaType\n * @api public\n */\n\nfunction SchemaUUID(key, options) {\n  SchemaType.call(this, key, options, 'UUID');\n  this.getters.push(function(value) {\n    // For populated\n    if (value != null && value.$__ != null) {\n      return value;\n    }\n    return binaryToString(value);\n  });\n}\n\n/**\n * This schema type's name, to defend against minifiers that mangle\n * function names.\n *\n * @api public\n */\nSchemaUUID.schemaName = 'UUID';\n\nSchemaUUID.defaultOptions = {};\n\n/*!\n * Inherits from SchemaType.\n */\nSchemaUUID.prototype = Object.create(SchemaType.prototype);\nSchemaUUID.prototype.constructor = SchemaUUID;\n\n/*!\n * ignore\n */\n\nSchemaUUID._cast = function(value) {\n  if (value == null) {\n    return value;\n  }\n\n  function newBuffer(initbuff) {\n    const buff = new MongooseBuffer(initbuff);\n    buff._subtype = 4;\n    return buff;\n  }\n\n  if (typeof value === 'string') {\n    if (UUID_FORMAT.test(value)) {\n      return stringToBinary(value);\n    } else {\n      throw new CastError(SchemaUUID.schemaName, value, this.path);\n    }\n  }\n\n  if (Buffer.isBuffer(value)) {\n    return newBuffer(value);\n  }\n\n  if (value instanceof Binary) {\n    return newBuffer(value.value(true));\n  }\n\n  // Re: gh-647 and gh-3030, we're ok with casting using `toString()`\n  // **unless** its the default Object.toString, because \"[object Object]\"\n  // doesn't really qualify as useful data\n  if (value.toString && value.toString !== Object.prototype.toString) {\n    if (UUID_FORMAT.test(value.toString())) {\n      return stringToBinary(value.toString());\n    }\n  }\n\n  throw new CastError(SchemaUUID.schemaName, value, this.path);\n};\n\n/**\n * Attaches a getter for all UUID instances.\n *\n * #### Example:\n *\n *     // Note that `v` is a string by default\n *     mongoose.Schema.UUID.get(v => v.toUpperCase());\n *\n *     const Model = mongoose.model('Test', new Schema({ test: 'UUID' }));\n *     new Model({ test: uuid.v4() }).test; // UUID with all uppercase\n *\n * @param {Function} getter\n * @return {this}\n * @function get\n * @static\n * @api public\n */\n\nSchemaUUID.get = SchemaType.get;\n\n/**\n * Sets a default option for all UUID instances.\n *\n * #### Example:\n *\n *     // Make all UUIDs have `required` of true by default.\n *     mongoose.Schema.UUID.set('required', true);\n *\n *     const User = mongoose.model('User', new Schema({ test: mongoose.UUID }));\n *     new User({ }).validateSync().errors.test.message; // Path `test` is required.\n *\n * @param {String} option The option you'd like to set the value for\n * @param {Any} value value for option\n * @return {undefined}\n * @function set\n * @static\n * @api public\n */\n\nSchemaUUID.set = SchemaType.set;\n\nSchemaUUID.setters = [];\n\n/**\n * Get/set the function used to cast arbitrary values to UUIDs.\n *\n * #### Example:\n *\n *     // Make Mongoose refuse to cast UUIDs with 0 length\n *     const original = mongoose.Schema.Types.UUID.cast();\n *     mongoose.UUID.cast(v => {\n *       assert.ok(typeof v === \"string\" && v.length > 0);\n *       return original(v);\n *     });\n *\n *     // Or disable casting entirely\n *     mongoose.UUID.cast(false);\n *\n * @param {Function} [caster]\n * @return {Function}\n * @function get\n * @static\n * @api public\n */\n\nSchemaUUID.cast = function cast(caster) {\n  if (arguments.length === 0) {\n    return this._cast;\n  }\n  if (caster === false) {\n    caster = this._defaultCaster;\n  }\n  this._cast = caster;\n\n  return this._cast;\n};\n\n/*!\n * ignore\n */\n\nSchemaUUID._checkRequired = v => v != null;\n\n/**\n * Override the function the required validator uses to check whether a string\n * passes the `required` check.\n *\n * @param {Function} fn\n * @return {Function}\n * @function checkRequired\n * @static\n * @api public\n */\n\nSchemaUUID.checkRequired = SchemaType.checkRequired;\n\n/**\n * Check if the given value satisfies a required validator.\n *\n * @param {Any} value\n * @return {Boolean}\n * @api public\n */\n\nSchemaUUID.prototype.checkRequired = function checkRequired(value) {\n  if (Buffer.isBuffer(value)) {\n    value = binaryToString(value);\n  }\n  return value != null && UUID_FORMAT.test(value);\n};\n\n/**\n * Casts to UUID\n *\n * @param {Object} value\n * @param {Object} doc\n * @param {Boolean} init whether this is an initialization cast\n * @api private\n */\n\nSchemaUUID.prototype.cast = function(value, doc, init) {\n  if (utils.isNonBuiltinObject(value) &&\n      SchemaType._isRef(this, value, doc, init)) {\n    return this._castRef(value, doc, init);\n  }\n\n  let castFn;\n  if (typeof this._castFunction === 'function') {\n    castFn = this._castFunction;\n  } else if (typeof this.constructor.cast === 'function') {\n    castFn = this.constructor.cast();\n  } else {\n    castFn = SchemaUUID.cast();\n  }\n\n  try {\n    return castFn(value);\n  } catch (error) {\n    throw new CastError(SchemaUUID.schemaName, value, this.path, error, this);\n  }\n};\n\n/*!\n * ignore\n */\n\nfunction handleSingle(val) {\n  return this.cast(val);\n}\n\n/*!\n * ignore\n */\n\nfunction handleArray(val) {\n  return val.map((m) => {\n    return this.cast(m);\n  });\n}\n\nSchemaUUID.prototype.$conditionalHandlers = {\n  ...SchemaType.prototype.$conditionalHandlers,\n  $bitsAllClear: handleBitwiseOperator,\n  $bitsAnyClear: handleBitwiseOperator,\n  $bitsAllSet: handleBitwiseOperator,\n  $bitsAnySet: handleBitwiseOperator,\n  $all: handleArray,\n  $gt: handleSingle,\n  $gte: handleSingle,\n  $in: handleArray,\n  $lt: handleSingle,\n  $lte: handleSingle,\n  $ne: handleSingle,\n  $nin: handleArray\n};\n\n/**\n * Casts contents for queries.\n *\n * @param {String} $conditional\n * @param {any} val\n * @api private\n */\n\nSchemaUUID.prototype.castForQuery = function($conditional, val, context) {\n  let handler;\n  if ($conditional != null) {\n    handler = this.$conditionalHandlers[$conditional];\n    if (!handler)\n      throw new Error('Can\\'t use ' + $conditional + ' with UUID.');\n    return handler.call(this, val, context);\n  }\n\n  try {\n    return this.applySetters(val, context);\n  } catch (err) {\n    if (err instanceof CastError && err.path === this.path && this.$fullPath != null) {\n      err.path = this.$fullPath;\n    }\n    throw err;\n  }\n};\n\n/*!\n * Module exports.\n */\n\nmodule.exports = SchemaUUID;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvc2NoZW1hL3V1aWQuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBOztBQUVhOztBQUViLHVCQUF1QixtQkFBTyxDQUFDLDRFQUFpQjtBQUNoRCxtQkFBbUIsbUJBQU8sQ0FBQyx3RUFBZTtBQUMxQztBQUNBLGNBQWMsbUJBQU8sQ0FBQyw4REFBVTtBQUNoQyw4QkFBOEIsbUJBQU8sQ0FBQyw0RkFBcUI7O0FBRTNELDhCQUE4QixFQUFFLFVBQVUsRUFBRSxlQUFlLEVBQUUsZ0JBQWdCLEVBQUUsVUFBVSxHQUFHO0FBQzVGOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWEsUUFBUTtBQUNyQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhLGdCQUFnQjtBQUM3QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxXQUFXO0FBQzdDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLHNCQUFzQjtBQUNqQyxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsY0FBYztBQUN2RSxtQkFBbUIsaUJBQWlCLFFBQVE7QUFDNUM7QUFDQSxXQUFXLFVBQVU7QUFDckIsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0QscUJBQXFCO0FBQzdFLG1CQUFtQixzQ0FBc0M7QUFDekQ7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxLQUFLO0FBQ2hCLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsVUFBVTtBQUNyQixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsVUFBVTtBQUNyQixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsU0FBUztBQUNwQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxLQUFLO0FBQ2hCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbGllbnQvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvc2NoZW1hL3V1aWQuanM/NzE2YyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBNb25nb29zZUJ1ZmZlciA9IHJlcXVpcmUoJy4uL3R5cGVzL2J1ZmZlcicpO1xuY29uc3QgU2NoZW1hVHlwZSA9IHJlcXVpcmUoJy4uL3NjaGVtYVR5cGUnKTtcbmNvbnN0IENhc3RFcnJvciA9IFNjaGVtYVR5cGUuQ2FzdEVycm9yO1xuY29uc3QgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscycpO1xuY29uc3QgaGFuZGxlQml0d2lzZU9wZXJhdG9yID0gcmVxdWlyZSgnLi9vcGVyYXRvcnMvYml0d2lzZScpO1xuXG5jb25zdCBVVUlEX0ZPUk1BVCA9IC9bMC05YS1mXXs4fS1bMC05YS1mXXs0fS1bMC05XVswLTlhLWZdezN9LVs4OWFiXVswLTlhLWZdezN9LVswLTlhLWZdezEyfS9pO1xuY29uc3QgQmluYXJ5ID0gTW9uZ29vc2VCdWZmZXIuQmluYXJ5O1xuXG4vKipcbiAqIEhlbHBlciBmdW5jdGlvbiB0byBjb252ZXJ0IHRoZSBpbnB1dCBoZXgtc3RyaW5nIHRvIGEgYnVmZmVyXG4gKiBAcGFyYW0ge1N0cmluZ30gaGV4IFRoZSBoZXggc3RyaW5nIHRvIGNvbnZlcnRcbiAqIEByZXR1cm5zIHtCdWZmZXJ9IFRoZSBoZXggYXMgYnVmZmVyXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBoZXgyYnVmZmVyKGhleCkge1xuICAvLyB1c2UgYnVmZmVyIGJ1aWx0LWluIGZ1bmN0aW9uIHRvIGNvbnZlcnQgZnJvbSBoZXgtc3RyaW5nIHRvIGJ1ZmZlclxuICBjb25zdCBidWZmID0gaGV4ICE9IG51bGwgJiYgQnVmZmVyLmZyb20oaGV4LCAnaGV4Jyk7XG4gIHJldHVybiBidWZmO1xufVxuXG4vKipcbiAqIEhlbHBlciBmdW5jdGlvbiB0byBjb252ZXJ0IHRoZSBidWZmZXIgaW5wdXQgdG8gYSBzdHJpbmdcbiAqIEBwYXJhbSB7QnVmZmVyfSBidWYgVGhlIGJ1ZmZlciB0byBjb252ZXJ0IHRvIGEgaGV4LXN0cmluZ1xuICogQHJldHVybnMge1N0cmluZ30gVGhlIGJ1ZmZlciBhcyBhIGhleC1zdHJpbmdcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGJpbmFyeTJoZXgoYnVmKSB7XG4gIC8vIHVzZSBidWZmZXIgYnVpbHQtaW4gZnVuY3Rpb24gdG8gY29udmVydCBmcm9tIGJ1ZmZlciB0byBoZXgtc3RyaW5nXG4gIGNvbnN0IGhleCA9IGJ1ZiAhPSBudWxsICYmIGJ1Zi50b1N0cmluZygnaGV4Jyk7XG4gIHJldHVybiBoZXg7XG59XG5cbi8qKlxuICogQ29udmVydCBhIFN0cmluZyB0byBCaW5hcnlcbiAqIEBwYXJhbSB7U3RyaW5nfSB1dWlkU3RyIFRoZSB2YWx1ZSB0byBwcm9jZXNzXG4gKiBAcmV0dXJucyB7TW9uZ29vc2VCdWZmZXJ9IFRoZSBiaW5hcnkgdG8gc3RvcmVcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHN0cmluZ1RvQmluYXJ5KHV1aWRTdHIpIHtcbiAgLy8gUHJvdGVjdCBhZ2FpbnN0IHVuZGVmaW5lZCAmIHRocm93aW5nIGVyclxuICBpZiAodHlwZW9mIHV1aWRTdHIgIT09ICdzdHJpbmcnKSB1dWlkU3RyID0gJyc7XG4gIGNvbnN0IGhleCA9IHV1aWRTdHIucmVwbGFjZSgvW3t9LV0vZywgJycpOyAvLyByZW1vdmUgZXh0cmEgY2hhcmFjdGVyc1xuICBjb25zdCBieXRlcyA9IGhleDJidWZmZXIoaGV4KTtcbiAgY29uc3QgYnVmZiA9IG5ldyBNb25nb29zZUJ1ZmZlcihieXRlcyk7XG4gIGJ1ZmYuX3N1YnR5cGUgPSA0O1xuXG4gIHJldHVybiBidWZmO1xufVxuXG4vKipcbiAqIENvbnZlcnQgYmluYXJ5IHRvIGEgdXVpZCBzdHJpbmdcbiAqIEBwYXJhbSB7QnVmZmVyfEJpbmFyeXxTdHJpbmd9IHV1aWRCaW4gVGhlIHZhbHVlIHRvIHByb2Nlc3NcbiAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBjb21wbGV0ZWQgdXVpZC1zdHJpbmdcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBiaW5hcnlUb1N0cmluZyh1dWlkQmluKSB7XG4gIC8vIGkoaGFzZXpvZXkpIGRvbnQgcXVpdGUga25vdyB3aHksIGJ1dCBcInV1aWRCaW5cIiBtYXkgc29tZXRpbWVzIGFsc28gYmUgdGhlIGFscmVhZHkgcHJvY2Vzc2VkIHN0cmluZ1xuICBsZXQgaGV4O1xuICBpZiAodHlwZW9mIHV1aWRCaW4gIT09ICdzdHJpbmcnICYmIHV1aWRCaW4gIT0gbnVsbCkge1xuICAgIGhleCA9IGJpbmFyeTJoZXgodXVpZEJpbik7XG4gICAgY29uc3QgdXVpZFN0ciA9IGhleC5zdWJzdHJpbmcoMCwgOCkgKyAnLScgKyBoZXguc3Vic3RyaW5nKDgsIDggKyA0KSArICctJyArIGhleC5zdWJzdHJpbmcoMTIsIDEyICsgNCkgKyAnLScgKyBoZXguc3Vic3RyaW5nKDE2LCAxNiArIDQpICsgJy0nICsgaGV4LnN1YnN0cmluZygyMCwgMjAgKyAxMik7XG4gICAgcmV0dXJuIHV1aWRTdHI7XG4gIH1cbiAgcmV0dXJuIHV1aWRCaW47XG59XG5cbi8qKlxuICogVVVJRHYxIFNjaGVtYVR5cGUgY29uc3RydWN0b3IuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGtleVxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEBpbmhlcml0cyBTY2hlbWFUeXBlXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIFNjaGVtYVVVSUQoa2V5LCBvcHRpb25zKSB7XG4gIFNjaGVtYVR5cGUuY2FsbCh0aGlzLCBrZXksIG9wdGlvbnMsICdVVUlEJyk7XG4gIHRoaXMuZ2V0dGVycy5wdXNoKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgLy8gRm9yIHBvcHVsYXRlZFxuICAgIGlmICh2YWx1ZSAhPSBudWxsICYmIHZhbHVlLiRfXyAhPSBudWxsKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIHJldHVybiBiaW5hcnlUb1N0cmluZyh2YWx1ZSk7XG4gIH0pO1xufVxuXG4vKipcbiAqIFRoaXMgc2NoZW1hIHR5cGUncyBuYW1lLCB0byBkZWZlbmQgYWdhaW5zdCBtaW5pZmllcnMgdGhhdCBtYW5nbGVcbiAqIGZ1bmN0aW9uIG5hbWVzLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblNjaGVtYVVVSUQuc2NoZW1hTmFtZSA9ICdVVUlEJztcblxuU2NoZW1hVVVJRC5kZWZhdWx0T3B0aW9ucyA9IHt9O1xuXG4vKiFcbiAqIEluaGVyaXRzIGZyb20gU2NoZW1hVHlwZS5cbiAqL1xuU2NoZW1hVVVJRC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFNjaGVtYVR5cGUucHJvdG90eXBlKTtcblNjaGVtYVVVSUQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gU2NoZW1hVVVJRDtcblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5TY2hlbWFVVUlELl9jYXN0ID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cblxuICBmdW5jdGlvbiBuZXdCdWZmZXIoaW5pdGJ1ZmYpIHtcbiAgICBjb25zdCBidWZmID0gbmV3IE1vbmdvb3NlQnVmZmVyKGluaXRidWZmKTtcbiAgICBidWZmLl9zdWJ0eXBlID0gNDtcbiAgICByZXR1cm4gYnVmZjtcbiAgfVxuXG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgaWYgKFVVSURfRk9STUFULnRlc3QodmFsdWUpKSB7XG4gICAgICByZXR1cm4gc3RyaW5nVG9CaW5hcnkodmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgQ2FzdEVycm9yKFNjaGVtYVVVSUQuc2NoZW1hTmFtZSwgdmFsdWUsIHRoaXMucGF0aCk7XG4gICAgfVxuICB9XG5cbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcih2YWx1ZSkpIHtcbiAgICByZXR1cm4gbmV3QnVmZmVyKHZhbHVlKTtcbiAgfVxuXG4gIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEJpbmFyeSkge1xuICAgIHJldHVybiBuZXdCdWZmZXIodmFsdWUudmFsdWUodHJ1ZSkpO1xuICB9XG5cbiAgLy8gUmU6IGdoLTY0NyBhbmQgZ2gtMzAzMCwgd2UncmUgb2sgd2l0aCBjYXN0aW5nIHVzaW5nIGB0b1N0cmluZygpYFxuICAvLyAqKnVubGVzcyoqIGl0cyB0aGUgZGVmYXVsdCBPYmplY3QudG9TdHJpbmcsIGJlY2F1c2UgXCJbb2JqZWN0IE9iamVjdF1cIlxuICAvLyBkb2Vzbid0IHJlYWxseSBxdWFsaWZ5IGFzIHVzZWZ1bCBkYXRhXG4gIGlmICh2YWx1ZS50b1N0cmluZyAmJiB2YWx1ZS50b1N0cmluZyAhPT0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZykge1xuICAgIGlmIChVVUlEX0ZPUk1BVC50ZXN0KHZhbHVlLnRvU3RyaW5nKCkpKSB7XG4gICAgICByZXR1cm4gc3RyaW5nVG9CaW5hcnkodmFsdWUudG9TdHJpbmcoKSk7XG4gICAgfVxuICB9XG5cbiAgdGhyb3cgbmV3IENhc3RFcnJvcihTY2hlbWFVVUlELnNjaGVtYU5hbWUsIHZhbHVlLCB0aGlzLnBhdGgpO1xufTtcblxuLyoqXG4gKiBBdHRhY2hlcyBhIGdldHRlciBmb3IgYWxsIFVVSUQgaW5zdGFuY2VzLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgLy8gTm90ZSB0aGF0IGB2YCBpcyBhIHN0cmluZyBieSBkZWZhdWx0XG4gKiAgICAgbW9uZ29vc2UuU2NoZW1hLlVVSUQuZ2V0KHYgPT4gdi50b1VwcGVyQ2FzZSgpKTtcbiAqXG4gKiAgICAgY29uc3QgTW9kZWwgPSBtb25nb29zZS5tb2RlbCgnVGVzdCcsIG5ldyBTY2hlbWEoeyB0ZXN0OiAnVVVJRCcgfSkpO1xuICogICAgIG5ldyBNb2RlbCh7IHRlc3Q6IHV1aWQudjQoKSB9KS50ZXN0OyAvLyBVVUlEIHdpdGggYWxsIHVwcGVyY2FzZVxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGdldHRlclxuICogQHJldHVybiB7dGhpc31cbiAqIEBmdW5jdGlvbiBnZXRcbiAqIEBzdGF0aWNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuU2NoZW1hVVVJRC5nZXQgPSBTY2hlbWFUeXBlLmdldDtcblxuLyoqXG4gKiBTZXRzIGEgZGVmYXVsdCBvcHRpb24gZm9yIGFsbCBVVUlEIGluc3RhbmNlcy5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIC8vIE1ha2UgYWxsIFVVSURzIGhhdmUgYHJlcXVpcmVkYCBvZiB0cnVlIGJ5IGRlZmF1bHQuXG4gKiAgICAgbW9uZ29vc2UuU2NoZW1hLlVVSUQuc2V0KCdyZXF1aXJlZCcsIHRydWUpO1xuICpcbiAqICAgICBjb25zdCBVc2VyID0gbW9uZ29vc2UubW9kZWwoJ1VzZXInLCBuZXcgU2NoZW1hKHsgdGVzdDogbW9uZ29vc2UuVVVJRCB9KSk7XG4gKiAgICAgbmV3IFVzZXIoeyB9KS52YWxpZGF0ZVN5bmMoKS5lcnJvcnMudGVzdC5tZXNzYWdlOyAvLyBQYXRoIGB0ZXN0YCBpcyByZXF1aXJlZC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gb3B0aW9uIFRoZSBvcHRpb24geW91J2QgbGlrZSB0byBzZXQgdGhlIHZhbHVlIGZvclxuICogQHBhcmFtIHtBbnl9IHZhbHVlIHZhbHVlIGZvciBvcHRpb25cbiAqIEByZXR1cm4ge3VuZGVmaW5lZH1cbiAqIEBmdW5jdGlvbiBzZXRcbiAqIEBzdGF0aWNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuU2NoZW1hVVVJRC5zZXQgPSBTY2hlbWFUeXBlLnNldDtcblxuU2NoZW1hVVVJRC5zZXR0ZXJzID0gW107XG5cbi8qKlxuICogR2V0L3NldCB0aGUgZnVuY3Rpb24gdXNlZCB0byBjYXN0IGFyYml0cmFyeSB2YWx1ZXMgdG8gVVVJRHMuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICAvLyBNYWtlIE1vbmdvb3NlIHJlZnVzZSB0byBjYXN0IFVVSURzIHdpdGggMCBsZW5ndGhcbiAqICAgICBjb25zdCBvcmlnaW5hbCA9IG1vbmdvb3NlLlNjaGVtYS5UeXBlcy5VVUlELmNhc3QoKTtcbiAqICAgICBtb25nb29zZS5VVUlELmNhc3QodiA9PiB7XG4gKiAgICAgICBhc3NlcnQub2sodHlwZW9mIHYgPT09IFwic3RyaW5nXCIgJiYgdi5sZW5ndGggPiAwKTtcbiAqICAgICAgIHJldHVybiBvcmlnaW5hbCh2KTtcbiAqICAgICB9KTtcbiAqXG4gKiAgICAgLy8gT3IgZGlzYWJsZSBjYXN0aW5nIGVudGlyZWx5XG4gKiAgICAgbW9uZ29vc2UuVVVJRC5jYXN0KGZhbHNlKTtcbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FzdGVyXVxuICogQHJldHVybiB7RnVuY3Rpb259XG4gKiBAZnVuY3Rpb24gZ2V0XG4gKiBAc3RhdGljXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblNjaGVtYVVVSUQuY2FzdCA9IGZ1bmN0aW9uIGNhc3QoY2FzdGVyKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIHRoaXMuX2Nhc3Q7XG4gIH1cbiAgaWYgKGNhc3RlciA9PT0gZmFsc2UpIHtcbiAgICBjYXN0ZXIgPSB0aGlzLl9kZWZhdWx0Q2FzdGVyO1xuICB9XG4gIHRoaXMuX2Nhc3QgPSBjYXN0ZXI7XG5cbiAgcmV0dXJuIHRoaXMuX2Nhc3Q7XG59O1xuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cblNjaGVtYVVVSUQuX2NoZWNrUmVxdWlyZWQgPSB2ID0+IHYgIT0gbnVsbDtcblxuLyoqXG4gKiBPdmVycmlkZSB0aGUgZnVuY3Rpb24gdGhlIHJlcXVpcmVkIHZhbGlkYXRvciB1c2VzIHRvIGNoZWNrIHdoZXRoZXIgYSBzdHJpbmdcbiAqIHBhc3NlcyB0aGUgYHJlcXVpcmVkYCBjaGVjay5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICogQHJldHVybiB7RnVuY3Rpb259XG4gKiBAZnVuY3Rpb24gY2hlY2tSZXF1aXJlZFxuICogQHN0YXRpY1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5TY2hlbWFVVUlELmNoZWNrUmVxdWlyZWQgPSBTY2hlbWFUeXBlLmNoZWNrUmVxdWlyZWQ7XG5cbi8qKlxuICogQ2hlY2sgaWYgdGhlIGdpdmVuIHZhbHVlIHNhdGlzZmllcyBhIHJlcXVpcmVkIHZhbGlkYXRvci5cbiAqXG4gKiBAcGFyYW0ge0FueX0gdmFsdWVcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblNjaGVtYVVVSUQucHJvdG90eXBlLmNoZWNrUmVxdWlyZWQgPSBmdW5jdGlvbiBjaGVja1JlcXVpcmVkKHZhbHVlKSB7XG4gIGlmIChCdWZmZXIuaXNCdWZmZXIodmFsdWUpKSB7XG4gICAgdmFsdWUgPSBiaW5hcnlUb1N0cmluZyh2YWx1ZSk7XG4gIH1cbiAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgVVVJRF9GT1JNQVQudGVzdCh2YWx1ZSk7XG59O1xuXG4vKipcbiAqIENhc3RzIHRvIFVVSURcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsdWVcbiAqIEBwYXJhbSB7T2JqZWN0fSBkb2NcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gaW5pdCB3aGV0aGVyIHRoaXMgaXMgYW4gaW5pdGlhbGl6YXRpb24gY2FzdFxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU2NoZW1hVVVJRC5wcm90b3R5cGUuY2FzdCA9IGZ1bmN0aW9uKHZhbHVlLCBkb2MsIGluaXQpIHtcbiAgaWYgKHV0aWxzLmlzTm9uQnVpbHRpbk9iamVjdCh2YWx1ZSkgJiZcbiAgICAgIFNjaGVtYVR5cGUuX2lzUmVmKHRoaXMsIHZhbHVlLCBkb2MsIGluaXQpKSB7XG4gICAgcmV0dXJuIHRoaXMuX2Nhc3RSZWYodmFsdWUsIGRvYywgaW5pdCk7XG4gIH1cblxuICBsZXQgY2FzdEZuO1xuICBpZiAodHlwZW9mIHRoaXMuX2Nhc3RGdW5jdGlvbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNhc3RGbiA9IHRoaXMuX2Nhc3RGdW5jdGlvbjtcbiAgfSBlbHNlIGlmICh0eXBlb2YgdGhpcy5jb25zdHJ1Y3Rvci5jYXN0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FzdEZuID0gdGhpcy5jb25zdHJ1Y3Rvci5jYXN0KCk7XG4gIH0gZWxzZSB7XG4gICAgY2FzdEZuID0gU2NoZW1hVVVJRC5jYXN0KCk7XG4gIH1cblxuICB0cnkge1xuICAgIHJldHVybiBjYXN0Rm4odmFsdWUpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHRocm93IG5ldyBDYXN0RXJyb3IoU2NoZW1hVVVJRC5zY2hlbWFOYW1lLCB2YWx1ZSwgdGhpcy5wYXRoLCBlcnJvciwgdGhpcyk7XG4gIH1cbn07XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxuZnVuY3Rpb24gaGFuZGxlU2luZ2xlKHZhbCkge1xuICByZXR1cm4gdGhpcy5jYXN0KHZhbCk7XG59XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxuZnVuY3Rpb24gaGFuZGxlQXJyYXkodmFsKSB7XG4gIHJldHVybiB2YWwubWFwKChtKSA9PiB7XG4gICAgcmV0dXJuIHRoaXMuY2FzdChtKTtcbiAgfSk7XG59XG5cblNjaGVtYVVVSUQucHJvdG90eXBlLiRjb25kaXRpb25hbEhhbmRsZXJzID0ge1xuICAuLi5TY2hlbWFUeXBlLnByb3RvdHlwZS4kY29uZGl0aW9uYWxIYW5kbGVycyxcbiAgJGJpdHNBbGxDbGVhcjogaGFuZGxlQml0d2lzZU9wZXJhdG9yLFxuICAkYml0c0FueUNsZWFyOiBoYW5kbGVCaXR3aXNlT3BlcmF0b3IsXG4gICRiaXRzQWxsU2V0OiBoYW5kbGVCaXR3aXNlT3BlcmF0b3IsXG4gICRiaXRzQW55U2V0OiBoYW5kbGVCaXR3aXNlT3BlcmF0b3IsXG4gICRhbGw6IGhhbmRsZUFycmF5LFxuICAkZ3Q6IGhhbmRsZVNpbmdsZSxcbiAgJGd0ZTogaGFuZGxlU2luZ2xlLFxuICAkaW46IGhhbmRsZUFycmF5LFxuICAkbHQ6IGhhbmRsZVNpbmdsZSxcbiAgJGx0ZTogaGFuZGxlU2luZ2xlLFxuICAkbmU6IGhhbmRsZVNpbmdsZSxcbiAgJG5pbjogaGFuZGxlQXJyYXlcbn07XG5cbi8qKlxuICogQ2FzdHMgY29udGVudHMgZm9yIHF1ZXJpZXMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9ICRjb25kaXRpb25hbFxuICogQHBhcmFtIHthbnl9IHZhbFxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU2NoZW1hVVVJRC5wcm90b3R5cGUuY2FzdEZvclF1ZXJ5ID0gZnVuY3Rpb24oJGNvbmRpdGlvbmFsLCB2YWwsIGNvbnRleHQpIHtcbiAgbGV0IGhhbmRsZXI7XG4gIGlmICgkY29uZGl0aW9uYWwgIT0gbnVsbCkge1xuICAgIGhhbmRsZXIgPSB0aGlzLiRjb25kaXRpb25hbEhhbmRsZXJzWyRjb25kaXRpb25hbF07XG4gICAgaWYgKCFoYW5kbGVyKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5cXCd0IHVzZSAnICsgJGNvbmRpdGlvbmFsICsgJyB3aXRoIFVVSUQuJyk7XG4gICAgcmV0dXJuIGhhbmRsZXIuY2FsbCh0aGlzLCB2YWwsIGNvbnRleHQpO1xuICB9XG5cbiAgdHJ5IHtcbiAgICByZXR1cm4gdGhpcy5hcHBseVNldHRlcnModmFsLCBjb250ZXh0KTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgaWYgKGVyciBpbnN0YW5jZW9mIENhc3RFcnJvciAmJiBlcnIucGF0aCA9PT0gdGhpcy5wYXRoICYmIHRoaXMuJGZ1bGxQYXRoICE9IG51bGwpIHtcbiAgICAgIGVyci5wYXRoID0gdGhpcy4kZnVsbFBhdGg7XG4gICAgfVxuICAgIHRocm93IGVycjtcbiAgfVxufTtcblxuLyohXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNjaGVtYVVVSUQ7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../server/node_modules/mongoose/lib/schema/uuid.js\n");

/***/ }),

/***/ "../server/node_modules/mongoose/lib/schemaType.js":
/*!*********************************************************!*\
  !*** ../server/node_modules/mongoose/lib/schemaType.js ***!
  \*********************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("\n\n/*!\n * Module dependencies.\n */\n\nconst MongooseError = __webpack_require__(/*! ./error/index */ \"../server/node_modules/mongoose/lib/error/index.js\");\nconst SchemaTypeOptions = __webpack_require__(/*! ./options/schemaTypeOptions */ \"../server/node_modules/mongoose/lib/options/schemaTypeOptions.js\");\nconst $exists = __webpack_require__(/*! ./schema/operators/exists */ \"../server/node_modules/mongoose/lib/schema/operators/exists.js\");\nconst $type = __webpack_require__(/*! ./schema/operators/type */ \"../server/node_modules/mongoose/lib/schema/operators/type.js\");\nconst clone = __webpack_require__(/*! ./helpers/clone */ \"../server/node_modules/mongoose/lib/helpers/clone.js\");\nconst handleImmutable = __webpack_require__(/*! ./helpers/schematype/handleImmutable */ \"../server/node_modules/mongoose/lib/helpers/schematype/handleImmutable.js\");\nconst isAsyncFunction = __webpack_require__(/*! ./helpers/isAsyncFunction */ \"../server/node_modules/mongoose/lib/helpers/isAsyncFunction.js\");\nconst isSimpleValidator = __webpack_require__(/*! ./helpers/isSimpleValidator */ \"../server/node_modules/mongoose/lib/helpers/isSimpleValidator.js\");\nconst immediate = __webpack_require__(/*! ./helpers/immediate */ \"../server/node_modules/mongoose/lib/helpers/immediate.js\");\nconst schemaTypeSymbol = (__webpack_require__(/*! ./helpers/symbols */ \"../server/node_modules/mongoose/lib/helpers/symbols.js\").schemaTypeSymbol);\nconst utils = __webpack_require__(/*! ./utils */ \"../server/node_modules/mongoose/lib/utils.js\");\nconst validatorErrorSymbol = (__webpack_require__(/*! ./helpers/symbols */ \"../server/node_modules/mongoose/lib/helpers/symbols.js\").validatorErrorSymbol);\nconst documentIsModified = (__webpack_require__(/*! ./helpers/symbols */ \"../server/node_modules/mongoose/lib/helpers/symbols.js\").documentIsModified);\n\nconst populateModelSymbol = (__webpack_require__(/*! ./helpers/symbols */ \"../server/node_modules/mongoose/lib/helpers/symbols.js\").populateModelSymbol);\n\nconst CastError = MongooseError.CastError;\nconst ValidatorError = MongooseError.ValidatorError;\n\nconst setOptionsForDefaults = { _skipMarkModified: true };\n\n/**\n * SchemaType constructor. Do **not** instantiate `SchemaType` directly.\n * Mongoose converts your schema paths into SchemaTypes automatically.\n *\n * #### Example:\n *\n *     const schema = new Schema({ name: String });\n *     schema.path('name') instanceof SchemaType; // true\n *\n * @param {String} path\n * @param {SchemaTypeOptions} [options] See [SchemaTypeOptions docs](https://mongoosejs.com/docs/api/schematypeoptions.html)\n * @param {String} [instance]\n * @api public\n */\n\nfunction SchemaType(path, options, instance) {\n  this[schemaTypeSymbol] = true;\n  this.path = path;\n  this.instance = instance;\n  this.validators = [];\n  this.getters = this.constructor.hasOwnProperty('getters') ?\n    this.constructor.getters.slice() :\n    [];\n  this.setters = this.constructor.hasOwnProperty('setters') ?\n    this.constructor.setters.slice() :\n    [];\n\n  this.splitPath();\n\n  options = options || {};\n  const defaultOptions = this.constructor.defaultOptions || {};\n  const defaultOptionsKeys = Object.keys(defaultOptions);\n\n  for (const option of defaultOptionsKeys) {\n    if (option === 'validate') {\n      this.validate(defaultOptions.validate);\n    } else if (defaultOptions.hasOwnProperty(option) && !Object.prototype.hasOwnProperty.call(options, option)) {\n      options[option] = defaultOptions[option];\n    }\n  }\n\n  if (options.select == null) {\n    delete options.select;\n  }\n\n  const Options = this.OptionsConstructor || SchemaTypeOptions;\n  this.options = new Options(options);\n  this._index = null;\n\n\n  if (utils.hasUserDefinedProperty(this.options, 'immutable')) {\n    this.$immutable = this.options.immutable;\n\n    handleImmutable(this);\n  }\n\n  const keys = Object.keys(this.options);\n  for (const prop of keys) {\n    if (prop === 'cast') {\n      if (Array.isArray(this.options[prop])) {\n        this.castFunction.apply(this, this.options[prop]);\n      } else {\n        this.castFunction(this.options[prop]);\n      }\n      continue;\n    }\n    if (utils.hasUserDefinedProperty(this.options, prop) && typeof this[prop] === 'function') {\n      // { unique: true, index: true }\n      if (prop === 'index' && this._index) {\n        if (options.index === false) {\n          const index = this._index;\n          if (typeof index === 'object' && index != null) {\n            if (index.unique) {\n              throw new Error('Path \"' + this.path + '\" may not have `index` ' +\n                'set to false and `unique` set to true');\n            }\n            if (index.sparse) {\n              throw new Error('Path \"' + this.path + '\" may not have `index` ' +\n                'set to false and `sparse` set to true');\n            }\n          }\n\n          this._index = false;\n        }\n        continue;\n      }\n\n      const val = options[prop];\n      // Special case so we don't screw up array defaults, see gh-5780\n      if (prop === 'default') {\n        this.default(val);\n        continue;\n      }\n\n      const opts = Array.isArray(val) ? val : [val];\n\n      this[prop].apply(this, opts);\n    }\n  }\n\n  Object.defineProperty(this, '$$context', {\n    enumerable: false,\n    configurable: false,\n    writable: true,\n    value: null\n  });\n}\n\n/**\n * The class that Mongoose uses internally to instantiate this SchemaType's `options` property.\n * @memberOf SchemaType\n * @instance\n * @api private\n */\n\nSchemaType.prototype.OptionsConstructor = SchemaTypeOptions;\n\n/**\n * The path to this SchemaType in a Schema.\n *\n * #### Example:\n *\n *     const schema = new Schema({ name: String });\n *     schema.path('name').path; // 'name'\n *\n * @property path\n * @api public\n * @memberOf SchemaType\n */\n\nSchemaType.prototype.path;\n\n/**\n * The validators that Mongoose should run to validate properties at this SchemaType's path.\n *\n * #### Example:\n *\n *     const schema = new Schema({ name: { type: String, required: true } });\n *     schema.path('name').validators.length; // 1, the `required` validator\n *\n * @property validators\n * @api public\n * @memberOf SchemaType\n */\n\nSchemaType.prototype.validators;\n\n/**\n * True if this SchemaType has a required validator. False otherwise.\n *\n * #### Example:\n *\n *     const schema = new Schema({ name: { type: String, required: true } });\n *     schema.path('name').isRequired; // true\n *\n *     schema.path('name').required(false);\n *     schema.path('name').isRequired; // false\n *\n * @property isRequired\n * @api public\n * @memberOf SchemaType\n */\n\nSchemaType.prototype.isRequired;\n\n/**\n * Split the current dottet path into segments\n *\n * @return {String[]|undefined}\n * @api private\n */\n\nSchemaType.prototype.splitPath = function() {\n  if (this._presplitPath != null) {\n    return this._presplitPath;\n  }\n  if (this.path == null) {\n    return undefined;\n  }\n\n  this._presplitPath = this.path.indexOf('.') === -1 ? [this.path] : this.path.split('.');\n  return this._presplitPath;\n};\n\n/**\n * Get/set the function used to cast arbitrary values to this type.\n *\n * #### Example:\n *\n *     // Disallow `null` for numbers, and don't try to cast any values to\n *     // numbers, so even strings like '123' will cause a CastError.\n *     mongoose.Number.cast(function(v) {\n *       assert.ok(v === undefined || typeof v === 'number');\n *       return v;\n *     });\n *\n * @param {Function|false} caster Function that casts arbitrary values to this type, or throws an error if casting failed\n * @return {Function}\n * @static\n * @memberOf SchemaType\n * @function cast\n * @api public\n */\n\nSchemaType.cast = function cast(caster) {\n  if (arguments.length === 0) {\n    return this._cast;\n  }\n  if (caster === false) {\n    caster = v => v;\n  }\n  this._cast = caster;\n\n  return this._cast;\n};\n\n/**\n * Get/set the function used to cast arbitrary values to this particular schematype instance.\n * Overrides `SchemaType.cast()`.\n *\n * #### Example:\n *\n *     // Disallow `null` for numbers, and don't try to cast any values to\n *     // numbers, so even strings like '123' will cause a CastError.\n *     const number = new mongoose.Number('mypath', {});\n *     number.cast(function(v) {\n *       assert.ok(v === undefined || typeof v === 'number');\n *       return v;\n *     });\n *\n * @param {Function|false} caster Function that casts arbitrary values to this type, or throws an error if casting failed\n * @return {Function}\n * @memberOf SchemaType\n * @api public\n */\n\nSchemaType.prototype.castFunction = function castFunction(caster, message) {\n  if (arguments.length === 0) {\n    return this._castFunction;\n  }\n\n  if (caster === false) {\n    caster = this.constructor._defaultCaster || (v => v);\n  }\n  if (typeof caster === 'string') {\n    this._castErrorMessage = caster;\n    return this._castFunction;\n  }\n  if (caster != null) {\n    this._castFunction = caster;\n  }\n  if (message != null) {\n    this._castErrorMessage = message;\n  }\n\n  return this._castFunction;\n};\n\n/**\n * The function that Mongoose calls to cast arbitrary values to this SchemaType.\n *\n * @param {Object} value value to cast\n * @param {Document} doc document that triggers the casting\n * @param {Boolean} init\n * @api public\n */\n\nSchemaType.prototype.cast = function cast() {\n  throw new Error('Base SchemaType class does not implement a `cast()` function');\n};\n\n/**\n * Sets a default option for this schema type.\n *\n * #### Example:\n *\n *     // Make all strings be trimmed by default\n *     mongoose.SchemaTypes.String.set('trim', true);\n *\n * @param {String} option The name of the option you'd like to set (e.g. trim, lowercase, etc...)\n * @param {Any} value The value of the option you'd like to set.\n * @return {void}\n * @static\n * @memberOf SchemaType\n * @function set\n * @api public\n */\n\nSchemaType.set = function set(option, value) {\n  if (!this.hasOwnProperty('defaultOptions')) {\n    this.defaultOptions = Object.assign({}, this.defaultOptions);\n  }\n  this.defaultOptions[option] = value;\n};\n\n/**\n * Attaches a getter for all instances of this schema type.\n *\n * #### Example:\n *\n *     // Make all numbers round down\n *     mongoose.Number.get(function(v) { return Math.floor(v); });\n *\n * @param {Function} getter\n * @return {this}\n * @static\n * @memberOf SchemaType\n * @function get\n * @api public\n */\n\nSchemaType.get = function(getter) {\n  this.getters = this.hasOwnProperty('getters') ? this.getters : [];\n  this.getters.push(getter);\n};\n\n/**\n * Sets a default value for this SchemaType.\n *\n * #### Example:\n *\n *     const schema = new Schema({ n: { type: Number, default: 10 })\n *     const M = db.model('M', schema)\n *     const m = new M;\n *     console.log(m.n) // 10\n *\n * Defaults can be either `functions` which return the value to use as the default or the literal value itself. Either way, the value will be cast based on its schema type before being set during document creation.\n *\n * #### Example:\n *\n *     // values are cast:\n *     const schema = new Schema({ aNumber: { type: Number, default: 4.815162342 }})\n *     const M = db.model('M', schema)\n *     const m = new M;\n *     console.log(m.aNumber) // 4.815162342\n *\n *     // default unique objects for Mixed types:\n *     const schema = new Schema({ mixed: Schema.Types.Mixed });\n *     schema.path('mixed').default(function () {\n *       return {};\n *     });\n *\n *     // if we don't use a function to return object literals for Mixed defaults,\n *     // each document will receive a reference to the same object literal creating\n *     // a \"shared\" object instance:\n *     const schema = new Schema({ mixed: Schema.Types.Mixed });\n *     schema.path('mixed').default({});\n *     const M = db.model('M', schema);\n *     const m1 = new M;\n *     m1.mixed.added = 1;\n *     console.log(m1.mixed); // { added: 1 }\n *     const m2 = new M;\n *     console.log(m2.mixed); // { added: 1 }\n *\n * @param {Function|any} val The default value to set\n * @return {Any|undefined} Returns the set default value.\n * @api public\n */\n\nSchemaType.prototype.default = function(val) {\n  if (arguments.length === 1) {\n    if (val === void 0) {\n      this.defaultValue = void 0;\n      return void 0;\n    }\n\n    if (val != null && val.instanceOfSchema) {\n      throw new MongooseError('Cannot set default value of path `' + this.path +\n        '` to a mongoose Schema instance.');\n    }\n\n    this.defaultValue = val;\n    return this.defaultValue;\n  } else if (arguments.length > 1) {\n    this.defaultValue = [...arguments];\n  }\n  return this.defaultValue;\n};\n\n/**\n * Declares the index options for this schematype.\n *\n * #### Example:\n *\n *     const s = new Schema({ name: { type: String, index: true })\n *     const s = new Schema({ name: { type: String, index: -1 })\n *     const s = new Schema({ loc: { type: [Number], index: 'hashed' })\n *     const s = new Schema({ loc: { type: [Number], index: '2d', sparse: true })\n *     const s = new Schema({ loc: { type: [Number], index: { type: '2dsphere', sparse: true }})\n *     const s = new Schema({ date: { type: Date, index: { unique: true, expires: '1d' }})\n *     s.path('my.path').index(true);\n *     s.path('my.date').index({ expires: 60 });\n *     s.path('my.path').index({ unique: true, sparse: true });\n *\n * #### Note:\n *\n * _Indexes are created [in the background](https://www.mongodb.com/docs/manual/core/index-creation/#index-creation-background)\n * by default. If `background` is set to `false`, MongoDB will not execute any\n * read/write operations you send until the index build.\n * Specify `background: false` to override Mongoose's default._\n *\n * @param {Object|Boolean|String|Number} options\n * @return {SchemaType} this\n * @api public\n */\n\nSchemaType.prototype.index = function(options) {\n  this._index = options;\n  utils.expires(this._index);\n  return this;\n};\n\n/**\n * Declares an unique index.\n *\n * #### Example:\n *\n *     const s = new Schema({ name: { type: String, unique: true } });\n *     s.path('name').index({ unique: true });\n *\n * _NOTE: violating the constraint returns an `E11000` error from MongoDB when saving, not a Mongoose validation error._\n *\n * @param {Boolean} bool\n * @return {SchemaType} this\n * @api public\n */\n\nSchemaType.prototype.unique = function(bool) {\n  if (this._index === false) {\n    if (!bool) {\n      return;\n    }\n    throw new Error('Path \"' + this.path + '\" may not have `index` set to ' +\n      'false and `unique` set to true');\n  }\n\n  if (!this.options.hasOwnProperty('index') && bool === false) {\n    return this;\n  }\n\n  if (this._index == null || this._index === true) {\n    this._index = {};\n  } else if (typeof this._index === 'string') {\n    this._index = { type: this._index };\n  }\n\n  this._index.unique = bool;\n  return this;\n};\n\n/**\n * Declares a full text index.\n *\n * ### Example:\n *\n *      const s = new Schema({ name : { type: String, text : true } })\n *      s.path('name').index({ text : true });\n *\n * @param {Boolean} bool\n * @return {SchemaType} this\n * @api public\n */\n\nSchemaType.prototype.text = function(bool) {\n  if (this._index === false) {\n    if (!bool) {\n      return this;\n    }\n    throw new Error('Path \"' + this.path + '\" may not have `index` set to ' +\n      'false and `text` set to true');\n  }\n\n  if (!this.options.hasOwnProperty('index') && bool === false) {\n    return this;\n  }\n\n  if (this._index === null || this._index === undefined ||\n    typeof this._index === 'boolean') {\n    this._index = {};\n  } else if (typeof this._index === 'string') {\n    this._index = { type: this._index };\n  }\n\n  this._index.text = bool;\n  return this;\n};\n\n/**\n * Declares a sparse index.\n *\n * #### Example:\n *\n *     const s = new Schema({ name: { type: String, sparse: true } });\n *     s.path('name').index({ sparse: true });\n *\n * @param {Boolean} bool\n * @return {SchemaType} this\n * @api public\n */\n\nSchemaType.prototype.sparse = function(bool) {\n  if (this._index === false) {\n    if (!bool) {\n      return this;\n    }\n    throw new Error('Path \"' + this.path + '\" may not have `index` set to ' +\n      'false and `sparse` set to true');\n  }\n\n  if (!this.options.hasOwnProperty('index') && bool === false) {\n    return this;\n  }\n\n  if (this._index == null || typeof this._index === 'boolean') {\n    this._index = {};\n  } else if (typeof this._index === 'string') {\n    this._index = { type: this._index };\n  }\n\n  this._index.sparse = bool;\n  return this;\n};\n\n/**\n * Defines this path as immutable. Mongoose prevents you from changing\n * immutable paths unless the parent document has [`isNew: true`](https://mongoosejs.com/docs/api/document.html#Document.prototype.isNew()).\n *\n * #### Example:\n *\n *     const schema = new Schema({\n *       name: { type: String, immutable: true },\n *       age: Number\n *     });\n *     const Model = mongoose.model('Test', schema);\n *\n *     await Model.create({ name: 'test' });\n *     const doc = await Model.findOne();\n *\n *     doc.isNew; // false\n *     doc.name = 'new name';\n *     doc.name; // 'test', because `name` is immutable\n *\n * Mongoose also prevents changing immutable properties using `updateOne()`\n * and `updateMany()` based on [strict mode](https://mongoosejs.com/docs/guide.html#strict).\n *\n * #### Example:\n *\n *     // Mongoose will strip out the `name` update, because `name` is immutable\n *     Model.updateOne({}, { $set: { name: 'test2' }, $inc: { age: 1 } });\n *\n *     // If `strict` is set to 'throw', Mongoose will throw an error if you\n *     // update `name`\n *     const err = await Model.updateOne({}, { name: 'test2' }, { strict: 'throw' }).\n *       then(() => null, err => err);\n *     err.name; // StrictModeError\n *\n *     // If `strict` is `false`, Mongoose allows updating `name` even though\n *     // the property is immutable.\n *     Model.updateOne({}, { name: 'test2' }, { strict: false });\n *\n * @param {Boolean} bool\n * @return {SchemaType} this\n * @see isNew https://mongoosejs.com/docs/api/document.html#Document.prototype.isNew()\n * @api public\n */\n\nSchemaType.prototype.immutable = function(bool) {\n  this.$immutable = bool;\n  handleImmutable(this);\n\n  return this;\n};\n\n/**\n * Defines a custom function for transforming this path when converting a document to JSON.\n *\n * Mongoose calls this function with one parameter: the current `value` of the path. Mongoose\n * then uses the return value in the JSON output.\n *\n * #### Example:\n *\n *     const schema = new Schema({\n *       date: { type: Date, transform: v => v.getFullYear() }\n *     });\n *     const Model = mongoose.model('Test', schema);\n *\n *     await Model.create({ date: new Date('2016-06-01') });\n *     const doc = await Model.findOne();\n *\n *     doc.date instanceof Date; // true\n *\n *     doc.toJSON().date; // 2016 as a number\n *     JSON.stringify(doc); // '{\"_id\":...,\"date\":2016}'\n *\n * @param {Function} fn\n * @return {SchemaType} this\n * @api public\n */\n\nSchemaType.prototype.transform = function(fn) {\n  this.options.transform = fn;\n\n  return this;\n};\n\n/**\n * Adds a setter to this schematype.\n *\n * #### Example:\n *\n *     function capitalize (val) {\n *       if (typeof val !== 'string') val = '';\n *       return val.charAt(0).toUpperCase() + val.substring(1);\n *     }\n *\n *     // defining within the schema\n *     const s = new Schema({ name: { type: String, set: capitalize }});\n *\n *     // or with the SchemaType\n *     const s = new Schema({ name: String })\n *     s.path('name').set(capitalize);\n *\n * Setters allow you to transform the data before it gets to the raw mongodb\n * document or query.\n *\n * Suppose you are implementing user registration for a website. Users provide\n * an email and password, which gets saved to mongodb. The email is a string\n * that you will want to normalize to lower case, in order to avoid one email\n * having more than one account -- e.g., otherwise, avenue@q.com can be registered for 2 accounts via avenue@q.com and AvEnUe@Q.CoM.\n *\n * You can set up email lower case normalization easily via a Mongoose setter.\n *\n *     function toLower(v) {\n *       return v.toLowerCase();\n *     }\n *\n *     const UserSchema = new Schema({\n *       email: { type: String, set: toLower }\n *     });\n *\n *     const User = db.model('User', UserSchema);\n *\n *     const user = new User({email: 'AVENUE@Q.COM'});\n *     console.log(user.email); // 'avenue@q.com'\n *\n *     // or\n *     const user = new User();\n *     user.email = 'Avenue@Q.com';\n *     console.log(user.email); // 'avenue@q.com'\n *     User.updateOne({ _id: _id }, { $set: { email: 'AVENUE@Q.COM' } }); // update to 'avenue@q.com'\n *\n * As you can see above, setters allow you to transform the data before it\n * stored in MongoDB, or before executing a query.\n *\n * _NOTE: we could have also just used the built-in `lowercase: true` SchemaType option instead of defining our own function._\n *\n *     new Schema({ email: { type: String, lowercase: true }})\n *\n * Setters are also passed a second argument, the schematype on which the setter was defined. This allows for tailored behavior based on options passed in the schema.\n *\n *     function inspector (val, priorValue, schematype) {\n *       if (schematype.options.required) {\n *         return schematype.path + ' is required';\n *       } else {\n *         return val;\n *       }\n *     }\n *\n *     const VirusSchema = new Schema({\n *       name: { type: String, required: true, set: inspector },\n *       taxonomy: { type: String, set: inspector }\n *     })\n *\n *     const Virus = db.model('Virus', VirusSchema);\n *     const v = new Virus({ name: 'Parvoviridae', taxonomy: 'Parvovirinae' });\n *\n *     console.log(v.name);     // name is required\n *     console.log(v.taxonomy); // Parvovirinae\n *\n * You can also use setters to modify other properties on the document. If\n * you're setting a property `name` on a document, the setter will run with\n * `this` as the document. Be careful, in mongoose 5 setters will also run\n * when querying by `name` with `this` as the query.\n *\n *     const nameSchema = new Schema({ name: String, keywords: [String] });\n *     nameSchema.path('name').set(function(v) {\n *       // Need to check if `this` is a document, because in mongoose 5\n *       // setters will also run on queries, in which case `this` will be a\n *       // mongoose query object.\n *       if (this instanceof Document && v != null) {\n *         this.keywords = v.split(' ');\n *       }\n *       return v;\n *     });\n *\n * @param {Function} fn\n * @return {SchemaType} this\n * @api public\n */\n\nSchemaType.prototype.set = function(fn) {\n  if (typeof fn !== 'function') {\n    throw new TypeError('A setter must be a function.');\n  }\n  this.setters.push(fn);\n  return this;\n};\n\n/**\n * Adds a getter to this schematype.\n *\n * #### Example:\n *\n *     function dob (val) {\n *       if (!val) return val;\n *       return (val.getMonth() + 1) + \"/\" + val.getDate() + \"/\" + val.getFullYear();\n *     }\n *\n *     // defining within the schema\n *     const s = new Schema({ born: { type: Date, get: dob })\n *\n *     // or by retreiving its SchemaType\n *     const s = new Schema({ born: Date })\n *     s.path('born').get(dob)\n *\n * Getters allow you to transform the representation of the data as it travels from the raw mongodb document to the value that you see.\n *\n * Suppose you are storing credit card numbers and you want to hide everything except the last 4 digits to the mongoose user. You can do so by defining a getter in the following way:\n *\n *     function obfuscate (cc) {\n *       return '****-****-****-' + cc.slice(cc.length-4, cc.length);\n *     }\n *\n *     const AccountSchema = new Schema({\n *       creditCardNumber: { type: String, get: obfuscate }\n *     });\n *\n *     const Account = db.model('Account', AccountSchema);\n *\n *     Account.findById(id, function (err, found) {\n *       console.log(found.creditCardNumber); // '****-****-****-1234'\n *     });\n *\n * Getters are also passed a second argument, the schematype on which the getter was defined. This allows for tailored behavior based on options passed in the schema.\n *\n *     function inspector (val, priorValue, schematype) {\n *       if (schematype.options.required) {\n *         return schematype.path + ' is required';\n *       } else {\n *         return schematype.path + ' is not';\n *       }\n *     }\n *\n *     const VirusSchema = new Schema({\n *       name: { type: String, required: true, get: inspector },\n *       taxonomy: { type: String, get: inspector }\n *     })\n *\n *     const Virus = db.model('Virus', VirusSchema);\n *\n *     Virus.findById(id, function (err, virus) {\n *       console.log(virus.name);     // name is required\n *       console.log(virus.taxonomy); // taxonomy is not\n *     })\n *\n * @param {Function} fn\n * @return {SchemaType} this\n * @api public\n */\n\nSchemaType.prototype.get = function(fn) {\n  if (typeof fn !== 'function') {\n    throw new TypeError('A getter must be a function.');\n  }\n  this.getters.push(fn);\n  return this;\n};\n\n/**\n * Adds validator(s) for this document path.\n *\n * Validators always receive the value to validate as their first argument and\n * must return `Boolean`. Returning `false` or throwing an error means\n * validation failed.\n *\n * The error message argument is optional. If not passed, the [default generic error message template](https://mongoosejs.com/docs/api/error.html#Error.messages) will be used.\n *\n * #### Example:\n *\n *     // make sure every value is equal to \"something\"\n *     function validator (val) {\n *       return val === 'something';\n *     }\n *     new Schema({ name: { type: String, validate: validator }});\n *\n *     // with a custom error message\n *\n *     const custom = [validator, 'Uh oh, {PATH} does not equal \"something\".']\n *     new Schema({ name: { type: String, validate: custom }});\n *\n *     // adding many validators at a time\n *\n *     const many = [\n *         { validator: validator, message: 'uh oh' }\n *       , { validator: anotherValidator, message: 'failed' }\n *     ]\n *     new Schema({ name: { type: String, validate: many }});\n *\n *     // or utilizing SchemaType methods directly:\n *\n *     const schema = new Schema({ name: 'string' });\n *     schema.path('name').validate(validator, 'validation of `{PATH}` failed with value `{VALUE}`');\n *\n * #### Error message templates:\n *\n * Below is a list of supported template keywords:\n *\n * - PATH: The schema path where the error is being triggered.\n * - VALUE: The value assigned to the PATH that is triggering the error.\n * - KIND: The validation property that triggered the error i.e. required.\n * - REASON: The error object that caused this error if there was one.\n *\n * If Mongoose's built-in error message templating isn't enough, Mongoose\n * supports setting the `message` property to a function.\n *\n *     schema.path('name').validate({\n *       validator: function(v) { return v.length > 5; },\n *       // `errors['name']` will be \"name must have length 5, got 'foo'\"\n *       message: function(props) {\n *         return `${props.path} must have length 5, got '${props.value}'`;\n *       }\n *     });\n *\n * To bypass Mongoose's error messages and just copy the error message that\n * the validator throws, do this:\n *\n *     schema.path('name').validate({\n *       validator: function() { throw new Error('Oops!'); },\n *       // `errors['name']` will be \"Oops!\"\n *       message: function(props) { return props.reason.message; }\n *     });\n *\n * #### Asynchronous validation:\n *\n * Mongoose supports validators that return a promise. A validator that returns\n * a promise is called an _async validator_. Async validators run in\n * parallel, and `validate()` will wait until all async validators have settled.\n *\n *     schema.path('name').validate({\n *       validator: function (value) {\n *         return new Promise(function (resolve, reject) {\n *           resolve(false); // validation failed\n *         });\n *       }\n *     });\n *\n * You might use asynchronous validators to retreive other documents from the database to validate against or to meet other I/O bound validation needs.\n *\n * Validation occurs `pre('save')` or whenever you manually execute [document#validate](https://mongoosejs.com/docs/api/document.html#Document.prototype.validate()).\n *\n * If validation fails during `pre('save')` and no callback was passed to receive the error, an `error` event will be emitted on your Models associated db [connection](https://mongoosejs.com/docs/api/connection.html#Connection()), passing the validation error object along.\n *\n *     const conn = mongoose.createConnection(..);\n *     conn.on('error', handleError);\n *\n *     const Product = conn.model('Product', yourSchema);\n *     const dvd = new Product(..);\n *     dvd.save(); // emits error on the `conn` above\n *\n * If you want to handle these errors at the Model level, add an `error`\n * listener to your Model as shown below.\n *\n *     // registering an error listener on the Model lets us handle errors more locally\n *     Product.on('error', handleError);\n *\n * @param {RegExp|Function|Object} obj validator function, or hash describing options\n * @param {Function} [obj.validator] validator function. If the validator function returns `undefined` or a truthy value, validation succeeds. If it returns [falsy](https://masteringjs.io/tutorials/fundamentals/falsy) (except `undefined`) or throws an error, validation fails.\n * @param {String|Function} [obj.message] optional error message. If function, should return the error message as a string\n * @param {Boolean} [obj.propsParameter=false] If true, Mongoose will pass the validator properties object (with the `validator` function, `message`, etc.) as the 2nd arg to the validator function. This is disabled by default because many validators [rely on positional args](https://github.com/chriso/validator.js#validators), so turning this on may cause unpredictable behavior in external validators.\n * @param {String|Function} [errorMsg] optional error message. If function, should return the error message as a string\n * @param {String} [type] optional validator type\n * @return {SchemaType} this\n * @api public\n */\n\nSchemaType.prototype.validate = function(obj, message, type) {\n  if (typeof obj === 'function' || obj && utils.getFunctionName(obj.constructor) === 'RegExp') {\n    let properties;\n    if (typeof message === 'function') {\n      properties = { validator: obj, message: message };\n      properties.type = type || 'user defined';\n    } else if (message instanceof Object && !type) {\n      properties = isSimpleValidator(message) ? Object.assign({}, message) : clone(message);\n      if (!properties.message) {\n        properties.message = properties.msg;\n      }\n      properties.validator = obj;\n      properties.type = properties.type || 'user defined';\n    } else {\n      if (message == null) {\n        message = MongooseError.messages.general.default;\n      }\n      if (!type) {\n        type = 'user defined';\n      }\n      properties = { message: message, type: type, validator: obj };\n    }\n\n    this.validators.push(properties);\n    return this;\n  }\n\n  let i;\n  let length;\n  let arg;\n\n  for (i = 0, length = arguments.length; i < length; i++) {\n    arg = arguments[i];\n    if (!utils.isPOJO(arg)) {\n      const msg = 'Invalid validator. Received (' + typeof arg + ') '\n        + arg\n        + '. See https://mongoosejs.com/docs/api/schematype.html#SchemaType.prototype.validate()';\n\n      throw new Error(msg);\n    }\n    this.validate(arg.validator, arg);\n  }\n\n  return this;\n};\n\n/**\n * Adds a required validator to this SchemaType. The validator gets added\n * to the front of this SchemaType's validators array using `unshift()`.\n *\n * #### Example:\n *\n *     const s = new Schema({ born: { type: Date, required: true })\n *\n *     // or with custom error message\n *\n *     const s = new Schema({ born: { type: Date, required: '{PATH} is required!' })\n *\n *     // or with a function\n *\n *     const s = new Schema({\n *       userId: ObjectId,\n *       username: {\n *         type: String,\n *         required: function() { return this.userId != null; }\n *       }\n *     })\n *\n *     // or with a function and a custom message\n *     const s = new Schema({\n *       userId: ObjectId,\n *       username: {\n *         type: String,\n *         required: [\n *           function() { return this.userId != null; },\n *           'username is required if id is specified'\n *         ]\n *       }\n *     })\n *\n *     // or through the path API\n *\n *     s.path('name').required(true);\n *\n *     // with custom error messaging\n *\n *     s.path('name').required(true, 'grrr :( ');\n *\n *     // or make a path conditionally required based on a function\n *     const isOver18 = function() { return this.age >= 18; };\n *     s.path('voterRegistrationId').required(isOver18);\n *\n * The required validator uses the SchemaType's `checkRequired` function to\n * determine whether a given value satisfies the required validator. By default,\n * a value satisfies the required validator if `val != null` (that is, if\n * the value is not null nor undefined). However, most built-in mongoose schema\n * types override the default `checkRequired` function:\n *\n * @param {Boolean|Function|Object} required enable/disable the validator, or function that returns required boolean, or options object\n * @param {Boolean|Function} [options.isRequired] enable/disable the validator, or function that returns required boolean\n * @param {Function} [options.ErrorConstructor] custom error constructor. The constructor receives 1 parameter, an object containing the validator properties.\n * @param {String} [message] optional custom error message\n * @return {SchemaType} this\n * @see Customized Error Messages https://mongoosejs.com/docs/api/error.html#Error.messages\n * @see SchemaArray#checkRequired https://mongoosejs.com/docs/api/schemaarray.html#SchemaArray.prototype.checkRequired()\n * @see SchemaBoolean#checkRequired https://mongoosejs.com/docs/api/schemaboolean.html#SchemaBoolean.prototype.checkRequired()\n * @see SchemaBuffer#checkRequired https://mongoosejs.com/docs/api/schemabuffer.html#SchemaBuffer.prototype.checkRequired()\n * @see SchemaNumber#checkRequired https://mongoosejs.com/docs/api/schemanumber.html#SchemaNumber.prototype.checkRequired()\n * @see SchemaObjectId#checkRequired https://mongoosejs.com/docs/api/schemaobjectid.html#ObjectId.prototype.checkRequired()\n * @see SchemaString#checkRequired https://mongoosejs.com/docs/api/schemastring.html#SchemaString.prototype.checkRequired()\n * @api public\n */\n\nSchemaType.prototype.required = function(required, message) {\n  let customOptions = {};\n\n  if (arguments.length > 0 && required == null) {\n    this.validators = this.validators.filter(function(v) {\n      return v.validator !== this.requiredValidator;\n    }, this);\n\n    this.isRequired = false;\n    delete this.originalRequiredValue;\n    return this;\n  }\n\n  if (typeof required === 'object') {\n    customOptions = required;\n    message = customOptions.message || message;\n    required = required.isRequired;\n  }\n\n  if (required === false) {\n    this.validators = this.validators.filter(function(v) {\n      return v.validator !== this.requiredValidator;\n    }, this);\n\n    this.isRequired = false;\n    delete this.originalRequiredValue;\n    return this;\n  }\n\n  const _this = this;\n  this.isRequired = true;\n\n  this.requiredValidator = function(v) {\n    const cachedRequired = this && this.$__ && this.$__.cachedRequired;\n\n    // no validation when this path wasn't selected in the query.\n    if (cachedRequired != null && !this.$__isSelected(_this.path) && !this[documentIsModified](_this.path)) {\n      return true;\n    }\n\n    // `$cachedRequired` gets set in `_evaluateRequiredFunctions()` so we\n    // don't call required functions multiple times in one validate call\n    // See gh-6801\n    if (cachedRequired != null && _this.path in cachedRequired) {\n      const res = cachedRequired[_this.path] ?\n        _this.checkRequired(v, this) :\n        true;\n      delete cachedRequired[_this.path];\n      return res;\n    } else if (typeof required === 'function') {\n      return required.apply(this) ? _this.checkRequired(v, this) : true;\n    }\n\n    return _this.checkRequired(v, this);\n  };\n  this.originalRequiredValue = required;\n\n  if (typeof required === 'string') {\n    message = required;\n    required = undefined;\n  }\n\n  const msg = message || MongooseError.messages.general.required;\n  this.validators.unshift(Object.assign({}, customOptions, {\n    validator: this.requiredValidator,\n    message: msg,\n    type: 'required'\n  }));\n\n  return this;\n};\n\n/**\n * Set the model that this path refers to. This is the option that [populate](https://mongoosejs.com/docs/populate.html)\n * looks at to determine the foreign collection it should query.\n *\n * #### Example:\n *\n *     const userSchema = new Schema({ name: String });\n *     const User = mongoose.model('User', userSchema);\n *\n *     const postSchema = new Schema({ user: mongoose.ObjectId });\n *     postSchema.path('user').ref('User'); // Can set ref to a model name\n *     postSchema.path('user').ref(User); // Or a model class\n *     postSchema.path('user').ref(() => 'User'); // Or a function that returns the model name\n *     postSchema.path('user').ref(() => User); // Or a function that returns the model class\n *\n *     // Or you can just declare the `ref` inline in your schema\n *     const postSchema2 = new Schema({\n *       user: { type: mongoose.ObjectId, ref: User }\n *     });\n *\n * @param {String|Model|Function} ref either a model name, a [Model](https://mongoosejs.com/docs/models.html), or a function that returns a model name or model.\n * @return {SchemaType} this\n * @api public\n */\n\nSchemaType.prototype.ref = function(ref) {\n  this.options.ref = ref;\n  return this;\n};\n\n/**\n * Gets the default value\n *\n * @param {Object} scope the scope which callback are executed\n * @param {Boolean} init\n * @return {Any} The Stored default value.\n * @api private\n */\n\nSchemaType.prototype.getDefault = function(scope, init, options) {\n  let ret;\n  if (typeof this.defaultValue === 'function') {\n    if (\n      this.defaultValue === Date.now ||\n      this.defaultValue === Array ||\n      this.defaultValue.name.toLowerCase() === 'objectid'\n    ) {\n      ret = this.defaultValue.call(scope);\n    } else {\n      ret = this.defaultValue.call(scope, scope);\n    }\n  } else {\n    ret = this.defaultValue;\n  }\n\n  if (ret !== null && ret !== undefined) {\n    if (typeof ret === 'object' && (!this.options || !this.options.shared)) {\n      ret = clone(ret);\n    }\n\n    if (options && options.skipCast) {\n      return this._applySetters(ret, scope);\n    }\n\n    const casted = this.applySetters(ret, scope, init, undefined, setOptionsForDefaults);\n    if (casted && !Array.isArray(casted) && casted.$isSingleNested) {\n      casted.$__parent = scope;\n    }\n    return casted;\n  }\n  return ret;\n};\n\n/**\n * Applies setters without casting\n *\n * @param {Any} value\n * @param {Any} scope\n * @param {Boolean} init\n * @param {Any} priorVal\n * @param {Object} [options]\n * @instance\n * @api private\n */\n\nSchemaType.prototype._applySetters = function(value, scope, init, priorVal, options) {\n  let v = value;\n  if (init) {\n    return v;\n  }\n  const setters = this.setters;\n\n  for (let i = setters.length - 1; i >= 0; i--) {\n    v = setters[i].call(scope, v, priorVal, this, options);\n  }\n\n  return v;\n};\n\n/*!\n * ignore\n */\n\nSchemaType.prototype._castNullish = function _castNullish(v) {\n  return v;\n};\n\n/**\n * Applies setters\n *\n * @param {Object} value\n * @param {Object} scope\n * @param {Boolean} init\n * @return {Any}\n * @api private\n */\n\nSchemaType.prototype.applySetters = function(value, scope, init, priorVal, options) {\n  let v = this._applySetters(value, scope, init, priorVal, options);\n  if (v == null) {\n    return this._castNullish(v);\n  }\n  // do not cast until all setters are applied #665\n  v = this.cast(v, scope, init, priorVal, options);\n\n  return v;\n};\n\n/**\n * Applies getters to a value\n *\n * @param {Object} value\n * @param {Object} scope\n * @return {Any}\n * @api private\n */\n\nSchemaType.prototype.applyGetters = function(value, scope) {\n  let v = value;\n  const getters = this.getters;\n  const len = getters.length;\n\n  if (len === 0) {\n    return v;\n  }\n\n  for (let i = 0; i < len; ++i) {\n    v = getters[i].call(scope, v, this);\n  }\n\n  return v;\n};\n\n/**\n * Sets default `select()` behavior for this path.\n *\n * Set to `true` if this path should always be included in the results, `false` if it should be excluded by default. This setting can be overridden at the query level.\n *\n * #### Example:\n *\n *     T = db.model('T', new Schema({ x: { type: String, select: true }}));\n *     T.find(..); // field x will always be selected ..\n *     // .. unless overridden;\n *     T.find().select('-x').exec(callback);\n *\n * @param {Boolean} val\n * @return {SchemaType} this\n * @api public\n */\n\nSchemaType.prototype.select = function select(val) {\n  this.selected = !!val;\n  return this;\n};\n\n/**\n * Performs a validation of `value` using the validators declared for this SchemaType.\n *\n * @param {Any} value\n * @param {Function} callback\n * @param {Object} scope\n * @param {Object} [options]\n * @param {String} [options.path]\n * @return {Any} If no validators, returns the output from calling `fn`, otherwise no return\n * @api public\n */\n\nSchemaType.prototype.doValidate = function(value, fn, scope, options) {\n  let err = false;\n  const path = this.path;\n\n  // Avoid non-object `validators`\n  const validators = this.validators.\n    filter(v => typeof v === 'object' && v !== null);\n\n  let count = validators.length;\n\n  if (!count) {\n    return fn(null);\n  }\n\n  for (let i = 0, len = validators.length; i < len; ++i) {\n    if (err) {\n      break;\n    }\n\n    const v = validators[i];\n    const validator = v.validator;\n    let ok;\n\n    const validatorProperties = isSimpleValidator(v) ? Object.assign({}, v) : clone(v);\n    validatorProperties.path = options && options.path ? options.path : path;\n    validatorProperties.fullPath = this.$fullPath;\n    validatorProperties.value = value;\n\n    if (validator instanceof RegExp) {\n      validate(validator.test(value), validatorProperties, scope);\n      continue;\n    }\n\n    if (typeof validator !== 'function') {\n      continue;\n    }\n\n    if (value === undefined && validator !== this.requiredValidator) {\n      validate(true, validatorProperties, scope);\n      continue;\n    }\n\n    try {\n      if (validatorProperties.propsParameter) {\n        ok = validator.call(scope, value, validatorProperties);\n      } else {\n        ok = validator.call(scope, value);\n      }\n    } catch (error) {\n      ok = false;\n      validatorProperties.reason = error;\n      if (error.message) {\n        validatorProperties.message = error.message;\n      }\n    }\n\n    if (ok != null && typeof ok.then === 'function') {\n      ok.then(\n        function(ok) { validate(ok, validatorProperties, scope); },\n        function(error) {\n          validatorProperties.reason = error;\n          validatorProperties.message = error.message;\n          ok = false;\n          validate(ok, validatorProperties, scope);\n        });\n    } else {\n      validate(ok, validatorProperties, scope);\n    }\n  }\n\n  function validate(ok, validatorProperties, scope) {\n    if (err) {\n      return;\n    }\n    if (ok === undefined || ok) {\n      if (--count <= 0) {\n        immediate(function() {\n          fn(null);\n        });\n      }\n    } else {\n      const ErrorConstructor = validatorProperties.ErrorConstructor || ValidatorError;\n      err = new ErrorConstructor(validatorProperties, scope);\n      err[validatorErrorSymbol] = true;\n      immediate(function() {\n        fn(err);\n      });\n    }\n  }\n};\n\n\nfunction _validate(ok, validatorProperties) {\n  if (ok !== undefined && !ok) {\n    const ErrorConstructor = validatorProperties.ErrorConstructor || ValidatorError;\n    const err = new ErrorConstructor(validatorProperties);\n    err[validatorErrorSymbol] = true;\n    return err;\n  }\n}\n\n/**\n * Performs a validation of `value` using the validators declared for this SchemaType.\n *\n * #### Note:\n *\n * This method ignores the asynchronous validators.\n *\n * @param {Any} value\n * @param {Object} scope\n * @param {Object} [options]\n * @param {Object} [options.path]\n * @return {MongooseError|null}\n * @api private\n */\n\nSchemaType.prototype.doValidateSync = function(value, scope, options) {\n  const path = this.path;\n  const count = this.validators.length;\n\n  if (!count) {\n    return null;\n  }\n\n  let validators = this.validators;\n  if (value === void 0) {\n    if (this.validators.length !== 0 && this.validators[0].type === 'required') {\n      validators = [this.validators[0]];\n    } else {\n      return null;\n    }\n  }\n\n  let err = null;\n  let i = 0;\n  const len = validators.length;\n  for (i = 0; i < len; ++i) {\n\n    const v = validators[i];\n\n    if (v === null || typeof v !== 'object') {\n      continue;\n    }\n\n    const validator = v.validator;\n    const validatorProperties = isSimpleValidator(v) ? Object.assign({}, v) : clone(v);\n    validatorProperties.path = options && options.path ? options.path : path;\n    validatorProperties.fullPath = this.$fullPath;\n    validatorProperties.value = value;\n    let ok = false;\n\n    // Skip any explicit async validators. Validators that return a promise\n    // will still run, but won't trigger any errors.\n    if (isAsyncFunction(validator)) {\n      continue;\n    }\n\n    if (validator instanceof RegExp) {\n      err = _validate(validator.test(value), validatorProperties);\n      continue;\n    }\n\n    if (typeof validator !== 'function') {\n      continue;\n    }\n\n    try {\n      if (validatorProperties.propsParameter) {\n        ok = validator.call(scope, value, validatorProperties);\n      } else {\n        ok = validator.call(scope, value);\n      }\n    } catch (error) {\n      ok = false;\n      validatorProperties.reason = error;\n    }\n\n    // Skip any validators that return a promise, we can't handle those\n    // synchronously\n    if (ok != null && typeof ok.then === 'function') {\n      continue;\n    }\n    err = _validate(ok, validatorProperties);\n    if (err) {\n      break;\n    }\n  }\n\n  return err;\n};\n\n/**\n * Determines if value is a valid Reference.\n *\n * @param {SchemaType} self\n * @param {Object} value\n * @param {Document} doc\n * @param {Boolean} init\n * @return {Boolean}\n * @api private\n */\n\nSchemaType._isRef = function(self, value, doc, init) {\n  // fast path\n  let ref = init && self.options && (self.options.ref || self.options.refPath);\n\n  if (!ref && doc && doc.$__ != null) {\n    // checks for\n    // - this populated with adhoc model and no ref was set in schema OR\n    // - setting / pushing values after population\n    const path = doc.$__fullPath(self.path, true);\n\n    const owner = doc.ownerDocument();\n    ref = (path != null && owner.$populated(path)) || doc.$populated(self.path);\n  }\n\n  if (ref) {\n    if (value == null) {\n      return true;\n    }\n    if (!Buffer.isBuffer(value) && // buffers are objects too\n      value._bsontype !== 'Binary' // raw binary value from the db\n      && utils.isObject(value) // might have deselected _id in population query\n    ) {\n      return true;\n    }\n\n    return init;\n  }\n\n  return false;\n};\n\n/*!\n * ignore\n */\n\nSchemaType.prototype._castRef = function _castRef(value, doc, init) {\n  if (value == null) {\n    return value;\n  }\n\n  if (value.$__ != null) {\n    value.$__.wasPopulated = value.$__.wasPopulated || true;\n    return value;\n  }\n\n  // setting a populated path\n  if (Buffer.isBuffer(value) || !utils.isObject(value)) {\n    if (init) {\n      return value;\n    }\n    throw new CastError(this.instance, value, this.path, null, this);\n  }\n\n  // Handle the case where user directly sets a populated\n  // path to a plain object; cast to the Model used in\n  // the population query.\n  const path = doc.$__fullPath(this.path, true);\n  const owner = doc.ownerDocument();\n  const pop = owner.$populated(path, true);\n\n  let ret = value;\n  if (!doc.$__.populated ||\n    !doc.$__.populated[path] ||\n    !doc.$__.populated[path].options ||\n    !doc.$__.populated[path].options.options ||\n    !doc.$__.populated[path].options.options.lean) {\n    ret = new pop.options[populateModelSymbol](value);\n    ret.$__.wasPopulated = true;\n  }\n\n  return ret;\n};\n\n/*!\n * ignore\n */\n\nfunction handleSingle(val, context) {\n  return this.castForQuery(null, val, context);\n}\n\n/*!\n * ignore\n */\n\nfunction handleArray(val, context) {\n  const _this = this;\n  if (!Array.isArray(val)) {\n    return [this.castForQuery(null, val, context)];\n  }\n  return val.map(function(m) {\n    return _this.castForQuery(null, m, context);\n  });\n}\n\n/**\n * Just like handleArray, except also allows `[]` because surprisingly\n * `$in: [1, []]` works fine\n * @api private\n */\n\nfunction handle$in(val, context) {\n  const _this = this;\n  if (!Array.isArray(val)) {\n    return [this.castForQuery(null, val, context)];\n  }\n  return val.map(function(m) {\n    if (Array.isArray(m) && m.length === 0) {\n      return m;\n    }\n    return _this.castForQuery(null, m, context);\n  });\n}\n\n/*!\n * ignore\n */\n\nSchemaType.prototype.$conditionalHandlers = {\n  $all: handleArray,\n  $eq: handleSingle,\n  $in: handle$in,\n  $ne: handleSingle,\n  $nin: handle$in,\n  $exists: $exists,\n  $type: $type\n};\n\n/**\n * Cast the given value with the given optional query operator.\n *\n * @param {String} [$conditional] query operator, like `$eq` or `$in`\n * @param {Any} val\n * @param {Query} context\n * @return {Any}\n * @api private\n */\n\nSchemaType.prototype.castForQuery = function($conditional, val, context) {\n  let handler;\n  if ($conditional != null) {\n    handler = this.$conditionalHandlers[$conditional];\n    if (!handler) {\n      throw new Error('Can\\'t use ' + $conditional);\n    }\n    return handler.call(this, val, context);\n  }\n\n  try {\n    return this.applySetters(val, context);\n  } catch (err) {\n    if (err instanceof CastError && err.path === this.path && this.$fullPath != null) {\n      err.path = this.$fullPath;\n    }\n    throw err;\n  }\n};\n\n/**\n * Set & Get the `checkRequired` function\n * Override the function the required validator uses to check whether a value\n * passes the `required` check. Override this on the individual SchemaType.\n *\n * #### Example:\n *\n *     // Use this to allow empty strings to pass the `required` validator\n *     mongoose.Schema.Types.String.checkRequired(v => typeof v === 'string');\n *\n * @param {Function} [fn] If set, will overwrite the current set function\n * @return {Function} The input `fn` or the already set function\n * @static\n * @memberOf SchemaType\n * @function checkRequired\n * @api public\n */\n\nSchemaType.checkRequired = function(fn) {\n  if (arguments.length !== 0) {\n    this._checkRequired = fn;\n  }\n\n  return this._checkRequired;\n};\n\n/**\n * Default check for if this path satisfies the `required` validator.\n *\n * @param {Any} val\n * @return {Boolean} `true` when the value is not `null`, `false` otherwise\n * @api private\n */\n\nSchemaType.prototype.checkRequired = function(val) {\n  return val != null;\n};\n\n/**\n * Clone the current SchemaType\n *\n * @return {SchemaType} The cloned SchemaType instance\n * @api private\n */\n\nSchemaType.prototype.clone = function() {\n  const options = Object.assign({}, this.options);\n  const schematype = new this.constructor(this.path, options, this.instance);\n  schematype.validators = this.validators.slice();\n  if (this.requiredValidator !== undefined) schematype.requiredValidator = this.requiredValidator;\n  if (this.defaultValue !== undefined) schematype.defaultValue = this.defaultValue;\n  if (this.$immutable !== undefined && this.options.immutable === undefined) {\n    schematype.$immutable = this.$immutable;\n\n    handleImmutable(schematype);\n  }\n  if (this._index !== undefined) schematype._index = this._index;\n  if (this.selected !== undefined) schematype.selected = this.selected;\n  if (this.isRequired !== undefined) schematype.isRequired = this.isRequired;\n  if (this.originalRequiredValue !== undefined) schematype.originalRequiredValue = this.originalRequiredValue;\n  schematype.getters = this.getters.slice();\n  schematype.setters = this.setters.slice();\n  return schematype;\n};\n\n/*!\n * Module exports.\n */\n\nmodule.exports = exports = SchemaType;\n\nexports.CastError = CastError;\n\nexports.ValidatorError = ValidatorError;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvc2NoZW1hVHlwZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBO0FBQ0E7O0FBRUEsc0JBQXNCLG1CQUFPLENBQUMseUVBQWU7QUFDN0MsMEJBQTBCLG1CQUFPLENBQUMscUdBQTZCO0FBQy9ELGdCQUFnQixtQkFBTyxDQUFDLGlHQUEyQjtBQUNuRCxjQUFjLG1CQUFPLENBQUMsNkZBQXlCO0FBQy9DLGNBQWMsbUJBQU8sQ0FBQyw2RUFBaUI7QUFDdkMsd0JBQXdCLG1CQUFPLENBQUMsdUhBQXNDO0FBQ3RFLHdCQUF3QixtQkFBTyxDQUFDLGlHQUEyQjtBQUMzRCwwQkFBMEIsbUJBQU8sQ0FBQyxxR0FBNkI7QUFDL0Qsa0JBQWtCLG1CQUFPLENBQUMscUZBQXFCO0FBQy9DLHlCQUF5Qix5SEFBNkM7QUFDdEUsY0FBYyxtQkFBTyxDQUFDLDZEQUFTO0FBQy9CLDZCQUE2Qiw2SEFBaUQ7QUFDOUUsMkJBQTJCLDJIQUErQzs7QUFFMUUsNEJBQTRCLDRIQUFnRDs7QUFFNUU7QUFDQTs7QUFFQSxnQ0FBZ0M7O0FBRWhDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxjQUFjO0FBQ2pELGtEQUFrRDtBQUNsRDtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLG1CQUFtQjtBQUM5QixXQUFXLFFBQVE7QUFDbkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNB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QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFlBQVk7QUFDeEI7QUFDQTs7QUFFQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLGlCQUFpQjs7QUFFakIsc0JBQXNCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2xpZW50Ly4uL3NlcnZlci9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL3NjaGVtYVR5cGUuanM/OTVkNSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbi8qIVxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG5jb25zdCBNb25nb29zZUVycm9yID0gcmVxdWlyZSgnLi9lcnJvci9pbmRleCcpO1xuY29uc3QgU2NoZW1hVHlwZU9wdGlvbnMgPSByZXF1aXJlKCcuL29wdGlvbnMvc2NoZW1hVHlwZU9wdGlvbnMnKTtcbmNvbnN0ICRleGlzdHMgPSByZXF1aXJlKCcuL3NjaGVtYS9vcGVyYXRvcnMvZXhpc3RzJyk7XG5jb25zdCAkdHlwZSA9IHJlcXVpcmUoJy4vc2NoZW1hL29wZXJhdG9ycy90eXBlJyk7XG5jb25zdCBjbG9uZSA9IHJlcXVpcmUoJy4vaGVscGVycy9jbG9uZScpO1xuY29uc3QgaGFuZGxlSW1tdXRhYmxlID0gcmVxdWlyZSgnLi9oZWxwZXJzL3NjaGVtYXR5cGUvaGFuZGxlSW1tdXRhYmxlJyk7XG5jb25zdCBpc0FzeW5jRnVuY3Rpb24gPSByZXF1aXJlKCcuL2hlbHBlcnMvaXNBc3luY0Z1bmN0aW9uJyk7XG5jb25zdCBpc1NpbXBsZVZhbGlkYXRvciA9IHJlcXVpcmUoJy4vaGVscGVycy9pc1NpbXBsZVZhbGlkYXRvcicpO1xuY29uc3QgaW1tZWRpYXRlID0gcmVxdWlyZSgnLi9oZWxwZXJzL2ltbWVkaWF0ZScpO1xuY29uc3Qgc2NoZW1hVHlwZVN5bWJvbCA9IHJlcXVpcmUoJy4vaGVscGVycy9zeW1ib2xzJykuc2NoZW1hVHlwZVN5bWJvbDtcbmNvbnN0IHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xuY29uc3QgdmFsaWRhdG9yRXJyb3JTeW1ib2wgPSByZXF1aXJlKCcuL2hlbHBlcnMvc3ltYm9scycpLnZhbGlkYXRvckVycm9yU3ltYm9sO1xuY29uc3QgZG9jdW1lbnRJc01vZGlmaWVkID0gcmVxdWlyZSgnLi9oZWxwZXJzL3N5bWJvbHMnKS5kb2N1bWVudElzTW9kaWZpZWQ7XG5cbmNvbnN0IHBvcHVsYXRlTW9kZWxTeW1ib2wgPSByZXF1aXJlKCcuL2hlbHBlcnMvc3ltYm9scycpLnBvcHVsYXRlTW9kZWxTeW1ib2w7XG5cbmNvbnN0IENhc3RFcnJvciA9IE1vbmdvb3NlRXJyb3IuQ2FzdEVycm9yO1xuY29uc3QgVmFsaWRhdG9yRXJyb3IgPSBNb25nb29zZUVycm9yLlZhbGlkYXRvckVycm9yO1xuXG5jb25zdCBzZXRPcHRpb25zRm9yRGVmYXVsdHMgPSB7IF9za2lwTWFya01vZGlmaWVkOiB0cnVlIH07XG5cbi8qKlxuICogU2NoZW1hVHlwZSBjb25zdHJ1Y3Rvci4gRG8gKipub3QqKiBpbnN0YW50aWF0ZSBgU2NoZW1hVHlwZWAgZGlyZWN0bHkuXG4gKiBNb25nb29zZSBjb252ZXJ0cyB5b3VyIHNjaGVtYSBwYXRocyBpbnRvIFNjaGVtYVR5cGVzIGF1dG9tYXRpY2FsbHkuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBjb25zdCBzY2hlbWEgPSBuZXcgU2NoZW1hKHsgbmFtZTogU3RyaW5nIH0pO1xuICogICAgIHNjaGVtYS5wYXRoKCduYW1lJykgaW5zdGFuY2VvZiBTY2hlbWFUeXBlOyAvLyB0cnVlXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHBhdGhcbiAqIEBwYXJhbSB7U2NoZW1hVHlwZU9wdGlvbnN9IFtvcHRpb25zXSBTZWUgW1NjaGVtYVR5cGVPcHRpb25zIGRvY3NdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvc2NoZW1hdHlwZW9wdGlvbnMuaHRtbClcbiAqIEBwYXJhbSB7U3RyaW5nfSBbaW5zdGFuY2VdXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIFNjaGVtYVR5cGUocGF0aCwgb3B0aW9ucywgaW5zdGFuY2UpIHtcbiAgdGhpc1tzY2hlbWFUeXBlU3ltYm9sXSA9IHRydWU7XG4gIHRoaXMucGF0aCA9IHBhdGg7XG4gIHRoaXMuaW5zdGFuY2UgPSBpbnN0YW5jZTtcbiAgdGhpcy52YWxpZGF0b3JzID0gW107XG4gIHRoaXMuZ2V0dGVycyA9IHRoaXMuY29uc3RydWN0b3IuaGFzT3duUHJvcGVydHkoJ2dldHRlcnMnKSA/XG4gICAgdGhpcy5jb25zdHJ1Y3Rvci5nZXR0ZXJzLnNsaWNlKCkgOlxuICAgIFtdO1xuICB0aGlzLnNldHRlcnMgPSB0aGlzLmNvbnN0cnVjdG9yLmhhc093blByb3BlcnR5KCdzZXR0ZXJzJykgP1xuICAgIHRoaXMuY29uc3RydWN0b3Iuc2V0dGVycy5zbGljZSgpIDpcbiAgICBbXTtcblxuICB0aGlzLnNwbGl0UGF0aCgpO1xuXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBjb25zdCBkZWZhdWx0T3B0aW9ucyA9IHRoaXMuY29uc3RydWN0b3IuZGVmYXVsdE9wdGlvbnMgfHwge307XG4gIGNvbnN0IGRlZmF1bHRPcHRpb25zS2V5cyA9IE9iamVjdC5rZXlzKGRlZmF1bHRPcHRpb25zKTtcblxuICBmb3IgKGNvbnN0IG9wdGlvbiBvZiBkZWZhdWx0T3B0aW9uc0tleXMpIHtcbiAgICBpZiAob3B0aW9uID09PSAndmFsaWRhdGUnKSB7XG4gICAgICB0aGlzLnZhbGlkYXRlKGRlZmF1bHRPcHRpb25zLnZhbGlkYXRlKTtcbiAgICB9IGVsc2UgaWYgKGRlZmF1bHRPcHRpb25zLmhhc093blByb3BlcnR5KG9wdGlvbikgJiYgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvcHRpb25zLCBvcHRpb24pKSB7XG4gICAgICBvcHRpb25zW29wdGlvbl0gPSBkZWZhdWx0T3B0aW9uc1tvcHRpb25dO1xuICAgIH1cbiAgfVxuXG4gIGlmIChvcHRpb25zLnNlbGVjdCA9PSBudWxsKSB7XG4gICAgZGVsZXRlIG9wdGlvbnMuc2VsZWN0O1xuICB9XG5cbiAgY29uc3QgT3B0aW9ucyA9IHRoaXMuT3B0aW9uc0NvbnN0cnVjdG9yIHx8IFNjaGVtYVR5cGVPcHRpb25zO1xuICB0aGlzLm9wdGlvbnMgPSBuZXcgT3B0aW9ucyhvcHRpb25zKTtcbiAgdGhpcy5faW5kZXggPSBudWxsO1xuXG5cbiAgaWYgKHV0aWxzLmhhc1VzZXJEZWZpbmVkUHJvcGVydHkodGhpcy5vcHRpb25zLCAnaW1tdXRhYmxlJykpIHtcbiAgICB0aGlzLiRpbW11dGFibGUgPSB0aGlzLm9wdGlvbnMuaW1tdXRhYmxlO1xuXG4gICAgaGFuZGxlSW1tdXRhYmxlKHRoaXMpO1xuICB9XG5cbiAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHRoaXMub3B0aW9ucyk7XG4gIGZvciAoY29uc3QgcHJvcCBvZiBrZXlzKSB7XG4gICAgaWYgKHByb3AgPT09ICdjYXN0Jykge1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkodGhpcy5vcHRpb25zW3Byb3BdKSkge1xuICAgICAgICB0aGlzLmNhc3RGdW5jdGlvbi5hcHBseSh0aGlzLCB0aGlzLm9wdGlvbnNbcHJvcF0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5jYXN0RnVuY3Rpb24odGhpcy5vcHRpb25zW3Byb3BdKTtcbiAgICAgIH1cbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAodXRpbHMuaGFzVXNlckRlZmluZWRQcm9wZXJ0eSh0aGlzLm9wdGlvbnMsIHByb3ApICYmIHR5cGVvZiB0aGlzW3Byb3BdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAvLyB7IHVuaXF1ZTogdHJ1ZSwgaW5kZXg6IHRydWUgfVxuICAgICAgaWYgKHByb3AgPT09ICdpbmRleCcgJiYgdGhpcy5faW5kZXgpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMuaW5kZXggPT09IGZhbHNlKSB7XG4gICAgICAgICAgY29uc3QgaW5kZXggPSB0aGlzLl9pbmRleDtcbiAgICAgICAgICBpZiAodHlwZW9mIGluZGV4ID09PSAnb2JqZWN0JyAmJiBpbmRleCAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAoaW5kZXgudW5pcXVlKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUGF0aCBcIicgKyB0aGlzLnBhdGggKyAnXCIgbWF5IG5vdCBoYXZlIGBpbmRleGAgJyArXG4gICAgICAgICAgICAgICAgJ3NldCB0byBmYWxzZSBhbmQgYHVuaXF1ZWAgc2V0IHRvIHRydWUnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpbmRleC5zcGFyc2UpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQYXRoIFwiJyArIHRoaXMucGF0aCArICdcIiBtYXkgbm90IGhhdmUgYGluZGV4YCAnICtcbiAgICAgICAgICAgICAgICAnc2V0IHRvIGZhbHNlIGFuZCBgc3BhcnNlYCBzZXQgdG8gdHJ1ZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMuX2luZGV4ID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHZhbCA9IG9wdGlvbnNbcHJvcF07XG4gICAgICAvLyBTcGVjaWFsIGNhc2Ugc28gd2UgZG9uJ3Qgc2NyZXcgdXAgYXJyYXkgZGVmYXVsdHMsIHNlZSBnaC01NzgwXG4gICAgICBpZiAocHJvcCA9PT0gJ2RlZmF1bHQnKSB7XG4gICAgICAgIHRoaXMuZGVmYXVsdCh2YWwpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgY29uc3Qgb3B0cyA9IEFycmF5LmlzQXJyYXkodmFsKSA/IHZhbCA6IFt2YWxdO1xuXG4gICAgICB0aGlzW3Byb3BdLmFwcGx5KHRoaXMsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnJCRjb250ZXh0Jywge1xuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgd3JpdGFibGU6IHRydWUsXG4gICAgdmFsdWU6IG51bGxcbiAgfSk7XG59XG5cbi8qKlxuICogVGhlIGNsYXNzIHRoYXQgTW9uZ29vc2UgdXNlcyBpbnRlcm5hbGx5IHRvIGluc3RhbnRpYXRlIHRoaXMgU2NoZW1hVHlwZSdzIGBvcHRpb25zYCBwcm9wZXJ0eS5cbiAqIEBtZW1iZXJPZiBTY2hlbWFUeXBlXG4gKiBAaW5zdGFuY2VcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNjaGVtYVR5cGUucHJvdG90eXBlLk9wdGlvbnNDb25zdHJ1Y3RvciA9IFNjaGVtYVR5cGVPcHRpb25zO1xuXG4vKipcbiAqIFRoZSBwYXRoIHRvIHRoaXMgU2NoZW1hVHlwZSBpbiBhIFNjaGVtYS5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IHNjaGVtYSA9IG5ldyBTY2hlbWEoeyBuYW1lOiBTdHJpbmcgfSk7XG4gKiAgICAgc2NoZW1hLnBhdGgoJ25hbWUnKS5wYXRoOyAvLyAnbmFtZSdcbiAqXG4gKiBAcHJvcGVydHkgcGF0aFxuICogQGFwaSBwdWJsaWNcbiAqIEBtZW1iZXJPZiBTY2hlbWFUeXBlXG4gKi9cblxuU2NoZW1hVHlwZS5wcm90b3R5cGUucGF0aDtcblxuLyoqXG4gKiBUaGUgdmFsaWRhdG9ycyB0aGF0IE1vbmdvb3NlIHNob3VsZCBydW4gdG8gdmFsaWRhdGUgcHJvcGVydGllcyBhdCB0aGlzIFNjaGVtYVR5cGUncyBwYXRoLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgY29uc3Qgc2NoZW1hID0gbmV3IFNjaGVtYSh7IG5hbWU6IHsgdHlwZTogU3RyaW5nLCByZXF1aXJlZDogdHJ1ZSB9IH0pO1xuICogICAgIHNjaGVtYS5wYXRoKCduYW1lJykudmFsaWRhdG9ycy5sZW5ndGg7IC8vIDEsIHRoZSBgcmVxdWlyZWRgIHZhbGlkYXRvclxuICpcbiAqIEBwcm9wZXJ0eSB2YWxpZGF0b3JzXG4gKiBAYXBpIHB1YmxpY1xuICogQG1lbWJlck9mIFNjaGVtYVR5cGVcbiAqL1xuXG5TY2hlbWFUeXBlLnByb3RvdHlwZS52YWxpZGF0b3JzO1xuXG4vKipcbiAqIFRydWUgaWYgdGhpcyBTY2hlbWFUeXBlIGhhcyBhIHJlcXVpcmVkIHZhbGlkYXRvci4gRmFsc2Ugb3RoZXJ3aXNlLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgY29uc3Qgc2NoZW1hID0gbmV3IFNjaGVtYSh7IG5hbWU6IHsgdHlwZTogU3RyaW5nLCByZXF1aXJlZDogdHJ1ZSB9IH0pO1xuICogICAgIHNjaGVtYS5wYXRoKCduYW1lJykuaXNSZXF1aXJlZDsgLy8gdHJ1ZVxuICpcbiAqICAgICBzY2hlbWEucGF0aCgnbmFtZScpLnJlcXVpcmVkKGZhbHNlKTtcbiAqICAgICBzY2hlbWEucGF0aCgnbmFtZScpLmlzUmVxdWlyZWQ7IC8vIGZhbHNlXG4gKlxuICogQHByb3BlcnR5IGlzUmVxdWlyZWRcbiAqIEBhcGkgcHVibGljXG4gKiBAbWVtYmVyT2YgU2NoZW1hVHlwZVxuICovXG5cblNjaGVtYVR5cGUucHJvdG90eXBlLmlzUmVxdWlyZWQ7XG5cbi8qKlxuICogU3BsaXQgdGhlIGN1cnJlbnQgZG90dGV0IHBhdGggaW50byBzZWdtZW50c1xuICpcbiAqIEByZXR1cm4ge1N0cmluZ1tdfHVuZGVmaW5lZH1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNjaGVtYVR5cGUucHJvdG90eXBlLnNwbGl0UGF0aCA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5fcHJlc3BsaXRQYXRoICE9IG51bGwpIHtcbiAgICByZXR1cm4gdGhpcy5fcHJlc3BsaXRQYXRoO1xuICB9XG4gIGlmICh0aGlzLnBhdGggPT0gbnVsbCkge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cblxuICB0aGlzLl9wcmVzcGxpdFBhdGggPSB0aGlzLnBhdGguaW5kZXhPZignLicpID09PSAtMSA/IFt0aGlzLnBhdGhdIDogdGhpcy5wYXRoLnNwbGl0KCcuJyk7XG4gIHJldHVybiB0aGlzLl9wcmVzcGxpdFBhdGg7XG59O1xuXG4vKipcbiAqIEdldC9zZXQgdGhlIGZ1bmN0aW9uIHVzZWQgdG8gY2FzdCBhcmJpdHJhcnkgdmFsdWVzIHRvIHRoaXMgdHlwZS5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIC8vIERpc2FsbG93IGBudWxsYCBmb3IgbnVtYmVycywgYW5kIGRvbid0IHRyeSB0byBjYXN0IGFueSB2YWx1ZXMgdG9cbiAqICAgICAvLyBudW1iZXJzLCBzbyBldmVuIHN0cmluZ3MgbGlrZSAnMTIzJyB3aWxsIGNhdXNlIGEgQ2FzdEVycm9yLlxuICogICAgIG1vbmdvb3NlLk51bWJlci5jYXN0KGZ1bmN0aW9uKHYpIHtcbiAqICAgICAgIGFzc2VydC5vayh2ID09PSB1bmRlZmluZWQgfHwgdHlwZW9mIHYgPT09ICdudW1iZXInKTtcbiAqICAgICAgIHJldHVybiB2O1xuICogICAgIH0pO1xuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb258ZmFsc2V9IGNhc3RlciBGdW5jdGlvbiB0aGF0IGNhc3RzIGFyYml0cmFyeSB2YWx1ZXMgdG8gdGhpcyB0eXBlLCBvciB0aHJvd3MgYW4gZXJyb3IgaWYgY2FzdGluZyBmYWlsZWRcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIFNjaGVtYVR5cGVcbiAqIEBmdW5jdGlvbiBjYXN0XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblNjaGVtYVR5cGUuY2FzdCA9IGZ1bmN0aW9uIGNhc3QoY2FzdGVyKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIHRoaXMuX2Nhc3Q7XG4gIH1cbiAgaWYgKGNhc3RlciA9PT0gZmFsc2UpIHtcbiAgICBjYXN0ZXIgPSB2ID0+IHY7XG4gIH1cbiAgdGhpcy5fY2FzdCA9IGNhc3RlcjtcblxuICByZXR1cm4gdGhpcy5fY2FzdDtcbn07XG5cbi8qKlxuICogR2V0L3NldCB0aGUgZnVuY3Rpb24gdXNlZCB0byBjYXN0IGFyYml0cmFyeSB2YWx1ZXMgdG8gdGhpcyBwYXJ0aWN1bGFyIHNjaGVtYXR5cGUgaW5zdGFuY2UuXG4gKiBPdmVycmlkZXMgYFNjaGVtYVR5cGUuY2FzdCgpYC5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIC8vIERpc2FsbG93IGBudWxsYCBmb3IgbnVtYmVycywgYW5kIGRvbid0IHRyeSB0byBjYXN0IGFueSB2YWx1ZXMgdG9cbiAqICAgICAvLyBudW1iZXJzLCBzbyBldmVuIHN0cmluZ3MgbGlrZSAnMTIzJyB3aWxsIGNhdXNlIGEgQ2FzdEVycm9yLlxuICogICAgIGNvbnN0IG51bWJlciA9IG5ldyBtb25nb29zZS5OdW1iZXIoJ215cGF0aCcsIHt9KTtcbiAqICAgICBudW1iZXIuY2FzdChmdW5jdGlvbih2KSB7XG4gKiAgICAgICBhc3NlcnQub2sodiA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiB2ID09PSAnbnVtYmVyJyk7XG4gKiAgICAgICByZXR1cm4gdjtcbiAqICAgICB9KTtcbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufGZhbHNlfSBjYXN0ZXIgRnVuY3Rpb24gdGhhdCBjYXN0cyBhcmJpdHJhcnkgdmFsdWVzIHRvIHRoaXMgdHlwZSwgb3IgdGhyb3dzIGFuIGVycm9yIGlmIGNhc3RpbmcgZmFpbGVkXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAqIEBtZW1iZXJPZiBTY2hlbWFUeXBlXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblNjaGVtYVR5cGUucHJvdG90eXBlLmNhc3RGdW5jdGlvbiA9IGZ1bmN0aW9uIGNhc3RGdW5jdGlvbihjYXN0ZXIsIG1lc3NhZ2UpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gdGhpcy5fY2FzdEZ1bmN0aW9uO1xuICB9XG5cbiAgaWYgKGNhc3RlciA9PT0gZmFsc2UpIHtcbiAgICBjYXN0ZXIgPSB0aGlzLmNvbnN0cnVjdG9yLl9kZWZhdWx0Q2FzdGVyIHx8ICh2ID0+IHYpO1xuICB9XG4gIGlmICh0eXBlb2YgY2FzdGVyID09PSAnc3RyaW5nJykge1xuICAgIHRoaXMuX2Nhc3RFcnJvck1lc3NhZ2UgPSBjYXN0ZXI7XG4gICAgcmV0dXJuIHRoaXMuX2Nhc3RGdW5jdGlvbjtcbiAgfVxuICBpZiAoY2FzdGVyICE9IG51bGwpIHtcbiAgICB0aGlzLl9jYXN0RnVuY3Rpb24gPSBjYXN0ZXI7XG4gIH1cbiAgaWYgKG1lc3NhZ2UgIT0gbnVsbCkge1xuICAgIHRoaXMuX2Nhc3RFcnJvck1lc3NhZ2UgPSBtZXNzYWdlO1xuICB9XG5cbiAgcmV0dXJuIHRoaXMuX2Nhc3RGdW5jdGlvbjtcbn07XG5cbi8qKlxuICogVGhlIGZ1bmN0aW9uIHRoYXQgTW9uZ29vc2UgY2FsbHMgdG8gY2FzdCBhcmJpdHJhcnkgdmFsdWVzIHRvIHRoaXMgU2NoZW1hVHlwZS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsdWUgdmFsdWUgdG8gY2FzdFxuICogQHBhcmFtIHtEb2N1bWVudH0gZG9jIGRvY3VtZW50IHRoYXQgdHJpZ2dlcnMgdGhlIGNhc3RpbmdcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gaW5pdFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5TY2hlbWFUeXBlLnByb3RvdHlwZS5jYXN0ID0gZnVuY3Rpb24gY2FzdCgpIHtcbiAgdGhyb3cgbmV3IEVycm9yKCdCYXNlIFNjaGVtYVR5cGUgY2xhc3MgZG9lcyBub3QgaW1wbGVtZW50IGEgYGNhc3QoKWAgZnVuY3Rpb24nKTtcbn07XG5cbi8qKlxuICogU2V0cyBhIGRlZmF1bHQgb3B0aW9uIGZvciB0aGlzIHNjaGVtYSB0eXBlLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgLy8gTWFrZSBhbGwgc3RyaW5ncyBiZSB0cmltbWVkIGJ5IGRlZmF1bHRcbiAqICAgICBtb25nb29zZS5TY2hlbWFUeXBlcy5TdHJpbmcuc2V0KCd0cmltJywgdHJ1ZSk7XG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG9wdGlvbiBUaGUgbmFtZSBvZiB0aGUgb3B0aW9uIHlvdSdkIGxpa2UgdG8gc2V0IChlLmcuIHRyaW0sIGxvd2VyY2FzZSwgZXRjLi4uKVxuICogQHBhcmFtIHtBbnl9IHZhbHVlIFRoZSB2YWx1ZSBvZiB0aGUgb3B0aW9uIHlvdSdkIGxpa2UgdG8gc2V0LlxuICogQHJldHVybiB7dm9pZH1cbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBTY2hlbWFUeXBlXG4gKiBAZnVuY3Rpb24gc2V0XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblNjaGVtYVR5cGUuc2V0ID0gZnVuY3Rpb24gc2V0KG9wdGlvbiwgdmFsdWUpIHtcbiAgaWYgKCF0aGlzLmhhc093blByb3BlcnR5KCdkZWZhdWx0T3B0aW9ucycpKSB7XG4gICAgdGhpcy5kZWZhdWx0T3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMuZGVmYXVsdE9wdGlvbnMpO1xuICB9XG4gIHRoaXMuZGVmYXVsdE9wdGlvbnNbb3B0aW9uXSA9IHZhbHVlO1xufTtcblxuLyoqXG4gKiBBdHRhY2hlcyBhIGdldHRlciBmb3IgYWxsIGluc3RhbmNlcyBvZiB0aGlzIHNjaGVtYSB0eXBlLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgLy8gTWFrZSBhbGwgbnVtYmVycyByb3VuZCBkb3duXG4gKiAgICAgbW9uZ29vc2UuTnVtYmVyLmdldChmdW5jdGlvbih2KSB7IHJldHVybiBNYXRoLmZsb29yKHYpOyB9KTtcbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBnZXR0ZXJcbiAqIEByZXR1cm4ge3RoaXN9XG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgU2NoZW1hVHlwZVxuICogQGZ1bmN0aW9uIGdldFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5TY2hlbWFUeXBlLmdldCA9IGZ1bmN0aW9uKGdldHRlcikge1xuICB0aGlzLmdldHRlcnMgPSB0aGlzLmhhc093blByb3BlcnR5KCdnZXR0ZXJzJykgPyB0aGlzLmdldHRlcnMgOiBbXTtcbiAgdGhpcy5nZXR0ZXJzLnB1c2goZ2V0dGVyKTtcbn07XG5cbi8qKlxuICogU2V0cyBhIGRlZmF1bHQgdmFsdWUgZm9yIHRoaXMgU2NoZW1hVHlwZS5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IHNjaGVtYSA9IG5ldyBTY2hlbWEoeyBuOiB7IHR5cGU6IE51bWJlciwgZGVmYXVsdDogMTAgfSlcbiAqICAgICBjb25zdCBNID0gZGIubW9kZWwoJ00nLCBzY2hlbWEpXG4gKiAgICAgY29uc3QgbSA9IG5ldyBNO1xuICogICAgIGNvbnNvbGUubG9nKG0ubikgLy8gMTBcbiAqXG4gKiBEZWZhdWx0cyBjYW4gYmUgZWl0aGVyIGBmdW5jdGlvbnNgIHdoaWNoIHJldHVybiB0aGUgdmFsdWUgdG8gdXNlIGFzIHRoZSBkZWZhdWx0IG9yIHRoZSBsaXRlcmFsIHZhbHVlIGl0c2VsZi4gRWl0aGVyIHdheSwgdGhlIHZhbHVlIHdpbGwgYmUgY2FzdCBiYXNlZCBvbiBpdHMgc2NoZW1hIHR5cGUgYmVmb3JlIGJlaW5nIHNldCBkdXJpbmcgZG9jdW1lbnQgY3JlYXRpb24uXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICAvLyB2YWx1ZXMgYXJlIGNhc3Q6XG4gKiAgICAgY29uc3Qgc2NoZW1hID0gbmV3IFNjaGVtYSh7IGFOdW1iZXI6IHsgdHlwZTogTnVtYmVyLCBkZWZhdWx0OiA0LjgxNTE2MjM0MiB9fSlcbiAqICAgICBjb25zdCBNID0gZGIubW9kZWwoJ00nLCBzY2hlbWEpXG4gKiAgICAgY29uc3QgbSA9IG5ldyBNO1xuICogICAgIGNvbnNvbGUubG9nKG0uYU51bWJlcikgLy8gNC44MTUxNjIzNDJcbiAqXG4gKiAgICAgLy8gZGVmYXVsdCB1bmlxdWUgb2JqZWN0cyBmb3IgTWl4ZWQgdHlwZXM6XG4gKiAgICAgY29uc3Qgc2NoZW1hID0gbmV3IFNjaGVtYSh7IG1peGVkOiBTY2hlbWEuVHlwZXMuTWl4ZWQgfSk7XG4gKiAgICAgc2NoZW1hLnBhdGgoJ21peGVkJykuZGVmYXVsdChmdW5jdGlvbiAoKSB7XG4gKiAgICAgICByZXR1cm4ge307XG4gKiAgICAgfSk7XG4gKlxuICogICAgIC8vIGlmIHdlIGRvbid0IHVzZSBhIGZ1bmN0aW9uIHRvIHJldHVybiBvYmplY3QgbGl0ZXJhbHMgZm9yIE1peGVkIGRlZmF1bHRzLFxuICogICAgIC8vIGVhY2ggZG9jdW1lbnQgd2lsbCByZWNlaXZlIGEgcmVmZXJlbmNlIHRvIHRoZSBzYW1lIG9iamVjdCBsaXRlcmFsIGNyZWF0aW5nXG4gKiAgICAgLy8gYSBcInNoYXJlZFwiIG9iamVjdCBpbnN0YW5jZTpcbiAqICAgICBjb25zdCBzY2hlbWEgPSBuZXcgU2NoZW1hKHsgbWl4ZWQ6IFNjaGVtYS5UeXBlcy5NaXhlZCB9KTtcbiAqICAgICBzY2hlbWEucGF0aCgnbWl4ZWQnKS5kZWZhdWx0KHt9KTtcbiAqICAgICBjb25zdCBNID0gZGIubW9kZWwoJ00nLCBzY2hlbWEpO1xuICogICAgIGNvbnN0IG0xID0gbmV3IE07XG4gKiAgICAgbTEubWl4ZWQuYWRkZWQgPSAxO1xuICogICAgIGNvbnNvbGUubG9nKG0xLm1peGVkKTsgLy8geyBhZGRlZDogMSB9XG4gKiAgICAgY29uc3QgbTIgPSBuZXcgTTtcbiAqICAgICBjb25zb2xlLmxvZyhtMi5taXhlZCk7IC8vIHsgYWRkZWQ6IDEgfVxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb258YW55fSB2YWwgVGhlIGRlZmF1bHQgdmFsdWUgdG8gc2V0XG4gKiBAcmV0dXJuIHtBbnl8dW5kZWZpbmVkfSBSZXR1cm5zIHRoZSBzZXQgZGVmYXVsdCB2YWx1ZS5cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuU2NoZW1hVHlwZS5wcm90b3R5cGUuZGVmYXVsdCA9IGZ1bmN0aW9uKHZhbCkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgIGlmICh2YWwgPT09IHZvaWQgMCkge1xuICAgICAgdGhpcy5kZWZhdWx0VmFsdWUgPSB2b2lkIDA7XG4gICAgICByZXR1cm4gdm9pZCAwO1xuICAgIH1cblxuICAgIGlmICh2YWwgIT0gbnVsbCAmJiB2YWwuaW5zdGFuY2VPZlNjaGVtYSkge1xuICAgICAgdGhyb3cgbmV3IE1vbmdvb3NlRXJyb3IoJ0Nhbm5vdCBzZXQgZGVmYXVsdCB2YWx1ZSBvZiBwYXRoIGAnICsgdGhpcy5wYXRoICtcbiAgICAgICAgJ2AgdG8gYSBtb25nb29zZSBTY2hlbWEgaW5zdGFuY2UuJyk7XG4gICAgfVxuXG4gICAgdGhpcy5kZWZhdWx0VmFsdWUgPSB2YWw7XG4gICAgcmV0dXJuIHRoaXMuZGVmYXVsdFZhbHVlO1xuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgdGhpcy5kZWZhdWx0VmFsdWUgPSBbLi4uYXJndW1lbnRzXTtcbiAgfVxuICByZXR1cm4gdGhpcy5kZWZhdWx0VmFsdWU7XG59O1xuXG4vKipcbiAqIERlY2xhcmVzIHRoZSBpbmRleCBvcHRpb25zIGZvciB0aGlzIHNjaGVtYXR5cGUuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBjb25zdCBzID0gbmV3IFNjaGVtYSh7IG5hbWU6IHsgdHlwZTogU3RyaW5nLCBpbmRleDogdHJ1ZSB9KVxuICogICAgIGNvbnN0IHMgPSBuZXcgU2NoZW1hKHsgbmFtZTogeyB0eXBlOiBTdHJpbmcsIGluZGV4OiAtMSB9KVxuICogICAgIGNvbnN0IHMgPSBuZXcgU2NoZW1hKHsgbG9jOiB7IHR5cGU6IFtOdW1iZXJdLCBpbmRleDogJ2hhc2hlZCcgfSlcbiAqICAgICBjb25zdCBzID0gbmV3IFNjaGVtYSh7IGxvYzogeyB0eXBlOiBbTnVtYmVyXSwgaW5kZXg6ICcyZCcsIHNwYXJzZTogdHJ1ZSB9KVxuICogICAgIGNvbnN0IHMgPSBuZXcgU2NoZW1hKHsgbG9jOiB7IHR5cGU6IFtOdW1iZXJdLCBpbmRleDogeyB0eXBlOiAnMmRzcGhlcmUnLCBzcGFyc2U6IHRydWUgfX0pXG4gKiAgICAgY29uc3QgcyA9IG5ldyBTY2hlbWEoeyBkYXRlOiB7IHR5cGU6IERhdGUsIGluZGV4OiB7IHVuaXF1ZTogdHJ1ZSwgZXhwaXJlczogJzFkJyB9fSlcbiAqICAgICBzLnBhdGgoJ215LnBhdGgnKS5pbmRleCh0cnVlKTtcbiAqICAgICBzLnBhdGgoJ215LmRhdGUnKS5pbmRleCh7IGV4cGlyZXM6IDYwIH0pO1xuICogICAgIHMucGF0aCgnbXkucGF0aCcpLmluZGV4KHsgdW5pcXVlOiB0cnVlLCBzcGFyc2U6IHRydWUgfSk7XG4gKlxuICogIyMjIyBOb3RlOlxuICpcbiAqIF9JbmRleGVzIGFyZSBjcmVhdGVkIFtpbiB0aGUgYmFja2dyb3VuZF0oaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvY29yZS9pbmRleC1jcmVhdGlvbi8jaW5kZXgtY3JlYXRpb24tYmFja2dyb3VuZClcbiAqIGJ5IGRlZmF1bHQuIElmIGBiYWNrZ3JvdW5kYCBpcyBzZXQgdG8gYGZhbHNlYCwgTW9uZ29EQiB3aWxsIG5vdCBleGVjdXRlIGFueVxuICogcmVhZC93cml0ZSBvcGVyYXRpb25zIHlvdSBzZW5kIHVudGlsIHRoZSBpbmRleCBidWlsZC5cbiAqIFNwZWNpZnkgYGJhY2tncm91bmQ6IGZhbHNlYCB0byBvdmVycmlkZSBNb25nb29zZSdzIGRlZmF1bHQuX1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fEJvb2xlYW58U3RyaW5nfE51bWJlcn0gb3B0aW9uc1xuICogQHJldHVybiB7U2NoZW1hVHlwZX0gdGhpc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5TY2hlbWFUeXBlLnByb3RvdHlwZS5pbmRleCA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgdGhpcy5faW5kZXggPSBvcHRpb25zO1xuICB1dGlscy5leHBpcmVzKHRoaXMuX2luZGV4KTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIERlY2xhcmVzIGFuIHVuaXF1ZSBpbmRleC5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IHMgPSBuZXcgU2NoZW1hKHsgbmFtZTogeyB0eXBlOiBTdHJpbmcsIHVuaXF1ZTogdHJ1ZSB9IH0pO1xuICogICAgIHMucGF0aCgnbmFtZScpLmluZGV4KHsgdW5pcXVlOiB0cnVlIH0pO1xuICpcbiAqIF9OT1RFOiB2aW9sYXRpbmcgdGhlIGNvbnN0cmFpbnQgcmV0dXJucyBhbiBgRTExMDAwYCBlcnJvciBmcm9tIE1vbmdvREIgd2hlbiBzYXZpbmcsIG5vdCBhIE1vbmdvb3NlIHZhbGlkYXRpb24gZXJyb3IuX1xuICpcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gYm9vbFxuICogQHJldHVybiB7U2NoZW1hVHlwZX0gdGhpc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5TY2hlbWFUeXBlLnByb3RvdHlwZS51bmlxdWUgPSBmdW5jdGlvbihib29sKSB7XG4gIGlmICh0aGlzLl9pbmRleCA9PT0gZmFsc2UpIHtcbiAgICBpZiAoIWJvb2wpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKCdQYXRoIFwiJyArIHRoaXMucGF0aCArICdcIiBtYXkgbm90IGhhdmUgYGluZGV4YCBzZXQgdG8gJyArXG4gICAgICAnZmFsc2UgYW5kIGB1bmlxdWVgIHNldCB0byB0cnVlJyk7XG4gIH1cblxuICBpZiAoIXRoaXMub3B0aW9ucy5oYXNPd25Qcm9wZXJ0eSgnaW5kZXgnKSAmJiBib29sID09PSBmYWxzZSkge1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgaWYgKHRoaXMuX2luZGV4ID09IG51bGwgfHwgdGhpcy5faW5kZXggPT09IHRydWUpIHtcbiAgICB0aGlzLl9pbmRleCA9IHt9O1xuICB9IGVsc2UgaWYgKHR5cGVvZiB0aGlzLl9pbmRleCA9PT0gJ3N0cmluZycpIHtcbiAgICB0aGlzLl9pbmRleCA9IHsgdHlwZTogdGhpcy5faW5kZXggfTtcbiAgfVxuXG4gIHRoaXMuX2luZGV4LnVuaXF1ZSA9IGJvb2w7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBEZWNsYXJlcyBhIGZ1bGwgdGV4dCBpbmRleC5cbiAqXG4gKiAjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgIGNvbnN0IHMgPSBuZXcgU2NoZW1hKHsgbmFtZSA6IHsgdHlwZTogU3RyaW5nLCB0ZXh0IDogdHJ1ZSB9IH0pXG4gKiAgICAgIHMucGF0aCgnbmFtZScpLmluZGV4KHsgdGV4dCA6IHRydWUgfSk7XG4gKlxuICogQHBhcmFtIHtCb29sZWFufSBib29sXG4gKiBAcmV0dXJuIHtTY2hlbWFUeXBlfSB0aGlzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblNjaGVtYVR5cGUucHJvdG90eXBlLnRleHQgPSBmdW5jdGlvbihib29sKSB7XG4gIGlmICh0aGlzLl9pbmRleCA9PT0gZmFsc2UpIHtcbiAgICBpZiAoIWJvb2wpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1BhdGggXCInICsgdGhpcy5wYXRoICsgJ1wiIG1heSBub3QgaGF2ZSBgaW5kZXhgIHNldCB0byAnICtcbiAgICAgICdmYWxzZSBhbmQgYHRleHRgIHNldCB0byB0cnVlJyk7XG4gIH1cblxuICBpZiAoIXRoaXMub3B0aW9ucy5oYXNPd25Qcm9wZXJ0eSgnaW5kZXgnKSAmJiBib29sID09PSBmYWxzZSkge1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgaWYgKHRoaXMuX2luZGV4ID09PSBudWxsIHx8IHRoaXMuX2luZGV4ID09PSB1bmRlZmluZWQgfHxcbiAgICB0eXBlb2YgdGhpcy5faW5kZXggPT09ICdib29sZWFuJykge1xuICAgIHRoaXMuX2luZGV4ID0ge307XG4gIH0gZWxzZSBpZiAodHlwZW9mIHRoaXMuX2luZGV4ID09PSAnc3RyaW5nJykge1xuICAgIHRoaXMuX2luZGV4ID0geyB0eXBlOiB0aGlzLl9pbmRleCB9O1xuICB9XG5cbiAgdGhpcy5faW5kZXgudGV4dCA9IGJvb2w7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBEZWNsYXJlcyBhIHNwYXJzZSBpbmRleC5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IHMgPSBuZXcgU2NoZW1hKHsgbmFtZTogeyB0eXBlOiBTdHJpbmcsIHNwYXJzZTogdHJ1ZSB9IH0pO1xuICogICAgIHMucGF0aCgnbmFtZScpLmluZGV4KHsgc3BhcnNlOiB0cnVlIH0pO1xuICpcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gYm9vbFxuICogQHJldHVybiB7U2NoZW1hVHlwZX0gdGhpc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5TY2hlbWFUeXBlLnByb3RvdHlwZS5zcGFyc2UgPSBmdW5jdGlvbihib29sKSB7XG4gIGlmICh0aGlzLl9pbmRleCA9PT0gZmFsc2UpIHtcbiAgICBpZiAoIWJvb2wpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1BhdGggXCInICsgdGhpcy5wYXRoICsgJ1wiIG1heSBub3QgaGF2ZSBgaW5kZXhgIHNldCB0byAnICtcbiAgICAgICdmYWxzZSBhbmQgYHNwYXJzZWAgc2V0IHRvIHRydWUnKTtcbiAgfVxuXG4gIGlmICghdGhpcy5vcHRpb25zLmhhc093blByb3BlcnR5KCdpbmRleCcpICYmIGJvb2wgPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBpZiAodGhpcy5faW5kZXggPT0gbnVsbCB8fCB0eXBlb2YgdGhpcy5faW5kZXggPT09ICdib29sZWFuJykge1xuICAgIHRoaXMuX2luZGV4ID0ge307XG4gIH0gZWxzZSBpZiAodHlwZW9mIHRoaXMuX2luZGV4ID09PSAnc3RyaW5nJykge1xuICAgIHRoaXMuX2luZGV4ID0geyB0eXBlOiB0aGlzLl9pbmRleCB9O1xuICB9XG5cbiAgdGhpcy5faW5kZXguc3BhcnNlID0gYm9vbDtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIERlZmluZXMgdGhpcyBwYXRoIGFzIGltbXV0YWJsZS4gTW9uZ29vc2UgcHJldmVudHMgeW91IGZyb20gY2hhbmdpbmdcbiAqIGltbXV0YWJsZSBwYXRocyB1bmxlc3MgdGhlIHBhcmVudCBkb2N1bWVudCBoYXMgW2Bpc05ldzogdHJ1ZWBdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvZG9jdW1lbnQuaHRtbCNEb2N1bWVudC5wcm90b3R5cGUuaXNOZXcoKSkuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBjb25zdCBzY2hlbWEgPSBuZXcgU2NoZW1hKHtcbiAqICAgICAgIG5hbWU6IHsgdHlwZTogU3RyaW5nLCBpbW11dGFibGU6IHRydWUgfSxcbiAqICAgICAgIGFnZTogTnVtYmVyXG4gKiAgICAgfSk7XG4gKiAgICAgY29uc3QgTW9kZWwgPSBtb25nb29zZS5tb2RlbCgnVGVzdCcsIHNjaGVtYSk7XG4gKlxuICogICAgIGF3YWl0IE1vZGVsLmNyZWF0ZSh7IG5hbWU6ICd0ZXN0JyB9KTtcbiAqICAgICBjb25zdCBkb2MgPSBhd2FpdCBNb2RlbC5maW5kT25lKCk7XG4gKlxuICogICAgIGRvYy5pc05ldzsgLy8gZmFsc2VcbiAqICAgICBkb2MubmFtZSA9ICduZXcgbmFtZSc7XG4gKiAgICAgZG9jLm5hbWU7IC8vICd0ZXN0JywgYmVjYXVzZSBgbmFtZWAgaXMgaW1tdXRhYmxlXG4gKlxuICogTW9uZ29vc2UgYWxzbyBwcmV2ZW50cyBjaGFuZ2luZyBpbW11dGFibGUgcHJvcGVydGllcyB1c2luZyBgdXBkYXRlT25lKClgXG4gKiBhbmQgYHVwZGF0ZU1hbnkoKWAgYmFzZWQgb24gW3N0cmljdCBtb2RlXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvZ3VpZGUuaHRtbCNzdHJpY3QpLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgLy8gTW9uZ29vc2Ugd2lsbCBzdHJpcCBvdXQgdGhlIGBuYW1lYCB1cGRhdGUsIGJlY2F1c2UgYG5hbWVgIGlzIGltbXV0YWJsZVxuICogICAgIE1vZGVsLnVwZGF0ZU9uZSh7fSwgeyAkc2V0OiB7IG5hbWU6ICd0ZXN0MicgfSwgJGluYzogeyBhZ2U6IDEgfSB9KTtcbiAqXG4gKiAgICAgLy8gSWYgYHN0cmljdGAgaXMgc2V0IHRvICd0aHJvdycsIE1vbmdvb3NlIHdpbGwgdGhyb3cgYW4gZXJyb3IgaWYgeW91XG4gKiAgICAgLy8gdXBkYXRlIGBuYW1lYFxuICogICAgIGNvbnN0IGVyciA9IGF3YWl0IE1vZGVsLnVwZGF0ZU9uZSh7fSwgeyBuYW1lOiAndGVzdDInIH0sIHsgc3RyaWN0OiAndGhyb3cnIH0pLlxuICogICAgICAgdGhlbigoKSA9PiBudWxsLCBlcnIgPT4gZXJyKTtcbiAqICAgICBlcnIubmFtZTsgLy8gU3RyaWN0TW9kZUVycm9yXG4gKlxuICogICAgIC8vIElmIGBzdHJpY3RgIGlzIGBmYWxzZWAsIE1vbmdvb3NlIGFsbG93cyB1cGRhdGluZyBgbmFtZWAgZXZlbiB0aG91Z2hcbiAqICAgICAvLyB0aGUgcHJvcGVydHkgaXMgaW1tdXRhYmxlLlxuICogICAgIE1vZGVsLnVwZGF0ZU9uZSh7fSwgeyBuYW1lOiAndGVzdDInIH0sIHsgc3RyaWN0OiBmYWxzZSB9KTtcbiAqXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGJvb2xcbiAqIEByZXR1cm4ge1NjaGVtYVR5cGV9IHRoaXNcbiAqIEBzZWUgaXNOZXcgaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2FwaS9kb2N1bWVudC5odG1sI0RvY3VtZW50LnByb3RvdHlwZS5pc05ldygpXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblNjaGVtYVR5cGUucHJvdG90eXBlLmltbXV0YWJsZSA9IGZ1bmN0aW9uKGJvb2wpIHtcbiAgdGhpcy4kaW1tdXRhYmxlID0gYm9vbDtcbiAgaGFuZGxlSW1tdXRhYmxlKHRoaXMpO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBEZWZpbmVzIGEgY3VzdG9tIGZ1bmN0aW9uIGZvciB0cmFuc2Zvcm1pbmcgdGhpcyBwYXRoIHdoZW4gY29udmVydGluZyBhIGRvY3VtZW50IHRvIEpTT04uXG4gKlxuICogTW9uZ29vc2UgY2FsbHMgdGhpcyBmdW5jdGlvbiB3aXRoIG9uZSBwYXJhbWV0ZXI6IHRoZSBjdXJyZW50IGB2YWx1ZWAgb2YgdGhlIHBhdGguIE1vbmdvb3NlXG4gKiB0aGVuIHVzZXMgdGhlIHJldHVybiB2YWx1ZSBpbiB0aGUgSlNPTiBvdXRwdXQuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBjb25zdCBzY2hlbWEgPSBuZXcgU2NoZW1hKHtcbiAqICAgICAgIGRhdGU6IHsgdHlwZTogRGF0ZSwgdHJhbnNmb3JtOiB2ID0+IHYuZ2V0RnVsbFllYXIoKSB9XG4gKiAgICAgfSk7XG4gKiAgICAgY29uc3QgTW9kZWwgPSBtb25nb29zZS5tb2RlbCgnVGVzdCcsIHNjaGVtYSk7XG4gKlxuICogICAgIGF3YWl0IE1vZGVsLmNyZWF0ZSh7IGRhdGU6IG5ldyBEYXRlKCcyMDE2LTA2LTAxJykgfSk7XG4gKiAgICAgY29uc3QgZG9jID0gYXdhaXQgTW9kZWwuZmluZE9uZSgpO1xuICpcbiAqICAgICBkb2MuZGF0ZSBpbnN0YW5jZW9mIERhdGU7IC8vIHRydWVcbiAqXG4gKiAgICAgZG9jLnRvSlNPTigpLmRhdGU7IC8vIDIwMTYgYXMgYSBudW1iZXJcbiAqICAgICBKU09OLnN0cmluZ2lmeShkb2MpOyAvLyAne1wiX2lkXCI6Li4uLFwiZGF0ZVwiOjIwMTZ9J1xuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKiBAcmV0dXJuIHtTY2hlbWFUeXBlfSB0aGlzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblNjaGVtYVR5cGUucHJvdG90eXBlLnRyYW5zZm9ybSA9IGZ1bmN0aW9uKGZuKSB7XG4gIHRoaXMub3B0aW9ucy50cmFuc2Zvcm0gPSBmbjtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQWRkcyBhIHNldHRlciB0byB0aGlzIHNjaGVtYXR5cGUuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBmdW5jdGlvbiBjYXBpdGFsaXplICh2YWwpIHtcbiAqICAgICAgIGlmICh0eXBlb2YgdmFsICE9PSAnc3RyaW5nJykgdmFsID0gJyc7XG4gKiAgICAgICByZXR1cm4gdmFsLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgdmFsLnN1YnN0cmluZygxKTtcbiAqICAgICB9XG4gKlxuICogICAgIC8vIGRlZmluaW5nIHdpdGhpbiB0aGUgc2NoZW1hXG4gKiAgICAgY29uc3QgcyA9IG5ldyBTY2hlbWEoeyBuYW1lOiB7IHR5cGU6IFN0cmluZywgc2V0OiBjYXBpdGFsaXplIH19KTtcbiAqXG4gKiAgICAgLy8gb3Igd2l0aCB0aGUgU2NoZW1hVHlwZVxuICogICAgIGNvbnN0IHMgPSBuZXcgU2NoZW1hKHsgbmFtZTogU3RyaW5nIH0pXG4gKiAgICAgcy5wYXRoKCduYW1lJykuc2V0KGNhcGl0YWxpemUpO1xuICpcbiAqIFNldHRlcnMgYWxsb3cgeW91IHRvIHRyYW5zZm9ybSB0aGUgZGF0YSBiZWZvcmUgaXQgZ2V0cyB0byB0aGUgcmF3IG1vbmdvZGJcbiAqIGRvY3VtZW50IG9yIHF1ZXJ5LlxuICpcbiAqIFN1cHBvc2UgeW91IGFyZSBpbXBsZW1lbnRpbmcgdXNlciByZWdpc3RyYXRpb24gZm9yIGEgd2Vic2l0ZS4gVXNlcnMgcHJvdmlkZVxuICogYW4gZW1haWwgYW5kIHBhc3N3b3JkLCB3aGljaCBnZXRzIHNhdmVkIHRvIG1vbmdvZGIuIFRoZSBlbWFpbCBpcyBhIHN0cmluZ1xuICogdGhhdCB5b3Ugd2lsbCB3YW50IHRvIG5vcm1hbGl6ZSB0byBsb3dlciBjYXNlLCBpbiBvcmRlciB0byBhdm9pZCBvbmUgZW1haWxcbiAqIGhhdmluZyBtb3JlIHRoYW4gb25lIGFjY291bnQgLS0gZS5nLiwgb3RoZXJ3aXNlLCBhdmVudWVAcS5jb20gY2FuIGJlIHJlZ2lzdGVyZWQgZm9yIDIgYWNjb3VudHMgdmlhIGF2ZW51ZUBxLmNvbSBhbmQgQXZFblVlQFEuQ29NLlxuICpcbiAqIFlvdSBjYW4gc2V0IHVwIGVtYWlsIGxvd2VyIGNhc2Ugbm9ybWFsaXphdGlvbiBlYXNpbHkgdmlhIGEgTW9uZ29vc2Ugc2V0dGVyLlxuICpcbiAqICAgICBmdW5jdGlvbiB0b0xvd2VyKHYpIHtcbiAqICAgICAgIHJldHVybiB2LnRvTG93ZXJDYXNlKCk7XG4gKiAgICAgfVxuICpcbiAqICAgICBjb25zdCBVc2VyU2NoZW1hID0gbmV3IFNjaGVtYSh7XG4gKiAgICAgICBlbWFpbDogeyB0eXBlOiBTdHJpbmcsIHNldDogdG9Mb3dlciB9XG4gKiAgICAgfSk7XG4gKlxuICogICAgIGNvbnN0IFVzZXIgPSBkYi5tb2RlbCgnVXNlcicsIFVzZXJTY2hlbWEpO1xuICpcbiAqICAgICBjb25zdCB1c2VyID0gbmV3IFVzZXIoe2VtYWlsOiAnQVZFTlVFQFEuQ09NJ30pO1xuICogICAgIGNvbnNvbGUubG9nKHVzZXIuZW1haWwpOyAvLyAnYXZlbnVlQHEuY29tJ1xuICpcbiAqICAgICAvLyBvclxuICogICAgIGNvbnN0IHVzZXIgPSBuZXcgVXNlcigpO1xuICogICAgIHVzZXIuZW1haWwgPSAnQXZlbnVlQFEuY29tJztcbiAqICAgICBjb25zb2xlLmxvZyh1c2VyLmVtYWlsKTsgLy8gJ2F2ZW51ZUBxLmNvbSdcbiAqICAgICBVc2VyLnVwZGF0ZU9uZSh7IF9pZDogX2lkIH0sIHsgJHNldDogeyBlbWFpbDogJ0FWRU5VRUBRLkNPTScgfSB9KTsgLy8gdXBkYXRlIHRvICdhdmVudWVAcS5jb20nXG4gKlxuICogQXMgeW91IGNhbiBzZWUgYWJvdmUsIHNldHRlcnMgYWxsb3cgeW91IHRvIHRyYW5zZm9ybSB0aGUgZGF0YSBiZWZvcmUgaXRcbiAqIHN0b3JlZCBpbiBNb25nb0RCLCBvciBiZWZvcmUgZXhlY3V0aW5nIGEgcXVlcnkuXG4gKlxuICogX05PVEU6IHdlIGNvdWxkIGhhdmUgYWxzbyBqdXN0IHVzZWQgdGhlIGJ1aWx0LWluIGBsb3dlcmNhc2U6IHRydWVgIFNjaGVtYVR5cGUgb3B0aW9uIGluc3RlYWQgb2YgZGVmaW5pbmcgb3VyIG93biBmdW5jdGlvbi5fXG4gKlxuICogICAgIG5ldyBTY2hlbWEoeyBlbWFpbDogeyB0eXBlOiBTdHJpbmcsIGxvd2VyY2FzZTogdHJ1ZSB9fSlcbiAqXG4gKiBTZXR0ZXJzIGFyZSBhbHNvIHBhc3NlZCBhIHNlY29uZCBhcmd1bWVudCwgdGhlIHNjaGVtYXR5cGUgb24gd2hpY2ggdGhlIHNldHRlciB3YXMgZGVmaW5lZC4gVGhpcyBhbGxvd3MgZm9yIHRhaWxvcmVkIGJlaGF2aW9yIGJhc2VkIG9uIG9wdGlvbnMgcGFzc2VkIGluIHRoZSBzY2hlbWEuXG4gKlxuICogICAgIGZ1bmN0aW9uIGluc3BlY3RvciAodmFsLCBwcmlvclZhbHVlLCBzY2hlbWF0eXBlKSB7XG4gKiAgICAgICBpZiAoc2NoZW1hdHlwZS5vcHRpb25zLnJlcXVpcmVkKSB7XG4gKiAgICAgICAgIHJldHVybiBzY2hlbWF0eXBlLnBhdGggKyAnIGlzIHJlcXVpcmVkJztcbiAqICAgICAgIH0gZWxzZSB7XG4gKiAgICAgICAgIHJldHVybiB2YWw7XG4gKiAgICAgICB9XG4gKiAgICAgfVxuICpcbiAqICAgICBjb25zdCBWaXJ1c1NjaGVtYSA9IG5ldyBTY2hlbWEoe1xuICogICAgICAgbmFtZTogeyB0eXBlOiBTdHJpbmcsIHJlcXVpcmVkOiB0cnVlLCBzZXQ6IGluc3BlY3RvciB9LFxuICogICAgICAgdGF4b25vbXk6IHsgdHlwZTogU3RyaW5nLCBzZXQ6IGluc3BlY3RvciB9XG4gKiAgICAgfSlcbiAqXG4gKiAgICAgY29uc3QgVmlydXMgPSBkYi5tb2RlbCgnVmlydXMnLCBWaXJ1c1NjaGVtYSk7XG4gKiAgICAgY29uc3QgdiA9IG5ldyBWaXJ1cyh7IG5hbWU6ICdQYXJ2b3ZpcmlkYWUnLCB0YXhvbm9teTogJ1BhcnZvdmlyaW5hZScgfSk7XG4gKlxuICogICAgIGNvbnNvbGUubG9nKHYubmFtZSk7ICAgICAvLyBuYW1lIGlzIHJlcXVpcmVkXG4gKiAgICAgY29uc29sZS5sb2codi50YXhvbm9teSk7IC8vIFBhcnZvdmlyaW5hZVxuICpcbiAqIFlvdSBjYW4gYWxzbyB1c2Ugc2V0dGVycyB0byBtb2RpZnkgb3RoZXIgcHJvcGVydGllcyBvbiB0aGUgZG9jdW1lbnQuIElmXG4gKiB5b3UncmUgc2V0dGluZyBhIHByb3BlcnR5IGBuYW1lYCBvbiBhIGRvY3VtZW50LCB0aGUgc2V0dGVyIHdpbGwgcnVuIHdpdGhcbiAqIGB0aGlzYCBhcyB0aGUgZG9jdW1lbnQuIEJlIGNhcmVmdWwsIGluIG1vbmdvb3NlIDUgc2V0dGVycyB3aWxsIGFsc28gcnVuXG4gKiB3aGVuIHF1ZXJ5aW5nIGJ5IGBuYW1lYCB3aXRoIGB0aGlzYCBhcyB0aGUgcXVlcnkuXG4gKlxuICogICAgIGNvbnN0IG5hbWVTY2hlbWEgPSBuZXcgU2NoZW1hKHsgbmFtZTogU3RyaW5nLCBrZXl3b3JkczogW1N0cmluZ10gfSk7XG4gKiAgICAgbmFtZVNjaGVtYS5wYXRoKCduYW1lJykuc2V0KGZ1bmN0aW9uKHYpIHtcbiAqICAgICAgIC8vIE5lZWQgdG8gY2hlY2sgaWYgYHRoaXNgIGlzIGEgZG9jdW1lbnQsIGJlY2F1c2UgaW4gbW9uZ29vc2UgNVxuICogICAgICAgLy8gc2V0dGVycyB3aWxsIGFsc28gcnVuIG9uIHF1ZXJpZXMsIGluIHdoaWNoIGNhc2UgYHRoaXNgIHdpbGwgYmUgYVxuICogICAgICAgLy8gbW9uZ29vc2UgcXVlcnkgb2JqZWN0LlxuICogICAgICAgaWYgKHRoaXMgaW5zdGFuY2VvZiBEb2N1bWVudCAmJiB2ICE9IG51bGwpIHtcbiAqICAgICAgICAgdGhpcy5rZXl3b3JkcyA9IHYuc3BsaXQoJyAnKTtcbiAqICAgICAgIH1cbiAqICAgICAgIHJldHVybiB2O1xuICogICAgIH0pO1xuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKiBAcmV0dXJuIHtTY2hlbWFUeXBlfSB0aGlzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblNjaGVtYVR5cGUucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uKGZuKSB7XG4gIGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBIHNldHRlciBtdXN0IGJlIGEgZnVuY3Rpb24uJyk7XG4gIH1cbiAgdGhpcy5zZXR0ZXJzLnB1c2goZm4pO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQWRkcyBhIGdldHRlciB0byB0aGlzIHNjaGVtYXR5cGUuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBmdW5jdGlvbiBkb2IgKHZhbCkge1xuICogICAgICAgaWYgKCF2YWwpIHJldHVybiB2YWw7XG4gKiAgICAgICByZXR1cm4gKHZhbC5nZXRNb250aCgpICsgMSkgKyBcIi9cIiArIHZhbC5nZXREYXRlKCkgKyBcIi9cIiArIHZhbC5nZXRGdWxsWWVhcigpO1xuICogICAgIH1cbiAqXG4gKiAgICAgLy8gZGVmaW5pbmcgd2l0aGluIHRoZSBzY2hlbWFcbiAqICAgICBjb25zdCBzID0gbmV3IFNjaGVtYSh7IGJvcm46IHsgdHlwZTogRGF0ZSwgZ2V0OiBkb2IgfSlcbiAqXG4gKiAgICAgLy8gb3IgYnkgcmV0cmVpdmluZyBpdHMgU2NoZW1hVHlwZVxuICogICAgIGNvbnN0IHMgPSBuZXcgU2NoZW1hKHsgYm9ybjogRGF0ZSB9KVxuICogICAgIHMucGF0aCgnYm9ybicpLmdldChkb2IpXG4gKlxuICogR2V0dGVycyBhbGxvdyB5b3UgdG8gdHJhbnNmb3JtIHRoZSByZXByZXNlbnRhdGlvbiBvZiB0aGUgZGF0YSBhcyBpdCB0cmF2ZWxzIGZyb20gdGhlIHJhdyBtb25nb2RiIGRvY3VtZW50IHRvIHRoZSB2YWx1ZSB0aGF0IHlvdSBzZWUuXG4gKlxuICogU3VwcG9zZSB5b3UgYXJlIHN0b3JpbmcgY3JlZGl0IGNhcmQgbnVtYmVycyBhbmQgeW91IHdhbnQgdG8gaGlkZSBldmVyeXRoaW5nIGV4Y2VwdCB0aGUgbGFzdCA0IGRpZ2l0cyB0byB0aGUgbW9uZ29vc2UgdXNlci4gWW91IGNhbiBkbyBzbyBieSBkZWZpbmluZyBhIGdldHRlciBpbiB0aGUgZm9sbG93aW5nIHdheTpcbiAqXG4gKiAgICAgZnVuY3Rpb24gb2JmdXNjYXRlIChjYykge1xuICogICAgICAgcmV0dXJuICcqKioqLSoqKiotKioqKi0nICsgY2Muc2xpY2UoY2MubGVuZ3RoLTQsIGNjLmxlbmd0aCk7XG4gKiAgICAgfVxuICpcbiAqICAgICBjb25zdCBBY2NvdW50U2NoZW1hID0gbmV3IFNjaGVtYSh7XG4gKiAgICAgICBjcmVkaXRDYXJkTnVtYmVyOiB7IHR5cGU6IFN0cmluZywgZ2V0OiBvYmZ1c2NhdGUgfVxuICogICAgIH0pO1xuICpcbiAqICAgICBjb25zdCBBY2NvdW50ID0gZGIubW9kZWwoJ0FjY291bnQnLCBBY2NvdW50U2NoZW1hKTtcbiAqXG4gKiAgICAgQWNjb3VudC5maW5kQnlJZChpZCwgZnVuY3Rpb24gKGVyciwgZm91bmQpIHtcbiAqICAgICAgIGNvbnNvbGUubG9nKGZvdW5kLmNyZWRpdENhcmROdW1iZXIpOyAvLyAnKioqKi0qKioqLSoqKiotMTIzNCdcbiAqICAgICB9KTtcbiAqXG4gKiBHZXR0ZXJzIGFyZSBhbHNvIHBhc3NlZCBhIHNlY29uZCBhcmd1bWVudCwgdGhlIHNjaGVtYXR5cGUgb24gd2hpY2ggdGhlIGdldHRlciB3YXMgZGVmaW5lZC4gVGhpcyBhbGxvd3MgZm9yIHRhaWxvcmVkIGJlaGF2aW9yIGJhc2VkIG9uIG9wdGlvbnMgcGFzc2VkIGluIHRoZSBzY2hlbWEuXG4gKlxuICogICAgIGZ1bmN0aW9uIGluc3BlY3RvciAodmFsLCBwcmlvclZhbHVlLCBzY2hlbWF0eXBlKSB7XG4gKiAgICAgICBpZiAoc2NoZW1hdHlwZS5vcHRpb25zLnJlcXVpcmVkKSB7XG4gKiAgICAgICAgIHJldHVybiBzY2hlbWF0eXBlLnBhdGggKyAnIGlzIHJlcXVpcmVkJztcbiAqICAgICAgIH0gZWxzZSB7XG4gKiAgICAgICAgIHJldHVybiBzY2hlbWF0eXBlLnBhdGggKyAnIGlzIG5vdCc7XG4gKiAgICAgICB9XG4gKiAgICAgfVxuICpcbiAqICAgICBjb25zdCBWaXJ1c1NjaGVtYSA9IG5ldyBTY2hlbWEoe1xuICogICAgICAgbmFtZTogeyB0eXBlOiBTdHJpbmcsIHJlcXVpcmVkOiB0cnVlLCBnZXQ6IGluc3BlY3RvciB9LFxuICogICAgICAgdGF4b25vbXk6IHsgdHlwZTogU3RyaW5nLCBnZXQ6IGluc3BlY3RvciB9XG4gKiAgICAgfSlcbiAqXG4gKiAgICAgY29uc3QgVmlydXMgPSBkYi5tb2RlbCgnVmlydXMnLCBWaXJ1c1NjaGVtYSk7XG4gKlxuICogICAgIFZpcnVzLmZpbmRCeUlkKGlkLCBmdW5jdGlvbiAoZXJyLCB2aXJ1cykge1xuICogICAgICAgY29uc29sZS5sb2codmlydXMubmFtZSk7ICAgICAvLyBuYW1lIGlzIHJlcXVpcmVkXG4gKiAgICAgICBjb25zb2xlLmxvZyh2aXJ1cy50YXhvbm9teSk7IC8vIHRheG9ub215IGlzIG5vdFxuICogICAgIH0pXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqIEByZXR1cm4ge1NjaGVtYVR5cGV9IHRoaXNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuU2NoZW1hVHlwZS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24oZm4pIHtcbiAgaWYgKHR5cGVvZiBmbiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0EgZ2V0dGVyIG11c3QgYmUgYSBmdW5jdGlvbi4nKTtcbiAgfVxuICB0aGlzLmdldHRlcnMucHVzaChmbik7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBBZGRzIHZhbGlkYXRvcihzKSBmb3IgdGhpcyBkb2N1bWVudCBwYXRoLlxuICpcbiAqIFZhbGlkYXRvcnMgYWx3YXlzIHJlY2VpdmUgdGhlIHZhbHVlIHRvIHZhbGlkYXRlIGFzIHRoZWlyIGZpcnN0IGFyZ3VtZW50IGFuZFxuICogbXVzdCByZXR1cm4gYEJvb2xlYW5gLiBSZXR1cm5pbmcgYGZhbHNlYCBvciB0aHJvd2luZyBhbiBlcnJvciBtZWFuc1xuICogdmFsaWRhdGlvbiBmYWlsZWQuXG4gKlxuICogVGhlIGVycm9yIG1lc3NhZ2UgYXJndW1lbnQgaXMgb3B0aW9uYWwuIElmIG5vdCBwYXNzZWQsIHRoZSBbZGVmYXVsdCBnZW5lcmljIGVycm9yIG1lc3NhZ2UgdGVtcGxhdGVdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvZXJyb3IuaHRtbCNFcnJvci5tZXNzYWdlcykgd2lsbCBiZSB1c2VkLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgLy8gbWFrZSBzdXJlIGV2ZXJ5IHZhbHVlIGlzIGVxdWFsIHRvIFwic29tZXRoaW5nXCJcbiAqICAgICBmdW5jdGlvbiB2YWxpZGF0b3IgKHZhbCkge1xuICogICAgICAgcmV0dXJuIHZhbCA9PT0gJ3NvbWV0aGluZyc7XG4gKiAgICAgfVxuICogICAgIG5ldyBTY2hlbWEoeyBuYW1lOiB7IHR5cGU6IFN0cmluZywgdmFsaWRhdGU6IHZhbGlkYXRvciB9fSk7XG4gKlxuICogICAgIC8vIHdpdGggYSBjdXN0b20gZXJyb3IgbWVzc2FnZVxuICpcbiAqICAgICBjb25zdCBjdXN0b20gPSBbdmFsaWRhdG9yLCAnVWggb2gsIHtQQVRIfSBkb2VzIG5vdCBlcXVhbCBcInNvbWV0aGluZ1wiLiddXG4gKiAgICAgbmV3IFNjaGVtYSh7IG5hbWU6IHsgdHlwZTogU3RyaW5nLCB2YWxpZGF0ZTogY3VzdG9tIH19KTtcbiAqXG4gKiAgICAgLy8gYWRkaW5nIG1hbnkgdmFsaWRhdG9ycyBhdCBhIHRpbWVcbiAqXG4gKiAgICAgY29uc3QgbWFueSA9IFtcbiAqICAgICAgICAgeyB2YWxpZGF0b3I6IHZhbGlkYXRvciwgbWVzc2FnZTogJ3VoIG9oJyB9XG4gKiAgICAgICAsIHsgdmFsaWRhdG9yOiBhbm90aGVyVmFsaWRhdG9yLCBtZXNzYWdlOiAnZmFpbGVkJyB9XG4gKiAgICAgXVxuICogICAgIG5ldyBTY2hlbWEoeyBuYW1lOiB7IHR5cGU6IFN0cmluZywgdmFsaWRhdGU6IG1hbnkgfX0pO1xuICpcbiAqICAgICAvLyBvciB1dGlsaXppbmcgU2NoZW1hVHlwZSBtZXRob2RzIGRpcmVjdGx5OlxuICpcbiAqICAgICBjb25zdCBzY2hlbWEgPSBuZXcgU2NoZW1hKHsgbmFtZTogJ3N0cmluZycgfSk7XG4gKiAgICAgc2NoZW1hLnBhdGgoJ25hbWUnKS52YWxpZGF0ZSh2YWxpZGF0b3IsICd2YWxpZGF0aW9uIG9mIGB7UEFUSH1gIGZhaWxlZCB3aXRoIHZhbHVlIGB7VkFMVUV9YCcpO1xuICpcbiAqICMjIyMgRXJyb3IgbWVzc2FnZSB0ZW1wbGF0ZXM6XG4gKlxuICogQmVsb3cgaXMgYSBsaXN0IG9mIHN1cHBvcnRlZCB0ZW1wbGF0ZSBrZXl3b3JkczpcbiAqXG4gKiAtIFBBVEg6IFRoZSBzY2hlbWEgcGF0aCB3aGVyZSB0aGUgZXJyb3IgaXMgYmVpbmcgdHJpZ2dlcmVkLlxuICogLSBWQUxVRTogVGhlIHZhbHVlIGFzc2lnbmVkIHRvIHRoZSBQQVRIIHRoYXQgaXMgdHJpZ2dlcmluZyB0aGUgZXJyb3IuXG4gKiAtIEtJTkQ6IFRoZSB2YWxpZGF0aW9uIHByb3BlcnR5IHRoYXQgdHJpZ2dlcmVkIHRoZSBlcnJvciBpLmUuIHJlcXVpcmVkLlxuICogLSBSRUFTT046IFRoZSBlcnJvciBvYmplY3QgdGhhdCBjYXVzZWQgdGhpcyBlcnJvciBpZiB0aGVyZSB3YXMgb25lLlxuICpcbiAqIElmIE1vbmdvb3NlJ3MgYnVpbHQtaW4gZXJyb3IgbWVzc2FnZSB0ZW1wbGF0aW5nIGlzbid0IGVub3VnaCwgTW9uZ29vc2VcbiAqIHN1cHBvcnRzIHNldHRpbmcgdGhlIGBtZXNzYWdlYCBwcm9wZXJ0eSB0byBhIGZ1bmN0aW9uLlxuICpcbiAqICAgICBzY2hlbWEucGF0aCgnbmFtZScpLnZhbGlkYXRlKHtcbiAqICAgICAgIHZhbGlkYXRvcjogZnVuY3Rpb24odikgeyByZXR1cm4gdi5sZW5ndGggPiA1OyB9LFxuICogICAgICAgLy8gYGVycm9yc1snbmFtZSddYCB3aWxsIGJlIFwibmFtZSBtdXN0IGhhdmUgbGVuZ3RoIDUsIGdvdCAnZm9vJ1wiXG4gKiAgICAgICBtZXNzYWdlOiBmdW5jdGlvbihwcm9wcykge1xuICogICAgICAgICByZXR1cm4gYCR7cHJvcHMucGF0aH0gbXVzdCBoYXZlIGxlbmd0aCA1LCBnb3QgJyR7cHJvcHMudmFsdWV9J2A7XG4gKiAgICAgICB9XG4gKiAgICAgfSk7XG4gKlxuICogVG8gYnlwYXNzIE1vbmdvb3NlJ3MgZXJyb3IgbWVzc2FnZXMgYW5kIGp1c3QgY29weSB0aGUgZXJyb3IgbWVzc2FnZSB0aGF0XG4gKiB0aGUgdmFsaWRhdG9yIHRocm93cywgZG8gdGhpczpcbiAqXG4gKiAgICAgc2NoZW1hLnBhdGgoJ25hbWUnKS52YWxpZGF0ZSh7XG4gKiAgICAgICB2YWxpZGF0b3I6IGZ1bmN0aW9uKCkgeyB0aHJvdyBuZXcgRXJyb3IoJ09vcHMhJyk7IH0sXG4gKiAgICAgICAvLyBgZXJyb3JzWyduYW1lJ11gIHdpbGwgYmUgXCJPb3BzIVwiXG4gKiAgICAgICBtZXNzYWdlOiBmdW5jdGlvbihwcm9wcykgeyByZXR1cm4gcHJvcHMucmVhc29uLm1lc3NhZ2U7IH1cbiAqICAgICB9KTtcbiAqXG4gKiAjIyMjIEFzeW5jaHJvbm91cyB2YWxpZGF0aW9uOlxuICpcbiAqIE1vbmdvb3NlIHN1cHBvcnRzIHZhbGlkYXRvcnMgdGhhdCByZXR1cm4gYSBwcm9taXNlLiBBIHZhbGlkYXRvciB0aGF0IHJldHVybnNcbiAqIGEgcHJvbWlzZSBpcyBjYWxsZWQgYW4gX2FzeW5jIHZhbGlkYXRvcl8uIEFzeW5jIHZhbGlkYXRvcnMgcnVuIGluXG4gKiBwYXJhbGxlbCwgYW5kIGB2YWxpZGF0ZSgpYCB3aWxsIHdhaXQgdW50aWwgYWxsIGFzeW5jIHZhbGlkYXRvcnMgaGF2ZSBzZXR0bGVkLlxuICpcbiAqICAgICBzY2hlbWEucGF0aCgnbmFtZScpLnZhbGlkYXRlKHtcbiAqICAgICAgIHZhbGlkYXRvcjogZnVuY3Rpb24gKHZhbHVlKSB7XG4gKiAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gKiAgICAgICAgICAgcmVzb2x2ZShmYWxzZSk7IC8vIHZhbGlkYXRpb24gZmFpbGVkXG4gKiAgICAgICAgIH0pO1xuICogICAgICAgfVxuICogICAgIH0pO1xuICpcbiAqIFlvdSBtaWdodCB1c2UgYXN5bmNocm9ub3VzIHZhbGlkYXRvcnMgdG8gcmV0cmVpdmUgb3RoZXIgZG9jdW1lbnRzIGZyb20gdGhlIGRhdGFiYXNlIHRvIHZhbGlkYXRlIGFnYWluc3Qgb3IgdG8gbWVldCBvdGhlciBJL08gYm91bmQgdmFsaWRhdGlvbiBuZWVkcy5cbiAqXG4gKiBWYWxpZGF0aW9uIG9jY3VycyBgcHJlKCdzYXZlJylgIG9yIHdoZW5ldmVyIHlvdSBtYW51YWxseSBleGVjdXRlIFtkb2N1bWVudCN2YWxpZGF0ZV0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2FwaS9kb2N1bWVudC5odG1sI0RvY3VtZW50LnByb3RvdHlwZS52YWxpZGF0ZSgpKS5cbiAqXG4gKiBJZiB2YWxpZGF0aW9uIGZhaWxzIGR1cmluZyBgcHJlKCdzYXZlJylgIGFuZCBubyBjYWxsYmFjayB3YXMgcGFzc2VkIHRvIHJlY2VpdmUgdGhlIGVycm9yLCBhbiBgZXJyb3JgIGV2ZW50IHdpbGwgYmUgZW1pdHRlZCBvbiB5b3VyIE1vZGVscyBhc3NvY2lhdGVkIGRiIFtjb25uZWN0aW9uXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvYXBpL2Nvbm5lY3Rpb24uaHRtbCNDb25uZWN0aW9uKCkpLCBwYXNzaW5nIHRoZSB2YWxpZGF0aW9uIGVycm9yIG9iamVjdCBhbG9uZy5cbiAqXG4gKiAgICAgY29uc3QgY29ubiA9IG1vbmdvb3NlLmNyZWF0ZUNvbm5lY3Rpb24oLi4pO1xuICogICAgIGNvbm4ub24oJ2Vycm9yJywgaGFuZGxlRXJyb3IpO1xuICpcbiAqICAgICBjb25zdCBQcm9kdWN0ID0gY29ubi5tb2RlbCgnUHJvZHVjdCcsIHlvdXJTY2hlbWEpO1xuICogICAgIGNvbnN0IGR2ZCA9IG5ldyBQcm9kdWN0KC4uKTtcbiAqICAgICBkdmQuc2F2ZSgpOyAvLyBlbWl0cyBlcnJvciBvbiB0aGUgYGNvbm5gIGFib3ZlXG4gKlxuICogSWYgeW91IHdhbnQgdG8gaGFuZGxlIHRoZXNlIGVycm9ycyBhdCB0aGUgTW9kZWwgbGV2ZWwsIGFkZCBhbiBgZXJyb3JgXG4gKiBsaXN0ZW5lciB0byB5b3VyIE1vZGVsIGFzIHNob3duIGJlbG93LlxuICpcbiAqICAgICAvLyByZWdpc3RlcmluZyBhbiBlcnJvciBsaXN0ZW5lciBvbiB0aGUgTW9kZWwgbGV0cyB1cyBoYW5kbGUgZXJyb3JzIG1vcmUgbG9jYWxseVxuICogICAgIFByb2R1Y3Qub24oJ2Vycm9yJywgaGFuZGxlRXJyb3IpO1xuICpcbiAqIEBwYXJhbSB7UmVnRXhwfEZ1bmN0aW9ufE9iamVjdH0gb2JqIHZhbGlkYXRvciBmdW5jdGlvbiwgb3IgaGFzaCBkZXNjcmliaW5nIG9wdGlvbnNcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtvYmoudmFsaWRhdG9yXSB2YWxpZGF0b3IgZnVuY3Rpb24uIElmIHRoZSB2YWxpZGF0b3IgZnVuY3Rpb24gcmV0dXJucyBgdW5kZWZpbmVkYCBvciBhIHRydXRoeSB2YWx1ZSwgdmFsaWRhdGlvbiBzdWNjZWVkcy4gSWYgaXQgcmV0dXJucyBbZmFsc3ldKGh0dHBzOi8vbWFzdGVyaW5nanMuaW8vdHV0b3JpYWxzL2Z1bmRhbWVudGFscy9mYWxzeSkgKGV4Y2VwdCBgdW5kZWZpbmVkYCkgb3IgdGhyb3dzIGFuIGVycm9yLCB2YWxpZGF0aW9uIGZhaWxzLlxuICogQHBhcmFtIHtTdHJpbmd8RnVuY3Rpb259IFtvYmoubWVzc2FnZV0gb3B0aW9uYWwgZXJyb3IgbWVzc2FnZS4gSWYgZnVuY3Rpb24sIHNob3VsZCByZXR1cm4gdGhlIGVycm9yIG1lc3NhZ2UgYXMgYSBzdHJpbmdcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29iai5wcm9wc1BhcmFtZXRlcj1mYWxzZV0gSWYgdHJ1ZSwgTW9uZ29vc2Ugd2lsbCBwYXNzIHRoZSB2YWxpZGF0b3IgcHJvcGVydGllcyBvYmplY3QgKHdpdGggdGhlIGB2YWxpZGF0b3JgIGZ1bmN0aW9uLCBgbWVzc2FnZWAsIGV0Yy4pIGFzIHRoZSAybmQgYXJnIHRvIHRoZSB2YWxpZGF0b3IgZnVuY3Rpb24uIFRoaXMgaXMgZGlzYWJsZWQgYnkgZGVmYXVsdCBiZWNhdXNlIG1hbnkgdmFsaWRhdG9ycyBbcmVseSBvbiBwb3NpdGlvbmFsIGFyZ3NdKGh0dHBzOi8vZ2l0aHViLmNvbS9jaHJpc28vdmFsaWRhdG9yLmpzI3ZhbGlkYXRvcnMpLCBzbyB0dXJuaW5nIHRoaXMgb24gbWF5IGNhdXNlIHVucHJlZGljdGFibGUgYmVoYXZpb3IgaW4gZXh0ZXJuYWwgdmFsaWRhdG9ycy5cbiAqIEBwYXJhbSB7U3RyaW5nfEZ1bmN0aW9ufSBbZXJyb3JNc2ddIG9wdGlvbmFsIGVycm9yIG1lc3NhZ2UuIElmIGZ1bmN0aW9uLCBzaG91bGQgcmV0dXJuIHRoZSBlcnJvciBtZXNzYWdlIGFzIGEgc3RyaW5nXG4gKiBAcGFyYW0ge1N0cmluZ30gW3R5cGVdIG9wdGlvbmFsIHZhbGlkYXRvciB0eXBlXG4gKiBAcmV0dXJuIHtTY2hlbWFUeXBlfSB0aGlzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblNjaGVtYVR5cGUucHJvdG90eXBlLnZhbGlkYXRlID0gZnVuY3Rpb24ob2JqLCBtZXNzYWdlLCB0eXBlKSB7XG4gIGlmICh0eXBlb2Ygb2JqID09PSAnZnVuY3Rpb24nIHx8IG9iaiAmJiB1dGlscy5nZXRGdW5jdGlvbk5hbWUob2JqLmNvbnN0cnVjdG9yKSA9PT0gJ1JlZ0V4cCcpIHtcbiAgICBsZXQgcHJvcGVydGllcztcbiAgICBpZiAodHlwZW9mIG1lc3NhZ2UgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHByb3BlcnRpZXMgPSB7IHZhbGlkYXRvcjogb2JqLCBtZXNzYWdlOiBtZXNzYWdlIH07XG4gICAgICBwcm9wZXJ0aWVzLnR5cGUgPSB0eXBlIHx8ICd1c2VyIGRlZmluZWQnO1xuICAgIH0gZWxzZSBpZiAobWVzc2FnZSBpbnN0YW5jZW9mIE9iamVjdCAmJiAhdHlwZSkge1xuICAgICAgcHJvcGVydGllcyA9IGlzU2ltcGxlVmFsaWRhdG9yKG1lc3NhZ2UpID8gT2JqZWN0LmFzc2lnbih7fSwgbWVzc2FnZSkgOiBjbG9uZShtZXNzYWdlKTtcbiAgICAgIGlmICghcHJvcGVydGllcy5tZXNzYWdlKSB7XG4gICAgICAgIHByb3BlcnRpZXMubWVzc2FnZSA9IHByb3BlcnRpZXMubXNnO1xuICAgICAgfVxuICAgICAgcHJvcGVydGllcy52YWxpZGF0b3IgPSBvYmo7XG4gICAgICBwcm9wZXJ0aWVzLnR5cGUgPSBwcm9wZXJ0aWVzLnR5cGUgfHwgJ3VzZXIgZGVmaW5lZCc7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChtZXNzYWdlID09IG51bGwpIHtcbiAgICAgICAgbWVzc2FnZSA9IE1vbmdvb3NlRXJyb3IubWVzc2FnZXMuZ2VuZXJhbC5kZWZhdWx0O1xuICAgICAgfVxuICAgICAgaWYgKCF0eXBlKSB7XG4gICAgICAgIHR5cGUgPSAndXNlciBkZWZpbmVkJztcbiAgICAgIH1cbiAgICAgIHByb3BlcnRpZXMgPSB7IG1lc3NhZ2U6IG1lc3NhZ2UsIHR5cGU6IHR5cGUsIHZhbGlkYXRvcjogb2JqIH07XG4gICAgfVxuXG4gICAgdGhpcy52YWxpZGF0b3JzLnB1c2gocHJvcGVydGllcyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBsZXQgaTtcbiAgbGV0IGxlbmd0aDtcbiAgbGV0IGFyZztcblxuICBmb3IgKGkgPSAwLCBsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICBhcmcgPSBhcmd1bWVudHNbaV07XG4gICAgaWYgKCF1dGlscy5pc1BPSk8oYXJnKSkge1xuICAgICAgY29uc3QgbXNnID0gJ0ludmFsaWQgdmFsaWRhdG9yLiBSZWNlaXZlZCAoJyArIHR5cGVvZiBhcmcgKyAnKSAnXG4gICAgICAgICsgYXJnXG4gICAgICAgICsgJy4gU2VlIGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvc2NoZW1hdHlwZS5odG1sI1NjaGVtYVR5cGUucHJvdG90eXBlLnZhbGlkYXRlKCknO1xuXG4gICAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbiAgICB9XG4gICAgdGhpcy52YWxpZGF0ZShhcmcudmFsaWRhdG9yLCBhcmcpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEFkZHMgYSByZXF1aXJlZCB2YWxpZGF0b3IgdG8gdGhpcyBTY2hlbWFUeXBlLiBUaGUgdmFsaWRhdG9yIGdldHMgYWRkZWRcbiAqIHRvIHRoZSBmcm9udCBvZiB0aGlzIFNjaGVtYVR5cGUncyB2YWxpZGF0b3JzIGFycmF5IHVzaW5nIGB1bnNoaWZ0KClgLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgY29uc3QgcyA9IG5ldyBTY2hlbWEoeyBib3JuOiB7IHR5cGU6IERhdGUsIHJlcXVpcmVkOiB0cnVlIH0pXG4gKlxuICogICAgIC8vIG9yIHdpdGggY3VzdG9tIGVycm9yIG1lc3NhZ2VcbiAqXG4gKiAgICAgY29uc3QgcyA9IG5ldyBTY2hlbWEoeyBib3JuOiB7IHR5cGU6IERhdGUsIHJlcXVpcmVkOiAne1BBVEh9IGlzIHJlcXVpcmVkIScgfSlcbiAqXG4gKiAgICAgLy8gb3Igd2l0aCBhIGZ1bmN0aW9uXG4gKlxuICogICAgIGNvbnN0IHMgPSBuZXcgU2NoZW1hKHtcbiAqICAgICAgIHVzZXJJZDogT2JqZWN0SWQsXG4gKiAgICAgICB1c2VybmFtZToge1xuICogICAgICAgICB0eXBlOiBTdHJpbmcsXG4gKiAgICAgICAgIHJlcXVpcmVkOiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMudXNlcklkICE9IG51bGw7IH1cbiAqICAgICAgIH1cbiAqICAgICB9KVxuICpcbiAqICAgICAvLyBvciB3aXRoIGEgZnVuY3Rpb24gYW5kIGEgY3VzdG9tIG1lc3NhZ2VcbiAqICAgICBjb25zdCBzID0gbmV3IFNjaGVtYSh7XG4gKiAgICAgICB1c2VySWQ6IE9iamVjdElkLFxuICogICAgICAgdXNlcm5hbWU6IHtcbiAqICAgICAgICAgdHlwZTogU3RyaW5nLFxuICogICAgICAgICByZXF1aXJlZDogW1xuICogICAgICAgICAgIGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy51c2VySWQgIT0gbnVsbDsgfSxcbiAqICAgICAgICAgICAndXNlcm5hbWUgaXMgcmVxdWlyZWQgaWYgaWQgaXMgc3BlY2lmaWVkJ1xuICogICAgICAgICBdXG4gKiAgICAgICB9XG4gKiAgICAgfSlcbiAqXG4gKiAgICAgLy8gb3IgdGhyb3VnaCB0aGUgcGF0aCBBUElcbiAqXG4gKiAgICAgcy5wYXRoKCduYW1lJykucmVxdWlyZWQodHJ1ZSk7XG4gKlxuICogICAgIC8vIHdpdGggY3VzdG9tIGVycm9yIG1lc3NhZ2luZ1xuICpcbiAqICAgICBzLnBhdGgoJ25hbWUnKS5yZXF1aXJlZCh0cnVlLCAnZ3JyciA6KCAnKTtcbiAqXG4gKiAgICAgLy8gb3IgbWFrZSBhIHBhdGggY29uZGl0aW9uYWxseSByZXF1aXJlZCBiYXNlZCBvbiBhIGZ1bmN0aW9uXG4gKiAgICAgY29uc3QgaXNPdmVyMTggPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMuYWdlID49IDE4OyB9O1xuICogICAgIHMucGF0aCgndm90ZXJSZWdpc3RyYXRpb25JZCcpLnJlcXVpcmVkKGlzT3ZlcjE4KTtcbiAqXG4gKiBUaGUgcmVxdWlyZWQgdmFsaWRhdG9yIHVzZXMgdGhlIFNjaGVtYVR5cGUncyBgY2hlY2tSZXF1aXJlZGAgZnVuY3Rpb24gdG9cbiAqIGRldGVybWluZSB3aGV0aGVyIGEgZ2l2ZW4gdmFsdWUgc2F0aXNmaWVzIHRoZSByZXF1aXJlZCB2YWxpZGF0b3IuIEJ5IGRlZmF1bHQsXG4gKiBhIHZhbHVlIHNhdGlzZmllcyB0aGUgcmVxdWlyZWQgdmFsaWRhdG9yIGlmIGB2YWwgIT0gbnVsbGAgKHRoYXQgaXMsIGlmXG4gKiB0aGUgdmFsdWUgaXMgbm90IG51bGwgbm9yIHVuZGVmaW5lZCkuIEhvd2V2ZXIsIG1vc3QgYnVpbHQtaW4gbW9uZ29vc2Ugc2NoZW1hXG4gKiB0eXBlcyBvdmVycmlkZSB0aGUgZGVmYXVsdCBgY2hlY2tSZXF1aXJlZGAgZnVuY3Rpb246XG4gKlxuICogQHBhcmFtIHtCb29sZWFufEZ1bmN0aW9ufE9iamVjdH0gcmVxdWlyZWQgZW5hYmxlL2Rpc2FibGUgdGhlIHZhbGlkYXRvciwgb3IgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHJlcXVpcmVkIGJvb2xlYW4sIG9yIG9wdGlvbnMgb2JqZWN0XG4gKiBAcGFyYW0ge0Jvb2xlYW58RnVuY3Rpb259IFtvcHRpb25zLmlzUmVxdWlyZWRdIGVuYWJsZS9kaXNhYmxlIHRoZSB2YWxpZGF0b3IsIG9yIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyByZXF1aXJlZCBib29sZWFuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5FcnJvckNvbnN0cnVjdG9yXSBjdXN0b20gZXJyb3IgY29uc3RydWN0b3IuIFRoZSBjb25zdHJ1Y3RvciByZWNlaXZlcyAxIHBhcmFtZXRlciwgYW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIHZhbGlkYXRvciBwcm9wZXJ0aWVzLlxuICogQHBhcmFtIHtTdHJpbmd9IFttZXNzYWdlXSBvcHRpb25hbCBjdXN0b20gZXJyb3IgbWVzc2FnZVxuICogQHJldHVybiB7U2NoZW1hVHlwZX0gdGhpc1xuICogQHNlZSBDdXN0b21pemVkIEVycm9yIE1lc3NhZ2VzIGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvZXJyb3IuaHRtbCNFcnJvci5tZXNzYWdlc1xuICogQHNlZSBTY2hlbWFBcnJheSNjaGVja1JlcXVpcmVkIGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvc2NoZW1hYXJyYXkuaHRtbCNTY2hlbWFBcnJheS5wcm90b3R5cGUuY2hlY2tSZXF1aXJlZCgpXG4gKiBAc2VlIFNjaGVtYUJvb2xlYW4jY2hlY2tSZXF1aXJlZCBodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvYXBpL3NjaGVtYWJvb2xlYW4uaHRtbCNTY2hlbWFCb29sZWFuLnByb3RvdHlwZS5jaGVja1JlcXVpcmVkKClcbiAqIEBzZWUgU2NoZW1hQnVmZmVyI2NoZWNrUmVxdWlyZWQgaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2FwaS9zY2hlbWFidWZmZXIuaHRtbCNTY2hlbWFCdWZmZXIucHJvdG90eXBlLmNoZWNrUmVxdWlyZWQoKVxuICogQHNlZSBTY2hlbWFOdW1iZXIjY2hlY2tSZXF1aXJlZCBodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvYXBpL3NjaGVtYW51bWJlci5odG1sI1NjaGVtYU51bWJlci5wcm90b3R5cGUuY2hlY2tSZXF1aXJlZCgpXG4gKiBAc2VlIFNjaGVtYU9iamVjdElkI2NoZWNrUmVxdWlyZWQgaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2FwaS9zY2hlbWFvYmplY3RpZC5odG1sI09iamVjdElkLnByb3RvdHlwZS5jaGVja1JlcXVpcmVkKClcbiAqIEBzZWUgU2NoZW1hU3RyaW5nI2NoZWNrUmVxdWlyZWQgaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2FwaS9zY2hlbWFzdHJpbmcuaHRtbCNTY2hlbWFTdHJpbmcucHJvdG90eXBlLmNoZWNrUmVxdWlyZWQoKVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5TY2hlbWFUeXBlLnByb3RvdHlwZS5yZXF1aXJlZCA9IGZ1bmN0aW9uKHJlcXVpcmVkLCBtZXNzYWdlKSB7XG4gIGxldCBjdXN0b21PcHRpb25zID0ge307XG5cbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIHJlcXVpcmVkID09IG51bGwpIHtcbiAgICB0aGlzLnZhbGlkYXRvcnMgPSB0aGlzLnZhbGlkYXRvcnMuZmlsdGVyKGZ1bmN0aW9uKHYpIHtcbiAgICAgIHJldHVybiB2LnZhbGlkYXRvciAhPT0gdGhpcy5yZXF1aXJlZFZhbGlkYXRvcjtcbiAgICB9LCB0aGlzKTtcblxuICAgIHRoaXMuaXNSZXF1aXJlZCA9IGZhbHNlO1xuICAgIGRlbGV0ZSB0aGlzLm9yaWdpbmFsUmVxdWlyZWRWYWx1ZTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGlmICh0eXBlb2YgcmVxdWlyZWQgPT09ICdvYmplY3QnKSB7XG4gICAgY3VzdG9tT3B0aW9ucyA9IHJlcXVpcmVkO1xuICAgIG1lc3NhZ2UgPSBjdXN0b21PcHRpb25zLm1lc3NhZ2UgfHwgbWVzc2FnZTtcbiAgICByZXF1aXJlZCA9IHJlcXVpcmVkLmlzUmVxdWlyZWQ7XG4gIH1cblxuICBpZiAocmVxdWlyZWQgPT09IGZhbHNlKSB7XG4gICAgdGhpcy52YWxpZGF0b3JzID0gdGhpcy52YWxpZGF0b3JzLmZpbHRlcihmdW5jdGlvbih2KSB7XG4gICAgICByZXR1cm4gdi52YWxpZGF0b3IgIT09IHRoaXMucmVxdWlyZWRWYWxpZGF0b3I7XG4gICAgfSwgdGhpcyk7XG5cbiAgICB0aGlzLmlzUmVxdWlyZWQgPSBmYWxzZTtcbiAgICBkZWxldGUgdGhpcy5vcmlnaW5hbFJlcXVpcmVkVmFsdWU7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBjb25zdCBfdGhpcyA9IHRoaXM7XG4gIHRoaXMuaXNSZXF1aXJlZCA9IHRydWU7XG5cbiAgdGhpcy5yZXF1aXJlZFZhbGlkYXRvciA9IGZ1bmN0aW9uKHYpIHtcbiAgICBjb25zdCBjYWNoZWRSZXF1aXJlZCA9IHRoaXMgJiYgdGhpcy4kX18gJiYgdGhpcy4kX18uY2FjaGVkUmVxdWlyZWQ7XG5cbiAgICAvLyBubyB2YWxpZGF0aW9uIHdoZW4gdGhpcyBwYXRoIHdhc24ndCBzZWxlY3RlZCBpbiB0aGUgcXVlcnkuXG4gICAgaWYgKGNhY2hlZFJlcXVpcmVkICE9IG51bGwgJiYgIXRoaXMuJF9faXNTZWxlY3RlZChfdGhpcy5wYXRoKSAmJiAhdGhpc1tkb2N1bWVudElzTW9kaWZpZWRdKF90aGlzLnBhdGgpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyBgJGNhY2hlZFJlcXVpcmVkYCBnZXRzIHNldCBpbiBgX2V2YWx1YXRlUmVxdWlyZWRGdW5jdGlvbnMoKWAgc28gd2VcbiAgICAvLyBkb24ndCBjYWxsIHJlcXVpcmVkIGZ1bmN0aW9ucyBtdWx0aXBsZSB0aW1lcyBpbiBvbmUgdmFsaWRhdGUgY2FsbFxuICAgIC8vIFNlZSBnaC02ODAxXG4gICAgaWYgKGNhY2hlZFJlcXVpcmVkICE9IG51bGwgJiYgX3RoaXMucGF0aCBpbiBjYWNoZWRSZXF1aXJlZCkge1xuICAgICAgY29uc3QgcmVzID0gY2FjaGVkUmVxdWlyZWRbX3RoaXMucGF0aF0gP1xuICAgICAgICBfdGhpcy5jaGVja1JlcXVpcmVkKHYsIHRoaXMpIDpcbiAgICAgICAgdHJ1ZTtcbiAgICAgIGRlbGV0ZSBjYWNoZWRSZXF1aXJlZFtfdGhpcy5wYXRoXTtcbiAgICAgIHJldHVybiByZXM7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgcmVxdWlyZWQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiByZXF1aXJlZC5hcHBseSh0aGlzKSA/IF90aGlzLmNoZWNrUmVxdWlyZWQodiwgdGhpcykgOiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBfdGhpcy5jaGVja1JlcXVpcmVkKHYsIHRoaXMpO1xuICB9O1xuICB0aGlzLm9yaWdpbmFsUmVxdWlyZWRWYWx1ZSA9IHJlcXVpcmVkO1xuXG4gIGlmICh0eXBlb2YgcmVxdWlyZWQgPT09ICdzdHJpbmcnKSB7XG4gICAgbWVzc2FnZSA9IHJlcXVpcmVkO1xuICAgIHJlcXVpcmVkID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgY29uc3QgbXNnID0gbWVzc2FnZSB8fCBNb25nb29zZUVycm9yLm1lc3NhZ2VzLmdlbmVyYWwucmVxdWlyZWQ7XG4gIHRoaXMudmFsaWRhdG9ycy51bnNoaWZ0KE9iamVjdC5hc3NpZ24oe30sIGN1c3RvbU9wdGlvbnMsIHtcbiAgICB2YWxpZGF0b3I6IHRoaXMucmVxdWlyZWRWYWxpZGF0b3IsXG4gICAgbWVzc2FnZTogbXNnLFxuICAgIHR5cGU6ICdyZXF1aXJlZCdcbiAgfSkpO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZXQgdGhlIG1vZGVsIHRoYXQgdGhpcyBwYXRoIHJlZmVycyB0by4gVGhpcyBpcyB0aGUgb3B0aW9uIHRoYXQgW3BvcHVsYXRlXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvcG9wdWxhdGUuaHRtbClcbiAqIGxvb2tzIGF0IHRvIGRldGVybWluZSB0aGUgZm9yZWlnbiBjb2xsZWN0aW9uIGl0IHNob3VsZCBxdWVyeS5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IHVzZXJTY2hlbWEgPSBuZXcgU2NoZW1hKHsgbmFtZTogU3RyaW5nIH0pO1xuICogICAgIGNvbnN0IFVzZXIgPSBtb25nb29zZS5tb2RlbCgnVXNlcicsIHVzZXJTY2hlbWEpO1xuICpcbiAqICAgICBjb25zdCBwb3N0U2NoZW1hID0gbmV3IFNjaGVtYSh7IHVzZXI6IG1vbmdvb3NlLk9iamVjdElkIH0pO1xuICogICAgIHBvc3RTY2hlbWEucGF0aCgndXNlcicpLnJlZignVXNlcicpOyAvLyBDYW4gc2V0IHJlZiB0byBhIG1vZGVsIG5hbWVcbiAqICAgICBwb3N0U2NoZW1hLnBhdGgoJ3VzZXInKS5yZWYoVXNlcik7IC8vIE9yIGEgbW9kZWwgY2xhc3NcbiAqICAgICBwb3N0U2NoZW1hLnBhdGgoJ3VzZXInKS5yZWYoKCkgPT4gJ1VzZXInKTsgLy8gT3IgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlIG1vZGVsIG5hbWVcbiAqICAgICBwb3N0U2NoZW1hLnBhdGgoJ3VzZXInKS5yZWYoKCkgPT4gVXNlcik7IC8vIE9yIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZSBtb2RlbCBjbGFzc1xuICpcbiAqICAgICAvLyBPciB5b3UgY2FuIGp1c3QgZGVjbGFyZSB0aGUgYHJlZmAgaW5saW5lIGluIHlvdXIgc2NoZW1hXG4gKiAgICAgY29uc3QgcG9zdFNjaGVtYTIgPSBuZXcgU2NoZW1hKHtcbiAqICAgICAgIHVzZXI6IHsgdHlwZTogbW9uZ29vc2UuT2JqZWN0SWQsIHJlZjogVXNlciB9XG4gKiAgICAgfSk7XG4gKlxuICogQHBhcmFtIHtTdHJpbmd8TW9kZWx8RnVuY3Rpb259IHJlZiBlaXRoZXIgYSBtb2RlbCBuYW1lLCBhIFtNb2RlbF0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL21vZGVscy5odG1sKSwgb3IgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgYSBtb2RlbCBuYW1lIG9yIG1vZGVsLlxuICogQHJldHVybiB7U2NoZW1hVHlwZX0gdGhpc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5TY2hlbWFUeXBlLnByb3RvdHlwZS5yZWYgPSBmdW5jdGlvbihyZWYpIHtcbiAgdGhpcy5vcHRpb25zLnJlZiA9IHJlZjtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEdldHMgdGhlIGRlZmF1bHQgdmFsdWVcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gc2NvcGUgdGhlIHNjb3BlIHdoaWNoIGNhbGxiYWNrIGFyZSBleGVjdXRlZFxuICogQHBhcmFtIHtCb29sZWFufSBpbml0XG4gKiBAcmV0dXJuIHtBbnl9IFRoZSBTdG9yZWQgZGVmYXVsdCB2YWx1ZS5cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNjaGVtYVR5cGUucHJvdG90eXBlLmdldERlZmF1bHQgPSBmdW5jdGlvbihzY29wZSwgaW5pdCwgb3B0aW9ucykge1xuICBsZXQgcmV0O1xuICBpZiAodHlwZW9mIHRoaXMuZGVmYXVsdFZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgaWYgKFxuICAgICAgdGhpcy5kZWZhdWx0VmFsdWUgPT09IERhdGUubm93IHx8XG4gICAgICB0aGlzLmRlZmF1bHRWYWx1ZSA9PT0gQXJyYXkgfHxcbiAgICAgIHRoaXMuZGVmYXVsdFZhbHVlLm5hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ29iamVjdGlkJ1xuICAgICkge1xuICAgICAgcmV0ID0gdGhpcy5kZWZhdWx0VmFsdWUuY2FsbChzY29wZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldCA9IHRoaXMuZGVmYXVsdFZhbHVlLmNhbGwoc2NvcGUsIHNjb3BlKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcmV0ID0gdGhpcy5kZWZhdWx0VmFsdWU7XG4gIH1cblxuICBpZiAocmV0ICE9PSBudWxsICYmIHJldCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKHR5cGVvZiByZXQgPT09ICdvYmplY3QnICYmICghdGhpcy5vcHRpb25zIHx8ICF0aGlzLm9wdGlvbnMuc2hhcmVkKSkge1xuICAgICAgcmV0ID0gY2xvbmUocmV0KTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLnNraXBDYXN0KSB7XG4gICAgICByZXR1cm4gdGhpcy5fYXBwbHlTZXR0ZXJzKHJldCwgc2NvcGUpO1xuICAgIH1cblxuICAgIGNvbnN0IGNhc3RlZCA9IHRoaXMuYXBwbHlTZXR0ZXJzKHJldCwgc2NvcGUsIGluaXQsIHVuZGVmaW5lZCwgc2V0T3B0aW9uc0ZvckRlZmF1bHRzKTtcbiAgICBpZiAoY2FzdGVkICYmICFBcnJheS5pc0FycmF5KGNhc3RlZCkgJiYgY2FzdGVkLiRpc1NpbmdsZU5lc3RlZCkge1xuICAgICAgY2FzdGVkLiRfX3BhcmVudCA9IHNjb3BlO1xuICAgIH1cbiAgICByZXR1cm4gY2FzdGVkO1xuICB9XG4gIHJldHVybiByZXQ7XG59O1xuXG4vKipcbiAqIEFwcGxpZXMgc2V0dGVycyB3aXRob3V0IGNhc3RpbmdcbiAqXG4gKiBAcGFyYW0ge0FueX0gdmFsdWVcbiAqIEBwYXJhbSB7QW55fSBzY29wZVxuICogQHBhcmFtIHtCb29sZWFufSBpbml0XG4gKiBAcGFyYW0ge0FueX0gcHJpb3JWYWxcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEBpbnN0YW5jZVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU2NoZW1hVHlwZS5wcm90b3R5cGUuX2FwcGx5U2V0dGVycyA9IGZ1bmN0aW9uKHZhbHVlLCBzY29wZSwgaW5pdCwgcHJpb3JWYWwsIG9wdGlvbnMpIHtcbiAgbGV0IHYgPSB2YWx1ZTtcbiAgaWYgKGluaXQpIHtcbiAgICByZXR1cm4gdjtcbiAgfVxuICBjb25zdCBzZXR0ZXJzID0gdGhpcy5zZXR0ZXJzO1xuXG4gIGZvciAobGV0IGkgPSBzZXR0ZXJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgdiA9IHNldHRlcnNbaV0uY2FsbChzY29wZSwgdiwgcHJpb3JWYWwsIHRoaXMsIG9wdGlvbnMpO1xuICB9XG5cbiAgcmV0dXJuIHY7XG59O1xuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cblNjaGVtYVR5cGUucHJvdG90eXBlLl9jYXN0TnVsbGlzaCA9IGZ1bmN0aW9uIF9jYXN0TnVsbGlzaCh2KSB7XG4gIHJldHVybiB2O1xufTtcblxuLyoqXG4gKiBBcHBsaWVzIHNldHRlcnNcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsdWVcbiAqIEBwYXJhbSB7T2JqZWN0fSBzY29wZVxuICogQHBhcmFtIHtCb29sZWFufSBpbml0XG4gKiBAcmV0dXJuIHtBbnl9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5TY2hlbWFUeXBlLnByb3RvdHlwZS5hcHBseVNldHRlcnMgPSBmdW5jdGlvbih2YWx1ZSwgc2NvcGUsIGluaXQsIHByaW9yVmFsLCBvcHRpb25zKSB7XG4gIGxldCB2ID0gdGhpcy5fYXBwbHlTZXR0ZXJzKHZhbHVlLCBzY29wZSwgaW5pdCwgcHJpb3JWYWwsIG9wdGlvbnMpO1xuICBpZiAodiA9PSBudWxsKSB7XG4gICAgcmV0dXJuIHRoaXMuX2Nhc3ROdWxsaXNoKHYpO1xuICB9XG4gIC8vIGRvIG5vdCBjYXN0IHVudGlsIGFsbCBzZXR0ZXJzIGFyZSBhcHBsaWVkICM2NjVcbiAgdiA9IHRoaXMuY2FzdCh2LCBzY29wZSwgaW5pdCwgcHJpb3JWYWwsIG9wdGlvbnMpO1xuXG4gIHJldHVybiB2O1xufTtcblxuLyoqXG4gKiBBcHBsaWVzIGdldHRlcnMgdG8gYSB2YWx1ZVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWx1ZVxuICogQHBhcmFtIHtPYmplY3R9IHNjb3BlXG4gKiBAcmV0dXJuIHtBbnl9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5TY2hlbWFUeXBlLnByb3RvdHlwZS5hcHBseUdldHRlcnMgPSBmdW5jdGlvbih2YWx1ZSwgc2NvcGUpIHtcbiAgbGV0IHYgPSB2YWx1ZTtcbiAgY29uc3QgZ2V0dGVycyA9IHRoaXMuZ2V0dGVycztcbiAgY29uc3QgbGVuID0gZ2V0dGVycy5sZW5ndGg7XG5cbiAgaWYgKGxlbiA9PT0gMCkge1xuICAgIHJldHVybiB2O1xuICB9XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgIHYgPSBnZXR0ZXJzW2ldLmNhbGwoc2NvcGUsIHYsIHRoaXMpO1xuICB9XG5cbiAgcmV0dXJuIHY7XG59O1xuXG4vKipcbiAqIFNldHMgZGVmYXVsdCBgc2VsZWN0KClgIGJlaGF2aW9yIGZvciB0aGlzIHBhdGguXG4gKlxuICogU2V0IHRvIGB0cnVlYCBpZiB0aGlzIHBhdGggc2hvdWxkIGFsd2F5cyBiZSBpbmNsdWRlZCBpbiB0aGUgcmVzdWx0cywgYGZhbHNlYCBpZiBpdCBzaG91bGQgYmUgZXhjbHVkZWQgYnkgZGVmYXVsdC4gVGhpcyBzZXR0aW5nIGNhbiBiZSBvdmVycmlkZGVuIGF0IHRoZSBxdWVyeSBsZXZlbC5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIFQgPSBkYi5tb2RlbCgnVCcsIG5ldyBTY2hlbWEoeyB4OiB7IHR5cGU6IFN0cmluZywgc2VsZWN0OiB0cnVlIH19KSk7XG4gKiAgICAgVC5maW5kKC4uKTsgLy8gZmllbGQgeCB3aWxsIGFsd2F5cyBiZSBzZWxlY3RlZCAuLlxuICogICAgIC8vIC4uIHVubGVzcyBvdmVycmlkZGVuO1xuICogICAgIFQuZmluZCgpLnNlbGVjdCgnLXgnKS5leGVjKGNhbGxiYWNrKTtcbiAqXG4gKiBAcGFyYW0ge0Jvb2xlYW59IHZhbFxuICogQHJldHVybiB7U2NoZW1hVHlwZX0gdGhpc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5TY2hlbWFUeXBlLnByb3RvdHlwZS5zZWxlY3QgPSBmdW5jdGlvbiBzZWxlY3QodmFsKSB7XG4gIHRoaXMuc2VsZWN0ZWQgPSAhIXZhbDtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFBlcmZvcm1zIGEgdmFsaWRhdGlvbiBvZiBgdmFsdWVgIHVzaW5nIHRoZSB2YWxpZGF0b3JzIGRlY2xhcmVkIGZvciB0aGlzIFNjaGVtYVR5cGUuXG4gKlxuICogQHBhcmFtIHtBbnl9IHZhbHVlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICogQHBhcmFtIHtPYmplY3R9IHNjb3BlXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMucGF0aF1cbiAqIEByZXR1cm4ge0FueX0gSWYgbm8gdmFsaWRhdG9ycywgcmV0dXJucyB0aGUgb3V0cHV0IGZyb20gY2FsbGluZyBgZm5gLCBvdGhlcndpc2Ugbm8gcmV0dXJuXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblNjaGVtYVR5cGUucHJvdG90eXBlLmRvVmFsaWRhdGUgPSBmdW5jdGlvbih2YWx1ZSwgZm4sIHNjb3BlLCBvcHRpb25zKSB7XG4gIGxldCBlcnIgPSBmYWxzZTtcbiAgY29uc3QgcGF0aCA9IHRoaXMucGF0aDtcblxuICAvLyBBdm9pZCBub24tb2JqZWN0IGB2YWxpZGF0b3JzYFxuICBjb25zdCB2YWxpZGF0b3JzID0gdGhpcy52YWxpZGF0b3JzLlxuICAgIGZpbHRlcih2ID0+IHR5cGVvZiB2ID09PSAnb2JqZWN0JyAmJiB2ICE9PSBudWxsKTtcblxuICBsZXQgY291bnQgPSB2YWxpZGF0b3JzLmxlbmd0aDtcblxuICBpZiAoIWNvdW50KSB7XG4gICAgcmV0dXJuIGZuKG51bGwpO1xuICB9XG5cbiAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IHZhbGlkYXRvcnMubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICBpZiAoZXJyKSB7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBjb25zdCB2ID0gdmFsaWRhdG9yc1tpXTtcbiAgICBjb25zdCB2YWxpZGF0b3IgPSB2LnZhbGlkYXRvcjtcbiAgICBsZXQgb2s7XG5cbiAgICBjb25zdCB2YWxpZGF0b3JQcm9wZXJ0aWVzID0gaXNTaW1wbGVWYWxpZGF0b3IodikgPyBPYmplY3QuYXNzaWduKHt9LCB2KSA6IGNsb25lKHYpO1xuICAgIHZhbGlkYXRvclByb3BlcnRpZXMucGF0aCA9IG9wdGlvbnMgJiYgb3B0aW9ucy5wYXRoID8gb3B0aW9ucy5wYXRoIDogcGF0aDtcbiAgICB2YWxpZGF0b3JQcm9wZXJ0aWVzLmZ1bGxQYXRoID0gdGhpcy4kZnVsbFBhdGg7XG4gICAgdmFsaWRhdG9yUHJvcGVydGllcy52YWx1ZSA9IHZhbHVlO1xuXG4gICAgaWYgKHZhbGlkYXRvciBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgICAgdmFsaWRhdGUodmFsaWRhdG9yLnRlc3QodmFsdWUpLCB2YWxpZGF0b3JQcm9wZXJ0aWVzLCBzY29wZSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHZhbGlkYXRvciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQgJiYgdmFsaWRhdG9yICE9PSB0aGlzLnJlcXVpcmVkVmFsaWRhdG9yKSB7XG4gICAgICB2YWxpZGF0ZSh0cnVlLCB2YWxpZGF0b3JQcm9wZXJ0aWVzLCBzY29wZSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgaWYgKHZhbGlkYXRvclByb3BlcnRpZXMucHJvcHNQYXJhbWV0ZXIpIHtcbiAgICAgICAgb2sgPSB2YWxpZGF0b3IuY2FsbChzY29wZSwgdmFsdWUsIHZhbGlkYXRvclByb3BlcnRpZXMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb2sgPSB2YWxpZGF0b3IuY2FsbChzY29wZSwgdmFsdWUpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBvayA9IGZhbHNlO1xuICAgICAgdmFsaWRhdG9yUHJvcGVydGllcy5yZWFzb24gPSBlcnJvcjtcbiAgICAgIGlmIChlcnJvci5tZXNzYWdlKSB7XG4gICAgICAgIHZhbGlkYXRvclByb3BlcnRpZXMubWVzc2FnZSA9IGVycm9yLm1lc3NhZ2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG9rICE9IG51bGwgJiYgdHlwZW9mIG9rLnRoZW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIG9rLnRoZW4oXG4gICAgICAgIGZ1bmN0aW9uKG9rKSB7IHZhbGlkYXRlKG9rLCB2YWxpZGF0b3JQcm9wZXJ0aWVzLCBzY29wZSk7IH0sXG4gICAgICAgIGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgICAgICAgdmFsaWRhdG9yUHJvcGVydGllcy5yZWFzb24gPSBlcnJvcjtcbiAgICAgICAgICB2YWxpZGF0b3JQcm9wZXJ0aWVzLm1lc3NhZ2UgPSBlcnJvci5tZXNzYWdlO1xuICAgICAgICAgIG9rID0gZmFsc2U7XG4gICAgICAgICAgdmFsaWRhdGUob2ssIHZhbGlkYXRvclByb3BlcnRpZXMsIHNjb3BlKTtcbiAgICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbGlkYXRlKG9rLCB2YWxpZGF0b3JQcm9wZXJ0aWVzLCBzY29wZSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gdmFsaWRhdGUob2ssIHZhbGlkYXRvclByb3BlcnRpZXMsIHNjb3BlKSB7XG4gICAgaWYgKGVycikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAob2sgPT09IHVuZGVmaW5lZCB8fCBvaykge1xuICAgICAgaWYgKC0tY291bnQgPD0gMCkge1xuICAgICAgICBpbW1lZGlhdGUoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgZm4obnVsbCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBFcnJvckNvbnN0cnVjdG9yID0gdmFsaWRhdG9yUHJvcGVydGllcy5FcnJvckNvbnN0cnVjdG9yIHx8IFZhbGlkYXRvckVycm9yO1xuICAgICAgZXJyID0gbmV3IEVycm9yQ29uc3RydWN0b3IodmFsaWRhdG9yUHJvcGVydGllcywgc2NvcGUpO1xuICAgICAgZXJyW3ZhbGlkYXRvckVycm9yU3ltYm9sXSA9IHRydWU7XG4gICAgICBpbW1lZGlhdGUoZnVuY3Rpb24oKSB7XG4gICAgICAgIGZuKGVycik7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbn07XG5cblxuZnVuY3Rpb24gX3ZhbGlkYXRlKG9rLCB2YWxpZGF0b3JQcm9wZXJ0aWVzKSB7XG4gIGlmIChvayAhPT0gdW5kZWZpbmVkICYmICFvaykge1xuICAgIGNvbnN0IEVycm9yQ29uc3RydWN0b3IgPSB2YWxpZGF0b3JQcm9wZXJ0aWVzLkVycm9yQ29uc3RydWN0b3IgfHwgVmFsaWRhdG9yRXJyb3I7XG4gICAgY29uc3QgZXJyID0gbmV3IEVycm9yQ29uc3RydWN0b3IodmFsaWRhdG9yUHJvcGVydGllcyk7XG4gICAgZXJyW3ZhbGlkYXRvckVycm9yU3ltYm9sXSA9IHRydWU7XG4gICAgcmV0dXJuIGVycjtcbiAgfVxufVxuXG4vKipcbiAqIFBlcmZvcm1zIGEgdmFsaWRhdGlvbiBvZiBgdmFsdWVgIHVzaW5nIHRoZSB2YWxpZGF0b3JzIGRlY2xhcmVkIGZvciB0aGlzIFNjaGVtYVR5cGUuXG4gKlxuICogIyMjIyBOb3RlOlxuICpcbiAqIFRoaXMgbWV0aG9kIGlnbm9yZXMgdGhlIGFzeW5jaHJvbm91cyB2YWxpZGF0b3JzLlxuICpcbiAqIEBwYXJhbSB7QW55fSB2YWx1ZVxuICogQHBhcmFtIHtPYmplY3R9IHNjb3BlXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMucGF0aF1cbiAqIEByZXR1cm4ge01vbmdvb3NlRXJyb3J8bnVsbH1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNjaGVtYVR5cGUucHJvdG90eXBlLmRvVmFsaWRhdGVTeW5jID0gZnVuY3Rpb24odmFsdWUsIHNjb3BlLCBvcHRpb25zKSB7XG4gIGNvbnN0IHBhdGggPSB0aGlzLnBhdGg7XG4gIGNvbnN0IGNvdW50ID0gdGhpcy52YWxpZGF0b3JzLmxlbmd0aDtcblxuICBpZiAoIWNvdW50KSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBsZXQgdmFsaWRhdG9ycyA9IHRoaXMudmFsaWRhdG9ycztcbiAgaWYgKHZhbHVlID09PSB2b2lkIDApIHtcbiAgICBpZiAodGhpcy52YWxpZGF0b3JzLmxlbmd0aCAhPT0gMCAmJiB0aGlzLnZhbGlkYXRvcnNbMF0udHlwZSA9PT0gJ3JlcXVpcmVkJykge1xuICAgICAgdmFsaWRhdG9ycyA9IFt0aGlzLnZhbGlkYXRvcnNbMF1dO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cblxuICBsZXQgZXJyID0gbnVsbDtcbiAgbGV0IGkgPSAwO1xuICBjb25zdCBsZW4gPSB2YWxpZGF0b3JzLmxlbmd0aDtcbiAgZm9yIChpID0gMDsgaSA8IGxlbjsgKytpKSB7XG5cbiAgICBjb25zdCB2ID0gdmFsaWRhdG9yc1tpXTtcblxuICAgIGlmICh2ID09PSBudWxsIHx8IHR5cGVvZiB2ICE9PSAnb2JqZWN0Jykge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgY29uc3QgdmFsaWRhdG9yID0gdi52YWxpZGF0b3I7XG4gICAgY29uc3QgdmFsaWRhdG9yUHJvcGVydGllcyA9IGlzU2ltcGxlVmFsaWRhdG9yKHYpID8gT2JqZWN0LmFzc2lnbih7fSwgdikgOiBjbG9uZSh2KTtcbiAgICB2YWxpZGF0b3JQcm9wZXJ0aWVzLnBhdGggPSBvcHRpb25zICYmIG9wdGlvbnMucGF0aCA/IG9wdGlvbnMucGF0aCA6IHBhdGg7XG4gICAgdmFsaWRhdG9yUHJvcGVydGllcy5mdWxsUGF0aCA9IHRoaXMuJGZ1bGxQYXRoO1xuICAgIHZhbGlkYXRvclByb3BlcnRpZXMudmFsdWUgPSB2YWx1ZTtcbiAgICBsZXQgb2sgPSBmYWxzZTtcblxuICAgIC8vIFNraXAgYW55IGV4cGxpY2l0IGFzeW5jIHZhbGlkYXRvcnMuIFZhbGlkYXRvcnMgdGhhdCByZXR1cm4gYSBwcm9taXNlXG4gICAgLy8gd2lsbCBzdGlsbCBydW4sIGJ1dCB3b24ndCB0cmlnZ2VyIGFueSBlcnJvcnMuXG4gICAgaWYgKGlzQXN5bmNGdW5jdGlvbih2YWxpZGF0b3IpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAodmFsaWRhdG9yIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgICBlcnIgPSBfdmFsaWRhdGUodmFsaWRhdG9yLnRlc3QodmFsdWUpLCB2YWxpZGF0b3JQcm9wZXJ0aWVzKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgdmFsaWRhdG9yICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgaWYgKHZhbGlkYXRvclByb3BlcnRpZXMucHJvcHNQYXJhbWV0ZXIpIHtcbiAgICAgICAgb2sgPSB2YWxpZGF0b3IuY2FsbChzY29wZSwgdmFsdWUsIHZhbGlkYXRvclByb3BlcnRpZXMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb2sgPSB2YWxpZGF0b3IuY2FsbChzY29wZSwgdmFsdWUpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBvayA9IGZhbHNlO1xuICAgICAgdmFsaWRhdG9yUHJvcGVydGllcy5yZWFzb24gPSBlcnJvcjtcbiAgICB9XG5cbiAgICAvLyBTa2lwIGFueSB2YWxpZGF0b3JzIHRoYXQgcmV0dXJuIGEgcHJvbWlzZSwgd2UgY2FuJ3QgaGFuZGxlIHRob3NlXG4gICAgLy8gc3luY2hyb25vdXNseVxuICAgIGlmIChvayAhPSBudWxsICYmIHR5cGVvZiBvay50aGVuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgZXJyID0gX3ZhbGlkYXRlKG9rLCB2YWxpZGF0b3JQcm9wZXJ0aWVzKTtcbiAgICBpZiAoZXJyKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZXJyO1xufTtcblxuLyoqXG4gKiBEZXRlcm1pbmVzIGlmIHZhbHVlIGlzIGEgdmFsaWQgUmVmZXJlbmNlLlxuICpcbiAqIEBwYXJhbSB7U2NoZW1hVHlwZX0gc2VsZlxuICogQHBhcmFtIHtPYmplY3R9IHZhbHVlXG4gKiBAcGFyYW0ge0RvY3VtZW50fSBkb2NcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gaW5pdFxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNjaGVtYVR5cGUuX2lzUmVmID0gZnVuY3Rpb24oc2VsZiwgdmFsdWUsIGRvYywgaW5pdCkge1xuICAvLyBmYXN0IHBhdGhcbiAgbGV0IHJlZiA9IGluaXQgJiYgc2VsZi5vcHRpb25zICYmIChzZWxmLm9wdGlvbnMucmVmIHx8IHNlbGYub3B0aW9ucy5yZWZQYXRoKTtcblxuICBpZiAoIXJlZiAmJiBkb2MgJiYgZG9jLiRfXyAhPSBudWxsKSB7XG4gICAgLy8gY2hlY2tzIGZvclxuICAgIC8vIC0gdGhpcyBwb3B1bGF0ZWQgd2l0aCBhZGhvYyBtb2RlbCBhbmQgbm8gcmVmIHdhcyBzZXQgaW4gc2NoZW1hIE9SXG4gICAgLy8gLSBzZXR0aW5nIC8gcHVzaGluZyB2YWx1ZXMgYWZ0ZXIgcG9wdWxhdGlvblxuICAgIGNvbnN0IHBhdGggPSBkb2MuJF9fZnVsbFBhdGgoc2VsZi5wYXRoLCB0cnVlKTtcblxuICAgIGNvbnN0IG93bmVyID0gZG9jLm93bmVyRG9jdW1lbnQoKTtcbiAgICByZWYgPSAocGF0aCAhPSBudWxsICYmIG93bmVyLiRwb3B1bGF0ZWQocGF0aCkpIHx8IGRvYy4kcG9wdWxhdGVkKHNlbGYucGF0aCk7XG4gIH1cblxuICBpZiAocmVmKSB7XG4gICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcih2YWx1ZSkgJiYgLy8gYnVmZmVycyBhcmUgb2JqZWN0cyB0b29cbiAgICAgIHZhbHVlLl9ic29udHlwZSAhPT0gJ0JpbmFyeScgLy8gcmF3IGJpbmFyeSB2YWx1ZSBmcm9tIHRoZSBkYlxuICAgICAgJiYgdXRpbHMuaXNPYmplY3QodmFsdWUpIC8vIG1pZ2h0IGhhdmUgZGVzZWxlY3RlZCBfaWQgaW4gcG9wdWxhdGlvbiBxdWVyeVxuICAgICkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGluaXQ7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59O1xuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cblNjaGVtYVR5cGUucHJvdG90eXBlLl9jYXN0UmVmID0gZnVuY3Rpb24gX2Nhc3RSZWYodmFsdWUsIGRvYywgaW5pdCkge1xuICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuXG4gIGlmICh2YWx1ZS4kX18gIT0gbnVsbCkge1xuICAgIHZhbHVlLiRfXy53YXNQb3B1bGF0ZWQgPSB2YWx1ZS4kX18ud2FzUG9wdWxhdGVkIHx8IHRydWU7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG5cbiAgLy8gc2V0dGluZyBhIHBvcHVsYXRlZCBwYXRoXG4gIGlmIChCdWZmZXIuaXNCdWZmZXIodmFsdWUpIHx8ICF1dGlscy5pc09iamVjdCh2YWx1ZSkpIHtcbiAgICBpZiAoaW5pdCkge1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgQ2FzdEVycm9yKHRoaXMuaW5zdGFuY2UsIHZhbHVlLCB0aGlzLnBhdGgsIG51bGwsIHRoaXMpO1xuICB9XG5cbiAgLy8gSGFuZGxlIHRoZSBjYXNlIHdoZXJlIHVzZXIgZGlyZWN0bHkgc2V0cyBhIHBvcHVsYXRlZFxuICAvLyBwYXRoIHRvIGEgcGxhaW4gb2JqZWN0OyBjYXN0IHRvIHRoZSBNb2RlbCB1c2VkIGluXG4gIC8vIHRoZSBwb3B1bGF0aW9uIHF1ZXJ5LlxuICBjb25zdCBwYXRoID0gZG9jLiRfX2Z1bGxQYXRoKHRoaXMucGF0aCwgdHJ1ZSk7XG4gIGNvbnN0IG93bmVyID0gZG9jLm93bmVyRG9jdW1lbnQoKTtcbiAgY29uc3QgcG9wID0gb3duZXIuJHBvcHVsYXRlZChwYXRoLCB0cnVlKTtcblxuICBsZXQgcmV0ID0gdmFsdWU7XG4gIGlmICghZG9jLiRfXy5wb3B1bGF0ZWQgfHxcbiAgICAhZG9jLiRfXy5wb3B1bGF0ZWRbcGF0aF0gfHxcbiAgICAhZG9jLiRfXy5wb3B1bGF0ZWRbcGF0aF0ub3B0aW9ucyB8fFxuICAgICFkb2MuJF9fLnBvcHVsYXRlZFtwYXRoXS5vcHRpb25zLm9wdGlvbnMgfHxcbiAgICAhZG9jLiRfXy5wb3B1bGF0ZWRbcGF0aF0ub3B0aW9ucy5vcHRpb25zLmxlYW4pIHtcbiAgICByZXQgPSBuZXcgcG9wLm9wdGlvbnNbcG9wdWxhdGVNb2RlbFN5bWJvbF0odmFsdWUpO1xuICAgIHJldC4kX18ud2FzUG9wdWxhdGVkID0gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiByZXQ7XG59O1xuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cbmZ1bmN0aW9uIGhhbmRsZVNpbmdsZSh2YWwsIGNvbnRleHQpIHtcbiAgcmV0dXJuIHRoaXMuY2FzdEZvclF1ZXJ5KG51bGwsIHZhbCwgY29udGV4dCk7XG59XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxuZnVuY3Rpb24gaGFuZGxlQXJyYXkodmFsLCBjb250ZXh0KSB7XG4gIGNvbnN0IF90aGlzID0gdGhpcztcbiAgaWYgKCFBcnJheS5pc0FycmF5KHZhbCkpIHtcbiAgICByZXR1cm4gW3RoaXMuY2FzdEZvclF1ZXJ5KG51bGwsIHZhbCwgY29udGV4dCldO1xuICB9XG4gIHJldHVybiB2YWwubWFwKGZ1bmN0aW9uKG0pIHtcbiAgICByZXR1cm4gX3RoaXMuY2FzdEZvclF1ZXJ5KG51bGwsIG0sIGNvbnRleHQpO1xuICB9KTtcbn1cblxuLyoqXG4gKiBKdXN0IGxpa2UgaGFuZGxlQXJyYXksIGV4Y2VwdCBhbHNvIGFsbG93cyBgW11gIGJlY2F1c2Ugc3VycHJpc2luZ2x5XG4gKiBgJGluOiBbMSwgW11dYCB3b3JrcyBmaW5lXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBoYW5kbGUkaW4odmFsLCBjb250ZXh0KSB7XG4gIGNvbnN0IF90aGlzID0gdGhpcztcbiAgaWYgKCFBcnJheS5pc0FycmF5KHZhbCkpIHtcbiAgICByZXR1cm4gW3RoaXMuY2FzdEZvclF1ZXJ5KG51bGwsIHZhbCwgY29udGV4dCldO1xuICB9XG4gIHJldHVybiB2YWwubWFwKGZ1bmN0aW9uKG0pIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShtKSAmJiBtLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIG07XG4gICAgfVxuICAgIHJldHVybiBfdGhpcy5jYXN0Rm9yUXVlcnkobnVsbCwgbSwgY29udGV4dCk7XG4gIH0pO1xufVxuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cblNjaGVtYVR5cGUucHJvdG90eXBlLiRjb25kaXRpb25hbEhhbmRsZXJzID0ge1xuICAkYWxsOiBoYW5kbGVBcnJheSxcbiAgJGVxOiBoYW5kbGVTaW5nbGUsXG4gICRpbjogaGFuZGxlJGluLFxuICAkbmU6IGhhbmRsZVNpbmdsZSxcbiAgJG5pbjogaGFuZGxlJGluLFxuICAkZXhpc3RzOiAkZXhpc3RzLFxuICAkdHlwZTogJHR5cGVcbn07XG5cbi8qKlxuICogQ2FzdCB0aGUgZ2l2ZW4gdmFsdWUgd2l0aCB0aGUgZ2l2ZW4gb3B0aW9uYWwgcXVlcnkgb3BlcmF0b3IuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IFskY29uZGl0aW9uYWxdIHF1ZXJ5IG9wZXJhdG9yLCBsaWtlIGAkZXFgIG9yIGAkaW5gXG4gKiBAcGFyYW0ge0FueX0gdmFsXG4gKiBAcGFyYW0ge1F1ZXJ5fSBjb250ZXh0XG4gKiBAcmV0dXJuIHtBbnl9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5TY2hlbWFUeXBlLnByb3RvdHlwZS5jYXN0Rm9yUXVlcnkgPSBmdW5jdGlvbigkY29uZGl0aW9uYWwsIHZhbCwgY29udGV4dCkge1xuICBsZXQgaGFuZGxlcjtcbiAgaWYgKCRjb25kaXRpb25hbCAhPSBudWxsKSB7XG4gICAgaGFuZGxlciA9IHRoaXMuJGNvbmRpdGlvbmFsSGFuZGxlcnNbJGNvbmRpdGlvbmFsXTtcbiAgICBpZiAoIWhhbmRsZXIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ2FuXFwndCB1c2UgJyArICRjb25kaXRpb25hbCk7XG4gICAgfVxuICAgIHJldHVybiBoYW5kbGVyLmNhbGwodGhpcywgdmFsLCBjb250ZXh0KTtcbiAgfVxuXG4gIHRyeSB7XG4gICAgcmV0dXJuIHRoaXMuYXBwbHlTZXR0ZXJzKHZhbCwgY29udGV4dCk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGlmIChlcnIgaW5zdGFuY2VvZiBDYXN0RXJyb3IgJiYgZXJyLnBhdGggPT09IHRoaXMucGF0aCAmJiB0aGlzLiRmdWxsUGF0aCAhPSBudWxsKSB7XG4gICAgICBlcnIucGF0aCA9IHRoaXMuJGZ1bGxQYXRoO1xuICAgIH1cbiAgICB0aHJvdyBlcnI7XG4gIH1cbn07XG5cbi8qKlxuICogU2V0ICYgR2V0IHRoZSBgY2hlY2tSZXF1aXJlZGAgZnVuY3Rpb25cbiAqIE92ZXJyaWRlIHRoZSBmdW5jdGlvbiB0aGUgcmVxdWlyZWQgdmFsaWRhdG9yIHVzZXMgdG8gY2hlY2sgd2hldGhlciBhIHZhbHVlXG4gKiBwYXNzZXMgdGhlIGByZXF1aXJlZGAgY2hlY2suIE92ZXJyaWRlIHRoaXMgb24gdGhlIGluZGl2aWR1YWwgU2NoZW1hVHlwZS5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIC8vIFVzZSB0aGlzIHRvIGFsbG93IGVtcHR5IHN0cmluZ3MgdG8gcGFzcyB0aGUgYHJlcXVpcmVkYCB2YWxpZGF0b3JcbiAqICAgICBtb25nb29zZS5TY2hlbWEuVHlwZXMuU3RyaW5nLmNoZWNrUmVxdWlyZWQodiA9PiB0eXBlb2YgdiA9PT0gJ3N0cmluZycpO1xuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtmbl0gSWYgc2V0LCB3aWxsIG92ZXJ3cml0ZSB0aGUgY3VycmVudCBzZXQgZnVuY3Rpb25cbiAqIEByZXR1cm4ge0Z1bmN0aW9ufSBUaGUgaW5wdXQgYGZuYCBvciB0aGUgYWxyZWFkeSBzZXQgZnVuY3Rpb25cbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBTY2hlbWFUeXBlXG4gKiBAZnVuY3Rpb24gY2hlY2tSZXF1aXJlZFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5TY2hlbWFUeXBlLmNoZWNrUmVxdWlyZWQgPSBmdW5jdGlvbihmbikge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCAhPT0gMCkge1xuICAgIHRoaXMuX2NoZWNrUmVxdWlyZWQgPSBmbjtcbiAgfVxuXG4gIHJldHVybiB0aGlzLl9jaGVja1JlcXVpcmVkO1xufTtcblxuLyoqXG4gKiBEZWZhdWx0IGNoZWNrIGZvciBpZiB0aGlzIHBhdGggc2F0aXNmaWVzIHRoZSBgcmVxdWlyZWRgIHZhbGlkYXRvci5cbiAqXG4gKiBAcGFyYW0ge0FueX0gdmFsXG4gKiBAcmV0dXJuIHtCb29sZWFufSBgdHJ1ZWAgd2hlbiB0aGUgdmFsdWUgaXMgbm90IGBudWxsYCwgYGZhbHNlYCBvdGhlcndpc2VcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNjaGVtYVR5cGUucHJvdG90eXBlLmNoZWNrUmVxdWlyZWQgPSBmdW5jdGlvbih2YWwpIHtcbiAgcmV0dXJuIHZhbCAhPSBudWxsO1xufTtcblxuLyoqXG4gKiBDbG9uZSB0aGUgY3VycmVudCBTY2hlbWFUeXBlXG4gKlxuICogQHJldHVybiB7U2NoZW1hVHlwZX0gVGhlIGNsb25lZCBTY2hlbWFUeXBlIGluc3RhbmNlXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5TY2hlbWFUeXBlLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uKCkge1xuICBjb25zdCBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5vcHRpb25zKTtcbiAgY29uc3Qgc2NoZW1hdHlwZSA9IG5ldyB0aGlzLmNvbnN0cnVjdG9yKHRoaXMucGF0aCwgb3B0aW9ucywgdGhpcy5pbnN0YW5jZSk7XG4gIHNjaGVtYXR5cGUudmFsaWRhdG9ycyA9IHRoaXMudmFsaWRhdG9ycy5zbGljZSgpO1xuICBpZiAodGhpcy5yZXF1aXJlZFZhbGlkYXRvciAhPT0gdW5kZWZpbmVkKSBzY2hlbWF0eXBlLnJlcXVpcmVkVmFsaWRhdG9yID0gdGhpcy5yZXF1aXJlZFZhbGlkYXRvcjtcbiAgaWYgKHRoaXMuZGVmYXVsdFZhbHVlICE9PSB1bmRlZmluZWQpIHNjaGVtYXR5cGUuZGVmYXVsdFZhbHVlID0gdGhpcy5kZWZhdWx0VmFsdWU7XG4gIGlmICh0aGlzLiRpbW11dGFibGUgIT09IHVuZGVmaW5lZCAmJiB0aGlzLm9wdGlvbnMuaW1tdXRhYmxlID09PSB1bmRlZmluZWQpIHtcbiAgICBzY2hlbWF0eXBlLiRpbW11dGFibGUgPSB0aGlzLiRpbW11dGFibGU7XG5cbiAgICBoYW5kbGVJbW11dGFibGUoc2NoZW1hdHlwZSk7XG4gIH1cbiAgaWYgKHRoaXMuX2luZGV4ICE9PSB1bmRlZmluZWQpIHNjaGVtYXR5cGUuX2luZGV4ID0gdGhpcy5faW5kZXg7XG4gIGlmICh0aGlzLnNlbGVjdGVkICE9PSB1bmRlZmluZWQpIHNjaGVtYXR5cGUuc2VsZWN0ZWQgPSB0aGlzLnNlbGVjdGVkO1xuICBpZiAodGhpcy5pc1JlcXVpcmVkICE9PSB1bmRlZmluZWQpIHNjaGVtYXR5cGUuaXNSZXF1aXJlZCA9IHRoaXMuaXNSZXF1aXJlZDtcbiAgaWYgKHRoaXMub3JpZ2luYWxSZXF1aXJlZFZhbHVlICE9PSB1bmRlZmluZWQpIHNjaGVtYXR5cGUub3JpZ2luYWxSZXF1aXJlZFZhbHVlID0gdGhpcy5vcmlnaW5hbFJlcXVpcmVkVmFsdWU7XG4gIHNjaGVtYXR5cGUuZ2V0dGVycyA9IHRoaXMuZ2V0dGVycy5zbGljZSgpO1xuICBzY2hlbWF0eXBlLnNldHRlcnMgPSB0aGlzLnNldHRlcnMuc2xpY2UoKTtcbiAgcmV0dXJuIHNjaGVtYXR5cGU7XG59O1xuXG4vKiFcbiAqIE1vZHVsZSBleHBvcnRzLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IFNjaGVtYVR5cGU7XG5cbmV4cG9ydHMuQ2FzdEVycm9yID0gQ2FzdEVycm9yO1xuXG5leHBvcnRzLlZhbGlkYXRvckVycm9yID0gVmFsaWRhdG9yRXJyb3I7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../server/node_modules/mongoose/lib/schemaType.js\n");

/***/ }),

/***/ "../server/node_modules/mongoose/lib/stateMachine.js":
/*!***********************************************************!*\
  !*** ../server/node_modules/mongoose/lib/stateMachine.js ***!
  \***********************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("\n/*!\n * Module dependencies.\n */\n\n\n\nconst utils = __webpack_require__(/*! ./utils */ \"../server/node_modules/mongoose/lib/utils.js\"); // eslint-disable-line no-unused-vars\n\n/**\n * StateMachine represents a minimal `interface` for the\n * constructors it builds via StateMachine.ctor(...).\n *\n * @api private\n */\n\nconst StateMachine = module.exports = exports = function StateMachine() {\n};\n\n/**\n * StateMachine.ctor('state1', 'state2', ...)\n * A factory method for subclassing StateMachine.\n * The arguments are a list of states. For each state,\n * the constructor's prototype gets state transition\n * methods named after each state. These transition methods\n * place their path argument into the given state.\n *\n * @param {String} state\n * @param {String} [state]\n * @return {Function} subclass constructor\n * @api private\n */\n\nStateMachine.ctor = function() {\n  const states = [...arguments];\n\n  const ctor = function() {\n    StateMachine.apply(this, arguments);\n    this.paths = {};\n    this.states = {};\n  };\n\n  ctor.prototype = new StateMachine();\n\n  ctor.prototype.stateNames = states;\n\n  states.forEach(function(state) {\n    // Changes the `path`'s state to `state`.\n    ctor.prototype[state] = function(path) {\n      this._changeState(path, state);\n    };\n  });\n\n  return ctor;\n};\n\n/**\n * This function is wrapped by the state change functions:\n *\n * - `require(path)`\n * - `modify(path)`\n * - `init(path)`\n *\n * @api private\n */\n\nStateMachine.prototype._changeState = function _changeState(path, nextState) {\n  const prevState = this.paths[path];\n  if (prevState === nextState) {\n    return;\n  }\n  const prevBucket = this.states[prevState];\n  if (prevBucket) delete prevBucket[path];\n\n  this.paths[path] = nextState;\n  this.states[nextState] = this.states[nextState] || {};\n  this.states[nextState][path] = true;\n};\n\n/*!\n * ignore\n */\n\nStateMachine.prototype.clear = function clear(state) {\n  if (this.states[state] == null) {\n    return;\n  }\n  const keys = Object.keys(this.states[state]);\n  let i = keys.length;\n  let path;\n\n  while (i--) {\n    path = keys[i];\n    delete this.states[state][path];\n    delete this.paths[path];\n  }\n};\n\n/*!\n * ignore\n */\n\nStateMachine.prototype.clearPath = function clearPath(path) {\n  const state = this.paths[path];\n  if (!state) {\n    return;\n  }\n  delete this.paths[path];\n  delete this.states[state][path];\n};\n\n/**\n * Gets the paths for the given state, or empty object `{}` if none.\n * @api private\n */\n\nStateMachine.prototype.getStatePaths = function getStatePaths(state) {\n  if (this.states[state] != null) {\n    return this.states[state];\n  }\n  return {};\n};\n\n/**\n * Checks to see if at least one path is in the states passed in via `arguments`\n * e.g., this.some('required', 'inited')\n *\n * @param {String} state that we want to check for.\n * @api private\n */\n\nStateMachine.prototype.some = function some() {\n  const _this = this;\n  const what = arguments.length ? arguments : this.stateNames;\n  return Array.prototype.some.call(what, function(state) {\n    if (_this.states[state] == null) {\n      return false;\n    }\n    return Object.keys(_this.states[state]).length;\n  });\n};\n\n/**\n * This function builds the functions that get assigned to `forEach` and `map`,\n * since both of those methods share a lot of the same logic.\n *\n * @param {String} iterMethod is either 'forEach' or 'map'\n * @return {Function}\n * @api private\n */\n\nStateMachine.prototype._iter = function _iter(iterMethod) {\n  return function() {\n    let states = [...arguments];\n    const callback = states.pop();\n\n    if (!states.length) states = this.stateNames;\n\n    const _this = this;\n\n    const paths = states.reduce(function(paths, state) {\n      if (_this.states[state] == null) {\n        return paths;\n      }\n      return paths.concat(Object.keys(_this.states[state]));\n    }, []);\n\n    return paths[iterMethod](function(path, i, paths) {\n      return callback(path, i, paths);\n    });\n  };\n};\n\n/**\n * Iterates over the paths that belong to one of the parameter states.\n *\n * The function profile can look like:\n * this.forEach(state1, fn);         // iterates over all paths in state1\n * this.forEach(state1, state2, fn); // iterates over all paths in state1 or state2\n * this.forEach(fn);                 // iterates over all paths in all states\n *\n * @param {String} [state]\n * @param {String} [state]\n * @param {Function} callback\n * @api private\n */\n\nStateMachine.prototype.forEach = function forEach() {\n  this.forEach = this._iter('forEach');\n  return this.forEach.apply(this, arguments);\n};\n\n/**\n * Maps over the paths that belong to one of the parameter states.\n *\n * The function profile can look like:\n * this.forEach(state1, fn);         // iterates over all paths in state1\n * this.forEach(state1, state2, fn); // iterates over all paths in state1 or state2\n * this.forEach(fn);                 // iterates over all paths in all states\n *\n * @param {String} [state]\n * @param {String} [state]\n * @param {Function} callback\n * @return {Array}\n * @api private\n */\n\nStateMachine.prototype.map = function map() {\n  this.map = this._iter('map');\n  return this.map.apply(this, arguments);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvc3RhdGVNYWNoaW5lLmpzIiwibWFwcGluZ3MiOiI7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7O0FBRWIsY0FBYyxtQkFBTyxDQUFDLDZEQUFTLEdBQUc7O0FBRWxDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFlBQVksVUFBVTtBQUN0QjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMERBQTBEO0FBQzFEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckMscUNBQXFDO0FBQ3JDLHFDQUFxQztBQUNyQztBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxVQUFVO0FBQ3JCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckMscUNBQXFDO0FBQ3JDLHFDQUFxQztBQUNyQztBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxVQUFVO0FBQ3JCLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2xpZW50Ly4uL3NlcnZlci9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL3N0YXRlTWFjaGluZS5qcz81ODc0Il0sInNvdXJjZXNDb250ZW50IjpbIlxuLyohXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuY29uc3QgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcblxuLyoqXG4gKiBTdGF0ZU1hY2hpbmUgcmVwcmVzZW50cyBhIG1pbmltYWwgYGludGVyZmFjZWAgZm9yIHRoZVxuICogY29uc3RydWN0b3JzIGl0IGJ1aWxkcyB2aWEgU3RhdGVNYWNoaW5lLmN0b3IoLi4uKS5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5jb25zdCBTdGF0ZU1hY2hpbmUgPSBtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBmdW5jdGlvbiBTdGF0ZU1hY2hpbmUoKSB7XG59O1xuXG4vKipcbiAqIFN0YXRlTWFjaGluZS5jdG9yKCdzdGF0ZTEnLCAnc3RhdGUyJywgLi4uKVxuICogQSBmYWN0b3J5IG1ldGhvZCBmb3Igc3ViY2xhc3NpbmcgU3RhdGVNYWNoaW5lLlxuICogVGhlIGFyZ3VtZW50cyBhcmUgYSBsaXN0IG9mIHN0YXRlcy4gRm9yIGVhY2ggc3RhdGUsXG4gKiB0aGUgY29uc3RydWN0b3IncyBwcm90b3R5cGUgZ2V0cyBzdGF0ZSB0cmFuc2l0aW9uXG4gKiBtZXRob2RzIG5hbWVkIGFmdGVyIGVhY2ggc3RhdGUuIFRoZXNlIHRyYW5zaXRpb24gbWV0aG9kc1xuICogcGxhY2UgdGhlaXIgcGF0aCBhcmd1bWVudCBpbnRvIHRoZSBnaXZlbiBzdGF0ZS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RhdGVcbiAqIEBwYXJhbSB7U3RyaW5nfSBbc3RhdGVdXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn0gc3ViY2xhc3MgY29uc3RydWN0b3JcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblN0YXRlTWFjaGluZS5jdG9yID0gZnVuY3Rpb24oKSB7XG4gIGNvbnN0IHN0YXRlcyA9IFsuLi5hcmd1bWVudHNdO1xuXG4gIGNvbnN0IGN0b3IgPSBmdW5jdGlvbigpIHtcbiAgICBTdGF0ZU1hY2hpbmUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB0aGlzLnBhdGhzID0ge307XG4gICAgdGhpcy5zdGF0ZXMgPSB7fTtcbiAgfTtcblxuICBjdG9yLnByb3RvdHlwZSA9IG5ldyBTdGF0ZU1hY2hpbmUoKTtcblxuICBjdG9yLnByb3RvdHlwZS5zdGF0ZU5hbWVzID0gc3RhdGVzO1xuXG4gIHN0YXRlcy5mb3JFYWNoKGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgLy8gQ2hhbmdlcyB0aGUgYHBhdGhgJ3Mgc3RhdGUgdG8gYHN0YXRlYC5cbiAgICBjdG9yLnByb3RvdHlwZVtzdGF0ZV0gPSBmdW5jdGlvbihwYXRoKSB7XG4gICAgICB0aGlzLl9jaGFuZ2VTdGF0ZShwYXRoLCBzdGF0ZSk7XG4gICAgfTtcbiAgfSk7XG5cbiAgcmV0dXJuIGN0b3I7XG59O1xuXG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gaXMgd3JhcHBlZCBieSB0aGUgc3RhdGUgY2hhbmdlIGZ1bmN0aW9uczpcbiAqXG4gKiAtIGByZXF1aXJlKHBhdGgpYFxuICogLSBgbW9kaWZ5KHBhdGgpYFxuICogLSBgaW5pdChwYXRoKWBcbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5TdGF0ZU1hY2hpbmUucHJvdG90eXBlLl9jaGFuZ2VTdGF0ZSA9IGZ1bmN0aW9uIF9jaGFuZ2VTdGF0ZShwYXRoLCBuZXh0U3RhdGUpIHtcbiAgY29uc3QgcHJldlN0YXRlID0gdGhpcy5wYXRoc1twYXRoXTtcbiAgaWYgKHByZXZTdGF0ZSA9PT0gbmV4dFN0YXRlKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IHByZXZCdWNrZXQgPSB0aGlzLnN0YXRlc1twcmV2U3RhdGVdO1xuICBpZiAocHJldkJ1Y2tldCkgZGVsZXRlIHByZXZCdWNrZXRbcGF0aF07XG5cbiAgdGhpcy5wYXRoc1twYXRoXSA9IG5leHRTdGF0ZTtcbiAgdGhpcy5zdGF0ZXNbbmV4dFN0YXRlXSA9IHRoaXMuc3RhdGVzW25leHRTdGF0ZV0gfHwge307XG4gIHRoaXMuc3RhdGVzW25leHRTdGF0ZV1bcGF0aF0gPSB0cnVlO1xufTtcblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5TdGF0ZU1hY2hpbmUucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gY2xlYXIoc3RhdGUpIHtcbiAgaWYgKHRoaXMuc3RhdGVzW3N0YXRlXSA9PSBudWxsKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyh0aGlzLnN0YXRlc1tzdGF0ZV0pO1xuICBsZXQgaSA9IGtleXMubGVuZ3RoO1xuICBsZXQgcGF0aDtcblxuICB3aGlsZSAoaS0tKSB7XG4gICAgcGF0aCA9IGtleXNbaV07XG4gICAgZGVsZXRlIHRoaXMuc3RhdGVzW3N0YXRlXVtwYXRoXTtcbiAgICBkZWxldGUgdGhpcy5wYXRoc1twYXRoXTtcbiAgfVxufTtcblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5TdGF0ZU1hY2hpbmUucHJvdG90eXBlLmNsZWFyUGF0aCA9IGZ1bmN0aW9uIGNsZWFyUGF0aChwYXRoKSB7XG4gIGNvbnN0IHN0YXRlID0gdGhpcy5wYXRoc1twYXRoXTtcbiAgaWYgKCFzdGF0ZSkge1xuICAgIHJldHVybjtcbiAgfVxuICBkZWxldGUgdGhpcy5wYXRoc1twYXRoXTtcbiAgZGVsZXRlIHRoaXMuc3RhdGVzW3N0YXRlXVtwYXRoXTtcbn07XG5cbi8qKlxuICogR2V0cyB0aGUgcGF0aHMgZm9yIHRoZSBnaXZlbiBzdGF0ZSwgb3IgZW1wdHkgb2JqZWN0IGB7fWAgaWYgbm9uZS5cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblN0YXRlTWFjaGluZS5wcm90b3R5cGUuZ2V0U3RhdGVQYXRocyA9IGZ1bmN0aW9uIGdldFN0YXRlUGF0aHMoc3RhdGUpIHtcbiAgaWYgKHRoaXMuc3RhdGVzW3N0YXRlXSAhPSBudWxsKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhdGVzW3N0YXRlXTtcbiAgfVxuICByZXR1cm4ge307XG59O1xuXG4vKipcbiAqIENoZWNrcyB0byBzZWUgaWYgYXQgbGVhc3Qgb25lIHBhdGggaXMgaW4gdGhlIHN0YXRlcyBwYXNzZWQgaW4gdmlhIGBhcmd1bWVudHNgXG4gKiBlLmcuLCB0aGlzLnNvbWUoJ3JlcXVpcmVkJywgJ2luaXRlZCcpXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0YXRlIHRoYXQgd2Ugd2FudCB0byBjaGVjayBmb3IuXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5TdGF0ZU1hY2hpbmUucHJvdG90eXBlLnNvbWUgPSBmdW5jdGlvbiBzb21lKCkge1xuICBjb25zdCBfdGhpcyA9IHRoaXM7XG4gIGNvbnN0IHdoYXQgPSBhcmd1bWVudHMubGVuZ3RoID8gYXJndW1lbnRzIDogdGhpcy5zdGF0ZU5hbWVzO1xuICByZXR1cm4gQXJyYXkucHJvdG90eXBlLnNvbWUuY2FsbCh3aGF0LCBmdW5jdGlvbihzdGF0ZSkge1xuICAgIGlmIChfdGhpcy5zdGF0ZXNbc3RhdGVdID09IG51bGwpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKF90aGlzLnN0YXRlc1tzdGF0ZV0pLmxlbmd0aDtcbiAgfSk7XG59O1xuXG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gYnVpbGRzIHRoZSBmdW5jdGlvbnMgdGhhdCBnZXQgYXNzaWduZWQgdG8gYGZvckVhY2hgIGFuZCBgbWFwYCxcbiAqIHNpbmNlIGJvdGggb2YgdGhvc2UgbWV0aG9kcyBzaGFyZSBhIGxvdCBvZiB0aGUgc2FtZSBsb2dpYy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gaXRlck1ldGhvZCBpcyBlaXRoZXIgJ2ZvckVhY2gnIG9yICdtYXAnXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblN0YXRlTWFjaGluZS5wcm90b3R5cGUuX2l0ZXIgPSBmdW5jdGlvbiBfaXRlcihpdGVyTWV0aG9kKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICBsZXQgc3RhdGVzID0gWy4uLmFyZ3VtZW50c107XG4gICAgY29uc3QgY2FsbGJhY2sgPSBzdGF0ZXMucG9wKCk7XG5cbiAgICBpZiAoIXN0YXRlcy5sZW5ndGgpIHN0YXRlcyA9IHRoaXMuc3RhdGVOYW1lcztcblxuICAgIGNvbnN0IF90aGlzID0gdGhpcztcblxuICAgIGNvbnN0IHBhdGhzID0gc3RhdGVzLnJlZHVjZShmdW5jdGlvbihwYXRocywgc3RhdGUpIHtcbiAgICAgIGlmIChfdGhpcy5zdGF0ZXNbc3RhdGVdID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHBhdGhzO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHBhdGhzLmNvbmNhdChPYmplY3Qua2V5cyhfdGhpcy5zdGF0ZXNbc3RhdGVdKSk7XG4gICAgfSwgW10pO1xuXG4gICAgcmV0dXJuIHBhdGhzW2l0ZXJNZXRob2RdKGZ1bmN0aW9uKHBhdGgsIGksIHBhdGhzKSB7XG4gICAgICByZXR1cm4gY2FsbGJhY2socGF0aCwgaSwgcGF0aHMpO1xuICAgIH0pO1xuICB9O1xufTtcblxuLyoqXG4gKiBJdGVyYXRlcyBvdmVyIHRoZSBwYXRocyB0aGF0IGJlbG9uZyB0byBvbmUgb2YgdGhlIHBhcmFtZXRlciBzdGF0ZXMuXG4gKlxuICogVGhlIGZ1bmN0aW9uIHByb2ZpbGUgY2FuIGxvb2sgbGlrZTpcbiAqIHRoaXMuZm9yRWFjaChzdGF0ZTEsIGZuKTsgICAgICAgICAvLyBpdGVyYXRlcyBvdmVyIGFsbCBwYXRocyBpbiBzdGF0ZTFcbiAqIHRoaXMuZm9yRWFjaChzdGF0ZTEsIHN0YXRlMiwgZm4pOyAvLyBpdGVyYXRlcyBvdmVyIGFsbCBwYXRocyBpbiBzdGF0ZTEgb3Igc3RhdGUyXG4gKiB0aGlzLmZvckVhY2goZm4pOyAgICAgICAgICAgICAgICAgLy8gaXRlcmF0ZXMgb3ZlciBhbGwgcGF0aHMgaW4gYWxsIHN0YXRlc1xuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBbc3RhdGVdXG4gKiBAcGFyYW0ge1N0cmluZ30gW3N0YXRlXVxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblN0YXRlTWFjaGluZS5wcm90b3R5cGUuZm9yRWFjaCA9IGZ1bmN0aW9uIGZvckVhY2goKSB7XG4gIHRoaXMuZm9yRWFjaCA9IHRoaXMuX2l0ZXIoJ2ZvckVhY2gnKTtcbiAgcmV0dXJuIHRoaXMuZm9yRWFjaC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufTtcblxuLyoqXG4gKiBNYXBzIG92ZXIgdGhlIHBhdGhzIHRoYXQgYmVsb25nIHRvIG9uZSBvZiB0aGUgcGFyYW1ldGVyIHN0YXRlcy5cbiAqXG4gKiBUaGUgZnVuY3Rpb24gcHJvZmlsZSBjYW4gbG9vayBsaWtlOlxuICogdGhpcy5mb3JFYWNoKHN0YXRlMSwgZm4pOyAgICAgICAgIC8vIGl0ZXJhdGVzIG92ZXIgYWxsIHBhdGhzIGluIHN0YXRlMVxuICogdGhpcy5mb3JFYWNoKHN0YXRlMSwgc3RhdGUyLCBmbik7IC8vIGl0ZXJhdGVzIG92ZXIgYWxsIHBhdGhzIGluIHN0YXRlMSBvciBzdGF0ZTJcbiAqIHRoaXMuZm9yRWFjaChmbik7ICAgICAgICAgICAgICAgICAvLyBpdGVyYXRlcyBvdmVyIGFsbCBwYXRocyBpbiBhbGwgc3RhdGVzXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IFtzdGF0ZV1cbiAqIEBwYXJhbSB7U3RyaW5nfSBbc3RhdGVdXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICogQHJldHVybiB7QXJyYXl9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5TdGF0ZU1hY2hpbmUucHJvdG90eXBlLm1hcCA9IGZ1bmN0aW9uIG1hcCgpIHtcbiAgdGhpcy5tYXAgPSB0aGlzLl9pdGVyKCdtYXAnKTtcbiAgcmV0dXJuIHRoaXMubWFwLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../server/node_modules/mongoose/lib/stateMachine.js\n");

/***/ }),

/***/ "../server/node_modules/mongoose/lib/types/array/index.js":
/*!****************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/types/array/index.js ***!
  \****************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("/*!\n * Module dependencies.\n */\n\n\n\nconst Document = __webpack_require__(/*! ../../document */ \"../server/node_modules/mongoose/lib/document.js\");\nconst mongooseArrayMethods = __webpack_require__(/*! ./methods */ \"../server/node_modules/mongoose/lib/types/array/methods/index.js\");\n\nconst arrayAtomicsSymbol = (__webpack_require__(/*! ../../helpers/symbols */ \"../server/node_modules/mongoose/lib/helpers/symbols.js\").arrayAtomicsSymbol);\nconst arrayAtomicsBackupSymbol = (__webpack_require__(/*! ../../helpers/symbols */ \"../server/node_modules/mongoose/lib/helpers/symbols.js\").arrayAtomicsBackupSymbol);\nconst arrayParentSymbol = (__webpack_require__(/*! ../../helpers/symbols */ \"../server/node_modules/mongoose/lib/helpers/symbols.js\").arrayParentSymbol);\nconst arrayPathSymbol = (__webpack_require__(/*! ../../helpers/symbols */ \"../server/node_modules/mongoose/lib/helpers/symbols.js\").arrayPathSymbol);\nconst arraySchemaSymbol = (__webpack_require__(/*! ../../helpers/symbols */ \"../server/node_modules/mongoose/lib/helpers/symbols.js\").arraySchemaSymbol);\n\n/**\n * Mongoose Array constructor.\n *\n * #### Note:\n *\n * _Values always have to be passed to the constructor to initialize, otherwise `MongooseArray#push` will mark the array as modified._\n *\n * @param {Array} values\n * @param {String} path\n * @param {Document} doc parent document\n * @api private\n * @inherits Array https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array\n * @see https://bit.ly/f6CnZU\n */\nconst _basePush = Array.prototype.push;\nconst numberRE = /^\\d+$/;\n\nfunction MongooseArray(values, path, doc, schematype) {\n  let __array;\n\n  if (Array.isArray(values)) {\n    const len = values.length;\n\n    // Perf optimizations for small arrays: much faster to use `...` than `for` + `push`,\n    // but large arrays may cause stack overflows. And for arrays of length 0/1, just\n    // modifying the array is faster. Seems small, but adds up when you have a document\n    // with thousands of nested arrays.\n    if (len === 0) {\n      __array = new Array();\n    } else if (len === 1) {\n      __array = new Array(1);\n      __array[0] = values[0];\n    } else if (len < 10000) {\n      __array = new Array();\n      _basePush.apply(__array, values);\n    } else {\n      __array = new Array();\n      for (let i = 0; i < len; ++i) {\n        _basePush.call(__array, values[i]);\n      }\n    }\n  } else {\n    __array = [];\n  }\n\n  const internals = {\n    [arrayAtomicsSymbol]: {},\n    [arrayAtomicsBackupSymbol]: void 0,\n    [arrayPathSymbol]: path,\n    [arraySchemaSymbol]: schematype,\n    [arrayParentSymbol]: void 0,\n    isMongooseArray: true,\n    isMongooseArrayProxy: true,\n    __array: __array\n  };\n\n  if (values && values[arrayAtomicsSymbol] != null) {\n    internals[arrayAtomicsSymbol] = values[arrayAtomicsSymbol];\n  }\n\n  // Because doc comes from the context of another function, doc === global\n  // can happen if there was a null somewhere up the chain (see #3020)\n  // RB Jun 17, 2015 updated to check for presence of expected paths instead\n  // to make more proof against unusual node environments\n  if (doc != null && doc instanceof Document) {\n    internals[arrayParentSymbol] = doc;\n    internals[arraySchemaSymbol] = schematype || doc.schema.path(path);\n  }\n\n  const proxy = new Proxy(__array, {\n    get: function(target, prop) {\n      if (internals.hasOwnProperty(prop)) {\n        return internals[prop];\n      }\n      if (mongooseArrayMethods.hasOwnProperty(prop)) {\n        return mongooseArrayMethods[prop];\n      }\n      if (typeof prop === 'string' && numberRE.test(prop) && schematype?.$embeddedSchemaType != null) {\n        return schematype.$embeddedSchemaType.applyGetters(__array[prop], doc);\n      }\n\n      return __array[prop];\n    },\n    set: function(target, prop, value) {\n      if (typeof prop === 'string' && numberRE.test(prop)) {\n        mongooseArrayMethods.set.call(proxy, prop, value, false);\n      } else if (internals.hasOwnProperty(prop)) {\n        internals[prop] = value;\n      } else {\n        __array[prop] = value;\n      }\n\n      return true;\n    }\n  });\n\n  return proxy;\n}\n\n/*!\n * Module exports.\n */\n\nmodule.exports = exports = MongooseArray;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvdHlwZXMvYXJyYXkvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBOztBQUVhOztBQUViLGlCQUFpQixtQkFBTyxDQUFDLHVFQUFnQjtBQUN6Qyw2QkFBNkIsbUJBQU8sQ0FBQyxtRkFBVzs7QUFFaEQsMkJBQTJCLCtIQUFtRDtBQUM5RSxpQ0FBaUMscUlBQXlEO0FBQzFGLDBCQUEwQiw4SEFBa0Q7QUFDNUUsd0JBQXdCLDRIQUFnRDtBQUN4RSwwQkFBMEIsOEhBQWtEOztBQUU1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxVQUFVO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLHNCQUFzQixTQUFTO0FBQy9CO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL2NsaWVudC8uLi9zZXJ2ZXIvbm9kZV9tb2R1bGVzL21vbmdvb3NlL2xpYi90eXBlcy9hcnJheS9pbmRleC5qcz9hZjZmIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbmNvbnN0IERvY3VtZW50ID0gcmVxdWlyZSgnLi4vLi4vZG9jdW1lbnQnKTtcbmNvbnN0IG1vbmdvb3NlQXJyYXlNZXRob2RzID0gcmVxdWlyZSgnLi9tZXRob2RzJyk7XG5cbmNvbnN0IGFycmF5QXRvbWljc1N5bWJvbCA9IHJlcXVpcmUoJy4uLy4uL2hlbHBlcnMvc3ltYm9scycpLmFycmF5QXRvbWljc1N5bWJvbDtcbmNvbnN0IGFycmF5QXRvbWljc0JhY2t1cFN5bWJvbCA9IHJlcXVpcmUoJy4uLy4uL2hlbHBlcnMvc3ltYm9scycpLmFycmF5QXRvbWljc0JhY2t1cFN5bWJvbDtcbmNvbnN0IGFycmF5UGFyZW50U3ltYm9sID0gcmVxdWlyZSgnLi4vLi4vaGVscGVycy9zeW1ib2xzJykuYXJyYXlQYXJlbnRTeW1ib2w7XG5jb25zdCBhcnJheVBhdGhTeW1ib2wgPSByZXF1aXJlKCcuLi8uLi9oZWxwZXJzL3N5bWJvbHMnKS5hcnJheVBhdGhTeW1ib2w7XG5jb25zdCBhcnJheVNjaGVtYVN5bWJvbCA9IHJlcXVpcmUoJy4uLy4uL2hlbHBlcnMvc3ltYm9scycpLmFycmF5U2NoZW1hU3ltYm9sO1xuXG4vKipcbiAqIE1vbmdvb3NlIEFycmF5IGNvbnN0cnVjdG9yLlxuICpcbiAqICMjIyMgTm90ZTpcbiAqXG4gKiBfVmFsdWVzIGFsd2F5cyBoYXZlIHRvIGJlIHBhc3NlZCB0byB0aGUgY29uc3RydWN0b3IgdG8gaW5pdGlhbGl6ZSwgb3RoZXJ3aXNlIGBNb25nb29zZUFycmF5I3B1c2hgIHdpbGwgbWFyayB0aGUgYXJyYXkgYXMgbW9kaWZpZWQuX1xuICpcbiAqIEBwYXJhbSB7QXJyYXl9IHZhbHVlc1xuICogQHBhcmFtIHtTdHJpbmd9IHBhdGhcbiAqIEBwYXJhbSB7RG9jdW1lbnR9IGRvYyBwYXJlbnQgZG9jdW1lbnRcbiAqIEBhcGkgcHJpdmF0ZVxuICogQGluaGVyaXRzIEFycmF5IGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0FycmF5XG4gKiBAc2VlIGh0dHBzOi8vYml0Lmx5L2Y2Q25aVVxuICovXG5jb25zdCBfYmFzZVB1c2ggPSBBcnJheS5wcm90b3R5cGUucHVzaDtcbmNvbnN0IG51bWJlclJFID0gL15cXGQrJC87XG5cbmZ1bmN0aW9uIE1vbmdvb3NlQXJyYXkodmFsdWVzLCBwYXRoLCBkb2MsIHNjaGVtYXR5cGUpIHtcbiAgbGV0IF9fYXJyYXk7XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWVzKSkge1xuICAgIGNvbnN0IGxlbiA9IHZhbHVlcy5sZW5ndGg7XG5cbiAgICAvLyBQZXJmIG9wdGltaXphdGlvbnMgZm9yIHNtYWxsIGFycmF5czogbXVjaCBmYXN0ZXIgdG8gdXNlIGAuLi5gIHRoYW4gYGZvcmAgKyBgcHVzaGAsXG4gICAgLy8gYnV0IGxhcmdlIGFycmF5cyBtYXkgY2F1c2Ugc3RhY2sgb3ZlcmZsb3dzLiBBbmQgZm9yIGFycmF5cyBvZiBsZW5ndGggMC8xLCBqdXN0XG4gICAgLy8gbW9kaWZ5aW5nIHRoZSBhcnJheSBpcyBmYXN0ZXIuIFNlZW1zIHNtYWxsLCBidXQgYWRkcyB1cCB3aGVuIHlvdSBoYXZlIGEgZG9jdW1lbnRcbiAgICAvLyB3aXRoIHRob3VzYW5kcyBvZiBuZXN0ZWQgYXJyYXlzLlxuICAgIGlmIChsZW4gPT09IDApIHtcbiAgICAgIF9fYXJyYXkgPSBuZXcgQXJyYXkoKTtcbiAgICB9IGVsc2UgaWYgKGxlbiA9PT0gMSkge1xuICAgICAgX19hcnJheSA9IG5ldyBBcnJheSgxKTtcbiAgICAgIF9fYXJyYXlbMF0gPSB2YWx1ZXNbMF07XG4gICAgfSBlbHNlIGlmIChsZW4gPCAxMDAwMCkge1xuICAgICAgX19hcnJheSA9IG5ldyBBcnJheSgpO1xuICAgICAgX2Jhc2VQdXNoLmFwcGx5KF9fYXJyYXksIHZhbHVlcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIF9fYXJyYXkgPSBuZXcgQXJyYXkoKTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAgX2Jhc2VQdXNoLmNhbGwoX19hcnJheSwgdmFsdWVzW2ldKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgX19hcnJheSA9IFtdO1xuICB9XG5cbiAgY29uc3QgaW50ZXJuYWxzID0ge1xuICAgIFthcnJheUF0b21pY3NTeW1ib2xdOiB7fSxcbiAgICBbYXJyYXlBdG9taWNzQmFja3VwU3ltYm9sXTogdm9pZCAwLFxuICAgIFthcnJheVBhdGhTeW1ib2xdOiBwYXRoLFxuICAgIFthcnJheVNjaGVtYVN5bWJvbF06IHNjaGVtYXR5cGUsXG4gICAgW2FycmF5UGFyZW50U3ltYm9sXTogdm9pZCAwLFxuICAgIGlzTW9uZ29vc2VBcnJheTogdHJ1ZSxcbiAgICBpc01vbmdvb3NlQXJyYXlQcm94eTogdHJ1ZSxcbiAgICBfX2FycmF5OiBfX2FycmF5XG4gIH07XG5cbiAgaWYgKHZhbHVlcyAmJiB2YWx1ZXNbYXJyYXlBdG9taWNzU3ltYm9sXSAhPSBudWxsKSB7XG4gICAgaW50ZXJuYWxzW2FycmF5QXRvbWljc1N5bWJvbF0gPSB2YWx1ZXNbYXJyYXlBdG9taWNzU3ltYm9sXTtcbiAgfVxuXG4gIC8vIEJlY2F1c2UgZG9jIGNvbWVzIGZyb20gdGhlIGNvbnRleHQgb2YgYW5vdGhlciBmdW5jdGlvbiwgZG9jID09PSBnbG9iYWxcbiAgLy8gY2FuIGhhcHBlbiBpZiB0aGVyZSB3YXMgYSBudWxsIHNvbWV3aGVyZSB1cCB0aGUgY2hhaW4gKHNlZSAjMzAyMClcbiAgLy8gUkIgSnVuIDE3LCAyMDE1IHVwZGF0ZWQgdG8gY2hlY2sgZm9yIHByZXNlbmNlIG9mIGV4cGVjdGVkIHBhdGhzIGluc3RlYWRcbiAgLy8gdG8gbWFrZSBtb3JlIHByb29mIGFnYWluc3QgdW51c3VhbCBub2RlIGVudmlyb25tZW50c1xuICBpZiAoZG9jICE9IG51bGwgJiYgZG9jIGluc3RhbmNlb2YgRG9jdW1lbnQpIHtcbiAgICBpbnRlcm5hbHNbYXJyYXlQYXJlbnRTeW1ib2xdID0gZG9jO1xuICAgIGludGVybmFsc1thcnJheVNjaGVtYVN5bWJvbF0gPSBzY2hlbWF0eXBlIHx8IGRvYy5zY2hlbWEucGF0aChwYXRoKTtcbiAgfVxuXG4gIGNvbnN0IHByb3h5ID0gbmV3IFByb3h5KF9fYXJyYXksIHtcbiAgICBnZXQ6IGZ1bmN0aW9uKHRhcmdldCwgcHJvcCkge1xuICAgICAgaWYgKGludGVybmFscy5oYXNPd25Qcm9wZXJ0eShwcm9wKSkge1xuICAgICAgICByZXR1cm4gaW50ZXJuYWxzW3Byb3BdO1xuICAgICAgfVxuICAgICAgaWYgKG1vbmdvb3NlQXJyYXlNZXRob2RzLmhhc093blByb3BlcnR5KHByb3ApKSB7XG4gICAgICAgIHJldHVybiBtb25nb29zZUFycmF5TWV0aG9kc1twcm9wXTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgcHJvcCA9PT0gJ3N0cmluZycgJiYgbnVtYmVyUkUudGVzdChwcm9wKSAmJiBzY2hlbWF0eXBlPy4kZW1iZWRkZWRTY2hlbWFUeXBlICE9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHNjaGVtYXR5cGUuJGVtYmVkZGVkU2NoZW1hVHlwZS5hcHBseUdldHRlcnMoX19hcnJheVtwcm9wXSwgZG9jKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIF9fYXJyYXlbcHJvcF07XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uKHRhcmdldCwgcHJvcCwgdmFsdWUpIHtcbiAgICAgIGlmICh0eXBlb2YgcHJvcCA9PT0gJ3N0cmluZycgJiYgbnVtYmVyUkUudGVzdChwcm9wKSkge1xuICAgICAgICBtb25nb29zZUFycmF5TWV0aG9kcy5zZXQuY2FsbChwcm94eSwgcHJvcCwgdmFsdWUsIGZhbHNlKTtcbiAgICAgIH0gZWxzZSBpZiAoaW50ZXJuYWxzLmhhc093blByb3BlcnR5KHByb3ApKSB7XG4gICAgICAgIGludGVybmFsc1twcm9wXSA9IHZhbHVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgX19hcnJheVtwcm9wXSA9IHZhbHVlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBwcm94eTtcbn1cblxuLyohXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBNb25nb29zZUFycmF5O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../server/node_modules/mongoose/lib/types/array/index.js\n");

/***/ }),

/***/ "../server/node_modules/mongoose/lib/types/array/isMongooseArray.js":
/*!**************************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/types/array/isMongooseArray.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\nexports.isMongooseArray = function(mongooseArray) {\n  return Array.isArray(mongooseArray) && mongooseArray.isMongooseArray;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvdHlwZXMvYXJyYXkvaXNNb25nb29zZUFycmF5LmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLHVCQUF1QjtBQUN2QjtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2xpZW50Ly4uL3NlcnZlci9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL3R5cGVzL2FycmF5L2lzTW9uZ29vc2VBcnJheS5qcz9lNjUyIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5pc01vbmdvb3NlQXJyYXkgPSBmdW5jdGlvbihtb25nb29zZUFycmF5KSB7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KG1vbmdvb3NlQXJyYXkpICYmIG1vbmdvb3NlQXJyYXkuaXNNb25nb29zZUFycmF5O1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../server/node_modules/mongoose/lib/types/array/isMongooseArray.js\n");

/***/ }),

/***/ "../server/node_modules/mongoose/lib/types/array/methods/index.js":
/*!************************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/types/array/methods/index.js ***!
  \************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst Document = __webpack_require__(/*! ../../../document */ \"../server/node_modules/mongoose/lib/document.js\");\nconst ArraySubdocument = __webpack_require__(/*! ../../arraySubdocument */ \"../server/node_modules/mongoose/lib/types/arraySubdocument.js\");\nconst MongooseError = __webpack_require__(/*! ../../../error/mongooseError */ \"../server/node_modules/mongoose/lib/error/mongooseError.js\");\nconst cleanModifiedSubpaths = __webpack_require__(/*! ../../../helpers/document/cleanModifiedSubpaths */ \"../server/node_modules/mongoose/lib/helpers/document/cleanModifiedSubpaths.js\");\nconst clone = __webpack_require__(/*! ../../../helpers/clone */ \"../server/node_modules/mongoose/lib/helpers/clone.js\");\nconst internalToObjectOptions = (__webpack_require__(/*! ../../../options */ \"../server/node_modules/mongoose/lib/options.js\").internalToObjectOptions);\nconst mpath = __webpack_require__(/*! mpath */ \"../server/node_modules/mpath/index.js\");\nconst utils = __webpack_require__(/*! ../../../utils */ \"../server/node_modules/mongoose/lib/utils.js\");\nconst isBsonType = __webpack_require__(/*! ../../../helpers/isBsonType */ \"../server/node_modules/mongoose/lib/helpers/isBsonType.js\");\n\nconst arrayAtomicsSymbol = (__webpack_require__(/*! ../../../helpers/symbols */ \"../server/node_modules/mongoose/lib/helpers/symbols.js\").arrayAtomicsSymbol);\nconst arrayParentSymbol = (__webpack_require__(/*! ../../../helpers/symbols */ \"../server/node_modules/mongoose/lib/helpers/symbols.js\").arrayParentSymbol);\nconst arrayPathSymbol = (__webpack_require__(/*! ../../../helpers/symbols */ \"../server/node_modules/mongoose/lib/helpers/symbols.js\").arrayPathSymbol);\nconst arraySchemaSymbol = (__webpack_require__(/*! ../../../helpers/symbols */ \"../server/node_modules/mongoose/lib/helpers/symbols.js\").arraySchemaSymbol);\nconst populateModelSymbol = (__webpack_require__(/*! ../../../helpers/symbols */ \"../server/node_modules/mongoose/lib/helpers/symbols.js\").populateModelSymbol);\nconst slicedSymbol = Symbol('mongoose#Array#sliced');\n\nconst _basePush = Array.prototype.push;\n\n/*!\n * ignore\n */\n\nconst methods = {\n  /**\n   * Depopulates stored atomic operation values as necessary for direct insertion to MongoDB.\n   *\n   * If no atomics exist, we return all array values after conversion.\n   *\n   * @return {Array}\n   * @method $__getAtomics\n   * @memberOf MongooseArray\n   * @instance\n   * @api private\n   */\n\n  $__getAtomics() {\n    const ret = [];\n    const keys = Object.keys(this[arrayAtomicsSymbol] || {});\n    let i = keys.length;\n\n    const opts = Object.assign({}, internalToObjectOptions, { _isNested: true });\n\n    if (i === 0) {\n      ret[0] = ['$set', this.toObject(opts)];\n      return ret;\n    }\n\n    while (i--) {\n      const op = keys[i];\n      let val = this[arrayAtomicsSymbol][op];\n\n      // the atomic values which are arrays are not MongooseArrays. we\n      // need to convert their elements as if they were MongooseArrays\n      // to handle populated arrays versus DocumentArrays properly.\n      if (utils.isMongooseObject(val)) {\n        val = val.toObject(opts);\n      } else if (Array.isArray(val)) {\n        val = this.toObject.call(val, opts);\n      } else if (val != null && Array.isArray(val.$each)) {\n        val.$each = this.toObject.call(val.$each, opts);\n      } else if (val != null && typeof val.valueOf === 'function') {\n        val = val.valueOf();\n      }\n\n      if (op === '$addToSet') {\n        val = { $each: val };\n      }\n\n      ret.push([op, val]);\n    }\n\n    return ret;\n  },\n\n  /*!\n   * ignore\n   */\n\n  $atomics() {\n    return this[arrayAtomicsSymbol];\n  },\n\n  /*!\n   * ignore\n   */\n\n  $parent() {\n    return this[arrayParentSymbol];\n  },\n\n  /*!\n   * ignore\n   */\n\n  $path() {\n    return this[arrayPathSymbol];\n  },\n\n  /**\n   * Atomically shifts the array at most one time per document `save()`.\n   *\n   * #### Note:\n   *\n   * _Calling this multiple times on an array before saving sends the same command as calling it once._\n   * _This update is implemented using the MongoDB [$pop](https://www.mongodb.com/docs/manual/reference/operator/update/pop/) method which enforces this restriction._\n   *\n   *      doc.array = [1,2,3];\n   *\n   *      const shifted = doc.array.$shift();\n   *      console.log(shifted); // 1\n   *      console.log(doc.array); // [2,3]\n   *\n   *      // no affect\n   *      shifted = doc.array.$shift();\n   *      console.log(doc.array); // [2,3]\n   *\n   *      doc.save(function (err) {\n   *        if (err) return handleError(err);\n   *\n   *        // we saved, now $shift works again\n   *        shifted = doc.array.$shift();\n   *        console.log(shifted ); // 2\n   *        console.log(doc.array); // [3]\n   *      })\n   *\n   * @api public\n   * @memberOf MongooseArray\n   * @instance\n   * @method $shift\n   * @see mongodb https://www.mongodb.com/docs/manual/reference/operator/update/pop/\n   */\n\n  $shift() {\n    this._registerAtomic('$pop', -1);\n    this._markModified();\n\n    // only allow shifting once\n    const __array = this.__array;\n    if (__array._shifted) {\n      return;\n    }\n    __array._shifted = true;\n\n    return [].shift.call(__array);\n  },\n\n  /**\n   * Pops the array atomically at most one time per document `save()`.\n   *\n   * #### NOTE:\n   *\n   * _Calling this multiple times on an array before saving sends the same command as calling it once._\n   * _This update is implemented using the MongoDB [$pop](https://www.mongodb.com/docs/manual/reference/operator/update/pop/) method which enforces this restriction._\n   *\n   *      doc.array = [1,2,3];\n   *\n   *      const popped = doc.array.$pop();\n   *      console.log(popped); // 3\n   *      console.log(doc.array); // [1,2]\n   *\n   *      // no affect\n   *      popped = doc.array.$pop();\n   *      console.log(doc.array); // [1,2]\n   *\n   *      doc.save(function (err) {\n   *        if (err) return handleError(err);\n   *\n   *        // we saved, now $pop works again\n   *        popped = doc.array.$pop();\n   *        console.log(popped); // 2\n   *        console.log(doc.array); // [1]\n   *      })\n   *\n   * @api public\n   * @method $pop\n   * @memberOf MongooseArray\n   * @instance\n   * @see mongodb https://www.mongodb.com/docs/manual/reference/operator/update/pop/\n   * @method $pop\n   * @memberOf MongooseArray\n   */\n\n  $pop() {\n    this._registerAtomic('$pop', 1);\n    this._markModified();\n\n    // only allow popping once\n    if (this._popped) {\n      return;\n    }\n    this._popped = true;\n\n    return [].pop.call(this);\n  },\n\n  /*!\n   * ignore\n   */\n\n  $schema() {\n    return this[arraySchemaSymbol];\n  },\n\n  /**\n   * Casts a member based on this arrays schema.\n   *\n   * @param {any} value\n   * @return value the casted value\n   * @method _cast\n   * @api private\n   * @memberOf MongooseArray\n   */\n\n  _cast(value) {\n    let populated = false;\n    let Model;\n\n    const parent = this[arrayParentSymbol];\n    if (parent) {\n      populated = parent.$populated(this[arrayPathSymbol], true);\n    }\n\n    if (populated && value !== null && value !== undefined) {\n      // cast to the populated Models schema\n      Model = populated.options[populateModelSymbol];\n      if (Model == null) {\n        throw new MongooseError('No populated model found for path `' + this[arrayPathSymbol] + '`. This is likely a bug in Mongoose, please report an issue on github.com/Automattic/mongoose.');\n      }\n\n      // only objects are permitted so we can safely assume that\n      // non-objects are to be interpreted as _id\n      if (Buffer.isBuffer(value) ||\n          isBsonType(value, 'ObjectId') || !utils.isObject(value)) {\n        value = { _id: value };\n      }\n\n      // gh-2399\n      // we should cast model only when it's not a discriminator\n      const isDisc = value.schema && value.schema.discriminatorMapping &&\n          value.schema.discriminatorMapping.key !== undefined;\n      if (!isDisc) {\n        value = new Model(value);\n      }\n      return this[arraySchemaSymbol].caster.applySetters(value, parent, true);\n    }\n\n    return this[arraySchemaSymbol].caster.applySetters(value, parent, false);\n  },\n\n  /**\n   * Internal helper for .map()\n   *\n   * @api private\n   * @return {Number}\n   * @method _mapCast\n   * @memberOf MongooseArray\n   */\n\n  _mapCast(val, index) {\n    return this._cast(val, this.length + index);\n  },\n\n  /**\n   * Marks this array as modified.\n   *\n   * If it bubbles up from an embedded document change, then it takes the following arguments (otherwise, takes 0 arguments)\n   *\n   * @param {ArraySubdocument} subdoc the embedded doc that invoked this method on the Array\n   * @param {String} embeddedPath the path which changed in the subdoc\n   * @method _markModified\n   * @api private\n   * @memberOf MongooseArray\n   */\n\n  _markModified(elem) {\n    const parent = this[arrayParentSymbol];\n    let dirtyPath;\n\n    if (parent) {\n      dirtyPath = this[arrayPathSymbol];\n\n      if (arguments.length) {\n        dirtyPath = dirtyPath + '.' + elem;\n      }\n\n      if (dirtyPath != null && dirtyPath.endsWith('.$')) {\n        return this;\n      }\n\n      parent.markModified(dirtyPath, arguments.length !== 0 ? elem : parent);\n    }\n\n    return this;\n  },\n\n  /**\n   * Register an atomic operation with the parent.\n   *\n   * @param {Array} op operation\n   * @param {any} val\n   * @method _registerAtomic\n   * @api private\n   * @memberOf MongooseArray\n   */\n\n  _registerAtomic(op, val) {\n    if (this[slicedSymbol]) {\n      return;\n    }\n    if (op === '$set') {\n      // $set takes precedence over all other ops.\n      // mark entire array modified.\n      this[arrayAtomicsSymbol] = { $set: val };\n      cleanModifiedSubpaths(this[arrayParentSymbol], this[arrayPathSymbol]);\n      this._markModified();\n      return this;\n    }\n\n    const atomics = this[arrayAtomicsSymbol];\n\n    // reset pop/shift after save\n    if (op === '$pop' && !('$pop' in atomics)) {\n      const _this = this;\n      this[arrayParentSymbol].once('save', function() {\n        _this._popped = _this._shifted = null;\n      });\n    }\n\n    // check for impossible $atomic combos (Mongo denies more than one\n    // $atomic op on a single path\n    if (atomics.$set || Object.keys(atomics).length && !(op in atomics)) {\n      // a different op was previously registered.\n      // save the entire thing.\n      this[arrayAtomicsSymbol] = { $set: this };\n      return this;\n    }\n\n    let selector;\n\n    if (op === '$pullAll' || op === '$addToSet') {\n      atomics[op] || (atomics[op] = []);\n      atomics[op] = atomics[op].concat(val);\n    } else if (op === '$pullDocs') {\n      const pullOp = atomics['$pull'] || (atomics['$pull'] = {});\n      if (val[0] instanceof ArraySubdocument) {\n        selector = pullOp['$or'] || (pullOp['$or'] = []);\n        Array.prototype.push.apply(selector, val.map(v => {\n          return v.toObject({\n            transform: (doc, ret) => {\n              if (v == null || v.$__ == null) {\n                return ret;\n              }\n\n              Object.keys(v.$__.activePaths.getStatePaths('default')).forEach(path => {\n                mpath.unset(path, ret);\n\n                _minimizePath(ret, path);\n              });\n\n              return ret;\n            },\n            virtuals: false\n          });\n        }));\n      } else {\n        selector = pullOp['_id'] || (pullOp['_id'] = { $in: [] });\n        selector['$in'] = selector['$in'].concat(val);\n      }\n    } else if (op === '$push') {\n      atomics.$push = atomics.$push || { $each: [] };\n      if (val != null && utils.hasUserDefinedProperty(val, '$each')) {\n        atomics.$push = val;\n      } else {\n        if (val.length === 1) {\n          atomics.$push.$each.push(val[0]);\n        } else if (val.length < 10000) {\n          atomics.$push.$each.push(...val);\n        } else {\n          for (const v of val) {\n            atomics.$push.$each.push(v);\n          }\n        }\n      }\n    } else {\n      atomics[op] = val;\n    }\n\n    return this;\n  },\n\n  /**\n   * Adds values to the array if not already present.\n   *\n   * #### Example:\n   *\n   *     console.log(doc.array) // [2,3,4]\n   *     const added = doc.array.addToSet(4,5);\n   *     console.log(doc.array) // [2,3,4,5]\n   *     console.log(added)     // [5]\n   *\n   * @param {...any} [args]\n   * @return {Array} the values that were added\n   * @memberOf MongooseArray\n   * @api public\n   * @method addToSet\n   */\n\n  addToSet() {\n    _checkManualPopulation(this, arguments);\n\n    const values = [].map.call(arguments, this._mapCast, this);\n    const added = [];\n    let type = '';\n    if (values[0] instanceof ArraySubdocument) {\n      type = 'doc';\n    } else if (values[0] instanceof Date) {\n      type = 'date';\n    } else if (isBsonType(values[0], 'ObjectId')) {\n      type = 'ObjectId';\n    }\n\n    const rawValues = utils.isMongooseArray(values) ? values.__array : values;\n    const rawArray = utils.isMongooseArray(this) ? this.__array : this;\n\n    rawValues.forEach(function(v) {\n      let found;\n      const val = +v;\n      switch (type) {\n        case 'doc':\n          found = this.some(function(doc) {\n            return doc.equals(v);\n          });\n          break;\n        case 'date':\n          found = this.some(function(d) {\n            return +d === val;\n          });\n          break;\n        case 'ObjectId':\n          found = this.find(o => o.toString() === v.toString());\n          break;\n        default:\n          found = ~this.indexOf(v);\n          break;\n      }\n\n      if (!found) {\n        this._markModified();\n        rawArray.push(v);\n        this._registerAtomic('$addToSet', v);\n        [].push.call(added, v);\n      }\n    }, this);\n\n    return added;\n  },\n\n  /**\n   * Returns the number of pending atomic operations to send to the db for this array.\n   *\n   * @api private\n   * @return {Number}\n   * @method hasAtomics\n   * @memberOf MongooseArray\n   */\n\n  hasAtomics() {\n    if (!utils.isPOJO(this[arrayAtomicsSymbol])) {\n      return 0;\n    }\n\n    return Object.keys(this[arrayAtomicsSymbol]).length;\n  },\n\n  /**\n   * Return whether or not the `obj` is included in the array.\n   *\n   * @param {Object} obj the item to check\n   * @param {Number} fromIndex\n   * @return {Boolean}\n   * @api public\n   * @method includes\n   * @memberOf MongooseArray\n   */\n\n  includes(obj, fromIndex) {\n    const ret = this.indexOf(obj, fromIndex);\n    return ret !== -1;\n  },\n\n  /**\n   * Return the index of `obj` or `-1` if not found.\n   *\n   * @param {Object} obj the item to look for\n   * @param {Number} fromIndex\n   * @return {Number}\n   * @api public\n   * @method indexOf\n   * @memberOf MongooseArray\n   */\n\n  indexOf(obj, fromIndex) {\n    if (isBsonType(obj, 'ObjectId')) {\n      obj = obj.toString();\n    }\n\n    fromIndex = fromIndex == null ? 0 : fromIndex;\n    const len = this.length;\n    for (let i = fromIndex; i < len; ++i) {\n      if (obj == this[i]) {\n        return i;\n      }\n    }\n    return -1;\n  },\n\n  /**\n   * Helper for console.log\n   *\n   * @api public\n   * @method inspect\n   * @memberOf MongooseArray\n   */\n\n  inspect() {\n    return JSON.stringify(this);\n  },\n\n  /**\n   * Pushes items to the array non-atomically.\n   *\n   * #### Note:\n   *\n   * _marks the entire array as modified, which if saved, will store it as a `$set` operation, potentially overwritting any changes that happen between when you retrieved the object and when you save it._\n   *\n   * @param {...any} [args]\n   * @api public\n   * @method nonAtomicPush\n   * @memberOf MongooseArray\n   */\n\n  nonAtomicPush() {\n    const values = [].map.call(arguments, this._mapCast, this);\n    this._markModified();\n    const ret = [].push.apply(this, values);\n    this._registerAtomic('$set', this);\n    return ret;\n  },\n\n  /**\n   * Wraps [`Array#pop`](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/pop) with proper change tracking.\n   *\n   * #### Note:\n   *\n   * _marks the entire array as modified which will pass the entire thing to $set potentially overwriting any changes that happen between when you retrieved the object and when you save it._\n   *\n   * @see MongooseArray#$pop https://mongoosejs.com/docs/api/array.html#MongooseArray.prototype.$pop()\n   * @api public\n   * @method pop\n   * @memberOf MongooseArray\n   */\n\n  pop() {\n    this._markModified();\n    const ret = [].pop.call(this);\n    this._registerAtomic('$set', this);\n    return ret;\n  },\n\n  /**\n   * Pulls items from the array atomically. Equality is determined by casting\n   * the provided value to an embedded document and comparing using\n   * [the `Document.equals()` function.](https://mongoosejs.com/docs/api/document.html#Document.prototype.equals())\n   *\n   * #### Example:\n   *\n   *     doc.array.pull(ObjectId)\n   *     doc.array.pull({ _id: 'someId' })\n   *     doc.array.pull(36)\n   *     doc.array.pull('tag 1', 'tag 2')\n   *\n   * To remove a document from a subdocument array we may pass an object with a matching `_id`.\n   *\n   *     doc.subdocs.push({ _id: 4815162342 })\n   *     doc.subdocs.pull({ _id: 4815162342 }) // removed\n   *\n   * Or we may passing the _id directly and let mongoose take care of it.\n   *\n   *     doc.subdocs.push({ _id: 4815162342 })\n   *     doc.subdocs.pull(4815162342); // works\n   *\n   * The first pull call will result in a atomic operation on the database, if pull is called repeatedly without saving the document, a $set operation is used on the complete array instead, overwriting possible changes that happened on the database in the meantime.\n   *\n   * @param {...any} [args]\n   * @see mongodb https://www.mongodb.com/docs/manual/reference/operator/update/pull/\n   * @api public\n   * @method pull\n   * @memberOf MongooseArray\n   */\n\n  pull() {\n    const values = [].map.call(arguments, (v, i) => this._cast(v, i, { defaults: false }), this);\n    const cur = this[arrayParentSymbol].get(this[arrayPathSymbol]);\n    let i = cur.length;\n    let mem;\n    this._markModified();\n\n    while (i--) {\n      mem = cur[i];\n      if (mem instanceof Document) {\n        const some = values.some(function(v) {\n          return mem.equals(v);\n        });\n        if (some) {\n          [].splice.call(cur, i, 1);\n        }\n      } else if (~cur.indexOf.call(values, mem)) {\n        [].splice.call(cur, i, 1);\n      }\n    }\n\n    if (values[0] instanceof ArraySubdocument) {\n      this._registerAtomic('$pullDocs', values.map(function(v) {\n        const _id = v.$__getValue('_id');\n        if (_id === undefined || v.$isDefault('_id')) {\n          return v;\n        }\n        return _id;\n      }));\n    } else {\n      this._registerAtomic('$pullAll', values);\n    }\n\n\n    // Might have modified child paths and then pulled, like\n    // `doc.children[1].name = 'test';` followed by\n    // `doc.children.remove(doc.children[0]);`. In this case we fall back\n    // to a `$set` on the whole array. See #3511\n    if (cleanModifiedSubpaths(this[arrayParentSymbol], this[arrayPathSymbol]) > 0) {\n      this._registerAtomic('$set', this);\n    }\n\n    return this;\n  },\n\n  /**\n   * Wraps [`Array#push`](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/push) with proper change tracking.\n   *\n   * #### Example:\n   *\n   *     const schema = Schema({ nums: [Number] });\n   *     const Model = mongoose.model('Test', schema);\n   *\n   *     const doc = await Model.create({ nums: [3, 4] });\n   *     doc.nums.push(5); // Add 5 to the end of the array\n   *     await doc.save();\n   *\n   *     // You can also pass an object with `$each` as the\n   *     // first parameter to use MongoDB's `$position`\n   *     doc.nums.push({\n   *       $each: [1, 2],\n   *       $position: 0\n   *     });\n   *     doc.nums; // [1, 2, 3, 4, 5]\n   *\n   * @param {...Object} [args]\n   * @api public\n   * @method push\n   * @memberOf MongooseArray\n   */\n\n  push() {\n    let values = arguments;\n    let atomic = values;\n    const isOverwrite = values[0] != null &&\n      utils.hasUserDefinedProperty(values[0], '$each');\n    const arr = utils.isMongooseArray(this) ? this.__array : this;\n    if (isOverwrite) {\n      atomic = values[0];\n      values = values[0].$each;\n    }\n\n    if (this[arraySchemaSymbol] == null) {\n      return _basePush.apply(this, values);\n    }\n\n    _checkManualPopulation(this, values);\n\n    values = [].map.call(values, this._mapCast, this);\n    let ret;\n    const atomics = this[arrayAtomicsSymbol];\n    this._markModified();\n    if (isOverwrite) {\n      atomic.$each = values;\n\n      if ((atomics.$push && atomics.$push.$each && atomics.$push.$each.length || 0) !== 0 &&\n          atomics.$push.$position != atomic.$position) {\n        throw new MongooseError('Cannot call `Array#push()` multiple times ' +\n          'with different `$position`');\n      }\n\n      if (atomic.$position != null) {\n        [].splice.apply(arr, [atomic.$position, 0].concat(values));\n        ret = this.length;\n      } else {\n        ret = [].push.apply(arr, values);\n      }\n    } else {\n      if ((atomics.$push && atomics.$push.$each && atomics.$push.$each.length || 0) !== 0 &&\n          atomics.$push.$position != null) {\n        throw new MongooseError('Cannot call `Array#push()` multiple times ' +\n          'with different `$position`');\n      }\n      atomic = values;\n      ret = _basePush.apply(arr, values);\n    }\n\n    this._registerAtomic('$push', atomic);\n    return ret;\n  },\n\n  /**\n   * Alias of [pull](https://mongoosejs.com/docs/api/array.html#MongooseArray.prototype.pull())\n   *\n   * @see MongooseArray#pull https://mongoosejs.com/docs/api/array.html#MongooseArray.prototype.pull()\n   * @see mongodb https://www.mongodb.com/docs/manual/reference/operator/update/pull/\n   * @api public\n   * @memberOf MongooseArray\n   * @instance\n   * @method remove\n   */\n\n  remove() {\n    return this.pull.apply(this, arguments);\n  },\n\n  /**\n   * Sets the casted `val` at index `i` and marks the array modified.\n   *\n   * #### Example:\n   *\n   *     // given documents based on the following\n   *     const Doc = mongoose.model('Doc', new Schema({ array: [Number] }));\n   *\n   *     const doc = new Doc({ array: [2,3,4] })\n   *\n   *     console.log(doc.array) // [2,3,4]\n   *\n   *     doc.array.set(1,\"5\");\n   *     console.log(doc.array); // [2,5,4] // properly cast to number\n   *     doc.save() // the change is saved\n   *\n   *     // VS not using array#set\n   *     doc.array[1] = \"5\";\n   *     console.log(doc.array); // [2,\"5\",4] // no casting\n   *     doc.save() // change is not saved\n   *\n   * @return {Array} this\n   * @api public\n   * @method set\n   * @memberOf MongooseArray\n   */\n\n  set(i, val, skipModified) {\n    const arr = this.__array;\n    if (skipModified) {\n      arr[i] = val;\n      return this;\n    }\n    const value = methods._cast.call(this, val, i);\n    methods._markModified.call(this, i);\n    arr[i] = value;\n    return this;\n  },\n\n  /**\n   * Wraps [`Array#shift`](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/unshift) with proper change tracking.\n   *\n   * #### Example:\n   *\n   *     doc.array = [2,3];\n   *     const res = doc.array.shift();\n   *     console.log(res) // 2\n   *     console.log(doc.array) // [3]\n   *\n   * #### Note:\n   *\n   * _marks the entire array as modified, which if saved, will store it as a `$set` operation, potentially overwritting any changes that happen between when you retrieved the object and when you save it._\n   *\n   * @api public\n   * @method shift\n   * @memberOf MongooseArray\n   */\n\n  shift() {\n    const arr = utils.isMongooseArray(this) ? this.__array : this;\n    this._markModified();\n    const ret = [].shift.call(arr);\n    this._registerAtomic('$set', this);\n    return ret;\n  },\n\n  /**\n   * Wraps [`Array#sort`](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/sort) with proper change tracking.\n   *\n   * #### Note:\n   *\n   * _marks the entire array as modified, which if saved, will store it as a `$set` operation, potentially overwritting any changes that happen between when you retrieved the object and when you save it._\n   *\n   * @api public\n   * @method sort\n   * @memberOf MongooseArray\n   * @see MasteringJS: Array sort https://masteringjs.io/tutorials/fundamentals/array-sort\n   */\n\n  sort() {\n    const arr = utils.isMongooseArray(this) ? this.__array : this;\n    const ret = [].sort.apply(arr, arguments);\n    this._registerAtomic('$set', this);\n    return ret;\n  },\n\n  /**\n   * Wraps [`Array#splice`](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/splice) with proper change tracking and casting.\n   *\n   * #### Note:\n   *\n   * _marks the entire array as modified, which if saved, will store it as a `$set` operation, potentially overwritting any changes that happen between when you retrieved the object and when you save it._\n   *\n   * @api public\n   * @method splice\n   * @memberOf MongooseArray\n   * @see MasteringJS: Array splice https://masteringjs.io/tutorials/fundamentals/array-splice\n   */\n\n  splice() {\n    let ret;\n    const arr = utils.isMongooseArray(this) ? this.__array : this;\n\n    this._markModified();\n    _checkManualPopulation(this, Array.prototype.slice.call(arguments, 2));\n\n    if (arguments.length) {\n      let vals;\n      if (this[arraySchemaSymbol] == null) {\n        vals = arguments;\n      } else {\n        vals = [];\n        for (let i = 0; i < arguments.length; ++i) {\n          vals[i] = i < 2 ?\n            arguments[i] :\n            this._cast(arguments[i], arguments[0] + (i - 2));\n        }\n      }\n\n      ret = [].splice.apply(arr, vals);\n      this._registerAtomic('$set', this);\n    }\n\n    return ret;\n  },\n\n  /*!\n   * ignore\n   */\n\n  toBSON() {\n    return this.toObject(internalToObjectOptions);\n  },\n\n  /**\n   * Returns a native js Array.\n   *\n   * @param {Object} options\n   * @return {Array}\n   * @api public\n   * @method toObject\n   * @memberOf MongooseArray\n   */\n\n  toObject(options) {\n    const arr = utils.isMongooseArray(this) ? this.__array : this;\n    if (options && options.depopulate) {\n      options = clone(options);\n      options._isNested = true;\n      // Ensure return value is a vanilla array, because in Node.js 6+ `map()`\n      // is smart enough to use the inherited array's constructor.\n      return [].concat(arr).map(function(doc) {\n        return doc instanceof Document\n          ? doc.toObject(options)\n          : doc;\n      });\n    }\n\n    return [].concat(arr);\n  },\n\n  $toObject() {\n    return this.constructor.prototype.toObject.apply(this, arguments);\n  },\n  /**\n   * Wraps [`Array#unshift`](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/unshift) with proper change tracking.\n   *\n   * #### Note:\n   *\n   * _marks the entire array as modified, which if saved, will store it as a `$set` operation, potentially overwriting any changes that happen between when you retrieved the object and when you save it._\n   *\n   * @api public\n   * @method unshift\n   * @memberOf MongooseArray\n   */\n\n  unshift() {\n    _checkManualPopulation(this, arguments);\n\n    let values;\n    if (this[arraySchemaSymbol] == null) {\n      values = arguments;\n    } else {\n      values = [].map.call(arguments, this._cast, this);\n    }\n\n    const arr = utils.isMongooseArray(this) ? this.__array : this;\n    this._markModified();\n    [].unshift.apply(arr, values);\n    this._registerAtomic('$set', this);\n    return this.length;\n  }\n};\n\n/*!\n * ignore\n */\n\nfunction _isAllSubdocs(docs, ref) {\n  if (!ref) {\n    return false;\n  }\n\n  for (const arg of docs) {\n    if (arg == null) {\n      return false;\n    }\n    const model = arg.constructor;\n    if (!(arg instanceof Document) ||\n      (model.modelName !== ref && model.baseModelName !== ref)) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n/*!\n * Minimize _just_ empty objects along the path chain specified\n * by `parts`, ignoring all other paths. Useful in cases where\n * you want to minimize after unsetting a path.\n *\n * #### Example:\n *\n *     const obj = { foo: { bar: { baz: {} } }, a: {} };\n *     _minimizePath(obj, 'foo.bar.baz');\n *     obj; // { a: {} }\n */\n\nfunction _minimizePath(obj, parts, i) {\n  if (typeof parts === 'string') {\n    if (parts.indexOf('.') === -1) {\n      return;\n    }\n\n    parts = mpath.stringToParts(parts);\n  }\n  i = i || 0;\n  if (i >= parts.length) {\n    return;\n  }\n  if (obj == null || typeof obj !== 'object') {\n    return;\n  }\n\n  _minimizePath(obj[parts[0]], parts, i + 1);\n  if (obj[parts[0]] != null && typeof obj[parts[0]] === 'object' && Object.keys(obj[parts[0]]).length === 0) {\n    delete obj[parts[0]];\n  }\n}\n\n/*!\n * ignore\n */\n\nfunction _checkManualPopulation(arr, docs) {\n  const ref = arr == null ?\n    null :\n    arr[arraySchemaSymbol] && arr[arraySchemaSymbol].caster && arr[arraySchemaSymbol].caster.options && arr[arraySchemaSymbol].caster.options.ref || null;\n  if (arr.length === 0 &&\n      docs.length !== 0) {\n    if (_isAllSubdocs(docs, ref)) {\n      arr[arrayParentSymbol].$populated(arr[arrayPathSymbol], [], {\n        [populateModelSymbol]: docs[0].constructor\n      });\n    }\n  }\n}\n\nconst returnVanillaArrayMethods = [\n  'filter',\n  'flat',\n  'flatMap',\n  'map',\n  'slice'\n];\nfor (const method of returnVanillaArrayMethods) {\n  if (Array.prototype[method] == null) {\n    continue;\n  }\n\n  methods[method] = function() {\n    const _arr = utils.isMongooseArray(this) ? this.__array : this;\n    const arr = [].concat(_arr);\n\n    return arr[method].apply(arr, arguments);\n  };\n}\n\nmodule.exports = methods;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvdHlwZXMvYXJyYXkvbWV0aG9kcy9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixpQkFBaUIsbUJBQU8sQ0FBQywwRUFBbUI7QUFDNUMseUJBQXlCLG1CQUFPLENBQUMsNkZBQXdCO0FBQ3pELHNCQUFzQixtQkFBTyxDQUFDLGdHQUE4QjtBQUM1RCw4QkFBOEIsbUJBQU8sQ0FBQyxzSUFBaUQ7QUFDdkYsY0FBYyxtQkFBTyxDQUFDLG9GQUF3QjtBQUM5QyxnQ0FBZ0MsdUhBQW1EO0FBQ25GLGNBQWMsbUJBQU8sQ0FBQyxvREFBTztBQUM3QixjQUFjLG1CQUFPLENBQUMsb0VBQWdCO0FBQ3RDLG1CQUFtQixtQkFBTyxDQUFDLDhGQUE2Qjs7QUFFeEQsMkJBQTJCLGtJQUFzRDtBQUNqRiwwQkFBMEIsaUlBQXFEO0FBQy9FLHdCQUF3QiwrSEFBbUQ7QUFDM0UsMEJBQTBCLGlJQUFxRDtBQUMvRSw0QkFBNEIsbUlBQXVEO0FBQ25GOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMkRBQTJEO0FBQzNEOztBQUVBLGlDQUFpQyw2QkFBNkIsaUJBQWlCOztBQUUvRTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0EsZ0JBQWdCO0FBQ2hCOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FB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OztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsT0FBTyxPQUFPLFdBQVc7QUFDOUM7QUFDQSxZQUFZLEtBQUs7QUFDakI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbGllbnQvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvdHlwZXMvYXJyYXkvbWV0aG9kcy9pbmRleC5qcz8xN2U3Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3QgRG9jdW1lbnQgPSByZXF1aXJlKCcuLi8uLi8uLi9kb2N1bWVudCcpO1xuY29uc3QgQXJyYXlTdWJkb2N1bWVudCA9IHJlcXVpcmUoJy4uLy4uL2FycmF5U3ViZG9jdW1lbnQnKTtcbmNvbnN0IE1vbmdvb3NlRXJyb3IgPSByZXF1aXJlKCcuLi8uLi8uLi9lcnJvci9tb25nb29zZUVycm9yJyk7XG5jb25zdCBjbGVhbk1vZGlmaWVkU3VicGF0aHMgPSByZXF1aXJlKCcuLi8uLi8uLi9oZWxwZXJzL2RvY3VtZW50L2NsZWFuTW9kaWZpZWRTdWJwYXRocycpO1xuY29uc3QgY2xvbmUgPSByZXF1aXJlKCcuLi8uLi8uLi9oZWxwZXJzL2Nsb25lJyk7XG5jb25zdCBpbnRlcm5hbFRvT2JqZWN0T3B0aW9ucyA9IHJlcXVpcmUoJy4uLy4uLy4uL29wdGlvbnMnKS5pbnRlcm5hbFRvT2JqZWN0T3B0aW9ucztcbmNvbnN0IG1wYXRoID0gcmVxdWlyZSgnbXBhdGgnKTtcbmNvbnN0IHV0aWxzID0gcmVxdWlyZSgnLi4vLi4vLi4vdXRpbHMnKTtcbmNvbnN0IGlzQnNvblR5cGUgPSByZXF1aXJlKCcuLi8uLi8uLi9oZWxwZXJzL2lzQnNvblR5cGUnKTtcblxuY29uc3QgYXJyYXlBdG9taWNzU3ltYm9sID0gcmVxdWlyZSgnLi4vLi4vLi4vaGVscGVycy9zeW1ib2xzJykuYXJyYXlBdG9taWNzU3ltYm9sO1xuY29uc3QgYXJyYXlQYXJlbnRTeW1ib2wgPSByZXF1aXJlKCcuLi8uLi8uLi9oZWxwZXJzL3N5bWJvbHMnKS5hcnJheVBhcmVudFN5bWJvbDtcbmNvbnN0IGFycmF5UGF0aFN5bWJvbCA9IHJlcXVpcmUoJy4uLy4uLy4uL2hlbHBlcnMvc3ltYm9scycpLmFycmF5UGF0aFN5bWJvbDtcbmNvbnN0IGFycmF5U2NoZW1hU3ltYm9sID0gcmVxdWlyZSgnLi4vLi4vLi4vaGVscGVycy9zeW1ib2xzJykuYXJyYXlTY2hlbWFTeW1ib2w7XG5jb25zdCBwb3B1bGF0ZU1vZGVsU3ltYm9sID0gcmVxdWlyZSgnLi4vLi4vLi4vaGVscGVycy9zeW1ib2xzJykucG9wdWxhdGVNb2RlbFN5bWJvbDtcbmNvbnN0IHNsaWNlZFN5bWJvbCA9IFN5bWJvbCgnbW9uZ29vc2UjQXJyYXkjc2xpY2VkJyk7XG5cbmNvbnN0IF9iYXNlUHVzaCA9IEFycmF5LnByb3RvdHlwZS5wdXNoO1xuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cbmNvbnN0IG1ldGhvZHMgPSB7XG4gIC8qKlxuICAgKiBEZXBvcHVsYXRlcyBzdG9yZWQgYXRvbWljIG9wZXJhdGlvbiB2YWx1ZXMgYXMgbmVjZXNzYXJ5IGZvciBkaXJlY3QgaW5zZXJ0aW9uIHRvIE1vbmdvREIuXG4gICAqXG4gICAqIElmIG5vIGF0b21pY3MgZXhpc3QsIHdlIHJldHVybiBhbGwgYXJyYXkgdmFsdWVzIGFmdGVyIGNvbnZlcnNpb24uXG4gICAqXG4gICAqIEByZXR1cm4ge0FycmF5fVxuICAgKiBAbWV0aG9kICRfX2dldEF0b21pY3NcbiAgICogQG1lbWJlck9mIE1vbmdvb3NlQXJyYXlcbiAgICogQGluc3RhbmNlXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cblxuICAkX19nZXRBdG9taWNzKCkge1xuICAgIGNvbnN0IHJldCA9IFtdO1xuICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyh0aGlzW2FycmF5QXRvbWljc1N5bWJvbF0gfHwge30pO1xuICAgIGxldCBpID0ga2V5cy5sZW5ndGg7XG5cbiAgICBjb25zdCBvcHRzID0gT2JqZWN0LmFzc2lnbih7fSwgaW50ZXJuYWxUb09iamVjdE9wdGlvbnMsIHsgX2lzTmVzdGVkOiB0cnVlIH0pO1xuXG4gICAgaWYgKGkgPT09IDApIHtcbiAgICAgIHJldFswXSA9IFsnJHNldCcsIHRoaXMudG9PYmplY3Qob3B0cyldO1xuICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG5cbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICBjb25zdCBvcCA9IGtleXNbaV07XG4gICAgICBsZXQgdmFsID0gdGhpc1thcnJheUF0b21pY3NTeW1ib2xdW29wXTtcblxuICAgICAgLy8gdGhlIGF0b21pYyB2YWx1ZXMgd2hpY2ggYXJlIGFycmF5cyBhcmUgbm90IE1vbmdvb3NlQXJyYXlzLiB3ZVxuICAgICAgLy8gbmVlZCB0byBjb252ZXJ0IHRoZWlyIGVsZW1lbnRzIGFzIGlmIHRoZXkgd2VyZSBNb25nb29zZUFycmF5c1xuICAgICAgLy8gdG8gaGFuZGxlIHBvcHVsYXRlZCBhcnJheXMgdmVyc3VzIERvY3VtZW50QXJyYXlzIHByb3Blcmx5LlxuICAgICAgaWYgKHV0aWxzLmlzTW9uZ29vc2VPYmplY3QodmFsKSkge1xuICAgICAgICB2YWwgPSB2YWwudG9PYmplY3Qob3B0cyk7XG4gICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodmFsKSkge1xuICAgICAgICB2YWwgPSB0aGlzLnRvT2JqZWN0LmNhbGwodmFsLCBvcHRzKTtcbiAgICAgIH0gZWxzZSBpZiAodmFsICE9IG51bGwgJiYgQXJyYXkuaXNBcnJheSh2YWwuJGVhY2gpKSB7XG4gICAgICAgIHZhbC4kZWFjaCA9IHRoaXMudG9PYmplY3QuY2FsbCh2YWwuJGVhY2gsIG9wdHMpO1xuICAgICAgfSBlbHNlIGlmICh2YWwgIT0gbnVsbCAmJiB0eXBlb2YgdmFsLnZhbHVlT2YgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdmFsID0gdmFsLnZhbHVlT2YoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKG9wID09PSAnJGFkZFRvU2V0Jykge1xuICAgICAgICB2YWwgPSB7ICRlYWNoOiB2YWwgfTtcbiAgICAgIH1cblxuICAgICAgcmV0LnB1c2goW29wLCB2YWxdKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmV0O1xuICB9LFxuXG4gIC8qIVxuICAgKiBpZ25vcmVcbiAgICovXG5cbiAgJGF0b21pY3MoKSB7XG4gICAgcmV0dXJuIHRoaXNbYXJyYXlBdG9taWNzU3ltYm9sXTtcbiAgfSxcblxuICAvKiFcbiAgICogaWdub3JlXG4gICAqL1xuXG4gICRwYXJlbnQoKSB7XG4gICAgcmV0dXJuIHRoaXNbYXJyYXlQYXJlbnRTeW1ib2xdO1xuICB9LFxuXG4gIC8qIVxuICAgKiBpZ25vcmVcbiAgICovXG5cbiAgJHBhdGgoKSB7XG4gICAgcmV0dXJuIHRoaXNbYXJyYXlQYXRoU3ltYm9sXTtcbiAgfSxcblxuICAvKipcbiAgICogQXRvbWljYWxseSBzaGlmdHMgdGhlIGFycmF5IGF0IG1vc3Qgb25lIHRpbWUgcGVyIGRvY3VtZW50IGBzYXZlKClgLlxuICAgKlxuICAgKiAjIyMjIE5vdGU6XG4gICAqXG4gICAqIF9DYWxsaW5nIHRoaXMgbXVsdGlwbGUgdGltZXMgb24gYW4gYXJyYXkgYmVmb3JlIHNhdmluZyBzZW5kcyB0aGUgc2FtZSBjb21tYW5kIGFzIGNhbGxpbmcgaXQgb25jZS5fXG4gICAqIF9UaGlzIHVwZGF0ZSBpcyBpbXBsZW1lbnRlZCB1c2luZyB0aGUgTW9uZ29EQiBbJHBvcF0oaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvcmVmZXJlbmNlL29wZXJhdG9yL3VwZGF0ZS9wb3AvKSBtZXRob2Qgd2hpY2ggZW5mb3JjZXMgdGhpcyByZXN0cmljdGlvbi5fXG4gICAqXG4gICAqICAgICAgZG9jLmFycmF5ID0gWzEsMiwzXTtcbiAgICpcbiAgICogICAgICBjb25zdCBzaGlmdGVkID0gZG9jLmFycmF5LiRzaGlmdCgpO1xuICAgKiAgICAgIGNvbnNvbGUubG9nKHNoaWZ0ZWQpOyAvLyAxXG4gICAqICAgICAgY29uc29sZS5sb2coZG9jLmFycmF5KTsgLy8gWzIsM11cbiAgICpcbiAgICogICAgICAvLyBubyBhZmZlY3RcbiAgICogICAgICBzaGlmdGVkID0gZG9jLmFycmF5LiRzaGlmdCgpO1xuICAgKiAgICAgIGNvbnNvbGUubG9nKGRvYy5hcnJheSk7IC8vIFsyLDNdXG4gICAqXG4gICAqICAgICAgZG9jLnNhdmUoZnVuY3Rpb24gKGVycikge1xuICAgKiAgICAgICAgaWYgKGVycikgcmV0dXJuIGhhbmRsZUVycm9yKGVycik7XG4gICAqXG4gICAqICAgICAgICAvLyB3ZSBzYXZlZCwgbm93ICRzaGlmdCB3b3JrcyBhZ2FpblxuICAgKiAgICAgICAgc2hpZnRlZCA9IGRvYy5hcnJheS4kc2hpZnQoKTtcbiAgICogICAgICAgIGNvbnNvbGUubG9nKHNoaWZ0ZWQgKTsgLy8gMlxuICAgKiAgICAgICAgY29uc29sZS5sb2coZG9jLmFycmF5KTsgLy8gWzNdXG4gICAqICAgICAgfSlcbiAgICpcbiAgICogQGFwaSBwdWJsaWNcbiAgICogQG1lbWJlck9mIE1vbmdvb3NlQXJyYXlcbiAgICogQGluc3RhbmNlXG4gICAqIEBtZXRob2QgJHNoaWZ0XG4gICAqIEBzZWUgbW9uZ29kYiBodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9yZWZlcmVuY2Uvb3BlcmF0b3IvdXBkYXRlL3BvcC9cbiAgICovXG5cbiAgJHNoaWZ0KCkge1xuICAgIHRoaXMuX3JlZ2lzdGVyQXRvbWljKCckcG9wJywgLTEpO1xuICAgIHRoaXMuX21hcmtNb2RpZmllZCgpO1xuXG4gICAgLy8gb25seSBhbGxvdyBzaGlmdGluZyBvbmNlXG4gICAgY29uc3QgX19hcnJheSA9IHRoaXMuX19hcnJheTtcbiAgICBpZiAoX19hcnJheS5fc2hpZnRlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBfX2FycmF5Ll9zaGlmdGVkID0gdHJ1ZTtcblxuICAgIHJldHVybiBbXS5zaGlmdC5jYWxsKF9fYXJyYXkpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBQb3BzIHRoZSBhcnJheSBhdG9taWNhbGx5IGF0IG1vc3Qgb25lIHRpbWUgcGVyIGRvY3VtZW50IGBzYXZlKClgLlxuICAgKlxuICAgKiAjIyMjIE5PVEU6XG4gICAqXG4gICAqIF9DYWxsaW5nIHRoaXMgbXVsdGlwbGUgdGltZXMgb24gYW4gYXJyYXkgYmVmb3JlIHNhdmluZyBzZW5kcyB0aGUgc2FtZSBjb21tYW5kIGFzIGNhbGxpbmcgaXQgb25jZS5fXG4gICAqIF9UaGlzIHVwZGF0ZSBpcyBpbXBsZW1lbnRlZCB1c2luZyB0aGUgTW9uZ29EQiBbJHBvcF0oaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvcmVmZXJlbmNlL29wZXJhdG9yL3VwZGF0ZS9wb3AvKSBtZXRob2Qgd2hpY2ggZW5mb3JjZXMgdGhpcyByZXN0cmljdGlvbi5fXG4gICAqXG4gICAqICAgICAgZG9jLmFycmF5ID0gWzEsMiwzXTtcbiAgICpcbiAgICogICAgICBjb25zdCBwb3BwZWQgPSBkb2MuYXJyYXkuJHBvcCgpO1xuICAgKiAgICAgIGNvbnNvbGUubG9nKHBvcHBlZCk7IC8vIDNcbiAgICogICAgICBjb25zb2xlLmxvZyhkb2MuYXJyYXkpOyAvLyBbMSwyXVxuICAgKlxuICAgKiAgICAgIC8vIG5vIGFmZmVjdFxuICAgKiAgICAgIHBvcHBlZCA9IGRvYy5hcnJheS4kcG9wKCk7XG4gICAqICAgICAgY29uc29sZS5sb2coZG9jLmFycmF5KTsgLy8gWzEsMl1cbiAgICpcbiAgICogICAgICBkb2Muc2F2ZShmdW5jdGlvbiAoZXJyKSB7XG4gICAqICAgICAgICBpZiAoZXJyKSByZXR1cm4gaGFuZGxlRXJyb3IoZXJyKTtcbiAgICpcbiAgICogICAgICAgIC8vIHdlIHNhdmVkLCBub3cgJHBvcCB3b3JrcyBhZ2FpblxuICAgKiAgICAgICAgcG9wcGVkID0gZG9jLmFycmF5LiRwb3AoKTtcbiAgICogICAgICAgIGNvbnNvbGUubG9nKHBvcHBlZCk7IC8vIDJcbiAgICogICAgICAgIGNvbnNvbGUubG9nKGRvYy5hcnJheSk7IC8vIFsxXVxuICAgKiAgICAgIH0pXG4gICAqXG4gICAqIEBhcGkgcHVibGljXG4gICAqIEBtZXRob2QgJHBvcFxuICAgKiBAbWVtYmVyT2YgTW9uZ29vc2VBcnJheVxuICAgKiBAaW5zdGFuY2VcbiAgICogQHNlZSBtb25nb2RiIGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvbWFudWFsL3JlZmVyZW5jZS9vcGVyYXRvci91cGRhdGUvcG9wL1xuICAgKiBAbWV0aG9kICRwb3BcbiAgICogQG1lbWJlck9mIE1vbmdvb3NlQXJyYXlcbiAgICovXG5cbiAgJHBvcCgpIHtcbiAgICB0aGlzLl9yZWdpc3RlckF0b21pYygnJHBvcCcsIDEpO1xuICAgIHRoaXMuX21hcmtNb2RpZmllZCgpO1xuXG4gICAgLy8gb25seSBhbGxvdyBwb3BwaW5nIG9uY2VcbiAgICBpZiAodGhpcy5fcG9wcGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX3BvcHBlZCA9IHRydWU7XG5cbiAgICByZXR1cm4gW10ucG9wLmNhbGwodGhpcyk7XG4gIH0sXG5cbiAgLyohXG4gICAqIGlnbm9yZVxuICAgKi9cblxuICAkc2NoZW1hKCkge1xuICAgIHJldHVybiB0aGlzW2FycmF5U2NoZW1hU3ltYm9sXTtcbiAgfSxcblxuICAvKipcbiAgICogQ2FzdHMgYSBtZW1iZXIgYmFzZWQgb24gdGhpcyBhcnJheXMgc2NoZW1hLlxuICAgKlxuICAgKiBAcGFyYW0ge2FueX0gdmFsdWVcbiAgICogQHJldHVybiB2YWx1ZSB0aGUgY2FzdGVkIHZhbHVlXG4gICAqIEBtZXRob2QgX2Nhc3RcbiAgICogQGFwaSBwcml2YXRlXG4gICAqIEBtZW1iZXJPZiBNb25nb29zZUFycmF5XG4gICAqL1xuXG4gIF9jYXN0KHZhbHVlKSB7XG4gICAgbGV0IHBvcHVsYXRlZCA9IGZhbHNlO1xuICAgIGxldCBNb2RlbDtcblxuICAgIGNvbnN0IHBhcmVudCA9IHRoaXNbYXJyYXlQYXJlbnRTeW1ib2xdO1xuICAgIGlmIChwYXJlbnQpIHtcbiAgICAgIHBvcHVsYXRlZCA9IHBhcmVudC4kcG9wdWxhdGVkKHRoaXNbYXJyYXlQYXRoU3ltYm9sXSwgdHJ1ZSk7XG4gICAgfVxuXG4gICAgaWYgKHBvcHVsYXRlZCAmJiB2YWx1ZSAhPT0gbnVsbCAmJiB2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBjYXN0IHRvIHRoZSBwb3B1bGF0ZWQgTW9kZWxzIHNjaGVtYVxuICAgICAgTW9kZWwgPSBwb3B1bGF0ZWQub3B0aW9uc1twb3B1bGF0ZU1vZGVsU3ltYm9sXTtcbiAgICAgIGlmIChNb2RlbCA9PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBNb25nb29zZUVycm9yKCdObyBwb3B1bGF0ZWQgbW9kZWwgZm91bmQgZm9yIHBhdGggYCcgKyB0aGlzW2FycmF5UGF0aFN5bWJvbF0gKyAnYC4gVGhpcyBpcyBsaWtlbHkgYSBidWcgaW4gTW9uZ29vc2UsIHBsZWFzZSByZXBvcnQgYW4gaXNzdWUgb24gZ2l0aHViLmNvbS9BdXRvbWF0dGljL21vbmdvb3NlLicpO1xuICAgICAgfVxuXG4gICAgICAvLyBvbmx5IG9iamVjdHMgYXJlIHBlcm1pdHRlZCBzbyB3ZSBjYW4gc2FmZWx5IGFzc3VtZSB0aGF0XG4gICAgICAvLyBub24tb2JqZWN0cyBhcmUgdG8gYmUgaW50ZXJwcmV0ZWQgYXMgX2lkXG4gICAgICBpZiAoQnVmZmVyLmlzQnVmZmVyKHZhbHVlKSB8fFxuICAgICAgICAgIGlzQnNvblR5cGUodmFsdWUsICdPYmplY3RJZCcpIHx8ICF1dGlscy5pc09iamVjdCh2YWx1ZSkpIHtcbiAgICAgICAgdmFsdWUgPSB7IF9pZDogdmFsdWUgfTtcbiAgICAgIH1cblxuICAgICAgLy8gZ2gtMjM5OVxuICAgICAgLy8gd2Ugc2hvdWxkIGNhc3QgbW9kZWwgb25seSB3aGVuIGl0J3Mgbm90IGEgZGlzY3JpbWluYXRvclxuICAgICAgY29uc3QgaXNEaXNjID0gdmFsdWUuc2NoZW1hICYmIHZhbHVlLnNjaGVtYS5kaXNjcmltaW5hdG9yTWFwcGluZyAmJlxuICAgICAgICAgIHZhbHVlLnNjaGVtYS5kaXNjcmltaW5hdG9yTWFwcGluZy5rZXkgIT09IHVuZGVmaW5lZDtcbiAgICAgIGlmICghaXNEaXNjKSB7XG4gICAgICAgIHZhbHVlID0gbmV3IE1vZGVsKHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzW2FycmF5U2NoZW1hU3ltYm9sXS5jYXN0ZXIuYXBwbHlTZXR0ZXJzKHZhbHVlLCBwYXJlbnQsIHRydWUpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzW2FycmF5U2NoZW1hU3ltYm9sXS5jYXN0ZXIuYXBwbHlTZXR0ZXJzKHZhbHVlLCBwYXJlbnQsIGZhbHNlKTtcbiAgfSxcblxuICAvKipcbiAgICogSW50ZXJuYWwgaGVscGVyIGZvciAubWFwKClcbiAgICpcbiAgICogQGFwaSBwcml2YXRlXG4gICAqIEByZXR1cm4ge051bWJlcn1cbiAgICogQG1ldGhvZCBfbWFwQ2FzdFxuICAgKiBAbWVtYmVyT2YgTW9uZ29vc2VBcnJheVxuICAgKi9cblxuICBfbWFwQ2FzdCh2YWwsIGluZGV4KSB7XG4gICAgcmV0dXJuIHRoaXMuX2Nhc3QodmFsLCB0aGlzLmxlbmd0aCArIGluZGV4KTtcbiAgfSxcblxuICAvKipcbiAgICogTWFya3MgdGhpcyBhcnJheSBhcyBtb2RpZmllZC5cbiAgICpcbiAgICogSWYgaXQgYnViYmxlcyB1cCBmcm9tIGFuIGVtYmVkZGVkIGRvY3VtZW50IGNoYW5nZSwgdGhlbiBpdCB0YWtlcyB0aGUgZm9sbG93aW5nIGFyZ3VtZW50cyAob3RoZXJ3aXNlLCB0YWtlcyAwIGFyZ3VtZW50cylcbiAgICpcbiAgICogQHBhcmFtIHtBcnJheVN1YmRvY3VtZW50fSBzdWJkb2MgdGhlIGVtYmVkZGVkIGRvYyB0aGF0IGludm9rZWQgdGhpcyBtZXRob2Qgb24gdGhlIEFycmF5XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBlbWJlZGRlZFBhdGggdGhlIHBhdGggd2hpY2ggY2hhbmdlZCBpbiB0aGUgc3ViZG9jXG4gICAqIEBtZXRob2QgX21hcmtNb2RpZmllZFxuICAgKiBAYXBpIHByaXZhdGVcbiAgICogQG1lbWJlck9mIE1vbmdvb3NlQXJyYXlcbiAgICovXG5cbiAgX21hcmtNb2RpZmllZChlbGVtKSB7XG4gICAgY29uc3QgcGFyZW50ID0gdGhpc1thcnJheVBhcmVudFN5bWJvbF07XG4gICAgbGV0IGRpcnR5UGF0aDtcblxuICAgIGlmIChwYXJlbnQpIHtcbiAgICAgIGRpcnR5UGF0aCA9IHRoaXNbYXJyYXlQYXRoU3ltYm9sXTtcblxuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgZGlydHlQYXRoID0gZGlydHlQYXRoICsgJy4nICsgZWxlbTtcbiAgICAgIH1cblxuICAgICAgaWYgKGRpcnR5UGF0aCAhPSBudWxsICYmIGRpcnR5UGF0aC5lbmRzV2l0aCgnLiQnKSkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgcGFyZW50Lm1hcmtNb2RpZmllZChkaXJ0eVBhdGgsIGFyZ3VtZW50cy5sZW5ndGggIT09IDAgPyBlbGVtIDogcGFyZW50KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvKipcbiAgICogUmVnaXN0ZXIgYW4gYXRvbWljIG9wZXJhdGlvbiB3aXRoIHRoZSBwYXJlbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7QXJyYXl9IG9wIG9wZXJhdGlvblxuICAgKiBAcGFyYW0ge2FueX0gdmFsXG4gICAqIEBtZXRob2QgX3JlZ2lzdGVyQXRvbWljXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKiBAbWVtYmVyT2YgTW9uZ29vc2VBcnJheVxuICAgKi9cblxuICBfcmVnaXN0ZXJBdG9taWMob3AsIHZhbCkge1xuICAgIGlmICh0aGlzW3NsaWNlZFN5bWJvbF0pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKG9wID09PSAnJHNldCcpIHtcbiAgICAgIC8vICRzZXQgdGFrZXMgcHJlY2VkZW5jZSBvdmVyIGFsbCBvdGhlciBvcHMuXG4gICAgICAvLyBtYXJrIGVudGlyZSBhcnJheSBtb2RpZmllZC5cbiAgICAgIHRoaXNbYXJyYXlBdG9taWNzU3ltYm9sXSA9IHsgJHNldDogdmFsIH07XG4gICAgICBjbGVhbk1vZGlmaWVkU3VicGF0aHModGhpc1thcnJheVBhcmVudFN5bWJvbF0sIHRoaXNbYXJyYXlQYXRoU3ltYm9sXSk7XG4gICAgICB0aGlzLl9tYXJrTW9kaWZpZWQoKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGNvbnN0IGF0b21pY3MgPSB0aGlzW2FycmF5QXRvbWljc1N5bWJvbF07XG5cbiAgICAvLyByZXNldCBwb3Avc2hpZnQgYWZ0ZXIgc2F2ZVxuICAgIGlmIChvcCA9PT0gJyRwb3AnICYmICEoJyRwb3AnIGluIGF0b21pY3MpKSB7XG4gICAgICBjb25zdCBfdGhpcyA9IHRoaXM7XG4gICAgICB0aGlzW2FycmF5UGFyZW50U3ltYm9sXS5vbmNlKCdzYXZlJywgZnVuY3Rpb24oKSB7XG4gICAgICAgIF90aGlzLl9wb3BwZWQgPSBfdGhpcy5fc2hpZnRlZCA9IG51bGw7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBjaGVjayBmb3IgaW1wb3NzaWJsZSAkYXRvbWljIGNvbWJvcyAoTW9uZ28gZGVuaWVzIG1vcmUgdGhhbiBvbmVcbiAgICAvLyAkYXRvbWljIG9wIG9uIGEgc2luZ2xlIHBhdGhcbiAgICBpZiAoYXRvbWljcy4kc2V0IHx8IE9iamVjdC5rZXlzKGF0b21pY3MpLmxlbmd0aCAmJiAhKG9wIGluIGF0b21pY3MpKSB7XG4gICAgICAvLyBhIGRpZmZlcmVudCBvcCB3YXMgcHJldmlvdXNseSByZWdpc3RlcmVkLlxuICAgICAgLy8gc2F2ZSB0aGUgZW50aXJlIHRoaW5nLlxuICAgICAgdGhpc1thcnJheUF0b21pY3NTeW1ib2xdID0geyAkc2V0OiB0aGlzIH07XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBsZXQgc2VsZWN0b3I7XG5cbiAgICBpZiAob3AgPT09ICckcHVsbEFsbCcgfHwgb3AgPT09ICckYWRkVG9TZXQnKSB7XG4gICAgICBhdG9taWNzW29wXSB8fCAoYXRvbWljc1tvcF0gPSBbXSk7XG4gICAgICBhdG9taWNzW29wXSA9IGF0b21pY3Nbb3BdLmNvbmNhdCh2YWwpO1xuICAgIH0gZWxzZSBpZiAob3AgPT09ICckcHVsbERvY3MnKSB7XG4gICAgICBjb25zdCBwdWxsT3AgPSBhdG9taWNzWyckcHVsbCddIHx8IChhdG9taWNzWyckcHVsbCddID0ge30pO1xuICAgICAgaWYgKHZhbFswXSBpbnN0YW5jZW9mIEFycmF5U3ViZG9jdW1lbnQpIHtcbiAgICAgICAgc2VsZWN0b3IgPSBwdWxsT3BbJyRvciddIHx8IChwdWxsT3BbJyRvciddID0gW10pO1xuICAgICAgICBBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseShzZWxlY3RvciwgdmFsLm1hcCh2ID0+IHtcbiAgICAgICAgICByZXR1cm4gdi50b09iamVjdCh7XG4gICAgICAgICAgICB0cmFuc2Zvcm06IChkb2MsIHJldCkgPT4ge1xuICAgICAgICAgICAgICBpZiAodiA9PSBudWxsIHx8IHYuJF9fID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgT2JqZWN0LmtleXModi4kX18uYWN0aXZlUGF0aHMuZ2V0U3RhdGVQYXRocygnZGVmYXVsdCcpKS5mb3JFYWNoKHBhdGggPT4ge1xuICAgICAgICAgICAgICAgIG1wYXRoLnVuc2V0KHBhdGgsIHJldCk7XG5cbiAgICAgICAgICAgICAgICBfbWluaW1pemVQYXRoKHJldCwgcGF0aCk7XG4gICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdmlydHVhbHM6IGZhbHNlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNlbGVjdG9yID0gcHVsbE9wWydfaWQnXSB8fCAocHVsbE9wWydfaWQnXSA9IHsgJGluOiBbXSB9KTtcbiAgICAgICAgc2VsZWN0b3JbJyRpbiddID0gc2VsZWN0b3JbJyRpbiddLmNvbmNhdCh2YWwpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAob3AgPT09ICckcHVzaCcpIHtcbiAgICAgIGF0b21pY3MuJHB1c2ggPSBhdG9taWNzLiRwdXNoIHx8IHsgJGVhY2g6IFtdIH07XG4gICAgICBpZiAodmFsICE9IG51bGwgJiYgdXRpbHMuaGFzVXNlckRlZmluZWRQcm9wZXJ0eSh2YWwsICckZWFjaCcpKSB7XG4gICAgICAgIGF0b21pY3MuJHB1c2ggPSB2YWw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAodmFsLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgIGF0b21pY3MuJHB1c2guJGVhY2gucHVzaCh2YWxbMF0pO1xuICAgICAgICB9IGVsc2UgaWYgKHZhbC5sZW5ndGggPCAxMDAwMCkge1xuICAgICAgICAgIGF0b21pY3MuJHB1c2guJGVhY2gucHVzaCguLi52YWwpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZvciAoY29uc3QgdiBvZiB2YWwpIHtcbiAgICAgICAgICAgIGF0b21pY3MuJHB1c2guJGVhY2gucHVzaCh2KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgYXRvbWljc1tvcF0gPSB2YWw7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEFkZHMgdmFsdWVzIHRvIHRoZSBhcnJheSBpZiBub3QgYWxyZWFkeSBwcmVzZW50LlxuICAgKlxuICAgKiAjIyMjIEV4YW1wbGU6XG4gICAqXG4gICAqICAgICBjb25zb2xlLmxvZyhkb2MuYXJyYXkpIC8vIFsyLDMsNF1cbiAgICogICAgIGNvbnN0IGFkZGVkID0gZG9jLmFycmF5LmFkZFRvU2V0KDQsNSk7XG4gICAqICAgICBjb25zb2xlLmxvZyhkb2MuYXJyYXkpIC8vIFsyLDMsNCw1XVxuICAgKiAgICAgY29uc29sZS5sb2coYWRkZWQpICAgICAvLyBbNV1cbiAgICpcbiAgICogQHBhcmFtIHsuLi5hbnl9IFthcmdzXVxuICAgKiBAcmV0dXJuIHtBcnJheX0gdGhlIHZhbHVlcyB0aGF0IHdlcmUgYWRkZWRcbiAgICogQG1lbWJlck9mIE1vbmdvb3NlQXJyYXlcbiAgICogQGFwaSBwdWJsaWNcbiAgICogQG1ldGhvZCBhZGRUb1NldFxuICAgKi9cblxuICBhZGRUb1NldCgpIHtcbiAgICBfY2hlY2tNYW51YWxQb3B1bGF0aW9uKHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgICBjb25zdCB2YWx1ZXMgPSBbXS5tYXAuY2FsbChhcmd1bWVudHMsIHRoaXMuX21hcENhc3QsIHRoaXMpO1xuICAgIGNvbnN0IGFkZGVkID0gW107XG4gICAgbGV0IHR5cGUgPSAnJztcbiAgICBpZiAodmFsdWVzWzBdIGluc3RhbmNlb2YgQXJyYXlTdWJkb2N1bWVudCkge1xuICAgICAgdHlwZSA9ICdkb2MnO1xuICAgIH0gZWxzZSBpZiAodmFsdWVzWzBdIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgdHlwZSA9ICdkYXRlJztcbiAgICB9IGVsc2UgaWYgKGlzQnNvblR5cGUodmFsdWVzWzBdLCAnT2JqZWN0SWQnKSkge1xuICAgICAgdHlwZSA9ICdPYmplY3RJZCc7XG4gICAgfVxuXG4gICAgY29uc3QgcmF3VmFsdWVzID0gdXRpbHMuaXNNb25nb29zZUFycmF5KHZhbHVlcykgPyB2YWx1ZXMuX19hcnJheSA6IHZhbHVlcztcbiAgICBjb25zdCByYXdBcnJheSA9IHV0aWxzLmlzTW9uZ29vc2VBcnJheSh0aGlzKSA/IHRoaXMuX19hcnJheSA6IHRoaXM7XG5cbiAgICByYXdWYWx1ZXMuZm9yRWFjaChmdW5jdGlvbih2KSB7XG4gICAgICBsZXQgZm91bmQ7XG4gICAgICBjb25zdCB2YWwgPSArdjtcbiAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlICdkb2MnOlxuICAgICAgICAgIGZvdW5kID0gdGhpcy5zb21lKGZ1bmN0aW9uKGRvYykge1xuICAgICAgICAgICAgcmV0dXJuIGRvYy5lcXVhbHModik7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2RhdGUnOlxuICAgICAgICAgIGZvdW5kID0gdGhpcy5zb21lKGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgIHJldHVybiArZCA9PT0gdmFsO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdPYmplY3RJZCc6XG4gICAgICAgICAgZm91bmQgPSB0aGlzLmZpbmQobyA9PiBvLnRvU3RyaW5nKCkgPT09IHYudG9TdHJpbmcoKSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgZm91bmQgPSB+dGhpcy5pbmRleE9mKHYpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWZvdW5kKSB7XG4gICAgICAgIHRoaXMuX21hcmtNb2RpZmllZCgpO1xuICAgICAgICByYXdBcnJheS5wdXNoKHYpO1xuICAgICAgICB0aGlzLl9yZWdpc3RlckF0b21pYygnJGFkZFRvU2V0Jywgdik7XG4gICAgICAgIFtdLnB1c2guY2FsbChhZGRlZCwgdik7XG4gICAgICB9XG4gICAgfSwgdGhpcyk7XG5cbiAgICByZXR1cm4gYWRkZWQ7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIG51bWJlciBvZiBwZW5kaW5nIGF0b21pYyBvcGVyYXRpb25zIHRvIHNlbmQgdG8gdGhlIGRiIGZvciB0aGlzIGFycmF5LlxuICAgKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICogQHJldHVybiB7TnVtYmVyfVxuICAgKiBAbWV0aG9kIGhhc0F0b21pY3NcbiAgICogQG1lbWJlck9mIE1vbmdvb3NlQXJyYXlcbiAgICovXG5cbiAgaGFzQXRvbWljcygpIHtcbiAgICBpZiAoIXV0aWxzLmlzUE9KTyh0aGlzW2FycmF5QXRvbWljc1N5bWJvbF0pKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG5cbiAgICByZXR1cm4gT2JqZWN0LmtleXModGhpc1thcnJheUF0b21pY3NTeW1ib2xdKS5sZW5ndGg7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJldHVybiB3aGV0aGVyIG9yIG5vdCB0aGUgYG9iamAgaXMgaW5jbHVkZWQgaW4gdGhlIGFycmF5LlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqIHRoZSBpdGVtIHRvIGNoZWNrXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBmcm9tSW5kZXhcbiAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICogQGFwaSBwdWJsaWNcbiAgICogQG1ldGhvZCBpbmNsdWRlc1xuICAgKiBAbWVtYmVyT2YgTW9uZ29vc2VBcnJheVxuICAgKi9cblxuICBpbmNsdWRlcyhvYmosIGZyb21JbmRleCkge1xuICAgIGNvbnN0IHJldCA9IHRoaXMuaW5kZXhPZihvYmosIGZyb21JbmRleCk7XG4gICAgcmV0dXJuIHJldCAhPT0gLTE7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgaW5kZXggb2YgYG9iamAgb3IgYC0xYCBpZiBub3QgZm91bmQuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmogdGhlIGl0ZW0gdG8gbG9vayBmb3JcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGZyb21JbmRleFxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9XG4gICAqIEBhcGkgcHVibGljXG4gICAqIEBtZXRob2QgaW5kZXhPZlxuICAgKiBAbWVtYmVyT2YgTW9uZ29vc2VBcnJheVxuICAgKi9cblxuICBpbmRleE9mKG9iaiwgZnJvbUluZGV4KSB7XG4gICAgaWYgKGlzQnNvblR5cGUob2JqLCAnT2JqZWN0SWQnKSkge1xuICAgICAgb2JqID0gb2JqLnRvU3RyaW5nKCk7XG4gICAgfVxuXG4gICAgZnJvbUluZGV4ID0gZnJvbUluZGV4ID09IG51bGwgPyAwIDogZnJvbUluZGV4O1xuICAgIGNvbnN0IGxlbiA9IHRoaXMubGVuZ3RoO1xuICAgIGZvciAobGV0IGkgPSBmcm9tSW5kZXg7IGkgPCBsZW47ICsraSkge1xuICAgICAgaWYgKG9iaiA9PSB0aGlzW2ldKSB7XG4gICAgICAgIHJldHVybiBpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gLTE7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEhlbHBlciBmb3IgY29uc29sZS5sb2dcbiAgICpcbiAgICogQGFwaSBwdWJsaWNcbiAgICogQG1ldGhvZCBpbnNwZWN0XG4gICAqIEBtZW1iZXJPZiBNb25nb29zZUFycmF5XG4gICAqL1xuXG4gIGluc3BlY3QoKSB7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHRoaXMpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBQdXNoZXMgaXRlbXMgdG8gdGhlIGFycmF5IG5vbi1hdG9taWNhbGx5LlxuICAgKlxuICAgKiAjIyMjIE5vdGU6XG4gICAqXG4gICAqIF9tYXJrcyB0aGUgZW50aXJlIGFycmF5IGFzIG1vZGlmaWVkLCB3aGljaCBpZiBzYXZlZCwgd2lsbCBzdG9yZSBpdCBhcyBhIGAkc2V0YCBvcGVyYXRpb24sIHBvdGVudGlhbGx5IG92ZXJ3cml0dGluZyBhbnkgY2hhbmdlcyB0aGF0IGhhcHBlbiBiZXR3ZWVuIHdoZW4geW91IHJldHJpZXZlZCB0aGUgb2JqZWN0IGFuZCB3aGVuIHlvdSBzYXZlIGl0Ll9cbiAgICpcbiAgICogQHBhcmFtIHsuLi5hbnl9IFthcmdzXVxuICAgKiBAYXBpIHB1YmxpY1xuICAgKiBAbWV0aG9kIG5vbkF0b21pY1B1c2hcbiAgICogQG1lbWJlck9mIE1vbmdvb3NlQXJyYXlcbiAgICovXG5cbiAgbm9uQXRvbWljUHVzaCgpIHtcbiAgICBjb25zdCB2YWx1ZXMgPSBbXS5tYXAuY2FsbChhcmd1bWVudHMsIHRoaXMuX21hcENhc3QsIHRoaXMpO1xuICAgIHRoaXMuX21hcmtNb2RpZmllZCgpO1xuICAgIGNvbnN0IHJldCA9IFtdLnB1c2guYXBwbHkodGhpcywgdmFsdWVzKTtcbiAgICB0aGlzLl9yZWdpc3RlckF0b21pYygnJHNldCcsIHRoaXMpO1xuICAgIHJldHVybiByZXQ7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFdyYXBzIFtgQXJyYXkjcG9wYF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQXJyYXkvcG9wKSB3aXRoIHByb3BlciBjaGFuZ2UgdHJhY2tpbmcuXG4gICAqXG4gICAqICMjIyMgTm90ZTpcbiAgICpcbiAgICogX21hcmtzIHRoZSBlbnRpcmUgYXJyYXkgYXMgbW9kaWZpZWQgd2hpY2ggd2lsbCBwYXNzIHRoZSBlbnRpcmUgdGhpbmcgdG8gJHNldCBwb3RlbnRpYWxseSBvdmVyd3JpdGluZyBhbnkgY2hhbmdlcyB0aGF0IGhhcHBlbiBiZXR3ZWVuIHdoZW4geW91IHJldHJpZXZlZCB0aGUgb2JqZWN0IGFuZCB3aGVuIHlvdSBzYXZlIGl0Ll9cbiAgICpcbiAgICogQHNlZSBNb25nb29zZUFycmF5IyRwb3AgaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2FwaS9hcnJheS5odG1sI01vbmdvb3NlQXJyYXkucHJvdG90eXBlLiRwb3AoKVxuICAgKiBAYXBpIHB1YmxpY1xuICAgKiBAbWV0aG9kIHBvcFxuICAgKiBAbWVtYmVyT2YgTW9uZ29vc2VBcnJheVxuICAgKi9cblxuICBwb3AoKSB7XG4gICAgdGhpcy5fbWFya01vZGlmaWVkKCk7XG4gICAgY29uc3QgcmV0ID0gW10ucG9wLmNhbGwodGhpcyk7XG4gICAgdGhpcy5fcmVnaXN0ZXJBdG9taWMoJyRzZXQnLCB0aGlzKTtcbiAgICByZXR1cm4gcmV0O1xuICB9LFxuXG4gIC8qKlxuICAgKiBQdWxscyBpdGVtcyBmcm9tIHRoZSBhcnJheSBhdG9taWNhbGx5LiBFcXVhbGl0eSBpcyBkZXRlcm1pbmVkIGJ5IGNhc3RpbmdcbiAgICogdGhlIHByb3ZpZGVkIHZhbHVlIHRvIGFuIGVtYmVkZGVkIGRvY3VtZW50IGFuZCBjb21wYXJpbmcgdXNpbmdcbiAgICogW3RoZSBgRG9jdW1lbnQuZXF1YWxzKClgIGZ1bmN0aW9uLl0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2FwaS9kb2N1bWVudC5odG1sI0RvY3VtZW50LnByb3RvdHlwZS5lcXVhbHMoKSlcbiAgICpcbiAgICogIyMjIyBFeGFtcGxlOlxuICAgKlxuICAgKiAgICAgZG9jLmFycmF5LnB1bGwoT2JqZWN0SWQpXG4gICAqICAgICBkb2MuYXJyYXkucHVsbCh7IF9pZDogJ3NvbWVJZCcgfSlcbiAgICogICAgIGRvYy5hcnJheS5wdWxsKDM2KVxuICAgKiAgICAgZG9jLmFycmF5LnB1bGwoJ3RhZyAxJywgJ3RhZyAyJylcbiAgICpcbiAgICogVG8gcmVtb3ZlIGEgZG9jdW1lbnQgZnJvbSBhIHN1YmRvY3VtZW50IGFycmF5IHdlIG1heSBwYXNzIGFuIG9iamVjdCB3aXRoIGEgbWF0Y2hpbmcgYF9pZGAuXG4gICAqXG4gICAqICAgICBkb2Muc3ViZG9jcy5wdXNoKHsgX2lkOiA0ODE1MTYyMzQyIH0pXG4gICAqICAgICBkb2Muc3ViZG9jcy5wdWxsKHsgX2lkOiA0ODE1MTYyMzQyIH0pIC8vIHJlbW92ZWRcbiAgICpcbiAgICogT3Igd2UgbWF5IHBhc3NpbmcgdGhlIF9pZCBkaXJlY3RseSBhbmQgbGV0IG1vbmdvb3NlIHRha2UgY2FyZSBvZiBpdC5cbiAgICpcbiAgICogICAgIGRvYy5zdWJkb2NzLnB1c2goeyBfaWQ6IDQ4MTUxNjIzNDIgfSlcbiAgICogICAgIGRvYy5zdWJkb2NzLnB1bGwoNDgxNTE2MjM0Mik7IC8vIHdvcmtzXG4gICAqXG4gICAqIFRoZSBmaXJzdCBwdWxsIGNhbGwgd2lsbCByZXN1bHQgaW4gYSBhdG9taWMgb3BlcmF0aW9uIG9uIHRoZSBkYXRhYmFzZSwgaWYgcHVsbCBpcyBjYWxsZWQgcmVwZWF0ZWRseSB3aXRob3V0IHNhdmluZyB0aGUgZG9jdW1lbnQsIGEgJHNldCBvcGVyYXRpb24gaXMgdXNlZCBvbiB0aGUgY29tcGxldGUgYXJyYXkgaW5zdGVhZCwgb3ZlcndyaXRpbmcgcG9zc2libGUgY2hhbmdlcyB0aGF0IGhhcHBlbmVkIG9uIHRoZSBkYXRhYmFzZSBpbiB0aGUgbWVhbnRpbWUuXG4gICAqXG4gICAqIEBwYXJhbSB7Li4uYW55fSBbYXJnc11cbiAgICogQHNlZSBtb25nb2RiIGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvbWFudWFsL3JlZmVyZW5jZS9vcGVyYXRvci91cGRhdGUvcHVsbC9cbiAgICogQGFwaSBwdWJsaWNcbiAgICogQG1ldGhvZCBwdWxsXG4gICAqIEBtZW1iZXJPZiBNb25nb29zZUFycmF5XG4gICAqL1xuXG4gIHB1bGwoKSB7XG4gICAgY29uc3QgdmFsdWVzID0gW10ubWFwLmNhbGwoYXJndW1lbnRzLCAodiwgaSkgPT4gdGhpcy5fY2FzdCh2LCBpLCB7IGRlZmF1bHRzOiBmYWxzZSB9KSwgdGhpcyk7XG4gICAgY29uc3QgY3VyID0gdGhpc1thcnJheVBhcmVudFN5bWJvbF0uZ2V0KHRoaXNbYXJyYXlQYXRoU3ltYm9sXSk7XG4gICAgbGV0IGkgPSBjdXIubGVuZ3RoO1xuICAgIGxldCBtZW07XG4gICAgdGhpcy5fbWFya01vZGlmaWVkKCk7XG5cbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICBtZW0gPSBjdXJbaV07XG4gICAgICBpZiAobWVtIGluc3RhbmNlb2YgRG9jdW1lbnQpIHtcbiAgICAgICAgY29uc3Qgc29tZSA9IHZhbHVlcy5zb21lKGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgICByZXR1cm4gbWVtLmVxdWFscyh2KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChzb21lKSB7XG4gICAgICAgICAgW10uc3BsaWNlLmNhbGwoY3VyLCBpLCAxKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh+Y3VyLmluZGV4T2YuY2FsbCh2YWx1ZXMsIG1lbSkpIHtcbiAgICAgICAgW10uc3BsaWNlLmNhbGwoY3VyLCBpLCAxKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodmFsdWVzWzBdIGluc3RhbmNlb2YgQXJyYXlTdWJkb2N1bWVudCkge1xuICAgICAgdGhpcy5fcmVnaXN0ZXJBdG9taWMoJyRwdWxsRG9jcycsIHZhbHVlcy5tYXAoZnVuY3Rpb24odikge1xuICAgICAgICBjb25zdCBfaWQgPSB2LiRfX2dldFZhbHVlKCdfaWQnKTtcbiAgICAgICAgaWYgKF9pZCA9PT0gdW5kZWZpbmVkIHx8IHYuJGlzRGVmYXVsdCgnX2lkJykpIHtcbiAgICAgICAgICByZXR1cm4gdjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX2lkO1xuICAgICAgfSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9yZWdpc3RlckF0b21pYygnJHB1bGxBbGwnLCB2YWx1ZXMpO1xuICAgIH1cblxuXG4gICAgLy8gTWlnaHQgaGF2ZSBtb2RpZmllZCBjaGlsZCBwYXRocyBhbmQgdGhlbiBwdWxsZWQsIGxpa2VcbiAgICAvLyBgZG9jLmNoaWxkcmVuWzFdLm5hbWUgPSAndGVzdCc7YCBmb2xsb3dlZCBieVxuICAgIC8vIGBkb2MuY2hpbGRyZW4ucmVtb3ZlKGRvYy5jaGlsZHJlblswXSk7YC4gSW4gdGhpcyBjYXNlIHdlIGZhbGwgYmFja1xuICAgIC8vIHRvIGEgYCRzZXRgIG9uIHRoZSB3aG9sZSBhcnJheS4gU2VlICMzNTExXG4gICAgaWYgKGNsZWFuTW9kaWZpZWRTdWJwYXRocyh0aGlzW2FycmF5UGFyZW50U3ltYm9sXSwgdGhpc1thcnJheVBhdGhTeW1ib2xdKSA+IDApIHtcbiAgICAgIHRoaXMuX3JlZ2lzdGVyQXRvbWljKCckc2V0JywgdGhpcyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFdyYXBzIFtgQXJyYXkjcHVzaGBdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0FycmF5L3B1c2gpIHdpdGggcHJvcGVyIGNoYW5nZSB0cmFja2luZy5cbiAgICpcbiAgICogIyMjIyBFeGFtcGxlOlxuICAgKlxuICAgKiAgICAgY29uc3Qgc2NoZW1hID0gU2NoZW1hKHsgbnVtczogW051bWJlcl0gfSk7XG4gICAqICAgICBjb25zdCBNb2RlbCA9IG1vbmdvb3NlLm1vZGVsKCdUZXN0Jywgc2NoZW1hKTtcbiAgICpcbiAgICogICAgIGNvbnN0IGRvYyA9IGF3YWl0IE1vZGVsLmNyZWF0ZSh7IG51bXM6IFszLCA0XSB9KTtcbiAgICogICAgIGRvYy5udW1zLnB1c2goNSk7IC8vIEFkZCA1IHRvIHRoZSBlbmQgb2YgdGhlIGFycmF5XG4gICAqICAgICBhd2FpdCBkb2Muc2F2ZSgpO1xuICAgKlxuICAgKiAgICAgLy8gWW91IGNhbiBhbHNvIHBhc3MgYW4gb2JqZWN0IHdpdGggYCRlYWNoYCBhcyB0aGVcbiAgICogICAgIC8vIGZpcnN0IHBhcmFtZXRlciB0byB1c2UgTW9uZ29EQidzIGAkcG9zaXRpb25gXG4gICAqICAgICBkb2MubnVtcy5wdXNoKHtcbiAgICogICAgICAgJGVhY2g6IFsxLCAyXSxcbiAgICogICAgICAgJHBvc2l0aW9uOiAwXG4gICAqICAgICB9KTtcbiAgICogICAgIGRvYy5udW1zOyAvLyBbMSwgMiwgMywgNCwgNV1cbiAgICpcbiAgICogQHBhcmFtIHsuLi5PYmplY3R9IFthcmdzXVxuICAgKiBAYXBpIHB1YmxpY1xuICAgKiBAbWV0aG9kIHB1c2hcbiAgICogQG1lbWJlck9mIE1vbmdvb3NlQXJyYXlcbiAgICovXG5cbiAgcHVzaCgpIHtcbiAgICBsZXQgdmFsdWVzID0gYXJndW1lbnRzO1xuICAgIGxldCBhdG9taWMgPSB2YWx1ZXM7XG4gICAgY29uc3QgaXNPdmVyd3JpdGUgPSB2YWx1ZXNbMF0gIT0gbnVsbCAmJlxuICAgICAgdXRpbHMuaGFzVXNlckRlZmluZWRQcm9wZXJ0eSh2YWx1ZXNbMF0sICckZWFjaCcpO1xuICAgIGNvbnN0IGFyciA9IHV0aWxzLmlzTW9uZ29vc2VBcnJheSh0aGlzKSA/IHRoaXMuX19hcnJheSA6IHRoaXM7XG4gICAgaWYgKGlzT3ZlcndyaXRlKSB7XG4gICAgICBhdG9taWMgPSB2YWx1ZXNbMF07XG4gICAgICB2YWx1ZXMgPSB2YWx1ZXNbMF0uJGVhY2g7XG4gICAgfVxuXG4gICAgaWYgKHRoaXNbYXJyYXlTY2hlbWFTeW1ib2xdID09IG51bGwpIHtcbiAgICAgIHJldHVybiBfYmFzZVB1c2guYXBwbHkodGhpcywgdmFsdWVzKTtcbiAgICB9XG5cbiAgICBfY2hlY2tNYW51YWxQb3B1bGF0aW9uKHRoaXMsIHZhbHVlcyk7XG5cbiAgICB2YWx1ZXMgPSBbXS5tYXAuY2FsbCh2YWx1ZXMsIHRoaXMuX21hcENhc3QsIHRoaXMpO1xuICAgIGxldCByZXQ7XG4gICAgY29uc3QgYXRvbWljcyA9IHRoaXNbYXJyYXlBdG9taWNzU3ltYm9sXTtcbiAgICB0aGlzLl9tYXJrTW9kaWZpZWQoKTtcbiAgICBpZiAoaXNPdmVyd3JpdGUpIHtcbiAgICAgIGF0b21pYy4kZWFjaCA9IHZhbHVlcztcblxuICAgICAgaWYgKChhdG9taWNzLiRwdXNoICYmIGF0b21pY3MuJHB1c2guJGVhY2ggJiYgYXRvbWljcy4kcHVzaC4kZWFjaC5sZW5ndGggfHwgMCkgIT09IDAgJiZcbiAgICAgICAgICBhdG9taWNzLiRwdXNoLiRwb3NpdGlvbiAhPSBhdG9taWMuJHBvc2l0aW9uKSB7XG4gICAgICAgIHRocm93IG5ldyBNb25nb29zZUVycm9yKCdDYW5ub3QgY2FsbCBgQXJyYXkjcHVzaCgpYCBtdWx0aXBsZSB0aW1lcyAnICtcbiAgICAgICAgICAnd2l0aCBkaWZmZXJlbnQgYCRwb3NpdGlvbmAnKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGF0b21pYy4kcG9zaXRpb24gIT0gbnVsbCkge1xuICAgICAgICBbXS5zcGxpY2UuYXBwbHkoYXJyLCBbYXRvbWljLiRwb3NpdGlvbiwgMF0uY29uY2F0KHZhbHVlcykpO1xuICAgICAgICByZXQgPSB0aGlzLmxlbmd0aDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldCA9IFtdLnB1c2guYXBwbHkoYXJyLCB2YWx1ZXMpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoKGF0b21pY3MuJHB1c2ggJiYgYXRvbWljcy4kcHVzaC4kZWFjaCAmJiBhdG9taWNzLiRwdXNoLiRlYWNoLmxlbmd0aCB8fCAwKSAhPT0gMCAmJlxuICAgICAgICAgIGF0b21pY3MuJHB1c2guJHBvc2l0aW9uICE9IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IE1vbmdvb3NlRXJyb3IoJ0Nhbm5vdCBjYWxsIGBBcnJheSNwdXNoKClgIG11bHRpcGxlIHRpbWVzICcgK1xuICAgICAgICAgICd3aXRoIGRpZmZlcmVudCBgJHBvc2l0aW9uYCcpO1xuICAgICAgfVxuICAgICAgYXRvbWljID0gdmFsdWVzO1xuICAgICAgcmV0ID0gX2Jhc2VQdXNoLmFwcGx5KGFyciwgdmFsdWVzKTtcbiAgICB9XG5cbiAgICB0aGlzLl9yZWdpc3RlckF0b21pYygnJHB1c2gnLCBhdG9taWMpO1xuICAgIHJldHVybiByZXQ7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEFsaWFzIG9mIFtwdWxsXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvYXBpL2FycmF5Lmh0bWwjTW9uZ29vc2VBcnJheS5wcm90b3R5cGUucHVsbCgpKVxuICAgKlxuICAgKiBAc2VlIE1vbmdvb3NlQXJyYXkjcHVsbCBodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvYXBpL2FycmF5Lmh0bWwjTW9uZ29vc2VBcnJheS5wcm90b3R5cGUucHVsbCgpXG4gICAqIEBzZWUgbW9uZ29kYiBodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9yZWZlcmVuY2Uvb3BlcmF0b3IvdXBkYXRlL3B1bGwvXG4gICAqIEBhcGkgcHVibGljXG4gICAqIEBtZW1iZXJPZiBNb25nb29zZUFycmF5XG4gICAqIEBpbnN0YW5jZVxuICAgKiBAbWV0aG9kIHJlbW92ZVxuICAgKi9cblxuICByZW1vdmUoKSB7XG4gICAgcmV0dXJuIHRoaXMucHVsbC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBjYXN0ZWQgYHZhbGAgYXQgaW5kZXggYGlgIGFuZCBtYXJrcyB0aGUgYXJyYXkgbW9kaWZpZWQuXG4gICAqXG4gICAqICMjIyMgRXhhbXBsZTpcbiAgICpcbiAgICogICAgIC8vIGdpdmVuIGRvY3VtZW50cyBiYXNlZCBvbiB0aGUgZm9sbG93aW5nXG4gICAqICAgICBjb25zdCBEb2MgPSBtb25nb29zZS5tb2RlbCgnRG9jJywgbmV3IFNjaGVtYSh7IGFycmF5OiBbTnVtYmVyXSB9KSk7XG4gICAqXG4gICAqICAgICBjb25zdCBkb2MgPSBuZXcgRG9jKHsgYXJyYXk6IFsyLDMsNF0gfSlcbiAgICpcbiAgICogICAgIGNvbnNvbGUubG9nKGRvYy5hcnJheSkgLy8gWzIsMyw0XVxuICAgKlxuICAgKiAgICAgZG9jLmFycmF5LnNldCgxLFwiNVwiKTtcbiAgICogICAgIGNvbnNvbGUubG9nKGRvYy5hcnJheSk7IC8vIFsyLDUsNF0gLy8gcHJvcGVybHkgY2FzdCB0byBudW1iZXJcbiAgICogICAgIGRvYy5zYXZlKCkgLy8gdGhlIGNoYW5nZSBpcyBzYXZlZFxuICAgKlxuICAgKiAgICAgLy8gVlMgbm90IHVzaW5nIGFycmF5I3NldFxuICAgKiAgICAgZG9jLmFycmF5WzFdID0gXCI1XCI7XG4gICAqICAgICBjb25zb2xlLmxvZyhkb2MuYXJyYXkpOyAvLyBbMixcIjVcIiw0XSAvLyBubyBjYXN0aW5nXG4gICAqICAgICBkb2Muc2F2ZSgpIC8vIGNoYW5nZSBpcyBub3Qgc2F2ZWRcbiAgICpcbiAgICogQHJldHVybiB7QXJyYXl9IHRoaXNcbiAgICogQGFwaSBwdWJsaWNcbiAgICogQG1ldGhvZCBzZXRcbiAgICogQG1lbWJlck9mIE1vbmdvb3NlQXJyYXlcbiAgICovXG5cbiAgc2V0KGksIHZhbCwgc2tpcE1vZGlmaWVkKSB7XG4gICAgY29uc3QgYXJyID0gdGhpcy5fX2FycmF5O1xuICAgIGlmIChza2lwTW9kaWZpZWQpIHtcbiAgICAgIGFycltpXSA9IHZhbDtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBjb25zdCB2YWx1ZSA9IG1ldGhvZHMuX2Nhc3QuY2FsbCh0aGlzLCB2YWwsIGkpO1xuICAgIG1ldGhvZHMuX21hcmtNb2RpZmllZC5jYWxsKHRoaXMsIGkpO1xuICAgIGFycltpXSA9IHZhbHVlO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8qKlxuICAgKiBXcmFwcyBbYEFycmF5I3NoaWZ0YF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQXJyYXkvdW5zaGlmdCkgd2l0aCBwcm9wZXIgY2hhbmdlIHRyYWNraW5nLlxuICAgKlxuICAgKiAjIyMjIEV4YW1wbGU6XG4gICAqXG4gICAqICAgICBkb2MuYXJyYXkgPSBbMiwzXTtcbiAgICogICAgIGNvbnN0IHJlcyA9IGRvYy5hcnJheS5zaGlmdCgpO1xuICAgKiAgICAgY29uc29sZS5sb2cocmVzKSAvLyAyXG4gICAqICAgICBjb25zb2xlLmxvZyhkb2MuYXJyYXkpIC8vIFszXVxuICAgKlxuICAgKiAjIyMjIE5vdGU6XG4gICAqXG4gICAqIF9tYXJrcyB0aGUgZW50aXJlIGFycmF5IGFzIG1vZGlmaWVkLCB3aGljaCBpZiBzYXZlZCwgd2lsbCBzdG9yZSBpdCBhcyBhIGAkc2V0YCBvcGVyYXRpb24sIHBvdGVudGlhbGx5IG92ZXJ3cml0dGluZyBhbnkgY2hhbmdlcyB0aGF0IGhhcHBlbiBiZXR3ZWVuIHdoZW4geW91IHJldHJpZXZlZCB0aGUgb2JqZWN0IGFuZCB3aGVuIHlvdSBzYXZlIGl0Ll9cbiAgICpcbiAgICogQGFwaSBwdWJsaWNcbiAgICogQG1ldGhvZCBzaGlmdFxuICAgKiBAbWVtYmVyT2YgTW9uZ29vc2VBcnJheVxuICAgKi9cblxuICBzaGlmdCgpIHtcbiAgICBjb25zdCBhcnIgPSB1dGlscy5pc01vbmdvb3NlQXJyYXkodGhpcykgPyB0aGlzLl9fYXJyYXkgOiB0aGlzO1xuICAgIHRoaXMuX21hcmtNb2RpZmllZCgpO1xuICAgIGNvbnN0IHJldCA9IFtdLnNoaWZ0LmNhbGwoYXJyKTtcbiAgICB0aGlzLl9yZWdpc3RlckF0b21pYygnJHNldCcsIHRoaXMpO1xuICAgIHJldHVybiByZXQ7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFdyYXBzIFtgQXJyYXkjc29ydGBdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0FycmF5L3NvcnQpIHdpdGggcHJvcGVyIGNoYW5nZSB0cmFja2luZy5cbiAgICpcbiAgICogIyMjIyBOb3RlOlxuICAgKlxuICAgKiBfbWFya3MgdGhlIGVudGlyZSBhcnJheSBhcyBtb2RpZmllZCwgd2hpY2ggaWYgc2F2ZWQsIHdpbGwgc3RvcmUgaXQgYXMgYSBgJHNldGAgb3BlcmF0aW9uLCBwb3RlbnRpYWxseSBvdmVyd3JpdHRpbmcgYW55IGNoYW5nZXMgdGhhdCBoYXBwZW4gYmV0d2VlbiB3aGVuIHlvdSByZXRyaWV2ZWQgdGhlIG9iamVjdCBhbmQgd2hlbiB5b3Ugc2F2ZSBpdC5fXG4gICAqXG4gICAqIEBhcGkgcHVibGljXG4gICAqIEBtZXRob2Qgc29ydFxuICAgKiBAbWVtYmVyT2YgTW9uZ29vc2VBcnJheVxuICAgKiBAc2VlIE1hc3RlcmluZ0pTOiBBcnJheSBzb3J0IGh0dHBzOi8vbWFzdGVyaW5nanMuaW8vdHV0b3JpYWxzL2Z1bmRhbWVudGFscy9hcnJheS1zb3J0XG4gICAqL1xuXG4gIHNvcnQoKSB7XG4gICAgY29uc3QgYXJyID0gdXRpbHMuaXNNb25nb29zZUFycmF5KHRoaXMpID8gdGhpcy5fX2FycmF5IDogdGhpcztcbiAgICBjb25zdCByZXQgPSBbXS5zb3J0LmFwcGx5KGFyciwgYXJndW1lbnRzKTtcbiAgICB0aGlzLl9yZWdpc3RlckF0b21pYygnJHNldCcsIHRoaXMpO1xuICAgIHJldHVybiByZXQ7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFdyYXBzIFtgQXJyYXkjc3BsaWNlYF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQXJyYXkvc3BsaWNlKSB3aXRoIHByb3BlciBjaGFuZ2UgdHJhY2tpbmcgYW5kIGNhc3RpbmcuXG4gICAqXG4gICAqICMjIyMgTm90ZTpcbiAgICpcbiAgICogX21hcmtzIHRoZSBlbnRpcmUgYXJyYXkgYXMgbW9kaWZpZWQsIHdoaWNoIGlmIHNhdmVkLCB3aWxsIHN0b3JlIGl0IGFzIGEgYCRzZXRgIG9wZXJhdGlvbiwgcG90ZW50aWFsbHkgb3ZlcndyaXR0aW5nIGFueSBjaGFuZ2VzIHRoYXQgaGFwcGVuIGJldHdlZW4gd2hlbiB5b3UgcmV0cmlldmVkIHRoZSBvYmplY3QgYW5kIHdoZW4geW91IHNhdmUgaXQuX1xuICAgKlxuICAgKiBAYXBpIHB1YmxpY1xuICAgKiBAbWV0aG9kIHNwbGljZVxuICAgKiBAbWVtYmVyT2YgTW9uZ29vc2VBcnJheVxuICAgKiBAc2VlIE1hc3RlcmluZ0pTOiBBcnJheSBzcGxpY2UgaHR0cHM6Ly9tYXN0ZXJpbmdqcy5pby90dXRvcmlhbHMvZnVuZGFtZW50YWxzL2FycmF5LXNwbGljZVxuICAgKi9cblxuICBzcGxpY2UoKSB7XG4gICAgbGV0IHJldDtcbiAgICBjb25zdCBhcnIgPSB1dGlscy5pc01vbmdvb3NlQXJyYXkodGhpcykgPyB0aGlzLl9fYXJyYXkgOiB0aGlzO1xuXG4gICAgdGhpcy5fbWFya01vZGlmaWVkKCk7XG4gICAgX2NoZWNrTWFudWFsUG9wdWxhdGlvbih0aGlzLCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpKTtcblxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICBsZXQgdmFscztcbiAgICAgIGlmICh0aGlzW2FycmF5U2NoZW1hU3ltYm9sXSA9PSBudWxsKSB7XG4gICAgICAgIHZhbHMgPSBhcmd1bWVudHM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YWxzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgdmFsc1tpXSA9IGkgPCAyID9cbiAgICAgICAgICAgIGFyZ3VtZW50c1tpXSA6XG4gICAgICAgICAgICB0aGlzLl9jYXN0KGFyZ3VtZW50c1tpXSwgYXJndW1lbnRzWzBdICsgKGkgLSAyKSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0ID0gW10uc3BsaWNlLmFwcGx5KGFyciwgdmFscyk7XG4gICAgICB0aGlzLl9yZWdpc3RlckF0b21pYygnJHNldCcsIHRoaXMpO1xuICAgIH1cblxuICAgIHJldHVybiByZXQ7XG4gIH0sXG5cbiAgLyohXG4gICAqIGlnbm9yZVxuICAgKi9cblxuICB0b0JTT04oKSB7XG4gICAgcmV0dXJuIHRoaXMudG9PYmplY3QoaW50ZXJuYWxUb09iamVjdE9wdGlvbnMpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgbmF0aXZlIGpzIEFycmF5LlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgKiBAcmV0dXJuIHtBcnJheX1cbiAgICogQGFwaSBwdWJsaWNcbiAgICogQG1ldGhvZCB0b09iamVjdFxuICAgKiBAbWVtYmVyT2YgTW9uZ29vc2VBcnJheVxuICAgKi9cblxuICB0b09iamVjdChvcHRpb25zKSB7XG4gICAgY29uc3QgYXJyID0gdXRpbHMuaXNNb25nb29zZUFycmF5KHRoaXMpID8gdGhpcy5fX2FycmF5IDogdGhpcztcbiAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmRlcG9wdWxhdGUpIHtcbiAgICAgIG9wdGlvbnMgPSBjbG9uZShvcHRpb25zKTtcbiAgICAgIG9wdGlvbnMuX2lzTmVzdGVkID0gdHJ1ZTtcbiAgICAgIC8vIEVuc3VyZSByZXR1cm4gdmFsdWUgaXMgYSB2YW5pbGxhIGFycmF5LCBiZWNhdXNlIGluIE5vZGUuanMgNisgYG1hcCgpYFxuICAgICAgLy8gaXMgc21hcnQgZW5vdWdoIHRvIHVzZSB0aGUgaW5oZXJpdGVkIGFycmF5J3MgY29uc3RydWN0b3IuXG4gICAgICByZXR1cm4gW10uY29uY2F0KGFycikubWFwKGZ1bmN0aW9uKGRvYykge1xuICAgICAgICByZXR1cm4gZG9jIGluc3RhbmNlb2YgRG9jdW1lbnRcbiAgICAgICAgICA/IGRvYy50b09iamVjdChvcHRpb25zKVxuICAgICAgICAgIDogZG9jO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIFtdLmNvbmNhdChhcnIpO1xuICB9LFxuXG4gICR0b09iamVjdCgpIHtcbiAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci5wcm90b3R5cGUudG9PYmplY3QuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfSxcbiAgLyoqXG4gICAqIFdyYXBzIFtgQXJyYXkjdW5zaGlmdGBdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0FycmF5L3Vuc2hpZnQpIHdpdGggcHJvcGVyIGNoYW5nZSB0cmFja2luZy5cbiAgICpcbiAgICogIyMjIyBOb3RlOlxuICAgKlxuICAgKiBfbWFya3MgdGhlIGVudGlyZSBhcnJheSBhcyBtb2RpZmllZCwgd2hpY2ggaWYgc2F2ZWQsIHdpbGwgc3RvcmUgaXQgYXMgYSBgJHNldGAgb3BlcmF0aW9uLCBwb3RlbnRpYWxseSBvdmVyd3JpdGluZyBhbnkgY2hhbmdlcyB0aGF0IGhhcHBlbiBiZXR3ZWVuIHdoZW4geW91IHJldHJpZXZlZCB0aGUgb2JqZWN0IGFuZCB3aGVuIHlvdSBzYXZlIGl0Ll9cbiAgICpcbiAgICogQGFwaSBwdWJsaWNcbiAgICogQG1ldGhvZCB1bnNoaWZ0XG4gICAqIEBtZW1iZXJPZiBNb25nb29zZUFycmF5XG4gICAqL1xuXG4gIHVuc2hpZnQoKSB7XG4gICAgX2NoZWNrTWFudWFsUG9wdWxhdGlvbih0aGlzLCBhcmd1bWVudHMpO1xuXG4gICAgbGV0IHZhbHVlcztcbiAgICBpZiAodGhpc1thcnJheVNjaGVtYVN5bWJvbF0gPT0gbnVsbCkge1xuICAgICAgdmFsdWVzID0gYXJndW1lbnRzO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZXMgPSBbXS5tYXAuY2FsbChhcmd1bWVudHMsIHRoaXMuX2Nhc3QsIHRoaXMpO1xuICAgIH1cblxuICAgIGNvbnN0IGFyciA9IHV0aWxzLmlzTW9uZ29vc2VBcnJheSh0aGlzKSA/IHRoaXMuX19hcnJheSA6IHRoaXM7XG4gICAgdGhpcy5fbWFya01vZGlmaWVkKCk7XG4gICAgW10udW5zaGlmdC5hcHBseShhcnIsIHZhbHVlcyk7XG4gICAgdGhpcy5fcmVnaXN0ZXJBdG9taWMoJyRzZXQnLCB0aGlzKTtcbiAgICByZXR1cm4gdGhpcy5sZW5ndGg7XG4gIH1cbn07XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxuZnVuY3Rpb24gX2lzQWxsU3ViZG9jcyhkb2NzLCByZWYpIHtcbiAgaWYgKCFyZWYpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBmb3IgKGNvbnN0IGFyZyBvZiBkb2NzKSB7XG4gICAgaWYgKGFyZyA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IG1vZGVsID0gYXJnLmNvbnN0cnVjdG9yO1xuICAgIGlmICghKGFyZyBpbnN0YW5jZW9mIERvY3VtZW50KSB8fFxuICAgICAgKG1vZGVsLm1vZGVsTmFtZSAhPT0gcmVmICYmIG1vZGVsLmJhc2VNb2RlbE5hbWUgIT09IHJlZikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuLyohXG4gKiBNaW5pbWl6ZSBfanVzdF8gZW1wdHkgb2JqZWN0cyBhbG9uZyB0aGUgcGF0aCBjaGFpbiBzcGVjaWZpZWRcbiAqIGJ5IGBwYXJ0c2AsIGlnbm9yaW5nIGFsbCBvdGhlciBwYXRocy4gVXNlZnVsIGluIGNhc2VzIHdoZXJlXG4gKiB5b3Ugd2FudCB0byBtaW5pbWl6ZSBhZnRlciB1bnNldHRpbmcgYSBwYXRoLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgY29uc3Qgb2JqID0geyBmb286IHsgYmFyOiB7IGJhejoge30gfSB9LCBhOiB7fSB9O1xuICogICAgIF9taW5pbWl6ZVBhdGgob2JqLCAnZm9vLmJhci5iYXonKTtcbiAqICAgICBvYmo7IC8vIHsgYToge30gfVxuICovXG5cbmZ1bmN0aW9uIF9taW5pbWl6ZVBhdGgob2JqLCBwYXJ0cywgaSkge1xuICBpZiAodHlwZW9mIHBhcnRzID09PSAnc3RyaW5nJykge1xuICAgIGlmIChwYXJ0cy5pbmRleE9mKCcuJykgPT09IC0xKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgcGFydHMgPSBtcGF0aC5zdHJpbmdUb1BhcnRzKHBhcnRzKTtcbiAgfVxuICBpID0gaSB8fCAwO1xuICBpZiAoaSA+PSBwYXJ0cy5sZW5ndGgpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKG9iaiA9PSBudWxsIHx8IHR5cGVvZiBvYmogIT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgX21pbmltaXplUGF0aChvYmpbcGFydHNbMF1dLCBwYXJ0cywgaSArIDEpO1xuICBpZiAob2JqW3BhcnRzWzBdXSAhPSBudWxsICYmIHR5cGVvZiBvYmpbcGFydHNbMF1dID09PSAnb2JqZWN0JyAmJiBPYmplY3Qua2V5cyhvYmpbcGFydHNbMF1dKS5sZW5ndGggPT09IDApIHtcbiAgICBkZWxldGUgb2JqW3BhcnRzWzBdXTtcbiAgfVxufVxuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cbmZ1bmN0aW9uIF9jaGVja01hbnVhbFBvcHVsYXRpb24oYXJyLCBkb2NzKSB7XG4gIGNvbnN0IHJlZiA9IGFyciA9PSBudWxsID9cbiAgICBudWxsIDpcbiAgICBhcnJbYXJyYXlTY2hlbWFTeW1ib2xdICYmIGFyclthcnJheVNjaGVtYVN5bWJvbF0uY2FzdGVyICYmIGFyclthcnJheVNjaGVtYVN5bWJvbF0uY2FzdGVyLm9wdGlvbnMgJiYgYXJyW2FycmF5U2NoZW1hU3ltYm9sXS5jYXN0ZXIub3B0aW9ucy5yZWYgfHwgbnVsbDtcbiAgaWYgKGFyci5sZW5ndGggPT09IDAgJiZcbiAgICAgIGRvY3MubGVuZ3RoICE9PSAwKSB7XG4gICAgaWYgKF9pc0FsbFN1YmRvY3MoZG9jcywgcmVmKSkge1xuICAgICAgYXJyW2FycmF5UGFyZW50U3ltYm9sXS4kcG9wdWxhdGVkKGFyclthcnJheVBhdGhTeW1ib2xdLCBbXSwge1xuICAgICAgICBbcG9wdWxhdGVNb2RlbFN5bWJvbF06IGRvY3NbMF0uY29uc3RydWN0b3JcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxufVxuXG5jb25zdCByZXR1cm5WYW5pbGxhQXJyYXlNZXRob2RzID0gW1xuICAnZmlsdGVyJyxcbiAgJ2ZsYXQnLFxuICAnZmxhdE1hcCcsXG4gICdtYXAnLFxuICAnc2xpY2UnXG5dO1xuZm9yIChjb25zdCBtZXRob2Qgb2YgcmV0dXJuVmFuaWxsYUFycmF5TWV0aG9kcykge1xuICBpZiAoQXJyYXkucHJvdG90eXBlW21ldGhvZF0gPT0gbnVsbCkge1xuICAgIGNvbnRpbnVlO1xuICB9XG5cbiAgbWV0aG9kc1ttZXRob2RdID0gZnVuY3Rpb24oKSB7XG4gICAgY29uc3QgX2FyciA9IHV0aWxzLmlzTW9uZ29vc2VBcnJheSh0aGlzKSA/IHRoaXMuX19hcnJheSA6IHRoaXM7XG4gICAgY29uc3QgYXJyID0gW10uY29uY2F0KF9hcnIpO1xuXG4gICAgcmV0dXJuIGFyclttZXRob2RdLmFwcGx5KGFyciwgYXJndW1lbnRzKTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtZXRob2RzO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../server/node_modules/mongoose/lib/types/array/methods/index.js\n");

/***/ }),

/***/ "../server/node_modules/mongoose/lib/types/arraySubdocument.js":
/*!*********************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/types/arraySubdocument.js ***!
  \*********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*!\n * Module dependencies.\n */\n\n\n\nconst EventEmitter = (__webpack_require__(/*! events */ \"events\").EventEmitter);\nconst Subdocument = __webpack_require__(/*! ./subdocument */ \"../server/node_modules/mongoose/lib/types/subdocument.js\");\nconst utils = __webpack_require__(/*! ../utils */ \"../server/node_modules/mongoose/lib/utils.js\");\n\nconst documentArrayParent = (__webpack_require__(/*! ../helpers/symbols */ \"../server/node_modules/mongoose/lib/helpers/symbols.js\").documentArrayParent);\n\n/**\n * A constructor.\n *\n * @param {Object} obj js object returned from the db\n * @param {MongooseDocumentArray} parentArr the parent array of this document\n * @param {Boolean} skipId\n * @param {Object} fields\n * @param {Number} index\n * @inherits Document\n * @api private\n */\n\nfunction ArraySubdocument(obj, parentArr, skipId, fields, index) {\n  if (utils.isMongooseDocumentArray(parentArr)) {\n    this.__parentArray = parentArr;\n    this[documentArrayParent] = parentArr.$parent();\n  } else {\n    this.__parentArray = undefined;\n    this[documentArrayParent] = undefined;\n  }\n  this.$setIndex(index);\n  this.$__parent = this[documentArrayParent];\n\n  let options;\n  if (typeof skipId === 'object' && skipId != null) {\n    options = { isNew: true, ...skipId };\n    skipId = undefined;\n  } else {\n    options = { isNew: true };\n  }\n\n  Subdocument.call(this, obj, fields, this[documentArrayParent], skipId, options);\n}\n\n/*!\n * Inherit from Subdocument\n */\nArraySubdocument.prototype = Object.create(Subdocument.prototype);\nArraySubdocument.prototype.constructor = ArraySubdocument;\n\nObject.defineProperty(ArraySubdocument.prototype, '$isSingleNested', {\n  configurable: false,\n  writable: false,\n  value: false\n});\n\nObject.defineProperty(ArraySubdocument.prototype, '$isDocumentArrayElement', {\n  configurable: false,\n  writable: false,\n  value: true\n});\n\nfor (const i in EventEmitter.prototype) {\n  ArraySubdocument[i] = EventEmitter.prototype[i];\n}\n\n/*!\n * ignore\n */\n\nArraySubdocument.prototype.$setIndex = function(index) {\n  this.__index = index;\n\n  if (this.$__ != null && this.$__.validationError != null) {\n    const keys = Object.keys(this.$__.validationError.errors);\n    for (const key of keys) {\n      this.invalidate(key, this.$__.validationError.errors[key]);\n    }\n  }\n};\n\n/*!\n * ignore\n */\n\nArraySubdocument.prototype.populate = function() {\n  throw new Error('Mongoose does not support calling populate() on nested ' +\n    'docs. Instead of `doc.arr[0].populate(\"path\")`, use ' +\n    '`doc.populate(\"arr.0.path\")`');\n};\n\n/*!\n * ignore\n */\n\nArraySubdocument.prototype.$__removeFromParent = function() {\n  const _id = this._doc._id;\n  if (!_id) {\n    throw new Error('For your own good, Mongoose does not know ' +\n      'how to remove an ArraySubdocument that has no _id');\n  }\n  this.__parentArray.pull({ _id: _id });\n};\n\n/**\n * Returns the full path to this document. If optional `path` is passed, it is appended to the full path.\n *\n * @param {String} [path]\n * @param {Boolean} [skipIndex] Skip adding the array index. For example `arr.foo` instead of `arr.0.foo`.\n * @return {String}\n * @api private\n * @method $__fullPath\n * @memberOf ArraySubdocument\n * @instance\n */\n\nArraySubdocument.prototype.$__fullPath = function(path, skipIndex) {\n  if (this.__index == null) {\n    return null;\n  }\n  if (!this.$__.fullPath) {\n    this.ownerDocument();\n  }\n\n  if (skipIndex) {\n    return path ?\n      this.$__.fullPath + '.' + path :\n      this.$__.fullPath;\n  }\n\n  return path ?\n    this.$__.fullPath + '.' + this.__index + '.' + path :\n    this.$__.fullPath + '.' + this.__index;\n};\n\n/**\n * Given a path relative to this document, return the path relative\n * to the top-level document.\n * @method $__pathRelativeToParent\n * @memberOf ArraySubdocument\n * @instance\n * @api private\n */\n\nArraySubdocument.prototype.$__pathRelativeToParent = function(path, skipIndex) {\n  if (this.__index == null) {\n    return null;\n  }\n  if (skipIndex) {\n    return path == null ? this.__parentArray.$path() : this.__parentArray.$path() + '.' + path;\n  }\n  if (path == null) {\n    return this.__parentArray.$path() + '.' + this.__index;\n  }\n  return this.__parentArray.$path() + '.' + this.__index + '.' + path;\n};\n\n/**\n * Returns this sub-documents parent document.\n * @method $parent\n * @memberOf ArraySubdocument\n * @instance\n * @api public\n */\n\nArraySubdocument.prototype.$parent = function() {\n  return this[documentArrayParent];\n};\n\n/**\n * Returns this subdocument's parent array.\n *\n * #### Example:\n *\n *     const Test = mongoose.model('Test', new Schema({\n *       docArr: [{ name: String }]\n *     }));\n *     const doc = new Test({ docArr: [{ name: 'test subdoc' }] });\n *\n *     doc.docArr[0].parentArray() === doc.docArr; // true\n *\n * @api public\n * @method parentArray\n * @returns DocumentArray\n */\n\nArraySubdocument.prototype.parentArray = function() {\n  return this.__parentArray;\n};\n\n/*!\n * Module exports.\n */\n\nmodule.exports = ArraySubdocument;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvdHlwZXMvYXJyYXlTdWJkb2N1bWVudC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7O0FBRWE7O0FBRWIscUJBQXFCLDBEQUE4QjtBQUNuRCxvQkFBb0IsbUJBQU8sQ0FBQywrRUFBZTtBQUMzQyxjQUFjLG1CQUFPLENBQUMsOERBQVU7O0FBRWhDLDRCQUE0Qiw2SEFBaUQ7O0FBRTdFO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLHVCQUF1QjtBQUNsQyxXQUFXLFNBQVM7QUFDcEIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0EsSUFBSTtBQUNKLGdCQUFnQjtBQUNoQjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixVQUFVO0FBQ3RDOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFNBQVM7QUFDcEIsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGNBQWM7QUFDbEMsUUFBUTtBQUNSLDhCQUE4QixXQUFXLHFCQUFxQixHQUFHO0FBQ2pFO0FBQ0EsbURBQW1EO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL2NsaWVudC8uLi9zZXJ2ZXIvbm9kZV9tb2R1bGVzL21vbmdvb3NlL2xpYi90eXBlcy9hcnJheVN1YmRvY3VtZW50LmpzPzI1M2IiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuY29uc3QgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyO1xuY29uc3QgU3ViZG9jdW1lbnQgPSByZXF1aXJlKCcuL3N1YmRvY3VtZW50Jyk7XG5jb25zdCB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzJyk7XG5cbmNvbnN0IGRvY3VtZW50QXJyYXlQYXJlbnQgPSByZXF1aXJlKCcuLi9oZWxwZXJzL3N5bWJvbHMnKS5kb2N1bWVudEFycmF5UGFyZW50O1xuXG4vKipcbiAqIEEgY29uc3RydWN0b3IuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9iaiBqcyBvYmplY3QgcmV0dXJuZWQgZnJvbSB0aGUgZGJcbiAqIEBwYXJhbSB7TW9uZ29vc2VEb2N1bWVudEFycmF5fSBwYXJlbnRBcnIgdGhlIHBhcmVudCBhcnJheSBvZiB0aGlzIGRvY3VtZW50XG4gKiBAcGFyYW0ge0Jvb2xlYW59IHNraXBJZFxuICogQHBhcmFtIHtPYmplY3R9IGZpZWxkc1xuICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4XG4gKiBAaW5oZXJpdHMgRG9jdW1lbnRcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIEFycmF5U3ViZG9jdW1lbnQob2JqLCBwYXJlbnRBcnIsIHNraXBJZCwgZmllbGRzLCBpbmRleCkge1xuICBpZiAodXRpbHMuaXNNb25nb29zZURvY3VtZW50QXJyYXkocGFyZW50QXJyKSkge1xuICAgIHRoaXMuX19wYXJlbnRBcnJheSA9IHBhcmVudEFycjtcbiAgICB0aGlzW2RvY3VtZW50QXJyYXlQYXJlbnRdID0gcGFyZW50QXJyLiRwYXJlbnQoKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLl9fcGFyZW50QXJyYXkgPSB1bmRlZmluZWQ7XG4gICAgdGhpc1tkb2N1bWVudEFycmF5UGFyZW50XSA9IHVuZGVmaW5lZDtcbiAgfVxuICB0aGlzLiRzZXRJbmRleChpbmRleCk7XG4gIHRoaXMuJF9fcGFyZW50ID0gdGhpc1tkb2N1bWVudEFycmF5UGFyZW50XTtcblxuICBsZXQgb3B0aW9ucztcbiAgaWYgKHR5cGVvZiBza2lwSWQgPT09ICdvYmplY3QnICYmIHNraXBJZCAhPSBudWxsKSB7XG4gICAgb3B0aW9ucyA9IHsgaXNOZXc6IHRydWUsIC4uLnNraXBJZCB9O1xuICAgIHNraXBJZCA9IHVuZGVmaW5lZDtcbiAgfSBlbHNlIHtcbiAgICBvcHRpb25zID0geyBpc05ldzogdHJ1ZSB9O1xuICB9XG5cbiAgU3ViZG9jdW1lbnQuY2FsbCh0aGlzLCBvYmosIGZpZWxkcywgdGhpc1tkb2N1bWVudEFycmF5UGFyZW50XSwgc2tpcElkLCBvcHRpb25zKTtcbn1cblxuLyohXG4gKiBJbmhlcml0IGZyb20gU3ViZG9jdW1lbnRcbiAqL1xuQXJyYXlTdWJkb2N1bWVudC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFN1YmRvY3VtZW50LnByb3RvdHlwZSk7XG5BcnJheVN1YmRvY3VtZW50LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEFycmF5U3ViZG9jdW1lbnQ7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShBcnJheVN1YmRvY3VtZW50LnByb3RvdHlwZSwgJyRpc1NpbmdsZU5lc3RlZCcsIHtcbiAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgd3JpdGFibGU6IGZhbHNlLFxuICB2YWx1ZTogZmFsc2Vcbn0pO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoQXJyYXlTdWJkb2N1bWVudC5wcm90b3R5cGUsICckaXNEb2N1bWVudEFycmF5RWxlbWVudCcsIHtcbiAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgd3JpdGFibGU6IGZhbHNlLFxuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbmZvciAoY29uc3QgaSBpbiBFdmVudEVtaXR0ZXIucHJvdG90eXBlKSB7XG4gIEFycmF5U3ViZG9jdW1lbnRbaV0gPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlW2ldO1xufVxuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cbkFycmF5U3ViZG9jdW1lbnQucHJvdG90eXBlLiRzZXRJbmRleCA9IGZ1bmN0aW9uKGluZGV4KSB7XG4gIHRoaXMuX19pbmRleCA9IGluZGV4O1xuXG4gIGlmICh0aGlzLiRfXyAhPSBudWxsICYmIHRoaXMuJF9fLnZhbGlkYXRpb25FcnJvciAhPSBudWxsKSB7XG4gICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHRoaXMuJF9fLnZhbGlkYXRpb25FcnJvci5lcnJvcnMpO1xuICAgIGZvciAoY29uc3Qga2V5IG9mIGtleXMpIHtcbiAgICAgIHRoaXMuaW52YWxpZGF0ZShrZXksIHRoaXMuJF9fLnZhbGlkYXRpb25FcnJvci5lcnJvcnNba2V5XSk7XG4gICAgfVxuICB9XG59O1xuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cbkFycmF5U3ViZG9jdW1lbnQucHJvdG90eXBlLnBvcHVsYXRlID0gZnVuY3Rpb24oKSB7XG4gIHRocm93IG5ldyBFcnJvcignTW9uZ29vc2UgZG9lcyBub3Qgc3VwcG9ydCBjYWxsaW5nIHBvcHVsYXRlKCkgb24gbmVzdGVkICcgK1xuICAgICdkb2NzLiBJbnN0ZWFkIG9mIGBkb2MuYXJyWzBdLnBvcHVsYXRlKFwicGF0aFwiKWAsIHVzZSAnICtcbiAgICAnYGRvYy5wb3B1bGF0ZShcImFyci4wLnBhdGhcIilgJyk7XG59O1xuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cbkFycmF5U3ViZG9jdW1lbnQucHJvdG90eXBlLiRfX3JlbW92ZUZyb21QYXJlbnQgPSBmdW5jdGlvbigpIHtcbiAgY29uc3QgX2lkID0gdGhpcy5fZG9jLl9pZDtcbiAgaWYgKCFfaWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZvciB5b3VyIG93biBnb29kLCBNb25nb29zZSBkb2VzIG5vdCBrbm93ICcgK1xuICAgICAgJ2hvdyB0byByZW1vdmUgYW4gQXJyYXlTdWJkb2N1bWVudCB0aGF0IGhhcyBubyBfaWQnKTtcbiAgfVxuICB0aGlzLl9fcGFyZW50QXJyYXkucHVsbCh7IF9pZDogX2lkIH0pO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBmdWxsIHBhdGggdG8gdGhpcyBkb2N1bWVudC4gSWYgb3B0aW9uYWwgYHBhdGhgIGlzIHBhc3NlZCwgaXQgaXMgYXBwZW5kZWQgdG8gdGhlIGZ1bGwgcGF0aC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gW3BhdGhdXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtza2lwSW5kZXhdIFNraXAgYWRkaW5nIHRoZSBhcnJheSBpbmRleC4gRm9yIGV4YW1wbGUgYGFyci5mb29gIGluc3RlYWQgb2YgYGFyci4wLmZvb2AuXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHByaXZhdGVcbiAqIEBtZXRob2QgJF9fZnVsbFBhdGhcbiAqIEBtZW1iZXJPZiBBcnJheVN1YmRvY3VtZW50XG4gKiBAaW5zdGFuY2VcbiAqL1xuXG5BcnJheVN1YmRvY3VtZW50LnByb3RvdHlwZS4kX19mdWxsUGF0aCA9IGZ1bmN0aW9uKHBhdGgsIHNraXBJbmRleCkge1xuICBpZiAodGhpcy5fX2luZGV4ID09IG51bGwpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBpZiAoIXRoaXMuJF9fLmZ1bGxQYXRoKSB7XG4gICAgdGhpcy5vd25lckRvY3VtZW50KCk7XG4gIH1cblxuICBpZiAoc2tpcEluZGV4KSB7XG4gICAgcmV0dXJuIHBhdGggP1xuICAgICAgdGhpcy4kX18uZnVsbFBhdGggKyAnLicgKyBwYXRoIDpcbiAgICAgIHRoaXMuJF9fLmZ1bGxQYXRoO1xuICB9XG5cbiAgcmV0dXJuIHBhdGggP1xuICAgIHRoaXMuJF9fLmZ1bGxQYXRoICsgJy4nICsgdGhpcy5fX2luZGV4ICsgJy4nICsgcGF0aCA6XG4gICAgdGhpcy4kX18uZnVsbFBhdGggKyAnLicgKyB0aGlzLl9faW5kZXg7XG59O1xuXG4vKipcbiAqIEdpdmVuIGEgcGF0aCByZWxhdGl2ZSB0byB0aGlzIGRvY3VtZW50LCByZXR1cm4gdGhlIHBhdGggcmVsYXRpdmVcbiAqIHRvIHRoZSB0b3AtbGV2ZWwgZG9jdW1lbnQuXG4gKiBAbWV0aG9kICRfX3BhdGhSZWxhdGl2ZVRvUGFyZW50XG4gKiBAbWVtYmVyT2YgQXJyYXlTdWJkb2N1bWVudFxuICogQGluc3RhbmNlXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5BcnJheVN1YmRvY3VtZW50LnByb3RvdHlwZS4kX19wYXRoUmVsYXRpdmVUb1BhcmVudCA9IGZ1bmN0aW9uKHBhdGgsIHNraXBJbmRleCkge1xuICBpZiAodGhpcy5fX2luZGV4ID09IG51bGwpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBpZiAoc2tpcEluZGV4KSB7XG4gICAgcmV0dXJuIHBhdGggPT0gbnVsbCA/IHRoaXMuX19wYXJlbnRBcnJheS4kcGF0aCgpIDogdGhpcy5fX3BhcmVudEFycmF5LiRwYXRoKCkgKyAnLicgKyBwYXRoO1xuICB9XG4gIGlmIChwYXRoID09IG51bGwpIHtcbiAgICByZXR1cm4gdGhpcy5fX3BhcmVudEFycmF5LiRwYXRoKCkgKyAnLicgKyB0aGlzLl9faW5kZXg7XG4gIH1cbiAgcmV0dXJuIHRoaXMuX19wYXJlbnRBcnJheS4kcGF0aCgpICsgJy4nICsgdGhpcy5fX2luZGV4ICsgJy4nICsgcGF0aDtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGlzIHN1Yi1kb2N1bWVudHMgcGFyZW50IGRvY3VtZW50LlxuICogQG1ldGhvZCAkcGFyZW50XG4gKiBAbWVtYmVyT2YgQXJyYXlTdWJkb2N1bWVudFxuICogQGluc3RhbmNlXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkFycmF5U3ViZG9jdW1lbnQucHJvdG90eXBlLiRwYXJlbnQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXNbZG9jdW1lbnRBcnJheVBhcmVudF07XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhpcyBzdWJkb2N1bWVudCdzIHBhcmVudCBhcnJheS5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IFRlc3QgPSBtb25nb29zZS5tb2RlbCgnVGVzdCcsIG5ldyBTY2hlbWEoe1xuICogICAgICAgZG9jQXJyOiBbeyBuYW1lOiBTdHJpbmcgfV1cbiAqICAgICB9KSk7XG4gKiAgICAgY29uc3QgZG9jID0gbmV3IFRlc3QoeyBkb2NBcnI6IFt7IG5hbWU6ICd0ZXN0IHN1YmRvYycgfV0gfSk7XG4gKlxuICogICAgIGRvYy5kb2NBcnJbMF0ucGFyZW50QXJyYXkoKSA9PT0gZG9jLmRvY0FycjsgLy8gdHJ1ZVxuICpcbiAqIEBhcGkgcHVibGljXG4gKiBAbWV0aG9kIHBhcmVudEFycmF5XG4gKiBAcmV0dXJucyBEb2N1bWVudEFycmF5XG4gKi9cblxuQXJyYXlTdWJkb2N1bWVudC5wcm90b3R5cGUucGFyZW50QXJyYXkgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX19wYXJlbnRBcnJheTtcbn07XG5cbi8qIVxuICogTW9kdWxlIGV4cG9ydHMuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBBcnJheVN1YmRvY3VtZW50O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../server/node_modules/mongoose/lib/types/arraySubdocument.js\n");

/***/ }),

/***/ "../server/node_modules/mongoose/lib/types/buffer.js":
/*!***********************************************************!*\
  !*** ../server/node_modules/mongoose/lib/types/buffer.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*!\n * Module dependencies.\n */\n\n\n\nconst Binary = (__webpack_require__(/*! bson */ \"../server/node_modules/bson/lib/bson.cjs\").Binary);\nconst utils = __webpack_require__(/*! ../utils */ \"../server/node_modules/mongoose/lib/utils.js\");\n\n/**\n * Mongoose Buffer constructor.\n *\n * Values always have to be passed to the constructor to initialize.\n *\n * @param {Buffer} value\n * @param {String} encode\n * @param {Number} offset\n * @api private\n * @inherits Buffer https://nodejs.org/api/buffer.html\n * @see https://bit.ly/f6CnZU\n */\n\nfunction MongooseBuffer(value, encode, offset) {\n  let val = value;\n  if (value == null) {\n    val = 0;\n  }\n\n  let encoding;\n  let path;\n  let doc;\n\n  if (Array.isArray(encode)) {\n    // internal casting\n    path = encode[0];\n    doc = encode[1];\n  } else {\n    encoding = encode;\n  }\n\n  let buf;\n  if (typeof val === 'number' || val instanceof Number) {\n    buf = Buffer.alloc(val);\n  } else { // string, array or object { type: 'Buffer', data: [...] }\n    buf = Buffer.from(val, encoding, offset);\n  }\n  utils.decorate(buf, MongooseBuffer.mixin);\n  buf.isMongooseBuffer = true;\n\n  // make sure these internal props don't show up in Object.keys()\n  buf[MongooseBuffer.pathSymbol] = path;\n  buf[parentSymbol] = doc;\n\n  buf._subtype = 0;\n  return buf;\n}\n\nconst pathSymbol = Symbol.for('mongoose#Buffer#_path');\nconst parentSymbol = Symbol.for('mongoose#Buffer#_parent');\nMongooseBuffer.pathSymbol = pathSymbol;\n\n/*!\n * Inherit from Buffer.\n */\n\nMongooseBuffer.mixin = {\n\n  /**\n   * Default subtype for the Binary representing this Buffer\n   *\n   * @api private\n   * @property _subtype\n   * @memberOf MongooseBuffer.mixin\n   * @static\n   */\n\n  _subtype: undefined,\n\n  /**\n   * Marks this buffer as modified.\n   *\n   * @api private\n   * @method _markModified\n   * @memberOf MongooseBuffer.mixin\n   * @static\n   */\n\n  _markModified: function() {\n    const parent = this[parentSymbol];\n\n    if (parent) {\n      parent.markModified(this[MongooseBuffer.pathSymbol]);\n    }\n    return this;\n  },\n\n  /**\n   * Writes the buffer.\n   *\n   * @api public\n   * @method write\n   * @memberOf MongooseBuffer.mixin\n   * @static\n   */\n\n  write: function() {\n    const written = Buffer.prototype.write.apply(this, arguments);\n\n    if (written > 0) {\n      this._markModified();\n    }\n\n    return written;\n  },\n\n  /**\n   * Copies the buffer.\n   *\n   * #### Note:\n   *\n   * `Buffer#copy` does not mark `target` as modified so you must copy from a `MongooseBuffer` for it to work as expected. This is a work around since `copy` modifies the target, not this.\n   *\n   * @return {Number} The number of bytes copied.\n   * @param {Buffer} target\n   * @method copy\n   * @memberOf MongooseBuffer.mixin\n   * @static\n   */\n\n  copy: function(target) {\n    const ret = Buffer.prototype.copy.apply(this, arguments);\n\n    if (target && target.isMongooseBuffer) {\n      target._markModified();\n    }\n\n    return ret;\n  }\n};\n\n/*!\n * Compile other Buffer methods marking this buffer as modified.\n */\n\nutils.each(\n  [\n    // node < 0.5\n    'writeUInt8', 'writeUInt16', 'writeUInt32', 'writeInt8', 'writeInt16', 'writeInt32',\n    'writeFloat', 'writeDouble', 'fill',\n    'utf8Write', 'binaryWrite', 'asciiWrite', 'set',\n\n    // node >= 0.5\n    'writeUInt16LE', 'writeUInt16BE', 'writeUInt32LE', 'writeUInt32BE',\n    'writeInt16LE', 'writeInt16BE', 'writeInt32LE', 'writeInt32BE', 'writeFloatLE', 'writeFloatBE', 'writeDoubleLE', 'writeDoubleBE']\n  , function(method) {\n    if (!Buffer.prototype[method]) {\n      return;\n    }\n    MongooseBuffer.mixin[method] = function() {\n      const ret = Buffer.prototype[method].apply(this, arguments);\n      this._markModified();\n      return ret;\n    };\n  });\n\n/**\n * Converts this buffer to its Binary type representation.\n *\n * #### SubTypes:\n *\n *     const bson = require('bson')\n *     bson.BSON_BINARY_SUBTYPE_DEFAULT\n *     bson.BSON_BINARY_SUBTYPE_FUNCTION\n *     bson.BSON_BINARY_SUBTYPE_BYTE_ARRAY\n *     bson.BSON_BINARY_SUBTYPE_UUID\n *     bson.BSON_BINARY_SUBTYPE_MD5\n *     bson.BSON_BINARY_SUBTYPE_USER_DEFINED\n *     doc.buffer.toObject(bson.BSON_BINARY_SUBTYPE_USER_DEFINED);\n *\n * @see bsonspec https://bsonspec.org/#/specification\n * @param {Hex} [subtype]\n * @return {Binary}\n * @api public\n * @method toObject\n * @memberOf MongooseBuffer\n */\n\nMongooseBuffer.mixin.toObject = function(options) {\n  const subtype = typeof options === 'number'\n    ? options\n    : (this._subtype || 0);\n  return new Binary(Buffer.from(this), subtype);\n};\n\nMongooseBuffer.mixin.$toObject = MongooseBuffer.mixin.toObject;\n\n/**\n * Converts this buffer for storage in MongoDB, including subtype\n *\n * @return {Binary}\n * @api public\n * @method toBSON\n * @memberOf MongooseBuffer\n */\n\nMongooseBuffer.mixin.toBSON = function() {\n  return new Binary(this, this._subtype || 0);\n};\n\n/**\n * Determines if this buffer is equals to `other` buffer\n *\n * @param {Buffer} other\n * @return {Boolean}\n * @method equals\n * @memberOf MongooseBuffer\n */\n\nMongooseBuffer.mixin.equals = function(other) {\n  if (!Buffer.isBuffer(other)) {\n    return false;\n  }\n\n  if (this.length !== other.length) {\n    return false;\n  }\n\n  for (let i = 0; i < this.length; ++i) {\n    if (this[i] !== other[i]) {\n      return false;\n    }\n  }\n\n  return true;\n};\n\n/**\n * Sets the subtype option and marks the buffer modified.\n *\n * #### SubTypes:\n *\n *     const bson = require('bson')\n *     bson.BSON_BINARY_SUBTYPE_DEFAULT\n *     bson.BSON_BINARY_SUBTYPE_FUNCTION\n *     bson.BSON_BINARY_SUBTYPE_BYTE_ARRAY\n *     bson.BSON_BINARY_SUBTYPE_UUID\n *     bson.BSON_BINARY_SUBTYPE_MD5\n *     bson.BSON_BINARY_SUBTYPE_USER_DEFINED\n *\n *     doc.buffer.subtype(bson.BSON_BINARY_SUBTYPE_UUID);\n *\n * @see bsonspec https://bsonspec.org/#/specification\n * @param {Hex} subtype\n * @api public\n * @method subtype\n * @memberOf MongooseBuffer\n */\n\nMongooseBuffer.mixin.subtype = function(subtype) {\n  if (typeof subtype !== 'number') {\n    throw new TypeError('Invalid subtype. Expected a number');\n  }\n\n  if (this._subtype !== subtype) {\n    this._markModified();\n  }\n\n  this._subtype = subtype;\n};\n\n/*!\n * Module exports.\n */\n\nMongooseBuffer.Binary = Binary;\n\nmodule.exports = MongooseBuffer;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvdHlwZXMvYnVmZmVyLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTs7QUFFYTs7QUFFYixlQUFlLG9GQUFzQjtBQUNyQyxjQUFjLG1CQUFPLENBQUMsOERBQVU7O0FBRWhDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUksT0FBTyw2QkFBNkI7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZO0FBQ1o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0IsaUJBQWlCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2xpZW50Ly4uL3NlcnZlci9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL3R5cGVzL2J1ZmZlci5qcz82ZDIzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbmNvbnN0IEJpbmFyeSA9IHJlcXVpcmUoJ2Jzb24nKS5CaW5hcnk7XG5jb25zdCB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzJyk7XG5cbi8qKlxuICogTW9uZ29vc2UgQnVmZmVyIGNvbnN0cnVjdG9yLlxuICpcbiAqIFZhbHVlcyBhbHdheXMgaGF2ZSB0byBiZSBwYXNzZWQgdG8gdGhlIGNvbnN0cnVjdG9yIHRvIGluaXRpYWxpemUuXG4gKlxuICogQHBhcmFtIHtCdWZmZXJ9IHZhbHVlXG4gKiBAcGFyYW0ge1N0cmluZ30gZW5jb2RlXG4gKiBAcGFyYW0ge051bWJlcn0gb2Zmc2V0XG4gKiBAYXBpIHByaXZhdGVcbiAqIEBpbmhlcml0cyBCdWZmZXIgaHR0cHM6Ly9ub2RlanMub3JnL2FwaS9idWZmZXIuaHRtbFxuICogQHNlZSBodHRwczovL2JpdC5seS9mNkNuWlVcbiAqL1xuXG5mdW5jdGlvbiBNb25nb29zZUJ1ZmZlcih2YWx1ZSwgZW5jb2RlLCBvZmZzZXQpIHtcbiAgbGV0IHZhbCA9IHZhbHVlO1xuICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgIHZhbCA9IDA7XG4gIH1cblxuICBsZXQgZW5jb2Rpbmc7XG4gIGxldCBwYXRoO1xuICBsZXQgZG9jO1xuXG4gIGlmIChBcnJheS5pc0FycmF5KGVuY29kZSkpIHtcbiAgICAvLyBpbnRlcm5hbCBjYXN0aW5nXG4gICAgcGF0aCA9IGVuY29kZVswXTtcbiAgICBkb2MgPSBlbmNvZGVbMV07XG4gIH0gZWxzZSB7XG4gICAgZW5jb2RpbmcgPSBlbmNvZGU7XG4gIH1cblxuICBsZXQgYnVmO1xuICBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicgfHwgdmFsIGluc3RhbmNlb2YgTnVtYmVyKSB7XG4gICAgYnVmID0gQnVmZmVyLmFsbG9jKHZhbCk7XG4gIH0gZWxzZSB7IC8vIHN0cmluZywgYXJyYXkgb3Igb2JqZWN0IHsgdHlwZTogJ0J1ZmZlcicsIGRhdGE6IFsuLi5dIH1cbiAgICBidWYgPSBCdWZmZXIuZnJvbSh2YWwsIGVuY29kaW5nLCBvZmZzZXQpO1xuICB9XG4gIHV0aWxzLmRlY29yYXRlKGJ1ZiwgTW9uZ29vc2VCdWZmZXIubWl4aW4pO1xuICBidWYuaXNNb25nb29zZUJ1ZmZlciA9IHRydWU7XG5cbiAgLy8gbWFrZSBzdXJlIHRoZXNlIGludGVybmFsIHByb3BzIGRvbid0IHNob3cgdXAgaW4gT2JqZWN0LmtleXMoKVxuICBidWZbTW9uZ29vc2VCdWZmZXIucGF0aFN5bWJvbF0gPSBwYXRoO1xuICBidWZbcGFyZW50U3ltYm9sXSA9IGRvYztcblxuICBidWYuX3N1YnR5cGUgPSAwO1xuICByZXR1cm4gYnVmO1xufVxuXG5jb25zdCBwYXRoU3ltYm9sID0gU3ltYm9sLmZvcignbW9uZ29vc2UjQnVmZmVyI19wYXRoJyk7XG5jb25zdCBwYXJlbnRTeW1ib2wgPSBTeW1ib2wuZm9yKCdtb25nb29zZSNCdWZmZXIjX3BhcmVudCcpO1xuTW9uZ29vc2VCdWZmZXIucGF0aFN5bWJvbCA9IHBhdGhTeW1ib2w7XG5cbi8qIVxuICogSW5oZXJpdCBmcm9tIEJ1ZmZlci5cbiAqL1xuXG5Nb25nb29zZUJ1ZmZlci5taXhpbiA9IHtcblxuICAvKipcbiAgICogRGVmYXVsdCBzdWJ0eXBlIGZvciB0aGUgQmluYXJ5IHJlcHJlc2VudGluZyB0aGlzIEJ1ZmZlclxuICAgKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICogQHByb3BlcnR5IF9zdWJ0eXBlXG4gICAqIEBtZW1iZXJPZiBNb25nb29zZUJ1ZmZlci5taXhpblxuICAgKiBAc3RhdGljXG4gICAqL1xuXG4gIF9zdWJ0eXBlOiB1bmRlZmluZWQsXG5cbiAgLyoqXG4gICAqIE1hcmtzIHRoaXMgYnVmZmVyIGFzIG1vZGlmaWVkLlxuICAgKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICogQG1ldGhvZCBfbWFya01vZGlmaWVkXG4gICAqIEBtZW1iZXJPZiBNb25nb29zZUJ1ZmZlci5taXhpblxuICAgKiBAc3RhdGljXG4gICAqL1xuXG4gIF9tYXJrTW9kaWZpZWQ6IGZ1bmN0aW9uKCkge1xuICAgIGNvbnN0IHBhcmVudCA9IHRoaXNbcGFyZW50U3ltYm9sXTtcblxuICAgIGlmIChwYXJlbnQpIHtcbiAgICAgIHBhcmVudC5tYXJrTW9kaWZpZWQodGhpc1tNb25nb29zZUJ1ZmZlci5wYXRoU3ltYm9sXSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8qKlxuICAgKiBXcml0ZXMgdGhlIGJ1ZmZlci5cbiAgICpcbiAgICogQGFwaSBwdWJsaWNcbiAgICogQG1ldGhvZCB3cml0ZVxuICAgKiBAbWVtYmVyT2YgTW9uZ29vc2VCdWZmZXIubWl4aW5cbiAgICogQHN0YXRpY1xuICAgKi9cblxuICB3cml0ZTogZnVuY3Rpb24oKSB7XG4gICAgY29uc3Qgd3JpdHRlbiA9IEJ1ZmZlci5wcm90b3R5cGUud3JpdGUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuICAgIGlmICh3cml0dGVuID4gMCkge1xuICAgICAgdGhpcy5fbWFya01vZGlmaWVkKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHdyaXR0ZW47XG4gIH0sXG5cbiAgLyoqXG4gICAqIENvcGllcyB0aGUgYnVmZmVyLlxuICAgKlxuICAgKiAjIyMjIE5vdGU6XG4gICAqXG4gICAqIGBCdWZmZXIjY29weWAgZG9lcyBub3QgbWFyayBgdGFyZ2V0YCBhcyBtb2RpZmllZCBzbyB5b3UgbXVzdCBjb3B5IGZyb20gYSBgTW9uZ29vc2VCdWZmZXJgIGZvciBpdCB0byB3b3JrIGFzIGV4cGVjdGVkLiBUaGlzIGlzIGEgd29yayBhcm91bmQgc2luY2UgYGNvcHlgIG1vZGlmaWVzIHRoZSB0YXJnZXQsIG5vdCB0aGlzLlxuICAgKlxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IFRoZSBudW1iZXIgb2YgYnl0ZXMgY29waWVkLlxuICAgKiBAcGFyYW0ge0J1ZmZlcn0gdGFyZ2V0XG4gICAqIEBtZXRob2QgY29weVxuICAgKiBAbWVtYmVyT2YgTW9uZ29vc2VCdWZmZXIubWl4aW5cbiAgICogQHN0YXRpY1xuICAgKi9cblxuICBjb3B5OiBmdW5jdGlvbih0YXJnZXQpIHtcbiAgICBjb25zdCByZXQgPSBCdWZmZXIucHJvdG90eXBlLmNvcHkuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuICAgIGlmICh0YXJnZXQgJiYgdGFyZ2V0LmlzTW9uZ29vc2VCdWZmZXIpIHtcbiAgICAgIHRhcmdldC5fbWFya01vZGlmaWVkKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJldDtcbiAgfVxufTtcblxuLyohXG4gKiBDb21waWxlIG90aGVyIEJ1ZmZlciBtZXRob2RzIG1hcmtpbmcgdGhpcyBidWZmZXIgYXMgbW9kaWZpZWQuXG4gKi9cblxudXRpbHMuZWFjaChcbiAgW1xuICAgIC8vIG5vZGUgPCAwLjVcbiAgICAnd3JpdGVVSW50OCcsICd3cml0ZVVJbnQxNicsICd3cml0ZVVJbnQzMicsICd3cml0ZUludDgnLCAnd3JpdGVJbnQxNicsICd3cml0ZUludDMyJyxcbiAgICAnd3JpdGVGbG9hdCcsICd3cml0ZURvdWJsZScsICdmaWxsJyxcbiAgICAndXRmOFdyaXRlJywgJ2JpbmFyeVdyaXRlJywgJ2FzY2lpV3JpdGUnLCAnc2V0JyxcblxuICAgIC8vIG5vZGUgPj0gMC41XG4gICAgJ3dyaXRlVUludDE2TEUnLCAnd3JpdGVVSW50MTZCRScsICd3cml0ZVVJbnQzMkxFJywgJ3dyaXRlVUludDMyQkUnLFxuICAgICd3cml0ZUludDE2TEUnLCAnd3JpdGVJbnQxNkJFJywgJ3dyaXRlSW50MzJMRScsICd3cml0ZUludDMyQkUnLCAnd3JpdGVGbG9hdExFJywgJ3dyaXRlRmxvYXRCRScsICd3cml0ZURvdWJsZUxFJywgJ3dyaXRlRG91YmxlQkUnXVxuICAsIGZ1bmN0aW9uKG1ldGhvZCkge1xuICAgIGlmICghQnVmZmVyLnByb3RvdHlwZVttZXRob2RdKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIE1vbmdvb3NlQnVmZmVyLm1peGluW21ldGhvZF0gPSBmdW5jdGlvbigpIHtcbiAgICAgIGNvbnN0IHJldCA9IEJ1ZmZlci5wcm90b3R5cGVbbWV0aG9kXS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgdGhpcy5fbWFya01vZGlmaWVkKCk7XG4gICAgICByZXR1cm4gcmV0O1xuICAgIH07XG4gIH0pO1xuXG4vKipcbiAqIENvbnZlcnRzIHRoaXMgYnVmZmVyIHRvIGl0cyBCaW5hcnkgdHlwZSByZXByZXNlbnRhdGlvbi5cbiAqXG4gKiAjIyMjIFN1YlR5cGVzOlxuICpcbiAqICAgICBjb25zdCBic29uID0gcmVxdWlyZSgnYnNvbicpXG4gKiAgICAgYnNvbi5CU09OX0JJTkFSWV9TVUJUWVBFX0RFRkFVTFRcbiAqICAgICBic29uLkJTT05fQklOQVJZX1NVQlRZUEVfRlVOQ1RJT05cbiAqICAgICBic29uLkJTT05fQklOQVJZX1NVQlRZUEVfQllURV9BUlJBWVxuICogICAgIGJzb24uQlNPTl9CSU5BUllfU1VCVFlQRV9VVUlEXG4gKiAgICAgYnNvbi5CU09OX0JJTkFSWV9TVUJUWVBFX01ENVxuICogICAgIGJzb24uQlNPTl9CSU5BUllfU1VCVFlQRV9VU0VSX0RFRklORURcbiAqICAgICBkb2MuYnVmZmVyLnRvT2JqZWN0KGJzb24uQlNPTl9CSU5BUllfU1VCVFlQRV9VU0VSX0RFRklORUQpO1xuICpcbiAqIEBzZWUgYnNvbnNwZWMgaHR0cHM6Ly9ic29uc3BlYy5vcmcvIy9zcGVjaWZpY2F0aW9uXG4gKiBAcGFyYW0ge0hleH0gW3N1YnR5cGVdXG4gKiBAcmV0dXJuIHtCaW5hcnl9XG4gKiBAYXBpIHB1YmxpY1xuICogQG1ldGhvZCB0b09iamVjdFxuICogQG1lbWJlck9mIE1vbmdvb3NlQnVmZmVyXG4gKi9cblxuTW9uZ29vc2VCdWZmZXIubWl4aW4udG9PYmplY3QgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gIGNvbnN0IHN1YnR5cGUgPSB0eXBlb2Ygb3B0aW9ucyA9PT0gJ251bWJlcidcbiAgICA/IG9wdGlvbnNcbiAgICA6ICh0aGlzLl9zdWJ0eXBlIHx8IDApO1xuICByZXR1cm4gbmV3IEJpbmFyeShCdWZmZXIuZnJvbSh0aGlzKSwgc3VidHlwZSk7XG59O1xuXG5Nb25nb29zZUJ1ZmZlci5taXhpbi4kdG9PYmplY3QgPSBNb25nb29zZUJ1ZmZlci5taXhpbi50b09iamVjdDtcblxuLyoqXG4gKiBDb252ZXJ0cyB0aGlzIGJ1ZmZlciBmb3Igc3RvcmFnZSBpbiBNb25nb0RCLCBpbmNsdWRpbmcgc3VidHlwZVxuICpcbiAqIEByZXR1cm4ge0JpbmFyeX1cbiAqIEBhcGkgcHVibGljXG4gKiBAbWV0aG9kIHRvQlNPTlxuICogQG1lbWJlck9mIE1vbmdvb3NlQnVmZmVyXG4gKi9cblxuTW9uZ29vc2VCdWZmZXIubWl4aW4udG9CU09OID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBuZXcgQmluYXJ5KHRoaXMsIHRoaXMuX3N1YnR5cGUgfHwgMCk7XG59O1xuXG4vKipcbiAqIERldGVybWluZXMgaWYgdGhpcyBidWZmZXIgaXMgZXF1YWxzIHRvIGBvdGhlcmAgYnVmZmVyXG4gKlxuICogQHBhcmFtIHtCdWZmZXJ9IG90aGVyXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICogQG1ldGhvZCBlcXVhbHNcbiAqIEBtZW1iZXJPZiBNb25nb29zZUJ1ZmZlclxuICovXG5cbk1vbmdvb3NlQnVmZmVyLm1peGluLmVxdWFscyA9IGZ1bmN0aW9uKG90aGVyKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKG90aGVyKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmICh0aGlzLmxlbmd0aCAhPT0gb3RoZXIubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgKytpKSB7XG4gICAgaWYgKHRoaXNbaV0gIT09IG90aGVyW2ldKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG4vKipcbiAqIFNldHMgdGhlIHN1YnR5cGUgb3B0aW9uIGFuZCBtYXJrcyB0aGUgYnVmZmVyIG1vZGlmaWVkLlxuICpcbiAqICMjIyMgU3ViVHlwZXM6XG4gKlxuICogICAgIGNvbnN0IGJzb24gPSByZXF1aXJlKCdic29uJylcbiAqICAgICBic29uLkJTT05fQklOQVJZX1NVQlRZUEVfREVGQVVMVFxuICogICAgIGJzb24uQlNPTl9CSU5BUllfU1VCVFlQRV9GVU5DVElPTlxuICogICAgIGJzb24uQlNPTl9CSU5BUllfU1VCVFlQRV9CWVRFX0FSUkFZXG4gKiAgICAgYnNvbi5CU09OX0JJTkFSWV9TVUJUWVBFX1VVSURcbiAqICAgICBic29uLkJTT05fQklOQVJZX1NVQlRZUEVfTUQ1XG4gKiAgICAgYnNvbi5CU09OX0JJTkFSWV9TVUJUWVBFX1VTRVJfREVGSU5FRFxuICpcbiAqICAgICBkb2MuYnVmZmVyLnN1YnR5cGUoYnNvbi5CU09OX0JJTkFSWV9TVUJUWVBFX1VVSUQpO1xuICpcbiAqIEBzZWUgYnNvbnNwZWMgaHR0cHM6Ly9ic29uc3BlYy5vcmcvIy9zcGVjaWZpY2F0aW9uXG4gKiBAcGFyYW0ge0hleH0gc3VidHlwZVxuICogQGFwaSBwdWJsaWNcbiAqIEBtZXRob2Qgc3VidHlwZVxuICogQG1lbWJlck9mIE1vbmdvb3NlQnVmZmVyXG4gKi9cblxuTW9uZ29vc2VCdWZmZXIubWl4aW4uc3VidHlwZSA9IGZ1bmN0aW9uKHN1YnR5cGUpIHtcbiAgaWYgKHR5cGVvZiBzdWJ0eXBlICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgc3VidHlwZS4gRXhwZWN0ZWQgYSBudW1iZXInKTtcbiAgfVxuXG4gIGlmICh0aGlzLl9zdWJ0eXBlICE9PSBzdWJ0eXBlKSB7XG4gICAgdGhpcy5fbWFya01vZGlmaWVkKCk7XG4gIH1cblxuICB0aGlzLl9zdWJ0eXBlID0gc3VidHlwZTtcbn07XG5cbi8qIVxuICogTW9kdWxlIGV4cG9ydHMuXG4gKi9cblxuTW9uZ29vc2VCdWZmZXIuQmluYXJ5ID0gQmluYXJ5O1xuXG5tb2R1bGUuZXhwb3J0cyA9IE1vbmdvb3NlQnVmZmVyO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../server/node_modules/mongoose/lib/types/buffer.js\n");

/***/ }),

/***/ "../server/node_modules/mongoose/lib/types/decimal128.js":
/*!***************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/types/decimal128.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/**\n * Decimal128 type constructor\n *\n * #### Example:\n *\n *     const id = new mongoose.Types.Decimal128('3.1415');\n *\n * @constructor Decimal128\n */\n\n\n\nmodule.exports = __webpack_require__(/*! bson */ \"../server/node_modules/bson/lib/bson.cjs\").Decimal128;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvdHlwZXMvZGVjaW1hbDEyOC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7O0FBRWIsdUdBQTJDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2xpZW50Ly4uL3NlcnZlci9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL3R5cGVzL2RlY2ltYWwxMjguanM/OWY2NiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIERlY2ltYWwxMjggdHlwZSBjb25zdHJ1Y3RvclxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgY29uc3QgaWQgPSBuZXcgbW9uZ29vc2UuVHlwZXMuRGVjaW1hbDEyOCgnMy4xNDE1Jyk7XG4gKlxuICogQGNvbnN0cnVjdG9yIERlY2ltYWwxMjhcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnYnNvbicpLkRlY2ltYWwxMjg7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../server/node_modules/mongoose/lib/types/decimal128.js\n");

/***/ }),

/***/ "../server/node_modules/mongoose/lib/types/documentArray/index.js":
/*!************************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/types/documentArray/index.js ***!
  \************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\n/*!\n * Module dependencies.\n */\n\nconst ArrayMethods = __webpack_require__(/*! ../array/methods */ \"../server/node_modules/mongoose/lib/types/array/methods/index.js\");\nconst DocumentArrayMethods = __webpack_require__(/*! ./methods */ \"../server/node_modules/mongoose/lib/types/documentArray/methods/index.js\");\nconst Document = __webpack_require__(/*! ../../document */ \"../server/node_modules/mongoose/lib/document.js\");\n\nconst arrayAtomicsSymbol = (__webpack_require__(/*! ../../helpers/symbols */ \"../server/node_modules/mongoose/lib/helpers/symbols.js\").arrayAtomicsSymbol);\nconst arrayAtomicsBackupSymbol = (__webpack_require__(/*! ../../helpers/symbols */ \"../server/node_modules/mongoose/lib/helpers/symbols.js\").arrayAtomicsBackupSymbol);\nconst arrayParentSymbol = (__webpack_require__(/*! ../../helpers/symbols */ \"../server/node_modules/mongoose/lib/helpers/symbols.js\").arrayParentSymbol);\nconst arrayPathSymbol = (__webpack_require__(/*! ../../helpers/symbols */ \"../server/node_modules/mongoose/lib/helpers/symbols.js\").arrayPathSymbol);\nconst arraySchemaSymbol = (__webpack_require__(/*! ../../helpers/symbols */ \"../server/node_modules/mongoose/lib/helpers/symbols.js\").arraySchemaSymbol);\n\nconst _basePush = Array.prototype.push;\nconst numberRE = /^\\d+$/;\n/**\n * DocumentArray constructor\n *\n * @param {Array} values\n * @param {String} path the path to this array\n * @param {Document} doc parent document\n * @api private\n * @return {MongooseDocumentArray}\n * @inherits MongooseArray\n * @see https://bit.ly/f6CnZU\n */\n\nfunction MongooseDocumentArray(values, path, doc) {\n  const __array = [];\n\n  const internals = {\n    [arrayAtomicsSymbol]: {},\n    [arrayAtomicsBackupSymbol]: void 0,\n    [arrayPathSymbol]: path,\n    [arraySchemaSymbol]: void 0,\n    [arrayParentSymbol]: void 0\n  };\n\n  if (Array.isArray(values)) {\n    if (values[arrayPathSymbol] === path &&\n        values[arrayParentSymbol] === doc) {\n      internals[arrayAtomicsSymbol] = Object.assign({}, values[arrayAtomicsSymbol]);\n    }\n    values.forEach(v => {\n      _basePush.call(__array, v);\n    });\n  }\n  internals[arrayPathSymbol] = path;\n  internals.__array = __array;\n\n  // Because doc comes from the context of another function, doc === global\n  // can happen if there was a null somewhere up the chain (see #3020 && #3034)\n  // RB Jun 17, 2015 updated to check for presence of expected paths instead\n  // to make more proof against unusual node environments\n  if (doc && doc instanceof Document) {\n    internals[arrayParentSymbol] = doc;\n    internals[arraySchemaSymbol] = doc.$__schema.path(path);\n\n    // `schema.path()` doesn't drill into nested arrays properly yet, see\n    // gh-6398, gh-6602. This is a workaround because nested arrays are\n    // always plain non-document arrays, so once you get to a document array\n    // nesting is done. Matryoshka code.\n    while (internals[arraySchemaSymbol] != null &&\n        internals[arraySchemaSymbol].$isMongooseArray &&\n        !internals[arraySchemaSymbol].$isMongooseDocumentArray) {\n      internals[arraySchemaSymbol] = internals[arraySchemaSymbol].casterConstructor;\n    }\n  }\n\n  const proxy = new Proxy(__array, {\n    get: function(target, prop) {\n      if (prop === 'isMongooseArray' ||\n          prop === 'isMongooseArrayProxy' ||\n          prop === 'isMongooseDocumentArray' ||\n          prop === 'isMongooseDocumentArrayProxy') {\n        return true;\n      }\n      if (internals.hasOwnProperty(prop)) {\n        return internals[prop];\n      }\n      if (DocumentArrayMethods.hasOwnProperty(prop)) {\n        return DocumentArrayMethods[prop];\n      }\n      if (ArrayMethods.hasOwnProperty(prop)) {\n        return ArrayMethods[prop];\n      }\n\n      return __array[prop];\n    },\n    set: function(target, prop, value) {\n      if (typeof prop === 'string' && numberRE.test(prop)) {\n        DocumentArrayMethods.set.call(proxy, prop, value, false);\n      } else if (internals.hasOwnProperty(prop)) {\n        internals[prop] = value;\n      } else {\n        __array[prop] = value;\n      }\n\n      return true;\n    }\n  });\n\n  return proxy;\n}\n\n/*!\n * Module exports.\n */\n\nmodule.exports = MongooseDocumentArray;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvdHlwZXMvZG9jdW1lbnRBcnJheS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBO0FBQ0E7O0FBRUEscUJBQXFCLG1CQUFPLENBQUMsMEZBQWtCO0FBQy9DLDZCQUE2QixtQkFBTyxDQUFDLDJGQUFXO0FBQ2hELGlCQUFpQixtQkFBTyxDQUFDLHVFQUFnQjs7QUFFekMsMkJBQTJCLCtIQUFtRDtBQUM5RSxpQ0FBaUMscUlBQXlEO0FBQzFGLDBCQUEwQiw4SEFBa0Q7QUFDNUUsd0JBQXdCLDRIQUFnRDtBQUN4RSwwQkFBMEIsOEhBQWtEOztBQUU1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsUUFBUTtBQUNuQixXQUFXLFVBQVU7QUFDckI7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0Q7QUFDdEQ7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2xpZW50Ly4uL3NlcnZlci9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL3R5cGVzL2RvY3VtZW50QXJyYXkvaW5kZXguanM/MTQyNCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbi8qIVxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG5jb25zdCBBcnJheU1ldGhvZHMgPSByZXF1aXJlKCcuLi9hcnJheS9tZXRob2RzJyk7XG5jb25zdCBEb2N1bWVudEFycmF5TWV0aG9kcyA9IHJlcXVpcmUoJy4vbWV0aG9kcycpO1xuY29uc3QgRG9jdW1lbnQgPSByZXF1aXJlKCcuLi8uLi9kb2N1bWVudCcpO1xuXG5jb25zdCBhcnJheUF0b21pY3NTeW1ib2wgPSByZXF1aXJlKCcuLi8uLi9oZWxwZXJzL3N5bWJvbHMnKS5hcnJheUF0b21pY3NTeW1ib2w7XG5jb25zdCBhcnJheUF0b21pY3NCYWNrdXBTeW1ib2wgPSByZXF1aXJlKCcuLi8uLi9oZWxwZXJzL3N5bWJvbHMnKS5hcnJheUF0b21pY3NCYWNrdXBTeW1ib2w7XG5jb25zdCBhcnJheVBhcmVudFN5bWJvbCA9IHJlcXVpcmUoJy4uLy4uL2hlbHBlcnMvc3ltYm9scycpLmFycmF5UGFyZW50U3ltYm9sO1xuY29uc3QgYXJyYXlQYXRoU3ltYm9sID0gcmVxdWlyZSgnLi4vLi4vaGVscGVycy9zeW1ib2xzJykuYXJyYXlQYXRoU3ltYm9sO1xuY29uc3QgYXJyYXlTY2hlbWFTeW1ib2wgPSByZXF1aXJlKCcuLi8uLi9oZWxwZXJzL3N5bWJvbHMnKS5hcnJheVNjaGVtYVN5bWJvbDtcblxuY29uc3QgX2Jhc2VQdXNoID0gQXJyYXkucHJvdG90eXBlLnB1c2g7XG5jb25zdCBudW1iZXJSRSA9IC9eXFxkKyQvO1xuLyoqXG4gKiBEb2N1bWVudEFycmF5IGNvbnN0cnVjdG9yXG4gKlxuICogQHBhcmFtIHtBcnJheX0gdmFsdWVzXG4gKiBAcGFyYW0ge1N0cmluZ30gcGF0aCB0aGUgcGF0aCB0byB0aGlzIGFycmF5XG4gKiBAcGFyYW0ge0RvY3VtZW50fSBkb2MgcGFyZW50IGRvY3VtZW50XG4gKiBAYXBpIHByaXZhdGVcbiAqIEByZXR1cm4ge01vbmdvb3NlRG9jdW1lbnRBcnJheX1cbiAqIEBpbmhlcml0cyBNb25nb29zZUFycmF5XG4gKiBAc2VlIGh0dHBzOi8vYml0Lmx5L2Y2Q25aVVxuICovXG5cbmZ1bmN0aW9uIE1vbmdvb3NlRG9jdW1lbnRBcnJheSh2YWx1ZXMsIHBhdGgsIGRvYykge1xuICBjb25zdCBfX2FycmF5ID0gW107XG5cbiAgY29uc3QgaW50ZXJuYWxzID0ge1xuICAgIFthcnJheUF0b21pY3NTeW1ib2xdOiB7fSxcbiAgICBbYXJyYXlBdG9taWNzQmFja3VwU3ltYm9sXTogdm9pZCAwLFxuICAgIFthcnJheVBhdGhTeW1ib2xdOiBwYXRoLFxuICAgIFthcnJheVNjaGVtYVN5bWJvbF06IHZvaWQgMCxcbiAgICBbYXJyYXlQYXJlbnRTeW1ib2xdOiB2b2lkIDBcbiAgfTtcblxuICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZXMpKSB7XG4gICAgaWYgKHZhbHVlc1thcnJheVBhdGhTeW1ib2xdID09PSBwYXRoICYmXG4gICAgICAgIHZhbHVlc1thcnJheVBhcmVudFN5bWJvbF0gPT09IGRvYykge1xuICAgICAgaW50ZXJuYWxzW2FycmF5QXRvbWljc1N5bWJvbF0gPSBPYmplY3QuYXNzaWduKHt9LCB2YWx1ZXNbYXJyYXlBdG9taWNzU3ltYm9sXSk7XG4gICAgfVxuICAgIHZhbHVlcy5mb3JFYWNoKHYgPT4ge1xuICAgICAgX2Jhc2VQdXNoLmNhbGwoX19hcnJheSwgdik7XG4gICAgfSk7XG4gIH1cbiAgaW50ZXJuYWxzW2FycmF5UGF0aFN5bWJvbF0gPSBwYXRoO1xuICBpbnRlcm5hbHMuX19hcnJheSA9IF9fYXJyYXk7XG5cbiAgLy8gQmVjYXVzZSBkb2MgY29tZXMgZnJvbSB0aGUgY29udGV4dCBvZiBhbm90aGVyIGZ1bmN0aW9uLCBkb2MgPT09IGdsb2JhbFxuICAvLyBjYW4gaGFwcGVuIGlmIHRoZXJlIHdhcyBhIG51bGwgc29tZXdoZXJlIHVwIHRoZSBjaGFpbiAoc2VlICMzMDIwICYmICMzMDM0KVxuICAvLyBSQiBKdW4gMTcsIDIwMTUgdXBkYXRlZCB0byBjaGVjayBmb3IgcHJlc2VuY2Ugb2YgZXhwZWN0ZWQgcGF0aHMgaW5zdGVhZFxuICAvLyB0byBtYWtlIG1vcmUgcHJvb2YgYWdhaW5zdCB1bnVzdWFsIG5vZGUgZW52aXJvbm1lbnRzXG4gIGlmIChkb2MgJiYgZG9jIGluc3RhbmNlb2YgRG9jdW1lbnQpIHtcbiAgICBpbnRlcm5hbHNbYXJyYXlQYXJlbnRTeW1ib2xdID0gZG9jO1xuICAgIGludGVybmFsc1thcnJheVNjaGVtYVN5bWJvbF0gPSBkb2MuJF9fc2NoZW1hLnBhdGgocGF0aCk7XG5cbiAgICAvLyBgc2NoZW1hLnBhdGgoKWAgZG9lc24ndCBkcmlsbCBpbnRvIG5lc3RlZCBhcnJheXMgcHJvcGVybHkgeWV0LCBzZWVcbiAgICAvLyBnaC02Mzk4LCBnaC02NjAyLiBUaGlzIGlzIGEgd29ya2Fyb3VuZCBiZWNhdXNlIG5lc3RlZCBhcnJheXMgYXJlXG4gICAgLy8gYWx3YXlzIHBsYWluIG5vbi1kb2N1bWVudCBhcnJheXMsIHNvIG9uY2UgeW91IGdldCB0byBhIGRvY3VtZW50IGFycmF5XG4gICAgLy8gbmVzdGluZyBpcyBkb25lLiBNYXRyeW9zaGthIGNvZGUuXG4gICAgd2hpbGUgKGludGVybmFsc1thcnJheVNjaGVtYVN5bWJvbF0gIT0gbnVsbCAmJlxuICAgICAgICBpbnRlcm5hbHNbYXJyYXlTY2hlbWFTeW1ib2xdLiRpc01vbmdvb3NlQXJyYXkgJiZcbiAgICAgICAgIWludGVybmFsc1thcnJheVNjaGVtYVN5bWJvbF0uJGlzTW9uZ29vc2VEb2N1bWVudEFycmF5KSB7XG4gICAgICBpbnRlcm5hbHNbYXJyYXlTY2hlbWFTeW1ib2xdID0gaW50ZXJuYWxzW2FycmF5U2NoZW1hU3ltYm9sXS5jYXN0ZXJDb25zdHJ1Y3RvcjtcbiAgICB9XG4gIH1cblxuICBjb25zdCBwcm94eSA9IG5ldyBQcm94eShfX2FycmF5LCB7XG4gICAgZ2V0OiBmdW5jdGlvbih0YXJnZXQsIHByb3ApIHtcbiAgICAgIGlmIChwcm9wID09PSAnaXNNb25nb29zZUFycmF5JyB8fFxuICAgICAgICAgIHByb3AgPT09ICdpc01vbmdvb3NlQXJyYXlQcm94eScgfHxcbiAgICAgICAgICBwcm9wID09PSAnaXNNb25nb29zZURvY3VtZW50QXJyYXknIHx8XG4gICAgICAgICAgcHJvcCA9PT0gJ2lzTW9uZ29vc2VEb2N1bWVudEFycmF5UHJveHknKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKGludGVybmFscy5oYXNPd25Qcm9wZXJ0eShwcm9wKSkge1xuICAgICAgICByZXR1cm4gaW50ZXJuYWxzW3Byb3BdO1xuICAgICAgfVxuICAgICAgaWYgKERvY3VtZW50QXJyYXlNZXRob2RzLmhhc093blByb3BlcnR5KHByb3ApKSB7XG4gICAgICAgIHJldHVybiBEb2N1bWVudEFycmF5TWV0aG9kc1twcm9wXTtcbiAgICAgIH1cbiAgICAgIGlmIChBcnJheU1ldGhvZHMuaGFzT3duUHJvcGVydHkocHJvcCkpIHtcbiAgICAgICAgcmV0dXJuIEFycmF5TWV0aG9kc1twcm9wXTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIF9fYXJyYXlbcHJvcF07XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uKHRhcmdldCwgcHJvcCwgdmFsdWUpIHtcbiAgICAgIGlmICh0eXBlb2YgcHJvcCA9PT0gJ3N0cmluZycgJiYgbnVtYmVyUkUudGVzdChwcm9wKSkge1xuICAgICAgICBEb2N1bWVudEFycmF5TWV0aG9kcy5zZXQuY2FsbChwcm94eSwgcHJvcCwgdmFsdWUsIGZhbHNlKTtcbiAgICAgIH0gZWxzZSBpZiAoaW50ZXJuYWxzLmhhc093blByb3BlcnR5KHByb3ApKSB7XG4gICAgICAgIGludGVybmFsc1twcm9wXSA9IHZhbHVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgX19hcnJheVtwcm9wXSA9IHZhbHVlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBwcm94eTtcbn1cblxuLyohXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IE1vbmdvb3NlRG9jdW1lbnRBcnJheTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../server/node_modules/mongoose/lib/types/documentArray/index.js\n");

/***/ }),

/***/ "../server/node_modules/mongoose/lib/types/documentArray/isMongooseDocumentArray.js":
/*!******************************************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/types/documentArray/isMongooseDocumentArray.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\nexports.isMongooseDocumentArray = function(mongooseDocumentArray) {\n  return Array.isArray(mongooseDocumentArray) && mongooseDocumentArray.isMongooseDocumentArray;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvdHlwZXMvZG9jdW1lbnRBcnJheS9pc01vbmdvb3NlRG9jdW1lbnRBcnJheS5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYiwrQkFBK0I7QUFDL0I7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2NsaWVudC8uLi9zZXJ2ZXIvbm9kZV9tb2R1bGVzL21vbmdvb3NlL2xpYi90eXBlcy9kb2N1bWVudEFycmF5L2lzTW9uZ29vc2VEb2N1bWVudEFycmF5LmpzP2E5MTIiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLmlzTW9uZ29vc2VEb2N1bWVudEFycmF5ID0gZnVuY3Rpb24obW9uZ29vc2VEb2N1bWVudEFycmF5KSB7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KG1vbmdvb3NlRG9jdW1lbnRBcnJheSkgJiYgbW9uZ29vc2VEb2N1bWVudEFycmF5LmlzTW9uZ29vc2VEb2N1bWVudEFycmF5O1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../server/node_modules/mongoose/lib/types/documentArray/isMongooseDocumentArray.js\n");

/***/ }),

/***/ "../server/node_modules/mongoose/lib/types/documentArray/methods/index.js":
/*!********************************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/types/documentArray/methods/index.js ***!
  \********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst ArrayMethods = __webpack_require__(/*! ../../array/methods */ \"../server/node_modules/mongoose/lib/types/array/methods/index.js\");\nconst Document = __webpack_require__(/*! ../../../document */ \"../server/node_modules/mongoose/lib/document.js\");\nconst castObjectId = __webpack_require__(/*! ../../../cast/objectid */ \"../server/node_modules/mongoose/lib/cast/objectid.js\");\nconst getDiscriminatorByValue = __webpack_require__(/*! ../../../helpers/discriminator/getDiscriminatorByValue */ \"../server/node_modules/mongoose/lib/helpers/discriminator/getDiscriminatorByValue.js\");\nconst internalToObjectOptions = (__webpack_require__(/*! ../../../options */ \"../server/node_modules/mongoose/lib/options.js\").internalToObjectOptions);\nconst utils = __webpack_require__(/*! ../../../utils */ \"../server/node_modules/mongoose/lib/utils.js\");\nconst isBsonType = __webpack_require__(/*! ../../../helpers/isBsonType */ \"../server/node_modules/mongoose/lib/helpers/isBsonType.js\");\n\nconst arrayParentSymbol = (__webpack_require__(/*! ../../../helpers/symbols */ \"../server/node_modules/mongoose/lib/helpers/symbols.js\").arrayParentSymbol);\nconst arrayPathSymbol = (__webpack_require__(/*! ../../../helpers/symbols */ \"../server/node_modules/mongoose/lib/helpers/symbols.js\").arrayPathSymbol);\nconst arraySchemaSymbol = (__webpack_require__(/*! ../../../helpers/symbols */ \"../server/node_modules/mongoose/lib/helpers/symbols.js\").arraySchemaSymbol);\nconst documentArrayParent = (__webpack_require__(/*! ../../../helpers/symbols */ \"../server/node_modules/mongoose/lib/helpers/symbols.js\").documentArrayParent);\n\nconst _baseToString = Array.prototype.toString;\n\nconst methods = {\n  /*!\n   * ignore\n   */\n\n  toBSON() {\n    return this.toObject(internalToObjectOptions);\n  },\n\n  toString() {\n    return _baseToString.call(this.__array.map(subdoc => {\n      if (subdoc != null && subdoc.$__ != null) {\n        return subdoc.toString();\n      }\n      return subdoc;\n    }));\n  },\n\n  /*!\n   * ignore\n   */\n\n  getArrayParent() {\n    return this[arrayParentSymbol];\n  },\n\n  /**\n   * Overrides MongooseArray#cast\n   *\n   * @method _cast\n   * @api private\n   * @memberOf MongooseDocumentArray\n   */\n\n  _cast(value, index, options) {\n    if (this[arraySchemaSymbol] == null) {\n      return value;\n    }\n    let Constructor = this[arraySchemaSymbol].casterConstructor;\n    const isInstance = Constructor.$isMongooseDocumentArray ?\n      utils.isMongooseDocumentArray(value) :\n      value instanceof Constructor;\n    if (isInstance ||\n        // Hack re: #5001, see #5005\n        (value && value.constructor && value.constructor.baseCasterConstructor === Constructor)) {\n      if (!(value[documentArrayParent] && value.__parentArray)) {\n        // value may have been created using array.create()\n        value[documentArrayParent] = this[arrayParentSymbol];\n        value.__parentArray = this;\n      }\n      value.$setIndex(index);\n      return value;\n    }\n\n    if (value === undefined || value === null) {\n      return null;\n    }\n\n    // handle cast('string') or cast(ObjectId) etc.\n    // only objects are permitted so we can safely assume that\n    // non-objects are to be interpreted as _id\n    if (Buffer.isBuffer(value) ||\n        isBsonType(value, 'ObjectId') || !utils.isObject(value)) {\n      value = { _id: value };\n    }\n\n    if (value &&\n        Constructor.discriminators &&\n        Constructor.schema &&\n        Constructor.schema.options &&\n        Constructor.schema.options.discriminatorKey) {\n      if (typeof value[Constructor.schema.options.discriminatorKey] === 'string' &&\n          Constructor.discriminators[value[Constructor.schema.options.discriminatorKey]]) {\n        Constructor = Constructor.discriminators[value[Constructor.schema.options.discriminatorKey]];\n      } else {\n        const constructorByValue = getDiscriminatorByValue(Constructor.discriminators, value[Constructor.schema.options.discriminatorKey]);\n        if (constructorByValue) {\n          Constructor = constructorByValue;\n        }\n      }\n    }\n\n    if (Constructor.$isMongooseDocumentArray) {\n      return Constructor.cast(value, this, undefined, undefined, index);\n    }\n    const ret = new Constructor(value, this, options, undefined, index);\n    ret.isNew = true;\n    return ret;\n  },\n\n  /**\n   * Searches array items for the first document with a matching _id.\n   *\n   * #### Example:\n   *\n   *     const embeddedDoc = m.array.id(some_id);\n   *\n   * @return {EmbeddedDocument|null} the subdocument or null if not found.\n   * @param {ObjectId|String|Number|Buffer} id\n   * @TODO cast to the _id based on schema for proper comparison\n   * @method id\n   * @api public\n   * @memberOf MongooseDocumentArray\n   */\n\n  id(id) {\n    let casted;\n    let sid;\n    let _id;\n\n    try {\n      casted = castObjectId(id).toString();\n    } catch (e) {\n      casted = null;\n    }\n\n    for (const val of this) {\n      if (!val) {\n        continue;\n      }\n\n      _id = val.get('_id');\n\n      if (_id === null || typeof _id === 'undefined') {\n        continue;\n      } else if (_id instanceof Document) {\n        sid || (sid = String(id));\n        if (sid == _id._id) {\n          return val;\n        }\n      } else if (!isBsonType(id, 'ObjectId') && !isBsonType(_id, 'ObjectId')) {\n        if (id == _id || utils.deepEqual(id, _id)) {\n          return val;\n        }\n      } else if (casted == _id) {\n        return val;\n      }\n    }\n\n    return null;\n  },\n\n  /**\n   * Returns a native js Array of plain js objects\n   *\n   * #### Note:\n   *\n   * _Each sub-document is converted to a plain object by calling its `#toObject` method._\n   *\n   * @param {Object} [options] optional options to pass to each documents `toObject` method call during conversion\n   * @return {Array}\n   * @method toObject\n   * @api public\n   * @memberOf MongooseDocumentArray\n   */\n\n  toObject(options) {\n    // `[].concat` coerces the return value into a vanilla JS array, rather\n    // than a Mongoose array.\n    return [].concat(this.map(function(doc) {\n      if (doc == null) {\n        return null;\n      }\n      if (typeof doc.toObject !== 'function') {\n        return doc;\n      }\n      return doc.toObject(options);\n    }));\n  },\n\n  $toObject() {\n    return this.constructor.prototype.toObject.apply(this, arguments);\n  },\n\n  /**\n   * Wraps [`Array#push`](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/push) with proper change tracking.\n   *\n   * @param {...Object} [args]\n   * @api public\n   * @method push\n   * @memberOf MongooseDocumentArray\n   */\n\n  push() {\n    const ret = ArrayMethods.push.apply(this, arguments);\n\n    _updateParentPopulated(this);\n\n    return ret;\n  },\n\n  /**\n   * Pulls items from the array atomically.\n   *\n   * @param {...Object} [args]\n   * @api public\n   * @method pull\n   * @memberOf MongooseDocumentArray\n   */\n\n  pull() {\n    const ret = ArrayMethods.pull.apply(this, arguments);\n\n    _updateParentPopulated(this);\n\n    return ret;\n  },\n\n  /**\n   * Wraps [`Array#shift`](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/unshift) with proper change tracking.\n   * @api private\n   */\n\n  shift() {\n    const ret = ArrayMethods.shift.apply(this, arguments);\n\n    _updateParentPopulated(this);\n\n    return ret;\n  },\n\n  /**\n   * Wraps [`Array#splice`](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/splice) with proper change tracking and casting.\n   * @api private\n   */\n\n  splice() {\n    const ret = ArrayMethods.splice.apply(this, arguments);\n\n    _updateParentPopulated(this);\n\n    return ret;\n  },\n\n  /**\n   * Helper for console.log\n   *\n   * @method inspect\n   * @api public\n   * @memberOf MongooseDocumentArray\n   */\n\n  inspect() {\n    return this.toObject();\n  },\n\n  /**\n   * Creates a subdocument casted to this schema.\n   *\n   * This is the same subdocument constructor used for casting.\n   *\n   * @param {Object} obj the value to cast to this arrays SubDocument schema\n   * @method create\n   * @api public\n   * @memberOf MongooseDocumentArray\n   */\n\n  create(obj) {\n    let Constructor = this[arraySchemaSymbol].casterConstructor;\n    if (obj &&\n        Constructor.discriminators &&\n        Constructor.schema &&\n        Constructor.schema.options &&\n        Constructor.schema.options.discriminatorKey) {\n      if (typeof obj[Constructor.schema.options.discriminatorKey] === 'string' &&\n          Constructor.discriminators[obj[Constructor.schema.options.discriminatorKey]]) {\n        Constructor = Constructor.discriminators[obj[Constructor.schema.options.discriminatorKey]];\n      } else {\n        const constructorByValue = getDiscriminatorByValue(Constructor.discriminators, obj[Constructor.schema.options.discriminatorKey]);\n        if (constructorByValue) {\n          Constructor = constructorByValue;\n        }\n      }\n    }\n\n    return new Constructor(obj, this);\n  },\n\n  /*!\n   * ignore\n   */\n\n  notify(event) {\n    const _this = this;\n    return function notify(val, _arr) {\n      _arr = _arr || _this;\n      let i = _arr.length;\n      while (i--) {\n        if (_arr[i] == null) {\n          continue;\n        }\n        switch (event) {\n          // only swap for save event for now, we may change this to all event types later\n          case 'save':\n            val = _this[i];\n            break;\n          default:\n            // NO-OP\n            break;\n        }\n\n        if (utils.isMongooseArray(_arr[i])) {\n          notify(val, _arr[i]);\n        } else if (_arr[i]) {\n          _arr[i].emit(event, val);\n        }\n      }\n    };\n  },\n\n  set(i, val, skipModified) {\n    const arr = this.__array;\n    if (skipModified) {\n      arr[i] = val;\n      return this;\n    }\n    const value = methods._cast.call(this, val, i);\n    methods._markModified.call(this, i);\n    arr[i] = value;\n    return this;\n  },\n\n  _markModified(elem, embeddedPath) {\n    const parent = this[arrayParentSymbol];\n    let dirtyPath;\n\n    if (parent) {\n      dirtyPath = this[arrayPathSymbol];\n\n      if (arguments.length) {\n        if (embeddedPath != null) {\n          // an embedded doc bubbled up the change\n          const index = elem.__index;\n          dirtyPath = dirtyPath + '.' + index + '.' + embeddedPath;\n        } else {\n          // directly set an index\n          dirtyPath = dirtyPath + '.' + elem;\n        }\n      }\n\n      if (dirtyPath != null && dirtyPath.endsWith('.$')) {\n        return this;\n      }\n\n      parent.markModified(dirtyPath, arguments.length !== 0 ? elem : parent);\n    }\n\n    return this;\n  }\n};\n\nmodule.exports = methods;\n\n/**\n * If this is a document array, each element may contain single\n * populated paths, so we need to modify the top-level document's\n * populated cache. See gh-8247, gh-8265.\n * @param {Array} arr\n * @api private\n */\n\nfunction _updateParentPopulated(arr) {\n  const parent = arr[arrayParentSymbol];\n  if (!parent || parent.$__.populated == null) return;\n\n  const populatedPaths = Object.keys(parent.$__.populated).\n    filter(p => p.startsWith(arr[arrayPathSymbol] + '.'));\n\n  for (const path of populatedPaths) {\n    const remnant = path.slice((arr[arrayPathSymbol] + '.').length);\n    if (!Array.isArray(parent.$__.populated[path].value)) {\n      continue;\n    }\n\n    parent.$__.populated[path].value = arr.map(val => val.$populated(remnant));\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvdHlwZXMvZG9jdW1lbnRBcnJheS9tZXRob2RzL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLHFCQUFxQixtQkFBTyxDQUFDLDZGQUFxQjtBQUNsRCxpQkFBaUIsbUJBQU8sQ0FBQywwRUFBbUI7QUFDNUMscUJBQXFCLG1CQUFPLENBQUMsb0ZBQXdCO0FBQ3JELGdDQUFnQyxtQkFBTyxDQUFDLG9KQUF3RDtBQUNoRyxnQ0FBZ0MsdUhBQW1EO0FBQ25GLGNBQWMsbUJBQU8sQ0FBQyxvRUFBZ0I7QUFDdEMsbUJBQW1CLG1CQUFPLENBQUMsOEZBQTZCOztBQUV4RCwwQkFBMEIsaUlBQXFEO0FBQy9FLHdCQUF3QiwrSEFBbUQ7QUFDM0UsMEJBQTBCLGlJQUFxRDtBQUMvRSw0QkFBNEIsbUlBQXVEOztBQUVuRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsdUJBQXVCO0FBQ3JDLGFBQWEsK0JBQStCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxhQUFhLFdBQVc7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsYUFBYSxXQUFXO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2xpZW50Ly4uL3NlcnZlci9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL3R5cGVzL2RvY3VtZW50QXJyYXkvbWV0aG9kcy9pbmRleC5qcz85Mzk1Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3QgQXJyYXlNZXRob2RzID0gcmVxdWlyZSgnLi4vLi4vYXJyYXkvbWV0aG9kcycpO1xuY29uc3QgRG9jdW1lbnQgPSByZXF1aXJlKCcuLi8uLi8uLi9kb2N1bWVudCcpO1xuY29uc3QgY2FzdE9iamVjdElkID0gcmVxdWlyZSgnLi4vLi4vLi4vY2FzdC9vYmplY3RpZCcpO1xuY29uc3QgZ2V0RGlzY3JpbWluYXRvckJ5VmFsdWUgPSByZXF1aXJlKCcuLi8uLi8uLi9oZWxwZXJzL2Rpc2NyaW1pbmF0b3IvZ2V0RGlzY3JpbWluYXRvckJ5VmFsdWUnKTtcbmNvbnN0IGludGVybmFsVG9PYmplY3RPcHRpb25zID0gcmVxdWlyZSgnLi4vLi4vLi4vb3B0aW9ucycpLmludGVybmFsVG9PYmplY3RPcHRpb25zO1xuY29uc3QgdXRpbHMgPSByZXF1aXJlKCcuLi8uLi8uLi91dGlscycpO1xuY29uc3QgaXNCc29uVHlwZSA9IHJlcXVpcmUoJy4uLy4uLy4uL2hlbHBlcnMvaXNCc29uVHlwZScpO1xuXG5jb25zdCBhcnJheVBhcmVudFN5bWJvbCA9IHJlcXVpcmUoJy4uLy4uLy4uL2hlbHBlcnMvc3ltYm9scycpLmFycmF5UGFyZW50U3ltYm9sO1xuY29uc3QgYXJyYXlQYXRoU3ltYm9sID0gcmVxdWlyZSgnLi4vLi4vLi4vaGVscGVycy9zeW1ib2xzJykuYXJyYXlQYXRoU3ltYm9sO1xuY29uc3QgYXJyYXlTY2hlbWFTeW1ib2wgPSByZXF1aXJlKCcuLi8uLi8uLi9oZWxwZXJzL3N5bWJvbHMnKS5hcnJheVNjaGVtYVN5bWJvbDtcbmNvbnN0IGRvY3VtZW50QXJyYXlQYXJlbnQgPSByZXF1aXJlKCcuLi8uLi8uLi9oZWxwZXJzL3N5bWJvbHMnKS5kb2N1bWVudEFycmF5UGFyZW50O1xuXG5jb25zdCBfYmFzZVRvU3RyaW5nID0gQXJyYXkucHJvdG90eXBlLnRvU3RyaW5nO1xuXG5jb25zdCBtZXRob2RzID0ge1xuICAvKiFcbiAgICogaWdub3JlXG4gICAqL1xuXG4gIHRvQlNPTigpIHtcbiAgICByZXR1cm4gdGhpcy50b09iamVjdChpbnRlcm5hbFRvT2JqZWN0T3B0aW9ucyk7XG4gIH0sXG5cbiAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIF9iYXNlVG9TdHJpbmcuY2FsbCh0aGlzLl9fYXJyYXkubWFwKHN1YmRvYyA9PiB7XG4gICAgICBpZiAoc3ViZG9jICE9IG51bGwgJiYgc3ViZG9jLiRfXyAhPSBudWxsKSB7XG4gICAgICAgIHJldHVybiBzdWJkb2MudG9TdHJpbmcoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzdWJkb2M7XG4gICAgfSkpO1xuICB9LFxuXG4gIC8qIVxuICAgKiBpZ25vcmVcbiAgICovXG5cbiAgZ2V0QXJyYXlQYXJlbnQoKSB7XG4gICAgcmV0dXJuIHRoaXNbYXJyYXlQYXJlbnRTeW1ib2xdO1xuICB9LFxuXG4gIC8qKlxuICAgKiBPdmVycmlkZXMgTW9uZ29vc2VBcnJheSNjYXN0XG4gICAqXG4gICAqIEBtZXRob2QgX2Nhc3RcbiAgICogQGFwaSBwcml2YXRlXG4gICAqIEBtZW1iZXJPZiBNb25nb29zZURvY3VtZW50QXJyYXlcbiAgICovXG5cbiAgX2Nhc3QodmFsdWUsIGluZGV4LCBvcHRpb25zKSB7XG4gICAgaWYgKHRoaXNbYXJyYXlTY2hlbWFTeW1ib2xdID09IG51bGwpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgbGV0IENvbnN0cnVjdG9yID0gdGhpc1thcnJheVNjaGVtYVN5bWJvbF0uY2FzdGVyQ29uc3RydWN0b3I7XG4gICAgY29uc3QgaXNJbnN0YW5jZSA9IENvbnN0cnVjdG9yLiRpc01vbmdvb3NlRG9jdW1lbnRBcnJheSA/XG4gICAgICB1dGlscy5pc01vbmdvb3NlRG9jdW1lbnRBcnJheSh2YWx1ZSkgOlxuICAgICAgdmFsdWUgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcjtcbiAgICBpZiAoaXNJbnN0YW5jZSB8fFxuICAgICAgICAvLyBIYWNrIHJlOiAjNTAwMSwgc2VlICM1MDA1XG4gICAgICAgICh2YWx1ZSAmJiB2YWx1ZS5jb25zdHJ1Y3RvciAmJiB2YWx1ZS5jb25zdHJ1Y3Rvci5iYXNlQ2FzdGVyQ29uc3RydWN0b3IgPT09IENvbnN0cnVjdG9yKSkge1xuICAgICAgaWYgKCEodmFsdWVbZG9jdW1lbnRBcnJheVBhcmVudF0gJiYgdmFsdWUuX19wYXJlbnRBcnJheSkpIHtcbiAgICAgICAgLy8gdmFsdWUgbWF5IGhhdmUgYmVlbiBjcmVhdGVkIHVzaW5nIGFycmF5LmNyZWF0ZSgpXG4gICAgICAgIHZhbHVlW2RvY3VtZW50QXJyYXlQYXJlbnRdID0gdGhpc1thcnJheVBhcmVudFN5bWJvbF07XG4gICAgICAgIHZhbHVlLl9fcGFyZW50QXJyYXkgPSB0aGlzO1xuICAgICAgfVxuICAgICAgdmFsdWUuJHNldEluZGV4KGluZGV4KTtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCB8fCB2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgLy8gaGFuZGxlIGNhc3QoJ3N0cmluZycpIG9yIGNhc3QoT2JqZWN0SWQpIGV0Yy5cbiAgICAvLyBvbmx5IG9iamVjdHMgYXJlIHBlcm1pdHRlZCBzbyB3ZSBjYW4gc2FmZWx5IGFzc3VtZSB0aGF0XG4gICAgLy8gbm9uLW9iamVjdHMgYXJlIHRvIGJlIGludGVycHJldGVkIGFzIF9pZFxuICAgIGlmIChCdWZmZXIuaXNCdWZmZXIodmFsdWUpIHx8XG4gICAgICAgIGlzQnNvblR5cGUodmFsdWUsICdPYmplY3RJZCcpIHx8ICF1dGlscy5pc09iamVjdCh2YWx1ZSkpIHtcbiAgICAgIHZhbHVlID0geyBfaWQ6IHZhbHVlIH07XG4gICAgfVxuXG4gICAgaWYgKHZhbHVlICYmXG4gICAgICAgIENvbnN0cnVjdG9yLmRpc2NyaW1pbmF0b3JzICYmXG4gICAgICAgIENvbnN0cnVjdG9yLnNjaGVtYSAmJlxuICAgICAgICBDb25zdHJ1Y3Rvci5zY2hlbWEub3B0aW9ucyAmJlxuICAgICAgICBDb25zdHJ1Y3Rvci5zY2hlbWEub3B0aW9ucy5kaXNjcmltaW5hdG9yS2V5KSB7XG4gICAgICBpZiAodHlwZW9mIHZhbHVlW0NvbnN0cnVjdG9yLnNjaGVtYS5vcHRpb25zLmRpc2NyaW1pbmF0b3JLZXldID09PSAnc3RyaW5nJyAmJlxuICAgICAgICAgIENvbnN0cnVjdG9yLmRpc2NyaW1pbmF0b3JzW3ZhbHVlW0NvbnN0cnVjdG9yLnNjaGVtYS5vcHRpb25zLmRpc2NyaW1pbmF0b3JLZXldXSkge1xuICAgICAgICBDb25zdHJ1Y3RvciA9IENvbnN0cnVjdG9yLmRpc2NyaW1pbmF0b3JzW3ZhbHVlW0NvbnN0cnVjdG9yLnNjaGVtYS5vcHRpb25zLmRpc2NyaW1pbmF0b3JLZXldXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGNvbnN0cnVjdG9yQnlWYWx1ZSA9IGdldERpc2NyaW1pbmF0b3JCeVZhbHVlKENvbnN0cnVjdG9yLmRpc2NyaW1pbmF0b3JzLCB2YWx1ZVtDb25zdHJ1Y3Rvci5zY2hlbWEub3B0aW9ucy5kaXNjcmltaW5hdG9yS2V5XSk7XG4gICAgICAgIGlmIChjb25zdHJ1Y3RvckJ5VmFsdWUpIHtcbiAgICAgICAgICBDb25zdHJ1Y3RvciA9IGNvbnN0cnVjdG9yQnlWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChDb25zdHJ1Y3Rvci4kaXNNb25nb29zZURvY3VtZW50QXJyYXkpIHtcbiAgICAgIHJldHVybiBDb25zdHJ1Y3Rvci5jYXN0KHZhbHVlLCB0aGlzLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgaW5kZXgpO1xuICAgIH1cbiAgICBjb25zdCByZXQgPSBuZXcgQ29uc3RydWN0b3IodmFsdWUsIHRoaXMsIG9wdGlvbnMsIHVuZGVmaW5lZCwgaW5kZXgpO1xuICAgIHJldC5pc05ldyA9IHRydWU7XG4gICAgcmV0dXJuIHJldDtcbiAgfSxcblxuICAvKipcbiAgICogU2VhcmNoZXMgYXJyYXkgaXRlbXMgZm9yIHRoZSBmaXJzdCBkb2N1bWVudCB3aXRoIGEgbWF0Y2hpbmcgX2lkLlxuICAgKlxuICAgKiAjIyMjIEV4YW1wbGU6XG4gICAqXG4gICAqICAgICBjb25zdCBlbWJlZGRlZERvYyA9IG0uYXJyYXkuaWQoc29tZV9pZCk7XG4gICAqXG4gICAqIEByZXR1cm4ge0VtYmVkZGVkRG9jdW1lbnR8bnVsbH0gdGhlIHN1YmRvY3VtZW50IG9yIG51bGwgaWYgbm90IGZvdW5kLlxuICAgKiBAcGFyYW0ge09iamVjdElkfFN0cmluZ3xOdW1iZXJ8QnVmZmVyfSBpZFxuICAgKiBAVE9ETyBjYXN0IHRvIHRoZSBfaWQgYmFzZWQgb24gc2NoZW1hIGZvciBwcm9wZXIgY29tcGFyaXNvblxuICAgKiBAbWV0aG9kIGlkXG4gICAqIEBhcGkgcHVibGljXG4gICAqIEBtZW1iZXJPZiBNb25nb29zZURvY3VtZW50QXJyYXlcbiAgICovXG5cbiAgaWQoaWQpIHtcbiAgICBsZXQgY2FzdGVkO1xuICAgIGxldCBzaWQ7XG4gICAgbGV0IF9pZDtcblxuICAgIHRyeSB7XG4gICAgICBjYXN0ZWQgPSBjYXN0T2JqZWN0SWQoaWQpLnRvU3RyaW5nKCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgY2FzdGVkID0gbnVsbDtcbiAgICB9XG5cbiAgICBmb3IgKGNvbnN0IHZhbCBvZiB0aGlzKSB7XG4gICAgICBpZiAoIXZhbCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgX2lkID0gdmFsLmdldCgnX2lkJyk7XG5cbiAgICAgIGlmIChfaWQgPT09IG51bGwgfHwgdHlwZW9mIF9pZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9IGVsc2UgaWYgKF9pZCBpbnN0YW5jZW9mIERvY3VtZW50KSB7XG4gICAgICAgIHNpZCB8fCAoc2lkID0gU3RyaW5nKGlkKSk7XG4gICAgICAgIGlmIChzaWQgPT0gX2lkLl9pZCkge1xuICAgICAgICAgIHJldHVybiB2YWw7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoIWlzQnNvblR5cGUoaWQsICdPYmplY3RJZCcpICYmICFpc0Jzb25UeXBlKF9pZCwgJ09iamVjdElkJykpIHtcbiAgICAgICAgaWYgKGlkID09IF9pZCB8fCB1dGlscy5kZWVwRXF1YWwoaWQsIF9pZCkpIHtcbiAgICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGNhc3RlZCA9PSBfaWQpIHtcbiAgICAgICAgcmV0dXJuIHZhbDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfSxcblxuICAvKipcbiAgICogUmV0dXJucyBhIG5hdGl2ZSBqcyBBcnJheSBvZiBwbGFpbiBqcyBvYmplY3RzXG4gICAqXG4gICAqICMjIyMgTm90ZTpcbiAgICpcbiAgICogX0VhY2ggc3ViLWRvY3VtZW50IGlzIGNvbnZlcnRlZCB0byBhIHBsYWluIG9iamVjdCBieSBjYWxsaW5nIGl0cyBgI3RvT2JqZWN0YCBtZXRob2QuX1xuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIG9wdGlvbmFsIG9wdGlvbnMgdG8gcGFzcyB0byBlYWNoIGRvY3VtZW50cyBgdG9PYmplY3RgIG1ldGhvZCBjYWxsIGR1cmluZyBjb252ZXJzaW9uXG4gICAqIEByZXR1cm4ge0FycmF5fVxuICAgKiBAbWV0aG9kIHRvT2JqZWN0XG4gICAqIEBhcGkgcHVibGljXG4gICAqIEBtZW1iZXJPZiBNb25nb29zZURvY3VtZW50QXJyYXlcbiAgICovXG5cbiAgdG9PYmplY3Qob3B0aW9ucykge1xuICAgIC8vIGBbXS5jb25jYXRgIGNvZXJjZXMgdGhlIHJldHVybiB2YWx1ZSBpbnRvIGEgdmFuaWxsYSBKUyBhcnJheSwgcmF0aGVyXG4gICAgLy8gdGhhbiBhIE1vbmdvb3NlIGFycmF5LlxuICAgIHJldHVybiBbXS5jb25jYXQodGhpcy5tYXAoZnVuY3Rpb24oZG9jKSB7XG4gICAgICBpZiAoZG9jID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIGRvYy50b09iamVjdCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gZG9jO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRvYy50b09iamVjdChvcHRpb25zKTtcbiAgICB9KSk7XG4gIH0sXG5cbiAgJHRvT2JqZWN0KCkge1xuICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdG9yLnByb3RvdHlwZS50b09iamVjdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBXcmFwcyBbYEFycmF5I3B1c2hgXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9BcnJheS9wdXNoKSB3aXRoIHByb3BlciBjaGFuZ2UgdHJhY2tpbmcuXG4gICAqXG4gICAqIEBwYXJhbSB7Li4uT2JqZWN0fSBbYXJnc11cbiAgICogQGFwaSBwdWJsaWNcbiAgICogQG1ldGhvZCBwdXNoXG4gICAqIEBtZW1iZXJPZiBNb25nb29zZURvY3VtZW50QXJyYXlcbiAgICovXG5cbiAgcHVzaCgpIHtcbiAgICBjb25zdCByZXQgPSBBcnJheU1ldGhvZHMucHVzaC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG4gICAgX3VwZGF0ZVBhcmVudFBvcHVsYXRlZCh0aGlzKTtcblxuICAgIHJldHVybiByZXQ7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFB1bGxzIGl0ZW1zIGZyb20gdGhlIGFycmF5IGF0b21pY2FsbHkuXG4gICAqXG4gICAqIEBwYXJhbSB7Li4uT2JqZWN0fSBbYXJnc11cbiAgICogQGFwaSBwdWJsaWNcbiAgICogQG1ldGhvZCBwdWxsXG4gICAqIEBtZW1iZXJPZiBNb25nb29zZURvY3VtZW50QXJyYXlcbiAgICovXG5cbiAgcHVsbCgpIHtcbiAgICBjb25zdCByZXQgPSBBcnJheU1ldGhvZHMucHVsbC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG4gICAgX3VwZGF0ZVBhcmVudFBvcHVsYXRlZCh0aGlzKTtcblxuICAgIHJldHVybiByZXQ7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFdyYXBzIFtgQXJyYXkjc2hpZnRgXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9BcnJheS91bnNoaWZ0KSB3aXRoIHByb3BlciBjaGFuZ2UgdHJhY2tpbmcuXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cblxuICBzaGlmdCgpIHtcbiAgICBjb25zdCByZXQgPSBBcnJheU1ldGhvZHMuc2hpZnQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuICAgIF91cGRhdGVQYXJlbnRQb3B1bGF0ZWQodGhpcyk7XG5cbiAgICByZXR1cm4gcmV0O1xuICB9LFxuXG4gIC8qKlxuICAgKiBXcmFwcyBbYEFycmF5I3NwbGljZWBdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0FycmF5L3NwbGljZSkgd2l0aCBwcm9wZXIgY2hhbmdlIHRyYWNraW5nIGFuZCBjYXN0aW5nLlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG5cbiAgc3BsaWNlKCkge1xuICAgIGNvbnN0IHJldCA9IEFycmF5TWV0aG9kcy5zcGxpY2UuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuICAgIF91cGRhdGVQYXJlbnRQb3B1bGF0ZWQodGhpcyk7XG5cbiAgICByZXR1cm4gcmV0O1xuICB9LFxuXG4gIC8qKlxuICAgKiBIZWxwZXIgZm9yIGNvbnNvbGUubG9nXG4gICAqXG4gICAqIEBtZXRob2QgaW5zcGVjdFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKiBAbWVtYmVyT2YgTW9uZ29vc2VEb2N1bWVudEFycmF5XG4gICAqL1xuXG4gIGluc3BlY3QoKSB7XG4gICAgcmV0dXJuIHRoaXMudG9PYmplY3QoKTtcbiAgfSxcblxuICAvKipcbiAgICogQ3JlYXRlcyBhIHN1YmRvY3VtZW50IGNhc3RlZCB0byB0aGlzIHNjaGVtYS5cbiAgICpcbiAgICogVGhpcyBpcyB0aGUgc2FtZSBzdWJkb2N1bWVudCBjb25zdHJ1Y3RvciB1c2VkIGZvciBjYXN0aW5nLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqIHRoZSB2YWx1ZSB0byBjYXN0IHRvIHRoaXMgYXJyYXlzIFN1YkRvY3VtZW50IHNjaGVtYVxuICAgKiBAbWV0aG9kIGNyZWF0ZVxuICAgKiBAYXBpIHB1YmxpY1xuICAgKiBAbWVtYmVyT2YgTW9uZ29vc2VEb2N1bWVudEFycmF5XG4gICAqL1xuXG4gIGNyZWF0ZShvYmopIHtcbiAgICBsZXQgQ29uc3RydWN0b3IgPSB0aGlzW2FycmF5U2NoZW1hU3ltYm9sXS5jYXN0ZXJDb25zdHJ1Y3RvcjtcbiAgICBpZiAob2JqICYmXG4gICAgICAgIENvbnN0cnVjdG9yLmRpc2NyaW1pbmF0b3JzICYmXG4gICAgICAgIENvbnN0cnVjdG9yLnNjaGVtYSAmJlxuICAgICAgICBDb25zdHJ1Y3Rvci5zY2hlbWEub3B0aW9ucyAmJlxuICAgICAgICBDb25zdHJ1Y3Rvci5zY2hlbWEub3B0aW9ucy5kaXNjcmltaW5hdG9yS2V5KSB7XG4gICAgICBpZiAodHlwZW9mIG9ialtDb25zdHJ1Y3Rvci5zY2hlbWEub3B0aW9ucy5kaXNjcmltaW5hdG9yS2V5XSA9PT0gJ3N0cmluZycgJiZcbiAgICAgICAgICBDb25zdHJ1Y3Rvci5kaXNjcmltaW5hdG9yc1tvYmpbQ29uc3RydWN0b3Iuc2NoZW1hLm9wdGlvbnMuZGlzY3JpbWluYXRvcktleV1dKSB7XG4gICAgICAgIENvbnN0cnVjdG9yID0gQ29uc3RydWN0b3IuZGlzY3JpbWluYXRvcnNbb2JqW0NvbnN0cnVjdG9yLnNjaGVtYS5vcHRpb25zLmRpc2NyaW1pbmF0b3JLZXldXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGNvbnN0cnVjdG9yQnlWYWx1ZSA9IGdldERpc2NyaW1pbmF0b3JCeVZhbHVlKENvbnN0cnVjdG9yLmRpc2NyaW1pbmF0b3JzLCBvYmpbQ29uc3RydWN0b3Iuc2NoZW1hLm9wdGlvbnMuZGlzY3JpbWluYXRvcktleV0pO1xuICAgICAgICBpZiAoY29uc3RydWN0b3JCeVZhbHVlKSB7XG4gICAgICAgICAgQ29uc3RydWN0b3IgPSBjb25zdHJ1Y3RvckJ5VmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IENvbnN0cnVjdG9yKG9iaiwgdGhpcyk7XG4gIH0sXG5cbiAgLyohXG4gICAqIGlnbm9yZVxuICAgKi9cblxuICBub3RpZnkoZXZlbnQpIHtcbiAgICBjb25zdCBfdGhpcyA9IHRoaXM7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIG5vdGlmeSh2YWwsIF9hcnIpIHtcbiAgICAgIF9hcnIgPSBfYXJyIHx8IF90aGlzO1xuICAgICAgbGV0IGkgPSBfYXJyLmxlbmd0aDtcbiAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgaWYgKF9hcnJbaV0gPT0gbnVsbCkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHN3aXRjaCAoZXZlbnQpIHtcbiAgICAgICAgICAvLyBvbmx5IHN3YXAgZm9yIHNhdmUgZXZlbnQgZm9yIG5vdywgd2UgbWF5IGNoYW5nZSB0aGlzIHRvIGFsbCBldmVudCB0eXBlcyBsYXRlclxuICAgICAgICAgIGNhc2UgJ3NhdmUnOlxuICAgICAgICAgICAgdmFsID0gX3RoaXNbaV07XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgLy8gTk8tT1BcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHV0aWxzLmlzTW9uZ29vc2VBcnJheShfYXJyW2ldKSkge1xuICAgICAgICAgIG5vdGlmeSh2YWwsIF9hcnJbaV0pO1xuICAgICAgICB9IGVsc2UgaWYgKF9hcnJbaV0pIHtcbiAgICAgICAgICBfYXJyW2ldLmVtaXQoZXZlbnQsIHZhbCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICB9LFxuXG4gIHNldChpLCB2YWwsIHNraXBNb2RpZmllZCkge1xuICAgIGNvbnN0IGFyciA9IHRoaXMuX19hcnJheTtcbiAgICBpZiAoc2tpcE1vZGlmaWVkKSB7XG4gICAgICBhcnJbaV0gPSB2YWw7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgY29uc3QgdmFsdWUgPSBtZXRob2RzLl9jYXN0LmNhbGwodGhpcywgdmFsLCBpKTtcbiAgICBtZXRob2RzLl9tYXJrTW9kaWZpZWQuY2FsbCh0aGlzLCBpKTtcbiAgICBhcnJbaV0gPSB2YWx1ZTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICBfbWFya01vZGlmaWVkKGVsZW0sIGVtYmVkZGVkUGF0aCkge1xuICAgIGNvbnN0IHBhcmVudCA9IHRoaXNbYXJyYXlQYXJlbnRTeW1ib2xdO1xuICAgIGxldCBkaXJ0eVBhdGg7XG5cbiAgICBpZiAocGFyZW50KSB7XG4gICAgICBkaXJ0eVBhdGggPSB0aGlzW2FycmF5UGF0aFN5bWJvbF07XG5cbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgIGlmIChlbWJlZGRlZFBhdGggIT0gbnVsbCkge1xuICAgICAgICAgIC8vIGFuIGVtYmVkZGVkIGRvYyBidWJibGVkIHVwIHRoZSBjaGFuZ2VcbiAgICAgICAgICBjb25zdCBpbmRleCA9IGVsZW0uX19pbmRleDtcbiAgICAgICAgICBkaXJ0eVBhdGggPSBkaXJ0eVBhdGggKyAnLicgKyBpbmRleCArICcuJyArIGVtYmVkZGVkUGF0aDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBkaXJlY3RseSBzZXQgYW4gaW5kZXhcbiAgICAgICAgICBkaXJ0eVBhdGggPSBkaXJ0eVBhdGggKyAnLicgKyBlbGVtO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChkaXJ0eVBhdGggIT0gbnVsbCAmJiBkaXJ0eVBhdGguZW5kc1dpdGgoJy4kJykpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIHBhcmVudC5tYXJrTW9kaWZpZWQoZGlydHlQYXRoLCBhcmd1bWVudHMubGVuZ3RoICE9PSAwID8gZWxlbSA6IHBhcmVudCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gbWV0aG9kcztcblxuLyoqXG4gKiBJZiB0aGlzIGlzIGEgZG9jdW1lbnQgYXJyYXksIGVhY2ggZWxlbWVudCBtYXkgY29udGFpbiBzaW5nbGVcbiAqIHBvcHVsYXRlZCBwYXRocywgc28gd2UgbmVlZCB0byBtb2RpZnkgdGhlIHRvcC1sZXZlbCBkb2N1bWVudCdzXG4gKiBwb3B1bGF0ZWQgY2FjaGUuIFNlZSBnaC04MjQ3LCBnaC04MjY1LlxuICogQHBhcmFtIHtBcnJheX0gYXJyXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBfdXBkYXRlUGFyZW50UG9wdWxhdGVkKGFycikge1xuICBjb25zdCBwYXJlbnQgPSBhcnJbYXJyYXlQYXJlbnRTeW1ib2xdO1xuICBpZiAoIXBhcmVudCB8fCBwYXJlbnQuJF9fLnBvcHVsYXRlZCA9PSBudWxsKSByZXR1cm47XG5cbiAgY29uc3QgcG9wdWxhdGVkUGF0aHMgPSBPYmplY3Qua2V5cyhwYXJlbnQuJF9fLnBvcHVsYXRlZCkuXG4gICAgZmlsdGVyKHAgPT4gcC5zdGFydHNXaXRoKGFyclthcnJheVBhdGhTeW1ib2xdICsgJy4nKSk7XG5cbiAgZm9yIChjb25zdCBwYXRoIG9mIHBvcHVsYXRlZFBhdGhzKSB7XG4gICAgY29uc3QgcmVtbmFudCA9IHBhdGguc2xpY2UoKGFyclthcnJheVBhdGhTeW1ib2xdICsgJy4nKS5sZW5ndGgpO1xuICAgIGlmICghQXJyYXkuaXNBcnJheShwYXJlbnQuJF9fLnBvcHVsYXRlZFtwYXRoXS52YWx1ZSkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHBhcmVudC4kX18ucG9wdWxhdGVkW3BhdGhdLnZhbHVlID0gYXJyLm1hcCh2YWwgPT4gdmFsLiRwb3B1bGF0ZWQocmVtbmFudCkpO1xuICB9XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../server/node_modules/mongoose/lib/types/documentArray/methods/index.js\n");

/***/ }),

/***/ "../server/node_modules/mongoose/lib/types/index.js":
/*!**********************************************************!*\
  !*** ../server/node_modules/mongoose/lib/types/index.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n/*!\n * Module exports.\n */\n\n\n\nexports.Array = __webpack_require__(/*! ./array */ \"../server/node_modules/mongoose/lib/types/array/index.js\");\nexports.Buffer = __webpack_require__(/*! ./buffer */ \"../server/node_modules/mongoose/lib/types/buffer.js\");\n\nexports.Document = // @deprecate\nexports.Embedded = __webpack_require__(/*! ./arraySubdocument */ \"../server/node_modules/mongoose/lib/types/arraySubdocument.js\");\n\nexports.DocumentArray = __webpack_require__(/*! ./documentArray */ \"../server/node_modules/mongoose/lib/types/documentArray/index.js\");\nexports.Decimal128 = __webpack_require__(/*! ./decimal128 */ \"../server/node_modules/mongoose/lib/types/decimal128.js\");\nexports.ObjectId = __webpack_require__(/*! ./objectid */ \"../server/node_modules/mongoose/lib/types/objectid.js\");\n\nexports.Map = __webpack_require__(/*! ./map */ \"../server/node_modules/mongoose/lib/types/map.js\");\n\nexports.Subdocument = __webpack_require__(/*! ./subdocument */ \"../server/node_modules/mongoose/lib/types/subdocument.js\");\n\nexports.UUID = __webpack_require__(/*! ./uuid */ \"../server/node_modules/mongoose/lib/types/uuid.js\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvdHlwZXMvaW5kZXguanMiLCJtYXBwaW5ncyI6IjtBQUNBO0FBQ0E7QUFDQTs7QUFFYTs7QUFFYiw4R0FBa0M7QUFDbEMsMkdBQW9DOztBQUVwQyxnQkFBZ0I7QUFDaEIsaUlBQWdEOztBQUVoRCxzSUFBa0Q7QUFDbEQsdUhBQTRDO0FBQzVDLGlIQUF3Qzs7QUFFeEMsa0dBQThCOztBQUU5QiwwSEFBOEM7O0FBRTlDLHFHQUFnQyIsInNvdXJjZXMiOlsid2VicGFjazovL2NsaWVudC8uLi9zZXJ2ZXIvbm9kZV9tb2R1bGVzL21vbmdvb3NlL2xpYi90eXBlcy9pbmRleC5qcz9hNDYwIl0sInNvdXJjZXNDb250ZW50IjpbIlxuLyohXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuQXJyYXkgPSByZXF1aXJlKCcuL2FycmF5Jyk7XG5leHBvcnRzLkJ1ZmZlciA9IHJlcXVpcmUoJy4vYnVmZmVyJyk7XG5cbmV4cG9ydHMuRG9jdW1lbnQgPSAvLyBAZGVwcmVjYXRlXG5leHBvcnRzLkVtYmVkZGVkID0gcmVxdWlyZSgnLi9hcnJheVN1YmRvY3VtZW50Jyk7XG5cbmV4cG9ydHMuRG9jdW1lbnRBcnJheSA9IHJlcXVpcmUoJy4vZG9jdW1lbnRBcnJheScpO1xuZXhwb3J0cy5EZWNpbWFsMTI4ID0gcmVxdWlyZSgnLi9kZWNpbWFsMTI4Jyk7XG5leHBvcnRzLk9iamVjdElkID0gcmVxdWlyZSgnLi9vYmplY3RpZCcpO1xuXG5leHBvcnRzLk1hcCA9IHJlcXVpcmUoJy4vbWFwJyk7XG5cbmV4cG9ydHMuU3ViZG9jdW1lbnQgPSByZXF1aXJlKCcuL3N1YmRvY3VtZW50Jyk7XG5cbmV4cG9ydHMuVVVJRCA9IHJlcXVpcmUoJy4vdXVpZCcpO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../server/node_modules/mongoose/lib/types/index.js\n");

/***/ }),

/***/ "../server/node_modules/mongoose/lib/types/map.js":
/*!********************************************************!*\
  !*** ../server/node_modules/mongoose/lib/types/map.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst Mixed = __webpack_require__(/*! ../schema/mixed */ \"../server/node_modules/mongoose/lib/schema/mixed.js\");\nconst MongooseError = __webpack_require__(/*! ../error/mongooseError */ \"../server/node_modules/mongoose/lib/error/mongooseError.js\");\nconst clone = __webpack_require__(/*! ../helpers/clone */ \"../server/node_modules/mongoose/lib/helpers/clone.js\");\nconst deepEqual = (__webpack_require__(/*! ../utils */ \"../server/node_modules/mongoose/lib/utils.js\").deepEqual);\nconst getConstructorName = __webpack_require__(/*! ../helpers/getConstructorName */ \"../server/node_modules/mongoose/lib/helpers/getConstructorName.js\");\nconst handleSpreadDoc = __webpack_require__(/*! ../helpers/document/handleSpreadDoc */ \"../server/node_modules/mongoose/lib/helpers/document/handleSpreadDoc.js\");\nconst util = __webpack_require__(/*! util */ \"util\");\nconst specialProperties = __webpack_require__(/*! ../helpers/specialProperties */ \"../server/node_modules/mongoose/lib/helpers/specialProperties.js\");\nconst isBsonType = __webpack_require__(/*! ../helpers/isBsonType */ \"../server/node_modules/mongoose/lib/helpers/isBsonType.js\");\n\nconst populateModelSymbol = (__webpack_require__(/*! ../helpers/symbols */ \"../server/node_modules/mongoose/lib/helpers/symbols.js\").populateModelSymbol);\n\n/*!\n * ignore\n */\n\nclass MongooseMap extends Map {\n  constructor(v, path, doc, schemaType) {\n    if (getConstructorName(v) === 'Object') {\n      v = Object.keys(v).reduce((arr, key) => arr.concat([[key, v[key]]]), []);\n    }\n    super(v);\n    this.$__parent = doc != null && doc.$__ != null ? doc : null;\n    this.$__path = path;\n    this.$__schemaType = schemaType == null ? new Mixed(path) : schemaType;\n\n    this.$__runDeferred();\n  }\n\n  $init(key, value) {\n    checkValidKey(key);\n\n    super.set(key, value);\n\n    if (value != null && value.$isSingleNested) {\n      value.$basePath = this.$__path + '.' + key;\n    }\n  }\n\n  $__set(key, value) {\n    super.set(key, value);\n  }\n\n  /**\n   * Overwrites native Map's `get()` function to support Mongoose getters.\n   *\n   * @api public\n   * @method get\n   * @memberOf Map\n   */\n\n  get(key, options) {\n    if (isBsonType(key, 'ObjectId')) {\n      key = key.toString();\n    }\n\n    options = options || {};\n    if (options.getters === false) {\n      return super.get(key);\n    }\n    return this.$__schemaType.applyGetters(super.get(key), this.$__parent);\n  }\n\n  /**\n   * Overwrites native Map's `set()` function to support setters, `populate()`,\n   * and change tracking. Note that Mongoose maps _only_ support strings and\n   * ObjectIds as keys.\n   *\n   * #### Example:\n   *\n   *     doc.myMap.set('test', 42); // works\n   *     doc.myMap.set({ obj: 42 }, 42); // Throws \"Mongoose maps only support string keys\"\n   *\n   * @api public\n   * @method set\n   * @memberOf Map\n   */\n\n  set(key, value) {\n    if (isBsonType(key, 'ObjectId')) {\n      key = key.toString();\n    }\n\n    checkValidKey(key);\n    value = handleSpreadDoc(value);\n\n    // Weird, but because you can't assign to `this` before calling `super()`\n    // you can't get access to `$__schemaType` to cast in the initial call to\n    // `set()` from the `super()` constructor.\n\n    if (this.$__schemaType == null) {\n      this.$__deferred = this.$__deferred || [];\n      this.$__deferred.push({ key: key, value: value });\n      return;\n    }\n\n    let _fullPath;\n    const parent = this.$__parent;\n    const populated = parent != null && parent.$__ && parent.$__.populated ?\n      parent.$populated(fullPath.call(this), true) || parent.$populated(this.$__path, true) :\n      null;\n    const priorVal = this.get(key);\n\n    if (populated != null) {\n      if (this.$__schemaType.$isSingleNested) {\n        throw new MongooseError(\n          'Cannot manually populate single nested subdoc underneath Map ' +\n          `at path \"${this.$__path}\". Try using an array instead of a Map.`\n        );\n      }\n      if (Array.isArray(value) && this.$__schemaType.$isMongooseArray) {\n        value = value.map(v => {\n          if (v.$__ == null) {\n            v = new populated.options[populateModelSymbol](v);\n          }\n          // Doesn't support single nested \"in-place\" populate\n          v.$__.wasPopulated = { value: v._id };\n          return v;\n        });\n      } else {\n        if (value.$__ == null) {\n          value = new populated.options[populateModelSymbol](value);\n        }\n        // Doesn't support single nested \"in-place\" populate\n        value.$__.wasPopulated = { value: value._id };\n      }\n    } else {\n      try {\n        const options = this.$__schemaType.$isMongooseDocumentArray || this.$__schemaType.$isSingleNested ?\n          { path: fullPath.call(this) } :\n          null;\n        value = this.$__schemaType.applySetters(\n          value,\n          this.$__parent,\n          false,\n          this.get(key),\n          options\n        );\n      } catch (error) {\n        if (this.$__parent != null && this.$__parent.$__ != null) {\n          this.$__parent.invalidate(fullPath.call(this), error);\n          return;\n        }\n        throw error;\n      }\n    }\n\n    super.set(key, value);\n\n    if (parent != null && parent.$__ != null && !deepEqual(value, priorVal)) {\n      parent.markModified(fullPath.call(this));\n    }\n\n    // Delay calculating full path unless absolutely necessary, because string\n    // concatenation is a bottleneck re: #13171\n    function fullPath() {\n      if (_fullPath) {\n        return _fullPath;\n      }\n      _fullPath = this.$__path + '.' + key;\n      return _fullPath;\n    }\n  }\n\n  /**\n   * Overwrites native Map's `clear()` function to support change tracking.\n   *\n   * @api public\n   * @method clear\n   * @memberOf Map\n   */\n\n  clear() {\n    super.clear();\n    const parent = this.$__parent;\n    if (parent != null) {\n      parent.markModified(this.$__path);\n    }\n  }\n\n  /**\n   * Overwrites native Map's `delete()` function to support change tracking.\n   *\n   * @api public\n   * @method delete\n   * @memberOf Map\n   */\n\n  delete(key) {\n    if (isBsonType(key, 'ObjectId')) {\n      key = key.toString();\n    }\n\n    this.set(key, undefined);\n    return super.delete(key);\n  }\n\n  /**\n   * Converts this map to a native JavaScript Map so the MongoDB driver can serialize it.\n   *\n   * @api public\n   * @method toBSON\n   * @memberOf Map\n   */\n\n  toBSON() {\n    return new Map(this);\n  }\n\n  toObject(options) {\n    if (options && options.flattenMaps) {\n      const ret = {};\n      const keys = this.keys();\n      for (const key of keys) {\n        ret[key] = clone(this.get(key), options);\n      }\n      return ret;\n    }\n\n    return new Map(this);\n  }\n\n  $toObject() {\n    return this.constructor.prototype.toObject.apply(this, arguments);\n  }\n\n  /**\n   * Converts this map to a native JavaScript Map for `JSON.stringify()`. Set\n   * the `flattenMaps` option to convert this map to a POJO instead.\n   *\n   * #### Example:\n   *\n   *     doc.myMap.toJSON() instanceof Map; // true\n   *     doc.myMap.toJSON({ flattenMaps: true }) instanceof Map; // false\n   *\n   * @api public\n   * @method toJSON\n   * @param {Object} [options]\n   * @param {Boolean} [options.flattenMaps=false] set to `true` to convert the map to a POJO rather than a native JavaScript map\n   * @memberOf Map\n   */\n\n  toJSON(options) {\n    if (typeof (options && options.flattenMaps) === 'boolean' ? options.flattenMaps : true) {\n      const ret = {};\n      const keys = this.keys();\n      for (const key of keys) {\n        ret[key] = clone(this.get(key), options);\n      }\n      return ret;\n    }\n\n    return new Map(this);\n  }\n\n  inspect() {\n    return new Map(this);\n  }\n\n  $__runDeferred() {\n    if (!this.$__deferred) {\n      return;\n    }\n\n    for (const keyValueObject of this.$__deferred) {\n      this.set(keyValueObject.key, keyValueObject.value);\n    }\n\n    this.$__deferred = null;\n  }\n}\n\nif (util.inspect.custom) {\n  Object.defineProperty(MongooseMap.prototype, util.inspect.custom, {\n    enumerable: false,\n    writable: false,\n    configurable: false,\n    value: MongooseMap.prototype.inspect\n  });\n}\n\nObject.defineProperty(MongooseMap.prototype, '$__set', {\n  enumerable: false,\n  writable: true,\n  configurable: false\n});\n\nObject.defineProperty(MongooseMap.prototype, '$__parent', {\n  enumerable: false,\n  writable: true,\n  configurable: false\n});\n\nObject.defineProperty(MongooseMap.prototype, '$__path', {\n  enumerable: false,\n  writable: true,\n  configurable: false\n});\n\nObject.defineProperty(MongooseMap.prototype, '$__schemaType', {\n  enumerable: false,\n  writable: true,\n  configurable: false\n});\n\n/**\n * Set to `true` for all Mongoose map instances\n *\n * @api public\n * @property $isMongooseMap\n * @memberOf MongooseMap\n * @instance\n */\n\nObject.defineProperty(MongooseMap.prototype, '$isMongooseMap', {\n  enumerable: false,\n  writable: false,\n  configurable: false,\n  value: true\n});\n\nObject.defineProperty(MongooseMap.prototype, '$__deferredCalls', {\n  enumerable: false,\n  writable: false,\n  configurable: false,\n  value: true\n});\n\n/**\n * Since maps are stored as objects under the hood, keys must be strings\n * and can't contain any invalid characters\n * @param {String} key\n * @api private\n */\n\nfunction checkValidKey(key) {\n  const keyType = typeof key;\n  if (keyType !== 'string') {\n    throw new TypeError(`Mongoose maps only support string keys, got ${keyType}`);\n  }\n  if (key.startsWith('$')) {\n    throw new Error(`Mongoose maps do not support keys that start with \"$\", got \"${key}\"`);\n  }\n  if (key.includes('.')) {\n    throw new Error(`Mongoose maps do not support keys that contain \".\", got \"${key}\"`);\n  }\n  if (specialProperties.has(key)) {\n    throw new Error(`Mongoose maps do not support reserved key name \"${key}\"`);\n  }\n}\n\nmodule.exports = MongooseMap;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvdHlwZXMvbWFwLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLGNBQWMsbUJBQU8sQ0FBQyw0RUFBaUI7QUFDdkMsc0JBQXNCLG1CQUFPLENBQUMsMEZBQXdCO0FBQ3RELGNBQWMsbUJBQU8sQ0FBQyw4RUFBa0I7QUFDeEMsa0JBQWtCLCtGQUE2QjtBQUMvQywyQkFBMkIsbUJBQU8sQ0FBQyx3R0FBK0I7QUFDbEUsd0JBQXdCLG1CQUFPLENBQUMsb0hBQXFDO0FBQ3JFLGFBQWEsbUJBQU8sQ0FBQyxrQkFBTTtBQUMzQiwwQkFBMEIsbUJBQU8sQ0FBQyxzR0FBOEI7QUFDaEUsbUJBQW1CLG1CQUFPLENBQUMsd0ZBQXVCOztBQUVsRCw0QkFBNEIsNkhBQWlEOztBQUU3RTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDLHlCQUF5QixTQUFTLE9BQU87QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsOEJBQThCLHdCQUF3QjtBQUN0RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixhQUFhO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxZQUFZLDRCQUE0QjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUMsNEJBQTRCLG1CQUFtQixrQkFBa0I7QUFDakU7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsU0FBUztBQUN0QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx1RUFBdUUsUUFBUTtBQUMvRTtBQUNBO0FBQ0EsbUZBQW1GLElBQUk7QUFDdkY7QUFDQTtBQUNBLGdGQUFnRixJQUFJO0FBQ3BGO0FBQ0E7QUFDQSx1RUFBdUUsSUFBSTtBQUMzRTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2xpZW50Ly4uL3NlcnZlci9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL3R5cGVzL21hcC5qcz8zNjRjIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3QgTWl4ZWQgPSByZXF1aXJlKCcuLi9zY2hlbWEvbWl4ZWQnKTtcbmNvbnN0IE1vbmdvb3NlRXJyb3IgPSByZXF1aXJlKCcuLi9lcnJvci9tb25nb29zZUVycm9yJyk7XG5jb25zdCBjbG9uZSA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvY2xvbmUnKTtcbmNvbnN0IGRlZXBFcXVhbCA9IHJlcXVpcmUoJy4uL3V0aWxzJykuZGVlcEVxdWFsO1xuY29uc3QgZ2V0Q29uc3RydWN0b3JOYW1lID0gcmVxdWlyZSgnLi4vaGVscGVycy9nZXRDb25zdHJ1Y3Rvck5hbWUnKTtcbmNvbnN0IGhhbmRsZVNwcmVhZERvYyA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvZG9jdW1lbnQvaGFuZGxlU3ByZWFkRG9jJyk7XG5jb25zdCB1dGlsID0gcmVxdWlyZSgndXRpbCcpO1xuY29uc3Qgc3BlY2lhbFByb3BlcnRpZXMgPSByZXF1aXJlKCcuLi9oZWxwZXJzL3NwZWNpYWxQcm9wZXJ0aWVzJyk7XG5jb25zdCBpc0Jzb25UeXBlID0gcmVxdWlyZSgnLi4vaGVscGVycy9pc0Jzb25UeXBlJyk7XG5cbmNvbnN0IHBvcHVsYXRlTW9kZWxTeW1ib2wgPSByZXF1aXJlKCcuLi9oZWxwZXJzL3N5bWJvbHMnKS5wb3B1bGF0ZU1vZGVsU3ltYm9sO1xuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cbmNsYXNzIE1vbmdvb3NlTWFwIGV4dGVuZHMgTWFwIHtcbiAgY29uc3RydWN0b3IodiwgcGF0aCwgZG9jLCBzY2hlbWFUeXBlKSB7XG4gICAgaWYgKGdldENvbnN0cnVjdG9yTmFtZSh2KSA9PT0gJ09iamVjdCcpIHtcbiAgICAgIHYgPSBPYmplY3Qua2V5cyh2KS5yZWR1Y2UoKGFyciwga2V5KSA9PiBhcnIuY29uY2F0KFtba2V5LCB2W2tleV1dXSksIFtdKTtcbiAgICB9XG4gICAgc3VwZXIodik7XG4gICAgdGhpcy4kX19wYXJlbnQgPSBkb2MgIT0gbnVsbCAmJiBkb2MuJF9fICE9IG51bGwgPyBkb2MgOiBudWxsO1xuICAgIHRoaXMuJF9fcGF0aCA9IHBhdGg7XG4gICAgdGhpcy4kX19zY2hlbWFUeXBlID0gc2NoZW1hVHlwZSA9PSBudWxsID8gbmV3IE1peGVkKHBhdGgpIDogc2NoZW1hVHlwZTtcblxuICAgIHRoaXMuJF9fcnVuRGVmZXJyZWQoKTtcbiAgfVxuXG4gICRpbml0KGtleSwgdmFsdWUpIHtcbiAgICBjaGVja1ZhbGlkS2V5KGtleSk7XG5cbiAgICBzdXBlci5zZXQoa2V5LCB2YWx1ZSk7XG5cbiAgICBpZiAodmFsdWUgIT0gbnVsbCAmJiB2YWx1ZS4kaXNTaW5nbGVOZXN0ZWQpIHtcbiAgICAgIHZhbHVlLiRiYXNlUGF0aCA9IHRoaXMuJF9fcGF0aCArICcuJyArIGtleTtcbiAgICB9XG4gIH1cblxuICAkX19zZXQoa2V5LCB2YWx1ZSkge1xuICAgIHN1cGVyLnNldChrZXksIHZhbHVlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBPdmVyd3JpdGVzIG5hdGl2ZSBNYXAncyBgZ2V0KClgIGZ1bmN0aW9uIHRvIHN1cHBvcnQgTW9uZ29vc2UgZ2V0dGVycy5cbiAgICpcbiAgICogQGFwaSBwdWJsaWNcbiAgICogQG1ldGhvZCBnZXRcbiAgICogQG1lbWJlck9mIE1hcFxuICAgKi9cblxuICBnZXQoa2V5LCBvcHRpb25zKSB7XG4gICAgaWYgKGlzQnNvblR5cGUoa2V5LCAnT2JqZWN0SWQnKSkge1xuICAgICAga2V5ID0ga2V5LnRvU3RyaW5nKCk7XG4gICAgfVxuXG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgaWYgKG9wdGlvbnMuZ2V0dGVycyA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybiBzdXBlci5nZXQoa2V5KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuJF9fc2NoZW1hVHlwZS5hcHBseUdldHRlcnMoc3VwZXIuZ2V0KGtleSksIHRoaXMuJF9fcGFyZW50KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBPdmVyd3JpdGVzIG5hdGl2ZSBNYXAncyBgc2V0KClgIGZ1bmN0aW9uIHRvIHN1cHBvcnQgc2V0dGVycywgYHBvcHVsYXRlKClgLFxuICAgKiBhbmQgY2hhbmdlIHRyYWNraW5nLiBOb3RlIHRoYXQgTW9uZ29vc2UgbWFwcyBfb25seV8gc3VwcG9ydCBzdHJpbmdzIGFuZFxuICAgKiBPYmplY3RJZHMgYXMga2V5cy5cbiAgICpcbiAgICogIyMjIyBFeGFtcGxlOlxuICAgKlxuICAgKiAgICAgZG9jLm15TWFwLnNldCgndGVzdCcsIDQyKTsgLy8gd29ya3NcbiAgICogICAgIGRvYy5teU1hcC5zZXQoeyBvYmo6IDQyIH0sIDQyKTsgLy8gVGhyb3dzIFwiTW9uZ29vc2UgbWFwcyBvbmx5IHN1cHBvcnQgc3RyaW5nIGtleXNcIlxuICAgKlxuICAgKiBAYXBpIHB1YmxpY1xuICAgKiBAbWV0aG9kIHNldFxuICAgKiBAbWVtYmVyT2YgTWFwXG4gICAqL1xuXG4gIHNldChrZXksIHZhbHVlKSB7XG4gICAgaWYgKGlzQnNvblR5cGUoa2V5LCAnT2JqZWN0SWQnKSkge1xuICAgICAga2V5ID0ga2V5LnRvU3RyaW5nKCk7XG4gICAgfVxuXG4gICAgY2hlY2tWYWxpZEtleShrZXkpO1xuICAgIHZhbHVlID0gaGFuZGxlU3ByZWFkRG9jKHZhbHVlKTtcblxuICAgIC8vIFdlaXJkLCBidXQgYmVjYXVzZSB5b3UgY2FuJ3QgYXNzaWduIHRvIGB0aGlzYCBiZWZvcmUgY2FsbGluZyBgc3VwZXIoKWBcbiAgICAvLyB5b3UgY2FuJ3QgZ2V0IGFjY2VzcyB0byBgJF9fc2NoZW1hVHlwZWAgdG8gY2FzdCBpbiB0aGUgaW5pdGlhbCBjYWxsIHRvXG4gICAgLy8gYHNldCgpYCBmcm9tIHRoZSBgc3VwZXIoKWAgY29uc3RydWN0b3IuXG5cbiAgICBpZiAodGhpcy4kX19zY2hlbWFUeXBlID09IG51bGwpIHtcbiAgICAgIHRoaXMuJF9fZGVmZXJyZWQgPSB0aGlzLiRfX2RlZmVycmVkIHx8IFtdO1xuICAgICAgdGhpcy4kX19kZWZlcnJlZC5wdXNoKHsga2V5OiBrZXksIHZhbHVlOiB2YWx1ZSB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBsZXQgX2Z1bGxQYXRoO1xuICAgIGNvbnN0IHBhcmVudCA9IHRoaXMuJF9fcGFyZW50O1xuICAgIGNvbnN0IHBvcHVsYXRlZCA9IHBhcmVudCAhPSBudWxsICYmIHBhcmVudC4kX18gJiYgcGFyZW50LiRfXy5wb3B1bGF0ZWQgP1xuICAgICAgcGFyZW50LiRwb3B1bGF0ZWQoZnVsbFBhdGguY2FsbCh0aGlzKSwgdHJ1ZSkgfHwgcGFyZW50LiRwb3B1bGF0ZWQodGhpcy4kX19wYXRoLCB0cnVlKSA6XG4gICAgICBudWxsO1xuICAgIGNvbnN0IHByaW9yVmFsID0gdGhpcy5nZXQoa2V5KTtcblxuICAgIGlmIChwb3B1bGF0ZWQgIT0gbnVsbCkge1xuICAgICAgaWYgKHRoaXMuJF9fc2NoZW1hVHlwZS4kaXNTaW5nbGVOZXN0ZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IE1vbmdvb3NlRXJyb3IoXG4gICAgICAgICAgJ0Nhbm5vdCBtYW51YWxseSBwb3B1bGF0ZSBzaW5nbGUgbmVzdGVkIHN1YmRvYyB1bmRlcm5lYXRoIE1hcCAnICtcbiAgICAgICAgICBgYXQgcGF0aCBcIiR7dGhpcy4kX19wYXRofVwiLiBUcnkgdXNpbmcgYW4gYXJyYXkgaW5zdGVhZCBvZiBhIE1hcC5gXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkgJiYgdGhpcy4kX19zY2hlbWFUeXBlLiRpc01vbmdvb3NlQXJyYXkpIHtcbiAgICAgICAgdmFsdWUgPSB2YWx1ZS5tYXAodiA9PiB7XG4gICAgICAgICAgaWYgKHYuJF9fID09IG51bGwpIHtcbiAgICAgICAgICAgIHYgPSBuZXcgcG9wdWxhdGVkLm9wdGlvbnNbcG9wdWxhdGVNb2RlbFN5bWJvbF0odik7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIERvZXNuJ3Qgc3VwcG9ydCBzaW5nbGUgbmVzdGVkIFwiaW4tcGxhY2VcIiBwb3B1bGF0ZVxuICAgICAgICAgIHYuJF9fLndhc1BvcHVsYXRlZCA9IHsgdmFsdWU6IHYuX2lkIH07XG4gICAgICAgICAgcmV0dXJuIHY7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHZhbHVlLiRfXyA9PSBudWxsKSB7XG4gICAgICAgICAgdmFsdWUgPSBuZXcgcG9wdWxhdGVkLm9wdGlvbnNbcG9wdWxhdGVNb2RlbFN5bWJvbF0odmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIC8vIERvZXNuJ3Qgc3VwcG9ydCBzaW5nbGUgbmVzdGVkIFwiaW4tcGxhY2VcIiBwb3B1bGF0ZVxuICAgICAgICB2YWx1ZS4kX18ud2FzUG9wdWxhdGVkID0geyB2YWx1ZTogdmFsdWUuX2lkIH07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLiRfX3NjaGVtYVR5cGUuJGlzTW9uZ29vc2VEb2N1bWVudEFycmF5IHx8IHRoaXMuJF9fc2NoZW1hVHlwZS4kaXNTaW5nbGVOZXN0ZWQgP1xuICAgICAgICAgIHsgcGF0aDogZnVsbFBhdGguY2FsbCh0aGlzKSB9IDpcbiAgICAgICAgICBudWxsO1xuICAgICAgICB2YWx1ZSA9IHRoaXMuJF9fc2NoZW1hVHlwZS5hcHBseVNldHRlcnMoXG4gICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgdGhpcy4kX19wYXJlbnQsXG4gICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgdGhpcy5nZXQoa2V5KSxcbiAgICAgICAgICBvcHRpb25zXG4gICAgICAgICk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBpZiAodGhpcy4kX19wYXJlbnQgIT0gbnVsbCAmJiB0aGlzLiRfX3BhcmVudC4kX18gIT0gbnVsbCkge1xuICAgICAgICAgIHRoaXMuJF9fcGFyZW50LmludmFsaWRhdGUoZnVsbFBhdGguY2FsbCh0aGlzKSwgZXJyb3IpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzdXBlci5zZXQoa2V5LCB2YWx1ZSk7XG5cbiAgICBpZiAocGFyZW50ICE9IG51bGwgJiYgcGFyZW50LiRfXyAhPSBudWxsICYmICFkZWVwRXF1YWwodmFsdWUsIHByaW9yVmFsKSkge1xuICAgICAgcGFyZW50Lm1hcmtNb2RpZmllZChmdWxsUGF0aC5jYWxsKHRoaXMpKTtcbiAgICB9XG5cbiAgICAvLyBEZWxheSBjYWxjdWxhdGluZyBmdWxsIHBhdGggdW5sZXNzIGFic29sdXRlbHkgbmVjZXNzYXJ5LCBiZWNhdXNlIHN0cmluZ1xuICAgIC8vIGNvbmNhdGVuYXRpb24gaXMgYSBib3R0bGVuZWNrIHJlOiAjMTMxNzFcbiAgICBmdW5jdGlvbiBmdWxsUGF0aCgpIHtcbiAgICAgIGlmIChfZnVsbFBhdGgpIHtcbiAgICAgICAgcmV0dXJuIF9mdWxsUGF0aDtcbiAgICAgIH1cbiAgICAgIF9mdWxsUGF0aCA9IHRoaXMuJF9fcGF0aCArICcuJyArIGtleTtcbiAgICAgIHJldHVybiBfZnVsbFBhdGg7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIE92ZXJ3cml0ZXMgbmF0aXZlIE1hcCdzIGBjbGVhcigpYCBmdW5jdGlvbiB0byBzdXBwb3J0IGNoYW5nZSB0cmFja2luZy5cbiAgICpcbiAgICogQGFwaSBwdWJsaWNcbiAgICogQG1ldGhvZCBjbGVhclxuICAgKiBAbWVtYmVyT2YgTWFwXG4gICAqL1xuXG4gIGNsZWFyKCkge1xuICAgIHN1cGVyLmNsZWFyKCk7XG4gICAgY29uc3QgcGFyZW50ID0gdGhpcy4kX19wYXJlbnQ7XG4gICAgaWYgKHBhcmVudCAhPSBudWxsKSB7XG4gICAgICBwYXJlbnQubWFya01vZGlmaWVkKHRoaXMuJF9fcGF0aCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIE92ZXJ3cml0ZXMgbmF0aXZlIE1hcCdzIGBkZWxldGUoKWAgZnVuY3Rpb24gdG8gc3VwcG9ydCBjaGFuZ2UgdHJhY2tpbmcuXG4gICAqXG4gICAqIEBhcGkgcHVibGljXG4gICAqIEBtZXRob2QgZGVsZXRlXG4gICAqIEBtZW1iZXJPZiBNYXBcbiAgICovXG5cbiAgZGVsZXRlKGtleSkge1xuICAgIGlmIChpc0Jzb25UeXBlKGtleSwgJ09iamVjdElkJykpIHtcbiAgICAgIGtleSA9IGtleS50b1N0cmluZygpO1xuICAgIH1cblxuICAgIHRoaXMuc2V0KGtleSwgdW5kZWZpbmVkKTtcbiAgICByZXR1cm4gc3VwZXIuZGVsZXRlKGtleSk7XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydHMgdGhpcyBtYXAgdG8gYSBuYXRpdmUgSmF2YVNjcmlwdCBNYXAgc28gdGhlIE1vbmdvREIgZHJpdmVyIGNhbiBzZXJpYWxpemUgaXQuXG4gICAqXG4gICAqIEBhcGkgcHVibGljXG4gICAqIEBtZXRob2QgdG9CU09OXG4gICAqIEBtZW1iZXJPZiBNYXBcbiAgICovXG5cbiAgdG9CU09OKCkge1xuICAgIHJldHVybiBuZXcgTWFwKHRoaXMpO1xuICB9XG5cbiAgdG9PYmplY3Qob3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMuZmxhdHRlbk1hcHMpIHtcbiAgICAgIGNvbnN0IHJldCA9IHt9O1xuICAgICAgY29uc3Qga2V5cyA9IHRoaXMua2V5cygpO1xuICAgICAgZm9yIChjb25zdCBrZXkgb2Yga2V5cykge1xuICAgICAgICByZXRba2V5XSA9IGNsb25lKHRoaXMuZ2V0KGtleSksIG9wdGlvbnMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IE1hcCh0aGlzKTtcbiAgfVxuXG4gICR0b09iamVjdCgpIHtcbiAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci5wcm90b3R5cGUudG9PYmplY3QuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb252ZXJ0cyB0aGlzIG1hcCB0byBhIG5hdGl2ZSBKYXZhU2NyaXB0IE1hcCBmb3IgYEpTT04uc3RyaW5naWZ5KClgLiBTZXRcbiAgICogdGhlIGBmbGF0dGVuTWFwc2Agb3B0aW9uIHRvIGNvbnZlcnQgdGhpcyBtYXAgdG8gYSBQT0pPIGluc3RlYWQuXG4gICAqXG4gICAqICMjIyMgRXhhbXBsZTpcbiAgICpcbiAgICogICAgIGRvYy5teU1hcC50b0pTT04oKSBpbnN0YW5jZW9mIE1hcDsgLy8gdHJ1ZVxuICAgKiAgICAgZG9jLm15TWFwLnRvSlNPTih7IGZsYXR0ZW5NYXBzOiB0cnVlIH0pIGluc3RhbmNlb2YgTWFwOyAvLyBmYWxzZVxuICAgKlxuICAgKiBAYXBpIHB1YmxpY1xuICAgKiBAbWV0aG9kIHRvSlNPTlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuZmxhdHRlbk1hcHM9ZmFsc2VdIHNldCB0byBgdHJ1ZWAgdG8gY29udmVydCB0aGUgbWFwIHRvIGEgUE9KTyByYXRoZXIgdGhhbiBhIG5hdGl2ZSBKYXZhU2NyaXB0IG1hcFxuICAgKiBAbWVtYmVyT2YgTWFwXG4gICAqL1xuXG4gIHRvSlNPTihvcHRpb25zKSB7XG4gICAgaWYgKHR5cGVvZiAob3B0aW9ucyAmJiBvcHRpb25zLmZsYXR0ZW5NYXBzKSA9PT0gJ2Jvb2xlYW4nID8gb3B0aW9ucy5mbGF0dGVuTWFwcyA6IHRydWUpIHtcbiAgICAgIGNvbnN0IHJldCA9IHt9O1xuICAgICAgY29uc3Qga2V5cyA9IHRoaXMua2V5cygpO1xuICAgICAgZm9yIChjb25zdCBrZXkgb2Yga2V5cykge1xuICAgICAgICByZXRba2V5XSA9IGNsb25lKHRoaXMuZ2V0KGtleSksIG9wdGlvbnMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IE1hcCh0aGlzKTtcbiAgfVxuXG4gIGluc3BlY3QoKSB7XG4gICAgcmV0dXJuIG5ldyBNYXAodGhpcyk7XG4gIH1cblxuICAkX19ydW5EZWZlcnJlZCgpIHtcbiAgICBpZiAoIXRoaXMuJF9fZGVmZXJyZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBmb3IgKGNvbnN0IGtleVZhbHVlT2JqZWN0IG9mIHRoaXMuJF9fZGVmZXJyZWQpIHtcbiAgICAgIHRoaXMuc2V0KGtleVZhbHVlT2JqZWN0LmtleSwga2V5VmFsdWVPYmplY3QudmFsdWUpO1xuICAgIH1cblxuICAgIHRoaXMuJF9fZGVmZXJyZWQgPSBudWxsO1xuICB9XG59XG5cbmlmICh1dGlsLmluc3BlY3QuY3VzdG9tKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNb25nb29zZU1hcC5wcm90b3R5cGUsIHV0aWwuaW5zcGVjdC5jdXN0b20sIHtcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICB2YWx1ZTogTW9uZ29vc2VNYXAucHJvdG90eXBlLmluc3BlY3RcbiAgfSk7XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShNb25nb29zZU1hcC5wcm90b3R5cGUsICckX19zZXQnLCB7XG4gIGVudW1lcmFibGU6IGZhbHNlLFxuICB3cml0YWJsZTogdHJ1ZSxcbiAgY29uZmlndXJhYmxlOiBmYWxzZVxufSk7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShNb25nb29zZU1hcC5wcm90b3R5cGUsICckX19wYXJlbnQnLCB7XG4gIGVudW1lcmFibGU6IGZhbHNlLFxuICB3cml0YWJsZTogdHJ1ZSxcbiAgY29uZmlndXJhYmxlOiBmYWxzZVxufSk7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShNb25nb29zZU1hcC5wcm90b3R5cGUsICckX19wYXRoJywge1xuICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgd3JpdGFibGU6IHRydWUsXG4gIGNvbmZpZ3VyYWJsZTogZmFsc2Vcbn0pO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoTW9uZ29vc2VNYXAucHJvdG90eXBlLCAnJF9fc2NoZW1hVHlwZScsIHtcbiAgZW51bWVyYWJsZTogZmFsc2UsXG4gIHdyaXRhYmxlOiB0cnVlLFxuICBjb25maWd1cmFibGU6IGZhbHNlXG59KTtcblxuLyoqXG4gKiBTZXQgdG8gYHRydWVgIGZvciBhbGwgTW9uZ29vc2UgbWFwIGluc3RhbmNlc1xuICpcbiAqIEBhcGkgcHVibGljXG4gKiBAcHJvcGVydHkgJGlzTW9uZ29vc2VNYXBcbiAqIEBtZW1iZXJPZiBNb25nb29zZU1hcFxuICogQGluc3RhbmNlXG4gKi9cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KE1vbmdvb3NlTWFwLnByb3RvdHlwZSwgJyRpc01vbmdvb3NlTWFwJywge1xuICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgd3JpdGFibGU6IGZhbHNlLFxuICBjb25maWd1cmFibGU6IGZhbHNlLFxuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShNb25nb29zZU1hcC5wcm90b3R5cGUsICckX19kZWZlcnJlZENhbGxzJywge1xuICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgd3JpdGFibGU6IGZhbHNlLFxuICBjb25maWd1cmFibGU6IGZhbHNlLFxuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbi8qKlxuICogU2luY2UgbWFwcyBhcmUgc3RvcmVkIGFzIG9iamVjdHMgdW5kZXIgdGhlIGhvb2QsIGtleXMgbXVzdCBiZSBzdHJpbmdzXG4gKiBhbmQgY2FuJ3QgY29udGFpbiBhbnkgaW52YWxpZCBjaGFyYWN0ZXJzXG4gKiBAcGFyYW0ge1N0cmluZ30ga2V5XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBjaGVja1ZhbGlkS2V5KGtleSkge1xuICBjb25zdCBrZXlUeXBlID0gdHlwZW9mIGtleTtcbiAgaWYgKGtleVR5cGUgIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgTW9uZ29vc2UgbWFwcyBvbmx5IHN1cHBvcnQgc3RyaW5nIGtleXMsIGdvdCAke2tleVR5cGV9YCk7XG4gIH1cbiAgaWYgKGtleS5zdGFydHNXaXRoKCckJykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYE1vbmdvb3NlIG1hcHMgZG8gbm90IHN1cHBvcnQga2V5cyB0aGF0IHN0YXJ0IHdpdGggXCIkXCIsIGdvdCBcIiR7a2V5fVwiYCk7XG4gIH1cbiAgaWYgKGtleS5pbmNsdWRlcygnLicpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBNb25nb29zZSBtYXBzIGRvIG5vdCBzdXBwb3J0IGtleXMgdGhhdCBjb250YWluIFwiLlwiLCBnb3QgXCIke2tleX1cImApO1xuICB9XG4gIGlmIChzcGVjaWFsUHJvcGVydGllcy5oYXMoa2V5KSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgTW9uZ29vc2UgbWFwcyBkbyBub3Qgc3VwcG9ydCByZXNlcnZlZCBrZXkgbmFtZSBcIiR7a2V5fVwiYCk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBNb25nb29zZU1hcDtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../server/node_modules/mongoose/lib/types/map.js\n");

/***/ }),

/***/ "../server/node_modules/mongoose/lib/types/objectid.js":
/*!*************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/types/objectid.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/**\n * ObjectId type constructor\n *\n * #### Example:\n *\n *     const id = new mongoose.Types.ObjectId;\n *\n * @constructor ObjectId\n */\n\n\n\nconst ObjectId = (__webpack_require__(/*! bson */ \"../server/node_modules/bson/lib/bson.cjs\").ObjectId);\nconst objectIdSymbol = (__webpack_require__(/*! ../helpers/symbols */ \"../server/node_modules/mongoose/lib/helpers/symbols.js\").objectIdSymbol);\n\n/**\n * Getter for convenience with populate, see gh-6115\n * @api private\n */\n\nObject.defineProperty(ObjectId.prototype, '_id', {\n  enumerable: false,\n  configurable: true,\n  get: function() {\n    return this;\n  }\n});\n\n/*!\n * Convenience `valueOf()` to allow comparing ObjectIds using double equals re: gh-7299\n */\n\nif (!ObjectId.prototype.hasOwnProperty('valueOf')) {\n  ObjectId.prototype.valueOf = function objectIdValueOf() {\n    return this.toString();\n  };\n}\n\nObjectId.prototype[objectIdSymbol] = true;\n\nmodule.exports = ObjectId;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvdHlwZXMvb2JqZWN0aWQuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVhOztBQUViLGlCQUFpQixzRkFBd0I7QUFDekMsdUJBQXVCLHdIQUE0Qzs7QUFFbkU7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL2NsaWVudC8uLi9zZXJ2ZXIvbm9kZV9tb2R1bGVzL21vbmdvb3NlL2xpYi90eXBlcy9vYmplY3RpZC5qcz8yN2Q3Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogT2JqZWN0SWQgdHlwZSBjb25zdHJ1Y3RvclxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgY29uc3QgaWQgPSBuZXcgbW9uZ29vc2UuVHlwZXMuT2JqZWN0SWQ7XG4gKlxuICogQGNvbnN0cnVjdG9yIE9iamVjdElkXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBPYmplY3RJZCA9IHJlcXVpcmUoJ2Jzb24nKS5PYmplY3RJZDtcbmNvbnN0IG9iamVjdElkU3ltYm9sID0gcmVxdWlyZSgnLi4vaGVscGVycy9zeW1ib2xzJykub2JqZWN0SWRTeW1ib2w7XG5cbi8qKlxuICogR2V0dGVyIGZvciBjb252ZW5pZW5jZSB3aXRoIHBvcHVsYXRlLCBzZWUgZ2gtNjExNVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KE9iamVjdElkLnByb3RvdHlwZSwgJ19pZCcsIHtcbiAgZW51bWVyYWJsZTogZmFsc2UsXG4gIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxufSk7XG5cbi8qIVxuICogQ29udmVuaWVuY2UgYHZhbHVlT2YoKWAgdG8gYWxsb3cgY29tcGFyaW5nIE9iamVjdElkcyB1c2luZyBkb3VibGUgZXF1YWxzIHJlOiBnaC03Mjk5XG4gKi9cblxuaWYgKCFPYmplY3RJZC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkoJ3ZhbHVlT2YnKSkge1xuICBPYmplY3RJZC5wcm90b3R5cGUudmFsdWVPZiA9IGZ1bmN0aW9uIG9iamVjdElkVmFsdWVPZigpIHtcbiAgICByZXR1cm4gdGhpcy50b1N0cmluZygpO1xuICB9O1xufVxuXG5PYmplY3RJZC5wcm90b3R5cGVbb2JqZWN0SWRTeW1ib2xdID0gdHJ1ZTtcblxubW9kdWxlLmV4cG9ydHMgPSBPYmplY3RJZDtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../server/node_modules/mongoose/lib/types/objectid.js\n");

/***/ }),

/***/ "../server/node_modules/mongoose/lib/types/subdocument.js":
/*!****************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/types/subdocument.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst Document = __webpack_require__(/*! ../document */ \"../server/node_modules/mongoose/lib/document.js\");\nconst immediate = __webpack_require__(/*! ../helpers/immediate */ \"../server/node_modules/mongoose/lib/helpers/immediate.js\");\nconst internalToObjectOptions = (__webpack_require__(/*! ../options */ \"../server/node_modules/mongoose/lib/options.js\").internalToObjectOptions);\nconst util = __webpack_require__(/*! util */ \"util\");\nconst utils = __webpack_require__(/*! ../utils */ \"../server/node_modules/mongoose/lib/utils.js\");\n\nmodule.exports = Subdocument;\n\n/**\n * Subdocument constructor.\n *\n * @inherits Document\n * @api private\n */\n\nfunction Subdocument(value, fields, parent, skipId, options) {\n  if (typeof skipId === 'object' && skipId != null && options == null) {\n    options = skipId;\n    skipId = undefined;\n  }\n  if (parent != null) {\n    // If setting a nested path, should copy isNew from parent re: gh-7048\n    const parentOptions = { isNew: parent.isNew };\n    if ('defaults' in parent.$__) {\n      parentOptions.defaults = parent.$__.defaults;\n    }\n    options = Object.assign(parentOptions, options);\n  }\n  if (options != null && options.path != null) {\n    this.$basePath = options.path;\n  }\n  Document.call(this, value, fields, skipId, options);\n\n  delete this.$__.priorDoc;\n}\n\nSubdocument.prototype = Object.create(Document.prototype);\n\nObject.defineProperty(Subdocument.prototype, '$isSubdocument', {\n  configurable: false,\n  writable: false,\n  value: true\n});\n\nObject.defineProperty(Subdocument.prototype, '$isSingleNested', {\n  configurable: false,\n  writable: false,\n  value: true\n});\n\n/*!\n * ignore\n */\n\nSubdocument.prototype.toBSON = function() {\n  return this.toObject(internalToObjectOptions);\n};\n\n/**\n * Used as a stub for middleware\n *\n * #### Note:\n *\n * _This is a no-op. Does not actually save the doc to the db._\n *\n * @param {Function} [fn]\n * @return {Promise} resolved Promise\n * @api private\n */\n\nSubdocument.prototype.save = async function save(options) {\n  options = options || {};\n\n  if (!options.suppressWarning) {\n    utils.warn('mongoose: calling `save()` on a subdoc does **not** save ' +\n      'the document to MongoDB, it only runs save middleware. ' +\n      'Use `subdoc.save({ suppressWarning: true })` to hide this warning ' +\n      'if you\\'re sure this behavior is right for your app.');\n  }\n\n  return new Promise((resolve, reject) => {\n    this.$__save((err) => {\n      if (err != null) {\n        return reject(err);\n      }\n      resolve(this);\n    });\n  });\n};\n\n/**\n * Given a path relative to this document, return the path relative\n * to the top-level document.\n * @param {String} path\n * @method $__fullPath\n * @memberOf Subdocument\n * @instance\n * @returns {String}\n * @api private\n */\n\nSubdocument.prototype.$__fullPath = function(path) {\n  if (!this.$__.fullPath) {\n    this.ownerDocument();\n  }\n\n  return path ?\n    this.$__.fullPath + '.' + path :\n    this.$__.fullPath;\n};\n\n/**\n * Given a path relative to this document, return the path relative\n * to the top-level document.\n * @param {String} p\n * @returns {String}\n * @method $__pathRelativeToParent\n * @memberOf Subdocument\n * @instance\n * @api private\n */\n\nSubdocument.prototype.$__pathRelativeToParent = function(p) {\n  if (p == null) {\n    return this.$basePath;\n  }\n  return [this.$basePath, p].join('.');\n};\n\n/**\n * Used as a stub for middleware\n *\n * #### Note:\n *\n * _This is a no-op. Does not actually save the doc to the db._\n *\n * @param {Function} [fn]\n * @method $__save\n * @api private\n */\n\nSubdocument.prototype.$__save = function(fn) {\n  return immediate(() => fn(null, this));\n};\n\n/*!\n * ignore\n */\n\nSubdocument.prototype.$isValid = function(path) {\n  const parent = this.$parent();\n  const fullPath = this.$__pathRelativeToParent(path);\n  if (parent != null && fullPath != null) {\n    return parent.$isValid(fullPath);\n  }\n  return Document.prototype.$isValid.call(this, path);\n};\n\n/*!\n * ignore\n */\n\nSubdocument.prototype.markModified = function(path) {\n  Document.prototype.markModified.call(this, path);\n  const parent = this.$parent();\n  const fullPath = this.$__pathRelativeToParent(path);\n\n  if (parent == null || fullPath == null) {\n    return;\n  }\n\n  const myPath = this.$__pathRelativeToParent().replace(/\\.$/, '');\n  if (parent.isDirectModified(myPath) || this.isNew) {\n    return;\n  }\n  this.$__parent.markModified(fullPath, this);\n};\n\n/*!\n * ignore\n */\n\nSubdocument.prototype.isModified = function(paths, options, modifiedPaths) {\n  const parent = this.$parent();\n  if (parent != null) {\n    if (Array.isArray(paths) || typeof paths === 'string') {\n      paths = (Array.isArray(paths) ? paths : paths.split(' '));\n      paths = paths.map(p => this.$__pathRelativeToParent(p)).filter(p => p != null);\n    } else if (!paths) {\n      paths = this.$__pathRelativeToParent();\n    }\n\n    return parent.$isModified(paths, options, modifiedPaths);\n  }\n\n  return Document.prototype.isModified.call(this, paths, options, modifiedPaths);\n};\n\n/**\n * Marks a path as valid, removing existing validation errors.\n *\n * @param {String} path the field to mark as valid\n * @api private\n * @method $markValid\n * @memberOf Subdocument\n */\n\nSubdocument.prototype.$markValid = function(path) {\n  Document.prototype.$markValid.call(this, path);\n  const parent = this.$parent();\n  const fullPath = this.$__pathRelativeToParent(path);\n  if (parent != null && fullPath != null) {\n    parent.$markValid(fullPath);\n  }\n};\n\n/*!\n * ignore\n */\n\nSubdocument.prototype.invalidate = function(path, err, val) {\n  Document.prototype.invalidate.call(this, path, err, val);\n\n  const parent = this.$parent();\n  const fullPath = this.$__pathRelativeToParent(path);\n  if (parent != null && fullPath != null) {\n    parent.invalidate(fullPath, err, val);\n  } else if (err.kind === 'cast' || err.name === 'CastError' || fullPath == null) {\n    throw err;\n  }\n\n  return this.ownerDocument().$__.validationError;\n};\n\n/*!\n * ignore\n */\n\nSubdocument.prototype.$ignore = function(path) {\n  Document.prototype.$ignore.call(this, path);\n  const parent = this.$parent();\n  const fullPath = this.$__pathRelativeToParent(path);\n  if (parent != null && fullPath != null) {\n    parent.$ignore(fullPath);\n  }\n};\n\n/**\n * Returns the top level document of this sub-document.\n *\n * @return {Document}\n */\n\nSubdocument.prototype.ownerDocument = function() {\n  if (this.$__.ownerDocument) {\n    return this.$__.ownerDocument;\n  }\n\n  let parent = this; // eslint-disable-line consistent-this\n  const paths = [];\n  const seenDocs = new Set([parent]);\n\n  while (true) {\n    if (typeof parent.$__pathRelativeToParent !== 'function') {\n      break;\n    }\n    paths.unshift(parent.$__pathRelativeToParent(void 0, true));\n    const _parent = parent.$parent();\n    if (_parent == null) {\n      break;\n    }\n    parent = _parent;\n    if (seenDocs.has(parent)) {\n      throw new Error('Infinite subdocument loop: subdoc with _id ' + parent._id + ' is a parent of itself');\n    }\n\n    seenDocs.add(parent);\n  }\n\n  this.$__.fullPath = paths.join('.');\n\n  this.$__.ownerDocument = parent;\n  return this.$__.ownerDocument;\n};\n\n/*!\n * ignore\n */\n\nSubdocument.prototype.$__fullPathWithIndexes = function() {\n  let parent = this; // eslint-disable-line consistent-this\n  const paths = [];\n  const seenDocs = new Set([parent]);\n\n  while (true) {\n    if (typeof parent.$__pathRelativeToParent !== 'function') {\n      break;\n    }\n    paths.unshift(parent.$__pathRelativeToParent(void 0, false));\n    const _parent = parent.$parent();\n    if (_parent == null) {\n      break;\n    }\n    parent = _parent;\n    if (seenDocs.has(parent)) {\n      throw new Error('Infinite subdocument loop: subdoc with _id ' + parent._id + ' is a parent of itself');\n    }\n\n    seenDocs.add(parent);\n  }\n\n  return paths.join('.');\n};\n\n/**\n * Returns this sub-documents parent document.\n *\n * @api public\n */\n\nSubdocument.prototype.parent = function() {\n  return this.$__parent;\n};\n\n/**\n * Returns this sub-documents parent document.\n *\n * @api public\n * @method $parent\n */\n\nSubdocument.prototype.$parent = Subdocument.prototype.parent;\n\n/**\n * no-op for hooks\n * @param {Function} cb\n * @method $__deleteOne\n * @memberOf Subdocument\n * @instance\n * @api private\n */\n\nSubdocument.prototype.$__deleteOne = function(cb) {\n  if (cb == null) {\n    return;\n  }\n  return cb(null, this);\n};\n\n/**\n * ignore\n * @method $__removeFromParent\n * @memberOf Subdocument\n * @instance\n * @api private\n */\n\nSubdocument.prototype.$__removeFromParent = function() {\n  this.$__parent.set(this.$basePath, null);\n};\n\n/**\n * Null-out this subdoc\n *\n * @param {Object} [options]\n * @param {Function} [callback] optional callback for compatibility with Document.prototype.remove\n */\n\nSubdocument.prototype.deleteOne = function(options, callback) {\n  if (typeof options === 'function') {\n    callback = options;\n    options = null;\n  }\n  registerRemoveListener(this);\n\n  // If removing entire doc, no need to remove subdoc\n  if (!options || !options.noop) {\n    this.$__removeFromParent();\n  }\n\n  return this.$__deleteOne(callback);\n};\n\n/*!\n * ignore\n */\n\nSubdocument.prototype.populate = function() {\n  throw new Error('Mongoose does not support calling populate() on nested ' +\n    'docs. Instead of `doc.nested.populate(\"path\")`, use ' +\n    '`doc.populate(\"nested.path\")`');\n};\n\n/**\n * Helper for console.log\n *\n * @api public\n */\n\nSubdocument.prototype.inspect = function() {\n  return this.toObject();\n};\n\nif (util.inspect.custom) {\n  // Avoid Node deprecation warning DEP0079\n  Subdocument.prototype[util.inspect.custom] = Subdocument.prototype.inspect;\n}\n\n/**\n * Registers remove event listeners for triggering\n * on subdocuments.\n *\n * @param {Subdocument} sub\n * @api private\n */\n\nfunction registerRemoveListener(sub) {\n  let owner = sub.ownerDocument();\n\n  function emitRemove() {\n    owner.$removeListener('save', emitRemove);\n    owner.$removeListener('deleteOne', emitRemove);\n    sub.emit('deleteOne', sub);\n    sub.constructor.emit('deleteOne', sub);\n    owner = sub = null;\n  }\n\n  owner.$on('save', emitRemove);\n  owner.$on('deleteOne', emitRemove);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvdHlwZXMvc3ViZG9jdW1lbnQuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsaUJBQWlCLG1CQUFPLENBQUMsb0VBQWE7QUFDdEMsa0JBQWtCLG1CQUFPLENBQUMsc0ZBQXNCO0FBQ2hELGdDQUFnQyxpSEFBNkM7QUFDN0UsYUFBYSxtQkFBTyxDQUFDLGtCQUFNO0FBQzNCLGNBQWMsbUJBQU8sQ0FBQyw4REFBVTs7QUFFaEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsVUFBVTtBQUNyQixZQUFZLFNBQVM7QUFDckI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQix1QkFBdUI7QUFDakQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFCQUFxQjtBQUNyQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLFdBQVcsVUFBVTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsVUFBVTtBQUNyQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsYUFBYTtBQUN4QjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2xpZW50Ly4uL3NlcnZlci9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL3R5cGVzL3N1YmRvY3VtZW50LmpzPzExN2IiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBEb2N1bWVudCA9IHJlcXVpcmUoJy4uL2RvY3VtZW50Jyk7XG5jb25zdCBpbW1lZGlhdGUgPSByZXF1aXJlKCcuLi9oZWxwZXJzL2ltbWVkaWF0ZScpO1xuY29uc3QgaW50ZXJuYWxUb09iamVjdE9wdGlvbnMgPSByZXF1aXJlKCcuLi9vcHRpb25zJykuaW50ZXJuYWxUb09iamVjdE9wdGlvbnM7XG5jb25zdCB1dGlsID0gcmVxdWlyZSgndXRpbCcpO1xuY29uc3QgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFN1YmRvY3VtZW50O1xuXG4vKipcbiAqIFN1YmRvY3VtZW50IGNvbnN0cnVjdG9yLlxuICpcbiAqIEBpbmhlcml0cyBEb2N1bWVudFxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gU3ViZG9jdW1lbnQodmFsdWUsIGZpZWxkcywgcGFyZW50LCBza2lwSWQsIG9wdGlvbnMpIHtcbiAgaWYgKHR5cGVvZiBza2lwSWQgPT09ICdvYmplY3QnICYmIHNraXBJZCAhPSBudWxsICYmIG9wdGlvbnMgPT0gbnVsbCkge1xuICAgIG9wdGlvbnMgPSBza2lwSWQ7XG4gICAgc2tpcElkID0gdW5kZWZpbmVkO1xuICB9XG4gIGlmIChwYXJlbnQgIT0gbnVsbCkge1xuICAgIC8vIElmIHNldHRpbmcgYSBuZXN0ZWQgcGF0aCwgc2hvdWxkIGNvcHkgaXNOZXcgZnJvbSBwYXJlbnQgcmU6IGdoLTcwNDhcbiAgICBjb25zdCBwYXJlbnRPcHRpb25zID0geyBpc05ldzogcGFyZW50LmlzTmV3IH07XG4gICAgaWYgKCdkZWZhdWx0cycgaW4gcGFyZW50LiRfXykge1xuICAgICAgcGFyZW50T3B0aW9ucy5kZWZhdWx0cyA9IHBhcmVudC4kX18uZGVmYXVsdHM7XG4gICAgfVxuICAgIG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHBhcmVudE9wdGlvbnMsIG9wdGlvbnMpO1xuICB9XG4gIGlmIChvcHRpb25zICE9IG51bGwgJiYgb3B0aW9ucy5wYXRoICE9IG51bGwpIHtcbiAgICB0aGlzLiRiYXNlUGF0aCA9IG9wdGlvbnMucGF0aDtcbiAgfVxuICBEb2N1bWVudC5jYWxsKHRoaXMsIHZhbHVlLCBmaWVsZHMsIHNraXBJZCwgb3B0aW9ucyk7XG5cbiAgZGVsZXRlIHRoaXMuJF9fLnByaW9yRG9jO1xufVxuXG5TdWJkb2N1bWVudC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKERvY3VtZW50LnByb3RvdHlwZSk7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShTdWJkb2N1bWVudC5wcm90b3R5cGUsICckaXNTdWJkb2N1bWVudCcsIHtcbiAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgd3JpdGFibGU6IGZhbHNlLFxuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShTdWJkb2N1bWVudC5wcm90b3R5cGUsICckaXNTaW5nbGVOZXN0ZWQnLCB7XG4gIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gIHdyaXRhYmxlOiBmYWxzZSxcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cblN1YmRvY3VtZW50LnByb3RvdHlwZS50b0JTT04gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMudG9PYmplY3QoaW50ZXJuYWxUb09iamVjdE9wdGlvbnMpO1xufTtcblxuLyoqXG4gKiBVc2VkIGFzIGEgc3R1YiBmb3IgbWlkZGxld2FyZVxuICpcbiAqICMjIyMgTm90ZTpcbiAqXG4gKiBfVGhpcyBpcyBhIG5vLW9wLiBEb2VzIG5vdCBhY3R1YWxseSBzYXZlIHRoZSBkb2MgdG8gdGhlIGRiLl9cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbZm5dXG4gKiBAcmV0dXJuIHtQcm9taXNlfSByZXNvbHZlZCBQcm9taXNlXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5TdWJkb2N1bWVudC5wcm90b3R5cGUuc2F2ZSA9IGFzeW5jIGZ1bmN0aW9uIHNhdmUob3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICBpZiAoIW9wdGlvbnMuc3VwcHJlc3NXYXJuaW5nKSB7XG4gICAgdXRpbHMud2FybignbW9uZ29vc2U6IGNhbGxpbmcgYHNhdmUoKWAgb24gYSBzdWJkb2MgZG9lcyAqKm5vdCoqIHNhdmUgJyArXG4gICAgICAndGhlIGRvY3VtZW50IHRvIE1vbmdvREIsIGl0IG9ubHkgcnVucyBzYXZlIG1pZGRsZXdhcmUuICcgK1xuICAgICAgJ1VzZSBgc3ViZG9jLnNhdmUoeyBzdXBwcmVzc1dhcm5pbmc6IHRydWUgfSlgIHRvIGhpZGUgdGhpcyB3YXJuaW5nICcgK1xuICAgICAgJ2lmIHlvdVxcJ3JlIHN1cmUgdGhpcyBiZWhhdmlvciBpcyByaWdodCBmb3IgeW91ciBhcHAuJyk7XG4gIH1cblxuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIHRoaXMuJF9fc2F2ZSgoZXJyKSA9PiB7XG4gICAgICBpZiAoZXJyICE9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHJlamVjdChlcnIpO1xuICAgICAgfVxuICAgICAgcmVzb2x2ZSh0aGlzKTtcbiAgICB9KTtcbiAgfSk7XG59O1xuXG4vKipcbiAqIEdpdmVuIGEgcGF0aCByZWxhdGl2ZSB0byB0aGlzIGRvY3VtZW50LCByZXR1cm4gdGhlIHBhdGggcmVsYXRpdmVcbiAqIHRvIHRoZSB0b3AtbGV2ZWwgZG9jdW1lbnQuXG4gKiBAcGFyYW0ge1N0cmluZ30gcGF0aFxuICogQG1ldGhvZCAkX19mdWxsUGF0aFxuICogQG1lbWJlck9mIFN1YmRvY3VtZW50XG4gKiBAaW5zdGFuY2VcbiAqIEByZXR1cm5zIHtTdHJpbmd9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5TdWJkb2N1bWVudC5wcm90b3R5cGUuJF9fZnVsbFBhdGggPSBmdW5jdGlvbihwYXRoKSB7XG4gIGlmICghdGhpcy4kX18uZnVsbFBhdGgpIHtcbiAgICB0aGlzLm93bmVyRG9jdW1lbnQoKTtcbiAgfVxuXG4gIHJldHVybiBwYXRoID9cbiAgICB0aGlzLiRfXy5mdWxsUGF0aCArICcuJyArIHBhdGggOlxuICAgIHRoaXMuJF9fLmZ1bGxQYXRoO1xufTtcblxuLyoqXG4gKiBHaXZlbiBhIHBhdGggcmVsYXRpdmUgdG8gdGhpcyBkb2N1bWVudCwgcmV0dXJuIHRoZSBwYXRoIHJlbGF0aXZlXG4gKiB0byB0aGUgdG9wLWxldmVsIGRvY3VtZW50LlxuICogQHBhcmFtIHtTdHJpbmd9IHBcbiAqIEByZXR1cm5zIHtTdHJpbmd9XG4gKiBAbWV0aG9kICRfX3BhdGhSZWxhdGl2ZVRvUGFyZW50XG4gKiBAbWVtYmVyT2YgU3ViZG9jdW1lbnRcbiAqIEBpbnN0YW5jZVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU3ViZG9jdW1lbnQucHJvdG90eXBlLiRfX3BhdGhSZWxhdGl2ZVRvUGFyZW50ID0gZnVuY3Rpb24ocCkge1xuICBpZiAocCA9PSBudWxsKSB7XG4gICAgcmV0dXJuIHRoaXMuJGJhc2VQYXRoO1xuICB9XG4gIHJldHVybiBbdGhpcy4kYmFzZVBhdGgsIHBdLmpvaW4oJy4nKTtcbn07XG5cbi8qKlxuICogVXNlZCBhcyBhIHN0dWIgZm9yIG1pZGRsZXdhcmVcbiAqXG4gKiAjIyMjIE5vdGU6XG4gKlxuICogX1RoaXMgaXMgYSBuby1vcC4gRG9lcyBub3QgYWN0dWFsbHkgc2F2ZSB0aGUgZG9jIHRvIHRoZSBkYi5fXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2ZuXVxuICogQG1ldGhvZCAkX19zYXZlXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5TdWJkb2N1bWVudC5wcm90b3R5cGUuJF9fc2F2ZSA9IGZ1bmN0aW9uKGZuKSB7XG4gIHJldHVybiBpbW1lZGlhdGUoKCkgPT4gZm4obnVsbCwgdGhpcykpO1xufTtcblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5TdWJkb2N1bWVudC5wcm90b3R5cGUuJGlzVmFsaWQgPSBmdW5jdGlvbihwYXRoKSB7XG4gIGNvbnN0IHBhcmVudCA9IHRoaXMuJHBhcmVudCgpO1xuICBjb25zdCBmdWxsUGF0aCA9IHRoaXMuJF9fcGF0aFJlbGF0aXZlVG9QYXJlbnQocGF0aCk7XG4gIGlmIChwYXJlbnQgIT0gbnVsbCAmJiBmdWxsUGF0aCAhPSBudWxsKSB7XG4gICAgcmV0dXJuIHBhcmVudC4kaXNWYWxpZChmdWxsUGF0aCk7XG4gIH1cbiAgcmV0dXJuIERvY3VtZW50LnByb3RvdHlwZS4kaXNWYWxpZC5jYWxsKHRoaXMsIHBhdGgpO1xufTtcblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5TdWJkb2N1bWVudC5wcm90b3R5cGUubWFya01vZGlmaWVkID0gZnVuY3Rpb24ocGF0aCkge1xuICBEb2N1bWVudC5wcm90b3R5cGUubWFya01vZGlmaWVkLmNhbGwodGhpcywgcGF0aCk7XG4gIGNvbnN0IHBhcmVudCA9IHRoaXMuJHBhcmVudCgpO1xuICBjb25zdCBmdWxsUGF0aCA9IHRoaXMuJF9fcGF0aFJlbGF0aXZlVG9QYXJlbnQocGF0aCk7XG5cbiAgaWYgKHBhcmVudCA9PSBudWxsIHx8IGZ1bGxQYXRoID09IG51bGwpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBjb25zdCBteVBhdGggPSB0aGlzLiRfX3BhdGhSZWxhdGl2ZVRvUGFyZW50KCkucmVwbGFjZSgvXFwuJC8sICcnKTtcbiAgaWYgKHBhcmVudC5pc0RpcmVjdE1vZGlmaWVkKG15UGF0aCkgfHwgdGhpcy5pc05ldykge1xuICAgIHJldHVybjtcbiAgfVxuICB0aGlzLiRfX3BhcmVudC5tYXJrTW9kaWZpZWQoZnVsbFBhdGgsIHRoaXMpO1xufTtcblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5TdWJkb2N1bWVudC5wcm90b3R5cGUuaXNNb2RpZmllZCA9IGZ1bmN0aW9uKHBhdGhzLCBvcHRpb25zLCBtb2RpZmllZFBhdGhzKSB7XG4gIGNvbnN0IHBhcmVudCA9IHRoaXMuJHBhcmVudCgpO1xuICBpZiAocGFyZW50ICE9IG51bGwpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShwYXRocykgfHwgdHlwZW9mIHBhdGhzID09PSAnc3RyaW5nJykge1xuICAgICAgcGF0aHMgPSAoQXJyYXkuaXNBcnJheShwYXRocykgPyBwYXRocyA6IHBhdGhzLnNwbGl0KCcgJykpO1xuICAgICAgcGF0aHMgPSBwYXRocy5tYXAocCA9PiB0aGlzLiRfX3BhdGhSZWxhdGl2ZVRvUGFyZW50KHApKS5maWx0ZXIocCA9PiBwICE9IG51bGwpO1xuICAgIH0gZWxzZSBpZiAoIXBhdGhzKSB7XG4gICAgICBwYXRocyA9IHRoaXMuJF9fcGF0aFJlbGF0aXZlVG9QYXJlbnQoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcGFyZW50LiRpc01vZGlmaWVkKHBhdGhzLCBvcHRpb25zLCBtb2RpZmllZFBhdGhzKTtcbiAgfVxuXG4gIHJldHVybiBEb2N1bWVudC5wcm90b3R5cGUuaXNNb2RpZmllZC5jYWxsKHRoaXMsIHBhdGhzLCBvcHRpb25zLCBtb2RpZmllZFBhdGhzKTtcbn07XG5cbi8qKlxuICogTWFya3MgYSBwYXRoIGFzIHZhbGlkLCByZW1vdmluZyBleGlzdGluZyB2YWxpZGF0aW9uIGVycm9ycy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcGF0aCB0aGUgZmllbGQgdG8gbWFyayBhcyB2YWxpZFxuICogQGFwaSBwcml2YXRlXG4gKiBAbWV0aG9kICRtYXJrVmFsaWRcbiAqIEBtZW1iZXJPZiBTdWJkb2N1bWVudFxuICovXG5cblN1YmRvY3VtZW50LnByb3RvdHlwZS4kbWFya1ZhbGlkID0gZnVuY3Rpb24ocGF0aCkge1xuICBEb2N1bWVudC5wcm90b3R5cGUuJG1hcmtWYWxpZC5jYWxsKHRoaXMsIHBhdGgpO1xuICBjb25zdCBwYXJlbnQgPSB0aGlzLiRwYXJlbnQoKTtcbiAgY29uc3QgZnVsbFBhdGggPSB0aGlzLiRfX3BhdGhSZWxhdGl2ZVRvUGFyZW50KHBhdGgpO1xuICBpZiAocGFyZW50ICE9IG51bGwgJiYgZnVsbFBhdGggIT0gbnVsbCkge1xuICAgIHBhcmVudC4kbWFya1ZhbGlkKGZ1bGxQYXRoKTtcbiAgfVxufTtcblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5TdWJkb2N1bWVudC5wcm90b3R5cGUuaW52YWxpZGF0ZSA9IGZ1bmN0aW9uKHBhdGgsIGVyciwgdmFsKSB7XG4gIERvY3VtZW50LnByb3RvdHlwZS5pbnZhbGlkYXRlLmNhbGwodGhpcywgcGF0aCwgZXJyLCB2YWwpO1xuXG4gIGNvbnN0IHBhcmVudCA9IHRoaXMuJHBhcmVudCgpO1xuICBjb25zdCBmdWxsUGF0aCA9IHRoaXMuJF9fcGF0aFJlbGF0aXZlVG9QYXJlbnQocGF0aCk7XG4gIGlmIChwYXJlbnQgIT0gbnVsbCAmJiBmdWxsUGF0aCAhPSBudWxsKSB7XG4gICAgcGFyZW50LmludmFsaWRhdGUoZnVsbFBhdGgsIGVyciwgdmFsKTtcbiAgfSBlbHNlIGlmIChlcnIua2luZCA9PT0gJ2Nhc3QnIHx8IGVyci5uYW1lID09PSAnQ2FzdEVycm9yJyB8fCBmdWxsUGF0aCA9PSBudWxsKSB7XG4gICAgdGhyb3cgZXJyO1xuICB9XG5cbiAgcmV0dXJuIHRoaXMub3duZXJEb2N1bWVudCgpLiRfXy52YWxpZGF0aW9uRXJyb3I7XG59O1xuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cblN1YmRvY3VtZW50LnByb3RvdHlwZS4kaWdub3JlID0gZnVuY3Rpb24ocGF0aCkge1xuICBEb2N1bWVudC5wcm90b3R5cGUuJGlnbm9yZS5jYWxsKHRoaXMsIHBhdGgpO1xuICBjb25zdCBwYXJlbnQgPSB0aGlzLiRwYXJlbnQoKTtcbiAgY29uc3QgZnVsbFBhdGggPSB0aGlzLiRfX3BhdGhSZWxhdGl2ZVRvUGFyZW50KHBhdGgpO1xuICBpZiAocGFyZW50ICE9IG51bGwgJiYgZnVsbFBhdGggIT0gbnVsbCkge1xuICAgIHBhcmVudC4kaWdub3JlKGZ1bGxQYXRoKTtcbiAgfVxufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSB0b3AgbGV2ZWwgZG9jdW1lbnQgb2YgdGhpcyBzdWItZG9jdW1lbnQuXG4gKlxuICogQHJldHVybiB7RG9jdW1lbnR9XG4gKi9cblxuU3ViZG9jdW1lbnQucHJvdG90eXBlLm93bmVyRG9jdW1lbnQgPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMuJF9fLm93bmVyRG9jdW1lbnQpIHtcbiAgICByZXR1cm4gdGhpcy4kX18ub3duZXJEb2N1bWVudDtcbiAgfVxuXG4gIGxldCBwYXJlbnQgPSB0aGlzOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGNvbnNpc3RlbnQtdGhpc1xuICBjb25zdCBwYXRocyA9IFtdO1xuICBjb25zdCBzZWVuRG9jcyA9IG5ldyBTZXQoW3BhcmVudF0pO1xuXG4gIHdoaWxlICh0cnVlKSB7XG4gICAgaWYgKHR5cGVvZiBwYXJlbnQuJF9fcGF0aFJlbGF0aXZlVG9QYXJlbnQgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBwYXRocy51bnNoaWZ0KHBhcmVudC4kX19wYXRoUmVsYXRpdmVUb1BhcmVudCh2b2lkIDAsIHRydWUpKTtcbiAgICBjb25zdCBfcGFyZW50ID0gcGFyZW50LiRwYXJlbnQoKTtcbiAgICBpZiAoX3BhcmVudCA9PSBudWxsKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgcGFyZW50ID0gX3BhcmVudDtcbiAgICBpZiAoc2VlbkRvY3MuaGFzKHBhcmVudCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW5maW5pdGUgc3ViZG9jdW1lbnQgbG9vcDogc3ViZG9jIHdpdGggX2lkICcgKyBwYXJlbnQuX2lkICsgJyBpcyBhIHBhcmVudCBvZiBpdHNlbGYnKTtcbiAgICB9XG5cbiAgICBzZWVuRG9jcy5hZGQocGFyZW50KTtcbiAgfVxuXG4gIHRoaXMuJF9fLmZ1bGxQYXRoID0gcGF0aHMuam9pbignLicpO1xuXG4gIHRoaXMuJF9fLm93bmVyRG9jdW1lbnQgPSBwYXJlbnQ7XG4gIHJldHVybiB0aGlzLiRfXy5vd25lckRvY3VtZW50O1xufTtcblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5TdWJkb2N1bWVudC5wcm90b3R5cGUuJF9fZnVsbFBhdGhXaXRoSW5kZXhlcyA9IGZ1bmN0aW9uKCkge1xuICBsZXQgcGFyZW50ID0gdGhpczsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBjb25zaXN0ZW50LXRoaXNcbiAgY29uc3QgcGF0aHMgPSBbXTtcbiAgY29uc3Qgc2VlbkRvY3MgPSBuZXcgU2V0KFtwYXJlbnRdKTtcblxuICB3aGlsZSAodHJ1ZSkge1xuICAgIGlmICh0eXBlb2YgcGFyZW50LiRfX3BhdGhSZWxhdGl2ZVRvUGFyZW50ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgcGF0aHMudW5zaGlmdChwYXJlbnQuJF9fcGF0aFJlbGF0aXZlVG9QYXJlbnQodm9pZCAwLCBmYWxzZSkpO1xuICAgIGNvbnN0IF9wYXJlbnQgPSBwYXJlbnQuJHBhcmVudCgpO1xuICAgIGlmIChfcGFyZW50ID09IG51bGwpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBwYXJlbnQgPSBfcGFyZW50O1xuICAgIGlmIChzZWVuRG9jcy5oYXMocGFyZW50KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbmZpbml0ZSBzdWJkb2N1bWVudCBsb29wOiBzdWJkb2Mgd2l0aCBfaWQgJyArIHBhcmVudC5faWQgKyAnIGlzIGEgcGFyZW50IG9mIGl0c2VsZicpO1xuICAgIH1cblxuICAgIHNlZW5Eb2NzLmFkZChwYXJlbnQpO1xuICB9XG5cbiAgcmV0dXJuIHBhdGhzLmpvaW4oJy4nKTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGlzIHN1Yi1kb2N1bWVudHMgcGFyZW50IGRvY3VtZW50LlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuU3ViZG9jdW1lbnQucHJvdG90eXBlLnBhcmVudCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy4kX19wYXJlbnQ7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhpcyBzdWItZG9jdW1lbnRzIHBhcmVudCBkb2N1bWVudC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICogQG1ldGhvZCAkcGFyZW50XG4gKi9cblxuU3ViZG9jdW1lbnQucHJvdG90eXBlLiRwYXJlbnQgPSBTdWJkb2N1bWVudC5wcm90b3R5cGUucGFyZW50O1xuXG4vKipcbiAqIG5vLW9wIGZvciBob29rc1xuICogQHBhcmFtIHtGdW5jdGlvbn0gY2JcbiAqIEBtZXRob2QgJF9fZGVsZXRlT25lXG4gKiBAbWVtYmVyT2YgU3ViZG9jdW1lbnRcbiAqIEBpbnN0YW5jZVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU3ViZG9jdW1lbnQucHJvdG90eXBlLiRfX2RlbGV0ZU9uZSA9IGZ1bmN0aW9uKGNiKSB7XG4gIGlmIChjYiA9PSBudWxsKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHJldHVybiBjYihudWxsLCB0aGlzKTtcbn07XG5cbi8qKlxuICogaWdub3JlXG4gKiBAbWV0aG9kICRfX3JlbW92ZUZyb21QYXJlbnRcbiAqIEBtZW1iZXJPZiBTdWJkb2N1bWVudFxuICogQGluc3RhbmNlXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5TdWJkb2N1bWVudC5wcm90b3R5cGUuJF9fcmVtb3ZlRnJvbVBhcmVudCA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLiRfX3BhcmVudC5zZXQodGhpcy4kYmFzZVBhdGgsIG51bGwpO1xufTtcblxuLyoqXG4gKiBOdWxsLW91dCB0aGlzIHN1YmRvY1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gb3B0aW9uYWwgY2FsbGJhY2sgZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBEb2N1bWVudC5wcm90b3R5cGUucmVtb3ZlXG4gKi9cblxuU3ViZG9jdW1lbnQucHJvdG90eXBlLmRlbGV0ZU9uZSA9IGZ1bmN0aW9uKG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNhbGxiYWNrID0gb3B0aW9ucztcbiAgICBvcHRpb25zID0gbnVsbDtcbiAgfVxuICByZWdpc3RlclJlbW92ZUxpc3RlbmVyKHRoaXMpO1xuXG4gIC8vIElmIHJlbW92aW5nIGVudGlyZSBkb2MsIG5vIG5lZWQgdG8gcmVtb3ZlIHN1YmRvY1xuICBpZiAoIW9wdGlvbnMgfHwgIW9wdGlvbnMubm9vcCkge1xuICAgIHRoaXMuJF9fcmVtb3ZlRnJvbVBhcmVudCgpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXMuJF9fZGVsZXRlT25lKGNhbGxiYWNrKTtcbn07XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxuU3ViZG9jdW1lbnQucHJvdG90eXBlLnBvcHVsYXRlID0gZnVuY3Rpb24oKSB7XG4gIHRocm93IG5ldyBFcnJvcignTW9uZ29vc2UgZG9lcyBub3Qgc3VwcG9ydCBjYWxsaW5nIHBvcHVsYXRlKCkgb24gbmVzdGVkICcgK1xuICAgICdkb2NzLiBJbnN0ZWFkIG9mIGBkb2MubmVzdGVkLnBvcHVsYXRlKFwicGF0aFwiKWAsIHVzZSAnICtcbiAgICAnYGRvYy5wb3B1bGF0ZShcIm5lc3RlZC5wYXRoXCIpYCcpO1xufTtcblxuLyoqXG4gKiBIZWxwZXIgZm9yIGNvbnNvbGUubG9nXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5TdWJkb2N1bWVudC5wcm90b3R5cGUuaW5zcGVjdCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy50b09iamVjdCgpO1xufTtcblxuaWYgKHV0aWwuaW5zcGVjdC5jdXN0b20pIHtcbiAgLy8gQXZvaWQgTm9kZSBkZXByZWNhdGlvbiB3YXJuaW5nIERFUDAwNzlcbiAgU3ViZG9jdW1lbnQucHJvdG90eXBlW3V0aWwuaW5zcGVjdC5jdXN0b21dID0gU3ViZG9jdW1lbnQucHJvdG90eXBlLmluc3BlY3Q7XG59XG5cbi8qKlxuICogUmVnaXN0ZXJzIHJlbW92ZSBldmVudCBsaXN0ZW5lcnMgZm9yIHRyaWdnZXJpbmdcbiAqIG9uIHN1YmRvY3VtZW50cy5cbiAqXG4gKiBAcGFyYW0ge1N1YmRvY3VtZW50fSBzdWJcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHJlZ2lzdGVyUmVtb3ZlTGlzdGVuZXIoc3ViKSB7XG4gIGxldCBvd25lciA9IHN1Yi5vd25lckRvY3VtZW50KCk7XG5cbiAgZnVuY3Rpb24gZW1pdFJlbW92ZSgpIHtcbiAgICBvd25lci4kcmVtb3ZlTGlzdGVuZXIoJ3NhdmUnLCBlbWl0UmVtb3ZlKTtcbiAgICBvd25lci4kcmVtb3ZlTGlzdGVuZXIoJ2RlbGV0ZU9uZScsIGVtaXRSZW1vdmUpO1xuICAgIHN1Yi5lbWl0KCdkZWxldGVPbmUnLCBzdWIpO1xuICAgIHN1Yi5jb25zdHJ1Y3Rvci5lbWl0KCdkZWxldGVPbmUnLCBzdWIpO1xuICAgIG93bmVyID0gc3ViID0gbnVsbDtcbiAgfVxuXG4gIG93bmVyLiRvbignc2F2ZScsIGVtaXRSZW1vdmUpO1xuICBvd25lci4kb24oJ2RlbGV0ZU9uZScsIGVtaXRSZW1vdmUpO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../server/node_modules/mongoose/lib/types/subdocument.js\n");

/***/ }),

/***/ "../server/node_modules/mongoose/lib/types/uuid.js":
/*!*********************************************************!*\
  !*** ../server/node_modules/mongoose/lib/types/uuid.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/**\n * UUID type constructor\n *\n * #### Example:\n *\n *     const id = new mongoose.Types.UUID();\n *\n * @constructor UUID\n */\n\n\n\nmodule.exports = __webpack_require__(/*! bson */ \"../server/node_modules/bson/lib/bson.cjs\").UUID;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvdHlwZXMvdXVpZC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7O0FBRWIsaUdBQXFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2xpZW50Ly4uL3NlcnZlci9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL3R5cGVzL3V1aWQuanM/ZjY3MyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFVVSUQgdHlwZSBjb25zdHJ1Y3RvclxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgY29uc3QgaWQgPSBuZXcgbW9uZ29vc2UuVHlwZXMuVVVJRCgpO1xuICpcbiAqIEBjb25zdHJ1Y3RvciBVVUlEXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJ2Jzb24nKS5VVUlEO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../server/node_modules/mongoose/lib/types/uuid.js\n");

/***/ }),

/***/ "../server/node_modules/mongoose/lib/utils.js":
/*!****************************************************!*\
  !*** ../server/node_modules/mongoose/lib/utils.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\n/*!\n * Module dependencies.\n */\n\nconst UUID = (__webpack_require__(/*! bson */ \"../server/node_modules/bson/lib/bson.cjs\").UUID);\nconst ms = __webpack_require__(/*! ms */ \"../server/node_modules/mongoose/node_modules/ms/index.js\");\nconst mpath = __webpack_require__(/*! mpath */ \"../server/node_modules/mpath/index.js\");\nconst ObjectId = __webpack_require__(/*! ./types/objectid */ \"../server/node_modules/mongoose/lib/types/objectid.js\");\nconst PopulateOptions = __webpack_require__(/*! ./options/populateOptions */ \"../server/node_modules/mongoose/lib/options/populateOptions.js\");\nconst clone = __webpack_require__(/*! ./helpers/clone */ \"../server/node_modules/mongoose/lib/helpers/clone.js\");\nconst immediate = __webpack_require__(/*! ./helpers/immediate */ \"../server/node_modules/mongoose/lib/helpers/immediate.js\");\nconst isObject = __webpack_require__(/*! ./helpers/isObject */ \"../server/node_modules/mongoose/lib/helpers/isObject.js\");\nconst isMongooseArray = __webpack_require__(/*! ./types/array/isMongooseArray */ \"../server/node_modules/mongoose/lib/types/array/isMongooseArray.js\");\nconst isMongooseDocumentArray = __webpack_require__(/*! ./types/documentArray/isMongooseDocumentArray */ \"../server/node_modules/mongoose/lib/types/documentArray/isMongooseDocumentArray.js\");\nconst isBsonType = __webpack_require__(/*! ./helpers/isBsonType */ \"../server/node_modules/mongoose/lib/helpers/isBsonType.js\");\nconst getFunctionName = __webpack_require__(/*! ./helpers/getFunctionName */ \"../server/node_modules/mongoose/lib/helpers/getFunctionName.js\");\nconst isMongooseObject = __webpack_require__(/*! ./helpers/isMongooseObject */ \"../server/node_modules/mongoose/lib/helpers/isMongooseObject.js\");\nconst promiseOrCallback = __webpack_require__(/*! ./helpers/promiseOrCallback */ \"../server/node_modules/mongoose/lib/helpers/promiseOrCallback.js\");\nconst schemaMerge = __webpack_require__(/*! ./helpers/schema/merge */ \"../server/node_modules/mongoose/lib/helpers/schema/merge.js\");\nconst specialProperties = __webpack_require__(/*! ./helpers/specialProperties */ \"../server/node_modules/mongoose/lib/helpers/specialProperties.js\");\nconst { trustedSymbol } = __webpack_require__(/*! ./helpers/query/trusted */ \"../server/node_modules/mongoose/lib/helpers/query/trusted.js\");\n\nlet Document;\n\nexports.specialProperties = specialProperties;\n\nexports.isMongooseArray = isMongooseArray.isMongooseArray;\nexports.isMongooseDocumentArray = isMongooseDocumentArray.isMongooseDocumentArray;\nexports.registerMongooseArray = isMongooseArray.registerMongooseArray;\nexports.registerMongooseDocumentArray = isMongooseDocumentArray.registerMongooseDocumentArray;\n\nconst oneSpaceRE = /\\s/;\nconst manySpaceRE = /\\s+/;\n\n/**\n * Produces a collection name from model `name`. By default, just returns\n * the model name\n *\n * @param {String} name a model name\n * @param {Function} pluralize function that pluralizes the collection name\n * @return {String} a collection name\n * @api private\n */\n\nexports.toCollectionName = function(name, pluralize) {\n  if (name === 'system.profile') {\n    return name;\n  }\n  if (name === 'system.indexes') {\n    return name;\n  }\n  if (typeof pluralize === 'function') {\n    return pluralize(name);\n  }\n  return name;\n};\n\n/**\n * Determines if `a` and `b` are deep equal.\n *\n * Modified from node/lib/assert.js\n *\n * @param {any} a a value to compare to `b`\n * @param {any} b a value to compare to `a`\n * @return {Boolean}\n * @api private\n */\n\nexports.deepEqual = function deepEqual(a, b) {\n  if (a === b) {\n    return true;\n  }\n\n  if (typeof a !== 'object' || typeof b !== 'object') {\n    return a === b;\n  }\n\n  if (a instanceof Date && b instanceof Date) {\n    return a.getTime() === b.getTime();\n  }\n\n  if ((isBsonType(a, 'ObjectId') && isBsonType(b, 'ObjectId')) ||\n      (isBsonType(a, 'Decimal128') && isBsonType(b, 'Decimal128'))) {\n    return a.toString() === b.toString();\n  }\n\n  if (a instanceof RegExp && b instanceof RegExp) {\n    return a.source === b.source &&\n        a.ignoreCase === b.ignoreCase &&\n        a.multiline === b.multiline &&\n        a.global === b.global &&\n        a.dotAll === b.dotAll &&\n        a.unicode === b.unicode &&\n        a.sticky === b.sticky &&\n        a.hasIndices === b.hasIndices;\n  }\n\n  if (a == null || b == null) {\n    return false;\n  }\n\n  if (a.prototype !== b.prototype) {\n    return false;\n  }\n\n  if (a instanceof Map || b instanceof Map) {\n    if (!(a instanceof Map) || !(b instanceof Map)) {\n      return false;\n    }\n    return deepEqual(Array.from(a.keys()), Array.from(b.keys())) &&\n      deepEqual(Array.from(a.values()), Array.from(b.values()));\n  }\n\n  // Handle MongooseNumbers\n  if (a instanceof Number && b instanceof Number) {\n    return a.valueOf() === b.valueOf();\n  }\n\n  if (Buffer.isBuffer(a)) {\n    return exports.buffer.areEqual(a, b);\n  }\n\n  if (Array.isArray(a) || Array.isArray(b)) {\n    if (!Array.isArray(a) || !Array.isArray(b)) {\n      return false;\n    }\n    const len = a.length;\n    if (len !== b.length) {\n      return false;\n    }\n    for (let i = 0; i < len; ++i) {\n      if (!deepEqual(a[i], b[i])) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  if (a.$__ != null) {\n    a = a._doc;\n  } else if (isMongooseObject(a)) {\n    a = a.toObject();\n  }\n\n  if (b.$__ != null) {\n    b = b._doc;\n  } else if (isMongooseObject(b)) {\n    b = b.toObject();\n  }\n\n  const ka = Object.keys(a);\n  const kb = Object.keys(b);\n  const kaLength = ka.length;\n\n  // having the same number of owned properties (keys incorporates\n  // hasOwnProperty)\n  if (kaLength !== kb.length) {\n    return false;\n  }\n\n  // ~~~cheap key test\n  for (let i = kaLength - 1; i >= 0; i--) {\n    if (ka[i] !== kb[i]) {\n      return false;\n    }\n  }\n\n  // equivalent values for every corresponding key, and\n  // ~~~possibly expensive deep test\n  for (const key of ka) {\n    if (!deepEqual(a[key], b[key])) {\n      return false;\n    }\n  }\n\n  return true;\n};\n\n/**\n * Get the last element of an array\n * @param {Array} arr\n */\n\nexports.last = function(arr) {\n  if (arr.length > 0) {\n    return arr[arr.length - 1];\n  }\n  return void 0;\n};\n\n/*!\n * ignore\n */\n\nexports.promiseOrCallback = promiseOrCallback;\n\n/*!\n * ignore\n */\n\nexports.cloneArrays = function cloneArrays(arr) {\n  if (!Array.isArray(arr)) {\n    return arr;\n  }\n\n  return arr.map(el => exports.cloneArrays(el));\n};\n\n/*!\n * ignore\n */\n\nexports.omit = function omit(obj, keys) {\n  if (keys == null) {\n    return Object.assign({}, obj);\n  }\n  if (!Array.isArray(keys)) {\n    keys = [keys];\n  }\n\n  const ret = Object.assign({}, obj);\n  for (const key of keys) {\n    delete ret[key];\n  }\n  return ret;\n};\n\n/**\n * Merges `from` into `to` without overwriting existing properties.\n *\n * @param {Object} to\n * @param {Object} from\n * @param {Object} [options]\n * @param {String} [path]\n * @api private\n */\n\nexports.merge = function merge(to, from, options, path) {\n  options = options || {};\n\n  const keys = Object.keys(from);\n  let i = 0;\n  const len = keys.length;\n  let key;\n\n  if (from[trustedSymbol]) {\n    to[trustedSymbol] = from[trustedSymbol];\n  }\n\n  path = path || '';\n  const omitNested = options.omitNested || {};\n\n  while (i < len) {\n    key = keys[i++];\n    if (options.omit && options.omit[key]) {\n      continue;\n    }\n    if (omitNested[path]) {\n      continue;\n    }\n    if (specialProperties.has(key)) {\n      continue;\n    }\n    if (to[key] == null) {\n      to[key] = from[key];\n    } else if (exports.isObject(from[key])) {\n      if (!exports.isObject(to[key])) {\n        to[key] = {};\n      }\n      if (from[key] != null) {\n        // Skip merging schemas if we're creating a discriminator schema and\n        // base schema has a given path as a single nested but discriminator schema\n        // has the path as a document array, or vice versa (gh-9534)\n        if (options.isDiscriminatorSchemaMerge &&\n            (from[key].$isSingleNested && to[key].$isMongooseDocumentArray) ||\n            (from[key].$isMongooseDocumentArray && to[key].$isSingleNested)) {\n          continue;\n        } else if (from[key].instanceOfSchema) {\n          if (to[key].instanceOfSchema) {\n            schemaMerge(to[key], from[key].clone(), options.isDiscriminatorSchemaMerge);\n          } else {\n            to[key] = from[key].clone();\n          }\n          continue;\n        } else if (isBsonType(from[key], 'ObjectId')) {\n          to[key] = new ObjectId(from[key]);\n          continue;\n        }\n      }\n      merge(to[key], from[key], options, path ? path + '.' + key : key);\n    } else if (options.overwrite) {\n      to[key] = from[key];\n    }\n  }\n};\n\n/**\n * Applies toObject recursively.\n *\n * @param {Document|Array|Object} obj\n * @return {Object}\n * @api private\n */\n\nexports.toObject = function toObject(obj) {\n  Document || (Document = __webpack_require__(/*! ./document */ \"../server/node_modules/mongoose/lib/document.js\"));\n  let ret;\n\n  if (obj == null) {\n    return obj;\n  }\n\n  if (obj instanceof Document) {\n    return obj.toObject();\n  }\n\n  if (Array.isArray(obj)) {\n    ret = [];\n\n    for (const doc of obj) {\n      ret.push(toObject(doc));\n    }\n\n    return ret;\n  }\n\n  if (exports.isPOJO(obj)) {\n    ret = {};\n\n    if (obj[trustedSymbol]) {\n      ret[trustedSymbol] = obj[trustedSymbol];\n    }\n\n    for (const k of Object.keys(obj)) {\n      if (specialProperties.has(k)) {\n        continue;\n      }\n      ret[k] = toObject(obj[k]);\n    }\n\n    return ret;\n  }\n\n  return obj;\n};\n\nexports.isObject = isObject;\n\n/**\n * Determines if `arg` is a plain old JavaScript object (POJO). Specifically,\n * `arg` must be an object but not an instance of any special class, like String,\n * ObjectId, etc.\n *\n * `Object.getPrototypeOf()` is part of ES5: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getPrototypeOf\n *\n * @param {Object|Array|String|Function|RegExp|any} arg\n * @api private\n * @return {Boolean}\n */\n\nexports.isPOJO = __webpack_require__(/*! ./helpers/isPOJO */ \"../server/node_modules/mongoose/lib/helpers/isPOJO.js\");\n\n/**\n * Determines if `arg` is an object that isn't an instance of a built-in value\n * class, like Array, Buffer, ObjectId, etc.\n * @param {Any} val\n */\n\nexports.isNonBuiltinObject = function isNonBuiltinObject(val) {\n  return typeof val === 'object' &&\n    !exports.isNativeObject(val) &&\n    !exports.isMongooseType(val) &&\n    !(val instanceof UUID) &&\n    val != null;\n};\n\n/**\n * Determines if `obj` is a built-in object like an array, date, boolean,\n * etc.\n * @param {Any} arg\n */\n\nexports.isNativeObject = function(arg) {\n  return Array.isArray(arg) ||\n    arg instanceof Date ||\n    arg instanceof Boolean ||\n    arg instanceof Number ||\n    arg instanceof String;\n};\n\n/**\n * Determines if `val` is an object that has no own keys\n * @param {Any} val\n */\n\nexports.isEmptyObject = function(val) {\n  return val != null &&\n    typeof val === 'object' &&\n    Object.keys(val).length === 0;\n};\n\n/**\n * Search if `obj` or any POJOs nested underneath `obj` has a property named\n * `key`\n * @param {Object} obj\n * @param {String} key\n */\n\nexports.hasKey = function hasKey(obj, key) {\n  const props = Object.keys(obj);\n  for (const prop of props) {\n    if (prop === key) {\n      return true;\n    }\n    if (exports.isPOJO(obj[prop]) && exports.hasKey(obj[prop], key)) {\n      return true;\n    }\n  }\n  return false;\n};\n\n/**\n * process.nextTick helper.\n *\n * Wraps `callback` in a try/catch + nextTick.\n *\n * node-mongodb-native has a habit of state corruption when an error is immediately thrown from within a collection callback.\n *\n * @param {Function} callback\n * @api private\n */\n\nexports.tick = function tick(callback) {\n  if (typeof callback !== 'function') {\n    return;\n  }\n  return function() {\n    try {\n      callback.apply(this, arguments);\n    } catch (err) {\n      // only nextTick on err to get out of\n      // the event loop and avoid state corruption.\n      immediate(function() {\n        throw err;\n      });\n    }\n  };\n};\n\n/**\n * Returns true if `v` is an object that can be serialized as a primitive in\n * MongoDB\n * @param {Any} v\n */\n\nexports.isMongooseType = function(v) {\n  return isBsonType(v, 'ObjectId') || isBsonType(v, 'Decimal128') || v instanceof Buffer;\n};\n\nexports.isMongooseObject = isMongooseObject;\n\n/**\n * Converts `expires` options of index objects to `expiresAfterSeconds` options for MongoDB.\n *\n * @param {Object} object\n * @api private\n */\n\nexports.expires = function expires(object) {\n  if (!(object && object.constructor.name === 'Object')) {\n    return;\n  }\n  if (!('expires' in object)) {\n    return;\n  }\n\n  object.expireAfterSeconds = (typeof object.expires !== 'string')\n    ? object.expires\n    : Math.round(ms(object.expires) / 1000);\n  delete object.expires;\n};\n\n/**\n * populate helper\n * @param {String} path\n * @param {String} select\n * @param {Model} model\n * @param {Object} match\n * @param {Object} options\n * @param {Any} subPopulate\n * @param {Boolean} justOne\n * @param {Boolean} count\n */\n\nexports.populate = function populate(path, select, model, match, options, subPopulate, justOne, count) {\n  // might have passed an object specifying all arguments\n  let obj = null;\n  if (arguments.length === 1) {\n    if (path instanceof PopulateOptions) {\n      // If reusing old populate docs, avoid reusing `_docs` because that may\n      // lead to bugs and memory leaks. See gh-11641\n      path._docs = [];\n      path._childDocs = [];\n      return [path];\n    }\n\n    if (Array.isArray(path)) {\n      const singles = makeSingles(path);\n      return singles.map(o => exports.populate(o)[0]);\n    }\n\n    if (exports.isObject(path)) {\n      obj = Object.assign({}, path);\n    } else {\n      obj = { path: path };\n    }\n  } else if (typeof model === 'object') {\n    obj = {\n      path: path,\n      select: select,\n      match: model,\n      options: match\n    };\n  } else {\n    obj = {\n      path: path,\n      select: select,\n      model: model,\n      match: match,\n      options: options,\n      populate: subPopulate,\n      justOne: justOne,\n      count: count\n    };\n  }\n\n  if (typeof obj.path !== 'string') {\n    throw new TypeError('utils.populate: invalid path. Expected string. Got typeof `' + typeof path + '`');\n  }\n\n  return _populateObj(obj);\n\n  // The order of select/conditions args is opposite Model.find but\n  // necessary to keep backward compatibility (select could be\n  // an array, string, or object literal).\n  function makeSingles(arr) {\n    const ret = [];\n    arr.forEach(function(obj) {\n      if (oneSpaceRE.test(obj.path)) {\n        const paths = obj.path.split(manySpaceRE);\n        paths.forEach(function(p) {\n          const copy = Object.assign({}, obj);\n          copy.path = p;\n          ret.push(copy);\n        });\n      } else {\n        ret.push(obj);\n      }\n    });\n\n    return ret;\n  }\n};\n\nfunction _populateObj(obj) {\n  if (Array.isArray(obj.populate)) {\n    const ret = [];\n    obj.populate.forEach(function(obj) {\n      if (oneSpaceRE.test(obj.path)) {\n        const copy = Object.assign({}, obj);\n        const paths = copy.path.split(manySpaceRE);\n        paths.forEach(function(p) {\n          copy.path = p;\n          ret.push(exports.populate(copy)[0]);\n        });\n      } else {\n        ret.push(exports.populate(obj)[0]);\n      }\n    });\n    obj.populate = exports.populate(ret);\n  } else if (obj.populate != null && typeof obj.populate === 'object') {\n    obj.populate = exports.populate(obj.populate);\n  }\n\n  const ret = [];\n  const paths = oneSpaceRE.test(obj.path) ? obj.path.split(manySpaceRE) : [obj.path];\n  if (obj.options != null) {\n    obj.options = clone(obj.options);\n  }\n\n  for (const path of paths) {\n    ret.push(new PopulateOptions(Object.assign({}, obj, { path: path })));\n  }\n\n  return ret;\n}\n\n/**\n * Return the value of `obj` at the given `path`.\n *\n * @param {String} path\n * @param {Object} obj\n * @param {Any} map\n */\n\nexports.getValue = function(path, obj, map) {\n  return mpath.get(path, obj, getValueLookup, map);\n};\n\n/*!\n * ignore\n */\n\nconst mapGetterOptions = Object.freeze({ getters: false });\n\nfunction getValueLookup(obj, part) {\n  let _from = obj?._doc || obj;\n  if (_from != null && _from.isMongooseArrayProxy) {\n    _from = _from.__array;\n  }\n  return _from instanceof Map ?\n    _from.get(part, mapGetterOptions) :\n    _from[part];\n}\n\n/**\n * Sets the value of `obj` at the given `path`.\n *\n * @param {String} path\n * @param {Anything} val\n * @param {Object} obj\n * @param {Any} map\n * @param {Any} _copying\n */\n\nexports.setValue = function(path, val, obj, map, _copying) {\n  mpath.set(path, val, obj, '_doc', map, _copying);\n};\n\n/**\n * Returns an array of values from object `o`.\n *\n * @param {Object} o\n * @return {Array}\n * @api private\n */\n\nexports.object = {};\nexports.object.vals = function vals(o) {\n  const keys = Object.keys(o);\n  let i = keys.length;\n  const ret = [];\n\n  while (i--) {\n    ret.push(o[keys[i]]);\n  }\n\n  return ret;\n};\n\nconst hop = Object.prototype.hasOwnProperty;\n\n/**\n * Safer helper for hasOwnProperty checks\n *\n * @param {Object} obj\n * @param {String} prop\n */\n\nexports.object.hasOwnProperty = function(obj, prop) {\n  return hop.call(obj, prop);\n};\n\n/**\n * Determine if `val` is null or undefined\n *\n * @param {Any} val\n * @return {Boolean}\n */\n\nexports.isNullOrUndefined = function(val) {\n  return val === null || val === undefined;\n};\n\n/*!\n * ignore\n */\n\nexports.array = {};\n\n/**\n * Flattens an array.\n *\n * [ 1, [ 2, 3, [4] ]] -> [1,2,3,4]\n *\n * @param {Array} arr\n * @param {Function} [filter] If passed, will be invoked with each item in the array. If `filter` returns a falsy value, the item will not be included in the results.\n * @param {Array} ret\n * @return {Array}\n * @api private\n */\n\nexports.array.flatten = function flatten(arr, filter, ret) {\n  ret || (ret = []);\n\n  arr.forEach(function(item) {\n    if (Array.isArray(item)) {\n      flatten(item, filter, ret);\n    } else {\n      if (!filter || filter(item)) {\n        ret.push(item);\n      }\n    }\n  });\n\n  return ret;\n};\n\n/*!\n * ignore\n */\n\nconst _hasOwnProperty = Object.prototype.hasOwnProperty;\n\nexports.hasUserDefinedProperty = function(obj, key) {\n  if (obj == null) {\n    return false;\n  }\n\n  if (Array.isArray(key)) {\n    for (const k of key) {\n      if (exports.hasUserDefinedProperty(obj, k)) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  if (_hasOwnProperty.call(obj, key)) {\n    return true;\n  }\n  if (typeof obj === 'object' && key in obj) {\n    const v = obj[key];\n    return v !== Object.prototype[key] && v !== Array.prototype[key];\n  }\n\n  return false;\n};\n\n/*!\n * ignore\n */\n\nconst MAX_ARRAY_INDEX = Math.pow(2, 32) - 1;\n\nexports.isArrayIndex = function(val) {\n  if (typeof val === 'number') {\n    return val >= 0 && val <= MAX_ARRAY_INDEX;\n  }\n  if (typeof val === 'string') {\n    if (!/^\\d+$/.test(val)) {\n      return false;\n    }\n    val = +val;\n    return val >= 0 && val <= MAX_ARRAY_INDEX;\n  }\n\n  return false;\n};\n\n/**\n * Removes duplicate values from an array\n *\n * [1, 2, 3, 3, 5] => [1, 2, 3, 5]\n * [ ObjectId(\"550988ba0c19d57f697dc45e\"), ObjectId(\"550988ba0c19d57f697dc45e\") ]\n *    => [ObjectId(\"550988ba0c19d57f697dc45e\")]\n *\n * @param {Array} arr\n * @return {Array}\n * @api private\n */\n\nexports.array.unique = function(arr) {\n  const primitives = new Set();\n  const ids = new Set();\n  const ret = [];\n\n  for (const item of arr) {\n    if (typeof item === 'number' || typeof item === 'string' || item == null) {\n      if (primitives.has(item)) {\n        continue;\n      }\n      ret.push(item);\n      primitives.add(item);\n    } else if (isBsonType(item, 'ObjectId')) {\n      if (ids.has(item.toString())) {\n        continue;\n      }\n      ret.push(item);\n      ids.add(item.toString());\n    } else {\n      ret.push(item);\n    }\n  }\n\n  return ret;\n};\n\nexports.buffer = {};\n\n/**\n * Determines if two buffers are equal.\n *\n * @param {Buffer} a\n * @param {Object} b\n */\n\nexports.buffer.areEqual = function(a, b) {\n  if (!Buffer.isBuffer(a)) {\n    return false;\n  }\n  if (!Buffer.isBuffer(b)) {\n    return false;\n  }\n  if (a.length !== b.length) {\n    return false;\n  }\n  for (let i = 0, len = a.length; i < len; ++i) {\n    if (a[i] !== b[i]) {\n      return false;\n    }\n  }\n  return true;\n};\n\nexports.getFunctionName = getFunctionName;\n\n/**\n * Decorate buffers\n * @param {Object} destination\n * @param {Object} source\n */\n\nexports.decorate = function(destination, source) {\n  for (const key in source) {\n    if (specialProperties.has(key)) {\n      continue;\n    }\n    destination[key] = source[key];\n  }\n};\n\n/**\n * merges to with a copy of from\n *\n * @param {Object} to\n * @param {Object} fromObj\n * @api private\n */\n\nexports.mergeClone = function(to, fromObj) {\n  if (isMongooseObject(fromObj)) {\n    fromObj = fromObj.toObject({\n      transform: false,\n      virtuals: false,\n      depopulate: true,\n      getters: false,\n      flattenDecimals: false\n    });\n  }\n  const keys = Object.keys(fromObj);\n  const len = keys.length;\n  let i = 0;\n  let key;\n\n  while (i < len) {\n    key = keys[i++];\n    if (specialProperties.has(key)) {\n      continue;\n    }\n    if (typeof to[key] === 'undefined') {\n      to[key] = clone(fromObj[key], {\n        transform: false,\n        virtuals: false,\n        depopulate: true,\n        getters: false,\n        flattenDecimals: false\n      });\n    } else {\n      let val = fromObj[key];\n      if (val != null && val.valueOf && !(val instanceof Date)) {\n        val = val.valueOf();\n      }\n      if (exports.isObject(val)) {\n        let obj = val;\n        if (isMongooseObject(val) && !val.isMongooseBuffer) {\n          obj = obj.toObject({\n            transform: false,\n            virtuals: false,\n            depopulate: true,\n            getters: false,\n            flattenDecimals: false\n          });\n        }\n        if (val.isMongooseBuffer) {\n          obj = Buffer.from(obj);\n        }\n        exports.mergeClone(to[key], obj);\n      } else {\n        to[key] = clone(val, {\n          flattenDecimals: false\n        });\n      }\n    }\n  }\n};\n\n/**\n * Executes a function on each element of an array (like _.each)\n *\n * @param {Array} arr\n * @param {Function} fn\n * @api private\n */\n\nexports.each = function(arr, fn) {\n  for (const item of arr) {\n    fn(item);\n  }\n};\n\n/**\n * Rename an object key, while preserving its position in the object\n *\n * @param {Object} oldObj\n * @param {String|Number} oldKey\n * @param {String|Number} newKey\n * @api private\n */\nexports.renameObjKey = function(oldObj, oldKey, newKey) {\n  const keys = Object.keys(oldObj);\n  return keys.reduce(\n    (acc, val) => {\n      if (val === oldKey) {\n        acc[newKey] = oldObj[oldKey];\n      } else {\n        acc[val] = oldObj[val];\n      }\n      return acc;\n    },\n    {}\n  );\n};\n\n/*!\n * ignore\n */\n\nexports.getOption = function(name) {\n  const sources = Array.prototype.slice.call(arguments, 1);\n\n  for (const source of sources) {\n    if (source == null) {\n      continue;\n    }\n    if (source[name] != null) {\n      return source[name];\n    }\n  }\n\n  return null;\n};\n\n/*!\n * ignore\n */\n\nexports.noop = function() {};\n\nexports.errorToPOJO = function errorToPOJO(error) {\n  const isError = error instanceof Error;\n  if (!isError) {\n    throw new Error('`error` must be `instanceof Error`.');\n  }\n\n  const ret = {};\n  for (const properyName of Object.getOwnPropertyNames(error)) {\n    ret[properyName] = error[properyName];\n  }\n  return ret;\n};\n\n/*!\n * ignore\n */\n\nexports.warn = function warn(message) {\n  return process.emitWarning(message, { code: 'MONGOOSE' });\n};\n\n\nexports.injectTimestampsOption = function injectTimestampsOption(writeOperation, timestampsOption) {\n  if (timestampsOption == null) {\n    return;\n  }\n  writeOperation.timestamps = timestampsOption;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvdXRpbHMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7QUFDQTtBQUNBOztBQUVBLGFBQWEsa0ZBQW9CO0FBQ2pDLFdBQVcsbUJBQU8sQ0FBQyxvRUFBSTtBQUN2QixjQUFjLG1CQUFPLENBQUMsb0RBQU87QUFDN0IsaUJBQWlCLG1CQUFPLENBQUMsK0VBQWtCO0FBQzNDLHdCQUF3QixtQkFBTyxDQUFDLGlHQUEyQjtBQUMzRCxjQUFjLG1CQUFPLENBQUMsNkVBQWlCO0FBQ3ZDLGtCQUFrQixtQkFBTyxDQUFDLHFGQUFxQjtBQUMvQyxpQkFBaUIsbUJBQU8sQ0FBQyxtRkFBb0I7QUFDN0Msd0JBQXdCLG1CQUFPLENBQUMseUdBQStCO0FBQy9ELGdDQUFnQyxtQkFBTyxDQUFDLHlJQUErQztBQUN2RixtQkFBbUIsbUJBQU8sQ0FBQyx1RkFBc0I7QUFDakQsd0JBQXdCLG1CQUFPLENBQUMsaUdBQTJCO0FBQzNELHlCQUF5QixtQkFBTyxDQUFDLG1HQUE0QjtBQUM3RCwwQkFBMEIsbUJBQU8sQ0FBQyxxR0FBNkI7QUFDL0Qsb0JBQW9CLG1CQUFPLENBQUMsMkZBQXdCO0FBQ3BELDBCQUEwQixtQkFBTyxDQUFDLHFHQUE2QjtBQUMvRCxRQUFRLGdCQUFnQixFQUFFLG1CQUFPLENBQUMsNkZBQXlCOztBQUUzRDs7QUFFQSx5QkFBeUI7O0FBRXpCLHVCQUF1QjtBQUN2QiwrQkFBK0I7QUFDL0IsNkJBQTZCO0FBQzdCLHFDQUFxQzs7QUFFckM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFVBQVU7QUFDckIsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7O0FBRUEsd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFX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c2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvdXRpbHMuanM/MDNmYSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbi8qIVxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG5jb25zdCBVVUlEID0gcmVxdWlyZSgnYnNvbicpLlVVSUQ7XG5jb25zdCBtcyA9IHJlcXVpcmUoJ21zJyk7XG5jb25zdCBtcGF0aCA9IHJlcXVpcmUoJ21wYXRoJyk7XG5jb25zdCBPYmplY3RJZCA9IHJlcXVpcmUoJy4vdHlwZXMvb2JqZWN0aWQnKTtcbmNvbnN0IFBvcHVsYXRlT3B0aW9ucyA9IHJlcXVpcmUoJy4vb3B0aW9ucy9wb3B1bGF0ZU9wdGlvbnMnKTtcbmNvbnN0IGNsb25lID0gcmVxdWlyZSgnLi9oZWxwZXJzL2Nsb25lJyk7XG5jb25zdCBpbW1lZGlhdGUgPSByZXF1aXJlKCcuL2hlbHBlcnMvaW1tZWRpYXRlJyk7XG5jb25zdCBpc09iamVjdCA9IHJlcXVpcmUoJy4vaGVscGVycy9pc09iamVjdCcpO1xuY29uc3QgaXNNb25nb29zZUFycmF5ID0gcmVxdWlyZSgnLi90eXBlcy9hcnJheS9pc01vbmdvb3NlQXJyYXknKTtcbmNvbnN0IGlzTW9uZ29vc2VEb2N1bWVudEFycmF5ID0gcmVxdWlyZSgnLi90eXBlcy9kb2N1bWVudEFycmF5L2lzTW9uZ29vc2VEb2N1bWVudEFycmF5Jyk7XG5jb25zdCBpc0Jzb25UeXBlID0gcmVxdWlyZSgnLi9oZWxwZXJzL2lzQnNvblR5cGUnKTtcbmNvbnN0IGdldEZ1bmN0aW9uTmFtZSA9IHJlcXVpcmUoJy4vaGVscGVycy9nZXRGdW5jdGlvbk5hbWUnKTtcbmNvbnN0IGlzTW9uZ29vc2VPYmplY3QgPSByZXF1aXJlKCcuL2hlbHBlcnMvaXNNb25nb29zZU9iamVjdCcpO1xuY29uc3QgcHJvbWlzZU9yQ2FsbGJhY2sgPSByZXF1aXJlKCcuL2hlbHBlcnMvcHJvbWlzZU9yQ2FsbGJhY2snKTtcbmNvbnN0IHNjaGVtYU1lcmdlID0gcmVxdWlyZSgnLi9oZWxwZXJzL3NjaGVtYS9tZXJnZScpO1xuY29uc3Qgc3BlY2lhbFByb3BlcnRpZXMgPSByZXF1aXJlKCcuL2hlbHBlcnMvc3BlY2lhbFByb3BlcnRpZXMnKTtcbmNvbnN0IHsgdHJ1c3RlZFN5bWJvbCB9ID0gcmVxdWlyZSgnLi9oZWxwZXJzL3F1ZXJ5L3RydXN0ZWQnKTtcblxubGV0IERvY3VtZW50O1xuXG5leHBvcnRzLnNwZWNpYWxQcm9wZXJ0aWVzID0gc3BlY2lhbFByb3BlcnRpZXM7XG5cbmV4cG9ydHMuaXNNb25nb29zZUFycmF5ID0gaXNNb25nb29zZUFycmF5LmlzTW9uZ29vc2VBcnJheTtcbmV4cG9ydHMuaXNNb25nb29zZURvY3VtZW50QXJyYXkgPSBpc01vbmdvb3NlRG9jdW1lbnRBcnJheS5pc01vbmdvb3NlRG9jdW1lbnRBcnJheTtcbmV4cG9ydHMucmVnaXN0ZXJNb25nb29zZUFycmF5ID0gaXNNb25nb29zZUFycmF5LnJlZ2lzdGVyTW9uZ29vc2VBcnJheTtcbmV4cG9ydHMucmVnaXN0ZXJNb25nb29zZURvY3VtZW50QXJyYXkgPSBpc01vbmdvb3NlRG9jdW1lbnRBcnJheS5yZWdpc3Rlck1vbmdvb3NlRG9jdW1lbnRBcnJheTtcblxuY29uc3Qgb25lU3BhY2VSRSA9IC9cXHMvO1xuY29uc3QgbWFueVNwYWNlUkUgPSAvXFxzKy87XG5cbi8qKlxuICogUHJvZHVjZXMgYSBjb2xsZWN0aW9uIG5hbWUgZnJvbSBtb2RlbCBgbmFtZWAuIEJ5IGRlZmF1bHQsIGp1c3QgcmV0dXJuc1xuICogdGhlIG1vZGVsIG5hbWVcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBhIG1vZGVsIG5hbWVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHBsdXJhbGl6ZSBmdW5jdGlvbiB0aGF0IHBsdXJhbGl6ZXMgdGhlIGNvbGxlY3Rpb24gbmFtZVxuICogQHJldHVybiB7U3RyaW5nfSBhIGNvbGxlY3Rpb24gbmFtZVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZXhwb3J0cy50b0NvbGxlY3Rpb25OYW1lID0gZnVuY3Rpb24obmFtZSwgcGx1cmFsaXplKSB7XG4gIGlmIChuYW1lID09PSAnc3lzdGVtLnByb2ZpbGUnKSB7XG4gICAgcmV0dXJuIG5hbWU7XG4gIH1cbiAgaWYgKG5hbWUgPT09ICdzeXN0ZW0uaW5kZXhlcycpIHtcbiAgICByZXR1cm4gbmFtZTtcbiAgfVxuICBpZiAodHlwZW9mIHBsdXJhbGl6ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBwbHVyYWxpemUobmFtZSk7XG4gIH1cbiAgcmV0dXJuIG5hbWU7XG59O1xuXG4vKipcbiAqIERldGVybWluZXMgaWYgYGFgIGFuZCBgYmAgYXJlIGRlZXAgZXF1YWwuXG4gKlxuICogTW9kaWZpZWQgZnJvbSBub2RlL2xpYi9hc3NlcnQuanNcbiAqXG4gKiBAcGFyYW0ge2FueX0gYSBhIHZhbHVlIHRvIGNvbXBhcmUgdG8gYGJgXG4gKiBAcGFyYW0ge2FueX0gYiBhIHZhbHVlIHRvIGNvbXBhcmUgdG8gYGFgXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZXhwb3J0cy5kZWVwRXF1YWwgPSBmdW5jdGlvbiBkZWVwRXF1YWwoYSwgYikge1xuICBpZiAoYSA9PT0gYikge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBhICE9PSAnb2JqZWN0JyB8fCB0eXBlb2YgYiAhPT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gYSA9PT0gYjtcbiAgfVxuXG4gIGlmIChhIGluc3RhbmNlb2YgRGF0ZSAmJiBiIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgIHJldHVybiBhLmdldFRpbWUoKSA9PT0gYi5nZXRUaW1lKCk7XG4gIH1cblxuICBpZiAoKGlzQnNvblR5cGUoYSwgJ09iamVjdElkJykgJiYgaXNCc29uVHlwZShiLCAnT2JqZWN0SWQnKSkgfHxcbiAgICAgIChpc0Jzb25UeXBlKGEsICdEZWNpbWFsMTI4JykgJiYgaXNCc29uVHlwZShiLCAnRGVjaW1hbDEyOCcpKSkge1xuICAgIHJldHVybiBhLnRvU3RyaW5nKCkgPT09IGIudG9TdHJpbmcoKTtcbiAgfVxuXG4gIGlmIChhIGluc3RhbmNlb2YgUmVnRXhwICYmIGIgaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICByZXR1cm4gYS5zb3VyY2UgPT09IGIuc291cmNlICYmXG4gICAgICAgIGEuaWdub3JlQ2FzZSA9PT0gYi5pZ25vcmVDYXNlICYmXG4gICAgICAgIGEubXVsdGlsaW5lID09PSBiLm11bHRpbGluZSAmJlxuICAgICAgICBhLmdsb2JhbCA9PT0gYi5nbG9iYWwgJiZcbiAgICAgICAgYS5kb3RBbGwgPT09IGIuZG90QWxsICYmXG4gICAgICAgIGEudW5pY29kZSA9PT0gYi51bmljb2RlICYmXG4gICAgICAgIGEuc3RpY2t5ID09PSBiLnN0aWNreSAmJlxuICAgICAgICBhLmhhc0luZGljZXMgPT09IGIuaGFzSW5kaWNlcztcbiAgfVxuXG4gIGlmIChhID09IG51bGwgfHwgYiA9PSBudWxsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKGEucHJvdG90eXBlICE9PSBiLnByb3RvdHlwZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChhIGluc3RhbmNlb2YgTWFwIHx8IGIgaW5zdGFuY2VvZiBNYXApIHtcbiAgICBpZiAoIShhIGluc3RhbmNlb2YgTWFwKSB8fCAhKGIgaW5zdGFuY2VvZiBNYXApKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBkZWVwRXF1YWwoQXJyYXkuZnJvbShhLmtleXMoKSksIEFycmF5LmZyb20oYi5rZXlzKCkpKSAmJlxuICAgICAgZGVlcEVxdWFsKEFycmF5LmZyb20oYS52YWx1ZXMoKSksIEFycmF5LmZyb20oYi52YWx1ZXMoKSkpO1xuICB9XG5cbiAgLy8gSGFuZGxlIE1vbmdvb3NlTnVtYmVyc1xuICBpZiAoYSBpbnN0YW5jZW9mIE51bWJlciAmJiBiIGluc3RhbmNlb2YgTnVtYmVyKSB7XG4gICAgcmV0dXJuIGEudmFsdWVPZigpID09PSBiLnZhbHVlT2YoKTtcbiAgfVxuXG4gIGlmIChCdWZmZXIuaXNCdWZmZXIoYSkpIHtcbiAgICByZXR1cm4gZXhwb3J0cy5idWZmZXIuYXJlRXF1YWwoYSwgYik7XG4gIH1cblxuICBpZiAoQXJyYXkuaXNBcnJheShhKSB8fCBBcnJheS5pc0FycmF5KGIpKSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGEpIHx8ICFBcnJheS5pc0FycmF5KGIpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IGxlbiA9IGEubGVuZ3RoO1xuICAgIGlmIChsZW4gIT09IGIubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgIGlmICghZGVlcEVxdWFsKGFbaV0sIGJbaV0pKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAoYS4kX18gIT0gbnVsbCkge1xuICAgIGEgPSBhLl9kb2M7XG4gIH0gZWxzZSBpZiAoaXNNb25nb29zZU9iamVjdChhKSkge1xuICAgIGEgPSBhLnRvT2JqZWN0KCk7XG4gIH1cblxuICBpZiAoYi4kX18gIT0gbnVsbCkge1xuICAgIGIgPSBiLl9kb2M7XG4gIH0gZWxzZSBpZiAoaXNNb25nb29zZU9iamVjdChiKSkge1xuICAgIGIgPSBiLnRvT2JqZWN0KCk7XG4gIH1cblxuICBjb25zdCBrYSA9IE9iamVjdC5rZXlzKGEpO1xuICBjb25zdCBrYiA9IE9iamVjdC5rZXlzKGIpO1xuICBjb25zdCBrYUxlbmd0aCA9IGthLmxlbmd0aDtcblxuICAvLyBoYXZpbmcgdGhlIHNhbWUgbnVtYmVyIG9mIG93bmVkIHByb3BlcnRpZXMgKGtleXMgaW5jb3Jwb3JhdGVzXG4gIC8vIGhhc093blByb3BlcnR5KVxuICBpZiAoa2FMZW5ndGggIT09IGtiLmxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8vIH5+fmNoZWFwIGtleSB0ZXN0XG4gIGZvciAobGV0IGkgPSBrYUxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgaWYgKGthW2ldICE9PSBrYltpXSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIC8vIGVxdWl2YWxlbnQgdmFsdWVzIGZvciBldmVyeSBjb3JyZXNwb25kaW5nIGtleSwgYW5kXG4gIC8vIH5+fnBvc3NpYmx5IGV4cGVuc2l2ZSBkZWVwIHRlc3RcbiAgZm9yIChjb25zdCBrZXkgb2Yga2EpIHtcbiAgICBpZiAoIWRlZXBFcXVhbChhW2tleV0sIGJba2V5XSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbi8qKlxuICogR2V0IHRoZSBsYXN0IGVsZW1lbnQgb2YgYW4gYXJyYXlcbiAqIEBwYXJhbSB7QXJyYXl9IGFyclxuICovXG5cbmV4cG9ydHMubGFzdCA9IGZ1bmN0aW9uKGFycikge1xuICBpZiAoYXJyLmxlbmd0aCA+IDApIHtcbiAgICByZXR1cm4gYXJyW2Fyci5sZW5ndGggLSAxXTtcbiAgfVxuICByZXR1cm4gdm9pZCAwO1xufTtcblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5leHBvcnRzLnByb21pc2VPckNhbGxiYWNrID0gcHJvbWlzZU9yQ2FsbGJhY2s7XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxuZXhwb3J0cy5jbG9uZUFycmF5cyA9IGZ1bmN0aW9uIGNsb25lQXJyYXlzKGFycikge1xuICBpZiAoIUFycmF5LmlzQXJyYXkoYXJyKSkge1xuICAgIHJldHVybiBhcnI7XG4gIH1cblxuICByZXR1cm4gYXJyLm1hcChlbCA9PiBleHBvcnRzLmNsb25lQXJyYXlzKGVsKSk7XG59O1xuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cbmV4cG9ydHMub21pdCA9IGZ1bmN0aW9uIG9taXQob2JqLCBrZXlzKSB7XG4gIGlmIChrZXlzID09IG51bGwpIHtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgb2JqKTtcbiAgfVxuICBpZiAoIUFycmF5LmlzQXJyYXkoa2V5cykpIHtcbiAgICBrZXlzID0gW2tleXNdO1xuICB9XG5cbiAgY29uc3QgcmV0ID0gT2JqZWN0LmFzc2lnbih7fSwgb2JqKTtcbiAgZm9yIChjb25zdCBrZXkgb2Yga2V5cykge1xuICAgIGRlbGV0ZSByZXRba2V5XTtcbiAgfVxuICByZXR1cm4gcmV0O1xufTtcblxuLyoqXG4gKiBNZXJnZXMgYGZyb21gIGludG8gYHRvYCB3aXRob3V0IG92ZXJ3cml0aW5nIGV4aXN0aW5nIHByb3BlcnRpZXMuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHRvXG4gKiBAcGFyYW0ge09iamVjdH0gZnJvbVxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQHBhcmFtIHtTdHJpbmd9IFtwYXRoXVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZXhwb3J0cy5tZXJnZSA9IGZ1bmN0aW9uIG1lcmdlKHRvLCBmcm9tLCBvcHRpb25zLCBwYXRoKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhmcm9tKTtcbiAgbGV0IGkgPSAwO1xuICBjb25zdCBsZW4gPSBrZXlzLmxlbmd0aDtcbiAgbGV0IGtleTtcblxuICBpZiAoZnJvbVt0cnVzdGVkU3ltYm9sXSkge1xuICAgIHRvW3RydXN0ZWRTeW1ib2xdID0gZnJvbVt0cnVzdGVkU3ltYm9sXTtcbiAgfVxuXG4gIHBhdGggPSBwYXRoIHx8ICcnO1xuICBjb25zdCBvbWl0TmVzdGVkID0gb3B0aW9ucy5vbWl0TmVzdGVkIHx8IHt9O1xuXG4gIHdoaWxlIChpIDwgbGVuKSB7XG4gICAga2V5ID0ga2V5c1tpKytdO1xuICAgIGlmIChvcHRpb25zLm9taXQgJiYgb3B0aW9ucy5vbWl0W2tleV0pIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAob21pdE5lc3RlZFtwYXRoXSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChzcGVjaWFsUHJvcGVydGllcy5oYXMoa2V5KSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmICh0b1trZXldID09IG51bGwpIHtcbiAgICAgIHRvW2tleV0gPSBmcm9tW2tleV07XG4gICAgfSBlbHNlIGlmIChleHBvcnRzLmlzT2JqZWN0KGZyb21ba2V5XSkpIHtcbiAgICAgIGlmICghZXhwb3J0cy5pc09iamVjdCh0b1trZXldKSkge1xuICAgICAgICB0b1trZXldID0ge307XG4gICAgICB9XG4gICAgICBpZiAoZnJvbVtrZXldICE9IG51bGwpIHtcbiAgICAgICAgLy8gU2tpcCBtZXJnaW5nIHNjaGVtYXMgaWYgd2UncmUgY3JlYXRpbmcgYSBkaXNjcmltaW5hdG9yIHNjaGVtYSBhbmRcbiAgICAgICAgLy8gYmFzZSBzY2hlbWEgaGFzIGEgZ2l2ZW4gcGF0aCBhcyBhIHNpbmdsZSBuZXN0ZWQgYnV0IGRpc2NyaW1pbmF0b3Igc2NoZW1hXG4gICAgICAgIC8vIGhhcyB0aGUgcGF0aCBhcyBhIGRvY3VtZW50IGFycmF5LCBvciB2aWNlIHZlcnNhIChnaC05NTM0KVxuICAgICAgICBpZiAob3B0aW9ucy5pc0Rpc2NyaW1pbmF0b3JTY2hlbWFNZXJnZSAmJlxuICAgICAgICAgICAgKGZyb21ba2V5XS4kaXNTaW5nbGVOZXN0ZWQgJiYgdG9ba2V5XS4kaXNNb25nb29zZURvY3VtZW50QXJyYXkpIHx8XG4gICAgICAgICAgICAoZnJvbVtrZXldLiRpc01vbmdvb3NlRG9jdW1lbnRBcnJheSAmJiB0b1trZXldLiRpc1NpbmdsZU5lc3RlZCkpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfSBlbHNlIGlmIChmcm9tW2tleV0uaW5zdGFuY2VPZlNjaGVtYSkge1xuICAgICAgICAgIGlmICh0b1trZXldLmluc3RhbmNlT2ZTY2hlbWEpIHtcbiAgICAgICAgICAgIHNjaGVtYU1lcmdlKHRvW2tleV0sIGZyb21ba2V5XS5jbG9uZSgpLCBvcHRpb25zLmlzRGlzY3JpbWluYXRvclNjaGVtYU1lcmdlKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdG9ba2V5XSA9IGZyb21ba2V5XS5jbG9uZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfSBlbHNlIGlmIChpc0Jzb25UeXBlKGZyb21ba2V5XSwgJ09iamVjdElkJykpIHtcbiAgICAgICAgICB0b1trZXldID0gbmV3IE9iamVjdElkKGZyb21ba2V5XSk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIG1lcmdlKHRvW2tleV0sIGZyb21ba2V5XSwgb3B0aW9ucywgcGF0aCA/IHBhdGggKyAnLicgKyBrZXkgOiBrZXkpO1xuICAgIH0gZWxzZSBpZiAob3B0aW9ucy5vdmVyd3JpdGUpIHtcbiAgICAgIHRvW2tleV0gPSBmcm9tW2tleV07XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIEFwcGxpZXMgdG9PYmplY3QgcmVjdXJzaXZlbHkuXG4gKlxuICogQHBhcmFtIHtEb2N1bWVudHxBcnJheXxPYmplY3R9IG9ialxuICogQHJldHVybiB7T2JqZWN0fVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZXhwb3J0cy50b09iamVjdCA9IGZ1bmN0aW9uIHRvT2JqZWN0KG9iaikge1xuICBEb2N1bWVudCB8fCAoRG9jdW1lbnQgPSByZXF1aXJlKCcuL2RvY3VtZW50JykpO1xuICBsZXQgcmV0O1xuXG4gIGlmIChvYmogPT0gbnVsbCkge1xuICAgIHJldHVybiBvYmo7XG4gIH1cblxuICBpZiAob2JqIGluc3RhbmNlb2YgRG9jdW1lbnQpIHtcbiAgICByZXR1cm4gb2JqLnRvT2JqZWN0KCk7XG4gIH1cblxuICBpZiAoQXJyYXkuaXNBcnJheShvYmopKSB7XG4gICAgcmV0ID0gW107XG5cbiAgICBmb3IgKGNvbnN0IGRvYyBvZiBvYmopIHtcbiAgICAgIHJldC5wdXNoKHRvT2JqZWN0KGRvYykpO1xuICAgIH1cblxuICAgIHJldHVybiByZXQ7XG4gIH1cblxuICBpZiAoZXhwb3J0cy5pc1BPSk8ob2JqKSkge1xuICAgIHJldCA9IHt9O1xuXG4gICAgaWYgKG9ialt0cnVzdGVkU3ltYm9sXSkge1xuICAgICAgcmV0W3RydXN0ZWRTeW1ib2xdID0gb2JqW3RydXN0ZWRTeW1ib2xdO1xuICAgIH1cblxuICAgIGZvciAoY29uc3QgayBvZiBPYmplY3Qua2V5cyhvYmopKSB7XG4gICAgICBpZiAoc3BlY2lhbFByb3BlcnRpZXMuaGFzKGspKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgcmV0W2tdID0gdG9PYmplY3Qob2JqW2tdKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmV0O1xuICB9XG5cbiAgcmV0dXJuIG9iajtcbn07XG5cbmV4cG9ydHMuaXNPYmplY3QgPSBpc09iamVjdDtcblxuLyoqXG4gKiBEZXRlcm1pbmVzIGlmIGBhcmdgIGlzIGEgcGxhaW4gb2xkIEphdmFTY3JpcHQgb2JqZWN0IChQT0pPKS4gU3BlY2lmaWNhbGx5LFxuICogYGFyZ2AgbXVzdCBiZSBhbiBvYmplY3QgYnV0IG5vdCBhbiBpbnN0YW5jZSBvZiBhbnkgc3BlY2lhbCBjbGFzcywgbGlrZSBTdHJpbmcsXG4gKiBPYmplY3RJZCwgZXRjLlxuICpcbiAqIGBPYmplY3QuZ2V0UHJvdG90eXBlT2YoKWAgaXMgcGFydCBvZiBFUzU6IGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL09iamVjdC9nZXRQcm90b3R5cGVPZlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fEFycmF5fFN0cmluZ3xGdW5jdGlvbnxSZWdFeHB8YW55fSBhcmdcbiAqIEBhcGkgcHJpdmF0ZVxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuXG5leHBvcnRzLmlzUE9KTyA9IHJlcXVpcmUoJy4vaGVscGVycy9pc1BPSk8nKTtcblxuLyoqXG4gKiBEZXRlcm1pbmVzIGlmIGBhcmdgIGlzIGFuIG9iamVjdCB0aGF0IGlzbid0IGFuIGluc3RhbmNlIG9mIGEgYnVpbHQtaW4gdmFsdWVcbiAqIGNsYXNzLCBsaWtlIEFycmF5LCBCdWZmZXIsIE9iamVjdElkLCBldGMuXG4gKiBAcGFyYW0ge0FueX0gdmFsXG4gKi9cblxuZXhwb3J0cy5pc05vbkJ1aWx0aW5PYmplY3QgPSBmdW5jdGlvbiBpc05vbkJ1aWx0aW5PYmplY3QodmFsKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsID09PSAnb2JqZWN0JyAmJlxuICAgICFleHBvcnRzLmlzTmF0aXZlT2JqZWN0KHZhbCkgJiZcbiAgICAhZXhwb3J0cy5pc01vbmdvb3NlVHlwZSh2YWwpICYmXG4gICAgISh2YWwgaW5zdGFuY2VvZiBVVUlEKSAmJlxuICAgIHZhbCAhPSBudWxsO1xufTtcblxuLyoqXG4gKiBEZXRlcm1pbmVzIGlmIGBvYmpgIGlzIGEgYnVpbHQtaW4gb2JqZWN0IGxpa2UgYW4gYXJyYXksIGRhdGUsIGJvb2xlYW4sXG4gKiBldGMuXG4gKiBAcGFyYW0ge0FueX0gYXJnXG4gKi9cblxuZXhwb3J0cy5pc05hdGl2ZU9iamVjdCA9IGZ1bmN0aW9uKGFyZykge1xuICByZXR1cm4gQXJyYXkuaXNBcnJheShhcmcpIHx8XG4gICAgYXJnIGluc3RhbmNlb2YgRGF0ZSB8fFxuICAgIGFyZyBpbnN0YW5jZW9mIEJvb2xlYW4gfHxcbiAgICBhcmcgaW5zdGFuY2VvZiBOdW1iZXIgfHxcbiAgICBhcmcgaW5zdGFuY2VvZiBTdHJpbmc7XG59O1xuXG4vKipcbiAqIERldGVybWluZXMgaWYgYHZhbGAgaXMgYW4gb2JqZWN0IHRoYXQgaGFzIG5vIG93biBrZXlzXG4gKiBAcGFyYW0ge0FueX0gdmFsXG4gKi9cblxuZXhwb3J0cy5pc0VtcHR5T2JqZWN0ID0gZnVuY3Rpb24odmFsKSB7XG4gIHJldHVybiB2YWwgIT0gbnVsbCAmJlxuICAgIHR5cGVvZiB2YWwgPT09ICdvYmplY3QnICYmXG4gICAgT2JqZWN0LmtleXModmFsKS5sZW5ndGggPT09IDA7XG59O1xuXG4vKipcbiAqIFNlYXJjaCBpZiBgb2JqYCBvciBhbnkgUE9KT3MgbmVzdGVkIHVuZGVybmVhdGggYG9iamAgaGFzIGEgcHJvcGVydHkgbmFtZWRcbiAqIGBrZXlgXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gKiBAcGFyYW0ge1N0cmluZ30ga2V5XG4gKi9cblxuZXhwb3J0cy5oYXNLZXkgPSBmdW5jdGlvbiBoYXNLZXkob2JqLCBrZXkpIHtcbiAgY29uc3QgcHJvcHMgPSBPYmplY3Qua2V5cyhvYmopO1xuICBmb3IgKGNvbnN0IHByb3Agb2YgcHJvcHMpIHtcbiAgICBpZiAocHJvcCA9PT0ga2V5KSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKGV4cG9ydHMuaXNQT0pPKG9ialtwcm9wXSkgJiYgZXhwb3J0cy5oYXNLZXkob2JqW3Byb3BdLCBrZXkpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuLyoqXG4gKiBwcm9jZXNzLm5leHRUaWNrIGhlbHBlci5cbiAqXG4gKiBXcmFwcyBgY2FsbGJhY2tgIGluIGEgdHJ5L2NhdGNoICsgbmV4dFRpY2suXG4gKlxuICogbm9kZS1tb25nb2RiLW5hdGl2ZSBoYXMgYSBoYWJpdCBvZiBzdGF0ZSBjb3JydXB0aW9uIHdoZW4gYW4gZXJyb3IgaXMgaW1tZWRpYXRlbHkgdGhyb3duIGZyb20gd2l0aGluIGEgY29sbGVjdGlvbiBjYWxsYmFjay5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZXhwb3J0cy50aWNrID0gZnVuY3Rpb24gdGljayhjYWxsYmFjaykge1xuICBpZiAodHlwZW9mIGNhbGxiYWNrICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB0cnkge1xuICAgICAgY2FsbGJhY2suYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIC8vIG9ubHkgbmV4dFRpY2sgb24gZXJyIHRvIGdldCBvdXQgb2ZcbiAgICAgIC8vIHRoZSBldmVudCBsb29wIGFuZCBhdm9pZCBzdGF0ZSBjb3JydXB0aW9uLlxuICAgICAgaW1tZWRpYXRlKGZ1bmN0aW9uKCkge1xuICAgICAgICB0aHJvdyBlcnI7XG4gICAgICB9KTtcbiAgICB9XG4gIH07XG59O1xuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiBgdmAgaXMgYW4gb2JqZWN0IHRoYXQgY2FuIGJlIHNlcmlhbGl6ZWQgYXMgYSBwcmltaXRpdmUgaW5cbiAqIE1vbmdvREJcbiAqIEBwYXJhbSB7QW55fSB2XG4gKi9cblxuZXhwb3J0cy5pc01vbmdvb3NlVHlwZSA9IGZ1bmN0aW9uKHYpIHtcbiAgcmV0dXJuIGlzQnNvblR5cGUodiwgJ09iamVjdElkJykgfHwgaXNCc29uVHlwZSh2LCAnRGVjaW1hbDEyOCcpIHx8IHYgaW5zdGFuY2VvZiBCdWZmZXI7XG59O1xuXG5leHBvcnRzLmlzTW9uZ29vc2VPYmplY3QgPSBpc01vbmdvb3NlT2JqZWN0O1xuXG4vKipcbiAqIENvbnZlcnRzIGBleHBpcmVzYCBvcHRpb25zIG9mIGluZGV4IG9iamVjdHMgdG8gYGV4cGlyZXNBZnRlclNlY29uZHNgIG9wdGlvbnMgZm9yIE1vbmdvREIuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdFxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZXhwb3J0cy5leHBpcmVzID0gZnVuY3Rpb24gZXhwaXJlcyhvYmplY3QpIHtcbiAgaWYgKCEob2JqZWN0ICYmIG9iamVjdC5jb25zdHJ1Y3Rvci5uYW1lID09PSAnT2JqZWN0JykpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKCEoJ2V4cGlyZXMnIGluIG9iamVjdCkpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBvYmplY3QuZXhwaXJlQWZ0ZXJTZWNvbmRzID0gKHR5cGVvZiBvYmplY3QuZXhwaXJlcyAhPT0gJ3N0cmluZycpXG4gICAgPyBvYmplY3QuZXhwaXJlc1xuICAgIDogTWF0aC5yb3VuZChtcyhvYmplY3QuZXhwaXJlcykgLyAxMDAwKTtcbiAgZGVsZXRlIG9iamVjdC5leHBpcmVzO1xufTtcblxuLyoqXG4gKiBwb3B1bGF0ZSBoZWxwZXJcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoXG4gKiBAcGFyYW0ge1N0cmluZ30gc2VsZWN0XG4gKiBAcGFyYW0ge01vZGVsfSBtb2RlbFxuICogQHBhcmFtIHtPYmplY3R9IG1hdGNoXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQHBhcmFtIHtBbnl9IHN1YlBvcHVsYXRlXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGp1c3RPbmVcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gY291bnRcbiAqL1xuXG5leHBvcnRzLnBvcHVsYXRlID0gZnVuY3Rpb24gcG9wdWxhdGUocGF0aCwgc2VsZWN0LCBtb2RlbCwgbWF0Y2gsIG9wdGlvbnMsIHN1YlBvcHVsYXRlLCBqdXN0T25lLCBjb3VudCkge1xuICAvLyBtaWdodCBoYXZlIHBhc3NlZCBhbiBvYmplY3Qgc3BlY2lmeWluZyBhbGwgYXJndW1lbnRzXG4gIGxldCBvYmogPSBudWxsO1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgIGlmIChwYXRoIGluc3RhbmNlb2YgUG9wdWxhdGVPcHRpb25zKSB7XG4gICAgICAvLyBJZiByZXVzaW5nIG9sZCBwb3B1bGF0ZSBkb2NzLCBhdm9pZCByZXVzaW5nIGBfZG9jc2AgYmVjYXVzZSB0aGF0IG1heVxuICAgICAgLy8gbGVhZCB0byBidWdzIGFuZCBtZW1vcnkgbGVha3MuIFNlZSBnaC0xMTY0MVxuICAgICAgcGF0aC5fZG9jcyA9IFtdO1xuICAgICAgcGF0aC5fY2hpbGREb2NzID0gW107XG4gICAgICByZXR1cm4gW3BhdGhdO1xuICAgIH1cblxuICAgIGlmIChBcnJheS5pc0FycmF5KHBhdGgpKSB7XG4gICAgICBjb25zdCBzaW5nbGVzID0gbWFrZVNpbmdsZXMocGF0aCk7XG4gICAgICByZXR1cm4gc2luZ2xlcy5tYXAobyA9PiBleHBvcnRzLnBvcHVsYXRlKG8pWzBdKTtcbiAgICB9XG5cbiAgICBpZiAoZXhwb3J0cy5pc09iamVjdChwYXRoKSkge1xuICAgICAgb2JqID0gT2JqZWN0LmFzc2lnbih7fSwgcGF0aCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9iaiA9IHsgcGF0aDogcGF0aCB9O1xuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlb2YgbW9kZWwgPT09ICdvYmplY3QnKSB7XG4gICAgb2JqID0ge1xuICAgICAgcGF0aDogcGF0aCxcbiAgICAgIHNlbGVjdDogc2VsZWN0LFxuICAgICAgbWF0Y2g6IG1vZGVsLFxuICAgICAgb3B0aW9uczogbWF0Y2hcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIG9iaiA9IHtcbiAgICAgIHBhdGg6IHBhdGgsXG4gICAgICBzZWxlY3Q6IHNlbGVjdCxcbiAgICAgIG1vZGVsOiBtb2RlbCxcbiAgICAgIG1hdGNoOiBtYXRjaCxcbiAgICAgIG9wdGlvbnM6IG9wdGlvbnMsXG4gICAgICBwb3B1bGF0ZTogc3ViUG9wdWxhdGUsXG4gICAgICBqdXN0T25lOiBqdXN0T25lLFxuICAgICAgY291bnQ6IGNvdW50XG4gICAgfTtcbiAgfVxuXG4gIGlmICh0eXBlb2Ygb2JqLnBhdGggIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcigndXRpbHMucG9wdWxhdGU6IGludmFsaWQgcGF0aC4gRXhwZWN0ZWQgc3RyaW5nLiBHb3QgdHlwZW9mIGAnICsgdHlwZW9mIHBhdGggKyAnYCcpO1xuICB9XG5cbiAgcmV0dXJuIF9wb3B1bGF0ZU9iaihvYmopO1xuXG4gIC8vIFRoZSBvcmRlciBvZiBzZWxlY3QvY29uZGl0aW9ucyBhcmdzIGlzIG9wcG9zaXRlIE1vZGVsLmZpbmQgYnV0XG4gIC8vIG5lY2Vzc2FyeSB0byBrZWVwIGJhY2t3YXJkIGNvbXBhdGliaWxpdHkgKHNlbGVjdCBjb3VsZCBiZVxuICAvLyBhbiBhcnJheSwgc3RyaW5nLCBvciBvYmplY3QgbGl0ZXJhbCkuXG4gIGZ1bmN0aW9uIG1ha2VTaW5nbGVzKGFycikge1xuICAgIGNvbnN0IHJldCA9IFtdO1xuICAgIGFyci5mb3JFYWNoKGZ1bmN0aW9uKG9iaikge1xuICAgICAgaWYgKG9uZVNwYWNlUkUudGVzdChvYmoucGF0aCkpIHtcbiAgICAgICAgY29uc3QgcGF0aHMgPSBvYmoucGF0aC5zcGxpdChtYW55U3BhY2VSRSk7XG4gICAgICAgIHBhdGhzLmZvckVhY2goZnVuY3Rpb24ocCkge1xuICAgICAgICAgIGNvbnN0IGNvcHkgPSBPYmplY3QuYXNzaWduKHt9LCBvYmopO1xuICAgICAgICAgIGNvcHkucGF0aCA9IHA7XG4gICAgICAgICAgcmV0LnB1c2goY29weSk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0LnB1c2gob2JqKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiByZXQ7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIF9wb3B1bGF0ZU9iaihvYmopIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkob2JqLnBvcHVsYXRlKSkge1xuICAgIGNvbnN0IHJldCA9IFtdO1xuICAgIG9iai5wb3B1bGF0ZS5mb3JFYWNoKGZ1bmN0aW9uKG9iaikge1xuICAgICAgaWYgKG9uZVNwYWNlUkUudGVzdChvYmoucGF0aCkpIHtcbiAgICAgICAgY29uc3QgY29weSA9IE9iamVjdC5hc3NpZ24oe30sIG9iaik7XG4gICAgICAgIGNvbnN0IHBhdGhzID0gY29weS5wYXRoLnNwbGl0KG1hbnlTcGFjZVJFKTtcbiAgICAgICAgcGF0aHMuZm9yRWFjaChmdW5jdGlvbihwKSB7XG4gICAgICAgICAgY29weS5wYXRoID0gcDtcbiAgICAgICAgICByZXQucHVzaChleHBvcnRzLnBvcHVsYXRlKGNvcHkpWzBdKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXQucHVzaChleHBvcnRzLnBvcHVsYXRlKG9iailbMF0pO1xuICAgICAgfVxuICAgIH0pO1xuICAgIG9iai5wb3B1bGF0ZSA9IGV4cG9ydHMucG9wdWxhdGUocmV0KTtcbiAgfSBlbHNlIGlmIChvYmoucG9wdWxhdGUgIT0gbnVsbCAmJiB0eXBlb2Ygb2JqLnBvcHVsYXRlID09PSAnb2JqZWN0Jykge1xuICAgIG9iai5wb3B1bGF0ZSA9IGV4cG9ydHMucG9wdWxhdGUob2JqLnBvcHVsYXRlKTtcbiAgfVxuXG4gIGNvbnN0IHJldCA9IFtdO1xuICBjb25zdCBwYXRocyA9IG9uZVNwYWNlUkUudGVzdChvYmoucGF0aCkgPyBvYmoucGF0aC5zcGxpdChtYW55U3BhY2VSRSkgOiBbb2JqLnBhdGhdO1xuICBpZiAob2JqLm9wdGlvbnMgIT0gbnVsbCkge1xuICAgIG9iai5vcHRpb25zID0gY2xvbmUob2JqLm9wdGlvbnMpO1xuICB9XG5cbiAgZm9yIChjb25zdCBwYXRoIG9mIHBhdGhzKSB7XG4gICAgcmV0LnB1c2gobmV3IFBvcHVsYXRlT3B0aW9ucyhPYmplY3QuYXNzaWduKHt9LCBvYmosIHsgcGF0aDogcGF0aCB9KSkpO1xuICB9XG5cbiAgcmV0dXJuIHJldDtcbn1cblxuLyoqXG4gKiBSZXR1cm4gdGhlIHZhbHVlIG9mIGBvYmpgIGF0IHRoZSBnaXZlbiBgcGF0aGAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHBhdGhcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAqIEBwYXJhbSB7QW55fSBtYXBcbiAqL1xuXG5leHBvcnRzLmdldFZhbHVlID0gZnVuY3Rpb24ocGF0aCwgb2JqLCBtYXApIHtcbiAgcmV0dXJuIG1wYXRoLmdldChwYXRoLCBvYmosIGdldFZhbHVlTG9va3VwLCBtYXApO1xufTtcblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5jb25zdCBtYXBHZXR0ZXJPcHRpb25zID0gT2JqZWN0LmZyZWV6ZSh7IGdldHRlcnM6IGZhbHNlIH0pO1xuXG5mdW5jdGlvbiBnZXRWYWx1ZUxvb2t1cChvYmosIHBhcnQpIHtcbiAgbGV0IF9mcm9tID0gb2JqPy5fZG9jIHx8IG9iajtcbiAgaWYgKF9mcm9tICE9IG51bGwgJiYgX2Zyb20uaXNNb25nb29zZUFycmF5UHJveHkpIHtcbiAgICBfZnJvbSA9IF9mcm9tLl9fYXJyYXk7XG4gIH1cbiAgcmV0dXJuIF9mcm9tIGluc3RhbmNlb2YgTWFwID9cbiAgICBfZnJvbS5nZXQocGFydCwgbWFwR2V0dGVyT3B0aW9ucykgOlxuICAgIF9mcm9tW3BhcnRdO1xufVxuXG4vKipcbiAqIFNldHMgdGhlIHZhbHVlIG9mIGBvYmpgIGF0IHRoZSBnaXZlbiBgcGF0aGAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHBhdGhcbiAqIEBwYXJhbSB7QW55dGhpbmd9IHZhbFxuICogQHBhcmFtIHtPYmplY3R9IG9ialxuICogQHBhcmFtIHtBbnl9IG1hcFxuICogQHBhcmFtIHtBbnl9IF9jb3B5aW5nXG4gKi9cblxuZXhwb3J0cy5zZXRWYWx1ZSA9IGZ1bmN0aW9uKHBhdGgsIHZhbCwgb2JqLCBtYXAsIF9jb3B5aW5nKSB7XG4gIG1wYXRoLnNldChwYXRoLCB2YWwsIG9iaiwgJ19kb2MnLCBtYXAsIF9jb3B5aW5nKTtcbn07XG5cbi8qKlxuICogUmV0dXJucyBhbiBhcnJheSBvZiB2YWx1ZXMgZnJvbSBvYmplY3QgYG9gLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvXG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmV4cG9ydHMub2JqZWN0ID0ge307XG5leHBvcnRzLm9iamVjdC52YWxzID0gZnVuY3Rpb24gdmFscyhvKSB7XG4gIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhvKTtcbiAgbGV0IGkgPSBrZXlzLmxlbmd0aDtcbiAgY29uc3QgcmV0ID0gW107XG5cbiAgd2hpbGUgKGktLSkge1xuICAgIHJldC5wdXNoKG9ba2V5c1tpXV0pO1xuICB9XG5cbiAgcmV0dXJuIHJldDtcbn07XG5cbmNvbnN0IGhvcCA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogU2FmZXIgaGVscGVyIGZvciBoYXNPd25Qcm9wZXJ0eSBjaGVja3NcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gKiBAcGFyYW0ge1N0cmluZ30gcHJvcFxuICovXG5cbmV4cG9ydHMub2JqZWN0Lmhhc093blByb3BlcnR5ID0gZnVuY3Rpb24ob2JqLCBwcm9wKSB7XG4gIHJldHVybiBob3AuY2FsbChvYmosIHByb3ApO1xufTtcblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYHZhbGAgaXMgbnVsbCBvciB1bmRlZmluZWRcbiAqXG4gKiBAcGFyYW0ge0FueX0gdmFsXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5cbmV4cG9ydHMuaXNOdWxsT3JVbmRlZmluZWQgPSBmdW5jdGlvbih2YWwpIHtcbiAgcmV0dXJuIHZhbCA9PT0gbnVsbCB8fCB2YWwgPT09IHVuZGVmaW5lZDtcbn07XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxuZXhwb3J0cy5hcnJheSA9IHt9O1xuXG4vKipcbiAqIEZsYXR0ZW5zIGFuIGFycmF5LlxuICpcbiAqIFsgMSwgWyAyLCAzLCBbNF0gXV0gLT4gWzEsMiwzLDRdXG4gKlxuICogQHBhcmFtIHtBcnJheX0gYXJyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbZmlsdGVyXSBJZiBwYXNzZWQsIHdpbGwgYmUgaW52b2tlZCB3aXRoIGVhY2ggaXRlbSBpbiB0aGUgYXJyYXkuIElmIGBmaWx0ZXJgIHJldHVybnMgYSBmYWxzeSB2YWx1ZSwgdGhlIGl0ZW0gd2lsbCBub3QgYmUgaW5jbHVkZWQgaW4gdGhlIHJlc3VsdHMuXG4gKiBAcGFyYW0ge0FycmF5fSByZXRcbiAqIEByZXR1cm4ge0FycmF5fVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZXhwb3J0cy5hcnJheS5mbGF0dGVuID0gZnVuY3Rpb24gZmxhdHRlbihhcnIsIGZpbHRlciwgcmV0KSB7XG4gIHJldCB8fCAocmV0ID0gW10pO1xuXG4gIGFyci5mb3JFYWNoKGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShpdGVtKSkge1xuICAgICAgZmxhdHRlbihpdGVtLCBmaWx0ZXIsIHJldCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICghZmlsdGVyIHx8IGZpbHRlcihpdGVtKSkge1xuICAgICAgICByZXQucHVzaChpdGVtKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiByZXQ7XG59O1xuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cbmNvbnN0IF9oYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbmV4cG9ydHMuaGFzVXNlckRlZmluZWRQcm9wZXJ0eSA9IGZ1bmN0aW9uKG9iaiwga2V5KSB7XG4gIGlmIChvYmogPT0gbnVsbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChBcnJheS5pc0FycmF5KGtleSkpIHtcbiAgICBmb3IgKGNvbnN0IGsgb2Yga2V5KSB7XG4gICAgICBpZiAoZXhwb3J0cy5oYXNVc2VyRGVmaW5lZFByb3BlcnR5KG9iaiwgaykpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChfaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAodHlwZW9mIG9iaiA9PT0gJ29iamVjdCcgJiYga2V5IGluIG9iaikge1xuICAgIGNvbnN0IHYgPSBvYmpba2V5XTtcbiAgICByZXR1cm4gdiAhPT0gT2JqZWN0LnByb3RvdHlwZVtrZXldICYmIHYgIT09IEFycmF5LnByb3RvdHlwZVtrZXldO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5jb25zdCBNQVhfQVJSQVlfSU5ERVggPSBNYXRoLnBvdygyLCAzMikgLSAxO1xuXG5leHBvcnRzLmlzQXJyYXlJbmRleCA9IGZ1bmN0aW9uKHZhbCkge1xuICBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICByZXR1cm4gdmFsID49IDAgJiYgdmFsIDw9IE1BWF9BUlJBWV9JTkRFWDtcbiAgfVxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICBpZiAoIS9eXFxkKyQvLnRlc3QodmFsKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB2YWwgPSArdmFsO1xuICAgIHJldHVybiB2YWwgPj0gMCAmJiB2YWwgPD0gTUFYX0FSUkFZX0lOREVYO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuLyoqXG4gKiBSZW1vdmVzIGR1cGxpY2F0ZSB2YWx1ZXMgZnJvbSBhbiBhcnJheVxuICpcbiAqIFsxLCAyLCAzLCAzLCA1XSA9PiBbMSwgMiwgMywgNV1cbiAqIFsgT2JqZWN0SWQoXCI1NTA5ODhiYTBjMTlkNTdmNjk3ZGM0NWVcIiksIE9iamVjdElkKFwiNTUwOTg4YmEwYzE5ZDU3ZjY5N2RjNDVlXCIpIF1cbiAqICAgID0+IFtPYmplY3RJZChcIjU1MDk4OGJhMGMxOWQ1N2Y2OTdkYzQ1ZVwiKV1cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJcbiAqIEByZXR1cm4ge0FycmF5fVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZXhwb3J0cy5hcnJheS51bmlxdWUgPSBmdW5jdGlvbihhcnIpIHtcbiAgY29uc3QgcHJpbWl0aXZlcyA9IG5ldyBTZXQoKTtcbiAgY29uc3QgaWRzID0gbmV3IFNldCgpO1xuICBjb25zdCByZXQgPSBbXTtcblxuICBmb3IgKGNvbnN0IGl0ZW0gb2YgYXJyKSB7XG4gICAgaWYgKHR5cGVvZiBpdGVtID09PSAnbnVtYmVyJyB8fCB0eXBlb2YgaXRlbSA9PT0gJ3N0cmluZycgfHwgaXRlbSA9PSBudWxsKSB7XG4gICAgICBpZiAocHJpbWl0aXZlcy5oYXMoaXRlbSkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICByZXQucHVzaChpdGVtKTtcbiAgICAgIHByaW1pdGl2ZXMuYWRkKGl0ZW0pO1xuICAgIH0gZWxzZSBpZiAoaXNCc29uVHlwZShpdGVtLCAnT2JqZWN0SWQnKSkge1xuICAgICAgaWYgKGlkcy5oYXMoaXRlbS50b1N0cmluZygpKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHJldC5wdXNoKGl0ZW0pO1xuICAgICAgaWRzLmFkZChpdGVtLnRvU3RyaW5nKCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXQucHVzaChpdGVtKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmV0O1xufTtcblxuZXhwb3J0cy5idWZmZXIgPSB7fTtcblxuLyoqXG4gKiBEZXRlcm1pbmVzIGlmIHR3byBidWZmZXJzIGFyZSBlcXVhbC5cbiAqXG4gKiBAcGFyYW0ge0J1ZmZlcn0gYVxuICogQHBhcmFtIHtPYmplY3R9IGJcbiAqL1xuXG5leHBvcnRzLmJ1ZmZlci5hcmVFcXVhbCA9IGZ1bmN0aW9uKGEsIGIpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYikpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKGEubGVuZ3RoICE9PSBiLmxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBmb3IgKGxldCBpID0gMCwgbGVuID0gYS5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgIGlmIChhW2ldICE9PSBiW2ldKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufTtcblxuZXhwb3J0cy5nZXRGdW5jdGlvbk5hbWUgPSBnZXRGdW5jdGlvbk5hbWU7XG5cbi8qKlxuICogRGVjb3JhdGUgYnVmZmVyc1xuICogQHBhcmFtIHtPYmplY3R9IGRlc3RpbmF0aW9uXG4gKiBAcGFyYW0ge09iamVjdH0gc291cmNlXG4gKi9cblxuZXhwb3J0cy5kZWNvcmF0ZSA9IGZ1bmN0aW9uKGRlc3RpbmF0aW9uLCBzb3VyY2UpIHtcbiAgZm9yIChjb25zdCBrZXkgaW4gc291cmNlKSB7XG4gICAgaWYgKHNwZWNpYWxQcm9wZXJ0aWVzLmhhcyhrZXkpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgZGVzdGluYXRpb25ba2V5XSA9IHNvdXJjZVtrZXldO1xuICB9XG59O1xuXG4vKipcbiAqIG1lcmdlcyB0byB3aXRoIGEgY29weSBvZiBmcm9tXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHRvXG4gKiBAcGFyYW0ge09iamVjdH0gZnJvbU9ialxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZXhwb3J0cy5tZXJnZUNsb25lID0gZnVuY3Rpb24odG8sIGZyb21PYmopIHtcbiAgaWYgKGlzTW9uZ29vc2VPYmplY3QoZnJvbU9iaikpIHtcbiAgICBmcm9tT2JqID0gZnJvbU9iai50b09iamVjdCh7XG4gICAgICB0cmFuc2Zvcm06IGZhbHNlLFxuICAgICAgdmlydHVhbHM6IGZhbHNlLFxuICAgICAgZGVwb3B1bGF0ZTogdHJ1ZSxcbiAgICAgIGdldHRlcnM6IGZhbHNlLFxuICAgICAgZmxhdHRlbkRlY2ltYWxzOiBmYWxzZVxuICAgIH0pO1xuICB9XG4gIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhmcm9tT2JqKTtcbiAgY29uc3QgbGVuID0ga2V5cy5sZW5ndGg7XG4gIGxldCBpID0gMDtcbiAgbGV0IGtleTtcblxuICB3aGlsZSAoaSA8IGxlbikge1xuICAgIGtleSA9IGtleXNbaSsrXTtcbiAgICBpZiAoc3BlY2lhbFByb3BlcnRpZXMuaGFzKGtleSkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHRvW2tleV0gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB0b1trZXldID0gY2xvbmUoZnJvbU9ialtrZXldLCB7XG4gICAgICAgIHRyYW5zZm9ybTogZmFsc2UsXG4gICAgICAgIHZpcnR1YWxzOiBmYWxzZSxcbiAgICAgICAgZGVwb3B1bGF0ZTogdHJ1ZSxcbiAgICAgICAgZ2V0dGVyczogZmFsc2UsXG4gICAgICAgIGZsYXR0ZW5EZWNpbWFsczogZmFsc2VcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgdmFsID0gZnJvbU9ialtrZXldO1xuICAgICAgaWYgKHZhbCAhPSBudWxsICYmIHZhbC52YWx1ZU9mICYmICEodmFsIGluc3RhbmNlb2YgRGF0ZSkpIHtcbiAgICAgICAgdmFsID0gdmFsLnZhbHVlT2YoKTtcbiAgICAgIH1cbiAgICAgIGlmIChleHBvcnRzLmlzT2JqZWN0KHZhbCkpIHtcbiAgICAgICAgbGV0IG9iaiA9IHZhbDtcbiAgICAgICAgaWYgKGlzTW9uZ29vc2VPYmplY3QodmFsKSAmJiAhdmFsLmlzTW9uZ29vc2VCdWZmZXIpIHtcbiAgICAgICAgICBvYmogPSBvYmoudG9PYmplY3Qoe1xuICAgICAgICAgICAgdHJhbnNmb3JtOiBmYWxzZSxcbiAgICAgICAgICAgIHZpcnR1YWxzOiBmYWxzZSxcbiAgICAgICAgICAgIGRlcG9wdWxhdGU6IHRydWUsXG4gICAgICAgICAgICBnZXR0ZXJzOiBmYWxzZSxcbiAgICAgICAgICAgIGZsYXR0ZW5EZWNpbWFsczogZmFsc2VcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsLmlzTW9uZ29vc2VCdWZmZXIpIHtcbiAgICAgICAgICBvYmogPSBCdWZmZXIuZnJvbShvYmopO1xuICAgICAgICB9XG4gICAgICAgIGV4cG9ydHMubWVyZ2VDbG9uZSh0b1trZXldLCBvYmopO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdG9ba2V5XSA9IGNsb25lKHZhbCwge1xuICAgICAgICAgIGZsYXR0ZW5EZWNpbWFsczogZmFsc2VcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIEV4ZWN1dGVzIGEgZnVuY3Rpb24gb24gZWFjaCBlbGVtZW50IG9mIGFuIGFycmF5IChsaWtlIF8uZWFjaClcbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5leHBvcnRzLmVhY2ggPSBmdW5jdGlvbihhcnIsIGZuKSB7XG4gIGZvciAoY29uc3QgaXRlbSBvZiBhcnIpIHtcbiAgICBmbihpdGVtKTtcbiAgfVxufTtcblxuLyoqXG4gKiBSZW5hbWUgYW4gb2JqZWN0IGtleSwgd2hpbGUgcHJlc2VydmluZyBpdHMgcG9zaXRpb24gaW4gdGhlIG9iamVjdFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvbGRPYmpcbiAqIEBwYXJhbSB7U3RyaW5nfE51bWJlcn0gb2xkS2V5XG4gKiBAcGFyYW0ge1N0cmluZ3xOdW1iZXJ9IG5ld0tleVxuICogQGFwaSBwcml2YXRlXG4gKi9cbmV4cG9ydHMucmVuYW1lT2JqS2V5ID0gZnVuY3Rpb24ob2xkT2JqLCBvbGRLZXksIG5ld0tleSkge1xuICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMob2xkT2JqKTtcbiAgcmV0dXJuIGtleXMucmVkdWNlKFxuICAgIChhY2MsIHZhbCkgPT4ge1xuICAgICAgaWYgKHZhbCA9PT0gb2xkS2V5KSB7XG4gICAgICAgIGFjY1tuZXdLZXldID0gb2xkT2JqW29sZEtleV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhY2NbdmFsXSA9IG9sZE9ialt2YWxdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFjYztcbiAgICB9LFxuICAgIHt9XG4gICk7XG59O1xuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cbmV4cG9ydHMuZ2V0T3B0aW9uID0gZnVuY3Rpb24obmFtZSkge1xuICBjb25zdCBzb3VyY2VzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcblxuICBmb3IgKGNvbnN0IHNvdXJjZSBvZiBzb3VyY2VzKSB7XG4gICAgaWYgKHNvdXJjZSA9PSBudWxsKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKHNvdXJjZVtuYW1lXSAhPSBudWxsKSB7XG4gICAgICByZXR1cm4gc291cmNlW25hbWVdO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBudWxsO1xufTtcblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5leHBvcnRzLm5vb3AgPSBmdW5jdGlvbigpIHt9O1xuXG5leHBvcnRzLmVycm9yVG9QT0pPID0gZnVuY3Rpb24gZXJyb3JUb1BPSk8oZXJyb3IpIHtcbiAgY29uc3QgaXNFcnJvciA9IGVycm9yIGluc3RhbmNlb2YgRXJyb3I7XG4gIGlmICghaXNFcnJvcikge1xuICAgIHRocm93IG5ldyBFcnJvcignYGVycm9yYCBtdXN0IGJlIGBpbnN0YW5jZW9mIEVycm9yYC4nKTtcbiAgfVxuXG4gIGNvbnN0IHJldCA9IHt9O1xuICBmb3IgKGNvbnN0IHByb3BlcnlOYW1lIG9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGVycm9yKSkge1xuICAgIHJldFtwcm9wZXJ5TmFtZV0gPSBlcnJvcltwcm9wZXJ5TmFtZV07XG4gIH1cbiAgcmV0dXJuIHJldDtcbn07XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxuZXhwb3J0cy53YXJuID0gZnVuY3Rpb24gd2FybihtZXNzYWdlKSB7XG4gIHJldHVybiBwcm9jZXNzLmVtaXRXYXJuaW5nKG1lc3NhZ2UsIHsgY29kZTogJ01PTkdPT1NFJyB9KTtcbn07XG5cblxuZXhwb3J0cy5pbmplY3RUaW1lc3RhbXBzT3B0aW9uID0gZnVuY3Rpb24gaW5qZWN0VGltZXN0YW1wc09wdGlvbih3cml0ZU9wZXJhdGlvbiwgdGltZXN0YW1wc09wdGlvbikge1xuICBpZiAodGltZXN0YW1wc09wdGlvbiA9PSBudWxsKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHdyaXRlT3BlcmF0aW9uLnRpbWVzdGFtcHMgPSB0aW1lc3RhbXBzT3B0aW9uO1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../server/node_modules/mongoose/lib/utils.js\n");

/***/ }),

/***/ "../server/node_modules/mongoose/lib/validOptions.js":
/*!***********************************************************!*\
  !*** ../server/node_modules/mongoose/lib/validOptions.js ***!
  \***********************************************************/
/***/ ((module) => {

"use strict";
eval("\n/*!\n * Valid mongoose options\n */\n\n\n\nconst VALID_OPTIONS = Object.freeze([\n  'allowDiskUse',\n  'applyPluginsToChildSchemas',\n  'applyPluginsToDiscriminators',\n  'autoCreate',\n  'autoIndex',\n  'autoSearchIndex',\n  'bufferCommands',\n  'bufferTimeoutMS',\n  'cloneSchemas',\n  'debug',\n  'id',\n  'timestamps.createdAt.immutable',\n  'maxTimeMS',\n  'objectIdGetter',\n  'overwriteModels',\n  'returnOriginal',\n  'runValidators',\n  'sanitizeFilter',\n  'sanitizeProjection',\n  'selectPopulatedPaths',\n  'setDefaultsOnInsert',\n  'strict',\n  'strictPopulate',\n  'strictQuery',\n  'toJSON',\n  'toObject',\n  'translateAliases'\n]);\n\nmodule.exports = VALID_OPTIONS;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvdmFsaWRPcHRpb25zLmpzIiwibWFwcGluZ3MiOiI7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL2NsaWVudC8uLi9zZXJ2ZXIvbm9kZV9tb2R1bGVzL21vbmdvb3NlL2xpYi92YWxpZE9wdGlvbnMuanM/N2Y2MSJdLCJzb3VyY2VzQ29udGVudCI6WyJcbi8qIVxuICogVmFsaWQgbW9uZ29vc2Ugb3B0aW9uc1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxuY29uc3QgVkFMSURfT1BUSU9OUyA9IE9iamVjdC5mcmVlemUoW1xuICAnYWxsb3dEaXNrVXNlJyxcbiAgJ2FwcGx5UGx1Z2luc1RvQ2hpbGRTY2hlbWFzJyxcbiAgJ2FwcGx5UGx1Z2luc1RvRGlzY3JpbWluYXRvcnMnLFxuICAnYXV0b0NyZWF0ZScsXG4gICdhdXRvSW5kZXgnLFxuICAnYXV0b1NlYXJjaEluZGV4JyxcbiAgJ2J1ZmZlckNvbW1hbmRzJyxcbiAgJ2J1ZmZlclRpbWVvdXRNUycsXG4gICdjbG9uZVNjaGVtYXMnLFxuICAnZGVidWcnLFxuICAnaWQnLFxuICAndGltZXN0YW1wcy5jcmVhdGVkQXQuaW1tdXRhYmxlJyxcbiAgJ21heFRpbWVNUycsXG4gICdvYmplY3RJZEdldHRlcicsXG4gICdvdmVyd3JpdGVNb2RlbHMnLFxuICAncmV0dXJuT3JpZ2luYWwnLFxuICAncnVuVmFsaWRhdG9ycycsXG4gICdzYW5pdGl6ZUZpbHRlcicsXG4gICdzYW5pdGl6ZVByb2plY3Rpb24nLFxuICAnc2VsZWN0UG9wdWxhdGVkUGF0aHMnLFxuICAnc2V0RGVmYXVsdHNPbkluc2VydCcsXG4gICdzdHJpY3QnLFxuICAnc3RyaWN0UG9wdWxhdGUnLFxuICAnc3RyaWN0UXVlcnknLFxuICAndG9KU09OJyxcbiAgJ3RvT2JqZWN0JyxcbiAgJ3RyYW5zbGF0ZUFsaWFzZXMnXG5dKTtcblxubW9kdWxlLmV4cG9ydHMgPSBWQUxJRF9PUFRJT05TO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../server/node_modules/mongoose/lib/validOptions.js\n");

/***/ }),

/***/ "../server/node_modules/mongoose/lib/virtualType.js":
/*!**********************************************************!*\
  !*** ../server/node_modules/mongoose/lib/virtualType.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst utils = __webpack_require__(/*! ./utils */ \"../server/node_modules/mongoose/lib/utils.js\");\n\n/**\n * VirtualType constructor\n *\n * This is what mongoose uses to define virtual attributes via `Schema.prototype.virtual`.\n *\n * #### Example:\n *\n *     const fullname = schema.virtual('fullname');\n *     fullname instanceof mongoose.VirtualType // true\n *\n * @param {Object} options\n * @param {String|Function} [options.ref] if `ref` is not nullish, this becomes a [populated virtual](https://mongoosejs.com/docs/populate.html#populate-virtuals)\n * @param {String|Function} [options.localField] the local field to populate on if this is a populated virtual.\n * @param {String|Function} [options.foreignField] the foreign field to populate on if this is a populated virtual.\n * @param {Boolean} [options.justOne=false] by default, a populated virtual is an array. If you set `justOne`, the populated virtual will be a single doc or `null`.\n * @param {Boolean} [options.getters=false] if you set this to `true`, Mongoose will call any custom getters you defined on this virtual\n * @param {Boolean} [options.count=false] if you set this to `true`, `populate()` will set this virtual to the number of populated documents, as opposed to the documents themselves, using [`Query#countDocuments()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.countDocuments())\n * @param {Object|Function} [options.match=null] add an extra match condition to `populate()`\n * @param {Number} [options.limit=null] add a default `limit` to the `populate()` query\n * @param {Number} [options.skip=null] add a default `skip` to the `populate()` query\n * @param {Number} [options.perDocumentLimit=null] For legacy reasons, `limit` with `populate()` may give incorrect results because it only executes a single query for every document being populated. If you set `perDocumentLimit`, Mongoose will ensure correct `limit` per document by executing a separate query for each document to `populate()`. For example, `.find().populate({ path: 'test', perDocumentLimit: 2 })` will execute 2 additional queries if `.find()` returns 2 documents.\n * @param {Object} [options.options=null] Additional options like `limit` and `lean`.\n * @param {String} name\n * @api public\n */\n\nfunction VirtualType(options, name) {\n  this.path = name;\n  this.getters = [];\n  this.setters = [];\n  this.options = Object.assign({}, options);\n}\n\n/**\n * If no getters/setters, add a default\n *\n * @api private\n */\n\nVirtualType.prototype._applyDefaultGetters = function() {\n  if (this.getters.length > 0 || this.setters.length > 0) {\n    return;\n  }\n\n  const path = this.path;\n  const internalProperty = '$' + path;\n  this.getters.push(function() {\n    return this.$locals[internalProperty];\n  });\n  this.setters.push(function(v) {\n    this.$locals[internalProperty] = v;\n  });\n};\n\n/*!\n * ignore\n */\n\nVirtualType.prototype.clone = function() {\n  const clone = new VirtualType(this.options, this.path);\n  clone.getters = [].concat(this.getters);\n  clone.setters = [].concat(this.setters);\n  return clone;\n};\n\n/**\n * Adds a custom getter to this virtual.\n *\n * Mongoose calls the getter function with the below 3 parameters.\n *\n * - `value`: the value returned by the previous getter. If there is only one getter, `value` will be `undefined`.\n * - `virtual`: the virtual object you called `.get()` on.\n * - `doc`: the document this virtual is attached to. Equivalent to `this`.\n *\n * #### Example:\n *\n *     const virtual = schema.virtual('fullname');\n *     virtual.get(function(value, virtual, doc) {\n *       return this.name.first + ' ' + this.name.last;\n *     });\n *\n * @param {Function} fn\n * @return {VirtualType} this\n * @api public\n */\n\nVirtualType.prototype.get = function(fn) {\n  this.getters.push(fn);\n  return this;\n};\n\n/**\n * Adds a custom setter to this virtual.\n *\n * Mongoose calls the setter function with the below 3 parameters.\n *\n * - `value`: the value being set.\n * - `virtual`: the virtual object you're calling `.set()` on.\n * - `doc`: the document this virtual is attached to. Equivalent to `this`.\n *\n * #### Example:\n *\n *     const virtual = schema.virtual('fullname');\n *     virtual.set(function(value, virtual, doc) {\n *       const parts = value.split(' ');\n *       this.name.first = parts[0];\n *       this.name.last = parts[1];\n *     });\n *\n *     const Model = mongoose.model('Test', schema);\n *     const doc = new Model();\n *     // Calls the setter with `value = 'Jean-Luc Picard'`\n *     doc.fullname = 'Jean-Luc Picard';\n *     doc.name.first; // 'Jean-Luc'\n *     doc.name.last; // 'Picard'\n *\n * @param {Function} fn\n * @return {VirtualType} this\n * @api public\n */\n\nVirtualType.prototype.set = function(fn) {\n  this.setters.push(fn);\n  return this;\n};\n\n/**\n * Applies getters to `value`.\n *\n * @param {Object} value\n * @param {Document} doc The document this virtual is attached to\n * @return {Any} the value after applying all getters\n * @api public\n */\n\nVirtualType.prototype.applyGetters = function(value, doc) {\n  if (utils.hasUserDefinedProperty(this.options, ['ref', 'refPath']) &&\n      doc.$$populatedVirtuals &&\n      doc.$$populatedVirtuals.hasOwnProperty(this.path)) {\n    value = doc.$$populatedVirtuals[this.path];\n  }\n\n  let v = value;\n  for (const getter of this.getters) {\n    v = getter.call(doc, v, this, doc);\n  }\n  return v;\n};\n\n/**\n * Applies setters to `value`.\n *\n * @param {Object} value\n * @param {Document} doc\n * @return {Any} the value after applying all setters\n * @api public\n */\n\nVirtualType.prototype.applySetters = function(value, doc) {\n  let v = value;\n  for (const setter of this.setters) {\n    v = setter.call(doc, v, this, doc);\n  }\n  return v;\n};\n\n/*!\n * exports\n */\n\nmodule.exports = VirtualType;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvdmlydHVhbFR5cGUuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsY0FBYyxtQkFBTyxDQUFDLDZEQUFTOztBQUUvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLGlCQUFpQjtBQUM1QixXQUFXLGlCQUFpQjtBQUM1QixXQUFXLGlCQUFpQjtBQUM1QixXQUFXLFNBQVM7QUFDcEIsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsU0FBUztBQUNwQixXQUFXLGlCQUFpQjtBQUM1QixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUSx3V0FBd1csbUNBQW1DO0FBQzlaLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCLFlBQVksYUFBYTtBQUN6QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkIsc0JBQXNCO0FBQ3RCO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCLFlBQVksYUFBYTtBQUN6QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFVBQVU7QUFDckIsWUFBWSxLQUFLO0FBQ2pCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxVQUFVO0FBQ3JCLFlBQVksS0FBSztBQUNqQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL2NsaWVudC8uLi9zZXJ2ZXIvbm9kZV9tb2R1bGVzL21vbmdvb3NlL2xpYi92aXJ0dWFsVHlwZS5qcz9kMGI2Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3QgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG5cbi8qKlxuICogVmlydHVhbFR5cGUgY29uc3RydWN0b3JcbiAqXG4gKiBUaGlzIGlzIHdoYXQgbW9uZ29vc2UgdXNlcyB0byBkZWZpbmUgdmlydHVhbCBhdHRyaWJ1dGVzIHZpYSBgU2NoZW1hLnByb3RvdHlwZS52aXJ0dWFsYC5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IGZ1bGxuYW1lID0gc2NoZW1hLnZpcnR1YWwoJ2Z1bGxuYW1lJyk7XG4gKiAgICAgZnVsbG5hbWUgaW5zdGFuY2VvZiBtb25nb29zZS5WaXJ0dWFsVHlwZSAvLyB0cnVlXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEBwYXJhbSB7U3RyaW5nfEZ1bmN0aW9ufSBbb3B0aW9ucy5yZWZdIGlmIGByZWZgIGlzIG5vdCBudWxsaXNoLCB0aGlzIGJlY29tZXMgYSBbcG9wdWxhdGVkIHZpcnR1YWxdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9wb3B1bGF0ZS5odG1sI3BvcHVsYXRlLXZpcnR1YWxzKVxuICogQHBhcmFtIHtTdHJpbmd8RnVuY3Rpb259IFtvcHRpb25zLmxvY2FsRmllbGRdIHRoZSBsb2NhbCBmaWVsZCB0byBwb3B1bGF0ZSBvbiBpZiB0aGlzIGlzIGEgcG9wdWxhdGVkIHZpcnR1YWwuXG4gKiBAcGFyYW0ge1N0cmluZ3xGdW5jdGlvbn0gW29wdGlvbnMuZm9yZWlnbkZpZWxkXSB0aGUgZm9yZWlnbiBmaWVsZCB0byBwb3B1bGF0ZSBvbiBpZiB0aGlzIGlzIGEgcG9wdWxhdGVkIHZpcnR1YWwuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmp1c3RPbmU9ZmFsc2VdIGJ5IGRlZmF1bHQsIGEgcG9wdWxhdGVkIHZpcnR1YWwgaXMgYW4gYXJyYXkuIElmIHlvdSBzZXQgYGp1c3RPbmVgLCB0aGUgcG9wdWxhdGVkIHZpcnR1YWwgd2lsbCBiZSBhIHNpbmdsZSBkb2Mgb3IgYG51bGxgLlxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5nZXR0ZXJzPWZhbHNlXSBpZiB5b3Ugc2V0IHRoaXMgdG8gYHRydWVgLCBNb25nb29zZSB3aWxsIGNhbGwgYW55IGN1c3RvbSBnZXR0ZXJzIHlvdSBkZWZpbmVkIG9uIHRoaXMgdmlydHVhbFxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5jb3VudD1mYWxzZV0gaWYgeW91IHNldCB0aGlzIHRvIGB0cnVlYCwgYHBvcHVsYXRlKClgIHdpbGwgc2V0IHRoaXMgdmlydHVhbCB0byB0aGUgbnVtYmVyIG9mIHBvcHVsYXRlZCBkb2N1bWVudHMsIGFzIG9wcG9zZWQgdG8gdGhlIGRvY3VtZW50cyB0aGVtc2VsdmVzLCB1c2luZyBbYFF1ZXJ5I2NvdW50RG9jdW1lbnRzKClgXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvYXBpL3F1ZXJ5Lmh0bWwjUXVlcnkucHJvdG90eXBlLmNvdW50RG9jdW1lbnRzKCkpXG4gKiBAcGFyYW0ge09iamVjdHxGdW5jdGlvbn0gW29wdGlvbnMubWF0Y2g9bnVsbF0gYWRkIGFuIGV4dHJhIG1hdGNoIGNvbmRpdGlvbiB0byBgcG9wdWxhdGUoKWBcbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5saW1pdD1udWxsXSBhZGQgYSBkZWZhdWx0IGBsaW1pdGAgdG8gdGhlIGBwb3B1bGF0ZSgpYCBxdWVyeVxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnNraXA9bnVsbF0gYWRkIGEgZGVmYXVsdCBgc2tpcGAgdG8gdGhlIGBwb3B1bGF0ZSgpYCBxdWVyeVxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnBlckRvY3VtZW50TGltaXQ9bnVsbF0gRm9yIGxlZ2FjeSByZWFzb25zLCBgbGltaXRgIHdpdGggYHBvcHVsYXRlKClgIG1heSBnaXZlIGluY29ycmVjdCByZXN1bHRzIGJlY2F1c2UgaXQgb25seSBleGVjdXRlcyBhIHNpbmdsZSBxdWVyeSBmb3IgZXZlcnkgZG9jdW1lbnQgYmVpbmcgcG9wdWxhdGVkLiBJZiB5b3Ugc2V0IGBwZXJEb2N1bWVudExpbWl0YCwgTW9uZ29vc2Ugd2lsbCBlbnN1cmUgY29ycmVjdCBgbGltaXRgIHBlciBkb2N1bWVudCBieSBleGVjdXRpbmcgYSBzZXBhcmF0ZSBxdWVyeSBmb3IgZWFjaCBkb2N1bWVudCB0byBgcG9wdWxhdGUoKWAuIEZvciBleGFtcGxlLCBgLmZpbmQoKS5wb3B1bGF0ZSh7IHBhdGg6ICd0ZXN0JywgcGVyRG9jdW1lbnRMaW1pdDogMiB9KWAgd2lsbCBleGVjdXRlIDIgYWRkaXRpb25hbCBxdWVyaWVzIGlmIGAuZmluZCgpYCByZXR1cm5zIDIgZG9jdW1lbnRzLlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLm9wdGlvbnM9bnVsbF0gQWRkaXRpb25hbCBvcHRpb25zIGxpa2UgYGxpbWl0YCBhbmQgYGxlYW5gLlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gVmlydHVhbFR5cGUob3B0aW9ucywgbmFtZSkge1xuICB0aGlzLnBhdGggPSBuYW1lO1xuICB0aGlzLmdldHRlcnMgPSBbXTtcbiAgdGhpcy5zZXR0ZXJzID0gW107XG4gIHRoaXMub3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMpO1xufVxuXG4vKipcbiAqIElmIG5vIGdldHRlcnMvc2V0dGVycywgYWRkIGEgZGVmYXVsdFxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblZpcnR1YWxUeXBlLnByb3RvdHlwZS5fYXBwbHlEZWZhdWx0R2V0dGVycyA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5nZXR0ZXJzLmxlbmd0aCA+IDAgfHwgdGhpcy5zZXR0ZXJzLmxlbmd0aCA+IDApIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBjb25zdCBwYXRoID0gdGhpcy5wYXRoO1xuICBjb25zdCBpbnRlcm5hbFByb3BlcnR5ID0gJyQnICsgcGF0aDtcbiAgdGhpcy5nZXR0ZXJzLnB1c2goZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuJGxvY2Fsc1tpbnRlcm5hbFByb3BlcnR5XTtcbiAgfSk7XG4gIHRoaXMuc2V0dGVycy5wdXNoKGZ1bmN0aW9uKHYpIHtcbiAgICB0aGlzLiRsb2NhbHNbaW50ZXJuYWxQcm9wZXJ0eV0gPSB2O1xuICB9KTtcbn07XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxuVmlydHVhbFR5cGUucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24oKSB7XG4gIGNvbnN0IGNsb25lID0gbmV3IFZpcnR1YWxUeXBlKHRoaXMub3B0aW9ucywgdGhpcy5wYXRoKTtcbiAgY2xvbmUuZ2V0dGVycyA9IFtdLmNvbmNhdCh0aGlzLmdldHRlcnMpO1xuICBjbG9uZS5zZXR0ZXJzID0gW10uY29uY2F0KHRoaXMuc2V0dGVycyk7XG4gIHJldHVybiBjbG9uZTtcbn07XG5cbi8qKlxuICogQWRkcyBhIGN1c3RvbSBnZXR0ZXIgdG8gdGhpcyB2aXJ0dWFsLlxuICpcbiAqIE1vbmdvb3NlIGNhbGxzIHRoZSBnZXR0ZXIgZnVuY3Rpb24gd2l0aCB0aGUgYmVsb3cgMyBwYXJhbWV0ZXJzLlxuICpcbiAqIC0gYHZhbHVlYDogdGhlIHZhbHVlIHJldHVybmVkIGJ5IHRoZSBwcmV2aW91cyBnZXR0ZXIuIElmIHRoZXJlIGlzIG9ubHkgb25lIGdldHRlciwgYHZhbHVlYCB3aWxsIGJlIGB1bmRlZmluZWRgLlxuICogLSBgdmlydHVhbGA6IHRoZSB2aXJ0dWFsIG9iamVjdCB5b3UgY2FsbGVkIGAuZ2V0KClgIG9uLlxuICogLSBgZG9jYDogdGhlIGRvY3VtZW50IHRoaXMgdmlydHVhbCBpcyBhdHRhY2hlZCB0by4gRXF1aXZhbGVudCB0byBgdGhpc2AuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBjb25zdCB2aXJ0dWFsID0gc2NoZW1hLnZpcnR1YWwoJ2Z1bGxuYW1lJyk7XG4gKiAgICAgdmlydHVhbC5nZXQoZnVuY3Rpb24odmFsdWUsIHZpcnR1YWwsIGRvYykge1xuICogICAgICAgcmV0dXJuIHRoaXMubmFtZS5maXJzdCArICcgJyArIHRoaXMubmFtZS5sYXN0O1xuICogICAgIH0pO1xuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKiBAcmV0dXJuIHtWaXJ0dWFsVHlwZX0gdGhpc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5WaXJ0dWFsVHlwZS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24oZm4pIHtcbiAgdGhpcy5nZXR0ZXJzLnB1c2goZm4pO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQWRkcyBhIGN1c3RvbSBzZXR0ZXIgdG8gdGhpcyB2aXJ0dWFsLlxuICpcbiAqIE1vbmdvb3NlIGNhbGxzIHRoZSBzZXR0ZXIgZnVuY3Rpb24gd2l0aCB0aGUgYmVsb3cgMyBwYXJhbWV0ZXJzLlxuICpcbiAqIC0gYHZhbHVlYDogdGhlIHZhbHVlIGJlaW5nIHNldC5cbiAqIC0gYHZpcnR1YWxgOiB0aGUgdmlydHVhbCBvYmplY3QgeW91J3JlIGNhbGxpbmcgYC5zZXQoKWAgb24uXG4gKiAtIGBkb2NgOiB0aGUgZG9jdW1lbnQgdGhpcyB2aXJ0dWFsIGlzIGF0dGFjaGVkIHRvLiBFcXVpdmFsZW50IHRvIGB0aGlzYC5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IHZpcnR1YWwgPSBzY2hlbWEudmlydHVhbCgnZnVsbG5hbWUnKTtcbiAqICAgICB2aXJ0dWFsLnNldChmdW5jdGlvbih2YWx1ZSwgdmlydHVhbCwgZG9jKSB7XG4gKiAgICAgICBjb25zdCBwYXJ0cyA9IHZhbHVlLnNwbGl0KCcgJyk7XG4gKiAgICAgICB0aGlzLm5hbWUuZmlyc3QgPSBwYXJ0c1swXTtcbiAqICAgICAgIHRoaXMubmFtZS5sYXN0ID0gcGFydHNbMV07XG4gKiAgICAgfSk7XG4gKlxuICogICAgIGNvbnN0IE1vZGVsID0gbW9uZ29vc2UubW9kZWwoJ1Rlc3QnLCBzY2hlbWEpO1xuICogICAgIGNvbnN0IGRvYyA9IG5ldyBNb2RlbCgpO1xuICogICAgIC8vIENhbGxzIHRoZSBzZXR0ZXIgd2l0aCBgdmFsdWUgPSAnSmVhbi1MdWMgUGljYXJkJ2BcbiAqICAgICBkb2MuZnVsbG5hbWUgPSAnSmVhbi1MdWMgUGljYXJkJztcbiAqICAgICBkb2MubmFtZS5maXJzdDsgLy8gJ0plYW4tTHVjJ1xuICogICAgIGRvYy5uYW1lLmxhc3Q7IC8vICdQaWNhcmQnXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqIEByZXR1cm4ge1ZpcnR1YWxUeXBlfSB0aGlzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblZpcnR1YWxUeXBlLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbihmbikge1xuICB0aGlzLnNldHRlcnMucHVzaChmbik7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBBcHBsaWVzIGdldHRlcnMgdG8gYHZhbHVlYC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsdWVcbiAqIEBwYXJhbSB7RG9jdW1lbnR9IGRvYyBUaGUgZG9jdW1lbnQgdGhpcyB2aXJ0dWFsIGlzIGF0dGFjaGVkIHRvXG4gKiBAcmV0dXJuIHtBbnl9IHRoZSB2YWx1ZSBhZnRlciBhcHBseWluZyBhbGwgZ2V0dGVyc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5WaXJ0dWFsVHlwZS5wcm90b3R5cGUuYXBwbHlHZXR0ZXJzID0gZnVuY3Rpb24odmFsdWUsIGRvYykge1xuICBpZiAodXRpbHMuaGFzVXNlckRlZmluZWRQcm9wZXJ0eSh0aGlzLm9wdGlvbnMsIFsncmVmJywgJ3JlZlBhdGgnXSkgJiZcbiAgICAgIGRvYy4kJHBvcHVsYXRlZFZpcnR1YWxzICYmXG4gICAgICBkb2MuJCRwb3B1bGF0ZWRWaXJ0dWFscy5oYXNPd25Qcm9wZXJ0eSh0aGlzLnBhdGgpKSB7XG4gICAgdmFsdWUgPSBkb2MuJCRwb3B1bGF0ZWRWaXJ0dWFsc1t0aGlzLnBhdGhdO1xuICB9XG5cbiAgbGV0IHYgPSB2YWx1ZTtcbiAgZm9yIChjb25zdCBnZXR0ZXIgb2YgdGhpcy5nZXR0ZXJzKSB7XG4gICAgdiA9IGdldHRlci5jYWxsKGRvYywgdiwgdGhpcywgZG9jKTtcbiAgfVxuICByZXR1cm4gdjtcbn07XG5cbi8qKlxuICogQXBwbGllcyBzZXR0ZXJzIHRvIGB2YWx1ZWAuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbHVlXG4gKiBAcGFyYW0ge0RvY3VtZW50fSBkb2NcbiAqIEByZXR1cm4ge0FueX0gdGhlIHZhbHVlIGFmdGVyIGFwcGx5aW5nIGFsbCBzZXR0ZXJzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblZpcnR1YWxUeXBlLnByb3RvdHlwZS5hcHBseVNldHRlcnMgPSBmdW5jdGlvbih2YWx1ZSwgZG9jKSB7XG4gIGxldCB2ID0gdmFsdWU7XG4gIGZvciAoY29uc3Qgc2V0dGVyIG9mIHRoaXMuc2V0dGVycykge1xuICAgIHYgPSBzZXR0ZXIuY2FsbChkb2MsIHYsIHRoaXMsIGRvYyk7XG4gIH1cbiAgcmV0dXJuIHY7XG59O1xuXG4vKiFcbiAqIGV4cG9ydHNcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IFZpcnR1YWxUeXBlO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../server/node_modules/mongoose/lib/virtualType.js\n");

/***/ }),

/***/ "../server/node_modules/mongoose/node_modules/ms/index.js":
/*!****************************************************************!*\
  !*** ../server/node_modules/mongoose/node_modules/ms/index.js ***!
  \****************************************************************/
/***/ ((module) => {

eval("/**\n * Helpers.\n */\n\nvar s = 1000;\nvar m = s * 60;\nvar h = m * 60;\nvar d = h * 24;\nvar w = d * 7;\nvar y = d * 365.25;\n\n/**\n * Parse or format the given `val`.\n *\n * Options:\n *\n *  - `long` verbose formatting [false]\n *\n * @param {String|Number} val\n * @param {Object} [options]\n * @throws {Error} throw an error if val is not a non-empty string or a number\n * @return {String|Number}\n * @api public\n */\n\nmodule.exports = function (val, options) {\n  options = options || {};\n  var type = typeof val;\n  if (type === 'string' && val.length > 0) {\n    return parse(val);\n  } else if (type === 'number' && isFinite(val)) {\n    return options.long ? fmtLong(val) : fmtShort(val);\n  }\n  throw new Error(\n    'val is not a non-empty string or a valid number. val=' +\n      JSON.stringify(val)\n  );\n};\n\n/**\n * Parse the given `str` and return milliseconds.\n *\n * @param {String} str\n * @return {Number}\n * @api private\n */\n\nfunction parse(str) {\n  str = String(str);\n  if (str.length > 100) {\n    return;\n  }\n  var match = /^(-?(?:\\d+)?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(\n    str\n  );\n  if (!match) {\n    return;\n  }\n  var n = parseFloat(match[1]);\n  var type = (match[2] || 'ms').toLowerCase();\n  switch (type) {\n    case 'years':\n    case 'year':\n    case 'yrs':\n    case 'yr':\n    case 'y':\n      return n * y;\n    case 'weeks':\n    case 'week':\n    case 'w':\n      return n * w;\n    case 'days':\n    case 'day':\n    case 'd':\n      return n * d;\n    case 'hours':\n    case 'hour':\n    case 'hrs':\n    case 'hr':\n    case 'h':\n      return n * h;\n    case 'minutes':\n    case 'minute':\n    case 'mins':\n    case 'min':\n    case 'm':\n      return n * m;\n    case 'seconds':\n    case 'second':\n    case 'secs':\n    case 'sec':\n    case 's':\n      return n * s;\n    case 'milliseconds':\n    case 'millisecond':\n    case 'msecs':\n    case 'msec':\n    case 'ms':\n      return n;\n    default:\n      return undefined;\n  }\n}\n\n/**\n * Short format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtShort(ms) {\n  var msAbs = Math.abs(ms);\n  if (msAbs >= d) {\n    return Math.round(ms / d) + 'd';\n  }\n  if (msAbs >= h) {\n    return Math.round(ms / h) + 'h';\n  }\n  if (msAbs >= m) {\n    return Math.round(ms / m) + 'm';\n  }\n  if (msAbs >= s) {\n    return Math.round(ms / s) + 's';\n  }\n  return ms + 'ms';\n}\n\n/**\n * Long format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtLong(ms) {\n  var msAbs = Math.abs(ms);\n  if (msAbs >= d) {\n    return plural(ms, msAbs, d, 'day');\n  }\n  if (msAbs >= h) {\n    return plural(ms, msAbs, h, 'hour');\n  }\n  if (msAbs >= m) {\n    return plural(ms, msAbs, m, 'minute');\n  }\n  if (msAbs >= s) {\n    return plural(ms, msAbs, s, 'second');\n  }\n  return ms + ' ms';\n}\n\n/**\n * Pluralization helper.\n */\n\nfunction plural(ms, msAbs, n, name) {\n  var isPlural = msAbs >= n * 1.5;\n  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9ub2RlX21vZHVsZXMvbXMvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsZUFBZTtBQUMxQixXQUFXLFFBQVE7QUFDbkIsWUFBWSxPQUFPO0FBQ25CLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbGllbnQvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9ub2RlX21vZHVsZXMvbXMvaW5kZXguanM/ZTZiMSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEhlbHBlcnMuXG4gKi9cblxudmFyIHMgPSAxMDAwO1xudmFyIG0gPSBzICogNjA7XG52YXIgaCA9IG0gKiA2MDtcbnZhciBkID0gaCAqIDI0O1xudmFyIHcgPSBkICogNztcbnZhciB5ID0gZCAqIDM2NS4yNTtcblxuLyoqXG4gKiBQYXJzZSBvciBmb3JtYXQgdGhlIGdpdmVuIGB2YWxgLlxuICpcbiAqIE9wdGlvbnM6XG4gKlxuICogIC0gYGxvbmdgIHZlcmJvc2UgZm9ybWF0dGluZyBbZmFsc2VdXG4gKlxuICogQHBhcmFtIHtTdHJpbmd8TnVtYmVyfSB2YWxcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEB0aHJvd3Mge0Vycm9yfSB0aHJvdyBhbiBlcnJvciBpZiB2YWwgaXMgbm90IGEgbm9uLWVtcHR5IHN0cmluZyBvciBhIG51bWJlclxuICogQHJldHVybiB7U3RyaW5nfE51bWJlcn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAodmFsLCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWw7XG4gIGlmICh0eXBlID09PSAnc3RyaW5nJyAmJiB2YWwubGVuZ3RoID4gMCkge1xuICAgIHJldHVybiBwYXJzZSh2YWwpO1xuICB9IGVsc2UgaWYgKHR5cGUgPT09ICdudW1iZXInICYmIGlzRmluaXRlKHZhbCkpIHtcbiAgICByZXR1cm4gb3B0aW9ucy5sb25nID8gZm10TG9uZyh2YWwpIDogZm10U2hvcnQodmFsKTtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgJ3ZhbCBpcyBub3QgYSBub24tZW1wdHkgc3RyaW5nIG9yIGEgdmFsaWQgbnVtYmVyLiB2YWw9JyArXG4gICAgICBKU09OLnN0cmluZ2lmeSh2YWwpXG4gICk7XG59O1xuXG4vKipcbiAqIFBhcnNlIHRoZSBnaXZlbiBgc3RyYCBhbmQgcmV0dXJuIG1pbGxpc2Vjb25kcy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBwYXJzZShzdHIpIHtcbiAgc3RyID0gU3RyaW5nKHN0cik7XG4gIGlmIChzdHIubGVuZ3RoID4gMTAwKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBtYXRjaCA9IC9eKC0/KD86XFxkKyk/XFwuP1xcZCspICoobWlsbGlzZWNvbmRzP3xtc2Vjcz98bXN8c2Vjb25kcz98c2Vjcz98c3xtaW51dGVzP3xtaW5zP3xtfGhvdXJzP3xocnM/fGh8ZGF5cz98ZHx3ZWVrcz98d3x5ZWFycz98eXJzP3x5KT8kL2kuZXhlYyhcbiAgICBzdHJcbiAgKTtcbiAgaWYgKCFtYXRjaCkge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgbiA9IHBhcnNlRmxvYXQobWF0Y2hbMV0pO1xuICB2YXIgdHlwZSA9IChtYXRjaFsyXSB8fCAnbXMnKS50b0xvd2VyQ2FzZSgpO1xuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlICd5ZWFycyc6XG4gICAgY2FzZSAneWVhcic6XG4gICAgY2FzZSAneXJzJzpcbiAgICBjYXNlICd5cic6XG4gICAgY2FzZSAneSc6XG4gICAgICByZXR1cm4gbiAqIHk7XG4gICAgY2FzZSAnd2Vla3MnOlxuICAgIGNhc2UgJ3dlZWsnOlxuICAgIGNhc2UgJ3cnOlxuICAgICAgcmV0dXJuIG4gKiB3O1xuICAgIGNhc2UgJ2RheXMnOlxuICAgIGNhc2UgJ2RheSc6XG4gICAgY2FzZSAnZCc6XG4gICAgICByZXR1cm4gbiAqIGQ7XG4gICAgY2FzZSAnaG91cnMnOlxuICAgIGNhc2UgJ2hvdXInOlxuICAgIGNhc2UgJ2hycyc6XG4gICAgY2FzZSAnaHInOlxuICAgIGNhc2UgJ2gnOlxuICAgICAgcmV0dXJuIG4gKiBoO1xuICAgIGNhc2UgJ21pbnV0ZXMnOlxuICAgIGNhc2UgJ21pbnV0ZSc6XG4gICAgY2FzZSAnbWlucyc6XG4gICAgY2FzZSAnbWluJzpcbiAgICBjYXNlICdtJzpcbiAgICAgIHJldHVybiBuICogbTtcbiAgICBjYXNlICdzZWNvbmRzJzpcbiAgICBjYXNlICdzZWNvbmQnOlxuICAgIGNhc2UgJ3NlY3MnOlxuICAgIGNhc2UgJ3NlYyc6XG4gICAgY2FzZSAncyc6XG4gICAgICByZXR1cm4gbiAqIHM7XG4gICAgY2FzZSAnbWlsbGlzZWNvbmRzJzpcbiAgICBjYXNlICdtaWxsaXNlY29uZCc6XG4gICAgY2FzZSAnbXNlY3MnOlxuICAgIGNhc2UgJ21zZWMnOlxuICAgIGNhc2UgJ21zJzpcbiAgICAgIHJldHVybiBuO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG59XG5cbi8qKlxuICogU2hvcnQgZm9ybWF0IGZvciBgbXNgLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBtc1xuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gZm10U2hvcnQobXMpIHtcbiAgdmFyIG1zQWJzID0gTWF0aC5hYnMobXMpO1xuICBpZiAobXNBYnMgPj0gZCkge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gZCkgKyAnZCc7XG4gIH1cbiAgaWYgKG1zQWJzID49IGgpIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIGgpICsgJ2gnO1xuICB9XG4gIGlmIChtc0FicyA+PSBtKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBtKSArICdtJztcbiAgfVxuICBpZiAobXNBYnMgPj0gcykge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gcykgKyAncyc7XG4gIH1cbiAgcmV0dXJuIG1zICsgJ21zJztcbn1cblxuLyoqXG4gKiBMb25nIGZvcm1hdCBmb3IgYG1zYC5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gbXNcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGZtdExvbmcobXMpIHtcbiAgdmFyIG1zQWJzID0gTWF0aC5hYnMobXMpO1xuICBpZiAobXNBYnMgPj0gZCkge1xuICAgIHJldHVybiBwbHVyYWwobXMsIG1zQWJzLCBkLCAnZGF5Jyk7XG4gIH1cbiAgaWYgKG1zQWJzID49IGgpIHtcbiAgICByZXR1cm4gcGx1cmFsKG1zLCBtc0FicywgaCwgJ2hvdXInKTtcbiAgfVxuICBpZiAobXNBYnMgPj0gbSkge1xuICAgIHJldHVybiBwbHVyYWwobXMsIG1zQWJzLCBtLCAnbWludXRlJyk7XG4gIH1cbiAgaWYgKG1zQWJzID49IHMpIHtcbiAgICByZXR1cm4gcGx1cmFsKG1zLCBtc0FicywgcywgJ3NlY29uZCcpO1xuICB9XG4gIHJldHVybiBtcyArICcgbXMnO1xufVxuXG4vKipcbiAqIFBsdXJhbGl6YXRpb24gaGVscGVyLlxuICovXG5cbmZ1bmN0aW9uIHBsdXJhbChtcywgbXNBYnMsIG4sIG5hbWUpIHtcbiAgdmFyIGlzUGx1cmFsID0gbXNBYnMgPj0gbiAqIDEuNTtcbiAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBuKSArICcgJyArIG5hbWUgKyAoaXNQbHVyYWwgPyAncycgOiAnJyk7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../server/node_modules/mongoose/node_modules/ms/index.js\n");

/***/ }),

/***/ "../server/node_modules/mongoose/package.json":
/*!****************************************************!*\
  !*** ../server/node_modules/mongoose/package.json ***!
  \****************************************************/
/***/ ((module) => {

"use strict";
module.exports = /*#__PURE__*/JSON.parse('{"name":"mongoose","description":"Mongoose MongoDB ODM","version":"8.2.0","author":"Guillermo Rauch <guillermo@learnboost.com>","keywords":["mongodb","document","model","schema","database","odm","data","datastore","query","nosql","orm","db"],"license":"MIT","dependencies":{"bson":"^6.2.0","kareem":"2.5.1","mongodb":"6.3.0","mpath":"0.9.0","mquery":"5.0.0","ms":"2.1.3","sift":"16.0.1"},"devDependencies":{"@babel/core":"7.23.9","@babel/preset-env":"7.23.9","@typescript-eslint/eslint-plugin":"^6.2.1","@typescript-eslint/parser":"^6.2.1","acquit":"1.3.0","acquit-ignore":"0.2.1","acquit-require":"0.1.1","assert-browserify":"2.0.0","axios":"1.1.3","babel-loader":"8.2.5","benchmark":"2.1.4","broken-link-checker":"^0.7.8","buffer":"^5.6.0","cheerio":"1.0.0-rc.12","crypto-browserify":"3.12.0","dotenv":"16.4.1","dox":"1.0.0","eslint":"8.56.0","eslint-plugin-markdown":"^3.0.1","eslint-plugin-mocha-no-only":"1.1.1","express":"^4.18.1","fs-extra":"~11.2.0","highlight.js":"11.8.0","lodash.isequal":"4.5.0","lodash.isequalwith":"4.4.0","markdownlint-cli2":"^0.12.1","marked":"4.3.0","mkdirp":"^3.0.1","mocha":"10.2.0","moment":"2.x","mongodb-memory-server":"8.15.1","ncp":"^2.0.0","nyc":"15.1.0","pug":"3.0.2","q":"1.5.1","sinon":"17.0.1","stream-browserify":"3.0.0","tsd":"0.30.4","typescript":"5.3.3","uuid":"9.0.1","webpack":"5.90.1"},"directories":{"lib":"./lib/mongoose"},"scripts":{"docs:clean":"npm run docs:clean:stable","docs:clean:stable":"rimraf index.html && rimraf -rf ./docs/*.html  && rimraf -rf ./docs/api && rimraf -rf ./docs/tutorials/*.html && rimraf -rf ./docs/typescript/*.html && rimraf -rf ./docs/*.html && rimraf -rf ./docs/source/_docs && rimraf -rf ./tmp","docs:clean:5x":"rimraf index.html && rimraf -rf ./docs/5.x && rimraf -rf ./docs/source/_docs && rimraf -rf ./tmp","docs:clean:6x":"rimraf index.html && rimraf -rf ./docs/6.x && rimraf -rf ./docs/source/_docs && rimraf -rf ./tmp","docs:copy:tmp":"mkdirp ./tmp/docs/css && mkdirp ./tmp/docs/js && mkdirp ./tmp/docs/images && mkdirp ./tmp/docs/tutorials && mkdirp ./tmp/docs/typescript && mkdirp ./tmp/docs/api && ncp ./docs/css ./tmp/docs/css --filter=.css$ && ncp ./docs/js ./tmp/docs/js --filter=.js$ && ncp ./docs/images ./tmp/docs/images && ncp ./docs/tutorials ./tmp/docs/tutorials && ncp ./docs/typescript ./tmp/docs/typescript && ncp ./docs/api ./tmp/docs/api && cp index.html ./tmp && cp docs/*.html ./tmp/docs/","docs:copy:tmp:5x":"rimraf ./docs/5.x && ncp ./tmp ./docs/5.x","docs:move:6x:tmp":"mv ./docs/6.x ./tmp","docs:copy:tmp:6x":"rimraf ./docs/6.x && ncp ./tmp ./docs/6.x","docs:checkout:gh-pages":"git checkout gh-pages","docs:checkout:5x":"git checkout 5.x","docs:checkout:6x":"git checkout 6.x","docs:generate":"node ./scripts/website.js","docs:generate:search":"node ./scripts/generateSearch.js","docs:generate:sponsorData":"node ./scripts/loadSponsorData.js","docs:merge:stable":"git merge master","docs:merge:5x":"git merge 5.x","docs:merge:6x":"git merge 6.x","docs:test":"npm run docs:generate && npm run docs:generate:search","docs:view":"node ./scripts/static.js","docs:prepare:publish:stable":"npm run docs:checkout:gh-pages && npm run docs:merge:stable && npm run docs:generate && npm run docs:generate:search","docs:prepare:publish:5x":"npm run docs:checkout:5x && npm run docs:merge:5x && npm run docs:clean:stable && npm run docs:generate && npm run docs:copy:tmp && npm run docs:checkout:gh-pages && npm run docs:copy:tmp:5x","docs:prepare:publish:6x":"npm run docs:checkout:6x && npm run docs:merge:6x && npm run docs:clean:stable && env DOCS_DEPLOY=true npm run docs:generate && npm run docs:move:6x:tmp && npm run docs:checkout:gh-pages && npm run docs:copy:tmp:6x","docs:prepare:publish:7x":"env DOCS_DEPLOY=true npm run docs:generate && npm run docs:checkout:gh-pages && rimraf ./docs/7.x && mv ./tmp ./docs/7.x","docs:check-links":"blc http://127.0.0.1:8089 -ro","lint":"eslint .","lint-js":"eslint . --ext .js --ext .cjs","lint-ts":"eslint . --ext .ts","lint-md":"markdownlint-cli2 \\"**/*.md\\"","build-browser":"(rm ./dist/* || true) && node ./scripts/build-browser.js","prepublishOnly":"npm run build-browser","release":"git pull && git push origin master --tags && npm publish","release-5x":"git pull origin 5.x && git push origin 5.x && git push origin 5.x --tags && npm publish --tag 5x","release-6x":"git pull origin 6.x && git push origin 6.x && git push origin 6.x --tags && npm publish --tag 6x","mongo":"node ./tools/repl.js","publish-7x":"npm publish --tag 7x","test":"mocha --exit ./test/*.test.js","test-deno":"deno run --allow-env --allow-read --allow-net --allow-run --allow-sys --allow-write ./test/deno.js","test-rs":"START_REPLICA_SET=1 mocha --timeout 30000 --exit ./test/*.test.js","test-tsd":"node ./test/types/check-types-filename && tsd","tdd":"mocha ./test/*.test.js --inspect --watch --recursive --watch-files ./**/*.{js,ts}","test-coverage":"nyc --reporter=html --reporter=text npm test","ts-benchmark":"cd ./benchmarks/typescript/simple && npm install && npm run benchmark | node ../../../scripts/tsc-diagnostics-check"},"main":"./index.js","types":"./types/index.d.ts","engines":{"node":">=16.20.1"},"bugs":{"url":"https://github.com/Automattic/mongoose/issues/new"},"repository":{"type":"git","url":"git://github.com/Automattic/mongoose.git"},"homepage":"https://mongoosejs.com","browser":"./dist/browser.umd.js","config":{"mongodbMemoryServer":{"disablePostinstall":true}},"funding":{"type":"opencollective","url":"https://opencollective.com/mongoose"},"tsd":{"directory":"test/types","compilerOptions":{"esModuleInterop":false,"strict":true,"allowSyntheticDefaultImports":true,"strictPropertyInitialization":false,"noImplicitAny":false,"strictNullChecks":true,"module":"commonjs","target":"ES2017"}}}');

/***/ })

};
;